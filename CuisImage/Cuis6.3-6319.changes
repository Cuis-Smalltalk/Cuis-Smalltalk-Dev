'From Cuis6.2 [latest update: #6156] on 29 December 2023 at 3:17:47 pm'!


----SNAPSHOT----(29 December 2023 15:17:47) Cuis6.2.image priorSource: 0!

----QUIT----(29 December 2023 15:18:07) Cuis6.3-6156.image priorSource: 73!

----STARTUP---- (29 December 2023 15:18:34) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.3-6156.image!


----QUIT----(29 December 2023 15:18:42) Cuis6.3-6156.image priorSource: 148!

----STARTUP---- (29 December 2023 15:36:13) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.3-6156.image!


SourceFileVersionString!

SourceFileVersionString := 'Cuis6.3' .!

SourceFileVersionString!

----QUIT----(29 December 2023 15:37:03) Cuis6.3-6156.image priorSource: 351!

----STARTUP---- (30 January 2024 19:37:07) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.3-6156.image!


'From Cuis6.3 [latest update: #6156] on 1 January 2024 at 4:07:00 pm'!
!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 1/1/2024 16:04:37' prior: 16970156!
    copyright
	"The Cuis Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak project. 1997-2024.
Copyright (c) Contributors to Cuis Smalltalk project. 2009-2024.'.! !
!Utilities class methodsFor: 'default desktop' stamp: 'jmv 1/1/2024 16:04:51' prior: 16996178!
 defaultTextEditorContents
	^ ('
', 
('Cuis Smalltalk

' centered blue pointSize: FontFamily defaultPointSize * 3),
('
"Yay, Juan.  You GO, guy!! ...a great example of malleable software (and a clever mind) at work."
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('Dan Ingalls
' italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('
"I like it... It''s nice and clean and simple and pretty. Nice stuff!!"
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('Alan Kay
' italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('
"I think you have a very elegant design aesthetic."
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('John Maloney
'italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
'

',
'Cuis is a modern, Open Source, multiplatform, Smalltalk-80 system.


',
'Cuis is:

' bold,
'    - Small
    - Clean
    - Appropriable
' blue,
'

Additionally, Cuis is:

' bold, 
'    - Open Source
    - Multiplatform
' blue,
'
 
Like other Smalltalk systems, Cuis is also:

' bold, 
'    - A complete development environment written in itself
    - A pure, dynamic Object Oriented language
' blue,
'

Cuis assumes very little on the underlying platform, and this lets it run out-of-the-box on Windows, MacOS, Linux, ChromeOS and WebBrowsers. Cuis shares the [OpenSmalltalk Virtual Machine] (http://www.opensmalltalk.org) with Squeak, Pharo and Newspeak.

What sets Cuis apart from the other members of the Squeak family is the focus on Smalltalk-80 and an active attitude towards system complexity:

Unbound complexity growth, together with development strategies focused only in the short term, are the worst long term enemies of all software systems. As systems grow older, they usually become more complex. New features are added as layers on top of whatever is below, sometimes without really understanding it, and almost always without modifying it. Complexity and size grow without control. Evolution slows down. Understanding the system becomes harder every day. Bugs are harder to fix. Codebases become huge for no clear reason. At some point, the system can''t evolve anymore and becomes "legacy code".

Complexity puts a limit to the level of understanding of the system a person might reach, and therefore limits the things that can be done with it. Dan Ingalls says all this in ["Design Principles Behind Smalltalk"] (http://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html). Even if you have already done so, please go and read it again!!

Cuis Smalltalk is our attempt at this challenge. Furthermore, we believe we are doing something else that no other Smalltalk, commercial or open source, does. We attempt to give the true Smalltalk-80 experience, and keep Smalltalk-80 not as legacy software of historic significance, but as a live, evolving system. We feel we are the keepers of the Smalltalk-80 heritage, and enablers of the Dynabook experience.

As Cuis evolves, we keep on these values. Every update, be it a bug fix or a feature enhancement, is reviewed carefully to avoid adding unneeded complexity to the system. Every opportunity to remove unneeded complexity is followed. As we go, features are enhanced, and any reported bugs fixed. We also adopt selected enhancements from Squeak and Pharo, and share our work with the wider Smalltalk community.


' justified,
'License
' bold,
'
Cuis is distributed subject to the MIT License, as in http://www.opensource.org/licenses/mit-license.php . Any contribution submitted for incorporation into or for distribution with Cuis shall be presumed subject to the same license.

Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982
Copyright (c) Apple Computer, Inc. 1985-1996
Copyright (c) Contributors to Squeak project. 1997-2024
Copyright (c) Contributors to Cuis Smalltalk project. 2009-2024')! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6157-UpdateCopyrightNotice-JuanVuletich-2024Jan01-16h04m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6157] on 2 January 2024 at 7:01:13 am'!
!Float methodsFor: 'mathematical functions' stamp: 'jmv 1/2/2024 06:50:37' prior: 16864523!
         arcTanNonPrimitive
	"Answer the angle in radians."

	| theta delta sinTheta cosTheta minPossibleDelta |

	"Newton-Raphson"
	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].

	"first guess"
	theta := (self * Halfpi) / (self + 1.0).

	"iterate"
	[
		sinTheta := theta sin.
		cosTheta := theta cos.
		delta := (sinTheta * cosTheta) - (self * cosTheta * cosTheta).
		minPossibleDelta := theta ulp.
		delta abs >= minPossibleDelta ]
		whileTrue: [
			theta := theta - delta.
			"There is a risk of not converging if #sin and #cos are not good enough.
			Still, there's no point in trying to further reduce delta, meaning we won't find
			a better approximation of the result."
			delta abs = minPossibleDelta ifTrue: [
				^theta ]].
	^ theta! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6158-arcTanNonPrimitive-fix-JuanVuletich-2024Jan02-06h48m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6156] on 30 December 2023 at 4:51:21 pm'!
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 12/30/2023 16:45:54'!
  disableUsePrefsFile
	Preferences name: #useUserPrefsFile category: #system value: false.! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 12/30/2023 16:45:36'!
                             enableUsePrefsFile
	Preferences name: #useUserPrefsFile category: #system value: true.
	PreferenceSet saveUserPrefs.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 12/30/2023 16:39:59' prior: 16966160!
    readAndApplyUserPrefs
	"
	Smalltalk readAndApplyUserPrefs
	"
	(Preferences at: #useUserPrefsFile) ifTrue: [
		PreferenceSet readAndApplyUserPrefs ].! !
!Preference methodsFor: 'accessing' stamp: 'jmv 12/30/2023 16:40:36' prior: 16928262!
                  isSavedToDisk: aBoolean
	"True if this preference was modified by the user, or read from disk.
	If so, keep the User Preferences file updated."

	isSavedToDisk := aBoolean.
	isSavedToDisk ifTrue: [
		(Preferences at: #useUserPrefsFile) ifTrue: [
			PreferenceSet saveUserPrefs ]].! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 12/30/2023 16:43:01' prior: 16928706!
      prefSystem
	^ #( #(allowNonLocalReturnsInExceptionHandlers true )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges true )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #roots #(root image vm current) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(useUserPrefsFile true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
	)! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 12/30/2023 16:50:57' prior: 16984359!
                              preferencesMenuOptions

	^`{
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Focus follows Mouse'.
				#selector 			-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Focus when Click'.
				#selector 			-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.

			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Show ST-80 assignments'.
				#selector 			-> 		#enableShowAssignmentAsLeftArrow.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Show ANSI assignments'.
				#selector 			-> 		#disableShowAssignmentAsLeftArrow.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		40.
				#label 			-> 		'Size of GUI elements...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		50.
				#label			->		'Set System Font...'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#promptUserAndSetDefault.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'change the current system font family.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		60.
				#label			->		'Load all TrueType Fonts'.
				#object 			-> 		TrueTypeFontFamily.
				#selector 			-> 		#readAdditionalFonts.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load additional TrueType fonts included with Cuis.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		70.
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		80.
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'Full screen on'.
				#selector 			-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		20.
				#label 			-> 		'Full screen off'.
				#selector 			-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.




			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		10.
				#label 			-> 		'Save Prefs in UserPrefs.txt'.
				#selector 			-> 		#enableUsePrefsFile.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Preferences are saved without need to save the Smalltalk Image.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		20.
				#label 			-> 		'Save Prefs in the Image'.
				#selector 			-> 		#disableUsePrefsFile.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Preferences are lost unless the Smalltalk Image is saved.'
			} asDictionary.





			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		30.
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 			-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		40.
				#label 			-> 		'All preferences...'.
				#object 			-> 		PreferenceSet.
				#selector 			-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}`.! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 12/30/2023 16:51:05' prior: 16984867!
                 worldMenuOptions

	^`
		TheWorldMenu worldMainMenuOptions,
		TheWorldMenu additionalMenuOptions,
		TheWorldMenu preferencesMenuOptions,
		TheWorldMenu windowsMenuOptions,
		TheWorldMenu helpMenuOptions,
		TheWorldMenu changesMenuOptions,
		TheWorldMenu debugMenuOptions`.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Preferences name: #useUserPrefsFile category: #system value: true.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6159-Preference-useUserPrefsFile-JuanVuletich-2023Dec30-16h39m-jmv.002.cs.st----!

'From Cuis6.3 [latest update: #6159] on 2 January 2024 at 12:23:13 pm'!
!FontFamily class methodsFor: 'ui' stamp: 'jmv 1/2/2024 12:08:06'!
                            promptUser: currentNameOrNil includeNonASCII: showFontsNotIncludingASCIICharacters
	"
	FontFamily promptUser
	FontFamily promptUser: FontFamily defaultFamilyName
	"
	"Present a menu of available fonts, and if one is chosen, return it.
	Otherwise return nil."

	| menu answer |
	menu := MenuMorph entitled: 'Fonts'.
	menu defaultTarget: menu.
	menu addTitle: 'Installed Fonts'.
	FontFamily familyNames do: [ :fontName | | fontFamily item |
		fontFamily := FontFamily familyNamed: fontName.
		(fontFamily includesAscii or: [showFontsNotIncludingASCIICharacters]) ifTrue: [
			item := menu
				add: (fontName = currentNameOrNil) asMenuItemTextPrefix, fontName
				target: menu
				action: #modalSelection:
				argument: {#fontName. fontName}.
			fontFamily includesAscii ifTrue: [
				item fontFamily: fontFamily ]]].

	menu addTitle: 'Available to install '.
	(DirectoryEntry trueTypeFontsDirectory
		directories sorted: [ :a :b | a name < b name ]) do: [ :dir | | subDirs |
			subDirs := dir directories sorted: [ :a :b | a name < b name ].
			subDirs isEmpty
				ifTrue: [
					self addFontDir: dir to: menu current: currentNameOrNil ]
				ifFalse: [ | submenu anyAdded |
					submenu := MenuMorph new defaultTarget: menu.
					anyAdded := false.
					subDirs do: [ :subdir |
						anyAdded := anyAdded | (self addFontDir: subdir to: submenu current: currentNameOrNil) ].
					anyAdded ifTrue: [
						menu add: dir name, '... ' subMenu: submenu ]]].
	menu lastSubmorph class == MenuLineMorph ifTrue: [
		3 timesRepeat: [menu lastSubmorph delete ]].

	answer := menu invokeModal.
	answer ifNil: [ ^nil ].
	answer first = #fontDirectory
		ifTrue: [ TrueTypeFontFamily readAllTrueTypeFontsIn: answer third ].
	^FontFamily familyNamed: answer second! !
!LabelMorph methodsFor: 'printing' stamp: 'jmv 1/2/2024 12:00:47'!
       fontFamily: aFontFamily
	"Set the font my text will use. The emphasis remains unchanged."

	font := aFontFamily atPointSize: (font ifNotNil: [ font pointSize ] ifNil: [ FontFamily defaultPointSize ]).
	self font: font emphasis: emphasis! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 1/2/2024 12:09:05' prior: 16867358!
                             promptUser
	"Present a menu of font families, answer selection.
	FontFamily promptUser
	"
	^self promptUser: FontFamily defaultFamilyName includeNonASCII: true! !
!FontFamily class methodsFor: 'ui' stamp: 'KLG 1/2/2024 12:08:48' prior: 16867365!
          promptUser: currentNameOrNil
	"
	FontFamily promptUser
	FontFamily promptUser: FontFamily defaultFamilyName
	"
	"Present a menu of available fonts, and if one is chosen, return it.
	Otherwise return nil."

	^self promptUser: currentNameOrNil includeNonASCII: true! !
!FontFamily class methodsFor: 'ui' stamp: 'KLG 1/2/2024 12:15:27' prior: 16867415!
  promptUserAlt
	"Present a menu of font families, answer selection.
	Alternative implementation: Show only installed fonts.
	FontFamily promptUserAlt
	"
	| fontMenu priorFontFamily |
	priorFontFamily := FontFamily defaultFamilyName.
	fontMenu := MenuMorph entitled: 'Installed Fonts'.
	FontFamily familyNames do: [ :fontName | | fontFamily item |
		item := fontMenu
			add: (priorFontFamily sameAs: fontName) asMenuItemTextPrefix, fontName
			target: fontMenu
			action: #modalSelection:
			argument: fontName.
		fontFamily := FontFamily familyNamed: fontName.
		fontFamily includesAscii ifTrue: [
			item fontFamily: fontFamily ]].
	^FontFamily familyNamed: fontMenu invokeModal.! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 1/2/2024 12:10:17' prior: 16867434!
  promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	(self promptUser: FontFamily defaultFamilyName includeNonASCII: false) ifNotNil: [ :fontFamily |
		fontFamily includesAscii
			ifTrue: [PreferenceSet setDefaultFont: fontFamily familyName ]
			ifFalse: [self inform: 'Selected font does not include ASCII characters. Can not be set as default.' ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6160-NicerFontFamilyUI-GeraldKlix-2024Jan02-12h18m-KLG.001.cs.st----!

'From Cuis6.3 [latest update: #6160] on 2 January 2024 at 1:56:32 pm'!
!FontFamily class methodsFor: 'ui' stamp: 'KLG 1/2/2024 13:54:22' prior: 16867449!
         promptUserForSize: currentSize fontFamily: fontFamily
	| menu |
	menu := MenuMorph entitled: 'Font Sizes'.
	menu defaultTarget: menu.
	fontFamily pointSizes do: [ :pt | | itemText sizeToUse |
		itemText := pt printString.
		sizeToUse := pt.
		menu
			add: (pt = currentSize) asMenuItemTextPrefix, itemText
			action: #modalSelection:
			argument: pt ::
				font: (fontFamily atPointSize: sizeToUse) ].
	^ menu invokeModal! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6161-FontSizeMenu-showActualSizes-GeraldKlix-2024Jan02-13h53m-KLG.001.cs.st----!

'From Cuis6.3 [latest update: #6161] on 2 January 2024 at 2:47:39 pm'!
!MenuItemMorph methodsFor: 'font' stamp: 'jmv 1/2/2024 14:37:54' overrides: 16888617!
                font: aFont emphasis: emphasisCode

	super font: aFont emphasis: emphasisCode.
	contentString ifNotNil: [
		self contentsWithMarkers: contentString inverse: false ].! !
!LabelMorph methodsFor: 'font' stamp: 'jmv 1/2/2024 14:40:03' prior: 16888653!
        emphasis: aNumber
	"Set the receiver's emphasis as indicated. aNumber is a bitmask with the following format:

	bit	attribute
	1	bold
	2	italic
	4	underlined
	8	struckThrough
	16	withUnderscoreGlyphs
	"

	"examples: 0 -> plain.  
	1 -> bold.  2 -> italic.  3 -> bold italic.  4 -> underlined  
	5 -> bold underlined.  6 -> italic underlined.   7 -> bold italic underlined   
	etc...

	Prefer AbstractFont method category: 'derivatives - emphasis' 
	to raw numbers:
	    self emphasis: AbstractFont boldItalic.
	etc."

	self font: font emphasis: aNumber.! !
!LabelMorph methodsFor: 'font' stamp: 'jmv 1/2/2024 14:39:45' prior: 16888738!
    font: aFont
	"Set the font my text will use. The emphasis remains unchanged."

	self font: aFont emphasis: emphasis.! !
!LabelMorph methodsFor: 'font' stamp: 'jmv 1/2/2024 14:41:15' prior: 50332200!
                         fontFamily: aFontFamily
	"Set the font my text will use. The emphasis remains unchanged."

	self
		font: (aFontFamily atPointSize: (font
			ifNotNil: [ font pointSize ]
			ifNil: [ FontFamily defaultPointSize ]))
		emphasis: emphasis.! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 1/2/2024 14:46:12' prior: 16893138!
                           contentsWithMarkers: aString inverse: invertMarkers
	"Set the menu item entry. Parse aString for embedded markers."

	| markerIndex marker |
	contentString := nil.	"get rid of old"
	self removeAllMorphs.	"get rid of old markers if updating"
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	contentString := aString.	"remember actual string"
	marker := ((marker = '<on>' or: [marker = '<yes>']) xor: invertMarkers)
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents: (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: 1@(self morphHeight +1- marker morphHeight // 2).
	marker lock.! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 1/2/2024 14:43:33' prior: 16893497!
          offImage
	"Return the form to be used for indicating an '<off>' marker"
	| e ps1 ps2 |
	ps1 := self fontToUse pointSize.
	ps2 := FontFamily defaultPointSize.
	e := (ps1 < ps2 ifTrue: [ ps1+ ps2 // 2 ] ifFalse: [ ps1 * 2 + (ps2 * 6) // 8 ]) asPoint.
	(OffImage isNil or: [ OffImage extent ~= e ]) ifTrue: [
		OffImage := Form extent: e depth: 32.
		OffImage getCanvas
			frameAndFillRectangle: OffImage boundingBox fillColor: `(Color gray: 0.9)`
				borderWidth: 2 borderColor: `Color black` ].
	^OffImage! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 1/2/2024 14:43:41' prior: 16893512!
               onImage
	"Return the form to be used for indicating an '<on>' marker"
	| e ps1 ps2 |
	ps1 := self fontToUse pointSize.
	ps2 := FontFamily defaultPointSize.
	e := (ps1 < ps2 ifTrue: [ ps1+ ps2 // 2 ] ifFalse: [ ps1 * 2 + (ps2 * 6) // 8 ]) asPoint.
	(OnImage isNil or: [ OnImage extent ~= e ]) ifTrue: [
		OnImage := Form extent: e depth: 32.
		OnImage getCanvas
			frameAndFillRectangle: OnImage boundingBox fillColor: `Color gray: 0.9`
				borderWidth: 2 borderColor: `Color black`;
			fillRectangle: (OnImage boundingBox insetBy: 3) color: `Color black` ].
	^OnImage! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6162-MenuTweaks-JuanVuletich-2024Jan02-14h37m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6162] on 2 January 2024 at 3:30:44 pm'!
!FontFamily class methodsFor: 'ui' stamp: 'jmv 1/2/2024 15:29:52' prior: 50332143!
                 promptUser: currentNameOrNil includeNonASCII: showFontsNotIncludingASCIICharacters
	"
	FontFamily promptUser
	FontFamily promptUser: FontFamily defaultFamilyName
	"
	"Present a menu of available fonts, and if one is chosen, return it.
	Otherwise return nil."

	| menu answer |
	menu := MenuMorph entitled: 'Fonts'.
	menu defaultTarget: menu.
	menu addTitle: 'Installed Fonts'.
	FontFamily familyNames do: [ :fontName | | fontFamily item |
		fontFamily := FontFamily familyNamed: fontName.
		(fontFamily includesAscii or: [showFontsNotIncludingASCIICharacters]) ifTrue: [
			item := menu
				add: (fontName = currentNameOrNil) asMenuItemTextPrefix, fontName
				target: menu
				action: #modalSelection:
				argument: {#fontName. fontName}.
			fontFamily includesAscii ifTrue: [
				item fontFamily: fontFamily ]]].

	menu addTitle: 'Available to install'.
	(DirectoryEntry trueTypeFontsDirectory
		directories sorted: [ :a :b | a name < b name ]) do: [ :dir | | subDirs |
			subDirs := dir directories sorted: [ :a :b | a name < b name ].
			subDirs isEmpty
				ifTrue: [
					self addFontDir: dir to: menu current: currentNameOrNil ]
				ifFalse: [ | submenu anyAdded |
					submenu := MenuMorph new defaultTarget: menu.
					anyAdded := false.
					subDirs do: [ :subdir |
						anyAdded := anyAdded | (self addFontDir: subdir to: submenu current: currentNameOrNil) ].
					anyAdded ifTrue: [
						menu add: dir name, '... ' subMenu: submenu ]]].
	"If there's nothing 'Available to install', remove the section title"
	(menu lastSubmorph is: #MenuItemMorph) ifFalse: [
		menu lastSubmorph delete ].

	answer := menu invokeModal.
	answer ifNil: [ ^nil ].
	answer first = #fontDirectory
		ifTrue: [ TrueTypeFontFamily readAllTrueTypeFontsIn: answer third ].
	^FontFamily familyNamed: answer second! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6163-Tweak-JuanVuletich-2024Jan02-15h26m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6163] on 17 January 2024 at 8:31:33 pm'!
!ContextPart methodsFor: 'instruction decoding' stamp: 'HAW 1/17/2024 20:30:55' prior: 16838024!
                        return: value from: aSender 
	"For simulation.  Roll back self to aSender and return value from it.  Execute any unwind blocks on the way.  ASSUMES aSender is a sender of self"

	| newTop |
	newTop := aSender sender.
	(aSender isDead or: [newTop isNil or: [newTop isDead]]) ifTrue: [
		^ self pc: nil; send: #cannotReturn: to: self with: {value} super: false].
	(self findNextUnwindContextUpTo: newTop) ifNotNil: [
		^ self send: #aboutToReturn:through: to: self with: {value. nil} super: false].
	self releaseTo: newTop.
	newTop ifNotNil: [newTop push: value].
	^ newTop! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6164-return_from_improvement-HernanWilkinson-2024Jan17-20h30m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6163] on 17 January 2024 at 8:56:28 pm'!
!SystemDictionary methodsFor: 'class names' stamp: 'HAW 1/17/2024 20:42:01' prior: 16962679!
                  classNamed: className 
	"className is either a class name or a class name followed by ' class'.
	Answer the class or metaclass it names.
	Answer nil if no class by that name."
	"
	Smalltalk classNamed: #Point
	Smalltalk classNamed: 'Point'
	Smalltalk classNamed: 'Point class'
	Smalltalk classNamed: 'BogusClassName'
	Smalltalk classNamed: 'BogusClassName class'

	Smalltalk classNamed: #Display
	Smalltalk classNamed: 'Display'
	Smalltalk classNamed: 'Display class'
	"

	self at: className asSymbol ifPresent: [ :found |
		^ found isBehavior ifTrue: [ found ]].

	(className withoutSuffix: ' class') ifNotNil: [ :baseName |
		self at: baseName asSymbol ifPresent: [ :found |
			^ found isBehavior ifTrue: [ found class ]]].

	^ nil! !
!SystemDictionary methodsFor: 'class names' stamp: 'HAW 1/17/2024 20:50:04' prior: 16962848!
  renameAndUpdateReferences: oldName as: newName
	"Dangerous. Simple search and replace could break stuff.
	Use only to generate change sets to later checked with care
	
OldMorph withAllSubclasses do: [ :c |
	n := c name.
	(n beginsWith: 'Old') ifTrue: [
		Smalltalk renameAndUpdateReferences: n as: (n copyFrom: 4 to: n size) asSymbol ]]

OldBorderStyle withAllSubclasses do: [ :c |
	n := c name.
	(n beginsWith: 'Old') ifTrue: [
		Smalltalk renameAndUpdateReferences: n as: (n copyFrom: 4 to: n size) asSymbol ]]

#(#OldKeyboardBuffer #OldLayoutCell #OldLayoutFrame #OldLayoutPolicy #OldLayoutProperties #OldMorphExtension #OldMouseClickState #OldProportionalLayout #OldTableLayout #OldTableLayoutProperties #OldTextAnchor #OldTextComposer #OldTextContainer #OldTextLine #OldTheWorldMenu #OldWorldState #OldWorldTest) do: [ :n |
	Smalltalk renameAndUpdateReferences: n as: (n copyFrom: 4 to: n size) asSymbol ]
	"

	self renameClassNamed: oldName as: newName.
	(self allCallsOn: (self associationAt: newName)) do: [ :methodRef |
		methodRef updateReferencesTo: oldName toBe: newName ]! !
!SystemDictionary methodsFor: 'class names' stamp: 'HAW 1/17/2024 20:50:21' prior: 16962902!
   renamedClass: aClass from: oldName 
	
	| newName |
	
	newName := aClass name.
	
	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: aClass category.
	self 
		logChange: 'Smalltalk renameClassNamed: #', oldName, ' as: #', newName
		preamble: 'classRenamed: #', oldName, ' as: #', newName, Utilities changeStampField! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:41:03' prior: 16962945!
                        browseEqEqSentToCharacterConstants
	"
	Smalltalk browseEqEqSentToCharacterConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#== #~~ ) identityIncludes: node selector key) and: [
					node receiver isConstantCharacter or: [ node arguments first isConstantCharacter ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:41:08' prior: 16962965!
                              browseEqEqSentToSmallIntegerConstants
	"
	Smalltalk browseEqEqSentToSmallIntegerConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#== #~~ ) identityIncludes: node selector key) and: [
					node receiver isConstantNumber or: [ node arguments first isConstantNumber ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:41:44' prior: 16963001!
                              browseUndeclaredReferences
	"
	Smalltalk browseUndeclaredReferences
	"
	| anythingToShow |
	self cleanOutUndeclared.
	anythingToShow := false.
	Undeclared keys do: [ :k |
		anythingToShow := true.
		self
			browseMessageList: (self allCallsOn: (Undeclared associationAt: k))
			name: 'References to Undeclared: ', k printString ].

	"undeclared not in Undeclared - "
	"This happened in Pharo. See http://lists.gforge.inria.fr/pipermail/pharo-project/2012-March/061270.html
	Maybe do something like this in Cuis too???
	lostUndeclared := self allSelect: [:m|
		m literals anySatisfy: [:l|
			l isVariableBinding
				and: [l key isSymbol ""avoid class-side methodClass literals""
				and: [(m methodClass bindingOf: l key) isNil
				and: [(Undeclared includesAssociation: l) not]]]]].
	"

	anythingToShow ifFalse: [
		 (PopUpMenu labels: ' OK ')
				startUpWithCaption: 'There are no Undeclared at all' ]! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:42:21' prior: 16963033!
                        cleanCompactObsoleteClasses

	| cct |
	"No Compact Classes support in Spur"
	self isSpur ifTrue: [ ^ self ].

	cct := self compactClassesArray.
	cct do: [ :c |
		c ifNotNil: [
			c isObsolete ifTrue: [ 
				cct at: c indexIfCompact put: nil ]]]! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:42:48' prior: 16963049!
          condenseChanges
	"Move all the changes onto a compacted sources file."
	"
	Smalltalk condenseChanges
	"

	| oldChanges classCount oldChangesLocalName oldChangesPathName |
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' forceWriteStreamDo: [ :f |
		f timeStamp.
		'Condensing Changes File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: self classNames size
			during: [ :barBlock |
				classCount := 0.
				self allClassesDo: [ :class | 
					barBlock value: (classCount := classCount + 1).
					class moveChangesTo: f.
					class putClassCommentToCondensedChangesFile: f.
					class class moveChangesTo: f ]].
		LastQuitLogPosition := f position ].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	oldChanges := SourceFiles at: 2.
	oldChangesPathName := oldChanges name.
	oldChangesLocalName := oldChanges localName.
	oldChanges close.
	(oldChangesPathName, '.old') asFileEntry delete.
	oldChangesPathName asFileEntry rename: oldChangesLocalName, '.old'.
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' rename: oldChangesLocalName.
	
	SourceFiles
			at: 2 put: oldChangesPathName asFileEntry appendStream.

	self inform: 'Changes file has been rewritten!!

Check that all is well, and then save/quit.
 
Otherwise, remove new changes,
replace it with the former one, and
exit without saving the image.
 '! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:42:59' prior: 16963115!
                            condenseSources: newVersionString
	"Move all the changes onto a compacted sources file."
	"Smalltalk condenseSources"

	| classCount oldChanges oldChangesLocalName oldChangesPathName newChangesPathName newSourcesName |
	SourceFileVersionString := newVersionString.

	"Write all sources with fileIndex 1"
	newSourcesName := self defaultSourcesName.
	newSourcesName asFileEntry writeStreamDo: [ :f |
		f timeStamp.
		'Condensing Sources File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: self classNames size
			during: [ :barBlock |
				classCount := 0.
				self allClassesDo: [ :class |
					barBlock value: (classCount := classCount + 1).
					class fileOutOn: f moveSource: true toFile: 1]]].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	"Make a new empty changes file"
	oldChanges := SourceFiles at: 2.
	oldChangesPathName := oldChanges name.
	oldChangesLocalName := oldChanges localName.
	self closeSourceFiles.
	oldChangesPathName ifNotNil: [
		(oldChangesPathName, '.old') asFileEntry delete.
	oldChangesPathName asFileEntry rename: oldChangesLocalName, '.old' ].
	newChangesPathName := self defaultChangesName.
	newChangesPathName asFileEntry writeStreamDo: [ :stream |
		stream timeStamp ].
	LastQuitLogPosition := 0.

	self openSourceFiles.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:45:00' prior: 16963159!
                           macroBenchmark1    "Smalltalk macroBenchmark1"
	"Decompiles and prettyPrints the source for every method in the system (or less depending on the *FILTER*, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same.  Because it never installs the new method, it should not cause any flusing of the method cache."
	 | methodNode oldMethod newMethod badOnes oldCodeString n classes |
	classes := self allClasses select: [:c | c name < 'B3'].
	badOnes := OrderedCollection new.
'Decompiling and recompiling...'
displayProgressAt: Sensor mousePoint
from: 0 to: (classes sum: [:c | c selectors size] ifEmpty: [0])
during: [:barBlock | n := 0.
	classes do:
		[:cls | 
		"Transcript cr; show: cls name."
		cls selectors do:
			[:selector | barBlock value: (n := n+1).
			oldMethod := cls compiledMethodAt: selector.
			oldCodeString := (cls decompilerClass new
								decompile: selector in: cls method: oldMethod)
							decompileString.
			methodNode := cls compilerClass new
						compile: oldCodeString
						in: cls notifying: nil ifFail: nil.
			newMethod := methodNode generate: #(0 0 0 0).
			oldCodeString = (cls decompilerClass new
								decompile: selector in: cls method: newMethod)
							decompileString ifFalse: [badOnes add: cls name , ' ' , selector]]].
].
	^ badOnes size! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:45:06' prior: 16963237!
                         obsoleteBehaviors
	"
	Smalltalk obsoleteBehaviors inspect
	Find all obsolete behaviors including meta classes
	"
	| obs |
	obs := OrderedCollection new.
	self garbageCollect.
	self allObjectsDo: [ :cl |
		(cl isBehavior and: [cl isObsolete]) ifTrue: [obs add: cl]].
	^ obs asArray! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:45:21' prior: 16963249!
      obsoleteClasses   "Smalltalk obsoleteClasses inspect"
	"NOTE:  Also try inspecting comments below"
	| obs c |
	obs := OrderedCollection new.  
	self garbageCollect.
	Metaclass allInstancesDo:
		[:m | c := m soleInstance.
		(c notNil and: ['AnOb*' match: c name asPlainString])
			ifTrue: [obs add: c]].
	^ obs asArray

"Likely in a ClassDict or Pool...
(Association allInstances select: [:a | (a value isKindOf: Class) and: ['AnOb*' match: a value name]]) asArray
"
"Obsolete class refs or super pointer in last lit of a method...
| n l found |
Smalltalk browseAllSelect:
	[:m | found := false.
	1 to: m numLiterals do:
		[:i | (((l := m literalAt: i) isMemberOf: Association)
				and: [(l value isKindOf: Behavior)
				and: ['AnOb*' match: l value name]])
			ifTrue: [found := true]].
	found]
"! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:49:14' prior: 16963320!
   removeEmptyMessageCategories
	"Smalltalk removeEmptyMessageCategories"
	self garbageCollect.
	(ClassOrganizer allInstances copyWith: SystemOrganization) do:
		[:org | org removeEmptyCategories]! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:52:04' prior: 16963329!
                             testDecompiler
	"
	Smalltalk testDecompiler
	"
	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."
	| methodNode oldMethod newMethod badOnes oldCodeString n |
	badOnes := OrderedCollection new.
	'Decompiling all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n := 0.
			self allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n := n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldMethod := cls compiledMethodAt: selector.
					oldCodeString := (cls decompilerClass new
						decompile: selector
						in: cls
						method: oldMethod) decompileString.
					methodNode := cls compilerClass new
						compile: oldCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod := methodNode generate: #(0 0 0 0 ).
					oldCodeString =
						(cls decompilerClass new
							decompile: selector
							in: cls
							method: newMethod) decompileString ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: (MethodReference class: cls selector: selector) ]]]].
	self
		browseMessageList: badOnes
		name: 'Decompiler Discrepancies'.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:52:15' prior: 16963379!
       testFormatter
	"Smalltalk testFormatter"
	"Reformats the source for every method in the system, and then compiles that source and verifies that it generates identical code.
	The formatting used will be classic monochrome."
	| newCodeString methodNode oldMethod newMethod badOnes n |
	badOnes := OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n := 0.
			self allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n := n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					newCodeString := cls compilerClass new
						format: (cls sourceCodeAt: selector)
						in: cls
						notifying: nil.
					methodNode := cls compilerClass new
						compile: newCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod := methodNode generate: #(0 0 0 0 ).
					oldMethod := cls compiledMethodAt: selector.
					oldMethod = newMethod ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	self
		browseMessageList: badOnes
		name: 'Formatter Discrepancies'.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:52:24' prior: 16963421!
                        testFormatter2
	"Smalltalk testFormatter2"
	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.
	The formatting used will be classic monochrome"
	| newCodeString badOnes n oldCodeString oldTokens newTokens |
	badOnes := OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n := 0.
			self allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n := n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldCodeString := (cls sourceCodeAt: selector) asPlainString.
					newCodeString := cls compilerClass new
						format: oldCodeString
						in: cls
						notifying: nil.
					oldTokens := oldCodeString findTokens: Character separators.
					newTokens := newCodeString findTokens: Character separators.
					oldTokens = newTokens ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	self
		browseMessageList: badOnes
		name: 'Formatter Discrepancies'.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 1/17/2024 20:52:35' prior: 16963461!
            verifyChanges		"Smalltalk verifyChanges"
	"Recompile all methods in the changes file."
	self allBehaviorsDo: [:class | class recompileChanges].
! !
!SystemDictionary methodsFor: 'image, changes name' stamp: 'HAW 1/17/2024 20:32:40' prior: 16963609!
       userChangesFileName
	"
	Smalltalk userChangesFileName
	"
	^(FileIOAccessor default baseNameFor: self imageName pathAndLocalName second), 
		(Preferences at: #userChangesFileNameExtension)! !
!SystemDictionary methodsFor: 'memory space' stamp: 'HAW 1/17/2024 20:44:51' prior: 16963783!
   lowSpaceWatcher
	"Wait until the low space semaphore is signalled, then take appropriate actions."

	| p |
	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [
		self garbageCollect <= self lowSpaceThreshold ifTrue: [
			"free space must be above threshold before starting low space watcher"
			^ self primitiveBeep ]].

	LowSpaceSemaphore := Semaphore new.
	self primLowSpaceSemaphore: LowSpaceSemaphore.
	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"

	LowSpaceSemaphore wait.  "wait for a low space condition..."

	self primSignalAtBytesLeft: 0.  "disable low space interrupts"
	self primLowSpaceSemaphore: nil.
	LowSpaceProcess := nil.
	"Note: user now unprotected until the low space watcher is re-installed"

	p := (self specialObjectsArray at: 23) ifNil: [
		"In case the LowSpaceSemaphore is signaled not by the VM but by someone else."
		Processor preemptedProcess ].
	self specialObjectsArray at: 23 put: nil.
	p isTerminated ifFalse: [
		p suspend.
		Debugger openProcess: p context: p suspendedContext label: 'Space is low' ]! !
!SystemDictionary methodsFor: 'code authors' stamp: 'HAW 1/17/2024 20:35:40' prior: 16963956!
    allContributors
"
	Smalltalk allContributors
"
	| answer author |
	answer := Set new.
	self allBehaviorsDo: [ :behavior |
		behavior methodsDo: [ :compiledMethod |
			author := compiledMethod author.
			author notEmpty ifTrue: [
				answer add: author ]]].
	^answer! !
!SystemDictionary methodsFor: 'code authors' stamp: 'HAW 1/17/2024 20:43:06' prior: 16963967!
                     contributionsOf: aString
	"
	Smalltalk contributionsOf: 'JMV'
	"
	| author answer |
	answer := OrderedCollection new.
	self allBehaviorsDo: [ :behavior |
		behavior methodsDo: [ :compiledMethod |
			author := compiledMethod author.
			aString = author ifTrue: [
				answer add: {compiledMethod methodClass. compiledMethod selector}]]].
	^answer! !
!SystemDictionary methodsFor: 'code authors' stamp: 'HAW 1/17/2024 20:52:32' prior: 16964219!
      unknownContributors
	"Answer a collection of authorInitials for whom there is code in the system 
	(either in core or in loaded packages), but we don't knwo their full name.
	Smalltalk unknownContributors
	"

	| all ok |
	all := self allContributors asSet.
	ok := (self knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
	^(all difference: ok) asArray sort! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'HAW 1/17/2024 20:43:19' prior: 16964278!
              extraVMMemory
	"Answer the current setting of the 'extraVMMemory' VM parameter. See the comment in extraVMMemory: for details."

	^ self vmParameterAt: 23
! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'HAW 1/17/2024 20:43:24' prior: 16964286!
  extraVMMemory: extraBytesToReserve
	"Request that the given amount of extra memory be reserved for use by the virtual machine to leave extra C heap space available for things like plugins, network and file buffers, and so on. This request is stored when the image is saved and honored when the image is next started up. Answer the previous value of this parameter."

	extraBytesToReserve < 0
		ifTrue: [self error: 'VM memory reservation must be non-negative'].
	^ self vmParameterAt: 23 put: extraBytesToReserve
! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'HAW 1/17/2024 20:43:47' prior: 16964305!
                            getCurrentWorkingDirectory
	"Do our best effort to answer the path from wich Cuis was started.

	Smalltalk getCurrentWorkingDirectory


On Linux, starting as
	juan@juandebian:/media/sf_SharedWithLinux/testPayload03/payload$      coglinux/bin/squeak        Cuis-Smalltalk-Dev-master/Cuis4.2-2367.image
we get:
	Smalltalk vmPath                       					'/media/sf_SharedWithLinux/testPayload03/payload/coglinux/lib/squeak/4.5-3370/'
	Smalltalk imagePath   							'/media/sf_SharedWithLinux/testPayload03/payload/Cuis-Smalltalk-Dev-master'
	Smalltalk primGetCurrentWorkingDirectoryUnix    '/media/sf_SharedWithLinux/testPayload03/payload'
	Smalltalk getCurrentWorkingDirectory 			'/media/sf_SharedWithLinux/testPayload03/payload'


On Windows 7, starting as
	C:\Users\Juan-Tuerca\SharedWithLinux\testPayload03\payload>        cogwin\squeak.exe            Cuis-Smalltalk-Dev-master/Cuis4.2-2367.image
we get:
	Smalltalk vmPath    										'C:\Users\Juan-Tuerca\SharedWithLinux\testPayload03\payload\cogwin\'
	Smalltalk imagePath   									'C:\Users\Juan-Tuerca\SharedWithLinux\testPayload03\payload\Cuis-Smalltalk-Dev-master'
	Smalltalk primGetCurrentWorkingDirectoryWindows       	'C:\Users\Juan-Tuerca\SharedWithLinux\testPayload03\payload\Cuis-Smalltalk-Dev-master'
	Smalltalk getCurrentWorkingDirectory  					'C:\Users\Juan-Tuerca\SharedWithLinux\testPayload03\payload'

	Easy on Unix. Harder on Windows, because #primGetCurrentWorkingDirectoryWindows insists on lying and answers the directory containing the image.
	"
	
	| fullImagePathName imageSpecCmdLineArgument |

	"Easy on Unix"
	 self primGetCurrentWorkingDirectoryUnix ifNotNil: [ :cwd |
		"It seems on Mac, when dropping image on VM, we get '/', that is not really meaningful"
		(cwd = '/' and: [ self platformName = 'Mac OS' ]) ifFalse: [
			^ cwd ]].

	"On Windows, extract shell path if image is in subtree"
	fullImagePathName := self imageName.
	imageSpecCmdLineArgument := self getSystemAttribute: 1.
	imageSpecCmdLineArgument ifNotNil: [
		(imageSpecCmdLineArgument size < fullImagePathName size and: [			"Not if they are equal, as if they are both fully qualified (absolute) paths"
			fullImagePathName asPathTokens endsWith: imageSpecCmdLineArgument asPathTokens]) ifTrue: [
				^ fullImagePathName copyFrom: 1 to: fullImagePathName size - imageSpecCmdLineArgument size - 1 ]].

	"If we don't know better, answer nil. If appropriate, senders do:
		Smalltalk getCurrentWorkingDirectory ifNil: [ Smalltalk imagePath ]
	to have, at least, some valid directory
	"
	^ nil! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'HAW 1/17/2024 20:44:30' prior: 16964516!
                 isDevelopmentEnvironmentPresent
	"Or we can't open a Smalltalk debugger"

	^ self isHeadless not and: [self includesKey: #Debugger]! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'HAW 1/17/2024 20:52:51' prior: 16964756!
                          vmOptionsDo: aBlock
	"Repeatedly evaluate aBlock for each vm option specified by the commandline that started Cuis.
	aBlock has two arguments: the vm option itself and the index (position)
	
	Smalltalk vmOptionsDo: [ :option :i | {i. option} print ]
	"
	| i vmOption |
	i := -1.
	[vmOption := self getSystemAttribute: i.
	vmOption notNil ] whileTrue: [
		aBlock value: vmOption value: i.
		i := i-1 ]! !
!SystemDictionary methodsFor: 'printing' stamp: 'jmv 9/3/2012 18:04' prior: 16964817 overrides: 16829096!
  printOn: aStream
	self == Smalltalk
		ifTrue: [ aStream nextPutAll: 'Smalltalk' ]
		ifFalse: [ super printOn: aStream ]! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:35:34' prior: 16964865!
         allBehaviorsDo: aBlock 
	"Evaluate the argument, aBlock, for each kind of Behavior in the system 
	(that is, Object and its subclasses).
	ar 7/15/1999: The code below will not enumerate any obsolete or anonymous
	behaviors for which the following should be executed:

		Smalltalk allObjectsDo:[:obj| obj isBehavior ifTrue:[aBlock value: obj]].

	but what follows is way faster than enumerating all objects."

	self do: [ :root |
		(root isBehavior and: [root superclass isNil]) ifTrue: [	"Grab ProtoObject and any other alike"
			root withAllSubclassesDo: [ :class |
				class isMeta ifFalse: [ "The metaclasses are rooted at Class; don't include them twice."
					aBlock
						value: class;
						value: class class ]]]]! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:36:20' prior: 16965090!
               allMethodsSourceStringMatching: aString
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.
	Search the class comments also.
	Argument might include $*, that matches any subsequence.
	For example, try:
		ensure:*[*close*]
	"
	| list classCount adder |
	list := Set new.
	adder := [ :mrClass :mrSel |
		list add: (MethodReference class: mrClass selector: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self classNames size
		during: [ :barBlock |
			classCount := 0.
			self allClassesDo: [ :class |
				barBlock value: (classCount := classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						(aString match: (cl sourceCodeAt: sel)) ifTrue: [
							adder
								value: cl
								value: sel ]].

					(aString match: cl organization classComment) ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:38:01' prior: 16965124!
                            allMethodsWithSourceString: aString matchCase: caseSensitive
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"
	| list classCount adder |
	list := Set new.
	adder := [ :mrClass :mrSel |
		list add: (MethodReference class: mrClass selector: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self classNames size
		during: [ :barBlock |
			classCount := 0.
			self allClassesDo: [ :class |
				barBlock value: (classCount := classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						((cl sourceCodeAt: sel)
							findString: aString
							startingAt: 1
							caseSensitive: caseSensitive) > 0 ifTrue: [
							adder
								value: cl
								value: sel ]].
					(cl organization classComment
						findString: aString
						startingAt: 1
						caseSensitive: caseSensitive) > 0 ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:38:05' prior: 16965276!
                             allReferencesToLiteral: aLiteral
	| coll |
	coll := OrderedCollection new.
	self allBehaviorsDo: [ :eaClass |
		eaClass
			addMethodsTo: coll
			thatReferenceTo: aLiteral
			special: false
			byte: nil ].
	^ coll.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:38:14' prior: 16965308!
           allSentMessagesWithout: classesAndMessagesPair
	"Answer the set of selectors which are sent somewhere in the system, 
	computed in the absence of the supplied classes and messages."

	| sent absentClasses absentSelectors |
	sent := IdentitySet new: CompiledMethod instanceCount.
	absentClasses := classesAndMessagesPair first.
	absentSelectors := classesAndMessagesPair second.
	self classNames do: [ :cName | 
		((absentClasses includes: cName)
				ifTrue: [#()]
				ifFalse: [{(self at: cName). (self at: cName) class}]) do: [ :cl |
			 (absentSelectors isEmpty
					ifTrue: [cl selectors]
					ifFalse: [cl selectors copyWithoutAll: absentSelectors]) do: [ :sel |
				 "Include all sels, but not if sent by self"
				self allSymbolsIn: (cl compiledMethodAt: sel) literals do: [ :m |
					m == sel ifFalse: [sent add: m] ]]]].
		"The following may be sent without being in any literal frame"
		1 to: self specialSelectorSize do: [ :index | 
			sent add: (self specialSelectorAt: index)].
	self presumedSentMessages do: [ :sel | sent add: sel].
	^ sent! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:38:48' prior: 16965402!
   allUnusedClassesWithout: classesAndMessagesPair
	"Enumerates all classes in the system and returns a list of those that are apparently unused. A class is considered in use if it (a) has subclasses or (b) is referred to by some method or (c) has its name in use as a literal (but not in the same class) or: (d) some instance is a global."
	"
	Smalltalk unusedClasses
	"

	| unused cl |
	self garbageCollect.
	unused := self classNames asIdentitySet
				copyWithoutAll: (self allGlobalRefsWithout: classesAndMessagesPair).
				
	self do: [ :global |
		unused remove: global class name ifAbsent: nil].
	
	^ unused reject: [ :cName |
		cl := self at: cName.
		cl subclasses notEmpty
			"or: [ cl someInstance notNil ]"
			"or: [cl inheritsFrom: FileDirectory]"]! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 1/17/2024 20:46:14' prior: 16965549!
           poolUsers
	"Answer a dictionary of pool name -> classes that refer to it. Also includes any globally know dictionaries (such as Smalltalk, Undeclared etc) which although not strictly accurate is potentially useful information "
	"Smalltalk poolUsers"
	| poolUsers pool refs |
	poolUsers := Dictionary new.
	self keys
		do: [ :k |
			 (((pool := self at: k) is: #Dictionary)
					or: [pool isKindOf: SharedPool class])
				ifTrue: [refs := self allClasses
								select: [:c | c sharedPools identityIncludes: pool]
								thenCollect: [:c | c name].
					refs := refs asOrderedCollection.
					refs
						add: (self
								allCallsOn: (self associationAt: k)).
					poolUsers at: k put: refs]].
	^ poolUsers! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'HAW 1/17/2024 20:35:27' prior: 16965603!
                            abandonSources
	"
	Smalltalk abandonSources
	"
	 | m bTotal bCount |
	(self confirm:
'This method will detach the image fom source code.
A fresh changes file will be created to record further changes.
-- CAUTION --
If you have backed up your system and
are prepared to face the consequences of
abandoning source code files, choose Yes.
If you have any doubts, you may choose No
to back out with no harm done.')
		==  true ifFalse: [^ self inform: 'Okay - no harm done'].
	bTotal := 0.  bCount := 0.
	self allBehaviorsDo: [: b | bTotal := bTotal + 1].
'Doing #destroySourcePointer ...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: bTotal
	during: [ :barBlock |
		self allBehaviorsDo: [ :cl |
		"for testing"
		"{ EllipseMorph } do: [ :cl |"
			barBlock value: (bCount := bCount + 1).
			cl selectors do: [:selector |
				m := cl compiledMethodAt: selector.
				m destroySourcePointer ]]].
	self allBehaviorsDo: [:b | b zapOrganization].
	self closeSourceFiles.
	Preferences at: #warnIfNoChangesFile put: false.
	Preferences at: #warnIfNoSourcesFile put: false! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'HAW 1/17/2024 20:48:51' prior: 16965693!
                         reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	self at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w submorphsDo: [ :a | a delete ]].
	Preferences at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	self garbageCollect.

	self removeEmptyMessageCategories.
	self organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := self unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(self at: c) removeFromSystem]. 
		n := self removeAllUnSentMessages.
		unused := self unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	self garbageCollect.

	self removeEmptyMessageCategories.
	self organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	self garbageCollect.
	oldDicts := MethodDictionary allInstances.
	newDicts := Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts := newDicts := nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'HAW 1/17/2024 20:49:00' prior: 16965760!
                        removeAllUnSentMessages
	"Smalltalk removeAllUnSentMessages"
	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]. 
	Smalltalk removeAllUnSentMessages > 0] whileTrue."
	"Remove all implementations of unsent messages."
	| sels n |
	sels := self allUnSentMessages.
	self presumedSentMessages
		do: [:sel | sels
				remove: sel
				ifAbsent: nil].
	sels isEmpty
		ifTrue: [^ 0].
	n := 0.
	self
		allBehaviorsDo: [:x | n := n + 1].
	'Removing ' , sels size printString , ' messages . . .'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: n
		during: [:barBlock | 
			n := 0.
			self
				allBehaviorsDo: [:class | 
					barBlock value: (n := n + 1).
					sels
						do: [:sel | class removeSelector: sel]]].
	^ sels size! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'HAW 1/17/2024 20:49:24' prior: 16965786!
                            removeSelector: descriptor
	"Safely remove a selector from a class (or metaclass). If the class
	or the method doesn't exist anymore, never mind and answer nil.
	This method should be used instead of 'Class removeSelector: #method'
	to omit global class references."

	| class sel |
	class := self at: descriptor first ifAbsent: [^ nil].
	(descriptor size > 2 and: [descriptor second == #class])
		ifTrue:
			[class := class class.
			sel := descriptor third]
		ifFalse: [sel := descriptor second].
	^ class removeSelector: sel! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'HAW 1/17/2024 20:49:55' prior: 16965805!
                  removedUnusedClassesAndMethods
	[
		#hereWeGo print.
		self unusedClasses do: [:c | 
			c print.
			(self at: c) removeFromSystem]. 
		self removeAllUnSentMessages > 0 or: [ self unusedClasses notEmpty ]] whileTrue.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:43:35' prior: 16966008!
  filenameForUpdatedImage: aBoolean
	"If aBoolean, include highest update number	"
	| fileName newName changesName systemVersion |
	systemVersion := SystemVersion current.
	fileName := String streamContents: [ :strm |
		strm nextPutAll: systemVersion versionString.
		aBoolean ifTrue: [
			strm
				nextPut: $-;
				print: systemVersion highestUpdate ].
		self isSpur
			ifTrue: [	
				self wordSize = 4 ifTrue: [
					strm nextPutAll: '-32' ]]
			ifFalse: [
				strm nextPutAll: '-v3' ]].
	newName := fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName := DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName := self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		self inform:
'There is already .changes file of the desired name,
', changesName, '
curiously already present, even though there is no
corresponding .image file.
Please remedy manually and then repeat your request.'.
		^nil  ].
	^newName! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:46:58' prior: 16966071!
                    printStuffToCleanOnImageSave
	"So far, to serve experiments.
	Some day, when this is empty, we'll be closer to bootstrap from sources."
	| n nonNilVars m classInstVars v|
	n := 0.
	""
	'--------' print.
	'Proceeses: ' print.
	(Processor processes
		sort: [ :a :b | a priority >= b priority ]) do: [ :p | p print ].
	'======' print.
	'Globals: ' print.
	self globals associationsDo: [ :g | " {g key. g value class }" g  print ].
	'======' print.
	'ClassVars (notNil):  ' print.
	n := 0.
	self hierachySortedAllClassesDo: [ :cls |
		"Cleared, but come again for lazy init during this report.
		therefore, not required for bootstrap from sources"
		({ Scanner } includes: cls) ifFalse: [
			nonNilVars := cls classPool select: [ :var | var notNil ].
			nonNilVars notEmpty ifTrue: [
				n := n + 1.
				{ cls. nonNilVars keys} print ]]].
	'======' print.
	'InstClassVars (notNil): ' print.
	m := 0.
	self hierachySortedAllClassesDo: [ :cls |
		classInstVars := Dictionary new.
		cls class allRegularInstVarNames do: [ :nam |
			v := cls instVarNamed: nam.
			v ifNotNil: [
				classInstVars at: nam put: v ]].
		classInstVars notEmpty ifTrue: [
			m := m + 1.
			{ cls class. classInstVars keys }  print ]].
	'======' print.
	
	{ n. m}  print! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:50:30' prior: 16966301!
  saveNumberedRelease
	"Save the image/changes using the next release version number."
	"
	Smalltalk saveNumberedRelease
	"
	| versionMajor versionMinor previousValue |
	versionMajor := 6.
	versionMinor := 2.
	SystemVersion newVersionMajor: versionMajor versionMinor: versionMinor.
	"While condensing sources, convert all variable assignment to ANSI Smalltalk form, i.e. :="
	previousValue := Preferences at: #fileOutANSIassignment.
	Preferences at: #fileOutANSIassignment put: true.
	self condenseSources: SystemVersion current versionString.
	Preferences at: #fileOutANSIassignment put: previousValue.
	self setDefaultGCParameters.

	(self filenameForUpdatedImage: false) ifNotNil: [ :newName |
		SystemVersion current beNumberedRelease.
		"Try to clear all user state, including all class vars, preferences, etc"
		self saveAndStayAs: newName clearAllClassState: true ].! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:50:35' prior: 16966411!
                  setDefaultGCParameters
	"Adjust the VM's default GC parameters to avoid premature tenuring, and too frequent scavenging.
	Parameters set here persist in saved images, so we set them image save for release.
	See #setGCParameters"

	"Desired Eden size: "
	self vmParameterAt: 45 put: `16*1024*1024`.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:50:53' prior: 16966424!
                setGCParameters
	"Adjust the VM's default GC parameters to avoid premature tenuring, and too frequent scavenging.
	Parameters set here don't persist, so we set them on startup.
	See #setDefaultGCParameters"

	"Grow old memory in chunks of: "
	self vmParameterAt: 25 put: `32*1024*1024`.
	"Shrink heap when unused memory is at least: "
	self vmParameterAt: 24 put: `64*1024*1024`.

	self isSpur
		ifTrue: [
			"Note: (jmv, 9/2021) It seems modern Spur VMs ignore parameter 6. This all seems to be bogus."
			| proportion edenSize survivorSize averageObjectSize numObjects |
			proportion := 0.9. "tenure when 90% of pastSpace is full"
			edenSize := self vmParameterAt: 44.
			survivorSize := edenSize / 5.0. "David's paper uses 140Kb eden + 2 x 28kb survivor spaces; Spur uses the same ratios :-)"
			averageObjectSize := 8 * self wordSize. "a good approximation"
			numObjects := (proportion * survivorSize / averageObjectSize) rounded.
			self vmParameterAt: 6 put: numObjects.  "tenure when more than this many objects survive the GC"
			"/Note: (jmv, 9/2021)"
			
			"Do a full GC when used memory grows by this factor. Fails on non-Spur VMs.
			Default is 0.333.
			2.0 means gull GC when heap size triples."
			self vmParameterAt: 55 put: 2.0.
			]
		ifFalse: [
			self vmParameterAt: 5 put: 4000.  "do an incremental GC after this many allocations"
			self vmParameterAt: 6 put: 2000.  "tenure when more than this many objects survive the GC"
			].! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'HAW 1/17/2024 20:51:46' prior: 16966496!
          snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
	"This is the main method for image save and / or quit.
	See senders."
	"WARNING: Current process will be killed. UI Process will be restarted"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic
	checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
	| activeProc |
	activeProc := Processor activeProcess.
[
	| isARealStartup guiRootObject guiRootObjectClass |
	save not & quit
		ifTrue: [ (SourceFiles at: 2) ifNotNil: [ :changes |
				ChangesInitialFileSize ifNotNil: [ changes truncate: ChangesInitialFileSize ]]]
		ifFalse: [ self logSnapshot: save andQuit: quit ].
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each |
			each isInWorld ifTrue: [ each delete.]].
		UISupervisor ui tearDownDesktop.
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.
	"These could be moved to some #shutDown"
	self stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	"Stuff needed to relaunch UI on startup"
	guiRootObjectClass := UISupervisor ui class.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	guiRootObject := clearAllStateFlag ifFalse: [ UISupervisor ui ].

	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [ activeProc terminate ].
	guiRootObject ifNotNil: [ guiRootObject releaseCachedState ].
	clearAllStateFlag ifTrue: [
		Processor processesDo: [ :p |
			(p name = 'Formerly: Morphic UI') ifTrue: [ p terminate ]]].
	MorphicCanvas allSubInstancesDo: [ :c |
		(c ownerProcess notNil and: [c ownerProcess isTerminated]) ifTrue: [
			c releaseEngine			]].

	"Clean Globals"
	self at: #Sensor put: nil.
	self closeSourceFiles.
	self at: #SourceFiles put: nil.
	self allClassesDo: [ :cls |
		cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [
		self allClassesDo: [ :cls |
			cls releaseClassState ]].
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [
		Transcript clear.
		"Enable this call to actually see the image clean report."
		false ifTrue: [self printStuffToCleanOnImageSave]].
	"Do image save & quit as apropriate"
	(Cursor cursorAt: #writeCursor) activateCursor.
	save
		ifTrue: [
			"The snapshot primitive answers false if it was just called to do the snapshot.
			But image startup is resumed by returning (again) from the primitive, but this time answering true."
			isARealStartup := embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup := false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].

	"If starting from absolute scratch, this would be a good time to recreate Global names"
	self at: #Sensor put: nil.
	self at: #SourceFiles put: (Array new: 2).
	self logStartupDebugAid: 'To #openSourceFiles'.
	self openSourceFiles.
	"Here, startup begins!! (isARealStartup might be nil)"
	self logStartupDebugAid: 'To #initClassCachedState'.
	self allClassesDo: [ :cls | cls initClassCachedState ].
	self logStartupDebugAid: 'To #doStartUp:'.
	self doStartUp: isARealStartup == true.
	self logStartupDebugAid: 'To #spawnNewMorphicProcessFor: ', guiRootObject printString.
	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject := guiRootObjectClass newWorld ]).
	self logStartupDebugAid: 'To #restoreLostChangesIfNecessary'.
	self restoreLostChangesIfNecessary.
	clearAllStateFlag ifTrue: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #recreateDefaultDesktop'.
			guiRootObject recreateDefaultDesktop; restoreDisplay ]]
	ifFalse: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #restoreDisplay'.
			guiRootObject restoreDisplay ]].
	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #readAndApplyUserPrefs'.
			self readAndApplyUserPrefs.
			self logStartupDebugAid: 'To #processCommandLineArguments'.
			self processCommandLineArguments.
			self logStartupDebugAid: 'To #launchApp'.
			AppLauncher launchApp ]].
	"Now it's time to raise an error"
	isARealStartup ifNil: [ self logStartupError: 'Failed to write image file (disk full?)' ]
]
	forkAt: Processor timingPriority - 1
	named: 'Startup process'.! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'HAW 1/17/2024 20:39:42' prior: 16966745!
                         assureStartupStampLogged
	"If there is a startup stamp not yet actually logged to disk, do it now."
	| changesFile directory oldUserChanges oldUserChangesName |
	StartupStamp ifNil: [^ self].
	(SourceFiles notNil and: [(changesFile := SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			changesFile nextChunkPut: StartupStamp; newLine.
			self forceChangesToDisk ]].
	(Preferences at: #autoNumberUserChanges) ifTrue: [
		oldUserChanges := DirectoryEntry userChangesDirectory // self userChangesFileName.
		oldUserChanges exists ifTrue: [
			directory := oldUserChanges parent.
			oldUserChangesName := directory nextNameFor: oldUserChanges nameWithoutExtension extension: 'changes'.
			oldUserChanges rename: oldUserChangesName ]].
	DirectoryEntry userChangesDirectory // self userChangesFileName appendStreamDo: [ :stream |
		stream newLine; newLine.
		stream nextChunkPut: StartupStamp; newLine.
		stream flush ].
	StartupStamp := nil! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'HAW 1/17/2024 20:44:40' prior: 16966975!
           logChange: aStringOrText preamble: preambleOrNil
	"Write the argument, aString, onto the changes file."
	| aString changesFile |
	self assureStartupStampLogged.
	aString := aStringOrText asPlainString.
	aString firstNonSeparator = 0 ifTrue: [^ self].  "null doits confuse replay"
	
	(SourceFiles notNil and: [(changesFile := SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			preambleOrNil ifNotNil: [
				changesFile nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			changesFile nextChunkPut: aString.
			self forceChangesToDisk ]].
	Utilities logsUserChanges ifTrue: [
		DirectoryEntry userChangesDirectory // self userChangesFileName appendStreamDo: [ :stream |
			stream newLine; newLine.
			preambleOrNil ifNotNil: [
				stream nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			stream nextChunkPut: aString.
			stream flush ]]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'HAW 1/17/2024 20:45:58' prior: 16967037!
     openSourcesAndChanges
	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems.
	Note: SourcesName and imageName are full paths; changesName is a  
	local name."
	| sources changes entry msg lastQuitLogPosition snapshotChunk entryPathName |

	"Do not open source files if internalized (i.e. notNil)"
	sources := SourceFiles at: 1.
	sources ifNil: [
		entry := self defaultSourcesName asFileEntry.
		entry exists ifFalse: [
			entry := self alternativeSourcesName asFileEntry ].
		entry exists ifTrue: [
			sources := [ entry readStream ] on: FileDoesNotExistException do: [ nil ]]].
	(sources isNil and: [ Preferences at: #warnIfNoSourcesFile ])
		ifTrue: [
				msg := 'Cuis cannot locate the sources file named ' , entry pathName, '.', String newLineString,
					'Please check that the file is properly named and is in the same directory as this image.'.
			self logStartupError: msg.
		].

	"Do not open source files if internalized (i.e. notNil)"
	changes := SourceFiles at: 2.
	changes ifNil: [
		entry := self defaultChangesName asFileEntry.
		entryPathName := entry pathName.
		"Read the last snapshot chunk. Validate that the .changes file is appropriate for this image."
		entry exists
			ifTrue: [
				lastQuitLogPosition := self lastQuitLogPosition.
				lastQuitLogPosition > 0 ifTrue: [
					entry readStreamDo: [ :changesFile |
						changesFile position: lastQuitLogPosition.
						snapshotChunk := changesFile nextChunk ].
					((snapshotChunk beginsWith: self tagHeader) and: [
						snapshotChunk includesSubString: 'priorSource: ']) ifFalse: [
							(Preferences at: #warnIfNoChangesFile) ifTrue: [
								self logStartupError:
									'Incorrect changes file: ', entryPathName, String newLineString,
									'Missing code will be decompiled', String newLineString,
									'New source code will not be saved' ].
							entry := nil ]]]
			ifFalse: [
				(Preferences at: #warnIfNoChangesFile) ifTrue: [
					self logStartupError:
						'Could not find changes file: ', entryPathName, String newLineString,
						'Missing code will be decompiled', String newLineString,
						'New source code will not be saved' ].
				entry := nil ].
		entry ifNotNil: [
			changes := [ entry appendStream ]
				on: FileWriteError
				do: [
					self logStartupError:
						'Could not write to changes file: ', entryPathName, String newLineString,
						'Changes file will not be used.', String newLineString,
						'Missing code will be decompiled', String newLineString,
						'New source code will not be saved'.
					nil ]]].
	ChangesInitialFileSize := changes ifNotNil: [ changes position ].

	SourceFiles := Array with: sources with: changes.! !
!SystemDictionary methodsFor: 'special objects' stamp: 'HAW 1/17/2024 20:42:32' prior: 16967165!
                    compactClassesArray  "Smalltalk compactClassesArray"
	"Return the array of 31 classes whose instances may be
	represented compactly"
	^ self specialObjectsArray at: 29! !
!SystemDictionary methodsFor: 'ui' stamp: 'HAW 1/17/2024 20:39:47' prior: 16967468!
 beep
	"
	Smalltalk beep
	"
	(Preferences at: #soundsEnabled) ifTrue: [
		self
			at: #SampledSound
			ifPresent: [ :cls | cls beep ]
			ifAbsent: [ self primitiveBeep ]]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:40:49' prior: 16967810!
                         browseClassCommentsWithString: aString
	"Smalltalk browseClassCommentsWithString: 'my instances' "
	"Launch a message list browser on all class comments containing aString as a substring."
	| caseSensitive suffix list |
	suffix := (caseSensitive := Sensor shiftPressed)
		ifTrue: [ ' (case-sensitive)' ]
		ifFalse: [ ' (use shift for case-sensitive)' ].
	list := Set new.
	self allClassesDo: [ :class |
		(class organization classComment
			findString: aString
			startingAt: 1
			caseSensitive: caseSensitive) > 0 ifTrue: [
			list add: (MethodReference class: class selector: #Comment) ]].
	^ self
		browseMessageList: list
		name: 'Class comments containing ', aString printString, suffix
		autoHighlight: aString
		allOccurrences: true.! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:40:57' prior: 16967836!
                              browseClassesWithNamesContaining: aString caseSensitive: caseSensitive 
	"Smalltalk browseClassesWithNamesContaining: 'eMorph' caseSensitive: true "
	"Launch a class-list list browser on all classes whose names containg aString as a substring."

	| suffix aList |
	suffix := caseSensitive
				ifTrue: [' (case-sensitive)']
				ifFalse: [' (use shift for case-sensitive)'].
	aList := OrderedCollection new.
	self allClassesDo: [ :class |
		(class name includesSubstring: aString caseSensitive: caseSensitive)
			ifTrue: [aList add: class name]].
	aList notEmpty
		ifTrue: [HierarchyBrowserWindow forClassesNamed: aList asSet sorted title: 'Classes whose names contain ' , aString , suffix]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:41:13' prior: 16967860!
                  browseEqSmallConstant

    "Dan Ingalls' search for arithmetic use of ==
Answer whether the receiver contains the pattern <expression> == <constant>,
where constant is -1, 0, 1, or 2...
	Smalltalk browseEqSmallConstant
"

	self browseAllSelect: [:m | m scanForEqSmallConstant]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:41:18' prior: 16967893!
              browseLikelyUnneededRedefinitions

	"
	Spot unneeded method redefinitions: methods that are equal to what would be inherited if they weren't there
	Smalltalk browseLikelyUnneededRedefinitions
	Be careful with class side #initialize methods that set up instance class variables
	In general, class side #initialize methods can't be removed unless empty.
	"

	self browseAllSelect: [ :cm |
		(cm methodClass superclass ifNotNil: [ :sup | sup lookupSelector: cm selector]) = cm ]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:41:26' prior: 16968046!
       browseObsoleteReferences   "Smalltalk browseObsoleteReferences"
	| references |
	references := OrderedCollection new.
	(LookupKey allSubInstances select:
		[:x | ((x value isKindOf: Behavior) and: ['AnOb*' match: x value name]) or:
		['AnOb*' match: x value class name]]) 
		do: [:x | references addAll: (self allCallsOn: x)].
	self 
		browseMessageList: references 
		name: 'References to Obsolete Classes'! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 1/17/2024 20:41:53' prior: 16968062!
           browseViewReferencesFromNonViews
	"
	Smalltalk browseViewReferencesFromNonViews
	"
	| aLiteral aCollection |

	aCollection := OrderedCollection new.

	"Tweak to look just for pluggables or also for menus (or maybe for all morphs)"
"	PopUpMenu withAllSubclasses , MenuMorph withAllSubclasses , PluggableMorph withAllSubclasses do: [ :view |"
	PluggableMorph withAllSubclassesDo: [ :view |
"	MenuMorph withAllSubclassesDo: [ :view |"
		
		aLiteral := view name.
		
		"tweak to linclude refs to SysWindow subhierarchy or not"
		(view includesBehavior: SystemWindow) & false ifFalse: [
			self allBehaviorsDo: [ :class |
				((class includesBehavior: Morph) or: [ class includesBehavior: Morph class ]) ifFalse: [
					class addMethodsTo: aCollection thatReferenceTo: aLiteral special: false byte: nil ]]]].
	
	self
		browseMessageList: aCollection asSet
		name: 'References to Views from non-Views'.! !
!SystemDictionary methodsFor: 'image format' stamp: 'HAW 1/17/2024 20:43:58' prior: 16969066!
                              imageFormatVersion
	"Answer an integer identifying the type of image in memory. The image version number may
	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements
	of the image (e.g. block closure support required). This invokes an optional primitive
	that may not be available on all virtual machines.
	Answer nil if unknown."

	"
	Smalltalk imageFormatVersion
	"

	<primitive: 'primitiveImageFormatVersion'>

	"Cog provides a VM parameter"
	^self vmParameterAt: 41! !
!SystemDictionary methodsFor: 'image format' stamp: 'HAW 1/17/2024 20:44:08' prior: 16969108!
         imageFormatVersionFromFileAsIs
	"Answer an integer identifying the type of image on file. The image version number may
	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements
	of the image (e.g. block closure support required). If the image file has a different
	endianness than the VM, the format version will appear byte-swapped."
	"
	Smalltalk imageFormatVersionFromFileAsIs
	"
	^ self imageName asFileEntry readStreamDo: [ :stream |
		(stream binary; next: 4)
			uint32At: 1
			bigEndian: self isBigEndian ]! !
!SystemDictionary methodsFor: 'startup' stamp: 'HAW 1/17/2024 20:47:13' prior: 16969414!
   processCommandLineOption: optionString optionArgument: optionArgument raiseExceptions: aBoolean
	"
	A possible example (duplicated single quotes: '' should be double quotes, but not allowed in a Smalltalk comment):
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -h
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -v
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -q
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -e -d''0 zope''
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -r YAXO -rJSON -d ''Smalltalk startUpScriptArguments print'' xx YY 3492 -d'' 'here comes another' print'' -d ''{'The answer is: '. Smalltalk startUpScriptArguments first asNumber + Smalltalk startUpScriptArguments second asNumber} print'' 3 4 -- -d'' 'not this' print' ''

Squeak.exe Cuis4.2-2211x.image -r RequiredFeature1 -r RequiredFeature2 -d ''Transcript show: 'popo1'; newLine'' -d ''Transcript show: 'popo2'; newLine'' -s smalltalkScript.st param1ToScript param2ToSCript ''parametro 3 to script ->>>--// 3''
	"
	"You can use 'Smalltalk startUpScriptArguments' inside the startUp script:"


	| exceptionToIgnoreOrNil entry |
	exceptionToIgnoreOrNil := aBoolean ifFalse: [UnhandledError] ifTrue: [nil].
	optionString caseOf: {
		[ '-h' ] -> [
			self displayCommandLineUsageOn: StdIOWriteStream stdout.
			self quit ].

		[ '-v' ] -> [ 
			self displaySystemInformationStringOn: StdIOWriteStream stdout.
			self quit ].

		[ '-q' ] -> [ self quit ].

		[ '-r' ] -> [		"as in 		-rRequiredFeature2        or         -r RequiredFeature2"
			{ 'Feature require: '. optionArgument } print.
			[ Feature require: optionArgument ] on: exceptionToIgnoreOrNil do: [:ex | ex return] ].

		[ '-d' ] -> [		"as in 		-d ''Transcript show: 'popo1'; newLine'' -d''Transcript show: 'popo2'; newLine''        (duplicated singleQuotes should read doubleQuote)"
			{ 'Compiler evaluate: '. optionArgument } print.
			[ Compiler evaluate: optionArgument ] on: exceptionToIgnoreOrNil do: [:ex | ex return] ].

		['-l' ] -> ["file in the file"
			{ 'File in: '. optionArgument} print.
			[(CodeFile newFromFile: optionArgument asFileEntry) fileIn] on: exceptionToIgnoreOrNil do: [:ex | ex return]].

		[ '-s' ] -> [		"as in 		-s smalltalkScript.st paramAlScript1 paramAlSCript2 ''parameter to script script ->>>--// 3'' 			(duplicated singleQuotes should read doubleQuote)"
			{ 'Compiler evaluate contents of file named: '. optionArgument. ' arguments: '. self startUpScriptArguments } print.
			entry := optionArgument asFileEntry.
			entry exists ifTrue: [
				entry readStreamDo: [ :stream |
					[ Compiler evaluate: stream contentsOfEntireFile ] on: exceptionToIgnoreOrNil do: [:ex | ex return]]]].

		[ '-ud' ] -> [ DirectoryEntry setUserBaseDirectory: optionArgument asDirectoryEntry ].

		[ '-udIsBase' ] -> [ DirectoryEntry setUserBaseDirectoryAsCuisBase ].
	}
	otherwise: [].! !
!SystemDictionary methodsFor: 'startup' stamp: 'HAW 1/17/2024 20:50:59' prior: 16969521!
                setStartupStamp

	| dateAndTime |
	dateAndTime := DateAndTime now.
	StartupStamp := String streamContents: [ :stream |
		stream nextPutAll: '----STARTUP---- ('.
		dateAndTime date printOn: stream.
		stream space.
		dateAndTime time print24: true showSeconds: true on: stream.
		stream
			nextPutAll: ') as ';
			nextPutAll: self imageName ] 
! !
!SystemDictionary methodsFor: 'vm parameters' stamp: 'HAW 1/17/2024 20:43:13' prior: 16969696!
       doMixedArithmetic
	"If true, then primitives can handle the conversions:
	SmallInteger arithmeticOp: Float (Small or Boxed)
	SmallInteger compareOp: Float (Small or Boxed)
	Else, the primitive fail in case of mixed arithmetic, and conversion will be performed at image side.
	See doMixedArithmetic:
	
	Note:
		OpenSmalltalk VMs after March, 2019 can set the option and will honor it. The comparison operation behaves as if the Float was converted #asTrueFraction. This means that some rather big SmallIntegers in 64 bit systems, that can not be represented exactly as a Float will not be equal to any Float. Squeak adopted this critera. Cuis follows the more conventional, Smalltalk-80 tradition to always convert to Float if any operand is Float. Therefore Cuis needs to do 'Smalltalk doMixedArithmetic: false'.
		Previous VMs can not set the option, and will answer true when queried. But these VMs did the conversion to Float, and the requested operation in Floats. So, with these VMs, Cuis will also have the desired behavior."

	^ ((self vmParameterAt: 48) allMask: 64) not! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6165-Reference_self_andNot_Smalltalk_FromSystemDictionary-HernanWilkinson-2024Jan17-20h31m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6165] on 20 January 2024 at 12:19:48 pm'!
!ContextPart methodsFor: 'instruction decoding' stamp: 'jar 1/18/2024 17:52:20' prior: 50332496!
                     return: value from: aSender 
	"For simulation.  Roll back self to aSender and return value from it.  Execute any unwind blocks on the way.  ASSUMES aSender is a sender of self"

	| newTop |
	newTop := aSender sender.
	(aSender isDead or: [newTop isNil or: [newTop isDead]]) ifTrue: [
		^ self pc: nil; send: #cannotReturn: to: self with: {value} super: false].
	(self findNextUnwindContextUpTo: newTop) ifNotNil: [
		^ self send: #aboutToReturn:through: to: self with: {value. nil} super: false].
	self releaseTo: newTop.
	^ newTop push: value! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6166-return_from_enhancement-JaromirMatas-2024Jan20-12h18m-jar.001.cs.st----!

'From Cuis6.3 [latest update: #6165] on 22 January 2024 at 9:02:00 pm'!
!Dictionary class methodsFor: 'error descriptions' stamp: 'HAW 1/22/2024 21:00:58'!
                          keyNotFoundErrorDescriptionFor: key

	^ String streamContents: [ :strm |
			strm nextPutAll: 	'key: '.
			key printOn: strm.
			strm nextPutAll: ' not found' ]! !
!Dictionary methodsFor: 'private' stamp: 'HAW 1/22/2024 20:58:02' prior: 16848567!
          errorKeyNotFound: key

	self error: (self class keyNotFoundErrorDescriptionFor: key)! !

Dictionary removeSelector: #keyNotFoundErrorDescriptionFor:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6167-keyNotFoundErrorDescriptionAsClassMessage-HernanWilkinson-2024Jan20-13h01m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6167] on 23 January 2024 at 12:43:32 pm'!

TransferMethod subclass: #PushUpMethod
	instanceVariableNames: 'subclassesToRemoveMethodFrom methods '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #PushUpMethod category: #'Tools-Refactoring' stamp: 'Install-6168-PushUpMethodEnhancements-HernanWilkinson-2024Jan23-12h08m-HAW.001.cs.st 1/30/2024 19:37:16'!
TransferMethod subclass: #PushUpMethod
	instanceVariableNames: 'subclassesToRemoveMethodFrom methods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

TransferMethodApplier subclass: #PushUpMethodApplier
	instanceVariableNames: 'subclassesToRemoveMethodsFrom dependantMethods '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #PushUpMethodApplier category: #'Tools-Refactoring' stamp: 'Install-6168-PushUpMethodEnhancements-HernanWilkinson-2024Jan23-12h08m-HAW.001.cs.st 1/30/2024 19:37:16'!
TransferMethodApplier subclass: #PushUpMethodApplier
	instanceVariableNames: 'subclassesToRemoveMethodsFrom dependantMethods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!ParseNode methodsFor: 'testing' stamp: 'RNG 12/31/2017 19:10:30'!
                   sendsMessageToSelf: aSelector

	^ false! !
!BlockNode methodsFor: 'testing' stamp: 'RNG 12/31/2017 19:11:55' overrides: 50334523!
                              sendsMessageToSelf: aSelector

	^ self statements anySatisfy: [ :statementNode | statementNode sendsMessageToSelf: aSelector ]! !
!BlockNode class methodsFor: 'instance creation' stamp: 'RNG 1/19/2018 21:06:55'!
            empty

	^ self statements: #() returns: false! !
!MethodNode methodsFor: 'testing' stamp: 'MEGL 7/30/2023 20:56:02' overrides: 50334523!
                       sendsMessageToSelf: aSelector

	^ self block sendsMessageToSelf: aSelector! !
!SelectorNode methodsFor: 'testing' stamp: 'HAW 3/14/2019 11:14:25'!
             isNamed: aSelectorName

	^ self key = aSelectorName! !
!VariableNode class methodsFor: 'instance creation' stamp: 'RNG 1/19/2018 20:50:48'!
                    named: aString 

	^ self new name: aString; yourself! !
!MessageNode methodsFor: 'testing' stamp: 'HAW 3/14/2019 11:13:47' overrides: 50334523!
                sendsMessageToSelf: aSelector

	^ self receiver referencesSelf and: [ self selector isNamed: aSelector ]! !
!ReturnNode methodsFor: 'testing' stamp: 'MEGL 7/30/2023 20:56:22' overrides: 50334523!
                            sendsMessageToSelf: aSelector

	^expr sendsMessageToSelf: aSelector! !
!TransferMethod methodsFor: 'applying - private' stamp: 'MEGL 8/20/2023 21:13:45'!
      methodCategory: aMethod

	^aMethod methodClass organization categoryOfElement: aMethod selector! !
!TransferMethod methodsFor: 'applying - private' stamp: 'MEGL 8/20/2023 21:15:51'!
          removeMethod: aMethod

	aMethod methodClass removeSelector: aMethod selector.
 ! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'MEGL 8/21/2023 14:09:29'!
                            compileMethodInSuperclass: aMethod

	aMethod methodClass superclass
		compile: aMethod sourceCode
		classified: (self methodCategory: aMethod).! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'HAW 1/23/2024 12:40:28'!
                             pushUpMethods

	methods do: [ :methodToPushUp | 
		self 
			compileMethodInSuperclass: methodToPushUp;
			removeMethod: methodToPushUp ]! !
!PushUpMethod methodsFor: 'initialization' stamp: 'MEGL 8/21/2023 15:43:39' overrides: 16988943!
                   initializeFor: aMethods

	methods := aMethods.
	subclassesToRemoveMethodFrom := #().! !
!PushUpMethod class methodsFor: 'instance creation' stamp: 'MEGL 8/21/2023 15:44:19'!
                  for: aMethodToPushUp additionallyRemovingFrom: subclassesToRemoveMethodFrom pushingUp: dependantMethods
	
	dependantMethods add: aMethodToPushUp.

	self assertIsValidToPushUp: dependantMethods.
	self assertIsValidToRemove: subclassesToRemoveMethodFrom.
	
	^self new initializeFor: dependantMethods additionallyRemovingFrom: subclassesToRemoveMethodFrom.! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'MEGL 8/15/2023 23:52:22'!
        assert: aMethodToRemove isValidToRemoveFrom: subclassesToRemoveMethodFrom

	self assert: subclassesToRemoveMethodFrom areSiblingsOf: aMethodToRemove methodClass.
	self assert: aMethodToRemove isImplementedIn: subclassesToRemoveMethodFrom.
	self assert: aMethodToRemove isEquivalentlyImplementedIn: subclassesToRemoveMethodFrom.

! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'MEGL 8/21/2023 15:23:05'!
assertIsValidToPushUp: methods

	| instanceVariablesToPushUp methodsImplementedInSuperClass |
	
	instanceVariablesToPushUp := self selectInstanceVariablesToPushUpFrom: methods.
	
	instanceVariablesToPushUp ifNotEmpty: [ self refactoringWarning: (self accessingInstanceVariableWarningMessage: instanceVariablesToPushUp)].

	methodsImplementedInSuperClass := (methods 	select: [ 
		:method |  		self checkIfMethodIsImplementedInSuperClass: method. 
		]) collect: [:method | method selector].
		
	methodsImplementedInSuperClass ifNotEmpty: [ self refactoringWarning: (self methodWithDifferentImplementationInSuperClass: methodsImplementedInSuperClass)].
	
	
! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'MEGL 8/15/2023 23:52:58'!
                          assertIsValidToRemove: subclassesToRemoveMethodFrom

	subclassesToRemoveMethodFrom associationsDo: [:assoc | 
		self assert: assoc key isValidToRemoveFrom: assoc value].

! !
!PushUpMethod class methodsFor: 'warnings' stamp: 'MEGL 8/16/2023 00:02:00'!
    methodWithDifferentImplementationInSuperClass: methods

	^String streamContents: [ :stream |
		stream 
			nextPutAll: 'The method(s): ';
			nextPutAll: methods asCommaStringAnd;
			nextPutAll: ' have an implementation not equivalent in the superclass and will be pushed up' ]! !
!PushUpMethod class methodsFor: 'instance variables' stamp: 'MEGL 8/21/2023 15:21:28'!
                  selectAccessedInstanceVariablesThatCanBePushedUpFrom: aMethodToPushUp

	| accessedInstanceVariables |

	accessedInstanceVariables := self selectAccessedInstanceVariables: aMethodToPushUp.

	accessedInstanceVariables do: [ :variable | PushUpInstanceVariable assertCanMove: variable from: aMethodToPushUp methodClass ].

	^accessedInstanceVariables! !
!PushUpMethod class methodsFor: 'instance variables' stamp: 'MEGL 8/21/2023 15:54:51'!
           selectInstanceVariablesToPushUpFrom: methods

	^ (methods collect: 
				[:method | self selectAccessedInstanceVariablesThatCanBePushedUpFrom: method ]
	    ) asArray flatten asSet 
! !
!PushUpMethod class methodsFor: 'implemented superclass' stamp: 'MEGL 8/14/2023 00:04:24'!
            checkIfMethodIsImplementedInSuperClass: aMethodToTransfer

		aMethodToTransfer methodClass superclass
		compiledMethodAt: aMethodToTransfer selector
		ifPresent: [ :superClassMethod | ^(self shouldWarnIf: aMethodToTransfer isImplementedInSuperclassAs: superClassMethod) not]
		ifAbsent: [^false]! !
!PushUpMethod class methodsFor: 'equivalent methods' stamp: 'MEGL 8/20/2023 00:36:04'!
                              assert: aMethod implementsEquivalentMethodIn: aSubclass

	^ aSubclass ~= aMethod methodClass and: [
		aSubclass
			compiledMethodAt: aMethod selector
			ifPresent: [ :subclassMethod | subclassMethod equivalentTo: aMethod ]
			ifAbsent: [ false ]]! !
!PushUpMethod class methodsFor: 'equivalent methods' stamp: 'MEGL 8/21/2023 16:20:37'!
               selectSiblingsWithEquivalentMethod: methods

	| withEquivalentMethod |
	
	withEquivalentMethod := Dictionary new.
	
	methods do: [:method | withEquivalentMethod add: method -> 
		(method methodClass superclass subclasses select:
			[ :aSubclass | self assert: method implementsEquivalentMethodIn: aSubclass ]
		)
	].

	^withEquivalentMethod reject: [:assoc | assoc value isEmpty ].
! !
!PushUpMethod class methodsFor: 'dependant methods' stamp: 'MEGL 8/20/2023 20:52:27'!
        selectAllMessageSendsToSelfNotImplementedInSuperClassFrom: aMethodToTransfer

	| selectors |

	selectors := Set new.
	self selectDependantSelectorsFrom: aMethodToTransfer using: selectors.
	
	selectors remove: aMethodToTransfer selector.
	
	^selectors! !
!PushUpMethod class methodsFor: 'dependant methods' stamp: 'MEGL 8/21/2023 16:21:04'!
           selectDependantSelectorsFrom: aMethod using: visitedSelectors

	| selectors |

	visitedSelectors add: aMethod selector.

	selectors := self selectorsSentToSelf: aMethod.

	(selectors difference: visitedSelectors) do: [:m | self selectDependantSelectorsFrom: (aMethod methodClass >> m) using: visitedSelectors]! !
!PushUpMethod class methodsFor: 'dependant methods' stamp: 'MEGL 8/20/2023 18:41:44'!
                 selectorsSentToSelf: aMethod

	^ aMethod methodClass selectors select: [ :method | aMethod methodNode sendsMessageToSelf: method]! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/21/2023 16:00:10'!
                     askMethodsToPushUpFrom: aDependantMethods

	| answer |

	answer := PopUpMenu 
		withCaption: (self withDependantMethodsMessage: aDependantMethods) 
		chooseFrom: #('Only PushUp this method' 'PushUp this method and all the dependant methods').

	answer = 1 ifTrue: [ ^dependantMethods := Set new ].
	answer = 2 ifTrue: [ ^dependantMethods := aDependantMethods ].
	self endRequest ! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/21/2023 15:59:38'!
                           selectDependantMethods
	|methods|

	methods := ((self refactoringClass selectAllMessageSendsToSelfNotImplementedInSuperClassFrom: methodToTransfer )
	                   collect:  [:method | methodToTransfer methodClass >> method ]) asSet.

	methods ifNotEmpty: [ self askMethodsToPushUpFrom: methods ].! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/21/2023 13:57:32'!
        selectSiblingsWithEquivalentMethod
	| methods withEquivalentMethod |
	
	methods := Set withAll: dependantMethods.
	methods add: methodToTransfer.
	
	withEquivalentMethod := self refactoringClass selectSiblingsWithEquivalentMethod: methods.

	withEquivalentMethod ifNotEmpty: [ self askMethodsToRemoveFrom: withEquivalentMethod ].
! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/19/2023 16:39:15'!
            withDependantMethodsMessage: aDependantMethods

	^ String streamContents: [ :stream |
		stream
			nextPutAll: methodToTransfer selector;
			nextPutAll: ' has the following dependant method(s): ';
			nextPutAll: (aDependantMethods collect: [:method | method selector ] ) asCommaStringAnd;
			nextPutAll: '. How do you want to proceed?' ]! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/20/2023 00:39:08'!
      withEquivalentMethodsMessage: withEquivalentMethod

	^ String streamContents: [ :stream |		
		withEquivalentMethod associationsDo: [:assoc |

			stream
				nextPutAll: assoc key selector;
				nextPutAll: ' has equivalent methods declared in ';
				nextPutAll: assoc value asCommaStringAnd;
				nextPutAll: ', ' 
		].

		stream
			nextPutAll: 'how do you want to proceed?' ].! !
!TransferMethod methodsFor: 'applying - private' stamp: 'MEGL 8/20/2023 21:13:54' prior: 16988955!
   methodCategory

	^self methodCategory: method.! !
!TransferMethod methodsFor: 'applying - private' stamp: 'MEGL 8/20/2023 21:16:07' prior: 16988966!
           removeMethod

	self removeMethod: method.
 ! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'MEGL 8/21/2023 15:46:55' prior: 16934012 overrides: 16988961!
                            moveMethod

	self 
		pushUpAccessedVariables;
		pushUpMethods.! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'MEGL 8/21/2023 15:56:46' prior: 16934025!
                             pushUpAccessedVariables

	|instanceVariablesToPushUp methodClass|
	
	instanceVariablesToPushUp := self class selectInstanceVariablesToPushUpFrom: methods.
	methodClass := methods anyOne methodClass.

	instanceVariablesToPushUp do: [:var | (PushUpInstanceVariable named: var from: methodClass) apply ]! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'MEGL 8/21/2023 15:46:14' prior: 16934036 overrides: 50334843!
                           removeMethod

	subclassesToRemoveMethodFrom associationsDo:
		[:assoc | assoc value do:
			[:class | class removeSelector: assoc key selector ]
		].! !
!PushUpMethod methodsFor: 'initialization' stamp: 'MEGL 8/21/2023 15:43:06' prior: 16934043!
           initializeFor: aMethods additionallyRemovingFrom: aSubclassesToRemoveMethodFrom

	methods := aMethods.
	subclassesToRemoveMethodFrom := aSubclassesToRemoveMethodFrom.! !
!PushUpMethod class methodsFor: 'instance creation' stamp: 'MEGL 8/19/2023 17:11:17' prior: 16934057!
                for: aMethodToPushUp

	^self for: aMethodToPushUp additionallyRemovingFrom: #() pushingUp: Set new.! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'HAW 5/26/2023 17:19:38' prior: 16934083!
                       assert: subclassesToRemoveMethodFrom areSiblingsOf: aClassToPushUpMethodFrom

	| noSiblings |
	
	noSiblings := subclassesToRemoveMethodFrom reject: [ :aSubclass |
		aSubclass superclass = aClassToPushUpMethodFrom superclass ].
	
	noSiblings ifNotEmpty: [ self signalNoSiblings: noSiblings ].! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'HAW 5/26/2023 17:29:39' prior: 16934095!
                       assert: aMethodToPushUp isEquivalentlyImplementedIn: subclassesToRemoveMethodFrom
	
	| notEquivalent |
	
	notEquivalent := subclassesToRemoveMethodFrom reject: [ :aSubclass |
		aSubclass >> aMethodToPushUp selector equivalentTo: aMethodToPushUp ].
	
	notEquivalent ifNotEmpty: [ self signalNotEquivalentMethodsFor: notEquivalent ].! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'HAW 5/26/2023 17:10:49' prior: 16934109!
               assert: aMethodToPushUp isImplementedIn: subclassesToRemoveMethodFrom
	
	| subclassesNotImplementing |
	
	subclassesNotImplementing := subclassesToRemoveMethodFrom reject: [ :aSubclass | 
		aSubclass includesSelector: aMethodToPushUp selector ].
	
	subclassesNotImplementing ifNotEmpty: [
		self signalMethodCannotBeRemovedMethodFrom: subclassesNotImplementing ]
	! !
!PushUpMethod class methodsFor: 'warnings' stamp: 'MEGL 8/21/2023 15:56:56' prior: 16934123!
                   accessingInstanceVariableWarningMessage: accessedInstanceVariables

	^String streamContents: [ :stream |
		stream 
			nextPutAll: 'The instance variable(s) ';
			nextPutAll: accessedInstanceVariables asCommaStringAnd;
			nextPutAll: ' will be pushed up' ]! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 11/12/2019 11:38:58' prior: 16934160!
                              errorMessageForMethodCannotAccessInstanceVariable
	
	^ 'Can not push up a method that access an instance variable'! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:14:45' prior: 16934167!
            errorMessageForMethodCannotBeRemovedMethodFrom: subclassesNotImplementing

	^String streamContents: [ :stream |
		stream
			nextPutAll: 'Can not remove method because is not implemented in:';
			newLine.

		subclassesNotImplementing asCommaSeparated: [ :aClass | stream print: aClass ] on: stream ].
		! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:24:10' prior: 16934180!
                errorMessageForNoSiblings: noSiblings

	^String streamContents: [ :stream |
		stream
			nextPutAll: 'Can not remove method from classes that are not siblings:';
			newLine.

		noSiblings asCommaSeparated: [ :aClass | stream print: aClass ] on: stream ].
			! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:29:24' prior: 16934191!
                             errorMessageForNotEquivalentMethods: notEquivalent

	^String streamContents: [ :stream |
		stream
			nextPutAll: 'Can not remove not equivalent methods from';
			newLine.

		notEquivalent asCommaSeparated: [ :aClass | stream print: aClass ] on: stream ].
			! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'MSC 10/19/2019 23:29:03' prior: 16934202!
                           signalMethodCannotAccessInstanceVariable
	
	self refactoringError: self errorMessageForMethodCannotAccessInstanceVariable! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:11:17' prior: 16934209!
     signalMethodCannotBeRemovedMethodFrom: subclassesNotImplementing
	
	self refactoringError: (self errorMessageForMethodCannotBeRemovedMethodFrom: subclassesNotImplementing)! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:24:10' prior: 16934217!
                   signalNoSiblings: noSiblings 

	self refactoringError: (self errorMessageForNoSiblings: noSiblings)! !
!PushUpMethod class methodsFor: 'exceptions' stamp: 'HAW 5/26/2023 17:29:39' prior: 16934223!
                           signalNotEquivalentMethodsFor: notEquivalent

	self refactoringError: (self errorMessageForNotEquivalentMethods: notEquivalent)! !
!PushUpMethod class methodsFor: 'instance variables' stamp: 'MEGL 7/12/2023 16:49:35' prior: 16934134!
                      selectAccessedInstanceVariables: aMethodToPushUp

	^aMethodToPushUp methodClass instVarNames
		select: [ :instVarName |  aMethodToPushUp accessesInstanceVariable: instVarName ]! !
!PushUpMethodApplier methodsFor: 'refactoring - creation' stamp: 'MEGL 8/21/2023 16:00:33' prior: 16934239 overrides: 16989036!
            createRefactoring

	^self refactoringClass for: methodToTransfer additionallyRemovingFrom: subclassesToRemoveMethodsFrom pushingUp: dependantMethods! !
!PushUpMethodApplier methodsFor: 'refactoring - creation' stamp: 'MSC 10/14/2019 19:36:48' prior: 16934246 overrides: 16989042!
        refactoringClass

	^PushUpMethod! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/21/2023 16:00:22' prior: 16934251!
      askMethodsToRemoveFrom: withEquivalentMethod

	| answer |
	
	answer := PopUpMenu 
		withCaption: (self withEquivalentMethodsMessage: withEquivalentMethod) 
		chooseFrom: #('Only PushUp' 'PushUp and delete all equivalent methods').

	answer = 1 ifTrue: [ ^subclassesToRemoveMethodsFrom := Dictionary new ].
	answer = 2 ifTrue: [ ^subclassesToRemoveMethodsFrom := withEquivalentMethod ].
	self endRequest ! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'MEGL 8/14/2023 22:49:08' prior: 16934279 overrides: 16989047!
                               requestRefactoringParameters

	self selectDependantMethods;
		selectSiblingsWithEquivalentMethod
		! !
!PushUpMethodApplier methodsFor: 'initialization' stamp: 'MEGL 7/30/2023 21:10:14' prior: 16934306 overrides: 16932297!
 initialize 

	subclassesToRemoveMethodsFrom := #().
	dependantMethods := #()! !

TransferMethod subclass: #PushUpMethod
	instanceVariableNames: 'subclassesToRemoveMethodFrom methods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #PushUpMethod category: #'Tools-Refactoring' stamp: 'Install-6168-PushUpMethodEnhancements-HernanWilkinson-2024Jan23-12h08m-HAW.001.cs.st 1/30/2024 19:37:16'!
TransferMethod subclass: #PushUpMethod
	instanceVariableNames: 'subclassesToRemoveMethodFrom methods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

TransferMethodApplier subclass: #PushUpMethodApplier
	instanceVariableNames: 'subclassesToRemoveMethodsFrom dependantMethods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #PushUpMethodApplier category: #'Tools-Refactoring' stamp: 'Install-6168-PushUpMethodEnhancements-HernanWilkinson-2024Jan23-12h08m-HAW.001.cs.st 1/30/2024 19:37:16'!
TransferMethodApplier subclass: #PushUpMethodApplier
	instanceVariableNames: 'subclassesToRemoveMethodsFrom dependantMethods'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6168-PushUpMethodEnhancements-HernanWilkinson-2024Jan23-12h08m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6167] on 23 January 2024 at 3:42:59 pm'!
!PushUpMethod class methodsFor: 'warnings' stamp: 'HAW 1/23/2024 15:00:48'!
    methodWithDifferentImplementationInSuperclass: methods

	^String streamContents: [ :stream |
		stream 
			nextPutAll: 'The method(s): ';
			nextPutAll: methods asCommaStringAnd;
			nextPutAll: ' have an implementation not equivalent in the superclass and will be pushed up' ]! !
!PushUpMethod class methodsFor: 'warnings' stamp: 'HAW 1/23/2024 15:00:54'!
                             warnIfDifferentImplementationInSuperclass: methods

	| methodsImplementedInSuperclass |
	
	methodsImplementedInSuperclass := methods 	
		select: [ :method |  		self checkIfMethodIsImplementedInSuperclass: method ]
		thenCollect: [ :method | method selector].
		
	methodsImplementedInSuperclass ifNotEmpty: [ 
		self refactoringWarning: (self methodWithDifferentImplementationInSuperclass: methodsImplementedInSuperclass)].
	
	
! !
!PushUpMethod class methodsFor: 'warnings' stamp: 'HAW 1/23/2024 14:58:36'!
     warnIfReferencesInstanceVariables: methods

	| instanceVariablesToPushUp |
	
	instanceVariablesToPushUp := self selectInstanceVariablesToPushUpFrom: methods.
	
	instanceVariablesToPushUp ifNotEmpty: [ 
		self refactoringWarning: (self accessingInstanceVariableWarningMessage: instanceVariablesToPushUp)].

! !
!PushUpMethod class methodsFor: 'implemented superclass' stamp: 'HAW 1/23/2024 15:11:42'!
                checkIfMethodIsImplementedInSuperclass: aMethodToTransfer

	^aMethodToTransfer methodClass superclass compiledMethodAt: aMethodToTransfer selector
		ifPresent: [ :superClassMethod | (self shouldWarnIf: aMethodToTransfer isImplementedInSuperclassAs: superClassMethod) not]
		ifAbsent: [ false ]! !
!PushUpMethod class methodsFor: 'equivalent methods' stamp: 'HAW 1/23/2024 15:21:15'!
 equivalentMethodsOfSiblingsOfAll: methods

	| allEquivalentMethods |
	
	allEquivalentMethods := Dictionary new.
	
	methods do: [:method | | equivalentMethods |
		equivalentMethods := method methodClass superclass subclasses select: [ :aSubclass | self is: method equivalentIn: aSubclass ].
		equivalentMethods ifNotEmpty: [ allEquivalentMethods at: method put: equivalentMethods ]].

	^allEquivalentMethods ! !
!PushUpMethod class methodsFor: 'equivalent methods' stamp: 'HAW 1/23/2024 15:21:01'!
               is: aMethod equivalentIn: aSubclass

	^ aSubclass ~= aMethod methodClass and: [
		aSubclass
			compiledMethodAt: aMethod selector
			ifPresent: [ :subclassMethod | subclassMethod equivalentTo: aMethod ]
			ifAbsent: [ false ]]! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'HAW 1/23/2024 15:31:30' prior: 50334869 overrides: 50334843!
      removeMethod

	subclassesToRemoveMethodFrom keysAndValuesDo: [ :methodWithSelectorToRemove :classesToRemoveMethodFrom |
		classesToRemoveMethodFrom do: [ :aClassToRemoveMethodFrom | 
			aClassToRemoveMethodFrom removeSelector: methodWithSelectorToRemove selector ]].
	
	! !
!PushUpMethod class methodsFor: 'instance creation' stamp: 'HAW 1/23/2024 15:36:00' prior: 50334886!
         for: aMethodToPushUp

	^self for: aMethodToPushUp additionallyRemovingFrom: Dictionary new pushingUp: Set new.! !
!PushUpMethod class methodsFor: 'pre-conditions' stamp: 'HAW 1/23/2024 15:01:14' prior: 50334628!
            assertIsValidToPushUp: methods

	self warnIfReferencesInstanceVariables: methods.
	self warnIfDifferentImplementationInSuperclass: methods! !
!PushUpMethod class methodsFor: 'instance variables' stamp: 'HAW 1/23/2024 15:10:16' prior: 50334686!
            selectInstanceVariablesToPushUpFrom: methods

	^ (methods collect: [:method | self selectAccessedInstanceVariablesThatCanBePushedUpFrom: method ]) asArray flatten asSet 
! !
!PushUpMethod class methodsFor: 'dependant methods' stamp: 'HAW 1/23/2024 15:22:52' prior: 50334745!
             selectDependantSelectorsFrom: aMethod using: visitedSelectors

	| selectors |

	visitedSelectors add: aMethod selector.

	selectors := self selectorsSentToSelf: aMethod.

	(selectors difference: visitedSelectors) do: [:selector | 
		self selectDependantSelectorsFrom: aMethod methodClass >> selector using: visitedSelectors]! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/23/2024 15:40:29' prior: 50335064 overrides: 16989047!
               requestRefactoringParameters

	self 
		selectDependantMethods;
		selectSiblingsWithEquivalentMethod
		! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/23/2024 15:41:47' prior: 50334782!
 selectDependantMethods

	| methods |

	methods := ((self refactoringClass selectAllMessageSendsToSelfNotImplementedInSuperClassFrom: methodToTransfer )
	                   collect: [ :selector | methodToTransfer methodClass >> selector ]) asSet.

	methods ifNotEmpty: [ self askMethodsToPushUpFrom: methods ].! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/23/2024 15:41:56' prior: 50334795!
                  selectSiblingsWithEquivalentMethod

	| methods withEquivalentMethod |
	
	methods := Set withAll: dependantMethods.
	methods add: methodToTransfer.
	
	withEquivalentMethod := self refactoringClass equivalentMethodsOfSiblingsOfAll: methods.

	withEquivalentMethod ifNotEmpty: [ self askMethodsToRemoveFrom: withEquivalentMethod ].
! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/23/2024 12:58:14' prior: 50334809!
                              withDependantMethodsMessage: aDependantMethods

	^ String streamContents: [ :stream |
		stream
			nextPutAll: methodToTransfer selector;
			nextPutAll: ' has the following dependant method(s): ';
			newLine;
			nextPutAll: (aDependantMethods collect: [:method | method selector ] ) asCommaStringAnd;
			newLine;
			nextPutAll: 'How do you want to proceed?' ]! !
!PushUpMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 1/23/2024 12:54:23' prior: 50334823!
 withEquivalentMethodsMessage: withEquivalentMethod

	^ String streamContents: [ :stream |		
		withEquivalentMethod associationsDo: [:assoc |
			stream
				nextPutAll: assoc key selector;
				nextPutAll: ' has equivalent methods declared in ';
				nextPutAll: assoc value asCommaStringAnd;
				newLine.
		].
		stream nextPutAll: 'How do you want to proceed?' ].! !
!PushUpMethodApplier methodsFor: 'initialization' stamp: 'HAW 1/23/2024 12:48:06' prior: 50335071 overrides: 16932297!
                             initialize 

	subclassesToRemoveMethodsFrom := Dictionary new.
	dependantMethods := Set new.! !

PushUpMethodApplier removeSelector: #withEquivalentMethodMessage:!

!methodRemoval: PushUpMethodApplier #withEquivalentMethodMessage: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:37:17'!
withEquivalentMethodMessage: withEquivalentMethod

	^ String streamContents: [ :stream |
		stream
			nextPutAll: methodToTransfer selector;
			nextPutAll: ' has equivalent methods declared in '.
		withEquivalentMethod asCommaSeparated:  [:aClass| stream print: aClass] on: stream.
		stream
			newLine;
			nextPutAll: 'How do you want to proceed?' ]!

PushUpMethod class removeSelector: #assert:implementsEquivalentMethodIn:!

!methodRemoval: PushUpMethod class #assert:implementsEquivalentMethodIn: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:37:17'!
assert: aMethod implementsEquivalentMethodIn: aSubclass

	^ aSubclass ~= aMethod methodClass and: [
		aSubclass
			compiledMethodAt: aMethod selector
			ifPresent: [ :subclassMethod | subclassMethod equivalentTo: aMethod ]
			ifAbsent: [ false ]]!

PushUpMethod class removeSelector: #selectSiblingsWithEquivalentMethod:!

!methodRemoval: PushUpMethod class #selectSiblingsWithEquivalentMethod: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:37:17'!
selectSiblingsWithEquivalentMethod: methods

	| withEquivalentMethod |
	
	withEquivalentMethod := Dictionary new.
	
	methods do: [:method | withEquivalentMethod add: method -> 
		(method methodClass superclass subclasses select:
			[ :aSubclass | self assert: method implementsEquivalentMethodIn: aSubclass ]
		)
	].

	^withEquivalentMethod reject: [:assoc | assoc value isEmpty ].
!

PushUpMethod class removeSelector: #errorMessageForMethodCannotAccessInstanceVariable!

!methodRemoval: PushUpMethod class #errorMessageForMethodCannotAccessInstanceVariable stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:37:17'!
errorMessageForMethodCannotAccessInstanceVariable
	
	^ 'Can not push up a method that access an instance variable'!

PushUpMethod class removeSelector: #warnIfMethodAccessInstanceVariable:!

!methodRemoval: PushUpMethod class #warnIfMethodAccessInstanceVariable: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:37:17'!
warnIfMethodAccessInstanceVariable: aMethodToPushUp

	| accessedInstanceVariables |

	accessedInstanceVariables := self selectAccessedInstanceVariables: aMethodToPushUp.

	accessedInstanceVariables isEmpty ifTrue: [^self].
	
	accessedInstanceVariables do: [ :variable | PushUpInstanceVariable assertCanMove: variable from: aMethodToPushUp methodClass ].

	self refactoringWarning: (self accessingInstanceVariableWarningMessage: accessedInstanceVariables)!

PushUpMethod class removeSelector: #for:additionallyRemovingFrom:!

!methodRemoval: PushUpMethod class #for:additionallyRemovingFrom: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:37:17'!
for: aMethodToPushUp additionallyRemovingFrom: subclassesToRemoveMethodFrom

	self warnIfMethodAccessInstanceVariable: aMethodToPushUp.
	self assert: subclassesToRemoveMethodFrom areSiblingsOf: aMethodToPushUp methodClass.
	self assert: aMethodToPushUp isImplementedIn: subclassesToRemoveMethodFrom.
	self assert: aMethodToPushUp isEquivalentlyImplementedIn: subclassesToRemoveMethodFrom.
	self warnIfMethodIsImplementedInSuperClass: aMethodToPushUp.

	^self new initializeFor: aMethodToPushUp additionallyRemovingFrom: subclassesToRemoveMethodFrom.!

PushUpMethod class removeSelector: #methodWithDifferentImplementationInSuperClass:!

!methodRemoval: PushUpMethod class #methodWithDifferentImplementationInSuperClass: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:37:17'!
methodWithDifferentImplementationInSuperClass: methods

	^String streamContents: [ :stream |
		stream 
			nextPutAll: 'The method(s): ';
			nextPutAll: methods asCommaStringAnd;
			nextPutAll: ' have an implementation not equivalent in the superclass and will be pushed up' ]!

PushUpMethod class removeSelector: #signalMethodCannotAccessInstanceVariable!

!methodRemoval: PushUpMethod class #signalMethodCannotAccessInstanceVariable stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:37:17'!
signalMethodCannotAccessInstanceVariable
	
	self refactoringError: self errorMessageForMethodCannotAccessInstanceVariable!

PushUpMethod class removeSelector: #checkIfMethodIsImplementedInSuperClass:!

!methodRemoval: PushUpMethod class #checkIfMethodIsImplementedInSuperClass: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:37:17'!
checkIfMethodIsImplementedInSuperClass: aMethodToTransfer

		aMethodToTransfer methodClass superclass
		compiledMethodAt: aMethodToTransfer selector
		ifPresent: [ :superClassMethod | ^(self shouldWarnIf: aMethodToTransfer isImplementedInSuperclassAs: superClassMethod) not]
		ifAbsent: [^false]!

PushUpMethod removeSelector: #initializeFor:!

!methodRemoval: PushUpMethod #initializeFor: stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:37:17'!
initializeFor: aMethods

	methods := aMethods.
	subclassesToRemoveMethodFrom := #().!

PushUpMethod removeSelector: #moveMethodAfterMovingAccessedVariables!

!methodRemoval: PushUpMethod #moveMethodAfterMovingAccessedVariables stamp: 'Install-6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st 1/30/2024 19:37:17'!
moveMethodAfterMovingAccessedVariables

	method methodClass superclass
		compile: method sourceCode
		classified: self methodCategory!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6169-PushUpMethodEnhancements2-HernanWilkinson-2024Jan23-12h45m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6169] on 24 January 2024 at 8:01:30 pm'!
!SystemDictionary methodsFor: 'sources, change log' stamp: 'HAW 1/24/2024 19:58:35'!
                    logToUserChanges: aString preamble: preambleOrNil

	"This message is used by TDD-Guru, do not remove it without looking at it - Hernan"
	Utilities logsUserChanges ifTrue: [
		DirectoryEntry userChangesDirectory // self userChangesFileName appendStreamDo: [ :stream |
			stream newLine; newLine.
			preambleOrNil ifNotNil: [
				stream nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			stream nextChunkPut: aString.
			stream flush ]]! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'HAW 1/24/2024 19:57:41' prior: 50333974!
                               logChange: aStringOrText preamble: preambleOrNil
	"Write the argument, aString, onto the changes file."
	| aString changesFile |
	self assureStartupStampLogged.
	aString := aStringOrText asPlainString.
	aString firstNonSeparator = 0 ifTrue: [^ self].  "null doits confuse replay"
	
	(SourceFiles notNil and: [(changesFile := SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			preambleOrNil ifNotNil: [
				changesFile nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			changesFile nextChunkPut: aString.
			self forceChangesToDisk ]].
	self logToUserChanges: aString preamble: preambleOrNil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6170-SpecificMessageToLogChangeToUserChanges-HernanWilkinson-2024Jan24-19h57m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6163] on 4 January 2024 at 1:05:03 pm'!
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 1/4/2024 13:04:10' prior: 16827682!
          browseVersions
	"Create and schedule a Versions Browser, showing all versions of the 
	currently selected message. Answer the browser or nil."
	| method class |
	model selectedMessageName isNil ifTrue: [
		^ VersionsBrowserWindow
			browseCommentOf: model selectedClass ].
	method := model currentCompiledMethod.
	class := method methodClass.
	^ VersionsBrowserWindow
		browseVersionsOf: method
		class: class
		meta: class isMeta
		category: (class organization categoryOfElement: method selector)
		selector: method selector! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6171-ClassCommentVersionsBrowser-fix-JuanVuletich-2024Jan04-13h04m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6164] on 4 January 2024 at 4:33:20 pm'!
!ClassBuilder methodsFor: 'class format' stamp: 'jmv 1/4/2024 15:17:52'!
               computeFormat: type instSize: newInstSize forSuper: newSuper
	"Compute the new format for making oldClass a subclass of newSuper.
	Return the format or nil if there is any problem."

	^ self computeFormat: type fullInstancesSize: (newInstSize + (newSuper ifNil: [0] ifNotNil: [newSuper instSize]))! !
!ProtoObject methodsFor: 'comparing' stamp: 'jmv 1/4/2024 16:19:39' prior: 16932359!
                              identityHash
	"Answer a SmallInteger whose value is related to the receiver's identity.
	This method must not be overridden, except by immediate classes such as
	SmallInteger, Character and SmallFloat64.
	Primitive. Fails if the receiver is a SmallInteger. Essential.
	See Object documentation whatIsAPrimitive.

	Do not override."

	<primitive: 75>
	self primitiveFailed! !
!Behavior methodsFor: 'accessing' stamp: 'jmv 1/4/2024 15:32:35' prior: 16786925!
                       typeOfClass
	"Answer a symbol uniquely describing the type of the receiver. c.f. kindOfSubclass, instSpec"
	^(#(normal
		normal
		variable
		variable
		weak
		ephemeron
		nil
		immediate
		nil
		longs
		words				nil
		shorts				nil nil nil
		bytes				nil nil nil nil nil nil nil
		compiledMethod	nil nil nil nil nil nil nil)
			at: self instSpec + 1) ifNil:
				[self error: 'invalid class type']! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:26:02' prior: 16786978!
instSize
	"Answer the number of named instance variables
	(as opposed to indexed variables) of the receiver.
	Class format is
		<5 bits inst spec><16 bits inst size>"

	^ format bitAnd: 16rFFFF! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:27:16' prior: 16787001!
           instSpec
	"Answer the instance specification part of the format that defines what kind of object
	 an instance of the receiver is."
	"The formats are
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)					(plus one odd bit, unused in 32-bits)
		12-15	= 16-bit indexable							(plus two odd bits, one unused in 32-bits)
		16-23	= 8-bit indexable							(plus three odd bits, one unused in 32-bits)
		24-31	= compiled methods (CompiledMethod)	(plus three odd bits, one unused in 32-bits)
	 Note that in the VM instances also have a 5 bit format field that relates to their class's format.
	 Formats 11, 13-15, 17-23 & 25-31 are unused in classes but used in instances to define the
	 number of elements missing up to the slot size.  For example, a 2-byte ByteString instance
	 has format 18 in 32-bits, since its size is one 32-bit slot - 2 bytes ((18 bitAnd: 3) = 2), and
	 22 in 64 bits, since its size is one 64-bit slot - 6 bytes ((22 bitAnd: 7) = 6)."

	^(format bitShift: -16) bitAnd: 16r1F! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:28:45' prior: 16787058!
                isBits
	"Answer whether the receiver contains just bits (not pointers).
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec >= 7! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:28:31' prior: 16787089!
   isBytes
	"Answer whether the receiver contains just bits (not pointers).
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec >= 16! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:28:35' prior: 16787126!
 isDoubleBytes
	"Answer whether the receiver's instances indexed 16-bit integer instance variables.
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec = 12! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:28:18' prior: 16787156!
        isDoubleWords
	"Answer whether the receiver's instances indexed 64-bit integer instance variables.
	 The class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec = 9! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:10:32' prior: 16787254!
       isVariable
	"Answer whether the receiver has indexable variables.
	 Class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"
	| instSpec |
	instSpec := self instSpec.
	^instSpec >= 2 and: [instSpec <= 4 or: [instSpec >= 9]]! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 16:08:47' prior: 16787304!
                               isWords
	"Answer whether the receiver's instances indexed 32-bit integer instance variables.
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec = 10! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 15:24:23' prior: 16787335!
              shouldNotBeRedefined
	"Return true if the receiver should not be redefined.
	The assumption is that classes in Smalltalk specialObjects and 
	Behaviors should not be redefined"

	^(Smalltalk specialObjectsArray identityIncludes: self)
			or: [self isKindOf: self]! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'jmv 1/4/2024 16:08:12' prior: 16788482!
           byteSizeOfInstance
	"Answer the total memory size of an instance of the receiver."

	<primitive: 181 error: ec>
	self isVariable ifTrue:
		[^self byteSizeOfInstanceOfSize: 0].
	self primitiveFailed! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'jmv 1/4/2024 16:08:18' prior: 16788492!
             byteSizeOfInstanceOfSize: basicSize
	"Answer the total memory size of an instance of the receiver
	 with the given number of indexable instance variables."

	<primitive: 181 error: ec>
	self isVariable
		ifTrue: "If the primitive overflowed answer a close approximation"
			[(basicSize isInteger
			  and: [basicSize >= 16r1000000]) ifTrue:
				[^2 * (self byteSizeOfInstanceOfSize: basicSize + 1 // 2)
				   - (self byteSizeOfInstanceOfSize: 0)]]
		ifFalse:
			[basicSize = 0 ifTrue:
				[^self byteSizeOfInstance]].
	self primitiveFailed! !
!Behavior methodsFor: 'testing class hierarchy' stamp: 'jmv 1/4/2024 15:31:55' prior: 16788727!
kindOfSubclass
	"Answer a String that is the keyword that describes the receiver's kind of subclass,
	 either a regular subclass, a variableSubclass, a variableByteSubclass,
	 a variableWordSubclass, a weakSubclass, an ephemeronSubclass or an immediateSubclass.
	 c.f. typeOfClass & instSpec"
	^(#(' subclass: '
		' subclass: '
		' variableSubclass: '
		' variableSubclass: '
		' weakSubclass: '
		' ephemeronSubclass: '
		nil
		' immediateSubclass: '
		nil
		' variableDoubleWordSubclass: '
		' variableWordSubclass: '		nil
		' variableDoubleByteSubclass: '	nil nil nil
		' variableByteSubclass: '		nil nil nil nil nil nil nil
		' variableByteSubclass: '		nil nil nil nil nil nil nil )
			at: self instSpec + 1) ifNil:
				[self error: 'invalid class type']! !
!Behavior methodsFor: 'comparing' stamp: 'jmv 1/4/2024 16:08:35' prior: 16789595 overrides: 50335605!
identityHash
	"Answer a SmallInteger whose value is related to the receiver's identity.
	 Behavior implements identityHash to allow the VM to use an object representation which
	 does not include a direct reference to an object's class in an object.  If the VM is using
	 this implementation then classes are held in a class table and instances contain the index
	 of their class in the table.  A class's class table index is its identityHash so that an instance
	 can be created without searching the table for a class's index.  The VM uses this primitive
	 to enter the class into the class table, assigning its identityHash with an as yet unused
	 class table index. If this primitive fails it means that the class table is full.
	 There are 22 bits of classTable index and 22 bits of identityHash per object.

	 Primitive. Essential. Do not override. See Object documentation whatIsAPrimitive."

	<primitive: 175>
	self primitiveFailed.! !
!Class methodsFor: 'subclass creation' stamp: 'jmv 1/4/2024 15:55:01' prior: 16815497!
                         immediateSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 
	"This is the standard initialization message for creating a new
	 immediate class as a subclass of an existing class (the receiver)."

	| answer |
	answer := ClassBuilder new
			superclass: self
			immediateSubclass: t
			instanceVariableNames: ''
			classVariableNames: d
			poolDictionaries: s
			category: cat.
		
	Smalltalk
		logChange: answer definition 
		preamble: answer definitionPreamble.
	^answer! !
!Class methodsFor: 'subclass creation' stamp: 'jmv 1/4/2024 15:44:55' prior: 16815525!
      subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class (the receiver)."

	| answer |
	answer := ClassBuilder new
		superclass: self
		subclass: t
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat.

	Smalltalk
		logChange: answer definition
		preamble: answer definitionPreamble.
	^answer 
	
! !
!Class methodsFor: 'subclass creation' stamp: 'jmv 1/4/2024 15:45:17' prior: 16815565!
        variableDoubleByteSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class (the receiver) in which the subclass is to 
	have indexable double-byte-sized (16 bits) nonpointer variables."
	
	| answer |
	answer := ClassBuilder new
		superclass: self
		variableDoubleByteSubclass: t
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat.
		
	Smalltalk
		logChange: answer definition 
		preamble: answer definitionPreamble.
	^answer
! !
!Class methodsFor: 'subclass creation' stamp: 'jmv 1/4/2024 15:45:26' prior: 16815588!
    variableDoubleWordSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class (the receiver) in which the subclass is to 
	have indexable double-word-sized (64 bits) nonpointer variables."

	| answer |
	answer := ClassBuilder new
		superclass: self
		variableDoubleWordSubclass: t
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat.
		
	Smalltalk
		logChange: answer definition 
		preamble: answer definitionPreamble.
	^answer! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 1/4/2024 15:16:50' prior: 16816449!
needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass
	"Answer whether we need a new subclass to conform to the requested changes"
	| newFormat |
	"Compute the format of the new class"
	newFormat := 
		self computeFormat: type 
			instSize: instVars size 
			forSuper: newSuper .
	newFormat
		ifNil: [^ nil].

	"Check if we really need a new subclass"
	oldClass ifNil:[^true]. "yes, it's a new class"
	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"
	newFormat = oldClass format ifFalse:[^true]. "yes, it's a format change"
	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"

	^false
! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 1/4/2024 15:18:32' prior: 16816475!
 newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass
	"Create a new subclass of the given superclass with the given specification."
	| newFormat newClass |
	"Compute the format of the new class"
	newFormat := 
		self computeFormat: type 
			instSize: instVars size 
			forSuper: newSuper.

	newFormat
		ifNil: [^ nil].

	(oldClass == nil or:[oldClass isMeta not]) 
		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]
		ifFalse:[newClass := oldClass shallowCopy].

	newClass 
		superclass: newSuper
		methodDictionary: MethodDictionary new
		format: newFormat;
		setInstVarNames: instVars.

	oldClass ifNotNil:[
		newClass organization: oldClass organization.
		"Recompile the new class"
		oldClass hasMethods 
			ifTrue:[newClass compileAllFrom: oldClass].
		self recordClass: oldClass replacedBy: newClass.
	].

	(oldClass == nil or:[oldClass isObsolete not]) 
		ifTrue:[newSuper addSubclass: newClass]
		ifFalse:[newSuper addObsoleteSubclass: newClass].

	^newClass! !
!ClassBuilder methodsFor: 'class format' stamp: 'jmv 1/4/2024 16:09:36' prior: 16816620!
             computeFormat: type fullInstancesSize: newInstSize
	"Compute the new format for making oldClass a subclass of newSuper.
	 Answer the format or nil if there is any problem."

	| isVar isPointers isWeak bitsUnitSize |
	type == #compiledMethod ifTrue: [
		newInstSize > 0 ifTrue: [
			self error: 'A compiled method class cannot have named instance variables'.
			^nil].
		^CompiledMethod format].
	newInstSize > 65535 ifTrue: [
		self error: 'Class has too many instance variables (', newInstSize printString,')'.
		^nil].
	type == #normal ifTrue:[isVar := isWeak := false. isPointers := true].
	type == #bytes ifTrue:[isVar := true. bitsUnitSize := 1. isPointers := isWeak := false].
	type == #shorts ifTrue:[isVar := true. bitsUnitSize := 2. isPointers := isWeak := false].
	type == #words ifTrue:[isVar := true. bitsUnitSize := 4. isPointers := isWeak := false].
	type == #longs ifTrue:[isVar := true. bitsUnitSize := 8. isPointers := isWeak := false].
	type == #variable ifTrue:[isVar := isPointers := true. isWeak := false].
	type == #weak ifTrue:[isVar := isWeak := isPointers := true].
	type == #ephemeron ifTrue:[isVar := false. isWeak := isPointers := true].
	type == #immediate ifTrue:[isVar := isWeak := isPointers := false].
	isVar ifNil: [ self error: 'Unsupported class format type: ', type. ^ nil ].
	(isPointers not and: [newInstSize > 0]) ifTrue: [
		self error: 'A non-pointer class cannot have named instance variables'.
		^nil].
	^self format: newInstSize variable: isVar bitsUnitSize: bitsUnitSize pointers: isPointers weak: isWeak! !
!ClassBuilder methodsFor: 'class format' stamp: 'jmv 1/4/2024 16:13:22' prior: 16816720!
                     format: nInstVars variable: isVar bitsUnitSize: bitsUnitSize pointers: isPointers weak: isWeak

	"Compute the format for the given instance specfication.
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character, SmallFloat64)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap, WideString)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable (ByteString)
		24-31	= compiled methods (CompiledMethod)"
	| instSpec |
	instSpec := isWeak
					ifTrue:
						[isVar
							ifTrue: [4]
							ifFalse: [5]]
					ifFalse:
						[isPointers
							ifTrue:
								[isVar
									ifTrue: [nInstVars > 0 ifTrue: [3] ifFalse: [2]]
									ifFalse: [nInstVars > 0 ifTrue: [1] ifFalse: [0]]]
							ifFalse:
								[isVar
									ifTrue: [bitsUnitSize caseOf: {
											[1] -> [16].
											[2] -> [12].
											[4] -> [10].
											[8] -> [9] }]
									ifFalse: [7]]].
	^(instSpec bitShift: 16) + nInstVars! !
!ClassBuilder methodsFor: 'private' stamp: 'jmv 1/4/2024 15:17:05' prior: 16817029!
                             privateNewSubclassOf: newSuper from: oldClass
	"Create a new meta and non-meta subclass of newSuper using oldClass as template"
	"WARNING: This method does not preserve the superclass/subclass invariant!!"
	| newSuperMeta oldMeta newMeta |
	oldClass ifNil:[^self privateNewSubclassOf: newSuper].
	newSuperMeta := newSuper ifNil:[Class] ifNotNil:[newSuper class].
	oldMeta := oldClass class.
	newMeta := oldMeta shallowCopy.
	newMeta 
		superclass: newSuperMeta
		methodDictionary: MethodDictionary new
		format: (self computeFormat: oldMeta typeOfClass 
					instSize: oldMeta instVarNames size 
					forSuper: newSuperMeta);
		setInstVarNames: oldMeta instVarNames;
		organization: oldMeta organization.
	"Recompile the meta class"
	oldMeta hasMethods 
		ifTrue:[newMeta compileAllFrom: oldMeta].
	"Record the meta class change"
	self recordClass: oldMeta replacedBy: newMeta.
	"And create a new instance"
	^newMeta adoptInstance: oldClass from: oldMeta! !
!ClassBuilder methodsFor: 'public' stamp: 'jmv 1/4/2024 15:35:25' prior: 16817131!
               superclass: aClass
	ephemeronSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class (the receiver) in which the subclass is to 
	have ephemeron semantics, i.e. where the object will be queued for
	finalization when the key (first) inst var is not reachable other than through
	the other fields of ephemerons with unreachable keys."

	aClass isPointers
		ifFalse: [^ self error: 'cannot make a pointer subclass of a class with non-pointer fields'].
	aClass instSize + f substrings size < 2
		ifTrue: [^ self error: 'cannot make an ephemeron class with less than two named instance varaibles'].
	^self 
		name: t
		subclassOf: aClass
		type: #ephemeron
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat! !
!ClassBuilder methodsFor: 'public' stamp: 'jmv 1/4/2024 15:35:41' prior: 16817170!
                  superclass: aClass
	immediateSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a
	 new immediate class as a subclass of an existing class."

	aClass instSize > 0
		ifTrue: [^self error: 'cannot make an immediate subclass of a class with named fields'].
	aClass isVariable
		ifTrue: [^self error: 'cannot make an immediate subclass of a class with indexed instance variables'].
	aClass isPointers
		ifFalse: [^self error: 'cannot make an immediate subclass of a class without pointer fields'].

	^self 
		name: t
		subclassOf: aClass
		type: #immediate
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat! !
!ClassBuilder methodsFor: 'public' stamp: 'jmv 1/4/2024 16:13:46' prior: 16817254!
 superclass: aClass
	variableDoubleByteSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class in which the subclass is to 
	have indexable double-byte-sized (16 bit) nonpointer variables."

	(aClass instSize > 0)
		ifTrue: [^self error: 'cannot make a 16-bit word subclass of a class with named fields'].
	(aClass isVariable and: [aClass isPointers])
		ifTrue: [^self error: 'cannot make a 16-bit word subclass of a class with pointer fields'].
	(aClass isVariable and: [aClass isDoubleBytes not])
		ifTrue: [^self error: 'cannot make a 16-bit word subclass of a class with 8, 32 or 64 bit fields'].

	^self 
		name: t
		subclassOf: aClass
		type: #shorts
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat! !
!ClassBuilder methodsFor: 'public' stamp: 'jmv 1/4/2024 16:13:52' prior: 16817286!
              superclass: aClass
	variableDoubleWordSubclass: t instanceVariableNames: f 
	classVariableNames: d poolDictionaries: s category: cat
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class in which the subclass is to 
	have indexable double-word-sized (64 bit) nonpointer variables."

	(aClass instSize > 0)
		ifTrue: [^self error: 'cannot make a 64-bit word subclass of a class with named fields'].
	(aClass isVariable and: [aClass isPointers])
		ifTrue: [^self error: 'cannot make a 64-bit word subclass of a class with pointer fields'].
	(aClass isVariable and: [aClass isDoubleWords not])
		ifTrue: [^self error: 'cannot make a 64-bit word subclass of a class with 8, 16 or 32 bit fields'].

	^self 
		name: t
		subclassOf: aClass
		type: #longs
		instanceVariableNames: f
		classVariableNames: d
		poolDictionaries: s
		category: cat! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'jmv 1/4/2024 15:57:44' prior: 16817485!
       update: oldClass to: newClass
	"Convert oldClass, all its instances and possibly its meta class into newClass,
	 instances of newClass and possibly its meta class. The process is surprisingly
	 simple in its implementation and surprisingly complex in its nuances and potentially
	 bad side effects.
	 We can rely on two assumptions (which are critical):
		#1: The method #updateInstancesFrom: will not create any lasting pointers to
			 'old' instances ('old' is quote on quote since #updateInstancesFrom: will do
			 a become of the old vs. the new instances and therefore it will not create
			 pointers to *new* instances before the #become: which are *old* afterwards)
		#2: The non-preemptive execution of the critical piece of code guarantees that
			 nobody can get a hold by 'other means' (such as process interruption and
			 reflection) on the old instances.
	 Given the above two, we know that after #updateInstancesFrom: there are no pointers
	 to any old instances. After the forwarding become there will be no pointers to the old
	 class or meta class either.
	 Andreas Raab, 2/27/2003 23:42"
	| meta allInstances |
	meta := oldClass isMeta.
	"Note: Everything from here on will run without the ability to get interrupted
	to prevent any other process to create new instances of the old class."
	["Note: The following removal may look somewhat obscure and needs an explanation.
	  When we mutate the class hierarchy we create new classes for any existing subclass.
	  So it may look as if we don't have to remove the old class from its superclass. However,
	  at the top of the hierarchy (the first class we reshape) that superclass itself is not newly
	  created so therefore it will hold both the oldClass and newClass in its (obsolete or not)
	  subclasses. Since the #become: below will transparently replace the pointers to oldClass
	  with newClass the superclass would have newClass in its subclasses TWICE. With rather
	  unclear effects if we consider that we may convert the meta-class hierarchy itself (which
	  is derived from the non-meta class hierarchy).
	  Due to this problem ALL classes are removed from their superclass just prior to converting
	  them. Here, breaking the superclass/subclass invariant really doesn't matter since we will
	  effectively remove the oldClass (becomeForward:) just a few lines below."

		"Convert the instances of oldClass into instances of newClass.
		Note: #canUpdateFrom: has already been called. Instance mutation is safe wrt methods currently in execution."
		allInstances := oldClass allInstances.
		allInstances notEmpty ifTrue: [
			newClass updateInstances: allInstances asArray from: oldClass isMeta: meta ].

		oldClass superclass removeSubclass: oldClass.
		oldClass superclass removeObsoleteSubclass: oldClass.

		"make sure that the VM cache is clean"
		oldClass methodDict do: [:cm | cm flushCache].

		meta
			ifTrue: [
				oldClass becomeForward: newClass.
				oldClass updateMethodBindingsTo: oldClass binding]
			ifFalse: [
				{oldClass. oldClass class} elementsForwardIdentityTo: {newClass. newClass class}.
				oldClass updateMethodBindingsTo: oldClass binding.
				oldClass class updateMethodBindingsTo: oldClass class binding].

		"eem 5/31/2014 07:22 At this point there used to be a garbage collect whose purpose was
		 to ensure no old instances existed after the becomeForward:.  Without the GC it was possible
		 to resurrect old instances using e.g. allInstancesDo:.  This was because the becomeForward:
		 updated references from the old objects to new objects but didn't destroy the old objects.
		 But as of late 2013/early 2014 becomeForward: has been modified to free all the old objects."
	] valueUnpreemptively! !
!Character methodsFor: 'accessing' stamp: 'jmv 1/4/2024 16:16:33' prior: 16810809!
          numericValue
	"Answer the value of the receiver that represents its ISO 8859-15 (Latin-9) encoding."

	<primitive: 171>
	^self primitiveFailed! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/4/2024 15:12:44' prior: 16810868 overrides: 50335605!
       identityHash
	"Answer the receiver's character code."

	<primitive: 171>! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/4/2024 16:17:57' prior: 16811309!
                   numericValue: anInteger
	"Answer the Character whose value is anInteger."

	<primitive: 170>
	^self primitiveFailed! !
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 1/4/2024 15:38:13' prior: 16833463!
                 numLiterals
	"Answer the number of literals used by the receiver."

	^ self header bitAnd: 16r7FFF! !
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 1/4/2024 15:38:37' prior: 16833479!
  primitive
	"Answer the primitive index associated with the receiver.
	Zero indicates that this is not a primitive method."

	| initialPC |
	^(self header anyMask: 65536) "Is the hasPrimitive? flag set?"
		ifTrue: [(self at: (initialPC := self initialPC) + 1) + ((self at: initialPC + 2) bitShift: 8)]
		ifFalse: [0]! !
!CompiledMethod class methodsFor: 'instance creation' stamp: 'jmv 1/4/2024 15:37:18' prior: 16835757!
                           newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex
	"Answer an instance of me. The header is specified by the message 
	 arguments. The remaining parts are not as yet determined."
	| method pc |
"15 | 63 | 32767"
	nArgs > 15
		ifTrue: [^self error: 'Cannot compile -- too many arguments'].
	nTemps > 63
		ifTrue: [^self error: 'Cannot compile -- too many temporary variables'].	
	nLits > 32767
		ifTrue: [^self error: 'Cannot compile -- too many literals'].

	method := self
				createMethod: numberOfBytes
				trailer: trailer
				header:    (nArgs bitShift: 24)
						+ (nTemps bitShift: 18)
						+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])
						+ nLits
						+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0]).
	primitiveIndex > 0 ifTrue: [
		pc := method initialPC.
		method
			at: pc + 0 put: method encoderClass callPrimitiveCode;
			at: pc + 1 put: (primitiveIndex bitAnd: 16rFF);
			at: pc + 2 put: (primitiveIndex bitShift: -8)].
	^method! !
!CompiledMethod class methodsFor: 'constants' stamp: 'jmv 1/4/2024 16:21:20' prior: 16836304!
               maxNumLiterals
	"The current header format and the VM's interpretation of it allows for a maximum of 32767 literals."

	^32767! !
!SystemDictionary methodsFor: 'memory space' stamp: 'jmv 1/4/2024 16:11:49' prior: 16963713!
 growMemoryByAtLeast: numBytes
	"Grow memory by at least the requested number of bytes.
	 Primitive.  Fail if no memory is available.  Essential.
	 N.B. In Spur, the heap is composed of segments. Growing memory adds a new
	 segment; it does not extend existing segments. Growth is by at least that
	 established by Smalltalk vmParameterAt: 25, which defaults to 16Mb."

	<primitive: 180>
	^(numBytes isInteger and: [numBytes > 0])
		ifTrue: [OutOfMemory signal]
		ifFalse: [self primitiveFailed]! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 1/4/2024 16:21:43' prior: 16965196!
                   allObjectsDo: aBlock 
	"Evaluate the argument, aBlock, for each object in the system, excluding immediates
	 such as SmallInteger, Character and SmallFloat64."
	self allObjectsOrNil
		ifNotNil: [:allObjects| allObjects do: aBlock]
		ifNil:
			["Fall back on the old single object primitive code.  With closures, this needs
			  to use an end marker (lastObject) since activation of the block will create
			  new contexts and cause an infinite loop.  The lastObject must be created
			  before calling someObject, so that the VM can settle the enumeration (e.g.
			  by flushing new space) as a side effect of  someObject"
			| object lastObject |
			lastObject := Object new.
			object := self someObject.
			[lastObject == object or: [0 == object]] whileFalse: [
				| nextObject |
				nextObject := object nextObject.
				aBlock value: object.
				object := nextObject ]]! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 1/4/2024 16:11:15' prior: 50333483!
                        reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w submorphsDo: [ :a | a delete ]].
	Preferences at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts := MethodDictionary allInstances.
	newDicts := Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts := newDicts := nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/4/2024 15:39:16' prior: 50333606!
     filenameForUpdatedImage: aBoolean
	"If aBoolean, include highest update number	"
	| fileName newName changesName systemVersion |
	systemVersion := SystemVersion current.
	fileName := String streamContents: [ :strm |
		strm nextPutAll: systemVersion versionString.
		aBoolean ifTrue: [
			strm
				nextPut: $-;
				print: systemVersion highestUpdate ].
		Smalltalk wordSize = 4 ifTrue: [
			strm nextPutAll: '-32' ]].
	newName := fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName := DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName := self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		self inform:
'There is already .changes file of the desired name,
', changesName, '
curiously already present, even though there is no
corresponding .image file.
Please remedy manually and then repeat your request.'.
		^nil  ].
	^newName! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/4/2024 16:26:42' prior: 50333732!
                            setGCParameters
	"Adjust the VM's default GC parameters to avoid premature tenuring, and too frequent scavenging.
	Parameters set here don't persist, so we set them on startup.
	See #setDefaultGCParameters"

	| proportion edenSize survivorSize averageObjectSize numObjects |

	"Grow old memory in chunks of: "
	Smalltalk vmParameterAt: 25 put: `32*1024*1024`.
	"Shrink heap when unused memory is at least: "
	Smalltalk vmParameterAt: 24 put: `64*1024*1024`.

	"Note: (jmv, 9/2021) It seems modern Spur VMs ignore parameter 6. This all seems to be bogus."
	proportion := 0.9. "tenure when 90% of pastSpace is full"
	edenSize := self vmParameterAt: 44.
	survivorSize := edenSize / 5.0. "David's paper uses 140Kb eden + 2 x 28kb survivor spaces; Spur uses the same ratios :-)"
	averageObjectSize := 8 * self wordSize. "a good approximation"
	numObjects := (proportion * survivorSize / averageObjectSize) rounded.
	self vmParameterAt: 6 put: numObjects.  "tenure when more than this many objects survive the GC"
	"/Note: (jmv, 9/2021)"
	
	"Do a full GC when used memory grows by this factor.
	Default is 0.333.
	2.0 means gull GC when heap size triples."
	Smalltalk vmParameterAt: 55 put: 2.0.! !
!SystemDictionary methodsFor: 'special objects' stamp: 'jmv 1/4/2024 16:25:58' prior: 16967210!
                       recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active process (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).

	newArray at: 25 put: nil.	"Was an array of 256 Characters. nil in Spur."
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	newArray at: 29 put: nil. "Was the #compactClassesArray. nil in Spur."
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization"
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.

	newArray at: 36 put: nil. "was the prototype MethodContext"

	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: []).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).

	"Weak reference finalization"
	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: []).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray.! !
!SystemDictionary methodsFor: 'system attributes' stamp: 'jmv 1/4/2024 15:39:42' prior: 16968855!
              maxIdentityHash
	"Answer the maximum identityHash value supported by the VM.
	Usually the VM is able to answer. It seems that SqueakJS (as of October 5, 2020) isn't.
	On primitive failure, still give a correct answer."

	<primitive: 176>	
	^ 16r3FFFFF							"22 bits in Spur"! !
!SystemDictionary methodsFor: 'vm parameters' stamp: 'jmv 1/4/2024 16:29:03' prior: 16969790!
           vmParameterAt: parameterIndex
	"parameterIndex is a positive integer corresponding to one of the VM's internal parameter/metric registers. 
	Answer with the current value of that register.
	Answer nil if the VM doesn't provide the register, and the primitive fails.
	
	Also see #getVMParameters and #vmParameterAt:put: These 3 methods call the 
	same primitive, whose behavior depends on argument count:
		0 args:	return an Array of VM parameter values;
  		1 arg:	return the indicated VM parameter;
  		2 args:	set the VM indicated parameter.

	VM parameters are numbered as follows:
		1	size of old-space (0-based, read-only)
		2	size of new-space (read-only)
		3	size of heap (read-only)
		4	nil (was allocationCount (read-only))
		5	nil (was allocations between GCs (read-write)
		6	survivor count tenuring threshold (read-write)
		7	full GCs since startup (read-only)
		8	total milliseconds in full GCs since startup (read-only)
		9	scavenges since startup (read-only)
		10	scavenges since startup (read-only)
		11	tenures of surving objects since startup or reset (read-write)
		12-20 were specific to ikp's JITTER VM, now 12-15 are open for use
		16	total microseconds at idle since start-up (if non-zero)
		17	fraction of the code zone to use (Sista only; used to control code zone use to preserve sendAndBranchData on counter tripped callback)
		18	total milliseconds in compaction phase of full GC since start-up
		19	scavenge threshold, the effective size of eden.  When eden fills to the threshold a scavenge is scheduled.
		20	utc microseconds at VM start-up (actually at time initialization, which precedes image load).
		21	root/remembered table size (occupancy) (read-only)
		22	root table overflows since startup (read-only)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc (stored in image file header).
		24	memory threshold above which shrinking object memory (rw)
		25	memory headroom when growing object memory (rw)
		26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (rw)
		27	number of times mark loop iterated for current IGC/FGC (read-only) includes ALL marking
		28	number of times sweep loop iterated for current IGC/FGC (read-only)
		29	number of times make forward loop iterated for current IGC/FGC (read-only)
		30	number of times compact move loop iterated for current IGC/FGC (read-only)
		31	number of grow memory requests (read-only)
		32	number of shrink memory requests (read-only)
		33	number of root table entries used for current IGC/FGC (read-only)
		34	bytes allocated in total since start-up or reset (read-write)
		35	number of survivor objects after current IGC/FGC (read-only)
		36	millisecond clock when current IGC/FGC completed (read-only)
		37	number of marked objects for Roots of the world, not including Root Table entries for current IGC/FGC (read-only)
		38	milliseconds taken by current IGC (read-only)
		39	Number of finalization signals for Weak Objects pending when current IGC/FGC completed (read-only)
		40	BytesPerOop for this image
		41	imageFormatVersion for the VM
		42	number of stack pages in use
		43	desired number of stack pages (stored in image file header, max 65535)
		44	size of eden, in bytes
		45	desired size of eden, in bytes (stored in image file header)
		46	machine code zone size, in bytes (Cog only; otherwise nil)
		47	desired machine code zone size (stored in image file header; Cog only; otherwise nil)
		48	various header flags.  
			Bit 0: tells the VM that the image's Process class has threadId as its 5th inst var (after nextLink, suspendedContext, priority & myList)
			Bit 1: on Cog JIT VMs asks the VM to set the flag bit in interpreted methods
			Bit 2: if set, preempting a process puts it to the head of its run queue, not the back,
					i.e. preempting a process by a higher priority one will not cause the preempted process to yield
						to others at the same priority.
			Bit 3: in a muilt-threaded VM, if set, the Window system will only be accessed from the first VM thread
			Bit 4: if set, causes weaklings and ephemerons to be queued individually for finalization
			Bit 5: (on VMs that support it) if set, implies wheel events will be delivered as such and not mapped to arrow key events
			Bit 6: (on VMs that support it) whether the arithmetic primitives perform conversion in case of mixed SmallInteger/Float (not set) or fail (set)
				(on VMs that don't support it, those primitives will fail in those cases)
		49	max size the image promises to grow the external semaphore table to (0 sets to default, which is 256 as of writing)
		50-51 nil; reserved for VM parameters that persist in the image (such as eden above)
		52	root/remembered table capacity
		53	number of segments
		54	total size of free old space
		55	ratio of growth and image size at or above which a GC will be performed post scavenge
		56	number of process switches since startup (read-only)
		57	number of ioProcessEvents calls since startup (read-only)
		58	number of ForceInterruptCheck calls since startup (read-only)
		59	number of check event calls since startup (read-only)
		60	number of stack page overflows since startup (read-only)
		61	number of stack page divorces since startup (read-only)
		62	compiled code compactions since startup (read-only; Cog only; otherwise nil)
		63	total milliseconds in compiled code compactions since startup (read-only; Cog only; otherwise nil)
		64	the number of methods that currently have jitted machine-code
		65	whether the VM supports a certain feature, MULTIPLE_BYTECODE_SETS is bit 0, IMMUTABILITY is bit 1
		66	the byte size of a stack page
		67	the max allowed size of old space (0 implies no limit except that of the underlying platform)
		68	the average number of live stack pages when scanned by GC (at scavenge/gc/become et al) (read-write)
		69	the maximum number of live stack pages when scanned by GC (at scavenge/gc/become et al) (read-write)
		70	the vmProxyMajorVersion (the interpreterProxy VM_MAJOR_VERSION)
		71	the vmProxyMinorVersion (the interpreterProxy VM_MINOR_VERSION)
		72  total milliseconds in full GCs Mark phase since startup (read-only)
		73  total milliseconds in full GCs Sweep phase since startup (read-only, can be 0 depending on compactors)
		74  maximum pause time due to segment allocation"

	<primitive: 254>
	^nil! !
!SystemDictionary methodsFor: 'vm parameters' stamp: 'jmv 1/4/2024 16:30:34' prior: 16970002!
        vmParameterAt: parameterIndex put: newValue
	"parameterIndex is a positive integer corresponding to one of the VM's internal
	parameter/metric registers.  Store newValue (a positive integer) into that
	register and answer with the previous value that was stored there.
	Fail if newValue is out of range, if parameterIndex has no corresponding
	register, or if the corresponding register is read-only.

	As of mid 2017 the parameters which can be set are
		5	allocations between GCs (read-write; nil in Cog VMs)
		6	survivor count tenuring threshold (read-write)
		17	proportion of code zone available for use (Sista VMs only)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc.
		24	memory threshold above whichto shrink object memory (read-write)
		25	memory headroom when growing object memory (read-write)
		26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (read-write)
		34	bytes allocated in total since start-up or reset (read-write)
		43	desired number of stack pages (stored in image file header, max 65535; Cog VMs only, otherwise nil)
		45	desired size of eden, in bytes (stored in image file header; Cog VMs only, otherwise nil)
		47	desired size of machine code zone, in bytes (applies at startup only, stored in image file header; Cog JIT VM only)
		48	various properties of the Cog VM as an integer encoding an array of bit flags.
			Bit 0: tells the VM that the image's Process class has threadId as its 5th inst var (after nextLink, suspendedContext, priority & myList)
			Bit 1: on Cog JIT VMs asks the VM to set the flag bit in interpreted methods
			Bit 2: if set, preempting a process puts it to the head of its run queue, not the back,
					i.e. preempting a process by a higher priority one will not cause the preempted process to yield
						to others at the same priority.
			Bit 3: in a muilt-threaded VM, if set, the Window system will only be accessed from the first VM thread
			Bit 4: in if set, causes weaklings and ephemerons to be queued individually for finalization
			Bit 5: (on VMs that support it) if set, implies wheel events will be delivered as such and not mapped to arrow key events
			Bit 6: (on VMs that support it) whether the arithmetic primitives perform conversion in case of mixed SmallInteger/Float (not set) or fail (set)
				(on VMs that don't support it, those primitives will fail in those cases)
		49	the size of the external semaphore table (read-write; Cog VMs only)
		55	ratio of growth and image size at or above which a GC will be performed post scavenge
		67	the maximum allowed size of old space in bytes, 0 implies no internal limit."

	<primitive: 254>
	self primitiveFailed! !
!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'jmv 1/4/2024 16:12:33' prior: 16801994!
       sizeCallPrimitive: primitiveIndex
	^self sizeOpcodeSelector: #genCallPrimitive: withArguments: {primitiveIndex}! !
!BytecodeEncoder methodsFor: 'method generation' stamp: 'jmv 1/4/2024 16:12:19' prior: 16802253!
            computeMethodHeaderForNumArgs: numArgs numTemps: numTemps numLits: numLits primitive: primitiveIndex
	numArgs > 15
		ifTrue: [^self error: 'Cannot compile -- too many arguments'].
	numTemps > 63
		ifTrue: [^self error: 'Cannot compile -- too many temporary variables'].	
	numLits > 65535
		ifTrue: [^self error: 'Cannot compile -- too many literals'].
	^(CompiledMethod headerFlagForEncoder: self)
		+ (numArgs bitShift: 24)
		+ (numTemps bitShift: 18)
		"+ (largeBit bitShift: 17)" "largeBit gets filled in later"
		+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0])
		+ numLits! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 1/4/2024 16:12:46' prior: 16854304!
   genCallPrimitive: primitiveIndex
	"139	11101111	iiiiiiii jjjjjjjj	Call Primitive #iiiiiiii + (jjjjjjjj * 256)"
	(primitiveIndex < 1 or: [primitiveIndex > 65535]) ifTrue: [
		self outOfRangeError: 'primitive index' index: primitiveIndex range: 1 to: 65535].
	stream
		nextPut: 139;
		nextPut: (primitiveIndex bitAnd: 255);
		nextPut: (primitiveIndex bitShift: -8)! !
!MethodNode methodsFor: 'code generation' stamp: 'jmv 1/4/2024 15:40:43' prior: 16901239!
                        generate: trailer using: aCompiledMethodClass
	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.
	 The argument, trailer, is arbitrary but is typically the reference to the source code
	 that is stored with every CompiledMethod."

	| primErrNode blkSize nLits locals literals stack header method |
	self generate: trailer
		using: aCompiledMethodClass
		ifQuick:
			[:m |
			 encoder noteBlockExtent: (0 to: 2) hasLocals: arguments.
			 m	literalAt: 2 put: encoder associationForClass;
				properties: properties.
			 ^m].
	primErrNode := self primitiveErrorVariableName ifNotNil:
						[encoder fixTemp: self primitiveErrorVariableName].
	self ensureClosureAnalysisDone.
	encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"
	blkSize := (block sizeCodeForEvaluatedValue: encoder)
				+ (primitive > 0
					ifTrue: [encoder sizeCallPrimitive: primitive]
					ifFalse: [0])
				+ (primErrNode
					ifNil: [0]
					ifNotNil:
						[primErrNode
							index: arguments size + temporaries size;
							sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).
	locals := arguments, temporaries, (primErrNode ifNil: [#()] ifNotNil: [{primErrNode}]).
	encoder noteBlockExtent: block blockExtent hasLocals: locals.
	header := encoder computeMethodHeaderForNumArgs: arguments size
					numTemps: locals size
					numLits: (nLits := (literals := encoder allLiterals) size)
					primitive: primitive.
	method := aCompiledMethodClass
					createMethod: blkSize
					trailer: trailer
					header: header.
	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].
	encoder streamToMethod: method.
	stack := ParseStack new init.
	primitive > 0 ifTrue:
		[encoder genCallPrimitive: primitive.
		 primErrNode ifNotNil:
			[primErrNode emitCodeForStore: stack encoder: encoder]].
	stack position: method numTemps.
	[block emitCodeForEvaluatedValue: stack encoder: encoder]
		on: Error "If an attempt is made to write too much code the method will be asked"
		do: [:ex|  "to grow, and the grow attempt will fail in CompiledMethod class>>#new:"
			ex signalerContext sender method = (CompiledMethod class>>#new:)
				ifTrue: [^self error: 'Compiler code size discrepancy']
				ifFalse: [ex pass]].
	stack position ~= (method numTemps + 1) ifTrue:
		[^self error: 'Compiler stack discrepancy'].
	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:
		[^self error: 'Compiler code size discrepancy'].
	method needsFrameSize: stack size - method numTemps.
	method properties: properties.
	^method! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 1/4/2024 16:32:05' prior: 16997246!
                 vmStatisticsReportOn: str
	"
	(TextModel new contents: Utilities vmStatisticsReportString) openLabel: 'VM Statistics'
	"

	| params oldSpaceEnd youngSpaceEnd memorySize fullGCs fullGCTime fullGCCompactionTime incrGCs incrGCTime tenureCount upTime
	  upTime2 fullGCs2 fullGCTime2  incrGCs2 incrGCTime2 tenureCount2 freeSize youngSize used timeReporter idleMs idleMs2 codeCompactionTime codeCompactionsOrNil codeCompactionTime2 codeCompactions2 maxParams |
	"Pad to protect for a VM that does not answer the expected parameter array"
	maxParams := 63. "max position referenced in this method"
	params := Array streamContents: [ :strm |
				strm nextPutAll: Smalltalk getVMParameters.
				[strm position < maxParams] whileTrue: [strm nextPut: nil]].
	oldSpaceEnd			:= params at: 1.
	youngSpaceEnd		:= params at: 2.
	memorySize			:= params at: 3.
	fullGCs			:= params at: 7.
	fullGCTime			:= params at: 8.
	incrGCs			:= params at: 9.
	incrGCTime			:= params at: 10.
	tenureCount			:= params at: 11.
	fullGCCompactionTime	:= params at: 18.
	codeCompactionsOrNil	:= params at: 62.
	codeCompactionTime	:= params at: 63.
	
	upTime := (params at: 20) ~= 0 "utcMicrosecondClock at startup"
				ifTrue: [Time primUtcMicrosecondClock - (params at: 20) + 500 // 1000]
				ifFalse: [Time primMillisecondClock]. "Fall back on old microsecond clock; Good for 47.5 days"
	timeReporter := [:time| | seconds |
					seconds := time / 1000.
					seconds >= (60*60*24)
						ifTrue:
							[str print: seconds / 60 // 60 // 24; nextPut: $d; space;
								print: seconds / 60 // 60 \\ 24; nextPut: $h; space]
						ifFalse:
							[seconds >= (60*60) ifTrue:
								[str print: (seconds / 60 // 60); nextPut: $h; space]].
					str
						print: (seconds / 60 \\ 60) asInteger; nextPut: $m; space;
						print: (seconds \\ 60) asInteger; nextPut: $s].
	str	nextPutAll: 'uptime		'.
	timeReporter value: upTime.
	(idleMs := params at: 16) ~= 0 ifTrue:
		[str tab; nextPutAll: '(runtime '.
		 idleMs := idleMs // 1000.
		 timeReporter value: upTime - idleMs.
		 str nextPutAll: ', idletime '.
		 timeReporter value: idleMs.
		 str nextPut: $)].
	str newLine.

	str	nextPutAll: 'memory			';
		nextPutAll: (self formatVMParameter: memorySize); nextPutAll: ' bytes'; newLine.
	str	nextPutAll:	'	old		';
		nextPutAll: (self formatVMParameter: oldSpaceEnd); nextPutAll: ' bytes (';
		print: oldSpaceEnd / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.

	(youngSize := (params at: 19)  * 7 // 5) = 0 ifTrue: [params at: 44].
	 youngSize := youngSize roundUpTo: 1024.
	 str	nextPutAll: '	young		';
		nextPutAll: (self formatVMParameter: youngSize); nextPutAll: ' bytes (';
		print: youngSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
	youngSize := youngSpaceEnd. "used eden"
	freeSize := (params at: 54) + (params at: 44) - youngSize.
	used := youngSize + oldSpaceEnd - freeSize.
	str	nextPutAll: '	used		';
		nextPutAll: (self formatVMParameter: used); nextPutAll: ' bytes (';
		print: used / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
	str	nextPutAll: '	free		';
		nextPutAll: (self formatVMParameter: freeSize); nextPutAll: ' bytes (';
		print: freeSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.

	str	nextPutAll: 'GCs					';
		nextPutAll: (self formatVMParameter: (fullGCs + incrGCs)).
	fullGCs + incrGCs > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime / (fullGCs + incrGCs) fractionDigits: 1; 
			nextPutAll: ' ms between GCs'.
		 idleMs > 0 ifTrue:
			[str
				space;
				print: upTime - idleMs / (fullGCs + incrGCs) fractionDigits: 1; 
				nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime); nextPutAll: ' ms (';
		print: fullGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime)';
		nextPutAll: ', avg '; print: (fullGCTime / (fullGCs max: 1)) fractionDigits: 1; nextPutAll: ' ms'.
	fullGCCompactionTime ~= 0 ifTrue:
		[str	newLine; nextPutAll: '		marking			';
			nextPutAll: (self formatVMParameter: (fullGCTime - fullGCCompactionTime)); nextPutAll: ' ms (';
			print: (fullGCTime - fullGCCompactionTime) / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: (fullGCTime - fullGCCompactionTime / (fullGCs max: 1)) fractionDigits: 1;
			nextPutAll: ' ms,'; newLine;
			nextPutAll: '		compacting			';
			nextPutAll: (self formatVMParameter: fullGCCompactionTime); nextPutAll: ' ms (';
			print: fullGCCompactionTime / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: fullGCCompactionTime / (fullGCs max: 1) fractionDigits: 1;
			nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: '	scavenges				';
		nextPutAll: (self formatVMParameter: incrGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime); nextPutAll: ' ms (';
		print: incrGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime), avg '; print: incrGCTime / incrGCs fractionDigits: 1; nextPutAll: ' ms'; newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount).
	tenureCount = 0 ifFalse:
		[str nextPutAll: ' (avg '; print: tenureCount // (incrGCs max: 1); nextPutAll: ' tenures per scavenge)'].
	str	newLine.

	codeCompactionsOrNil ifNotNil:
		[str
			nextPutAll: '	code compactions				'.
		codeCompactionsOrNil = 0
			ifTrue: [str
				nextPutAll: codeCompactionsOrNil printString; newLine]
			ifFalse: [str
				nextPutAll: (self formatVMParameter: codeCompactionsOrNil); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime); nextPutAll: ' ms (';
				print: codeCompactionTime / (upTime - idleMs) * 100 fractionDigits: 3;
				nextPutAll: '% runtime), avg '; print: codeCompactionTime / codeCompactionsOrNil fractionDigits: 1; nextPutAll: ' ms'; newLine]].

LastStats ifNil: [LastStats := Array new: 9]
ifNotNil: [
	LastStats size < 9 ifTrue:
		[LastStats := LastStats, (Array new: 9 - LastStats size withAll: 0)].
	upTime2 := upTime - (LastStats at: 1).
	fullGCs2 := fullGCs - (LastStats at: 2).
	fullGCTime2 := fullGCTime - (LastStats at: 3).
	incrGCs2 := incrGCs - (LastStats at: 4).
	incrGCTime2 := incrGCTime - (LastStats at: 5).
	tenureCount2 := tenureCount - (LastStats at: 6).
	idleMs2 := idleMs - (LastStats at: 7).
	codeCompactionsOrNil ifNotNil:
		[codeCompactions2	:= codeCompactionsOrNil - (LastStats at: 8).
		 codeCompactionTime2	:= codeCompactionTime - (LastStats at: 9)].

	str	nextPutAll: 'GCs since last view					';
		nextPutAll: (self formatVMParameter: (fullGCs2 + incrGCs2)).
	fullGCs2 + incrGCs2 > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime2 // (fullGCs2 + incrGCs2); 
			nextPutAll: ' ms between GCs'.
			idleMs2 > 0 ifTrue:
				[str
					nextPutAll: ', ';
					print: upTime2 - idleMs2 // (fullGCs2 + incrGCs2);
					nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str	newLine.
	str	nextPutAll: '	uptime				'; print: (upTime2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, runtime ';		   print: (upTime2 - idleMs2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, idletime ';		   print: (idleMs2 / 1000.0) fractionDigits: 1; nextPutAll: ' s'; newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs2).
	fullGCs2 + fullGCTime2 > 0 ifTrue:
		[str	nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime2); nextPutAll: ' ms (';
			print: fullGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
			nextPutAll: '% runtime)'.
		 str	nextPutAll: ', avg '; print: fullGCTime2 / (fullGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: '	scavenges				';
		nextPutAll: (self formatVMParameter: incrGCs2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime2); nextPutAll: ' ms (';
		print: incrGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
		nextPutAll: '% runtime), avg '; print: incrGCTime2 / (incrGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'.
	str	newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount2).
	tenureCount2 = 0 ifFalse:
		[str nextPutAll: ' (avg '; print: tenureCount2 // (incrGCs2 max: 1); nextPutAll: ' tenures per scavenge)'].
	str	newLine.
	codeCompactionsOrNil ifNotNil:
		[str	nextPutAll: '	code compactions				';
			nextPutAll: (self formatVMParameter: codeCompactions2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime2); nextPutAll: ' ms (';
			print: codeCompactionTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 3;
			nextPutAll: '% runtime)'.
		 codeCompactions2 > 0 ifTrue:
			[str nextPutAll: ', avg '; print: codeCompactionTime2 / codeCompactions2 fractionDigits: 1; nextPutAll: ' ms'; newLine.]]
].
	LastStats := { upTime. fullGCs. fullGCTime. incrGCs. incrGCTime. tenureCount. idleMs. codeCompactionsOrNil. codeCompactionTime }.! !
!SpaceTally methodsFor: 'instance size' stamp: 'jmv 1/4/2024 15:20:50' prior: 16958043!
                   spaceForInstancesOf: aClass
	"Answer a pair of the number of bytes consumed by all instances of the
	 given class, including their object headers, and the number of instances."

	| instances total |
	instances := aClass allInstances.
	instances isEmpty ifTrue: [^#(0 0)].
	total := 0.
	aClass isVariable
		ifTrue:
			[instances do:
				[:i| total := total + (aClass byteSizeOfInstanceOfSize: i basicSize)]]
		ifFalse:
			[total := instances size * aClass byteSizeOfInstance].
	^{ total. instances size }! !
!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 1/4/2024 15:20:08' prior: 16958151!
                   printSpaceAnalysis: threshold on: aStream
	"
	SpaceTally new printSpaceAnalysis: 1 on:(FileStream forceNewFileNamed: 'STspace.text')
	"
	"sd-This method should be rewrote to be more coherent within the rest of the class 
	ie using preAllocate and spaceForInstanceOf:"

	"If threshold > 0, then only those classes with more than that number
	of instances will be shown, and they will be sorted by total instance space.
	If threshold = 0, then all classes will appear, sorted by name."

	| codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |
	Smalltalk garbageCollect.
	totalCodeSpace := totalInstCount := totalInstSpace := n := 0.
	results := OrderedCollection new: Smalltalk classNames size.
	'Taking statistics...'
		displayProgressAt: Sensor mousePoint
		from: 0 to: Smalltalk classNames size
		during: [ :barBlock |
			Smalltalk allClassesDo: [ :cl |
				codeSpace := cl spaceUsed.
				barBlock value: (n := n+1).
				Smalltalk garbageCollectMost.
				instCount := cl instanceCount.
				instSpace := 8 * instCount. "Object headers""Warning: The 3rd header word for big objects is not considered!!"
				cl isVariable
					ifTrue: [
						eltSize := cl isBytes ifTrue: [1] ifFalse: [4].
						cl allInstancesDo: [ :x |
							instSpace := instSpace + (x basicSize * eltSize)]]
					ifFalse: [instSpace := instSpace + (cl instSize * instCount * 4)].
				results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).
				totalCodeSpace := totalCodeSpace + codeSpace.
				totalInstCount := totalInstCount + instCount.
				totalInstSpace := totalInstSpace + instSpace]].
	totalPercent := 0.0.

	aStream timeStamp.
	aStream
		nextPutAll: ('Class' padded: #right to: 30 with: $ );
		nextPutAll: ('code space' padded: #left to: 12 with: $ );
		nextPutAll: ('# instances' padded: #left to: 12 with: $ );
		nextPutAll: ('inst space' padded: #left to: 12 with: $ );
		nextPutAll: ('percent' padded: #left to: 8 with: $ ); newLine.

	threshold > 0 ifTrue: [
		"If inst count threshold > 0, then sort by space"
		results := (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])
			asArray sort: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].

	results do: [:s |
		aStream
			nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );
			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );
			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );
			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).
		percent := s spaceForInstances*100.0/totalInstSpace.
		totalPercent := totalPercent + percent.
		percent >= 0.1 ifTrue: [
			percent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil ].
		aStream newLine].

	aStream
		newLine; nextPutAll: ('Total' padded: #right to: 30 with: $ );
		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ ).
	totalPercent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil! !

SpaceTally removeSelector: #spaceForInstancesOfSpur:!

!methodRemoval: SpaceTally #spaceForInstancesOfSpur: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
spaceForInstancesOfSpur: aClass
	"Answer a pair of the number of bytes consumed by all instances of the
	 given class, including their object headers, and the number of instances."

	| instances total |
	instances := aClass allInstances.
	instances isEmpty ifTrue: [^#(0 0)].
	total := 0.
	aClass isVariable
		ifTrue:
			[instances do:
				[:i| total := total + (aClass byteSizeOfInstanceOfSize: i basicSize)]]
		ifFalse:
			[total := instances size * aClass byteSizeOfInstance].
	^{ total. instances size }!

SpaceTally removeSelector: #spaceForInstancesOfPreSpur:!

!methodRemoval: SpaceTally #spaceForInstancesOfPreSpur: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
spaceForInstancesOfPreSpur: aClass
	"Answer a pair of the number of bytes consumed by all instances of the
	 given class, including their object headers, and the number of instances."

	| instCount isCompact instVarBytes bytesPerElement contentBytes headerBytes total |
	instCount := aClass instanceCount.
	instCount = 0 ifTrue: [^ 0].
	isCompact := aClass indexIfCompact > 0.
	instVarBytes := aClass instSize * 4.
	aClass isVariable
		ifTrue: [
			bytesPerElement := aClass isBytes ifTrue: [1] ifFalse: [4].
			total := 0.
			aClass allInstancesDo: [:inst |
				contentBytes := instVarBytes + (inst size * bytesPerElement).
				headerBytes :=
					contentBytes > 255
						ifTrue: [12]
						ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].
				total := total + headerBytes + contentBytes].
			^ {total. instCount}]
		ifFalse: [
			headerBytes :=
				instVarBytes > 255
					ifTrue: [12]
					ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].
			^ {instCount * (headerBytes + instVarBytes). instCount}].
!

MethodNode removeSelector: #generatePreSpur:using:!

!methodRemoval: MethodNode #generatePreSpur:using: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
generatePreSpur: trailer using: aCompiledMethodClass
	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.
	 The argument, trailer, is arbitrary but is typically the reference to the source code
	 that is stored with every CompiledMethod."

	| primErrNode blkSize nLits literals stack method |
	self generate: trailer 
		using: aCompiledMethodClass
		ifQuick:
			[:m |
			 encoder noteBlockExtent: (0 to: 2) hasLocals: arguments.
			 m	literalAt: 2 put: encoder associationForClass;
				properties: properties.
			 ^m].
	primErrNode := self primitiveErrorVariableName ifNotNil:
						[encoder fixTemp: self primitiveErrorVariableName].
	encoder supportsClosureOpcodes ifTrue:
		[self ensureClosureAnalysisDone.
		 encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"].
	blkSize := (block sizeCodeForEvaluatedValue: encoder)
				+ (primErrNode
					ifNil: [0]
					ifNotNil:
						[primErrNode
							index: arguments size + temporaries size;
							sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).
	method := aCompiledMethodClass
				newBytes: blkSize
				trailerBytes: trailer 
				nArgs: arguments size
				nTemps: (encoder supportsClosureOpcodes
							ifTrue: [| locals |
									locals := arguments,
											  temporaries,
											  (primErrNode
												ifNil: [#()]
												ifNotNil: [{primErrNode}]).
									encoder
										noteBlockExtent: block blockExtent
										hasLocals: locals.
									locals size]
							ifFalse: [encoder maxTemp])
				nStack: 0
				nLits: (nLits := (literals := encoder allLiterals) size)
				primitive: primitive.
	nLits > 255 ifTrue:
		[^self error: 'Too many literals referenced'].
	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].
	encoder streamToMethod: method.
	stack := ParseStack new init.
	primErrNode ifNotNil: [primErrNode emitCodeForStore: stack encoder: encoder].
	stack position: method numTemps.
	[block emitCodeForEvaluatedValue: stack encoder: encoder]
		on: Error "If an attempt is made to write too much code the method will be asked"
		do: [:ex|  "to grow, and the grow attempt will fail in CompiledMethod class>>#new:"
			ex signalerContext sender method = (CompiledMethod class>>#new:)
				ifTrue: [^self error: 'Compiler code size discrepancy']
				ifFalse: [ex pass]].
	stack position ~= (method numTemps + 1) ifTrue:
		[^self error: 'Compiler stack discrepancy'].
	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:
		[^self error: 'Compiler code size discrepancy'].
	method needsFrameSize: stack size - method numTemps.
	method properties: properties.
	^method!

MethodNode removeSelector: #generateSpur:using:!

!methodRemoval: MethodNode #generateSpur:using: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
generateSpur: trailer using: aCompiledMethodClass
	"The receiver is the root of a parse tree. Answer an instance of aCompiledMethodClass.
	 The argument, trailer, is arbitrary but is typically the reference to the source code
	 that is stored with every CompiledMethod."

	| primErrNode blkSize nLits locals literals stack header method |
	self generate: trailer
		using: aCompiledMethodClass
		ifQuick:
			[:m |
			 encoder noteBlockExtent: (0 to: 2) hasLocals: arguments.
			 m	literalAt: 2 put: encoder associationForClass;
				properties: properties.
			 ^m].
	primErrNode := self primitiveErrorVariableName ifNotNil:
						[encoder fixTemp: self primitiveErrorVariableName].
	self ensureClosureAnalysisDone.
	encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"
	blkSize := (block sizeCodeForEvaluatedValue: encoder)
				+ (primitive > 0
					ifTrue: [encoder sizeCallPrimitive: primitive]
					ifFalse: [0])
				+ (primErrNode
					ifNil: [0]
					ifNotNil:
						[primErrNode
							index: arguments size + temporaries size;
							sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).
	locals := arguments, temporaries, (primErrNode ifNil: [#()] ifNotNil: [{primErrNode}]).
	encoder noteBlockExtent: block blockExtent hasLocals: locals.
	header := encoder computeMethodHeaderForNumArgs: arguments size
					numTemps: locals size
					numLits: (nLits := (literals := encoder allLiterals) size)
					primitive: primitive.
	method := aCompiledMethodClass
					createMethod: blkSize
					trailer: trailer
					header: header.
	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].
	encoder streamToMethod: method.
	stack := ParseStack new init.
	primitive > 0 ifTrue:
		[encoder genCallPrimitive: primitive.
		 primErrNode ifNotNil:
			[primErrNode emitCodeForStore: stack encoder: encoder]].
	stack position: method numTemps.
	[block emitCodeForEvaluatedValue: stack encoder: encoder]
		on: Error "If an attempt is made to write too much code the method will be asked"
		do: [:ex|  "to grow, and the grow attempt will fail in CompiledMethod class>>#new:"
			ex signalerContext sender method = (CompiledMethod class>>#new:)
				ifTrue: [^self error: 'Compiler code size discrepancy']
				ifFalse: [ex pass]].
	stack position ~= (method numTemps + 1) ifTrue:
		[^self error: 'Compiler stack discrepancy'].
	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:
		[^self error: 'Compiler code size discrepancy'].
	method needsFrameSize: stack size - method numTemps.
	method properties: properties.
	^method!

SystemDictionary removeSelector: #compactClassesArray!

!methodRemoval: SystemDictionary #compactClassesArray stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
compactClassesArray  "Smalltalk compactClassesArray"
	"Return the array of 31 classes whose instances may be
	represented compactly"
	^ self specialObjectsArray at: 29!

SystemDictionary removeSelector: #isSpur!

!methodRemoval: SystemDictionary #isSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
isSpur
	"Answer true if we are a Spur ObjectMemory.
	Spur introduces a new format of header for objects, new format for classes, etc.
	Smalltalk isSpur
	"

	^ self compactClassesArray isNil!

SystemDictionary removeSelector: #cleanCompactObsoleteClasses!

!methodRemoval: SystemDictionary #cleanCompactObsoleteClasses stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
cleanCompactObsoleteClasses

	| cct |
	"No Compact Classes support in Spur"
	self isSpur ifTrue: [ ^ self ].

	cct := self compactClassesArray.
	cct do: [ :c |
		c ifNotNil: [
			c isObsolete ifTrue: [ 
				cct at: c indexIfCompact put: nil ]]]!

SystemDictionary removeSelector: #compactClassesArrayIncludes:!

!methodRemoval: SystemDictionary #compactClassesArrayIncludes: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
compactClassesArrayIncludes: aClass
	"No compact classes in Spur, but usually some in non-Spur"
	^self compactClassesArray
		ifNil: [ false ]
		ifNotNil: [ :it | it identityIncludes: aClass ]!

CompiledMethod class removeSelector: #newPreSpurBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:!

!methodRemoval: CompiledMethod class #newPreSpurBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
newPreSpurBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex
	"Answer an instance of me. The header is specified by the message 
	arguments. The remaining parts are not as yet determined."
	| largeBit primBits method |
	nTemps > 63 ifTrue:
		[^ self error: 'Cannot compile -- too many temporary variables'].	
	nLits > 255 ifTrue:
		[^ self error: 'Cannot compile -- too many literals variables'].	
	largeBit := (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].
	primBits := primitiveIndex <= 16r1FF
		ifTrue: [primitiveIndex]
		ifFalse: ["For now the high bit of primitive no. is in the 29th bit of header"
				primitiveIndex > 16r3FF ifTrue: [self error: 'prim num too large'].
				(primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r200) bitShift: 19)].
	method := self newMethod: numberOfBytes + trailer size
		header: (nArgs bitShift: 24) +
				(nTemps bitShift: 18) +
				(largeBit bitShift: 17) +
				(nLits bitShift: 9) +
				primBits.
	1 to: trailer size do:  "Copy the source code trailer to the end"
		[:i | method at: method size - trailer size + i put: (trailer at: i)].
	^ method!

CompiledMethod class removeSelector: #newSpurBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive:!

!methodRemoval: CompiledMethod class #newSpurBytes:trailerBytes:nArgs:nTemps:nStack:nLits:primitive: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
newSpurBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex
	"Answer an instance of me. The header is specified by the message 
	 arguments. The remaining parts are not as yet determined."
	| method pc |
"15 | 63 | 32767"
	nArgs > 15 ifTrue:
		[^self error: 'Cannot compile -- too many arguments'].
	nTemps > 63 ifTrue:
		[^self error: 'Cannot compile -- too many temporary variables'].	
	nLits > 32767 ifTrue:
		[^self error: 'Cannot compile -- too many literals'].

	method := self
				createMethod: numberOfBytes
				trailer: trailer
				header:    (nArgs bitShift: 24)
						+ (nTemps bitShift: 18)
						+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])
						+ nLits
						+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0]).
	primitiveIndex > 0 ifTrue:
		[pc := method initialPC.
		 method
			at: pc + 0 put: method encoderClass callPrimitiveCode;
			at: pc + 1 put: (primitiveIndex bitAnd: 16rFF);
			at: pc + 2 put: (primitiveIndex bitShift: -8)].
	^method!

Character class removeSelector: #definition!

!methodRemoval: Character class #definition stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
definition
	"Special class definition for Character, SmallInteger and SmallFloat64
	Required to have the same definition both for preSpur and Spur, and to be compatible with both."
	^
'Object immediateSubclass: #Character
	instanceVariableNames: ''value''
	classVariableNames: ''CharacterTable''
	poolDictionaries: ''''
	category: ''', self category, ''''
!

Character class removeSelector: #immediateNumericValue:!

!methodRemoval: Character class #immediateNumericValue: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
immediateNumericValue: anInteger
	"Answer the Character whose value is anInteger, if instances happen to be immediate (i.e. as in Spur)"

	<primitive: 170>
	^self primitiveFailed!

Character class removeSelector: #nonImmediateNumericValue:!

!methodRemoval: Character class #nonImmediateNumericValue: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
nonImmediateNumericValue: anInteger
	"Answer the Character whose value is anInteger, if instances happen to be regular (i.e. not in Spur)"


	CharacterTable ifNil: [
		CharacterTable := (0 to: 255) collect: [ :i | Character basicNew instVarAt: 1 put: i; yourself ]].
	^CharacterTable at: anInteger + 1!

Character removeSelector: #nonImmediateNumericValue!

!methodRemoval: Character #nonImmediateNumericValue stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
nonImmediateNumericValue
	"Answer the numeric value of the receiver, if instances happen to be regular (i.e. not in Spur)"

	^self instVarAt: 1!

Character removeSelector: #immediateNumericValue!

!methodRemoval: Character #immediateNumericValue stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
immediateNumericValue
	"Answer the numeric value of the receiver, if instances happen to be immediate (i.e. as in Spur)"

	<primitive: 171>
	^self primitiveFailed!

ClassBuilder removeSelector: #computeFormat:instSize:forSuper:ccIndex:!

!methodRemoval: ClassBuilder #computeFormat:instSize:forSuper:ccIndex: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
computeFormat: type instSize: newInstSize forSuper: newSuper ccIndex: ccIndex
	"Compute the new format for making oldClass a subclass of newSuper.
	Return the format or nil if there is any problem."

	| instSize isVar isWords isPointers isWeak |

	"Spur uses this version"
	Smalltalk isSpur ifTrue: [
		^ self computeFormat: type fullInstancesSize: (newInstSize + (newSuper ifNil:[0] ifNotNil:[newSuper instSize])) ].

	"This for preSpur images"
	type == #compiledMethod
		ifTrue:[^CompiledMethod format].
	instSize := newInstSize + (newSuper ifNil:[0] ifNotNil:[newSuper instSize]).
	instSize > 254 ifTrue:[
		self error: 'Class has too many instance variables (', instSize printString,')'.
		^nil].
	type == #normal ifTrue:[isVar := isWeak := false. isWords := isPointers := true].
	type == #bytes ifTrue:[isVar := true. isWords := isPointers := isWeak := false].
	type == #words ifTrue:[isVar := isWords := true. isPointers := isWeak := false].
	type == #variable ifTrue:[isVar := isPointers := isWords := true. isWeak := false].
	type == #weak ifTrue:[isVar := isWeak := isWords := isPointers := true].
	isVar ifNil: [ self error: 'Unsupported class format type: ', type. ^ nil ].
	(isPointers not and:[instSize > 0]) ifTrue:[
		self error:'A non-pointer class cannot have instance variables'.
		^nil].
	^(self format: instSize 
		variable: isVar 
		words: isWords 
		pointers: isPointers 
		weak: isWeak) + (ccIndex bitShift: 11)!

ClassBuilder removeSelector: #format:variable:words:pointers:weak:!

!methodRemoval: ClassBuilder #format:variable:words:pointers:weak: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
format: nInstVars variable: isVar words: isWords pointers: isPointers weak: isWeak

	"Only for preSpur!!"

	"Compute the format for the given instance specfication."
	| cClass instSpec sizeHiBits fmt |
"
	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.
	For now the format word is...
		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>
	But when we revise the image format, it should become...
		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>
"
	sizeHiBits := (nInstVars+1) // 64.
	cClass := 0.  "for now"
	instSpec := isWeak
		ifTrue:[4]
		ifFalse:[isPointers
				ifTrue: [isVar
						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]
						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]
				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].
	fmt := sizeHiBits.
	fmt := (fmt bitShift: 5) + cClass.
	fmt := (fmt bitShift: 4) + instSpec.
	fmt := (fmt bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"
	fmt := (fmt bitShift: 1). "This shift plus integer bit lets wordSize work like byteSize"
	^fmt!

Class removeSelector: #becomeCompactSimplyAt:!

!methodRemoval: Class #becomeCompactSimplyAt: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
becomeCompactSimplyAt: index
	"Make me compact, but don't update the instances.  For importing segments."
"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."
	| cct |

	Smalltalk isSpur ifTrue: [^ self error: 'No Compact Classes support in Spur'].
	self isWeak ifTrue:[^ self error: 'You must not make a weak class compact'].
	cct := Smalltalk compactClassesArray.
	(self indexIfCompact > 0 or: [cct includes: self])
		ifTrue: [^ self error: self name , 'is already compact'].
	(cct at: index) ifNotNil: [^ self error: 'compact table slot already in use'].
	"Install this class in the compact class table"
	cct at: index put: self.
	"Update instspec so future instances will be compact"
	format := format + (index bitShift: 11).
	"Caller must convert the instances"
!

Class removeSelector: #becomeCompact!

!methodRemoval: Class #becomeCompact stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
becomeCompact
	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."
	| cct index |

	Smalltalk isSpur ifTrue: [^ self error: 'No Compact Classes support in Spur'].
	self isWeak ifTrue:[^ self error: 'You must not make a weak class compact'].
	cct := Smalltalk compactClassesArray.
	(self indexIfCompact > 0 or: [cct includes: self])
		ifTrue: [^ self error: self name , 'is already compact'].
	index := cct indexOf: nil
		ifAbsent: [^ self error: 'compact class table is full'].
	"Install this class in the compact class table"
	cct at: index put: self.
	"Update instspec so future instances will be compact"
	format := format + (index bitShift: 11).
	"Make up new instances and become old ones into them"
	self updateInstancesFrom: self.
	"Purge any old instances"
	Smalltalk garbageCollect.!

Class removeSelector: #becomeUncompact!

!methodRemoval: Class #becomeUncompact stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
becomeUncompact
	| cct index |
	cct := Smalltalk compactClassesArray.
	(index := self indexIfCompact) = 0
		ifTrue: [^ self].
	(cct includes: self)
		ifFalse: [^ self error:  'inconsistent state of compact classes'].
	"Update instspec so future instances will not be compact"
	format := format - (index bitShift: 11).
	"Make up new instances and become old ones into them"
	self updateInstancesFrom: self.
	"Make sure there are no compact ones left around"
	Smalltalk garbageCollect.
	"Remove this class from the compact class table"
	cct at: index put: nil.
!

ClassDescription removeSelector: #updateInstancesFrom:!

!methodRemoval: ClassDescription #updateInstancesFrom: stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
updateInstancesFrom: oldClass
	"Recreate any existing instances of the argument, oldClass, as instances of 
	 the receiver, which is a newly changed class. Permute variables as necessary,
	 and forward old instances to new instances.. Answer nil to defeat any clients
	 that expected the old behaviour of answering the array of old instances."
	"ar 7/15/1999: The updating below is possibly dangerous. If there are any
	contexts having an old instance as receiver it might crash the system if
	the new receiver in which the context is executed has a different layout.
	See bottom below for a simple example:
	jmv 1/29/2019: Detect the problem and prevent mutation if that is the case."
	| allInstances newMethod oldMethod selector |
	allInstances := oldClass allInstances.
	allInstances notEmpty ifTrue: [
		Processor 
			processesDo: [ :p | ]
			withStackFramestDo: [ :process :context |
				(context receiver isKindOf: oldClass) ifTrue: [
					selector := context method selector.
					oldMethod := oldClass lookupSelector: selector.
					newMethod := self lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: context receiver class name, ' has some instance running #', selector, '. This CompiledMethod would become invalid. Class reshaping aborted.' ]]]
			runningProcessSearchStart: nil.
		self updateInstances: allInstances asArray from: oldClass isMeta: self isMeta ].
	^nil

"This attempts to crash the VM by stepping off the end of an instance.
 As the doctor says, do not do this."
"	| crashingBlock class |
	class := Object subclass: #CrashTestDummy
		instanceVariableNames: 'instVar'
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	class compile:'instVar: value instVar := value'.
	class compile:'crashingBlock ^[instVar]'.
	crashingBlock := (class new) instVar: 42; crashingBlock.
	Object subclass: #CrashTestDummy
		instanceVariableNames: ''
		classVariableNames: ''
		poolDictionaries: ''
		category: 'Crash-Test'.
	crashingBlock value"!

Behavior removeSelector: #typeOfClassSpur!

!methodRemoval: Behavior #typeOfClassSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
typeOfClassSpur
	"Answer a symbol uniquely describing the type of the receiver. c.f. kindOfSubclass, instSpec"
	^(#(normal
		normal
		variable
		variable
		weak
		ephemeron
		nil
		immediate
		nil
		longs
		words				nil
		shorts				nil nil nil
		bytes				nil nil nil nil nil nil nil
		compiledMethod	nil nil nil nil nil nil nil)
			at: self instSpec + 1) ifNil:
				[self error: 'invalid class type']!

Behavior removeSelector: #kindOfSubclassSpur!

!methodRemoval: Behavior #kindOfSubclassSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
kindOfSubclassSpur
	"Answer a String that is the keyword that describes the receiver's kind of subclass,
	 either a regular subclass, a variableSubclass, a variableByteSubclass,
	 a variableWordSubclass, a weakSubclass, an ephemeronSubclass or an immediateSubclass.
	 c.f. typeOfClass & instSpec"
	^(#(' subclass: '
		' subclass: '
		' variableSubclass: '
		' variableSubclass: '
		' weakSubclass: '
		' ephemeronSubclass: '
		nil
		' immediateSubclass: '
		nil
		' variableDoubleWordSubclass: '
		' variableWordSubclass: '		nil
		' variableDoubleByteSubclass: '	nil nil nil
		' variableByteSubclass: '		nil nil nil nil nil nil nil
		' variableByteSubclass: '		nil nil nil nil nil nil nil )
			at: self instSpec + 1) ifNil:
				[self error: 'invalid class type']!

Behavior removeSelector: #indexIfCompact!

!methodRemoval: Behavior #indexIfCompact stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
indexIfCompact
	"If these 5 bits are non-zero, then instances of this class
	will be compact.  It is crucial that there be an entry in
	Smalltalk compactClassesArray for any class so optimized.
	See the msgs becomeCompact and becomeUncompact."

	"Spur doesn't allow Compact Classes"
	Smalltalk isSpur ifTrue: [ ^ 0 ].

	^ (format bitShift: -11) bitAnd: 16r1F
"
Smalltalk compactClassesArray withIndexDo: 
	[:c :i | c == nil ifFalse:
		[c indexIfCompact = i ifFalse: [self halt]]]
"!

Behavior removeSelector: #primitiveIdentityHash!

!methodRemoval: Behavior #primitiveIdentityHash stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
primitiveIdentityHash
	"Answer a SmallInteger whose value is related to the receiver's identity.
	 Behavior implements identityHash to allow the VM to use an object representation which
	 does not include a direct reference to an object's class in an object.  If the VM is using
	 this implementation then classes are held in a class table and instances contain the index
	 of their class in the table.  A class's class table index is its identityHash so that an instance
	 can be created without searching the table for a class's index.  The VM uses this primitive
	 to enter the class into the class table, assigning its identityHash with an as yet unused
	 class table index. If this primitive fails it means that the class table is full.  In Spur as of
	 2014 there are 22 bits of classTable index and 22 bits of identityHash per object.

	 Primitive. Essential. Do not override. See Object documentation whatIsAPrimitive."

	<primitive: 175>
	self primitiveFailed.!

Behavior removeSelector: #isVariableSpur!

!methodRemoval: Behavior #isVariableSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
isVariableSpur
	"Answer whether the receiver has indexable variables.
	 Above Cog Spur the class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"
	| instSpec |
	instSpec := self instSpec.
	^instSpec >= 2 and: [instSpec <= 4 or: [instSpec >= 9]]!

Behavior removeSelector: #isVariablePreSpur!

!methodRemoval: Behavior #isVariablePreSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
isVariablePreSpur
	"Answer whether the receiver has indexable variables."

	^ self instSpec >= 2!

Behavior removeSelector: #typeOfClassPreSpur!

!methodRemoval: Behavior #typeOfClassPreSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
typeOfClassPreSpur
	"Answer a symbol uniquely describing the type of the receiver"
	self instSpec = CompiledMethod instSpec ifTrue:[^#compiledMethod]. "Very special!!"
	self isBytes ifTrue:[^#bytes].
	(self isWords and:[self isPointers not]) ifTrue:[^#words].
	self isWeak ifTrue:[^#weak].
	self isVariable ifTrue:[^#variable].
	^#normal.!

Behavior removeSelector: #kindOfSubclassPreSpur!

!methodRemoval: Behavior #kindOfSubclassPreSpur stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
kindOfSubclassPreSpur
	"Answer a String that is the keyword that describes the receiver's kind 
	of subclass, either a regular subclass, a variableSubclass, a  
	variableByteSubclass, a variableWordSubclass, or a weakSubclass."
	self isWeak
		ifTrue: [^ ' weakSubclass: '].
	^ self isVariable
		ifTrue: [self isBits
				ifTrue: [self isBytes
						ifTrue: [ ' variableByteSubclass: ']
						ifFalse: [ ' variableWordSubclass: ']]
				ifFalse: [ ' variableSubclass: ']]
		ifFalse: [ ' subclass: ']!

SmallInteger class removeSelector: #definition!

!methodRemoval: SmallInteger class #definition stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
definition
	"Special class definition for Character, SmallInteger and SmallFloat64
	Required to have the same definition both for preSpur and Spur, and to be compatible with both."
	^
'Integer immediateSubclass: #SmallInteger
	instanceVariableNames: ''''
	classVariableNames: ''''
	poolDictionaries: ''''
	category: ''', self category, ''''!

SmallFloat64 class removeSelector: #definition!

!methodRemoval: SmallFloat64 class #definition stamp: 'Install-6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st 1/30/2024 19:37:17'!
definition
	"Special class definition for Character, SmallInteger and SmallFloat64
	Required to have the same definition both for preSpur and Spur, and to be compatible with both."
	^
'Float immediateSubclass: #SmallFloat64
	instanceVariableNames: ''''
	classVariableNames: ''''
	poolDictionaries: ''''
	category: ''', self category, ''''
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6172-SpurImageFormatOnly01-JuanVuletich-2024Jan04-15h08m-jmv.003.cs.st----!

'From Cuis6.3 [latest update: #6164] on 4 January 2024 at 4:34:47 pm'!

Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CharacterTable '
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Character category: #'Kernel-Text' stamp: 'Install-6173-SpurImageFormatOnly02-JuanVuletich-2024Jan04-16h33m-jmv.001.cs.st 1/30/2024 19:37:17'!
Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CharacterTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

Character class removeSelector: #initialize!

!methodRemoval: Character class #initialize stamp: 'Install-6173-SpurImageFormatOnly02-JuanVuletich-2024Jan04-16h33m-jmv.001.cs.st 1/30/2024 19:37:17'!
initialize
	"
	Character initialize
	"
	Character isImmediateClass ifTrue: [
		CharacterTable := nil ].!

Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Character category: #'Kernel-Text' stamp: 'Install-6173-SpurImageFormatOnly02-JuanVuletich-2024Jan04-16h33m-jmv.001.cs.st 1/30/2024 19:37:17'!
Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

Character initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6173-SpurImageFormatOnly02-JuanVuletich-2024Jan04-16h33m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6164] on 4 January 2024 at 4:58:37 pm'!
!Object methodsFor: 'system primitives' stamp: 'jmv 9/25/2023 16:38:31' prior: 16915122!
                       primitiveChangeClassTo: anObject
	"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have.
	Note: The primitive will fail in most cases that you think might work. This is mostly because of because of differences in the format. As an example, '(Array new: 3) primitiveChangeClassTo: Morph basicNew' would fail for two of the reasons mentioned above. Array is variable and Morph is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too short (failure #3).
	The facility is really provided for certain, very specific applications (mostly related to classes changing shape) and not for casual use."

	<primitive: 115>
	self primitiveFailed! !
!Behavior methodsFor: 'testing' stamp: 'jmv 1/4/2024 16:57:28' prior: 50335807!
                 isVariable
	"Answer whether the receiver has indexable variables.
	 Class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"
	| instSpec |
	instSpec := self instSpec.
	(instSpec between: 2 and: 4) ifTrue: [ ^true ].
	^instSpec >= 9! !
!Character methodsFor: 'comparing' stamp: 'jmv 9/25/2023 16:46:30' prior: 50336488 overrides: 50335605!
                               identityHash
	"Answer the receiver's character code."
	<primitive: 171>
	^self primitiveFailed! !
!SystemDictionary methodsFor: 'special objects' stamp: 'jmv 9/25/2023 16:55:34' prior: 50336760!
                             recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active process (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).
	newArray at: 25 put: nil. "This is nil in Spur, which has immediate Characters."
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	newArray at: 29 put: nil. "This is nil in Spur, no compact classes."
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization.
	In Squeak these are: DoubleByteArray, WordArray, DoubleWordArray.
	Understand why."
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.
	newArray at: 36 put: nil. "was the prototype MethodContext"
	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: []).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).

	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: []).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray
	! !
!SystemDictionary methodsFor: 'vm parameters' stamp: 'jmv 9/25/2023 17:17:28' prior: 50336951!
                       vmParameterAt: parameterIndex
	"parameterIndex is a positive integer corresponding to one of the VM's internal parameter/metric registers. 
	Answer with the current value of that register.
	Answer nil if the VM doesn't provide the register, and the primitive fails.
	
	Also see #getVMParameters and #vmParameterAt:put: These 3 methods call the 
	same primitive, whose behavior depends on argument count:
		0 args:	return an Array of VM parameter values;
  		1 arg:	return the indicated VM parameter;
  		2 args:	set the VM indicated parameter.

	VM parameters are numbered as follows:
		1	byte size of old-space (read-only)
		2	byte size of young-space (read-only)
		3	byte size of object memory (read-only)
		4	nil (was allocationCount (read-only))
		5	nil (was allocations between GCs (read-write)
		6	survivor count tenuring threshold (read-write)
		7	full GCs since startup (read-only)
		8	total milliseconds in full GCs since startup (read-only)
		9	Scavenging GCs
		10	total milliseconds in scavenging GCs since startup (read-only) since startup (read-only)
		11	tenures of surving objects since startup/last write (read-write)
		12	event trace mask; if 1 << eventType is set in the mask then event received by primGetNextEvent: will be printed to stderr.
		13	VM ticker start microseconds (Croquet/QwaqVM only)
		14	VM ticker count (Croquet/QwaqVM only)
		15	VM ticker call count (Croquet/QwaqVM only)
		16	total microseconds at idle since start-up (if non-zero)
		17	fraction of the code zone to use (Sista only; used to control code zone use to preserve sendAndBranchData on counter tripped callback)
		18	total milliseconds in full GC compaction since startup (a portion of parameter 8)
		19	scavenge threshold, the effective size of eden.  When eden fills to the threshold a scavenge is scheduled.
		20	utc microseconds at VM start-up (actually at time initialization, which precedes image load).
		21	root/remembered table size (occupancy) (read-only)
		22	root table overflows since startup (read-only)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc (stored in image file header).
		24	memory threshold above which to shrink object memory (read-write)
		25	ammount to grow by when growing object memory (read-write)
		26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (read-write)
		27	number of times mark loop iterated for current IGC/FGC (read-only) includes ALL marking
		28	number of times sweep loop iterated for current IGC/FGC (read-only)
		29	number of times make forward loop iterated for current IGC/FGC (read-only)
		30	number of times compact move loop iterated for current IGC/FGC (read-only)
		31	number of grow memory requests (read-only)
		32	number of shrink memory requests (read-only)
		33	number of root table entries used for current IGC/FGC (read-only)
		34	bytes allocated in total since start-up or reset (read-write)
		35	number of survivor objects after current IGC/FGC (read-only)
		36	millisecond clock when current IGC/FGC completed (read-only)
		37	number of marked objects for Roots of the world, not including Root Table entries for current IGC/FGC (read-only)
		38	milliseconds taken by current IGC (read-only)
		39	Number of finalization signals for Weak Objects pending when current IGC/FGC completed (read-only)
		40	BytesPerOop for this image
		41	imageFormatVersion for the VM
		42	number of stack pages in use (Cog Stack VM only, otherwise nil)
		43	desired number of stack pages (stored in image file header, max 65535; Cog VMs only, otherwise nil)
		44	size of eden, in bytes (Cog VMs only, otherwise nil)
		45	desired size of eden, in bytes (stored in image file header; Cog VMs only, otherwise nil)
		46	size of machine code zone, in bytes (stored in image file header; Cog JIT VM only, otherwise nil)
		47	desired size of machine code zone, in bytes (applies at startup only, stored in image file header; Cog JIT VM only)
		48	various properties stored in the image header (that instruct the VM) as an integer encoding an array of bit flags. 
			Bit 0: tells the VM that the image's Process class has threadId as its 5th inst var (after nextLink, suspendedContext, priority & myList)
			Bit 1: on Cog JIT VMs asks the VM to set the flag bit in interpreted methods
			Bit 2: if set, preempting a process puts it to the head of its run queue, not the back,
					i.e. preempting a process by a higher priority one will not cause the preempted process to yield
						to others at the same priority.
			Bit 3: in a muilt-threaded VM, if set, the Window system will only be accessed from the first VM thread
			Bit 4: in a Spur vm, if set, causes weaklings and ephemerons to be queued individually for finalization
			Bit 5: (on VMs that support it) if set, implies wheel events will be delivered as such and not mapped to arrow key events
			Bit 6: (on VMs that support it) whether the arithmetic primitives perform conversion in case of mixed SmallInteger/Float (not set) or fail (set)
				(on VMs that don't support it, those primitives will fail in those cases)
		49	the size of the external semaphore table (read-write; Cog VMs only)
		50-51 reserved for VM parameters that persist in the image (such as eden above)
		52	root (remembered) table maximum size (read-only)
		53	the number of oldSpace segments (Spur only, otherwise nil)
		54	total size of free old space (Spur only, otherwise nil)
		55	ratio of growth and image size at or above which a GC will be performed post scavenge
		56	number of process switches since startup (read-only)
		57	number of ioProcessEvents calls since startup (read-only)
		58	number of forceInterruptCheck (Cog VMs) or quickCheckInterruptCalls (non-Cog VMs) calls since startup (read-only)
		59	number of check event calls since startup (read-only)
		60	number of stack page overflows since startup (read-only; Cog VMs only)
		61	number of stack page divorces since startup (read-only; Cog VMs only)
		62	number of machine code zone compactions since startup (read-only; Cog VMs only)
		63	milliseconds taken by machine code zone compactions since startup (read-only; Cog VMs only)
		64	current number of machine code methods (read-only; Cog VMs only)		
		65	In newer Cog VMs a set of flags describing VM features,
				if non-zero bit 0 implies multiple bytecode set support;
				if non-zero bit 1 implies read-only object support;
				if non-zero bit 2 implies the VM suffers from using an ITIMER heartbeat (if 0 it has a thread that provides the heartbeat)
			(read-only; Cog VMs only; nil in older Cog VMs, a boolean answering multiple bytecode support in not so old Cog VMs)
				if non-zero bit 3 implies the VM supports cross-platform BIT_IDENTICAL_FLOATING_POINT arithmetic
				if non-zero bit 4 implies the VM can catch exceptions in FFI calls and answer them as primitive failures
				if non-zero bit 5 implies the VM's suspend primitive backs up the process to before the wait if it was waiting on a condition variable
		66	the byte size of a stack page in the stack zone  (read-only; Cog VMs only)
		67	the maximum allowed size of old space in bytes, 0 implies no internal limit (Spur VMs only).
		68	the average number of live stack pages when scanned by GC (at scavenge/gc/become et al)
		69	the maximum number of live stack pages when scanned by GC (at scavenge/gc/become et al)
		70	the value of VM_PROXY_MAJOR (the interpreterProxy major version number)
		71	the value of VM_PROXY_MINOR (the interpreterProxy minor version number)
		72	total milliseconds in full GCs Mark phase since startup (read-only)
		73	total milliseconds in full GCs Sweep phase since startup (read-only, can be 0 depending on compactors)
		74	maximum pause time due to segment allocation
		75	whether arithmetic primitives will do mixed type arithmetic; if false they fail for different receiver and argument types
		76	the minimum unused headroom in all stack pages; Cog VMs only"

	<primitive: 254>
	(parameterIndex isInteger
	 and: [parameterIndex > 0]) ifTrue:
		[^nil].
	self primitiveFailed! !
!SystemDictionary methodsFor: 'vm parameters' stamp: 'jmv 9/25/2023 17:19:48' prior: 50337152!
      vmParameterAt: parameterIndex put: newValue
	"parameterIndex is a positive integer corresponding to one of the VM's internal
	parameter/metric registers.  Store newValue (a positive integer) into that
	register and answer with the previous value that was stored there.
	Fail if newValue is out of range, if parameterIndex has no corresponding
	register, or if the corresponding register is read-only.

	As of late 2020 the parameters which can be set are
		5	allocations between GCs (read-write; nil in Cog VMs)
		6	survivor count tenuring threshold (read-write)
		11	tenures of surving objects since startup/last write (read-write)
		12	event trace mask; if 1 << eventType is set in the mask then event received by primGetNextEvent: will be printed to stderr.
		17	proportion of code zone available for use (Sista VMs only)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc.
		24	memory threshold above whichto shrink object memory (read-write)
		25	memory headroom when growing object memory (read-write)
		26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (read-write)
		34	bytes allocated in total since start-up or reset (read-write)
		43	desired number of stack pages (stored in image file header, max 65535; Cog VMs only, otherwise nil)
		45	desired size of eden, in bytes (stored in image file header; Cog VMs only, otherwise nil)
		47	desired size of machine code zone, in bytes (applies at startup only, stored in image file header; Cog JIT VM only)
		48	various properties of the Cog VM as an integer encoding an array of bit flags.
			Bit 0: tells the VM that the image's Process class has threadId as its 5th inst var (after nextLink, suspendedContext, priority & myList)
			Bit 1: on Cog JIT VMs asks the VM to set the flag bit in interpreted methods
			Bit 2: if set, preempting a process puts it to the head of its run queue, not the back,
					i.e. preempting a process by a higher priority one will not cause the preempted process to yield
						to others at the same priority.
			Bit 3: in a muilt-threaded VM, if set, the Window system will only be accessed from the first VM thread
			Bit 4: in a Spur vm, if set, causes weaklings and ephemerons to be queued individually for finalization
			Bit 5: (on VMs that support it) if set, implies wheel events will be delivered as such and not mapped to arrow key events
			Bit 6: (on VMs that support it) whether the arithmetic primitives perform conversion in case of mixed SmallInteger/Float (not set) or fail (set)
				(on VMs that don't support it, those primitives will fail in those cases)
		49	the size of the external semaphore table (read-write; Cog VMs only)
		55	ratio of growth and image size at or above which a GC will be performed post scavenge (Spur only, otherwise nil)
		67	the maximum allowed size of old space in bytes, 0 implies no internal limit (Spur only).
		68	the average number of live stack pages when scanned by GC (at scavenge/gc/become et al)
		69	the maximum number of live stack pages when scanned by GC (at scavenge/gc/become et al)
		74 maximum pause time due to segment allocation
		75 whether arithmetic primitives will do mixed type arithmetic; if false they fail for different receiver and argument types"

	<primitive: 254>
	self primitiveFailed! !
!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 9/25/2023 16:02:21' prior: 50337670!
             printSpaceAnalysis: threshold on: aStream
	"Warning!!
	This is most likely wrong. It was written for 32 bit V3 images.
	Please take a look at #spaceForInstancesOf:
	Review both methods, and any other one that might be related.
	"
	"
	SpaceTally new printSpaceAnalysis: 1 on:(FileStream forceNewFileNamed: 'STspace.text')
	"
	"sd-This method should be rewrote to be more coherent within the rest of the class 
	ie using preAllocate and spaceForInstanceOf:"

	"If threshold > 0, then only those classes with more than that number
	of instances will be shown, and they will be sorted by total instance space.
	If threshold = 0, then all classes will appear, sorted by name."

	| codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |
	Smalltalk garbageCollect.
	totalCodeSpace := totalInstCount := totalInstSpace := n := 0.
	results := OrderedCollection new: Smalltalk classNames size.
	'Taking statistics...'
		displayProgressAt: Sensor mousePoint
		from: 0 to: Smalltalk classNames size
		during: [ :barBlock |
			Smalltalk allClassesDo: [ :cl |
				codeSpace := cl spaceUsed.
				barBlock value: (n := n+1).
				Smalltalk garbageCollectMost.
				instCount := cl instanceCount.
				instSpace := 8 * instCount. "Object headers""Warning: The 3rd header word for big objects is not considered!!"
				cl isVariable
					ifTrue: [
						eltSize := cl isBytes ifTrue: [1] ifFalse: [4].
						cl allInstancesDo: [ :x |
							instSpace := instSpace + (x basicSize * eltSize)]]
					ifFalse: [instSpace := instSpace + (cl instSize * instCount * 4)].
				results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).
				totalCodeSpace := totalCodeSpace + codeSpace.
				totalInstCount := totalInstCount + instCount.
				totalInstSpace := totalInstSpace + instSpace]].
	totalPercent := 0.0.

	aStream timeStamp.
	aStream
		nextPutAll: ('Class' padded: #right to: 30 with: $ );
		nextPutAll: ('code space' padded: #left to: 12 with: $ );
		nextPutAll: ('# instances' padded: #left to: 12 with: $ );
		nextPutAll: ('inst space' padded: #left to: 12 with: $ );
		nextPutAll: ('percent' padded: #left to: 8 with: $ ); newLine.

	threshold > 0 ifTrue: [
		"If inst count threshold > 0, then sort by space"
		results := (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])
			asArray sort: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].

	results do: [:s |
		aStream
			nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );
			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );
			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );
			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).
		percent := s spaceForInstances*100.0/totalInstSpace.
		totalPercent := totalPercent + percent.
		percent >= 0.1 ifTrue: [
			percent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil ].
		aStream newLine].

	aStream
		newLine; nextPutAll: ('Total' padded: #right to: 30 with: $ );
		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ ).
	totalPercent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6174-SpurImageFormatOnly03-JuanVuletich-2024Jan04-16h34m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6167] on 6 January 2024 at 3:16:13 pm'!
!Character methodsFor: 'testing' stamp: 'jmv 1/4/2024 21:28:30'!
                            isValidInFilenames
	"Can be part of a filename?
		$< isValidInFilenames
		$a isValidInFilenames
		$| isValidInFilenames
		$^ isValidInFilenames
		$: isValidInFilenames
	"
	self isNullCharacter ifTrue: [ ^false ].
	self isSeparator ifTrue: [ ^false ].
	^(#( $: $< $> $| $/ $\ $? $* $") statePointsTo: self) not.! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 1/6/2024 15:06:55'!
                              isValidInFilenames
self flag: #unicodeNeedsImprovement.
	self asCharacter ifNotNil: [ :ch | ^ch isValidInFilenames ].
	^true! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 1/4/2024 21:29:27' prior: 16813418!
    asFileName
	"Answer a String made up from the receiver that is an acceptable file name."

	^ self collect: [ :char |
		char isValidInFilenames
			ifFalse: [$#] 
			ifTrue: [char]].! !

CharacterSequence removeSelector: #indexOfAnyOf:!

!methodRemoval: CharacterSequence #indexOfAnyOf: stamp: 'Install-6175-String-refactor-JuanVuletich-2024Jan06-14h57m-jmv.004.cs.st 1/30/2024 19:37:17'!
indexOfAnyOf: aCharacterSet
	"returns the index of the first character in the given set, starting from 1."

	^ self indexOfAnyOf: aCharacterSet startingAt: 1 ifAbsent: 0!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6175-String-refactor-JuanVuletich-2024Jan06-14h57m-jmv.004.cs.st----!

'From Cuis6.3 [latest update: #6168] on 6 January 2024 at 3:54:22 pm'!
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 1/4/2024 22:06:45'!
                          findFirstBasicAt: aBlock startingAt: firstIndex
	"Return the index of my first element for which aBlock evaluates as true.
	Start at firstIndex.
	Use #basicAt: for accessing elements, not #at:
	This means, for String, evaluate aBlock on each byte."

	| s index |
	s := self size.
	index := firstIndex.
	[
		index <= s ] whileTrue: [
			(aBlock value: (self basicAt: index)) ifTrue: [^index ].
			index := index + 1.
			].
	^ 0! !
!String methodsFor: 'accessing' stamp: 'jmv 1/6/2024 15:26:41'!
                  indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start.
	aByteSetByteArray is a ByteArray of size 256 with a 1 for byte values considered to be included."

	| answer |
	answer := ByteArray findFirstInBytes: self inSet: aByteSetByteArray startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock value ]
		ifFalse: [ answer]! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/6/2024 15:31:57'!
                          indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start."

	"Fast lane."
	| index |
	self isAscii ifTrue: [
		^ bytes indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock ].

	"If only ASCII bytes are included in the map..."
	(ByteArray indexOfByte: 1 inBytes: aByteSetByteArray startingAt: 128) = 0 ifTrue: [
		|startBI foundBI|
		startBI := self byteIndexAt: start.
		foundBI := bytes indexOfAnyIn: aByteSetByteArray startingAt: startBI ifAbsent: aBlock.
		^ self codePointIndexAt: foundBI ].

	index := start.
	self do: [ :codePoint |
		codePoint iso8859s15Code ifNotNil: [ :ii |
			(aByteSetByteArray at: ii + 1) > 0 ifTrue: [ ^index ]].
		index := index + 1].

	^aBlock value! !
!ByteArray methodsFor: 'accessing' stamp: 'jmv 1/6/2024 15:32:59'!
       indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start.
	aByteSetByteArray is a ByteArray of size 256 with a 1 for byte values considered to be included."

	| answer |
	answer := ByteArray findFirstInBytes: self inSet: aByteSetByteArray startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock value ]
		ifFalse: [ answer]! !
!String methodsFor: 'converting' stamp: 'jmv 1/6/2024 15:37:39' prior: 16960260!
                unescapePercents
	"change each %XY substring to the character with ASCII value XY in hex.
	This is the opposite of #percentEscapingNonAscii: and #percentEscapingNonAsciiAndThoseIn:bytes:
	(String percentEscapingNonAscii: '⊙' bytes) unescapePercents
	'%E2%8A%99' unescapePercents
	"

	| myBytes answerClass answerBytes c decodedByte pos oldPos specialCharsByteSet |
	myBytes := self asByteArray.
	specialCharsByteSet := `ByteArray new: 256 :: at: $+ asciiValue + 1 put: 1; at: $% asciiValue + 1 put: 1; yourself`.
	answerClass := String.
	answerBytes := ByteArray streamContents: [ :byteStream |
		oldPos := 1.

		[pos := myBytes indexOfAnyIn: specialCharsByteSet startingAt: oldPos ifAbsent: [ 0 ]. pos > 0 ]
		whileTrue: [
			byteStream nextPutAll: (myBytes copyFrom: oldPos to: pos - 1).
			c := self at: pos.
			c = $+ ifTrue: [byteStream nextPut: `$  asciiValue` ] ifFalse: [
				(c = $% and: [pos + 2 <= self size]) ifTrue: [
					decodedByte := (self at: pos+1) asUppercase digitValue * 16 +
						(self at: pos+2) asUppercase digitValue.
					pos := pos + 2.
					decodedByte > 255 ifTrue: [^self].	"not really an escaped string"
					decodedByte > 127 ifTrue: [ answerClass := UnicodeString ].
					byteStream nextPut: decodedByte ]
				ifFalse: [byteStream nextPut: c numericValue ]].
			oldPos := pos+1].
		byteStream nextPutAll: (myBytes copyFrom: oldPos to: self size).
	].
	^ answerClass fromUtf8Bytes: answerBytes! !
!String class methodsFor: 'services' stamp: 'jmv 1/6/2024 15:50:03' prior: 16960790!
                  isAscii: aStringOrByteArray
	"Return true if all bytes in argument are less than 128.
	This means it is a pure 7-bit ASCII.
	Valid both for instances of String (possibly with accented latin letters or other Character)
	and for utf-8 encoded ByteArrays.
	In these cases, the bytes represent the same ascii string both as String and as Utf8.
	See also #nextUtf8BytesAndCodePointInto:into:, #ascii and #nonAscii"

	| nonAsciiBytesSetBA |
	nonAsciiBytesSetBA := `(ByteArray new: 128), ((ByteArray new: 128) + 1)`.
	^ (ByteArray
		findFirstInBytes: aStringOrByteArray
		inSet: nonAsciiBytesSetBA
		startingAt: 1)
			= 0.! !
!String class methodsFor: 'services' stamp: 'jmv 1/6/2024 15:39:20' prior: 16960812!
string: aString lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"
	
	| charSetLineEnders start end endWithoutDelimiters |
	charSetLineEnders := `ByteArray new: 256 :: at: Character cr asciiValue + 1 put: 1; at: Character lf asciiValue + 1 put: 1; yourself`.
	start := 1.
	[
		end := aString indexOfAnyIn: charSetLineEnders startingAt: start ifAbsent: [ 0 ].
		end = 0
			ifTrue: [
				"Last line was found. Evaluate and exit.
				Note. If last char in receiver is a line separator, there's an extra empty line"
				endWithoutDelimiters := end := aString size.
				aBlock value: start value: endWithoutDelimiters value: end.
				^aString ].

		"Account for CrLf sequence"
		endWithoutDelimiters := end - 1.
		(end < aString size
			and: [(aString basicAt: end + 1) = `Character lf asciiValue`
			and: [(aString basicAt: end) = `Character cr asciiValue` ]])
				ifTrue: [ end := end + 1].

		aBlock value: start value: endWithoutDelimiters value: end.
		start := end + 1 ] repeat! !
!String class methodsFor: 'services' stamp: 'jmv 1/6/2024 15:40:11' prior: 16960845!
                             string: aByteStringOrByteArray withLineEndings: newLineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"
	| cr lf charSetLineEnders inPos outPos outString lineEndPos newOutPos lineEndingSize |
	cr := Character cr.
	lf := Character lf.
	charSetLineEnders := `ByteArray new: 256 :: at: Character cr asciiValue + 1 put: 1; at: Character lf asciiValue + 1 put: 1; yourself`.
	(aByteStringOrByteArray is: #ByteArray)
		ifTrue: [
			cr := cr asciiValue.
			lf := lf asciiValue ].

	inPos := 1.
	outPos := 1.
	lineEndingSize := newLineEndingString size.
	"This could be extremely inefficient if lineEndingString size > 1"
	outString := aByteStringOrByteArray class new: aByteStringOrByteArray size * lineEndingSize.

	[
		lineEndPos := aByteStringOrByteArray indexOfAnyIn: charSetLineEnders startingAt: inPos ifAbsent: [0].
		lineEndPos ~= 0 ] whileTrue: [
			newOutPos := outPos + (lineEndPos - inPos).
			outString replaceFrom: outPos to: newOutPos - 1 with: aByteStringOrByteArray startingAt: inPos.
			1 to: lineEndingSize do: [ :i |
				outString at: newOutPos put: (newLineEndingString at: i).
				newOutPos := newOutPos + 1 ].
			outPos := newOutPos.
			((aByteStringOrByteArray at: lineEndPos) = cr and: [
					lineEndPos < aByteStringOrByteArray size and: [ (aByteStringOrByteArray at: lineEndPos+1) = lf ] ]) ifTrue: [
				"CRLF ending"
				inPos := lineEndPos + 2 ]
			ifFalse: [ 
				"CR or LF ending"
				inPos := lineEndPos + 1 ]].

	"no more line endings.  copy the rest"
	newOutPos := outPos + (aByteStringOrByteArray size - inPos).
	outString replaceFrom: outPos to: newOutPos with: aByteStringOrByteArray startingAt: inPos.

	^outString copyFrom: 1 to: newOutPos! !
!String class methodsFor: 'services' stamp: 'jmv 1/6/2024 15:47:19' prior: 16960896!
                         substringsIn: aByteStringOrByteArray
	"Answer an array of the substrings that compose the argument.
	If argument is an UTF-8 encoded ByteArray, answer is an array of same."

	| end beginning charSetNonSeparators charSetSeparators |
	charSetSeparators := `ByteArray new: 256 ::
		at: Character space asciiValue + 1 put: 1;
		at: Character tab asciiValue + 1 put: 1;
		at: Character lf asciiValue + 1 put: 1;
		at: Character cr asciiValue + 1 put: 1;
		at: Character newPage asciiValue + 1 put: 1;
		yourself`.
	charSetNonSeparators := `ByteArray new: 256 :: += 1;
		at: Character space asciiValue + 1 put: 0;
		at: Character tab asciiValue + 1 put: 0;
		at: Character lf asciiValue + 1 put: 0;
		at: Character cr asciiValue + 1 put: 0;
		at: Character newPage asciiValue + 1 put: 0;
		yourself`.
	end := 0.
	^Array streamContents: [ :result |
		"find one substring each time through this loop"
		[ 
			"find the beginning of the next substring"
			beginning := aByteStringOrByteArray indexOfAnyIn: charSetNonSeparators startingAt: end+1 ifAbsent: nil.
			beginning notNil ] 
		whileTrue: [
			"find the end"
			end := aByteStringOrByteArray indexOfAnyIn: charSetSeparators startingAt: beginning ifAbsent: [ aByteStringOrByteArray size + 1 ].
			end := end - 1.
			result nextPut: (aByteStringOrByteArray copyFrom: beginning to: end).
		]
	].! !
!ByteArray class methodsFor: 'services' stamp: 'jmv 1/6/2024 15:50:15' prior: 16801681!
        findFirstInBytes: aByteArrayOrByteString inSet: aByteSetByteArray startingAt: start
	| i stringSize |
	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>

	aByteSetByteArray size ~= 256 ifTrue: [ ^0 ].

	i := start.
	stringSize := aByteArrayOrByteString size.
	[ i <= stringSize and: [ (aByteSetByteArray at: (aByteArrayOrByteString basicAt: i) +1) = 0 ] ] whileTrue: [ 
		i := i + 1 ].

	i > stringSize ifTrue: [ ^0 ].
	^i! !

ByteArray removeSelector: #indexOfAnyOf:startingAt:ifAbsent:!

!methodRemoval: ByteArray #indexOfAnyOf:startingAt:ifAbsent: stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:37:17'!
indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start"

	| answer |
	answer := ByteArray findFirstInBytes: self inSet: aCharacterSet byteArrayMap startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock value ]
		ifFalse: [ answer]!

UnicodeString removeSelector: #indexOfAnyOf:startingAt:ifAbsent:!

!methodRemoval: UnicodeString #indexOfAnyOf:startingAt:ifAbsent: stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:37:17'!
indexOfAnyOf: aCharacterSet startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start."

	"Fast lane."
	| index |
	self isAscii ifTrue: [
		^ bytes indexOfAnyOf: aCharacterSet startingAt: start ifAbsent: aBlock ].
	aCharacterSet isAscii ifTrue: [ |startBI foundBI|
		startBI := self byteIndexAt: start.
		foundBI := bytes indexOfAnyOf: aCharacterSet startingAt: startBI ifAbsent: aBlock.
		^ self codePointIndexAt: foundBI ].

	index := start.
	self do: [ :codePoint |
		(aCharacterSet includes: codePoint) ifTrue: [ ^index ].
		index := index + 1].

	^aBlock value!

String class removeSelector: #basicCharSetNonSeparators!

!methodRemoval: String class #basicCharSetNonSeparators stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:37:17'!
basicCharSetNonSeparators
	"CR and LF--characters that terminate a line"
	| answer |
	answer := CharacterSet new.
	0 to: 255 do: [ :i | | char |
		char := Character numericValue: i.
		char isSeparator ifFalse: [
			answer add: char ]].
	^answer!

String class removeSelector: #charSetSeparators!

!methodRemoval: String class #charSetSeparators stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:37:17'!
charSetSeparators
	"CR and LF--characters that terminate a line"
	^`CharacterSet new addAll: Character separators; yourself`.!

String class removeSelector: #charSetLineEnders!

!methodRemoval: String class #charSetLineEnders stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:37:17'!
charSetLineEnders
	"CR and LF--characters that terminate a line"
	^`CharacterSet new
		add: Character cr;
		add: Character lf;
		yourself`.!

String class removeSelector: #charSetNonSeparators!

!methodRemoval: String class #charSetNonSeparators stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:37:17'!
charSetNonSeparators
	"CR and LF--characters that terminate a line"
	^`String basicCharSetNonSeparators`.!

String removeSelector: #indexOfAnyOf:startingAt:ifAbsent:!

!methodRemoval: String #indexOfAnyOf:startingAt:ifAbsent: stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:37:17'!
indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start"

	| answer |
	answer := ByteArray findFirstInBytes: self inSet: aCharacterSet byteArrayMap startingAt: start.

	^answer = 0 
		ifTrue: [ aBlock value ]
		ifFalse: [ answer]!

Collection removeSelector: #asCharacterSet!

!methodRemoval: Collection #asCharacterSet stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:37:17'!
asCharacterSet
	"Answer a CharacterSet whose elements are the unique elements of the receiver.  The receiver should only contain characters"

	^self as: CharacterSet!

Smalltalk removeClassNamed: #CharacterSet!

!classRemoval: #CharacterSet stamp: 'Install-6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st 1/30/2024 19:37:17'!
Collection subclass: #CharacterSet
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6176-CharacterSet-remove-JuanVuletich-2024Jan06-15h26m-jmv.002.cs.st----!

'From Cuis6.3 [latest update: #6169] on 8 January 2024 at 9:39:36 am'!
!Character class methodsFor: 'converting' stamp: 'jmv 1/7/2024 19:23:27'!
      utf8BytesAndCodePointForIso8859s1: byte into: bytesBlock into: codePointBlock
	"Latin-1"
	| codePoint |
	codePoint := byte.
	bytesBlock ifNotNil: [
		Character
			evaluateOnce: bytesBlock
			withUtf8BytesOfUnicodeCodePoint: codePoint ].
	codePointBlock ifNotNil: [
		codePointBlock value: codePoint ].
	^1! !
!Character methodsFor: 'accessing' stamp: 'jmv 1/7/2024 19:09:14' prior: 16810759!
                        codePoint
	"Unicode codePoint is blah blah blah"
	"
	self assert: $A codePoint hex = '16r41'.
	self assert: $€ codePoint hex = '16r20AC'.
	"
	<primitive: 171>
	^self primitiveFailed! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 08:44:44' prior: 16811258!
    codePoint: codePoint
	"
	Answer nil if the Unicode codePoint is not a valid ISO 8859-1 character
	
	self assert: (Character codePoint: 16r41) = $A.
	self assert: (Character codePoint: 16r20AC) = $€.
	"
	^ codePoint < 256 ifTrue: [
		Character numericValue: codePoint ].! !
!Character class methodsFor: 'converting' stamp: 'jmv 1/7/2024 19:30:48' prior: 16811672!
                   utf8BytesAndCodePointFor: byte1 byte2: byte2 byte3: byte3 byte4: byte4 into: bytesBlock into: codePointBlock
	"Find next UTF-8 encoded code point in argument bytes.
	Evaluate bytesBlock (if not nil). Arguments are utf8 bytes for the codePoint found.
	Evaluate codePointBlock (if not nil) with codePoint found as argument.
	Answer the number of bytes that comprised this codePoint.
	If there is an invalid UTF-8 sequence, consider the first byte an ISO-8859-1 Character, and answer 1.
	Skip codePoint U+FEFF (BOM, unneededly added by Win clipboard). Still, answer the number of bytes of the BOM sequence, to allow senders to update an index in an iteration.
	See senders."

	| codePoint |
	byte1 < 128 ifTrue: [	"single byte"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: nil value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: byte1 ].
		^ 1 ].
	
	"At least 2 bytes"
	(byte2 notNil and: [ (byte2 bitAnd: 16rC0) = 16r80 ]) ifFalse: [
		"invalid UTF-8. Assume byte1 is ISO8859-1, Latin-1."
		^ self utf8BytesAndCodePointForIso8859s1: byte1 into: bytesBlock into: codePointBlock ].
	(byte1 bitAnd: 16rE0) = 16rC0  ifTrue: [ "two bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePoint := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63).
			codePointBlock value: codePoint ].
		^2 ].
	
	"At least 3 bytes"
	(byte3 notNil and: [ (byte3 bitAnd: 16rC0) = 16r80 ]) ifFalse: [
		"invalid UTF-8. Assume byte1 is ISO8859-1, Latin-1."
		^ self utf8BytesAndCodePointForIso8859s1: byte1 into: bytesBlock into: codePointBlock ].
	(byte1 bitAnd: 16rF0) = 16rE0  ifTrue: [ "three bytes"
		codePoint :=  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
		codePoint = 16rFEFF ifTrue: [ "BOM. Ignore it. Skip ti."
			^3 ].
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: codePoint ].
		^3 ].

	"4 bytes"
	(byte4 notNil and: [ (byte4 bitAnd: 16rC0) = 16r80 ]) ifFalse: [
		"invalid UTF-8. Assume byte1 is ISO8859-1, Latin-1."
		^ self utf8BytesAndCodePointForIso8859s1: byte1 into: bytesBlock into: codePointBlock ].
	(byte1 bitAnd: 16rF8) = 16rF0  ifTrue: [  "four bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: byte4 ].
		codePointBlock ifNotNil: [
			codePoint := ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12)
					+ ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63).
			codePointBlock value: codePoint ].
		^ 4].

	"invalid UTF-8. Assume byte1 is ISO8859-1, Latin-1."
	^ self utf8BytesAndCodePointForIso8859s1: byte1 into: bytesBlock into: codePointBlock.! !
!UnicodeCodePoint methodsFor: 'accessing' stamp: 'jmv 1/8/2024 09:20:21' prior: 16992461!
    numericValue
self flag: #unicodeNeedsImprovement.
"To be removed. make it the Latin-1 codePoint for the time being.
This doesn't make much sense."
	value < 256 ifTrue: [ ^value ].
	^255! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 1/7/2024 19:41:52' prior: 16992669!
         < aCodePointOrCharacter
"pensar"
	^self codePoint < aCodePointOrCharacter codePoint! !
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 1/8/2024 09:19:22' prior: 16992707 overrides: 16913626!
                           hash
	"Hash is reimplemented because = is implemented."

	^value hash! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:04:18' prior: 16992720!
                            asLowercase
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character numericValue: value) asLowercase codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:13:07' prior: 16992740!
                    asUnaccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character numericValue: value) asUnaccented codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:04:26' prior: 16992752!
                  asUppercase
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character numericValue: value) asUppercase codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:11:20' prior: 16992471!
                    isAccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character numericValue: value) isAccented ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:11:14' prior: 16992564!
                           isUnaccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character numericValue: value) isUnaccented ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:11:46' prior: 50339517!
                       isValidInFilenames
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character numericValue: value) isValidInFilenames ].
	^true! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:11:07' prior: 16992632!
            isVowel
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^ (Character numericValue: value) isVowel ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 09:27:04' prior: 16992770!
withDiacriticalMark: anUnicodeCodePoint
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (
			(Character numericValue: value) withDiacriticalMark: anUnicodeCodePoint)
				codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'printing' stamp: 'jmv 1/8/2024 09:08:30' prior: 16992789 overrides: 16914834!
printOn: aStream 
	aStream nextPut: $$.
	aStream nextPut: self.
	value <= 32 ifTrue: [
		aStream nextPut: $".
		aStream nextPutAll: self hex.
		aStream nextPut: $" ].! !
!Date methodsFor: 'printing' stamp: 'jmv 1/7/2024 19:44:37' prior: 16842404!
         printOn: aStream format: formatArray 
	"Print a description of the receiver on aStream using the format 
	denoted the argument, formatArray: 
	
		#(item item item sep monthfmt yearfmt twoDigits) 
	
		items: 1=day 2=month 3=year will appear in the order given, 
	
		separated by sep which is eaither an ascii code or character. 
	
		monthFmt: 1=09 2=Sep 3=September 
	
		yearFmt: 1=1996 2=96 
	
		digits: (missing or)1=9 2=09. 
	
	See the examples in printOn: and mmddyy"
	| gregorian twoDigits element monthFormat |
	gregorian := self dayMonthYearDo: [ :d :m :y | {d. m. y} ].
	twoDigits := formatArray size > 6 and: [(formatArray at: 7) > 1].
	1 to: 3 do: 
		[ :i | 
			element := formatArray at: i.
			element = 1
				ifTrue: [twoDigits
						ifTrue: [aStream
								nextPutAll: (gregorian first printString
										padded: #left
										to: 2
										with: $0)]
						ifFalse: [gregorian first printOn: aStream]].
			element = 2
				ifTrue: [monthFormat := formatArray at: 5.
					monthFormat = 1
						ifTrue: [twoDigits
								ifTrue: [aStream
										nextPutAll: (gregorian middle printString
												padded: #left
												to: 2
												with: $0)]
								ifFalse: [gregorian middle printOn: aStream]].
					monthFormat = 2
						ifTrue: [aStream
								nextPutAll: ((Month nameOfMonth: gregorian middle)
										copyFrom: 1
										to: 3)].
					monthFormat = 3
						ifTrue: [aStream
								nextPutAll: (Month nameOfMonth: gregorian middle)]].
			element = 3
				ifTrue: [(formatArray at: 6)
							= 1
						ifTrue: [gregorian last printOn: aStream]
						ifFalse: [aStream
								nextPutAll: ((gregorian last \\ 100) printString
										padded: #left
										to: 2
										with: $0)]].
			i < 3
				ifTrue: [(formatArray at: 4)
							~= 0
						ifTrue: [
							aStream nextPut: ((formatArray at: 4) isNumber
								ifTrue: [ Character numericValue: (formatArray at: 4) ]
								ifFalse: [ (formatArray at: 4) ])
							]]]
! !
!String methodsFor: 'accessing' stamp: 'jmv 1/8/2024 08:51:38' prior: 16959655 overrides: 16913367!
    at: index put: aCharacter 
	"Primitive. Store the Character in the field of the receiver indicated by
	the index. Fail if the index is not an Integer or is out of bounds, or if
	the argument is not a Character. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 64>
	aCharacter isCharacter
		ifTrue: [	

			aCharacter class == UnicodeCodePoint ifTrue: [
				aCharacter codePoint > 255 ifTrue: [self error: 'String only store Latin-1 Characters'].
				^self at: index put: (Character numericValue: aCharacter codePoint) ].

			aCharacter numericValue > 255 ifTrue: [
				self error: 'String only store Latin-1 Characters'].
			index isInteger
				ifTrue: [self errorSubscriptBounds: index]
				ifFalse: [self errorNonIntegerIndex]]
		ifFalse: [self error: 'Strings only store Characters']! !
!String methodsFor: 'accessing' stamp: 'jmv 1/8/2024 09:21:57' prior: 16959727 overrides: 16947063!
                  indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| ans |
	aCharacter isCharacter ifFalse: [ ^ aBlock value ].
	"String can only hold ASCII + Latin1"
	aCharacter codePoint >255 ifTrue: [ ^ aBlock value ].
	ans := ByteArray indexOfByte: aCharacter codePoint inBytes: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ ans ]! !
!String methodsFor: 'enumerating' stamp: 'jmv 1/8/2024 08:46:40' prior: 16960316 overrides: 16814129!
                       collect: aBlock
	"Refer to the comment in Collection >> #collect:."
	| array resultClass |
	array := self collectInArray: aBlock.
	resultClass := String.
	array do: [ :element |
		element isCharacter ifFalse: [ ^array ].
		"String can only hold ISO-8859-1 (ASCII + Latin 1 Suplement)"
		element codePoint > 255 ifTrue: [
			resultClass := UnicodeString ]].
	^resultClass newFrom: array! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/8/2024 09:24:00' prior: 50339584!
    indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock
	"returns the index of the first character in the given set, starting from start.
	The set can only contain ASCII + Latin1 codePoints, i.e. < 256."

	"Fast lane."
	| index |
	self isAscii ifTrue: [
		^ bytes indexOfAnyIn: aByteSetByteArray startingAt: start ifAbsent: aBlock ].

	"If only ASCII bytes are included in the map..."
	(ByteArray indexOfByte: 1 inBytes: aByteSetByteArray startingAt: 128) = 0 ifTrue: [
		|startBI foundBI|
		startBI := self byteIndexAt: start.
		foundBI := bytes indexOfAnyIn: aByteSetByteArray startingAt: startBI ifAbsent: aBlock.
		^ self codePointIndexAt: foundBI ].

	index := start.
	self do: [ :codePoint |
		codePoint < 256 ifTrue: [
			(aByteSetByteArray at: codePoint + 1) > 0 ifTrue: [ ^index ]].
		index := index + 1].

	^aBlock value! !
!RWBinaryOrTextStream methodsFor: 'writing' stamp: 'jmv 1/7/2024 19:45:46' prior: 16934799 overrides: 17008880!
   nextPut: charOrByte

	super nextPut: 
		(charOrByte isCharacter
			ifTrue: [ charOrByte ]
			ifFalse: [ Character numericValue: charOrByte ])! !
!Encoder methodsFor: 'encoding' stamp: 'jmv 1/7/2024 19:46:50' prior: 16853478!
                               asciiStringLiteral: literalObject
	"Convert UnicodeStrings to Strings if ASCII.
	Same for UnicodeCodePoint and Character.
	Recursive for Arrays"
	
	literalObject class == Array ifTrue: [
		^literalObject collect: [ :each | self asciiStringLiteral: each ]].

	"Prefer String over UnicodeString for literals, if ASCII only."
	(literalObject class == UnicodeString and: [ literalObject isAscii ]) ifTrue: [
		^ literalObject asByteString ].
	
	"Prefer Character over UnicodeCodePoint for literals, if ASCII only."
	"bueh......"
	(literalObject class == UnicodeCodePoint and: [ literalObject asciiValue notNil ]) ifTrue: [
		^ Character codePoint: literalObject codePoint ].

	^literalObject! !

UnicodeCodePoint removeSelector: #iso8859s15Code!

!methodRemoval: UnicodeCodePoint #iso8859s15Code stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
iso8859s15Code
	"Answer the value of the receiver that represents its ISO 8859-15 (Latin-9) encoding.
	Any implementation of Character like object beyond ISO-8859-15 should answer nil.
	Senders, please consider that this method might answer nil.
	See #iso8859s15CodeForUnicodeCodePoint:"

	value < 128 ifTrue: [ ^value ]."Plain ASCII"
	self asCharacter ifNotNil: [ :ch | ^ch iso8859s15Code ].
	^nil!

UnicodeCodePoint removeSelector: #asCharacter!

!methodRemoval: UnicodeCodePoint #asCharacter stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
asCharacter
	"Might answer nil"
	^Character codePoint: value!

Character class removeSelector: #unicodeCodePoints!

!methodRemoval: Character class #unicodeCodePoints stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
unicodeCodePoints
	^`Character basicUnicodeCodePoints`!

Character class removeSelector: #basicUnicodeCodePoints!

!methodRemoval: Character class #basicUnicodeCodePoints stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
basicUnicodeCodePoints
	"Initialize the table of Unicode code points"
	| unicodeCodePoints |
	unicodeCodePoints := Array new: 256.
	0 to: 255 do: [ :code |
		unicodeCodePoints at: code + 1 put: code ].
	
	"The following codes are different in ISO 8859-15 from those in ISO 8859-1,
	so the character code is not equal to the Unicode code point"
	unicodeCodePoints at: 16rA4+1 put: 16r20AC.		"euro sign"
	unicodeCodePoints at: 16rA6+1 put: 16r160.		"latin capital letter S with caron"
	unicodeCodePoints at: 16rA8+1 put: 16r161.		"latin small letter s with caron"
	unicodeCodePoints at: 16rB4+1 put: 16r17D.		"latin capital letter Z with caron"
	unicodeCodePoints at: 16rB8+1 put: 16r17E.		"latin small letter z with caron"
	unicodeCodePoints at: 16rBC+1 put: 16r152.		"latin capital ligature OE"
	unicodeCodePoints at: 16rBD+1 put: 16r153.		"latin small ligature oe"
	unicodeCodePoints at: 16rBE+1 put: 16r178.		"latin capital letter Y with diaeresis"

	"Mathematical symbols (see Character>>#namedCharactersTable)"
	unicodeCodePoints at: 16r80+1 put: 16r221E.		"infinity"
	unicodeCodePoints at: 16r81+1 put: 16r2135.		"aleph"
	unicodeCodePoints at: 16r82+1 put: 16r2115.		"blackboard bold N"
	unicodeCodePoints at: 16r83+1 put: 16r2124.		"blackboard bold Z"
	unicodeCodePoints at: 16r84+1 put: 16r211A.		"blackboard bold Q"
	unicodeCodePoints at: 16r85+1 put: 16r211D.		"blackboard bold R"
	unicodeCodePoints at: 16r86+1 put: 16r2102.		"blackboard bold C"
	unicodeCodePoints at: 16r87+1 put: 16r2119.		"blackboard bold P"
	unicodeCodePoints at: 16r88+1 put: 16r03B1.		"alpha"
	unicodeCodePoints at: 16r89+1 put: 16r03B2.		"beta"
	unicodeCodePoints at: 16r8A+1 put: 16r03B3.		"gamma"
	unicodeCodePoints at: 16r8B+1 put: 16r03B4.		"delta"
	unicodeCodePoints at: 16r8C+1 put: 16r03B5.		"epsilon"
	unicodeCodePoints at: 16r8D+1 put: 16r03BB.		"lambda"
	unicodeCodePoints at: 16r8E+1 put: 16r03C0.		"pi"
	unicodeCodePoints at: 16r8F+1 put: 16r03B6.		"zeta"
	unicodeCodePoints at: 16r90+1 put: 16r2295.		"oplus"
	unicodeCodePoints at: 16r91+1 put: 16r2297.		"otimes"
	unicodeCodePoints at: 16r92+1 put: 16r2218.		"circ"
	unicodeCodePoints at: 16r93+1 put: 16r2293.		"prod"
	unicodeCodePoints at: 16r94+1 put: 16r2294.		"coprod"
	unicodeCodePoints at: 16r95+1 put: 16r22A5.		"perp"
	unicodeCodePoints at: 16r96+1 put: 16r0394.		"Delta"
	unicodeCodePoints at: 16r97+1 put: 16r0393.		"Gamma"
	unicodeCodePoints at: 16r98+1 put: 16r03C9.		"omega"
	unicodeCodePoints at: 16r99+1 put: 16r21A0.		"SURJECTIVE ARROW"
	unicodeCodePoints at: 16r9A+1 put: 16r21A3.		"INJECTIVE ARROW"
	unicodeCodePoints at: 16r9B+1 put: 16r2194.		"BIJECTIVE ARROW"
	unicodeCodePoints at: 16r9C+1 put: 16r21AA.		"INCLUSION ARROW"
	unicodeCodePoints at: 16r9D+1 put: 16r21A6.		"MAPPING ARROW"
	unicodeCodePoints at: 16r9E+1 put: 16r2202.		"partial differential"
	unicodeCodePoints at: 16r9F+1 put: 16r221A.		"sqrt"
	^unicodeCodePoints!

Character class removeSelector: #basicIrregularIso8859s15Codes!

!methodRemoval: Character class #basicIrregularIso8859s15Codes stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
basicIrregularIso8859s15Codes
	
	| unicodeCodePoints irregularIso8859s15Codes |
	unicodeCodePoints := Character unicodeCodePoints.
	irregularIso8859s15Codes := Dictionary new.
	0 to: 255 do: [ :iso |
		(unicodeCodePoints at: iso+1) = iso ifFalse: [
			irregularIso8859s15Codes at: (unicodeCodePoints at: iso+1) put: iso ]].
	^irregularIso8859s15Codes!

Character class removeSelector: #irregularIso8859s15Codes!

!methodRemoval: Character class #irregularIso8859s15Codes stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
irregularIso8859s15Codes
	^`Character basicIrregularIso8859s15Codes`!

Character class removeSelector: #utf8BytesAndCodePointForIso8859s15:into:into:!

!methodRemoval: Character class #utf8BytesAndCodePointForIso8859s15:into:into: stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
utf8BytesAndCodePointForIso8859s15: iso8859s15 into: bytesBlock into: codePointBlock
	| codePoint |
	codePoint := (Character numericValue: iso8859s15) codePoint.
	bytesBlock ifNotNil: [
		Character
			evaluateOnce: bytesBlock
			withUtf8BytesOfUnicodeCodePoint: codePoint ].
	codePointBlock ifNotNil: [
		codePointBlock value: codePoint ].
	^1!

Character class removeSelector: #iso8859s15CodeForUnicodeCodePoint:!

!methodRemoval: Character class #iso8859s15CodeForUnicodeCodePoint: stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
iso8859s15CodeForUnicodeCodePoint: codePoint
	"
	Answer nil if the Unicode codePoint is not a valid ISO 8859-15 character
	
	self assert: (Character iso8859s15CodeForUnicodeCodePoint: 16r41) = $A iso8859s15Code.
	self assert: (Character iso8859s15CodeForUnicodeCodePoint: 16r20AC) = $€ iso8859s15Code.
	"

	"For most 8 bit Characters, ISO 8859-15 and Unicode Code Point are the same. Fast path."
	(codePoint < 256 and: [ (self unicodeCodePoints at: codePoint+1) = codePoint ])
		ifTrue: [ ^codePoint ].

	^ self irregularIso8859s15Codes at: codePoint ifAbsent: nil.!

Character removeSelector: #iso8859s15Code!

!methodRemoval: Character #iso8859s15Code stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
iso8859s15Code
	"Answer the value of the receiver that represents its ISO 8859-15 (Latin-9) encoding.
	Any implementation of Character like object beyond ISO-8859-15 should answer nil.
	Senders, please consider that this method might answer nil.
	See #iso8859s15CodeForUnicodeCodePoint:"

	^ self numericValue!

Character removeSelector: #is:!

!methodRemoval: Character #is: stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
is: aSymbol
	^ aSymbol == #Character or: [ super is: aSymbol ]!

Character removeSelector: #asCharacter!

!methodRemoval: Character #asCharacter stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
asCharacter
	"Answer the receiver itself."
	^self!

Integer removeSelector: #asCharacter!

!methodRemoval: Integer #asCharacter stamp: 'Install-6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st 1/30/2024 19:37:17'!
asCharacter
	"Answer the Character whose value is the receiver."

	^Character numericValue: self!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6177-String-supportLatin1-JuanVuletich-2024Jan08-08h44m-jmv.006.cs.st----!

'From Cuis6.3 [latest update: #6170] on 8 January 2024 at 10:14:17 am'!
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 10:10:47' prior: 16811813!
          basicLookupTables
	| lowercaseMappingTable uppercaseMappingTable unaccentedTable |
	lowercaseMappingTable := Array new: 256.
	uppercaseMappingTable := Array new: 256.
	unaccentedTable := ByteArray new: 256.
	0
		to: 255
		do: [ :idx | | char |
			"Default to an identity mapping with a false truth mapping"
			char := self numericValue: idx.
			lowercaseMappingTable
				at: idx + 1 put: char.
			uppercaseMappingTable
				at: idx + 1 put: char.
			unaccentedTable at: idx + 1 put: idx].
	"Now override as needed"
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :group | | uppercase lowercase |
		group size > 1
			ifTrue: [ | lowercaseChar uppercaseChar |
				uppercase := group first numericValue.
				lowercase := group second numericValue.
				lowercaseChar := self numericValue: lowercase.
				uppercaseChar := self numericValue: uppercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar;
					at: uppercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: uppercaseChar;
					at: uppercase + 1 put: uppercaseChar.
				group size > 2
					ifTrue: [|unaccentedUppercase unaccentedLowercase|
						unaccentedUppercase := group third numericValue.
						unaccentedLowercase := group fourth numericValue.
						unaccentedTable
							at: uppercase+1 put: unaccentedUppercase;
							at: lowercase+1 put: unaccentedLowercase]]
			ifFalse: [ | lowercaseChar |
				lowercase := group first numericValue.
				lowercaseChar := self numericValue: lowercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: lowercaseChar ]].
	^{ lowercaseMappingTable. uppercaseMappingTable. unaccentedTable}.! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 10:10:52' prior: 16811969!
         lowercaseMappingTable
	^`Character basicLookupTables at: 1`.! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 10:10:54' prior: 16811974!
    unaccentedTable
	^`Character basicLookupTables at: 3`.! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 10:10:57' prior: 16811984!
          uppercaseMappingTable
	^`Character basicLookupTables at: 2`.! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 10:10:18' prior: 16961081!
       tokenishTable
	"a table for testing tokenish (for fast numArgs)"
	^`String withAll: (
		((0 to: 255) collect: [ :c | (Character numericValue: c) ])
			collect: 	[ :c | c tokenish ifTrue: [c] ifFalse: [$~]]	)`.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6178-coda-JuanVuletich-2024Jan08-10h10m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 11:21:58 am'!
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 11:13:00' prior: 16810989!
                              isVowel
	"Answer whether the receiver is one of the vowels, AEIOU, in upper or 
	lower case, and with various diacritical marks."

self flag: #unicodeNeedsImprovement.
	^Character vowels includes: self! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 11:13:46' prior: 16811142!
               accentedLetters
	"Answer all letters with all possible accents (combining diacritical marks).
	Order of this array is:
		unaccented
		U+0300 	COMBINING GRAVE ACCENT
		U+0301 	COMBINING ACUTE ACCENT
		U+0302 	COMBINING CIRCUMFLEX ACCENT
		U+0303 	COMBINING TILDE
		U+0308 	COMBINING DIAERESIS
		U+030A 	COMBINING RING ABOVE
		U+030C 	COMBINING CARON
	Do not include letters that can't have any accent in ISO 8859-15
	Denote unsupported combinations (for example A with caron, or N with accute accent) by a $-"
self flag: #unicodeNeedsImprovement.
	^#(
		'AÀÁÂÃÄÅ-'
		'aàáâãäå-'
		'EÈÉÊ-Ë--'
		'eèéê-ë--'
		'IÌÍÎ-Ï--'
		'iìíî-ï--'
		'OÒÓÔÕÖ--'
		'oòóôõö--'
		'UÙÚÛ-Ü--'
		'uùúû-ü--'
		'N---Ñ---'
		'n---ñ---'
		'S------Š'
		's------š'
		'Y-Ý--Ÿ--'
		'y-ý--ÿ--'
		'Z------Ž'
		'z------ž'
	).! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 11:14:27' prior: 16811211!
            uppercaseLowercaseAndUnaccentedLetters
	"Answer all uppercase and lowercase letters in standard collation order.
	For accented characters, include the non-accented ones.
	Note that $ß is 'LATIN SMALL LETTER SHARP S' and ISO 8859-15 doesn't have an uppercase version."
self flag: #unicodeNeedsImprovement.
	^#(
		'Aa' 'ÀàAa' 'ÁáAa' 'ÂâAa' 'ÃãAa' 'ÄäAa' 'ÅåAa'
		'Bb' 'Cc' 'Çç' 'Dd'
			'Ee' 'ÈèEe' 'ÉéEe' 'ÊêEe' 'ËëEe'
		'Ff' 'Gg' 'Hh'
			'Ii' 'ÌìIi' 'ÍíIi' 'ÎîIi' 'ÏïIi'
		'Jj' 'Kk' 'Ll' 'Mm' 'Nn' 'Ññ'
			'Oo' 'ÒòOo' 'ÓóOo' 'ÔôOo' 'ÕõOo' 'ÖöOo'
		'Pp' 'Qq' 'Rr'
			'Ss' 'ŠšSs'
		'Tt'
			'Uu' 'ÙùUu' 'ÚúUu' 'ÛûUu' 'ÜüUu'
		'Vv' 'Ww' 'Xx'
			'Yy' 'ÝýYy' 'ŸÿYy'
			'Zz' 'ŽžZz' 
		'Ææ' 'Ðð' 'Øø' 'Þþ' 'ß' 'Œœ'
	).! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 11:15:30' prior: 16811319!
                separators
self flag: #unicodeNeedsImprovement.
	"Also see #isSeparator"
	^ #(32 "space"
		13 "cr"
		9 "tab"
		10 "line feed"
		12 "form feed")
		collect: [:v | Character numericValue: v]

	
! !

Character class removeSelector: #greekUppercaseLetters!

!methodRemoval: Character class #greekUppercaseLetters stamp: 'Install-6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st 1/30/2024 19:37:17'!
greekUppercaseLetters
	"Answer the uppercase greek letters included in our font within the ASCII range.
	These are considered uppercase letters and can be used as identifiers (variable names, keyword or unary messages, etc)."
	^ 'ΔΓ'!

Character class removeSelector: #lfCharacter!

!methodRemoval: Character class #lfCharacter stamp: 'Install-6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st 1/30/2024 19:37:17'!
lfCharacter
	"Answer the Character representing a linefeed."
	"Deprecated. To be removed soon. Please use #lf"

	^self lf!

Character class removeSelector: #greekLowercaseLetters!

!methodRemoval: Character class #greekLowercaseLetters stamp: 'Install-6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st 1/30/2024 19:37:17'!
greekLowercaseLetters
	"Answer the lowercase greek letters included in our font within the ASCII range.
	These are considered lowercase letters and can be used as identifiers (variable names, keyword or unary messages, etc)."
	^ 'αβγδελπζµω'!

Character class removeSelector: #crCharacter!

!methodRemoval: Character class #crCharacter stamp: 'Install-6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st 1/30/2024 19:37:17'!
crCharacter
	"Answer the Character representing a carriage return."
	"Deprecated. To be removed soon. Please use #cr"

	^self cr!

Character class removeSelector: #blackboardLetters!

!methodRemoval: Character class #blackboardLetters stamp: 'Install-6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st 1/30/2024 19:37:17'!
blackboardLetters
	"Answer the 'blackboard bold' or 'double struck' letters included in our font within the ASCII range.
	These are considered uppercase letters and can be used as identifiers (variable names, keyword or unary messages, etc)."
	^ 'ℕℤℚℝℂℙ'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6179-Character-cleanup-JuanVuletich-2024Jan08-11h10m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 11:47:38 am'!
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 11:30:16' prior: 16810819!
 < aCharacter 
	"Compare with the standard case sensitive collation order.
	This stuff should be in Character and not in String..."

	self == aCharacter ifTrue: [ ^false ].

	(self codePoint < 256 and: [ aCharacter codePoint < 256 ]) ifTrue: [
		^String does: self collateBefore: aCharacter ].
	
	^self codePoint < aCharacter codePoint.! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 11:38:34' prior: 16810829!
                          <= aCharacter 
	"Answer whether the receiver is less than or equal to the argument."

	^(self > aCharacter) not.! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 11:39:12' prior: 16810837 overrides: 16913610!
     = aCodePointOrCharacter

	self == aCodePointOrCharacter ifTrue: [ ^true ].

	"Just remove this method and use inherited version when we remove UnicodeCodePoint ?"
	aCodePointOrCharacter class == UnicodeCodePoint ifFalse: [ ^false ].

	aCodePointOrCharacter isCharacter ifFalse: [ ^false ].
	^self codePoint = aCodePointOrCharacter codePoint! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 11:31:16' prior: 16810845!
                     > aCharacter 
	"Compare with the standard case sensitive collation order.
	This stuff should be in Character and not in String..."

	self == aCharacter ifTrue: [ ^false ].

	(self codePoint < 256 and: [ aCharacter codePoint < 256 ]) ifTrue: [
		^String does: self collateAfter: aCharacter ].
	
	^self codePoint > aCharacter codePoint.! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 11:39:54' prior: 16810855!
                           >= aCharacter 
	"Answer whether the receiver is greater than or equal to the argument."

	^(self < aCharacter) not.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6180-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h24m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 11:58:37 am'!
!Collection methodsFor: 'testing' stamp: 'jmv 1/8/2024 11:52:21'!
                 canHoldAnyCodePoint
	"Why not?"
	^true! !
!String methodsFor: 'converting' stamp: 'jmv 1/8/2024 11:54:45'!
                     thatCanHoldAnyCodePoint
	"See senders.
	Also see #asStreamResult"
	^ArrayOfCharactersAndCodePoints withAll: self! !
!String methodsFor: 'testing' stamp: 'jmv 1/8/2024 11:53:48' overrides: 50340955!
                          canHoldAnyCodePoint
	"Nope.
	We can only hold Code Points less than 256.
	Needs something like UnicodeString for others. Even an Array is better than us."
	^false! !
!Text methodsFor: 'converting' stamp: 'jmv 1/8/2024 11:54:54'!
                           thatCanHoldAnyCodePoint
	"See senders.
	Also see #asStreamResult	"
	string := string thatCanHoldAnyCodePoint! !
!Text methodsFor: 'testing' stamp: 'jmv 1/8/2024 11:52:30' overrides: 50340955!
canHoldAnyCodePoint
	"Ask our string"
	^string canHoldAnyCodePoint! !
!String methodsFor: 'copying' stamp: 'jmv 1/8/2024 11:51:02' prior: 16960080 overrides: 16947652!
                        copyWith: newElement
	newElement codePoint > 255 ifFalse: [
		^self asUnicodeString copyWith: newElement ].
	^super copyWith: newElement! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/8/2024 11:58:03' prior: 17008880 overrides: 16959125!
           nextPut: anObject 
	"Insert the argument at the next position in the Stream represented by the receiver."

	(anObject isCharacter and: [anObject codePoint > 255 and: [collection canHoldAnyCodePoint not]]) ifTrue: [
		collection := collection thatCanHoldAnyCodePoint ].
	position >= writeLimit
		ifTrue: [^ self pastEndPut: anObject]
		ifFalse: [
			position := position + 1.
			^collection at: position put: anObject].! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/8/2024 11:55:05' prior: 17008895 overrides: 16959137!
                 nextPutAll: aCollection

	| newEnd |
	(aCollection canHoldAnyCodePoint and: [collection canHoldAnyCodePoint not]) ifTrue: [
		collection := collection thatCanHoldAnyCodePoint ].
	(self isCompatibleWithContents: aCollection)
		ifFalse: [ ^ super nextPutAll: aCollection ].

	newEnd := position + aCollection size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.
	position := newEnd.! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/8/2024 11:55:08' prior: 17008912!
            nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(aString canHoldAnyCodePoint and: [collection canHoldAnyCodePoint not]) ifTrue: [
		collection := collection thatCanHoldAnyCodePoint ].
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ self nextPutAll: aString ].

	newEnd := position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position := newEnd! !

Text removeSelector: #thatCanHoldCodePoints!

!methodRemoval: Text #thatCanHoldCodePoints stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:37:17'!
thatCanHoldCodePoints
	"See senders.
	Also see #asStreamResult	"
	string := string thatCanHoldCodePoints!

Text removeSelector: #canHoldCodePoints!

!methodRemoval: Text #canHoldCodePoints stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:37:17'!
canHoldCodePoints
	"Ask our string"
	^string canHoldCodePoints!

String removeSelector: #thatCanHoldCodePoints!

!methodRemoval: String #thatCanHoldCodePoints stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:37:17'!
thatCanHoldCodePoints
	"See senders.
	Also see #asStreamResult"
	^ArrayOfCharactersAndCodePoints withAll: self!

String removeSelector: #canHoldCodePoints!

!methodRemoval: String #canHoldCodePoints stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:37:17'!
canHoldCodePoints
	"Nope. Needs something like UnicodeString for that. Even an Array is better than us."
	^false!

Collection removeSelector: #canHoldCodePoints!

!methodRemoval: Collection #canHoldCodePoints stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:37:17'!
canHoldCodePoints
	"Why not?"
	^true!

UnicodeCodePoint removeSelector: #isUnicodeCodePoint!

!methodRemoval: UnicodeCodePoint #isUnicodeCodePoint stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:37:17'!
isUnicodeCodePoint
	^true!

Object removeSelector: #isUnicodeCodePoint!

!methodRemoval: Object #isUnicodeCodePoint stamp: 'Install-6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st 1/30/2024 19:37:17'!
isUnicodeCodePoint
	"Overridden to return true in UnicodeCodePoint, natch"
	^ false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6181-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h47m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 12:12:17 pm'!
!String class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:08:14' prior: 16960480!
                       fromUtf8Bytes: aByteArray trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-8 to the internal encoding: ISO Latin 9 (ISO 8859-15).
	Discard any code points that can not be represented."

	^String streamContents: [ :strm | | s byteIndex n |
		s := aByteArray size.
		byteIndex := 1.
		[  byteIndex <= s ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					codePoint < 256 ifTrue: [
						strm nextPut: (Character codePoint: codePoint) ]].
			byteIndex := byteIndex + n
		].
		(doTrimLastNullChar and: [ aByteArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6182-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-11h58m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 12:14:04 pm'!
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:13:35' prior: 50340015!
          codePoint: anInteger
	"Answer the Character whose value is anInteger.
	
	self assert: (Character codePoint: 16r41) = $A.
	self assert: (Character codePoint: 16r20AC) = $€.
	"

	<primitive: 170>
	^self primitiveFailed! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6183-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h12m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 12:24:13 pm'!
!FileList methodsFor: 'private' stamp: 'jmv 1/8/2024 12:14:22' prior: 16862879!
                            readContentsHex: brevity
	"retrieve the contents from the external file unless it is too long.
	  Don't create a file here.  Check if exists."
	| size data hexData firstPartSize |
	firstPartSize := 1e3.
	directory // fileName readStreamDo: [ :stream |
		stream ifNil: [^ 'For some reason, this file cannot be read'].
		stream useBytes.
		((size := stream size)) > (10*firstPartSize) & brevity
			ifTrue: [ data := stream next: firstPartSize. brevityState := #briefHex ]
			ifFalse: [ data := stream next: size. brevityState := #fullHex ]].

	hexData := String streamContents: [ :s |
		0 to: data size-1 by: 16 do: [ :loc |
			loc printOn: s base: 16 length: 8 padded: true.
			s
				space;
				nextPut: $(.
			loc printOn: s base: 10 length: 10 padded: true.
			s
				nextPut: $);
				space;
				tab.
			loc+1 to: (loc+16 min: data size) do: [ :i | s nextPutAll: (Character codePoint: (data at: i)) hex; space ].
			s newLine ]].

	^ acceptedContentsCache := ((size > (10*firstPartSize)) & brevity
		ifTrue: ['File ''{1}'' is {2} bytes long.
You may use the ''get'' command to read the entire file.

Here are the first {3} characters...
------------------------------------------
{4}
------------------------------------------
... end of the first {3} characters.' format: {fileName. size. firstPartSize. hexData}]
		ifFalse: [hexData])! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:14:38' prior: 16811054!
                asUnaccented
	"
	$A asUnaccented
	$Á asUnaccented
	(0 to: 255) collect: [ :i | (Character codePoint: i) asUnaccented ]
	(0 to: 255) collect: [ :i | (Character codePoint: i) asUnaccented  asLowercase]
	"
	^ Character
		codePoint: (self class unaccentedTable at: self numericValue + 1)! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:27' prior: 16811078!
            to: other
	"Answer with a collection in ascii order -- $a to: $z"
	^ (self numericValue to: other numericValue) collect:
				[:ascii | Character codePoint: ascii]! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:16:02' prior: 16811271!
                         digitValue: x 
	"Answer the Character whose digit value is x. For example,
	 answer $9 for x=9, $0 for x=0, $A for x=10, $Z for x=35."

	| n |
	n := x asInteger.
	^self codePoint: (n < 10 ifTrue: [n + 48] ifFalse: [n + 55])! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:16:43' prior: 50340812!
                            separators
self flag: #unicodeNeedsImprovement.
	"Also see #isSeparator"
	^ #(32 "space"
		13 "cr"
		9 "tab"
		10 "line feed"
		12 "form feed")
		collect: [ :v | Character codePoint: v]

	
! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:15:30' prior: 16811327!
                backspace
	"Answer the Character representing a backspace."

	^self codePoint: 8! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:15:58' prior: 16811347!
                             delete
	^ self codePoint: 127! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:06' prior: 16811352!
                end
	^ self codePoint: 4! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:12' prior: 16811356!
                     enter
	"Answer the Character representing enter."

	^self codePoint: 3! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:15' prior: 16811362!
       escape
	"Answer the ASCII ESC character"

	^self codePoint: 27! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:18' prior: 16811368!
               home
	^ self codePoint: 1! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:22' prior: 16811372!
                    insert
	^ self codePoint: 5! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:26' prior: 16811399!
                  newPage
	"Answer the Character representing a form feed."

	^self codePoint: 12! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:30' prior: 16811405!
                              null
	"Answer the null Character."

	^self codePoint: 0! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:33' prior: 16811410!
                      pageDown
	^ self codePoint: 12! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:36' prior: 16811415!
               pageUp
	^ self codePoint: 11! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:16:49' prior: 16811420!
                 shortUnderscore
	"Answer the Character representing very short (or invisible) underscore.
	Used to optionally mark subscript in code."

	^ Character codePoint: 127! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:20:40' prior: 16811429!
          smalltalkDownArrow
	"
	The use of code 31 for a down arrow is not part of the ASCII or Unicode standards.
	This code is generally not used in text.
	Cuis holds a down arrow glyph at this code. This is for possible future use.

	The actual glyph used is decided by the TrueType font. See #mapAndStoreGlyphsUsing:
		and references to FallbackArrowGlyphs.

	Character smalltalkDownArrow
	"
	^ Character codePoint: 31! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:20:49' prior: 16811446!
                smalltalkLeftArrow
	"
	The use of code 28 for a left arrow is not part of the ASCII or Unicode standards.
	This code is generally not used in text files.

	Cuis holds a left arrow glyph at this code, that is only used to show $_ as a left arrow,
	when used for assignment of a Smalltalk variable.
	Note that it will be replaced by $_ when saving code files or exporting to OS clipboard.
	Browse senders to see how this works.

	The actual glyph used is decided by the TrueType font. See #mapAndStoreGlyphsUsing:
		and references to FallbackArrowGlyphs.

	Character smalltalkLeftArrow
	"
	^ Character codePoint: 28! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:20:56' prior: 16811469!
        smalltalkRightArrow
	"
	The use of code 30 for a right arrow is not part of the ASCII or Unicode standards.
	This code is generally not used in text.
	Cuis holds a right arrow glyph at this code. This is for possible future use.

	The actual glyph used is decided by the TrueType font. See #mapAndStoreGlyphsUsing:
		and references to FallbackArrowGlyphs.

	Character smalltalkRightArrow
	"
	^ Character codePoint: 30! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/8/2024 12:21:08' prior: 16811486!
            smalltalkUpArrow
	"
	The use of code 29 for an up arrow is not part of the ASCII or Unicode standards.
	This code is generally not used in text files.

	Cuis holds an up arrow glyph at this code, that is only used to show $^ as an up arrow,
	when used for return from a Smalltalk method.
	Note that it will be replaced by $^ when saving code files or exporting to OS clipboard.
	Browse senders to see how this works.

	The actual glyph used is decided by the TrueType font. See #mapAndStoreGlyphsUsing:
		and references to FallbackArrowGlyphs.

	Character smalltalkUpArrow
	"
	^ Character codePoint: 29! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:15:43' prior: 50340655!
      basicLookupTables
	| lowercaseMappingTable uppercaseMappingTable unaccentedTable |
	lowercaseMappingTable := Array new: 256.
	uppercaseMappingTable := Array new: 256.
	unaccentedTable := ByteArray new: 256.
	0
		to: 255
		do: [ :idx | | char |
			"Default to an identity mapping with a false truth mapping"
			char := self codePoint: idx.
			lowercaseMappingTable
				at: idx + 1 put: char.
			uppercaseMappingTable
				at: idx + 1 put: char.
			unaccentedTable at: idx + 1 put: idx].
	"Now override as needed"
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :group | | uppercase lowercase |
		group size > 1
			ifTrue: [ | lowercaseChar uppercaseChar |
				uppercase := group first numericValue.
				lowercase := group second numericValue.
				lowercaseChar := self codePoint: lowercase.
				uppercaseChar := self codePoint: uppercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar;
					at: uppercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: uppercaseChar;
					at: uppercase + 1 put: uppercaseChar.
				group size > 2
					ifTrue: [|unaccentedUppercase unaccentedLowercase|
						unaccentedUppercase := group third numericValue.
						unaccentedLowercase := group fourth numericValue.
						unaccentedTable
							at: uppercase+1 put: unaccentedUppercase;
							at: lowercase+1 put: unaccentedLowercase]]
			ifFalse: [ | lowercaseChar |
				lowercase := group first numericValue.
				lowercaseChar := self codePoint: lowercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: lowercaseChar ]].
	^{ lowercaseMappingTable. uppercaseMappingTable. unaccentedTable}.! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:15:48' prior: 50340712!
                     lowercaseMappingTable
	^`Character basicLookupTables at: 1`! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:15:51' prior: 50340717!
     unaccentedTable
	^`Character basicLookupTables at: 3`! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:15:53' prior: 50340722!
           uppercaseMappingTable
	^`Character basicLookupTables at: 2`! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:32' prior: 50340139!
      asLowercase
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character codePoint: value) asLowercase codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:37' prior: 50340148!
                       asUnaccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character codePoint: value) asUnaccented codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:41' prior: 50340157!
                     asUppercase
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (Character codePoint: value) asUppercase codePoint ].
	^self! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:45' prior: 50340166!
                       isAccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character codePoint: value) isAccented ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:48' prior: 50340174!
                              isUnaccented
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character codePoint: value) isUnaccented ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:51' prior: 50340182!
                          isValidInFilenames
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^(Character codePoint: value) isValidInFilenames ].
	^true! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:54' prior: 50340190!
               isVowel
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^ (Character codePoint: value) isVowel ].
	^false! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:17:57' prior: 50340197!
   withDiacriticalMark: anUnicodeCodePoint
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (
			(Character codePoint: value) withDiacriticalMark: anUnicodeCodePoint)
				codePoint ].
	^self! !
!Date methodsFor: 'printing' stamp: 'jmv 1/8/2024 12:18:04' prior: 50340216!
   printOn: aStream format: formatArray 
	"Print a description of the receiver on aStream using the format 
	denoted the argument, formatArray: 
	
		#(item item item sep monthfmt yearfmt twoDigits) 
	
		items: 1=day 2=month 3=year will appear in the order given, 
	
		separated by sep which is eaither an ascii code or character. 
	
		monthFmt: 1=09 2=Sep 3=September 
	
		yearFmt: 1=1996 2=96 
	
		digits: (missing or)1=9 2=09. 
	
	See the examples in printOn: and mmddyy"
	| gregorian twoDigits element monthFormat |
	gregorian := self dayMonthYearDo: [ :d :m :y | {d. m. y} ].
	twoDigits := formatArray size > 6 and: [(formatArray at: 7) > 1].
	1 to: 3 do: 
		[ :i | 
			element := formatArray at: i.
			element = 1
				ifTrue: [twoDigits
						ifTrue: [aStream
								nextPutAll: (gregorian first printString
										padded: #left
										to: 2
										with: $0)]
						ifFalse: [gregorian first printOn: aStream]].
			element = 2
				ifTrue: [monthFormat := formatArray at: 5.
					monthFormat = 1
						ifTrue: [twoDigits
								ifTrue: [aStream
										nextPutAll: (gregorian middle printString
												padded: #left
												to: 2
												with: $0)]
								ifFalse: [gregorian middle printOn: aStream]].
					monthFormat = 2
						ifTrue: [aStream
								nextPutAll: ((Month nameOfMonth: gregorian middle)
										copyFrom: 1
										to: 3)].
					monthFormat = 3
						ifTrue: [aStream
								nextPutAll: (Month nameOfMonth: gregorian middle)]].
			element = 3
				ifTrue: [(formatArray at: 6)
							= 1
						ifTrue: [gregorian last printOn: aStream]
						ifFalse: [aStream
								nextPutAll: ((gregorian last \\ 100) printString
										padded: #left
										to: 2
										with: $0)]].
			i < 3
				ifTrue: [(formatArray at: 4)
							~= 0
						ifTrue: [
							aStream nextPut: ((formatArray at: 4) isNumber
								ifTrue: [ Character codePoint: (formatArray at: 4) ]
								ifFalse: [ (formatArray at: 4) ])
							]]]
! !
!InputSensor methodsFor: 'private' stamp: 'jmv 1/8/2024 12:18:08' prior: 16882358!
                        characterForKeycode: keycode
	"Map the given keycode to a Smalltalk character object. Encoding:
		A keycode is 12 bits:   <4 modifer bits><8 bit ISO character>
		Modifier bits are:       <command><option><control><shift>"

	"NOTE: the command and option keys are specific to the Macintosh and may not have equivalents on other platforms."

	keycode ifNil: [ ^nil ].
	^ Character codePoint: (keycode bitAnd: 16rFF)! !
!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 1/8/2024 12:19:44' prior: 16856124!
        fetchMoreEventsDiscardingMouseEvents: discardMouseEvents
	"Fetch more events from the VM"
	| eventBuffer type |

	"Reset input semaphore so clients can wait for the next events after this one."
	inputSemaphore isSignaled
		ifTrue: [
			hasInputSemaphore := true.
			inputSemaphore initSignals ].

	"DebuggingAid""
	dd := Time localMillisecondClock - lastEventPoll.
	"

	eventBuffer := Array new: 8.
	[
		self primGetNextEvent: eventBuffer.
		"DebuggingAid""
		eventBuffer first = 2 ifTrue: [
			k1 := eventBuffer third.
			u1 := eventBuffer sixth.
			pressType := eventBuffer fourth.
			typeS := 'unknown'.
			pressType = EventSensor eventKeyDown ifTrue: [
				typeS := #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				typeS := #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				typeS := #keystroke].
			dd >100 ifTrue: ['-' print. dd := 0 ].
			{ k1 < 256 ifTrue: [Character codePoint: k1] ifFalse: [ '[]']. UnicodeCodePoint codePoint: k1. k1. k1 hex. '-----'. 
				UnicodeCodePoint codePoint: u1. u1. u1 hex. '----'. pressType. typeS } print.
			].
		"
		type := eventBuffer at: 1.
		type = EventSensor eventTypeNone ]
			whileFalse: [
				self
					processSensorEvent: eventBuffer
					discardingMouseEvents: discardMouseEvents ].

	"Remember the last time that I checked for events."
	lastEventPoll := Time localMillisecondClock.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:18:15' prior: 16813527!
                 asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in char rest did |
	in := self readStream.
	^self species streamContents: [ :out |
		[ in atEnd ] whileFalse: [
			in peek = $<
				ifTrue: [in unCommand] 	"Absorb <...><...>"
				ifFalse: [(char := in next) = $&
					ifTrue: [
						rest := in upTo: $;.
						did := out position.
						rest = 'lt' ifTrue: [out nextPut: $<].
						rest = 'gt' ifTrue: [out nextPut: $>].
						rest = 'amp' ifTrue: [out nextPut: $&].
						rest = 'deg' ifTrue: [out nextPut: $¡].
						rest = 'quot' ifTrue: [out nextPut: $"].
						rest first = $# ifTrue: [ out nextPut: (Character codePoint: rest findPositiveInteger) ].
						did = out position ifTrue: [
							out nextPut: $&; nextPutAll: rest.
							"self error: 'unknown encoded HTML char'."
							"Please add it to this method"]]
					ifFalse: [out nextPut: char]].
			]].! !
!String methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:18:20' prior: 16959643 overrides: 16913349!
                       at: index 
	"Primitive. Answer the Character stored in the field of the receiver
	indexed by the argument. Fail if the index argument is not an Integer or
	is out of bounds. Essential. See Object documentation whatIsAPrimitive."

	<primitive: 63>
	^Character codePoint: (super at: index)! !
!String methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:18:25' prior: 50340281 overrides: 16913367!
                         at: index put: aCharacter 
	"Primitive. Store the Character in the field of the receiver indicated by
	the index. Fail if the index is not an Integer or is out of bounds, or if
	the argument is not a Character. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 64>
	aCharacter isCharacter
		ifTrue: [	

			aCharacter class == UnicodeCodePoint ifTrue: [
				aCharacter codePoint > 255 ifTrue: [self error: 'String only store Latin-1 Characters'].
				^self at: index put: (Character codePoint: aCharacter codePoint) ].

			aCharacter numericValue > 255 ifTrue: [
				self error: 'String only store Latin-1 Characters'].
			index isInteger
				ifTrue: [self errorSubscriptBounds: index]
				ifFalse: [self errorNonIntegerIndex]]
		ifFalse: [self error: 'Strings only store Characters']! !
!String class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:15:04' prior: 16960553!
                           percentEscapingNonAsciiAndThoseIn: aCharacterMap bytes: aByteArray
	"Percent encode any byte not in the ASCII range.
	Also encode any in aCharacterMap.
	Replace them with %XX where XX are the hexadecimal digits.
	See https://en.wikipedia.org/wiki/URL_encoding
	
	String percentEscapingNonAscii: '⊙' bytes
	"

	^String streamContents: [ :strm |
		aByteArray do: [ :byte | | c |
			(byte > 127 or: [
						aCharacterMap isNil or: [
							c := Character codePoint: byte.
							aCharacterMap includes: c ]])
				ifTrue: [
					strm nextPut: $%.
					strm nextPut: (byte // 16) asHexDigit.
					strm nextPut: (byte \\ 16) asHexDigit ]
				ifFalse: [ strm nextPut: c ]]].! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:18:29' prior: 16961073!
      lowercasingTable
	"a table for translating to lower case"
	^`String withAll: ((0 to: 255) collect: [ :c | (Character codePoint: c) asLowercase ])`
! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:18:32' prior: 50340727!
                tokenishTable
	"a table for testing tokenish (for fast numArgs)"
	^`String withAll: (
		((0 to: 255) collect: [ :c | (Character codePoint: c) ])
			collect: 	[ :c | c tokenish ifTrue: [c] ifFalse: [$~]]	)`.! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:18:38' prior: 16961090!
                     uppercasingTable
	"a table for translating to upper case"
	^`String withAll: ((0 to: 255) collect: [ :c | (Character codePoint: c) asUppercase ])`
! !
!Base64MimeConverter class methodsFor: 'additional services' stamp: 'jmv 1/8/2024 12:15:13' prior: 16786605!
                            initializeTables

	FromCharTable := Array new: 256.	"nils"
	ToCharTable := Array new: 64.
	($A asciiValue to: $Z asciiValue) withIndexDo: [ :ascii :ind | 
		FromCharTable at: ascii+1 put: ind-1.
		ToCharTable at: ind put: (Character codePoint: ascii) ].
	($a asciiValue to: $z asciiValue) withIndexDo: [ :ascii :ind | 
		FromCharTable at: ascii+1 put: ind+25.
		ToCharTable at: ind+26 put: (Character codePoint: ascii) ].
	($0 asciiValue to: $9 asciiValue) withIndexDo: [ :ascii :ind | 
		FromCharTable at: ascii+1 put: ind+25+26.
		ToCharTable at: ind+26+26 put: (Character codePoint: ascii) ].
	FromCharTable at: $+ asciiValue + 1 put: 62.
	ToCharTable at: 63 put: $+.
	FromCharTable at: $/ asciiValue + 1 put: 63.
	ToCharTable at: 64 put: $/.
	! !
!RWBinaryOrTextStream methodsFor: 'writing' stamp: 'jmv 1/8/2024 12:18:41' prior: 50340370 overrides: 50340994!
 nextPut: charOrByte

	super nextPut: 
		(charOrByte isCharacter
			ifTrue: [ charOrByte ]
			ifFalse: [ Character codePoint: charOrByte ])! !
!Transcripter methodsFor: 'command line' stamp: 'jmv 1/8/2024 12:18:45' prior: 16988717!
                         request: prompt
	| startPos char contents return |
	return := Character codePoint: InputSensor returnKey.
	self
		newLine;
		show: prompt.
	startPos := position.
	[
		[ Sensor keyboardPressed ] whileFalse.
		(char := Sensor keyboard) = return ] whileFalse: [
			char = Character backspace
				ifTrue: [ readLimit := position := position - 1 max: startPos ]
				ifFalse: [ self nextPut: char ].
			self endEntry ].
	contents := self contents.
	^ contents
		copyFrom: startPos + 1
		to: contents size! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 1/8/2024 12:18:49' prior: 16841591!
                 readCharacter
    "PRIVATE -- Read a Character."

    ^ Character codePoint: (byteStream nextUint32BigEndian: true)! !
!Scanner class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 12:19:02' prior: 16945442 overrides: 16916096!
                   initialize
	"
	Scanner initialize.
	"
	self initTypeTable.
	self initializeDoitCharacter.! !
!Scanner class methodsFor: 'cached class state' stamp: 'jmv 1/8/2024 12:18:55' prior: 16945458!
   initTypeTable
	| newTable |
	newTable := Array new: 127 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"
	newTable atAll: '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.
	1 to: 127 do: [:index |
		(Character codePoint: index) isLetter ifTrue: [
			newTable at: index put: #xLetter ]].
	newTable atAll: ($0 numericValue to: $9 numericValue) put: #xDigit.
	newTable at: self doItCharacterValue put: #doIt.
	newTable at: $" numericValue put: #xDoubleQuote.
	newTable at: $# numericValue put: #xLitQuote.
	newTable at: $$ numericValue put: #xDollar.
	newTable at: $' numericValue put: #xSingleQuote.
	newTable at: $` numericValue put: #xBacktick.
	newTable at: $: numericValue put: #xColon.
	newTable at: $( numericValue put: #leftParenthesis.
	newTable at: $) numericValue put: #rightParenthesis.
	newTable at: $. numericValue put: #period.
	newTable at: $; numericValue put: #semicolon.
	newTable at: $[ numericValue put: #leftBracket.
	newTable at: $] numericValue put: #rightBracket.
	newTable at: ${ numericValue put: #leftBrace.
	newTable at: $} numericValue put: #rightBrace.
	newTable at: $^ numericValue put: #upArrow.
	newTable at: $_ numericValue put: #xUnderscore.
	newTable at: $| numericValue put: #verticalBar.
	newTable at: Character smalltalkLeftArrow numericValue put: #leftArrow.
	newTable at: Character smalltalkUpArrow numericValue put: #upArrow.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !
!TrieNode class methodsFor: 'constants' stamp: 'jmv 1/8/2024 12:19:08' prior: 16989808!
                        characterForLeaf
	"A special character to mean leaf node. Must have lower code than alphabetic chars,
	so in the trie 'car' comes before 'cars'"
	^Character codePoint: 0! !
!FileIOAccessor methodsFor: 'primitives' stamp: 'jmv 1/8/2024 12:19:53' prior: 16861997!
                          primLookupEntryIn: fullPathAsUtf8Bytes index: index
	"Look up the index-th entry of the directory with the given fully-qualified path (i.e., starting from the root of the file hierarchy) and return an array containing:

	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>

	On MacOS and Windows,  the empty string enumerates the mounted volumes/drives.
	
	On Linux, it is equivalent to '.', and lists the contents of DirectoryEntry currentDirectory.

	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad.
	
	Warning: The 'name' field is an instance of String, but in reality it contains the bytes for its UTF-8 representation.
	For instance, if the real name is 'puño' we'll get  'puño', as
	(String withAll: ('puño' AsUtf8Bytes asArray collect: [ :n | Character codePoint: n ]))        =        'puño'
	Senders MUST do appropriate conversion.
	
	Consider calling #primFixedNameLookupEntryIn:index: instead.
	"

 	<primitive: 'primitiveDirectoryLookup' module: 'FilePlugin'>
	^ #badDirectoryPath

! !
!ByteStringReadAdaptor methodsFor: 'reading' stamp: 'jmv 1/8/2024 12:19:12' prior: 16801723 overrides: 16992397!
                            next
	"Stream bytes as Cuis / ISO 8859-15 Characters.
	Disregard the fact that stream contents are most likely UTF-8.
	This is valid only if contents are ASCII, or Cuis / ISO-8859-15 byte Characters."

	stream nextByte ifNotNil: [ :byte |
		^Character codePoint: byte ].
	^nil! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 1/8/2024 12:19:19' prior: 16908827!
                 displayBulletTextLeft: texLeft number: bulletNumber
	"texLeft is relative to the morph currently being drawn"

	| pattern i c j s bullet bulletPos bulletSize prefix |
	pattern := paragraphStyle listBulletPattern.
	bullet := pattern.
	(i := pattern indexOf: $%) > 0
		ifTrue: [ bullet := bulletNumber printString]
		ifFalse: [
			(i := pattern indexOf: $z) > 0
				ifTrue: [ bullet := String with: (Character codePoint: 96 + bulletNumber) ]
				ifFalse: [
					(i := pattern indexOf: $Z) > 0
						ifTrue: [ bullet := String with: (Character codePoint: 64 + bulletNumber) ]]].
	prefix := 0.
	i > 0 ifTrue: [
		c := pattern at: i.
		j := i.
		s := pattern size.
		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j := j + 1 ].
		j := j - 1.
		bulletSize := j-i+1.
		prefix := bulletSize - bullet size max: 0.
		bullet size > bulletSize ifTrue: [
			bullet := bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].
		bullet := (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].
	bulletPos := paragraphStyle firstIndent + texLeft + ((font widthOf: $9) * prefix)@destY.
	canvas
		drawString: bullet
		from: 1
		to: bullet size
		at: bulletPos
		font: font
		color: foregroundColor! !
!TTFontTableDirEntry methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:15:19' prior: 16973688!
                          stringAt: stringOffset length: byteLength multiByte: aBoolean

	| string index stringLength |
	aBoolean ifFalse:[
		stringLength := byteLength.
		string := String new: stringLength.
		index := stringOffset.
		1 to: stringLength do:[:i|
			string at: i put: (Character codePoint: (fontData at: index + i - 1))].
		^string
	] ifTrue:[
		"UTF-16BE ???
		https://docs.microsoft.com/en-us/typography/opentype/spec/name#enc3
		This code appears to assume only lower byte is needed, most likely only ascii is supported here (jmv)"
		stringLength := byteLength // 2.
		string := String new: stringLength.
		index := stringOffset.
		1 to: stringLength do:[:i|
			string at: i put: (Character codePoint: (fontData at: index + 1)).
			index := index + 2].
		^string]! !

Character class removeSelector: #numericValue:!

!methodRemoval: Character class #numericValue: stamp: 'Install-6184-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h14m-jmv.001.cs.st 1/30/2024 19:37:18'!
numericValue: anInteger
	"Answer the Character whose value is anInteger."

	<primitive: 170>
	^self primitiveFailed!

Character class removeSelector: #asciiValue:!

!methodRemoval: Character class #asciiValue: stamp: 'Install-6184-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h14m-jmv.001.cs.st 1/30/2024 19:37:18'!
asciiValue: asciiValue
	"
	Answer the Character for the required asciiValue. Argument is a byte, i.e. in [0..255].
	values above 127, consider it an ISO 8859-15 code.
	
	self assert: (Character asciiValue: 16r41) = $A.
	self assert: (Character asciiValue: 16rA4) = $€.
	"
	^ Character numericValue: asciiValue!

Scanner initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6184-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h14m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6171] on 8 January 2024 at 1:19:40 pm'!
!SmallInteger methodsFor: 'printing' stamp: 'jmv 1/8/2024 12:27:13' prior: 16951711!
                    printStringBase: b nDigits: n
	"Return a string representation of this number in base b with n digits (left padded with 0).
	Should be invoked with: 0 <= self < (b raisedToInteger: n)."
	
	| integer next result |
	result := String new: n.
	integer := self.
	n to: 1 by: -1 do: [:i |
		next := integer // b.
		result at: i put: (Character digitValue: (integer - (next * b))).
		integer := next].
	^result! !
!Character methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:29:22' prior: 16810749!
                      asciiValue
	"Answer the value of the receiver that represents its ANSI encoding.
	This is the same as ISO 8859-15 for the first 128 characters.
	Answer nil if out of range."

	| n |
	n := self codePoint.
	^ n < 128 ifTrue: [ n ].! !
!Character methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:35:36' prior: 16810767!
    digitValue
	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 
	otherwise. This is used to parse literal numbers of radix 2-36.
	$0 numericValue = 48
	$9 numericValue = 57
	$A numericValue = 65
	$Z numericValue = 90 
	$7 digitValue = 7 
	"

	| nv |
	nv := self codePoint.
	(nv between: 48 and: 57)
		ifTrue: [ ^ nv - 48 ].
	(nv between: 65 and: 90)
		ifTrue: [ ^ nv - 55 ].
	^ -1! !
!Character methodsFor: 'comparing' stamp: 'jmv 1/8/2024 12:35:49' prior: 16810863 overrides: 16913626!
        hash
	"Hash is reimplemented because = is implemented."

	^self codePoint hash! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 12:37:08' prior: 16810904!
                             isDigit
	"Answer whether the receiver is a digit."

	^ self codePoint between: 48 and: 57! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 12:37:17' prior: 16810916!
                  isLineSeparator
	"Answer whether the receiver is a line separator character:
	line feed, cr, or form feed."

	^ #(10 13 12) statePointsTo: self codePoint! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 12:37:20' prior: 16810928!
                  isNullCharacter
	"Answer whether the receiver is the NULL character."

	^ self codePoint = 0! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 12:37:25' prior: 16810934!
               isSeparator
	"Answer whether the receiver is one of the separator characters
	space, tab, lf, cr, or form feed."
	"Also see #separators"

	^ #(32 9 10 13 12) statePointsTo: self codePoint! !
!Character methodsFor: 'printing' stamp: 'jmv 1/8/2024 12:37:00' prior: 16811009!
               hex
	self codePoint < 256 ifTrue: [
		^ String
			with: ('0123456789ABCDEF' at: self codePoint//16+1)
			with: ('0123456789ABCDEF' at: self codePoint\\16+1) ].
	^self codePoint printStringBase: 16 length: 6 padded: true! !
!Character methodsFor: 'printing' stamp: 'jmv 1/8/2024 12:37:41' prior: 16811019 overrides: 16914834!
                           printOn: aStream 
	aStream nextPut: $$.
	aStream nextPut: self.
	self codePoint <= 32 ifTrue: [
		aStream nextPut: $".
		aStream nextPutAll: self hex.
		aStream nextPut: $" ].! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:28:18' prior: 16811037!
                         asLowercase
self flag: #unicodeNeedsImprovement.
	self codePoint > 255 ifTrue: [ ^self ].
	^ Character lowercaseMappingTable at: self codePoint + 1.! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:28:52' prior: 50341215!
                    asUnaccented
	"
	$A asUnaccented
	$Á asUnaccented
	(0 to: 255) collect: [ :i | (Character codePoint: i) asUnaccented ]
	(0 to: 255) collect: [ :i | (Character codePoint: i) asUnaccented  asLowercase]
	"
self flag: #unicodeNeedsImprovement.
	self codePoint > 255 ifTrue: [ ^self ].
	^ Character
		codePoint: (self class unaccentedTable at: self codePoint + 1)! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:29:10' prior: 16811071!
 asUppercase
	"If the receiver is lowercase, answer its matching uppercase Character."
self flag: #unicodeNeedsImprovement.
	self codePoint > 255 ifTrue: [ ^self ].
	^ Character uppercaseMappingTable at: self codePoint + 1.! !
!Character methodsFor: 'converting' stamp: 'jmv 1/8/2024 12:38:10' prior: 50341227!
          to: other
	"Answer with a collection in ascii order -- $a to: $z"
	^ (self codePoint to: other codePoint) collect: [ :cp |
		Character codePoint: cp ]! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 12:58:23' prior: 50340784!
  uppercaseLowercaseAndUnaccentedLetters
	"Answer all uppercase and lowercase letters in standard collation order.
	For accented characters, include the non-accented ones.
	Note that $ß is 'LATIN SMALL LETTER SHARP S' and ISO 8859-15 doesn't have an uppercase version.
	Note: for $ÿ, 'Latin Small Letter Y with diaeresis' the uppercase version is not Latin 1"
self flag: #unicodeNeedsImprovement.
	^#(
		'Aa' 'ÀàAa' 'ÁáAa' 'ÂâAa' 'ÃãAa' 'ÄäAa' 'ÅåAa'
		'Bb' 'Cc' 'Çç' 'Dd'
			'Ee' 'ÈèEe' 'ÉéEe' 'ÊêEe' 'ËëEe'
		'Ff' 'Gg' 'Hh'
			'Ii' 'ÌìIi' 'ÍíIi' 'ÎîIi' 'ÏïIi'
		'Jj' 'Kk' 'Ll' 'Mm' 'Nn' 'Ññ'
			'Oo' 'ÒòOo' 'ÓóOo' 'ÔôOo' 'ÕõOo' 'ÖöOo'
		'Pp' 'Qq' 'Rr'
			'Ss'
		'Tt'
			'Uu' 'ÙùUu' 'ÚúUu' 'ÛûUu' 'ÜüUu'
		'Vv' 'Ww' 'Xx'
			'Yy' 'ÝýYy' 'ÿ'
			'Zz'
		'Ææ' 'Ðð' 'Øø' 'Þþ' 'ß'
	).! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:30:23' prior: 50341407!
                        basicLookupTables
	| lowercaseMappingTable uppercaseMappingTable unaccentedTable |
	lowercaseMappingTable := Array new: 256.
	uppercaseMappingTable := Array new: 256.
	unaccentedTable := ByteArray new: 256.
	0
		to: 255
		do: [ :idx | | char |
			"Default to an identity mapping with a false truth mapping"
			char := self codePoint: idx.
			lowercaseMappingTable
				at: idx + 1 put: char.
			uppercaseMappingTable
				at: idx + 1 put: char.
			unaccentedTable at: idx + 1 put: idx].
	"Now override as needed"
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :group | | uppercase lowercase |
		group size > 1
			ifTrue: [ | lowercaseChar uppercaseChar |
				uppercase := group first codePoint.
				lowercase := group second codePoint.
				lowercaseChar := self codePoint: lowercase.
				uppercaseChar := self codePoint: uppercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar;
					at: uppercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: uppercaseChar;
					at: uppercase + 1 put: uppercaseChar.
				group size > 2
					ifTrue: [|unaccentedUppercase unaccentedLowercase|
						unaccentedUppercase := group third codePoint.
						unaccentedLowercase := group fourth codePoint.
						unaccentedTable
							at: uppercase+1 put: unaccentedUppercase;
							at: lowercase+1 put: unaccentedLowercase]]
			ifFalse: [ | lowercaseChar |
				lowercase := group first codePoint.
				lowercaseChar := self codePoint: lowercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: lowercaseChar ]].
	^{ lowercaseMappingTable. uppercaseMappingTable. unaccentedTable}.! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:58:45' prior: 50341464!
    lowercaseMappingTable
	^`Character basicLookupTables at: 1`! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:58:48' prior: 50341469!
     unaccentedTable
	^`Character basicLookupTables at: 3`! !
!Character class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:58:51' prior: 50341474!
           uppercaseMappingTable
	^`Character basicLookupTables at: 2`! !
!InputSensor methodsFor: 'keyboard' stamp: 'jmv 1/8/2024 12:38:20' prior: 16882037!
             kbdTest
	"
	Sensor kbdTest
	"
	"This test routine will print the unmodified character, its keycode,
	and the OR of all its modifier bits, until the character x is typed

Also useful:
	Sensor test
	"
	| char |
	char := nil.
	[ char = $x ] whileFalse: [
		[ self keyboardPressed ] whileFalse.
		char := self keyboard.
		Display fill: `5@5 extent: 400@50` fillColor: `Color white`.
		(String streamContents: [ :s |
			s
				nextPut: $-;
				nextPut: char;
				nextPut: $-;
				space;
				print: char codePoint;
				space.
			self isMouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].
			self isMouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].
			self isMouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].
			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].
			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].
			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].
			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ].
			Time now printOn: s
			])
		displayAt: 10 @ 10 ].! !
!EventSensor methodsFor: 'initialization' stamp: 'jmv 1/8/2024 12:38:44' prior: 16856425 overrides: 16932297!
  initialize
	"Run the I/O process"
	mouseButtons := 0.
	mousePosition := `0@0`.
	self setInterruptKey: (interruptKey ifNil: [$. codePoint bitOr: 16r0800 ]). 	"cmd-."
	self flushAllButDandDEvents.
	inputSemaphore := Semaphore new.
	hasInputSemaphore := false.

	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).
	self installInterruptWatcher.
	self installEventTickler.
	self flushAllButDandDEvents.

	"Attempt to discover whether the input semaphore is actually being signaled."
	hasInputSemaphore := false.
	inputSemaphore initSignals! !
!String methodsFor: 'accessing' stamp: 'jmv 1/8/2024 12:39:05' prior: 50341722 overrides: 16913367!
    at: index put: aCharacter 
	"Primitive. Store the Character in the field of the receiver indicated by
	the index. Fail if the index is not an Integer or is out of bounds, or if
	the argument is not a Character. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 64>
	aCharacter isCharacter
		ifTrue: [	

			aCharacter class == UnicodeCodePoint ifTrue: [
				aCharacter codePoint > 255 ifTrue: [self error: 'String only store Latin-1 Characters'].
				^self at: index put: (Character codePoint: aCharacter codePoint) ].

			aCharacter codePoint > 255 ifTrue: [
				self error: 'String only store Latin-1 Characters'].
			index isInteger
				ifTrue: [self errorSubscriptBounds: index]
				ifFalse: [self errorNonIntegerIndex]]
		ifFalse: [self error: 'Strings only store Characters']! !
!String methodsFor: 'comparing' stamp: 'jmv 1/8/2024 13:02:09' prior: 16959888!
            crc16
	"Compute a 16 bit cyclic redundancy check."

	| crc |
	crc := 0.
	self do: [:c |
		crc := (crc bitShift: -8) bitXor: (
		 #(	16r0000	16rC0C1	16rC181	16r0140	16rC301	16r03C0	16r0280	16rC241
			16rC601	16r06C0	16r0780	16rC741	16r0500	16rC5C1	16rC481	16r0440
			16rCC01	16r0CC0	16r0D80	16rCD41	16r0F00	16rCFC1	16rCE81	16r0E40
			16r0A00	16rCAC1	16rCB81	16r0B40	16rC901	16r09C0	16r0880	16rC841
			16rD801	16r18C0	16r1980	16rD941	16r1B00	16rDBC1	16rDA81	16r1A40
			16r1E00	16rDEC1	16rDF81	16r1F40	16rDD01	16r1DC0	16r1C80	16rDC41
			16r1400	16rD4C1	16rD581	16r1540	16rD701	16r17C0	16r1680	16rD641
			16rD201	16r12C0	16r1380	16rD341	16r1100	16rD1C1	16rD081	16r1040
			16rF001	16r30C0	16r3180	16rF141	16r3300	16rF3C1	16rF281	16r3240
			16r3600	16rF6C1	16rF781	16r3740	16rF501	16r35C0	16r3480	16rF441
			16r3C00	16rFCC1	16rFD81	16r3D40	16rFF01	16r3FC0	16r3E80	16rFE41
			16rFA01	16r3AC0	16r3B80	16rFB41	16r3900	16rF9C1	16rF881	16r3840
			16r2800	16rE8C1	16rE981	16r2940	16rEB01	16r2BC0	16r2A80	16rEA41
			16rEE01	16r2EC0	16r2F80	16rEF41	16r2D00	16rEDC1	16rEC81	16r2C40
			16rE401	16r24C0	16r2580	16rE541	16r2700	16rE7C1	16rE681	16r2640
			16r2200	16rE2C1	16rE381	16r2340	16rE101	16r21C0	16r2080	16rE041
			16rA001	16r60C0	16r6180	16rA141	16r6300	16rA3C1	16rA281	16r6240
			16r6600	16rA6C1	16rA781	16r6740	16rA501	16r65C0	16r6480	16rA441
			16r6C00	16rACC1	16rAD81	16r6D40	16rAF01	16r6FC0	16r6E80	16rAE41
			16rAA01	16r6AC0	16r6B80	16rAB41	16r6900	16rA9C1	16rA881	16r6840
			16r7800	16rB8C1	16rB981	16r7940	16rBB01	16r7BC0	16r7A80	16rBA41
			16rBE01	16r7EC0	16r7F80	16rBF41	16r7D00	16rBDC1	16rBC81	16r7C40
			16rB401	16r74C0	16r7580	16rB541	16r7700	16rB7C1	16rB681	16r7640
			16r7200	16rB2C1	16rB381	16r7340	16rB101	16r71C0	16r7080	16rB041
			16r5000	16r90C1	16r9181	16r5140	16r9301	16r53C0	16r5280	16r9241
			16r9601	16r56C0	16r5780	16r9741	16r5500	16r95C1	16r9481	16r5440
			16r9C01	16r5CC0	16r5D80	16r9D41	16r5F00	16r9FC1	16r9E81	16r5E40
			16r5A00	16r9AC1	16r9B81	16r5B40	16r9901	16r59C0	16r5880	16r9841
			16r8801	16r48C0	16r4980	16r8941	16r4B00	16r8BC1	16r8A81	16r4A40
			16r4E00	16r8EC1	16r8F81	16r4F40	16r8D01	16r4DC0	16r4C80	16r8C41
			16r4400	16r84C1	16r8581	16r4540	16r8701	16r47C0	16r4680	16r8641
			16r8201	16r42C0	16r4380	16r8341	16r4100	16r81C1	16r8081	16r4040)
			 at: ((crc bitXor: c codePoint) bitAnd: 16rFF) + 1) ].
	^crc! !
!String class methodsFor: 'character collation' stamp: 'jmv 1/8/2024 13:04:20' prior: 16960643!
                           does: aCharacter caseInsensitiveCollateBefore: otherCharacter
	"
	String does: $a caseInsensitiveCollateBefore: $b
	String does: $a caseInsensitiveCollateBefore: $B
	String does: $A caseInsensitiveCollateBefore: $b
	"
	"Only for Latin-1"
	self flag: #unicodeNeedsImprovement.
	^ (self caseInsensitiveOrder at: aCharacter codePoint + 1) <
		(self caseInsensitiveOrder at: otherCharacter codePoint + 1)! !
!String class methodsFor: 'character collation' stamp: 'jmv 1/8/2024 13:04:06' prior: 16960657!
            does: aCharacter collateAfter: otherCharacter
	"Only for Latin-1"
	self flag: #unicodeNeedsImprovement.
	^ (self caseSensitiveOrder at: aCharacter codePoint + 1) >
		(self caseSensitiveOrder at: otherCharacter codePoint + 1)! !
!String class methodsFor: 'character collation' stamp: 'jmv 1/8/2024 13:03:55' prior: 16960666!
                            does: aCharacter collateBefore: otherCharacter
	"Only for Latin-1"
	self flag: #unicodeNeedsImprovement.
	^ (self caseSensitiveOrder at: aCharacter codePoint + 1) <
		(self caseSensitiveOrder at: otherCharacter codePoint + 1)! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:39:19' prior: 16960962!
  basicCaseInsensitiveOrder
	"Case insensitive compare sorts null, space, digits, letters, all the rest..."
	| newOrder order |
	newOrder := Array new: 256.
	order := -1.
	newOrder at: 0+1 put:  (order := order+1).
	32 to: 64 do: [ :c |
		newOrder at: c + 1 put: (order := order+1)].
	#(92 94 124 126 183 215 247) do: [ :c | "\^|~·÷×"
		newOrder at: c + 1 put: (order := order+1)].
	16r90 to: 16r9F do: [:c| "special math operators"
		newOrder at: c + 1 put: (order := order+1)].
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :upperAndLowercase |
		order := order+1.
		newOrder at: upperAndLowercase first codePoint + 1 put: order.
		upperAndLowercase size > 1 ifTrue: [
			newOrder at: upperAndLowercase second codePoint + 1 put: order ]].
	1 to: newOrder size do: [ :i |
		(newOrder at: i) ifNil: [
			newOrder at: i put: (order := order+1)]].
	^newOrder asByteArray.! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:59:55' prior: 16960993!
                   basicCaseSensitiveOrder
	"Case sensitive compare sorts null, space, digits, letters, all the rest..."
	| newOrder order lowercase |
	newOrder := Array new: 256.
	order := -1.
	newOrder at: 0+1 put:  (order := order+1).
	32 to: 64 do: [ :c |
		newOrder at: c + 1 put: (order := order+1)].
	#(92 94 124 126 183 215 247) do: [ :c | "\^|~·÷×"
		newOrder at: c + 1 put: (order := order+1)].
	16r90 to: 16r9F do: [:c| "special math operators"
		newOrder at: c + 1 put: (order := order+1)].
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :upperAndLowercase |
		upperAndLowercase size > 1 ifTrue: [
			newOrder at: upperAndLowercase first codePoint + 1 put: (order := order+1) ]].
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :upperAndLowercase |
		lowercase := upperAndLowercase size = 1
			ifTrue: [ upperAndLowercase first ]
			ifFalse: [ upperAndLowercase second ].
		newOrder at: lowercase codePoint + 1 put: (order := order+1) ].
	1 to: newOrder size do: [ :i |
		(newOrder at: i) ifNil: [
			newOrder at: i put: (order := order+1)]].
	order = 255 ifFalse: [self error: 'order problem'].
	^newOrder asByteArray.! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 12:59:01' prior: 16961043!
                       caseInsensitiveOrder
	^`String basicCaseInsensitiveOrder`! !
!String class methodsFor: 'static state' stamp: 'jmv 1/8/2024 13:00:08' prior: 16961048!
          caseSensitiveOrder
	^`String basicCaseSensitiveOrder`! !
!UnicodeString methodsFor: 'paragraph support' stamp: 'jmv 1/8/2024 13:05:35' prior: 16994021!
        encompassLine: aCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte left nullPosition right |
	argumentLeftByte := self byteIndexAt: aCodePointInterval first.
	argumentRightByte := self byteIndexAt: aCodePointInterval last.

	"Find byte position and code point position following last newLine before us."
	leftByte := (bytes lastIndexOf: `Character newLineCharacter codePoint` startingAt: argumentLeftByte - 1 ifAbsent: [0]) + 1.
	left := self codePointIndexAt: leftByte.

	"Find byte position and code point position for next newLine. Don't include it."
	right := count.
	rightCrByte := bytes indexOf: `Character newLineCharacter codePoint` startingAt: (argumentRightByte max: argumentLeftByte).
	rightCrByte = 0 ifFalse: [
		right := (self codePointIndexAt: rightCrByte)-1].

	"But stop before if any nulls. Don't include them!!"
	nullPosition := bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte).
	nullPosition = 0 ifFalse: [
		right := right min: ((self codePointIndexAt: nullPosition)-1) ].

	^left to: right! !
!UnicodeString methodsFor: 'paragraph support' stamp: 'jmv 1/8/2024 13:05:41' prior: 16994066!
            encompassParagraph: aCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte left nullPosition right |
	argumentLeftByte := self byteIndexAt: aCodePointInterval first.
	argumentRightByte := self byteIndexAt: aCodePointInterval last.

	"Find byte position and code point position following last newLine before us."
	leftByte := (bytes lastIndexOf: `Character newLineCharacter codePoint` startingAt: argumentLeftByte - 1 ifAbsent: [0]) + 1.
	left := self codePointIndexAt: leftByte.

	"Find byte position and code point position for next newLine. Include it."
	right := count.
	rightCrByte := bytes indexOf: `Character newLineCharacter codePoint` startingAt: (argumentRightByte max: argumentLeftByte).
	rightCrByte = 0 ifFalse: [
		right := self codePointIndexAt: rightCrByte].

	"But stop before if any nulls. Don't include them!!"
	nullPosition := bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte).
	nullPosition = 0 ifFalse: [
		right := right min: ((self codePointIndexAt: nullPosition)-1) ].

	^left to: right! !
!RWBinaryOrTextStream methodsFor: 'reading' stamp: 'jmv 1/8/2024 13:14:56' prior: 16934757 overrides: 16935157!
                          next

	| byte |
	^ isBinary 
			ifTrue: [byte := super next.
				 byte ifNil: [nil] ifNotNil: [byte codePoint]]
			ifFalse: [super next].
! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 1/8/2024 13:06:28' prior: 16991729 overrides: 17009239!
                           padToEndIfCantTruncate
	"Only makes sense for file streams with existing content.
	On file systems that don't support truncating this is needed.
	If truncating is supported, try that first"

	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."

	| pad |
	self atEnd ifTrue: [^ self].
	self truncate.
	self atEnd ifTrue: [^ self].
	pad := Character space codePoint.
	self nextPutAll: (ByteArray new: ((self size - self position) min: 20000) 
							withAll: pad)! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 1/8/2024 13:06:36' prior: 16841938!
                writeCharacter: aCharacter
	"PRIVATE -- Write a Character."

	byteStream nextUint32Put: aCharacter codePoint bigEndian: true! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 1/8/2024 13:07:26' prior: 16842001!
       writeStringOld: aString
	"PRIVATE -- Write the contents of a String."

	| length |
	aString size < 16384 
		ifTrue: [
			(length := aString size) < 192
				ifTrue: [byteStream nextPut: length]
				ifFalse: 
					[byteStream nextPut: (length // 256 + 192).
					byteStream nextPut: (length \\ 256)].
			aString do: [:char | byteStream nextPut: (char codePoint min: 255)]]
		ifFalse: [self writeByteArray: aString].	"takes more space"! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 1/8/2024 13:08:38' prior: 16945220!
               xIllegal
	"An illegal character was encountered"
	self notify: 'Illegal character (char code ' , hereChar printString, ' ', hereChar hex , ')' at: mark! !
!Scanner class methodsFor: 'cached class state' stamp: 'jmv 1/8/2024 13:08:03' prior: 50341870!
     initTypeTable
	| newTable |
	newTable := Array new: 127 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"
	newTable atAll: '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.
	1 to: 127 do: [:index |
		(Character codePoint: index) isLetter ifTrue: [
			newTable at: index put: #xLetter ]].
	newTable atAll: ($0 codePoint to: $9 codePoint) put: #xDigit.
	newTable at: self doItCharacterValue put: #doIt.
	newTable at: $" codePoint put: #xDoubleQuote.
	newTable at: $# codePoint put: #xLitQuote.
	newTable at: $$ codePoint put: #xDollar.
	newTable at: $' codePoint put: #xSingleQuote.
	newTable at: $` codePoint put: #xBacktick.
	newTable at: $: codePoint put: #xColon.
	newTable at: $( codePoint put: #leftParenthesis.
	newTable at: $) codePoint put: #rightParenthesis.
	newTable at: $. codePoint put: #period.
	newTable at: $; codePoint put: #semicolon.
	newTable at: $[ codePoint put: #leftBracket.
	newTable at: $] codePoint put: #rightBracket.
	newTable at: ${ codePoint put: #leftBrace.
	newTable at: $} codePoint put: #rightBrace.
	newTable at: $^ codePoint put: #upArrow.
	newTable at: $_ codePoint put: #xUnderscore.
	newTable at: $| codePoint put: #verticalBar.
	newTable at: Character smalltalkLeftArrow codePoint put: #leftArrow.
	newTable at: Character smalltalkUpArrow codePoint put: #upArrow.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 13:09:38' prior: 16852923!
              basicInitialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c | c initializeShortcuts; initializeCmdShortcuts ]! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 13:09:43' prior: 16852949 overrides: 16916096!
             initialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c | c basicInitialize ]! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 13:09:31' prior: 16852955!
  initializeCmdShortcuts
	"Initialize the (unshifted) command-key (or alt-key if not on Mac) shortcut table.
	If you want to add a new shortcut for an specific editor, for example SmalltalkEditor, you should
	define the message #smalltalkEditorCmdShortcutsSpec in a class of your category and it will
	be dynamically send"

	"NOTE: if you don't know what your keyboard generates, use Sensor test"

	"
	Editor initialize
	"

	cmdShortcuts := Array new: 256 withAll: #noop:.

	self putIntoCmdShortcuts: self allCmdShortcutsSpec
! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 13:09:15' prior: 16853014!
               putIntoCmdShortcuts: shortcutsSpec

	shortcutsSpec do: [ :ary | | i previous |
		i := ary first codePoint + 1.
		previous := cmdShortcuts at: i.
		previous = #noop:
			ifTrue: [
				cmdShortcuts at: i put: ary second ]
			ifFalse: [ 
				('Editor shortcut: ', ary first printString, ' already taken for: ', previous, 
				'. Override request for: ', ary second, '  ignored') print ]].! !
!CharacterScanner class methodsFor: 'class initialization' stamp: 'jmv 1/8/2024 13:10:22' prior: 16812649 overrides: 16916096!
                             initialize
	"
	CharacterScanner initialize
	"
	| stopConditions |
	stopConditions := Array new: 258.
	stopConditions atAllPut: nil.
	stopConditions at: Character space codePoint + 1 put: nil.
	stopConditions at: Character tab codePoint + 1 put: #tab.

	"This line makes lf be shown as a newLine"
	stopConditions at: Character lf codePoint + 1 put: #doNewLine.

	"This line makes cr be shown as a newLine"
	stopConditions at: Character cr codePoint + 1 put: #doNewLine.

	stopConditions at: CharacterScanner endOfRunCode put: #endOfRun.
	stopConditions at: CharacterScanner crossedXCode put: #crossedX.
	DefaultStopConditions := stopConditions.

	StopConditionsWithSpace := DefaultStopConditions copy.
	StopConditionsWithSpace at: Character space codePoint + 1 put: #space.

	StopConditionsWithPaddedSpace := DefaultStopConditions copy.
	StopConditionsWithPaddedSpace at: Character space codePoint + 1 put: #paddedSpace.
	
	! !

RemoteString removeSelector: #checkSum:!

!methodRemoval: RemoteString #checkSum: stamp: 'Install-6185-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h24m-jmv.003.cs.st 1/30/2024 19:37:18'!
checkSum: aString
	"Construct a checksum of the string.  A three byte number represented as Base64 characters."
	| sum shift bytes |
	sum := aString size.
	shift := 0.
	aString do: [:char |
		(shift := shift + 7) > 16 ifTrue: [shift := shift - 17].
			"shift by 7 to keep a change of adjacent chars from xoring to same value"
		sum := sum bitXor: (char numericValue bitShift: shift)
	].
	bytes := ByteArray new: 3.
	sum := sum + 16r10000000000.
	1 to: 3 do: [:ind | bytes at: ind put: (sum digitAt: ind)].
	^bytes base64Encoded!

String removeSelector: #unescapePercents!

!methodRemoval: String #unescapePercents stamp: 'Install-6185-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h24m-jmv.003.cs.st 1/30/2024 19:37:18'!
unescapePercents
	"change each %XY substring to the character with ASCII value XY in hex.
	This is the opposite of #percentEscapingNonAscii: and #percentEscapingNonAsciiAndThoseIn:bytes:
	(String percentEscapingNonAscii: '⊙' bytes) unescapePercents
	'%E2%8A%99' unescapePercents
	"

	| myBytes answerClass answerBytes c decodedByte pos oldPos specialCharsByteSet |
	myBytes := self asByteArray.
	specialCharsByteSet := `ByteArray new: 256 :: at: $+ asciiValue + 1 put: 1; at: $% asciiValue + 1 put: 1; yourself`.
	answerClass := String.
	answerBytes := ByteArray streamContents: [ :byteStream |
		oldPos := 1.

		[pos := myBytes indexOfAnyIn: specialCharsByteSet startingAt: oldPos ifAbsent: [ 0 ]. pos > 0 ]
		whileTrue: [
			byteStream nextPutAll: (myBytes copyFrom: oldPos to: pos - 1).
			c := self at: pos.
			c = $+ ifTrue: [byteStream nextPut: `$  asciiValue` ] ifFalse: [
				(c = $% and: [pos + 2 <= self size]) ifTrue: [
					decodedByte := (self at: pos+1) asUppercase digitValue * 16 +
						(self at: pos+2) asUppercase digitValue.
					pos := pos + 2.
					decodedByte > 255 ifTrue: [^self].	"not really an escaped string"
					decodedByte > 127 ifTrue: [ answerClass := UnicodeString ].
					byteStream nextPut: decodedByte ]
				ifFalse: [byteStream nextPut: c numericValue ]].
			oldPos := pos+1].
		byteStream nextPutAll: (myBytes copyFrom: oldPos to: self size).
	].
	^ answerClass fromUtf8Bytes: answerBytes!

UnicodeCodePoint removeSelector: #numericValue!

!methodRemoval: UnicodeCodePoint #numericValue stamp: 'Install-6185-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h24m-jmv.003.cs.st 1/30/2024 19:37:18'!
numericValue
self flag: #unicodeNeedsImprovement.
"To be removed. make it the Latin-1 codePoint for the time being.
This doesn't make much sense."
	value < 256 ifTrue: [ ^value ].
	^255!

Character removeSelector: #numericValue!

!methodRemoval: Character #numericValue stamp: 'Install-6185-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h24m-jmv.003.cs.st 1/30/2024 19:37:18'!
numericValue
	"Answer the value of the receiver that represents its ISO 8859-15 (Latin-9) encoding."

	<primitive: 171>
	^self primitiveFailed!

Editor initialize!

CharacterScanner initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6185-Character-EnablingUnicodeRange-JuanVuletich-2024Jan08-12h24m-jmv.003.cs.st----!

'From Cuis6.3 [latest update: #6169] on 8 January 2024 at 4:38:38 pm'!
!ReadWriteStream methodsFor: 'accessing' stamp: 'jmv 1/8/2024 16:36:44' overrides: 17008854!
                          next: n into: aCollection startingAt: startIndex
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."
	| max |
	max := (readLimit - position) min: n.
	aCollection 
		replaceFrom: startIndex 
		to: startIndex+max-1
		with: collection
		startingAt: position+1.
	position := position + max.
	max = n
		ifTrue:[^aCollection]
		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'jmv 1/8/2024 16:38:06' prior: 16842319!
                      streamedRepresentationOf: anObject

	| file |
	file := (ReadWriteStream on: (ByteArray new: 5000)).
	(self on: file) nextPut: anObject.
	^file contents! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'jmv 1/8/2024 16:38:09' prior: 16842345 overrides: 16915887!
             unStream: aByteArray

	^(self on: ((ReadWriteStream with: aByteArray) reset)) next! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 1/8/2024 15:29:31' prior: 16955897 overrides: 16841449!
                             nextPut: anObject
	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.
	You can see an analysis of which objects are written out by doing: 
	(SmartRefStream statsOfSubObjects: anObject)
	(SmartRefStream tallyOfSubObjects: anObject)
	(SmartRefStream subObjects: anObject ofClass: aClass)"

| info |
topCall
	ifNil: [
		topCall := anObject.
		'Please wait while objects are counted' 
			displayProgressAt: Sensor mousePoint
			from: 0 to: 10
			during: [ :barBlock | info := self instVarInfo: anObject].
		byteStream binary.
		'Writing an object file' displayProgressAt: Sensor mousePoint
			from: 0 to: objCount*4	"estimate"
			during: [ :barBlock |
				objCount := 0.
				progressBar := barBlock.
				self setStream: byteStream reading: false.
					"set basePos, but keep any class renames"
				super nextPut: ReferenceStream versionCode.
				super nextPut: info.
				super nextPut: anObject.		"<- the real writing"
				].
					"Note: the terminator, $!!, is not doubled inside object data"
		"references is an IDict of every object that got written"
		byteStream nextPut: $!! codePoint; nextPut: 10; nextPut: 10.
		byteStream padToEndIfCantTruncate.
		topCall := progressBar := nil]	"reset it"
	ifNotNil: [
		super nextPut: anObject.
		progressBar ifNotNil: [progressBar value: (objCount := objCount + 1)]].
! !

Smalltalk removeClassNamed: #RWBinaryOrTextStream!

!classRemoval: #RWBinaryOrTextStream stamp: 'Install-6186-RWBinaryOrTextStream-remove-JuanVuletich-2024Jan08-15h25m-jmv.004.cs.st 1/30/2024 19:37:18'!
ReadWriteStream subclass: #RWBinaryOrTextStream
	instanceVariableNames: 'isBinary'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Streams'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6186-RWBinaryOrTextStream-remove-JuanVuletich-2024Jan08-15h25m-jmv.004.cs.st----!

'From Cuis6.3 [latest update: #6179] on 8 January 2024 at 5:03:37 pm'!
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 16:55:13' prior: 16810910!
       isLetter
	"Answer whether the receiver is a letter."
	"
	(Character codePoint: 16r22C7) isLetter
	(Character codePoint: 16r042F) isLetter
	(Character codePoint: 16r0431) isLetter
	"
	^self isLowercase or: [ self isUppercase ]! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 16:56:03' prior: 50342143!
          isLineSeparator
	"Answer whether the receiver is a line separator character:
	line feed, cr, or form feed."

	^ #(10 13 12 16r0085 16r2028 16r2029) statePointsTo: self codePoint! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 16:58:26' prior: 16810956!
                          isValidInBinarySelectors
	"Can be part of a binary selector?
		$< isValidInBinarySelectors
		$| isValidInBinarySelectors
		$^ isValidInBinarySelectors
		$: isValidInBinarySelectors
	(Character codePoint: 16r22C7) isValidInBinarySelectors
	(Character codePoint: 16r042F) isValidInBinarySelectors
	(Character codePoint: 16r0431) isValidInBinarySelectors
	(Character codePoint: 16r20D7) isValidInBinarySelectors
	"
	self isNullCharacter ifTrue: [ ^false ].
	^#(verticalBar upArrow xColon xBinary xDiacritical) statePointsTo: (Scanner typeTableAt: self).! !
!Character methodsFor: 'testing' stamp: 'jmv 1/8/2024 17:01:44' prior: 16810969!
     isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	self isNullCharacter ifTrue: [ ^false ].
	self = $′ ifTrue: [ ^true ]. 		"Also see #xLetter"
	^#(xLetter xDigit xUnderscore xDiacritical) statePointsTo: (Scanner typeTableAt: self).! !
!Character methodsFor: 'fileman-testing' stamp: 'jmv 1/8/2024 16:54:29' prior: 16811121!
    isDriveLetter
	^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' includes: self! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6187-Character-includeCodePointBehavior-JuanVuletich-2024Jan08-16h54m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6179] on 8 January 2024 at 5:22:17 pm'!
!UnicodeCodePoint methodsFor: 'comparing' stamp: 'jmv 1/8/2024 17:18:05' prior: 50340126!
                    < aCharacter 
	"Compare with the standard case sensitive collation order.
	This stuff should be in Character and not in String..."

	self == aCharacter ifTrue: [ ^false ].

	(self codePoint < 256 and: [ aCharacter codePoint < 256 ]) ifTrue: [
		^String does: self collateBefore: aCharacter ].
	
	^self codePoint < aCharacter codePoint.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6188-Tweak-JuanVuletich-2024Jan08-17h18m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6181] on 9 January 2024 at 10:20:48 am'!

Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CompositionMapping DecompositionMapping UppercaseLettersTable LowercaseLettersTable CanonicalCombiningClasses NamedCharactersMap SymbolsLikeTable DiacriticalMarksTable '
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Character category: #'Kernel-Text' stamp: 'Install-6189-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h01m-jmv.001.cs.st 1/30/2024 19:37:18'!
Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CanonicalCombiningClasses CompositionMapping DecompositionMapping DiacriticalMarksTable LowercaseLettersTable NamedCharactersMap SymbolsLikeTable UppercaseLettersTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!
!Character class methodsFor: 'class initialization' stamp: 'jmv 4/11/2023 12:34:44' overrides: 16916096!
                        initialize
	"https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt
	http://www.unicode.org/L2/L1999/UnicodeData.html
	Character initialize
	"

	| fields codePoint codePointName generalCategory canonicalCombiningClass characterDecompositionMapping decomposition composition |
	UppercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	LowercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	SymbolsLikeTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	DiacriticalMarksTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	CanonicalCombiningClasses := Dictionary new.
	DecompositionMapping := Dictionary new.
	CompositionMapping := Dictionary new.
	(DirectoryEntry smalltalkImageDirectory // 'UnicodeData.txt') readStreamDo: [ :strm |
		[strm atEnd] whileFalse: [
			fields := strm nextLine substringsSeparatedBy: $;.
			(#(4 5 6) includes: fields first size) ifFalse: [ fields first print. self error: 'Bad UnicodeData.txt file' ].
			codePoint := ('16r', fields first) asNumber.
			codePointName := fields at: 2.
			generalCategory := fields at: 3.
			codePoint <= 16r1FFFF ifTrue: [
				({ 'Lu'. 'Lt' } includes: generalCategory) ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Ll'. 'Lo' } includes: generalCategory) ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Pc'. 'Po'. 'Sm'. 'Sc'. 'Sk'. 'So' } includes: generalCategory) ifTrue: [ SymbolsLikeTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Mn'. 'Mc'. 'Me' } includes: generalCategory) ifTrue: [ DiacriticalMarksTable bitBooleanAt: codePoint+1 put: true ]].
			canonicalCombiningClass := (fields at: 4) asNumber.
			canonicalCombiningClass = 0 ifFalse: [
				CanonicalCombiningClasses at: codePoint put: canonicalCombiningClass ].
			characterDecompositionMapping := fields at: 6.
			(characterDecompositionMapping size > 0 and: [ characterDecompositionMapping first ~= $< ]) ifTrue: [
				decomposition := characterDecompositionMapping substrings collect: [ :s | ('16r', s) asNumber].
				DecompositionMapping at: codePoint put: decomposition.
				decomposition size > 1 ifTrue: [
					composition := CompositionMapping at: decomposition first ifAbsentPut: [Dictionary new].
					composition at: decomposition second put: codePoint.
					decomposition size > 2 ifTrue: [self error: decomposition printString print].
					]].
			"
			uppercaseMapping := fields at: 13. lowercaseMapping := fields at: 14. titlecaseMapping := fields at: 15.
			Random next > 10.999 | (generalCategory = 'So') ifTrue: [
				{codePoint hex. codePointName. generalCategory} print ].
			decimalDigitValue := fields at: 7. digitValue := fields at: 8. numericValue := fields at: 9.
			decimalDigitValue isEmpty & digitValue isEmpty & numericValue isEmpty ifFalse: [
				{'numeric'. codePoint. codePointName. generalCategory. decimalDigitValue. digitValue. numericValue} print].
			"
			]].
	self initializeNamedCharactersMap! !
!Character class methodsFor: 'class initialization' stamp: 'len 5/19/2023 17:27:22'!
                      initializeNamedCharactersMap
	"Dictionary of named characters that we can enter in an editor using \name.
	Please keep the names short and try to follow the naming convention used in LaTeX."

	NamedCharactersMap := Dictionary new.
	"Superscripts:"
	4 to: 9 do: [:each| NamedCharactersMap at: '^', each printString put: (self codePoint: 16r2070 + each)].
	"Subscripts:"
	0 to: 9 do: [:each| NamedCharactersMap at: '_', each printString put: (self codePoint: 16r2080 + each)].
	'hklmnpst' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r2094 + i)].
	'iruv' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r1D61 + i)].
	"Combining characters:"
	#(
		(acute 16r0301) ('''' 16r0301) (bar 16r0304) (breve 16r0306) (check 16r030C)
		(grave 16r0300) ('`' 16r0300) (hat 16r0302) (not 16r0338) (overline 16r0305)
		(tilde 16r0303) ('~' 16r0303) ('"' 16r0308) (vec 16r20D7)
	) do: [:each| NamedCharactersMap at: each first put: (self codePoint: each second)].
	#(
		"Some more superscripts and subscripts:"
		('^0' $⁰) ('^1' $¹) ('^2' $²) ('^3' $³) ('^i' $ⁱ) ('^n' $ⁿ) ('_j' $ⱼ) ('^+' $⁺) ('^-' $⁻) ('_+' $₊) ('_-' $₋)
		"Arrows:"
		(left $←) (right $→) (up $↑) (down $↓) (leftright $↔) (updown $↕)
		(Left $⇐) (Up $⇑) (Right $⇒) (Down $⇓) (Leftright $⇔) (Updown $⇕)
		(gets $←) (to $→) (mapsto $↦) (mapsfrom $↤) (implies $⟹) (impliedby $⟸) (iff $⟺)
		(from $←) (iso $↔) (From $⇐) (To $⇒) (dfrom $⇇) (dto $⇉) "non-standard"
		"Greek alphabet:"
		(alpha $α) (beta $β) (gamma $γ) (delta $δ) (epsilon $ε) (zeta $ζ) (eta $η) (theta $θ) (iota $ι) (kappa $κ) (lambda $λ) (mu $μ) (nu $ν) (xi $ξ) (omicron $ο) (pi $π) (rho $ρ) (sigmaf $ς) (sigma $σ) (tau $τ) (upsilon $υ) (phi $φ) (chi $χ) (psi $ψ) (omega $ω) (thetasym $ϑ) (upsih $ϒ) (piv $ϖ)
		(Alpha $Α) (Beta $Β) (Gamma $Γ) (Delta $Δ) (Epsilon $Ε) (Zeta $Ζ) (Eta $Η) (Theta $Θ) (Iota $Ι) (Kappa $Κ) (Lambda $Λ) (Mu $Μ) (Nu $Ν) (Xi $Ξ) (Omicron $Ο) (Pi $Π) (Rho $Ρ) (Sigma $Σ) (Tau $Τ) (Upsilon $Υ) (Phi $Φ) (Chi $Χ) (Psi $Ψ) (Omega $Ω)
		"Blackboard bold:"
		(A $𝔸) (B $𝔹) (C $ℂ) (D $𝔻) (E $𝔼) (F $𝔽) (G $𝔾) (H $ℍ) (I $𝕀) (J $𝕁) (K $𝕂) (L $𝕃) (M $𝕄) (N $ℕ) (O $𝕆) (P $ℙ) (Q $ℚ) (R $ℝ) (S $𝕊) (T $𝕋) (U $𝕌) (V $𝕍) (W $𝕎) (X $𝕏) (Y $𝕐) (Z $ℤ)
		"Math symbols:"
		(oplus $⊕) (otimes $⊗) (ominus $⊖) (odot $⊙) (oslash $⊘)
		(times $×) (div $÷) (circ $∘) (bullet $∙) (cdot $·) (pm $±) (wr $≀)
		(perp $⊥)		
		(cap $∩) (cup $∪) (sqcap $⊓) (sqcup $⊔) (wedge $∧) (vee $∨) (perp $⊥) (parallel $∥)	
		(in $∈) (notin $∉) (exists $∃) (nexists $∄) (forall $∀) (emptyset $∅) (infty $∞) (aleph $ℵ) (ell $ℓ)
		(Im $ℑ) (Re $ℜ) (wp $℘)
		(sqrt $√) (partial $∂) (deg $°)
(leq $≤) (geq $≥) (neq $≠) (prec $≺) (succ $≻) (simeq $≃) (cong $≅) (equiv $≡) (approx $≈) (subset $⊂) (supset $⊃)
		(ldots $…) (cdots $⋯) (ddots $⋱) (iddots $⋰) (vdots $⋮) "(prime $′) (dprime $″) (tprime $‴)"
		"Other:"
		(langle $⟨) (rangle $⟩) (lceil $⌈) (rceil $⌉) (lfloor $⌊) (rfloor $⌋) (ltimes $⋉) (rtimes $⋊) 
		(lowast $⁎) (dag $†) (ddag $‡) (emdash $—) (endash $–) (questiondown $¿) (exclamdown $¡)
		(euro $€) (pounds $£) (celsius $℃) (farenheit $℉)
		(registered $®) (copyright $©) (trademark $™) (snowman $☃) (section $§))
	do: [:each| NamedCharactersMap at: each first put: each second].
	
	"Some synonyms:"
	#((prod sqcap) (coprod sqcup) (stack sqcap) (augment sqcup) (and wedge) (or vee) (xor oplus))
	do: [:each| NamedCharactersMap at: each first put: (NamedCharactersMap at: each second)]! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 4/3/2023 14:40:54'!
                    zeroWidthSpace
	^self  codePoint: 16r200B! !
!Character class methodsFor: 'services' stamp: 'jmv 12/11/2022 19:05:09'!
         canonicalCompositionOf: numericCodePoint and: combiningCodePoint

	| dict |
	dict := CompositionMapping at: numericCodePoint
		ifAbsent: [^nil ].
	^dict at: combiningCodePoint ifAbsent: nil! !
!Character class methodsFor: 'services' stamp: 'jmv 12/11/2022 19:06:32'!
                     canonicalDecomposition: numericCodePoint on: aStream

	| decomposition |
	decomposition := DecompositionMapping at: numericCodePoint
		ifAbsent: [^aStream nextPutCodePoint: numericCodePoint].
	decomposition do: [ :each |
		self canonicalDecomposition: each on: aStream ]! !
!Character class methodsFor: 'services' stamp: 'jmv 12/11/2022 19:14:16'!
    combiningClass: numericCodePoint
	(self isDiacriticalMark: numericCodePoint) ifFalse: [ ^0 ].
	^CanonicalCombiningClasses at: numericCodePoint ifAbsent: [ 	0 ]! !
!Character class methodsFor: 'services' stamp: 'jmv 12/2/2022 14:15:14'!
                    isCombiningStarter: numericCodePoint
	^ (self combiningClass: numericCodePoint) = 0! !
!Character class methodsFor: 'services' stamp: 'jmv 12/2/2022 14:13:46'!
isDiacriticalMark: numericCodePoint
	"
	(Character isDiacriticalMark: 16r0041) 
	(Character codePoint: 16r0041) isDiacriticalMark
	(Character isDiacriticalMark: 16r20D7)
	(Character codePoint: 16r20D7) isDiacriticalMark
	"
	| i |
	i := numericCodePoint + 1.
	DiacriticalMarksTable bitSize < i ifTrue: [ ^false ].
	^ DiacriticalMarksTable bitBooleanAt: i.! !
!Character class methodsFor: 'constants' stamp: 'len 12/1/2022 12:23:44'!
                namedCharactersMap
	"Dictionary of named characters that we can enter in an editor using \name."

	^ NamedCharactersMap! !

Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CanonicalCombiningClasses CompositionMapping DecompositionMapping DiacriticalMarksTable LowercaseLettersTable NamedCharactersMap SymbolsLikeTable UppercaseLettersTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

!classDefinition: #Character category: #'Kernel-Text' stamp: 'Install-6189-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h01m-jmv.001.cs.st 1/30/2024 19:37:18'!
Object immediateSubclass: #Character
	instanceVariableNames: ''
	classVariableNames: 'CanonicalCombiningClasses CompositionMapping DecompositionMapping DiacriticalMarksTable LowercaseLettersTable NamedCharactersMap SymbolsLikeTable UppercaseLettersTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

Character initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6189-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h01m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6182] on 9 January 2024 at 10:37:27 am'!
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 10:34:51' prior: 16810924!
                      isLowercase
	"Answer whether the receiver is a letter."
	"
	(Character codePoint: 16r22C7) isLowercase
	(Character codePoint: 16r042F) isLowercase
	(Character codePoint: 16r0431) isLowercase
	"
	| i |
	i := self codePoint + 1.
	LowercaseLettersTable bitSize < i ifTrue: [ ^false ].
	^LowercaseLettersTable bitBooleanAt: i.! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 10:35:17' prior: 16810943!
         isSymbolLike
	"
	(Character codePoint: 16r0041) isSymbolLike
	(Character codePoint: 16r002B) isSymbolLike
	(Character codePoint: 16r03F6) isSymbolLike
	(Character codePoint: 16r2140) isSymbolLike
	"
	| i |
	i := self codePoint + 1.
	SymbolsLikeTable bitSize < i ifTrue: [ ^false ].
	^ SymbolsLikeTable bitBooleanAt: i.! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 10:36:00' prior: 16810952!
             isUppercase
	"Answer whether the receiver is an uppercase letter."
	"
	(Character codePoint: 16r22C7) isUppercase
	(Character codePoint: 16r042F) isUppercase
	(Character codePoint: 16r0431) isUppercase
	"
	| i |
	i := self codePoint + 1.
	UppercaseLettersTable bitSize < i ifTrue: [ ^false ].
	^UppercaseLettersTable bitBooleanAt: i.! !

UnicodeCodePoint removeSelector: #asUnicodeCodePoint!

!methodRemoval: UnicodeCodePoint #asUnicodeCodePoint stamp: 'Install-6190-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h31m-jmv.001.cs.st 1/30/2024 19:37:21'!
asUnicodeCodePoint
	^self!

Character removeSelector: #asUnicodeCodePoint!

!methodRemoval: Character #asUnicodeCodePoint stamp: 'Install-6190-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h31m-jmv.001.cs.st 1/30/2024 19:37:21'!
asUnicodeCodePoint
	^UnicodeCodePoint codePoint: self codePoint!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6190-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-10h31m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6183] on 9 January 2024 at 11:19:13 am'!
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 10:39:52' prior: 16810898!
             isDiacriticalMark
	"
	(Character codePoint: 16r0041) isDiacriticalMark
	(Character codePoint: 16r20D7) isDiacriticalMark
	"
	| i |
	i := self codePoint + 1.
	DiacriticalMarksTable bitSize < i ifTrue: [ ^false ].
	^ DiacriticalMarksTable bitBooleanAt: i.! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 10:43:56' prior: 50342157!
              isSeparator
	"Answer whether the receiver is one of the separator characters"
	"Also see #separators"

	^ #(32 "space"
		9 "tab"
		10 "line feed"
		13 "cr"
		12 "form feed"
		8203"UnicodeCodePoint zeroWidthSpace")
			statePointsTo: self codePoint! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 11:14:11' prior: 50339504!
                     isValidInFilenames
	"Can be part of a filename?
		$< isValidInFilenames
		$a isValidInFilenames
		$| isValidInFilenames
		$^ isValidInFilenames
		$: isValidInFilenames
	"
self flag: #unicodeNeedsImprovement.
	self isNullCharacter ifTrue: [ ^false ].
	self isSeparator ifTrue: [ ^false ].
	^(#( $: $< $> $| $/ $\ $? $* $") statePointsTo: self) not.! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 10:44:23' prior: 50341247!
separators
	"Answer the separator characters"
	"Also see #isSeparator"

	^ #(32 "space"
		9 "tab"
		10 "line feed"
		13 "cr"
		12 "form feed"
		8203"UnicodeCodePoint zeroWidthSpace")
			collect: [ :v | Character codePoint: v ]! !
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 1/9/2024 10:53:18' prior: 50343443!
           zeroWidthSpace
	^self codePoint: 16r200B! !
!TTFontReader methodsFor: 'processing' stamp: 'jmv 1/9/2024 10:45:34' prior: 16972610!
                             mapAndStoreGlyphsUsing: characterMap
	"
	https://developer.apple.com/fonts/TrueType-Reference-Manual/RM07/appendixB.html
	"
	| glyphsByUTF8 unknownGlyph nullGlyph spaceGlyph mapSize preferredCodePoint arrowGlyphIndexes leftArrowGlyph upArrowGlyph rightArrowGlyph downArrowGlyph carriageReturnGlyph leftArrowGlyphCodePoint upArrowGlyphCodePoint rightArrowGlyphCodePoint downArrowGlyphCodePoint carriageReturnGlyphCodePoint |
	unknownGlyph := glyphs first.
	nullGlyph := glyphs second.
	mapSize := characterMap size.
	glyphsByUTF8 := Array new: 256.
	leftArrowGlyphCodePoint := self class smalltalkAssignmentArrowGlyphCodePoint.
	upArrowGlyphCodePoint := self class smalltalkReturnArrowGlyphCodePoint.
	rightArrowGlyphCodePoint := 8594.
	downArrowGlyphCodePoint := 8595.
	carriageReturnGlyphCodePoint := 8617.
	
	"Store Unicode arrow glyphs for future use if appropriate,"
	(FallbackArrowGlyphs isNil or: [fontDescription name = 'DejaVuSans']) ifTrue: [
		mapSize > 8617 ifTrue: [								"Usually true. Just in case."
			arrowGlyphIndexes := {leftArrowGlyphCodePoint. upArrowGlyphCodePoint. rightArrowGlyphCodePoint. downArrowGlyphCodePoint. carriageReturnGlyphCodePoint}
					collect: [ :codePoint | (characterMap at: codePoint+1)+1 ].
				(arrowGlyphIndexes allSatisfy: [ :i | i > 1 ]) ifTrue: [
					FallbackArrowGlyphs := arrowGlyphIndexes collect: [ :i | glyphs at: i ]]]].
	"Take arrow glyphs if present, or use fallbacks if not."
	leftArrowGlyph := upArrowGlyph := rightArrowGlyph := downArrowGlyph := carriageReturnGlyph := unknownGlyph.
	mapSize > downArrowGlyphCodePoint ifTrue: [
		leftArrowGlyph := glyphs at: (characterMap at: leftArrowGlyphCodePoint+1)+1.
		upArrowGlyph := glyphs at: (characterMap at: upArrowGlyphCodePoint+1)+1.
		rightArrowGlyph := glyphs at: (characterMap at: rightArrowGlyphCodePoint+1)+1.
		downArrowGlyph := glyphs at: (characterMap at: downArrowGlyphCodePoint+1)+1 ].
	leftArrowGlyph == unknownGlyph ifTrue: [ leftArrowGlyph := FallbackArrowGlyphs at: 1 ].
	upArrowGlyph == unknownGlyph ifTrue: [ upArrowGlyph := FallbackArrowGlyphs at: 2 ].
	rightArrowGlyph == unknownGlyph ifTrue: [ rightArrowGlyph := FallbackArrowGlyphs at: 3 ].
	downArrowGlyph == unknownGlyph ifTrue: [ downArrowGlyph := FallbackArrowGlyphs at: 4 ].
	mapSize > carriageReturnGlyphCodePoint ifTrue: [
		carriageReturnGlyph := glyphs at: (characterMap at: carriageReturnGlyphCodePoint+1)+1 ].
	carriageReturnGlyph == unknownGlyph ifTrue: [ carriageReturnGlyph := FallbackArrowGlyphs at: 5 ].

	0 to: mapSize - 1 do: [ :codePoint | | g array prevByte|

		preferredCodePoint := codePoint.
		(codePoint = $- codePoint and: [mapSize > 16r2212]) ifTrue: [ preferredCodePoint := 16r2212 ]. "WIDE MINUS"
		(codePoint = $* codePoint and: [mapSize > 16r2217]) ifTrue: [ preferredCodePoint := 16r2217 ]. "CENTERED ASTERISK"
		g := glyphs at: (characterMap at: preferredCodePoint+1)+1 ifAbsent: [ unknownGlyph ].
		g == unknownGlyph ifTrue: [
			g := glyphs at: (characterMap at: codePoint+1)+1 ifAbsent: [ unknownGlyph ]].

		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ].
					].
				prevByte := byte.
				]
			withUtf8BytesOfUnicodeCodePoint: codePoint.
			array at: prevByte+1 put: g.
		codePoint = 32 ifTrue: [
			spaceGlyph := g ].

		].

	"Synthetic Unicode zero width space glyph. Add others as needed."
	{ UnicodeCodePoint zeroWidthSpace } do: [ :codePoint | | g array prevByte|
		g := TTGlyph new.					"Suitable as zero width space"
		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ]].
				prevByte := byte ]
			withUtf8BytesOfUnicodeCodePoint: codePoint codePoint.
			array at: prevByte+1 put: g ].

	Character separators do: [ :s |
		s codePoint < 256 ifTrue: [
			glyphsByUTF8 at: s codePoint +1 put: spaceGlyph ]].
	1 to: 4 do: [ :i |			glyphsByUTF8 at: 28+i put: i ].
	glyphsByUTF8 at: 13 +1 put: carriageReturnGlyph.
	fontDescription
		glyphsByUtf8Bytes: glyphsByUTF8
		unknownGlyph: unknownGlyph scaleArrowGlyphs: {leftArrowGlyph.​ upArrowGlyph.​ rightArrowGlyph.​ downArrowGlyph. carriageReturnGlyph}! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6191-Character-use-UnicodeCodeData.txt-JuanVuletich-2024Jan09-11h18m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6184] on 9 January 2024 at 12:08:51 pm'!
!Encoder methodsFor: 'encoding' stamp: 'jmv 1/9/2024 11:23:12' prior: 50340378!
                  asciiStringLiteral: literalObject
	"Convert UnicodeStrings to Strings if ASCII.
	Same for UnicodeCodePoint and Character.
	Recursive for Arrays"
	
	literalObject class == Array ifTrue: [
		^literalObject collect: [ :each | self asciiStringLiteral: each ]].

	"Prefer String over UnicodeString for literals, if ASCII only."
	(literalObject class == UnicodeString and: [ literalObject isAscii ]) ifTrue: [
		^ literalObject asByteString ].
	
	"Prefer Character over UnicodeCodePoint for literals, if ASCII only."
	"bueh......"
	literalObject class == UnicodeCodePoint ifTrue: [
		^ Character codePoint: literalObject codePoint ].

	^literalObject! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6192-UseCharacter-NotUnicodeCodePoint-JuanVuletich-2024Jan09-12h07m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6184] on 9 January 2024 at 12:01:01 pm'!
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 11:39:35' prior: 50343146!
               isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	self isNullCharacter ifTrue: [ ^false ].
	self = $′ ifTrue: [ ^true ]. 		"Also see #xLetter"
	^#(xLetter xDigit xUnderscore xDiacritical) statePointsTo: (Scanner typeTableAt: self).! !
!Character methodsFor: 'converting' stamp: 'jmv 1/9/2024 11:26:03' prior: 16811042 overrides: 16913675!
                     asString
	^self codePoint > 255
		ifTrue: [ UnicodeString with: self ]
		ifFalse: [ String with: self ].! !
!Character methodsFor: 'converting' stamp: 'jmv 1/9/2024 11:27:54' prior: 16811086!
withDiacriticalMark: codePointOrCharacter
	"Answer the character resulting from adding a diacritical mark (accent) to a letter.
	If the result is unsupported in ISO 8859-15, answer the receiver.
	Supported diacritical marks are:
		U+0300 	COMBINING GRAVE ACCENT
		U+0301 	COMBINING ACUTE ACCENT
		U+0302 	COMBINING CIRCUMFLEX ACCENT
		U+0303 	COMBINING TILDE
		U+0308 	COMBINING DIAERESIS
		U+030A 	COMBINING RING ABOVE
		U+030C 	COMBINING CARON
		$a withDiacriticalMark: 16r301
		$N withDiacriticalMark: $~
		$Z withDiacriticalMark: $v
		
		invalid:
		$9 withDiacriticalMark:$v
		$A withDiacriticalMark: $v
		$Á withDiacriticalMark: $v
		$A withDiacriticalMark: 1244
		"
	| answer i |
	i := ((codePointOrCharacter isNumber
			ifTrue: [#(16r300 16r301 16r302 16r303 16r308 16r30A 16r30C)]
			ifFalse: [#($` $' $^ $~ $" $° $v)]) indexOf: codePointOrCharacter
				) + 1.
	answer := (Character accentedLetters detect: [ :group | group first = self ] ifNone: [ ^self ]) at: i.
	^answer = $- ifFalse: [answer] ifTrue: [self]! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:33:11' prior: 50343218 overrides: 16916096!
       initialize
	"https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt
	http://www.unicode.org/L2/L1999/UnicodeData.html
	Character initialize
	"

	| fields codePoint codePointName generalCategory canonicalCombiningClass characterDecompositionMapping decomposition composition |
	UppercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	LowercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	SymbolsLikeTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	DiacriticalMarksTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	CanonicalCombiningClasses := Dictionary new.
	DecompositionMapping := Dictionary new.
	CompositionMapping := Dictionary new.
	(DirectoryEntry smalltalkImageDirectory // 'UnicodeData.txt') readStreamDo: [ :strm |
		[strm atEnd] whileFalse: [
			fields := strm nextLine substringsSeparatedBy: $;.
			(#(4 5 6) includes: fields first size) ifFalse: [ fields first print. self error: 'Bad UnicodeData.txt file' ].
			codePoint := ('16r', fields first) asNumber.
			codePointName := fields at: 2.
			generalCategory := fields at: 3.
			codePoint <= 16r1FFFF ifTrue: [
				({ 'Lu'. 'Lt' } includes: generalCategory) ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Ll'. 'Lo' } includes: generalCategory) ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Pc'. 'Po'. 'Sm'. 'Sc'. 'Sk'. 'So' } includes: generalCategory) ifTrue: [ SymbolsLikeTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Mn'. 'Mc'. 'Me' } includes: generalCategory) ifTrue: [ DiacriticalMarksTable bitBooleanAt: codePoint+1 put: true ]].
			canonicalCombiningClass := (fields at: 4) asNumber.
			canonicalCombiningClass = 0 ifFalse: [
				CanonicalCombiningClasses at: codePoint put: canonicalCombiningClass ].
			characterDecompositionMapping := fields at: 6.
			(characterDecompositionMapping size > 0 and: [ characterDecompositionMapping first ~= $< ]) ifTrue: [
				decomposition := characterDecompositionMapping substrings collect: [ :s | ('16r', s) asNumber].
				DecompositionMapping at: codePoint put: decomposition.
				decomposition size > 1 ifTrue: [
					composition := CompositionMapping at: decomposition first ifAbsentPut: [Dictionary new].
					composition at: decomposition second put: codePoint.
					decomposition size > 2 ifTrue: [self error: decomposition printString print].
					]].
			"
			uppercaseMapping := fields at: 13. lowercaseMapping := fields at: 14. titlecaseMapping := fields at: 15.
			Random next > 10.999 | (generalCategory = 'So') ifTrue: [
				{codePoint hex. codePointName. generalCategory} print ].
			decimalDigitValue := fields at: 7. digitValue := fields at: 8. numericValue := fields at: 9.
			decimalDigitValue isEmpty & digitValue isEmpty & numericValue isEmpty ifFalse: [
				{'numeric'. codePoint. codePointName. generalCategory. decimalDigitValue. digitValue. numericValue} print].
			"
			]].
	self initializeNamedCharactersMap.! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:35:51' prior: 50343320!
      initializeNamedCharactersMap
	"Dictionary of named characters that we can enter in an editor using \name.
	Please keep the names short and try to follow the naming convention used in LaTeX."

	NamedCharactersMap := Dictionary new.
	"Superscripts:"
	4 to: 9 do: [:each| NamedCharactersMap at: '^', each printString put: (self codePoint: 16r2070 + each)].
	"Subscripts:"
	0 to: 9 do: [:each| NamedCharactersMap at: '_', each printString put: (self codePoint: 16r2080 + each)].
	'hklmnpst' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r2094 + i)].
	'iruv' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r1D61 + i)].
	"Combining characters:"
	#(
		(acute 16r0301) ('''' 16r0301) (bar 16r0304) (breve 16r0306) (check 16r030C)
		(grave 16r0300) ('`' 16r0300) (hat 16r0302) (not 16r0338) (overline 16r0305)
		(tilde 16r0303) ('~' 16r0303) ('"' 16r0308) (vec 16r20D7)
	) do: [:each| NamedCharactersMap at: each first put: (self codePoint: each second)].
	#(
		"Some more superscripts and subscripts:"
		('^0' $⁰) ('^1' $¹) ('^2' $²) ('^3' $³) ('^i' $ⁱ) ('^n' $ⁿ) ('_j' $ⱼ) ('^+' $⁺) ('^-' $⁻) ('_+' $₊) ('_-' $₋)
		"Arrows:"
		(left $←) (right $→) (up $↑) (down $↓) (leftright $↔) (updown $↕)
		(Left $⇐) (Up $⇑) (Right $⇒) (Down $⇓) (Leftright $⇔) (Updown $⇕)
		(gets $←) (to $→) (mapsto $↦) (mapsfrom $↤) (implies $⟹) (impliedby $⟸) (iff $⟺)
		(from $←) (iso $↔) (From $⇐) (To $⇒) (dfrom $⇇) (dto $⇉) "non-standard"
		"Greek alphabet:"
		(alpha $α) (beta $β) (gamma $γ) (delta $δ) (epsilon $ε) (zeta $ζ) (eta $η) (theta $θ) (iota $ι) (kappa $κ) (lambda $λ) (mu $μ) (nu $ν) (xi $ξ) (omicron $ο) (pi $π) (rho $ρ) (sigmaf $ς) (sigma $σ) (tau $τ) (upsilon $υ) (phi $φ) (chi $χ) (psi $ψ) (omega $ω) (thetasym $ϑ) (upsih $ϒ) (piv $ϖ)
		(Alpha $Α) (Beta $Β) (Gamma $Γ) (Delta $Δ) (Epsilon $Ε) (Zeta $Ζ) (Eta $Η) (Theta $Θ) (Iota $Ι) (Kappa $Κ) (Lambda $Λ) (Mu $Μ) (Nu $Ν) (Xi $Ξ) (Omicron $Ο) (Pi $Π) (Rho $Ρ) (Sigma $Σ) (Tau $Τ) (Upsilon $Υ) (Phi $Φ) (Chi $Χ) (Psi $Ψ) (Omega $Ω)
		"Blackboard bold:"
		(A $𝔸) (B $𝔹) (C $ℂ) (D $𝔻) (E $𝔼) (F $𝔽) (G $𝔾) (H $ℍ) (I $𝕀) (J $𝕁) (K $𝕂) (L $𝕃) (M $𝕄) (N $ℕ) (O $𝕆) (P $ℙ) (Q $ℚ) (R $ℝ) (S $𝕊) (T $𝕋) (U $𝕌) (V $𝕍) (W $𝕎) (X $𝕏) (Y $𝕐) (Z $ℤ)
		"Math symbols:"
		(oplus $⊕) (otimes $⊗) (ominus $⊖) (odot $⊙) (oslash $⊘)
		(times $×) (div $÷) (circ $∘) (bullet $∙) (cdot $·) (pm $±) (wr $≀)
		(perp $⊥)		
		(cap $∩) (cup $∪) (sqcap $⊓) (sqcup $⊔) (wedge $∧) (vee $∨) (perp $⊥) (parallel $∥)	
		(in $∈) (notin $∉) (exists $∃) (nexists $∄) (forall $∀) (emptyset $∅) (infty $∞) (aleph $ℵ) (ell $ℓ)
		(Im $ℑ) (Re $ℜ) (wp $℘)
		(sqrt $√) (partial $∂) (deg $°)
(leq $≤) (geq $≥) (neq $≠) (prec $≺) (succ $≻) (simeq $≃) (cong $≅) (equiv $≡) (approx $≈) (subset $⊂) (supset $⊃)
		(ldots $…) (cdots $⋯) (ddots $⋱) (iddots $⋰) (vdots $⋮) "(prime $′) (dprime $″) (tprime $‴)"
		"Other:"
		(langle $⟨) (rangle $⟩) (lceil $⌈) (rceil $⌉) (lfloor $⌊) (rfloor $⌋) (ltimes $⋉) (rtimes $⋊) 
		(lowast $⁎) (dag $†) (ddag $‡) (emdash $—) (endash $–) (questiondown $¿) (exclamdown $¡)
		(euro $€) (pounds $£) (celsius $℃) (farenheit $℉)
		(registered $®) (copyright $©) (trademark $™) (snowman $☃) (section $§))
	do: [:each| NamedCharactersMap at: each first put: each second].
	
	"Some synonyms:"
	#((prod sqcap) (coprod sqcup) (stack sqcap) (augment sqcup) (and wedge) (or vee) (xor oplus))
	do: [:each| NamedCharactersMap at: each first put: (NamedCharactersMap at: each second)]! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 1/9/2024 11:39:40' prior: 16992610!
                           isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	self isNullCharacter ifTrue: [ ^false ].
	self = $′ ifTrue: [ ^true ]. 		"Also see #xLetter"
	^#(xLetter xDigit xUnderscore xDiacritical) statePointsTo: (Scanner typeTableAt: self).! !
!UnicodeCodePoint methodsFor: 'converting' stamp: 'jmv 1/9/2024 11:28:07' prior: 50341537!
  withDiacriticalMark: codePointOrCharacter
self flag: #unicodeNeedsImprovement.
"hack"
	value < 128 ifTrue: [
		^UnicodeCodePoint codePoint: (
			(Character codePoint: value) withDiacriticalMark: codePointOrCharacter)
				codePoint ].
	^self! !
!UnicodeCodePoint class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 11:51:27' prior: 16992830!
    codePoint: aNumber
	^Character codePoint: aNumber! !
!UnicodeCodePoint class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:33:04' prior: 16992835 overrides: 16916096!
            initialize
	"https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt
	http://www.unicode.org/L2/L1999/UnicodeData.html
	UnicodeCodePoint initialize
	"

	| fields codePoint codePointName generalCategory canonicalCombiningClass characterDecompositionMapping decomposition composition |
	UppercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	LowercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	SymbolsLikeTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	DiacriticalMarksTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	CanonicalCombiningClasses := Dictionary new.
	DecompositionMapping := Dictionary new.
	CompositionMapping := Dictionary new.
	(DirectoryEntry smalltalkImageDirectory // 'UnicodeData.txt') readStreamDo: [ :strm |
		[strm atEnd] whileFalse: [
			fields := strm nextLine substringsSeparatedBy: $;.
			(#(4 5 6) includes: fields first size) ifFalse: [ fields first print. self error: 'Bad UnicodeData.txt file' ].
			codePoint := ('16r', fields first) asNumber.
			codePointName := fields at: 2.
			generalCategory := fields at: 3.
			codePoint <= 16r1FFFF ifTrue: [
				({ 'Lu'. 'Lt' } includes: generalCategory) ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Ll'. 'Lo' } includes: generalCategory) ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Pc'. 'Po'. 'Sm'. 'Sc'. 'Sk'. 'So' } includes: generalCategory) ifTrue: [ SymbolsLikeTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Mn'. 'Mc'. 'Me' } includes: generalCategory) ifTrue: [ DiacriticalMarksTable bitBooleanAt: codePoint+1 put: true ]].
			canonicalCombiningClass := (fields at: 4) asNumber.
			canonicalCombiningClass = 0 ifFalse: [
				CanonicalCombiningClasses at: codePoint put: canonicalCombiningClass ].
			characterDecompositionMapping := fields at: 6.
			(characterDecompositionMapping size > 0 and: [ characterDecompositionMapping first ~= $< ]) ifTrue: [
				decomposition := characterDecompositionMapping substrings collect: [ :s | ('16r', s) asNumber].
				DecompositionMapping at: codePoint put: decomposition.
				decomposition size > 1 ifTrue: [
					composition := CompositionMapping at: decomposition first ifAbsentPut: [Dictionary new].
					composition at: decomposition second put: codePoint.
					decomposition size > 2 ifTrue: [self error: decomposition printString print].
					]].
			"
			uppercaseMapping := fields at: 13. lowercaseMapping := fields at: 14. titlecaseMapping := fields at: 15.
			Random next > 10.999 | (generalCategory = 'So') ifTrue: [
				{codePoint hex. codePointName. generalCategory} print ].
			decimalDigitValue := fields at: 7. digitValue := fields at: 8. numericValue := fields at: 9.
			decimalDigitValue isEmpty & digitValue isEmpty & numericValue isEmpty ifFalse: [
				{'numeric'. codePoint. codePointName. generalCategory. decimalDigitValue. digitValue. numericValue} print].
			"
			]].
	self initializeNamedCharactersMap.! !
!UnicodeCodePoint class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:35:57' prior: 16992936!
                        initializeNamedCharactersMap
	"Dictionary of named characters that we can enter in an editor using \name.
	Please keep the names short and try to follow the naming convention used in LaTeX."

	NamedCharactersMap := Dictionary new.
	"Superscripts:"
	4 to: 9 do: [:each| NamedCharactersMap at: '^', each printString put: (self codePoint: 16r2070 + each)].
	"Subscripts:"
	0 to: 9 do: [:each| NamedCharactersMap at: '_', each printString put: (self codePoint: 16r2080 + each)].
	'hklmnpst' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r2094 + i)].
	'iruv' withIndexDo: [:each :i| NamedCharactersMap at: '_', each asString put: (self codePoint: 16r1D61 + i)].
	"Combining characters:"
	#(
		(acute 16r0301) ('''' 16r0301) (bar 16r0304) (breve 16r0306) (check 16r030C)
		(grave 16r0300) ('`' 16r0300) (hat 16r0302) (not 16r0338) (overline 16r0305)
		(tilde 16r0303) ('~' 16r0303) ('"' 16r0308) (vec 16r20D7)
	) do: [:each| NamedCharactersMap at: each first put: (self codePoint: each second)].
	#(
		"Some more superscripts and subscripts:"
		('^0' $⁰) ('^1' $¹) ('^2' $²) ('^3' $³) ('^i' $ⁱ) ('^n' $ⁿ) ('_j' $ⱼ) ('^+' $⁺) ('^-' $⁻) ('_+' $₊) ('_-' $₋)
		"Arrows:"
		(left $←) (right $→) (up $↑) (down $↓) (leftright $↔) (updown $↕)
		(Left $⇐) (Up $⇑) (Right $⇒) (Down $⇓) (Leftright $⇔) (Updown $⇕)
		(gets $←) (to $→) (mapsto $↦) (mapsfrom $↤) (implies $⟹) (impliedby $⟸) (iff $⟺)
		(from $←) (iso $↔) (From $⇐) (To $⇒) (dfrom $⇇) (dto $⇉) "non-standard"
		"Greek alphabet:"
		(alpha $α) (beta $β) (gamma $γ) (delta $δ) (epsilon $ε) (zeta $ζ) (eta $η) (theta $θ) (iota $ι) (kappa $κ) (lambda $λ) (mu $μ) (nu $ν) (xi $ξ) (omicron $ο) (pi $π) (rho $ρ) (sigmaf $ς) (sigma $σ) (tau $τ) (upsilon $υ) (phi $φ) (chi $χ) (psi $ψ) (omega $ω) (thetasym $ϑ) (upsih $ϒ) (piv $ϖ)
		(Alpha $Α) (Beta $Β) (Gamma $Γ) (Delta $Δ) (Epsilon $Ε) (Zeta $Ζ) (Eta $Η) (Theta $Θ) (Iota $Ι) (Kappa $Κ) (Lambda $Λ) (Mu $Μ) (Nu $Ν) (Xi $Ξ) (Omicron $Ο) (Pi $Π) (Rho $Ρ) (Sigma $Σ) (Tau $Τ) (Upsilon $Υ) (Phi $Φ) (Chi $Χ) (Psi $Ψ) (Omega $Ω)
		"Blackboard bold:"
		(A $𝔸) (B $𝔹) (C $ℂ) (D $𝔻) (E $𝔼) (F $𝔽) (G $𝔾) (H $ℍ) (I $𝕀) (J $𝕁) (K $𝕂) (L $𝕃) (M $𝕄) (N $ℕ) (O $𝕆) (P $ℙ) (Q $ℚ) (R $ℝ) (S $𝕊) (T $𝕋) (U $𝕌) (V $𝕍) (W $𝕎) (X $𝕏) (Y $𝕐) (Z $ℤ)
		"Math symbols:"
		(oplus $⊕) (otimes $⊗) (ominus $⊖) (odot $⊙) (oslash $⊘)
		(times $×) (div $÷) (circ $∘) (bullet $∙) (cdot $·) (pm $±) (wr $≀)
		(perp $⊥)		
		(cap $∩) (cup $∪) (sqcap $⊓) (sqcup $⊔) (wedge $∧) (vee $∨) (perp $⊥) (parallel $∥)	
		(in $∈) (notin $∉) (exists $∃) (nexists $∄) (forall $∀) (emptyset $∅) (infty $∞) (aleph $ℵ) (ell $ℓ)
		(Im $ℑ) (Re $ℜ) (wp $℘)
		(sqrt $√) (partial $∂) (deg $°)
(leq $≤) (geq $≥) (neq $≠) (prec $≺) (succ $≻) (simeq $≃) (cong $≅) (equiv $≡) (approx $≈) (subset $⊂) (supset $⊃)
		(ldots $…) (cdots $⋯) (ddots $⋱) (iddots $⋰) (vdots $⋮) "(prime $′) (dprime $″) (tprime $‴)"
		"Other:"
		(langle $⟨) (rangle $⟩) (lceil $⌈) (rceil $⌉) (lfloor $⌊) (rfloor $⌋) (ltimes $⋉) (rtimes $⋊) 
		(lowast $⁎) (dag $†) (ddag $‡) (emdash $—) (endash $–) (questiondown $¿) (exclamdown $¡)
		(euro $€) (pounds $£) (celsius $℃) (farenheit $℉)
		(registered $®) (copyright $©) (trademark $™) (snowman $☃) (section $§))
	do: [:each| NamedCharactersMap at: each first put: each second].
	
	"Some synonyms:"
	#((prod sqcap) (coprod sqcup) (stack sqcap) (augment sqcup) (and wedge) (or vee) (xor oplus))
	do: [:each| NamedCharactersMap at: each first put: (NamedCharactersMap at: each second)]! !
!EventSensor methodsFor: 'test' stamp: 'jmv 1/9/2024 11:28:42' prior: 16856344!
   printEventBuffer: evtBuf
	"Print the event buffer, currently only used by the method `test`."

	| type buttons macRomanCode modifiers pressType stamp unicodeCodePoint |
	type := evtBuf first.
	stamp := evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	type = EventSensor eventTypeMouse
		ifTrue: [ | position |
			position := evtBuf third @ evtBuf fourth.
			buttons := evtBuf fifth.
			modifiers := evtBuf sixth.
			Transcript
				newLine;
				show: 'Mouse';
				show: ' position:', position printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeMouseScroll
		ifTrue: [ | delta |
			delta := evtBuf third @ evtBuf fourth.
			buttons := evtBuf fifth.
			modifiers := evtBuf sixth.
			Transcript
				newLine;
				show: 'Scroll';
				show: ' delta:', delta printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeKeyboard 
		ifTrue: [
			macRomanCode := evtBuf third.
			unicodeCodePoint := evtBuf sixth.
			pressType := evtBuf fourth.
			modifiers := evtBuf fifth.
			pressType = EventSensor eventKeyDown ifTrue: [
				type := #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				type := #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				type := #keystroke].
			{type. 'macRoman:'. macRomanCode. macRomanCode hex.
				'unicodeCodePoint:'. unicodeCodePoint. unicodeCodePoint hex. Character codePoint: unicodeCodePoint} print.
			Transcript nextPutAll: ' modifiers: ', modifiers printString.
			(modifiers anyMask: 8) ifTrue: [ Transcript nextPutAll: ' [commandWinAlt]' ].
			(modifiers anyMask: 4) ifTrue: [ Transcript nextPutAll: ' [macOption]' ].
			(modifiers anyMask: 2) ifTrue: [ Transcript nextPutAll: ' [control]' ].
			(modifiers anyMask: 1) ifTrue: [ Transcript nextPutAll: ' [shift]' ].
			''print.
			].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 1/9/2024 11:39:46' prior: 50341674!
    asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in char rest did |
	in := self readStream.
	^self species streamContents: [ :out |
		[ in atEnd ] whileFalse: [
			in peek = $<
				ifTrue: [in unCommand] 	"Absorb <...><...>"
				ifFalse: [(char := in next) = $&
					ifTrue: [
						rest := in upTo: $;.
						did := out position.
						rest = 'lt' ifTrue: [out nextPut: $<].
						rest = 'gt' ifTrue: [out nextPut: $>].
						rest = 'amp' ifTrue: [out nextPut: $&].
						rest = 'deg' ifTrue: [out nextPut: $¡].
						rest = 'quot' ifTrue: [out nextPut: $"].
						rest first = $# ifTrue: [ out nextPut: (Character codePoint: rest findPositiveInteger) ].
						did = out position ifTrue: [
							out nextPut: $&; nextPutAll: rest.
							"self error: 'unknown encoded HTML char'."
							"Please add it to this method"]]
					ifFalse: [out nextPut: char]].
			]].! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 11:26:50' prior: 16993208 overrides: 16913349!
                at: codePointIndex
	"Answer the UnicodeCodePoint at code point index codePointIndex.
	(not a byte index!!)"

	| byteIndex |
	self boundsCheck: codePointIndex.
	self isAscii ifTrue: [ ^ Character codePoint: (bytes at: codePointIndex) ].
	byteIndex := self byteIndexAt: codePointIndex.
	Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
		^Character codePoint: codePoint ].
	^nil "Invalid UTF-8"! !
!UnicodeString methodsFor: 'enumerating' stamp: 'jmv 1/9/2024 11:24:34' prior: 16993947 overrides: 16947773!
  do: aBlock
	"Evaluate aBlock for all elements."

	| byteIndex stopByteIndex n |
	byteIndex := 1.
	stopByteIndex := bytes size.
	[ byteIndex <= stopByteIndex ] whileTrue: [
		n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (Character codePoint: codePoint) ].
		byteIndex := byteIndex + n ].! !
!UnicodeString methodsFor: 'enumerating' stamp: 'jmv 1/9/2024 11:24:30' prior: 16993961 overrides: 16947973!
                  from: startIndex to: stopIndex do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex n cpIndex |
	byteIndex := self byteIndexAt: startIndex.
	cpIndex := startIndex.
	[ cpIndex <= stopIndex ] whileTrue: [
		n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (Character codePoint: codePoint).
			cpIndex := cpIndex + 1 ].
		byteIndex := byteIndex + n ].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 1/9/2024 11:26:32' prior: 16994351!
                      basicCanonicalComposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalComposition.
	(UnicodeString fromCodePoints: #(119128 119141)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119135 119151)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119128 119141 119151)) basicCanonicalComposition asCodePoints
	"
	| byteIndex stopByteIndex n combining cls |
	byteIndex := 1.
	stopByteIndex := bytes size.
	combining := OrderedCollection new.
	^UnicodeString streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				cls := Character combiningClass: codePoint.
				cls = 0 ifTrue: [
					self basicCompose: combining on: strm.
					combining := OrderedCollection new ].
				combining add: codePoint ].
			byteIndex := byteIndex + n ].
		self basicCompose: combining on: strm ].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 1/9/2024 11:26:14' prior: 16994387!
                basicCanonicalDecomposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalDecomposition.
	(Character codePoint: 119135) asString basicCanonicalDecomposition asCodePoints
	(Character codePoint: 119137) asString basicCanonicalDecomposition asCodePoints
	"
	| byteIndex stopByteIndex n |
	byteIndex := 1.
	stopByteIndex := bytes size.
	^UnicodeString streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				Character canonicalDecomposition: codePoint on: strm ].
			byteIndex := byteIndex + n ]].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 1/9/2024 11:24:46' prior: 16994413!
                          basicCanonicallyOrdered
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	(UnicodeString fromCodePoints: #(16r61  16r0300 16r0315 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0300 16r031B 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r031B 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r0300 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0300 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0315 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	"
	| byteIndex stopByteIndex n combining cls element |
	byteIndex := 1.
	stopByteIndex := bytes size.
	combining := OrderedCollection new.
	^UnicodeString streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				cls := Character combiningClass: codePoint.
				cls = 0
					ifTrue: [
						combining notEmpty ifTrue: [
							combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
							combining do: [ :e | strm nextPutCodePoint: e third ]].
						strm nextPutCodePoint: codePoint.
						combining := OrderedCollection new ]
					ifFalse: [
						element := { cls. combining size+1. codePoint }.
						combining add: element ]].
			byteIndex := byteIndex + n ].
		combining notEmpty ifTrue: [
			combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
			combining do: [ :e | strm nextPutCodePoint: e third ] ]].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 1/9/2024 11:24:41' prior: 16994478!
        basicCompose: combiningCodePoints on: aStream
	| continue composition i base |
	combiningCodePoints notEmpty ifTrue: [
		continue := combiningCodePoints size > 1.
		[continue] whileTrue: [
			continue := false.
			base := combiningCodePoints first.
			i := 2.
			composition := nil.
			[composition isNil and: [i <= combiningCodePoints size ]] whileTrue: [
				composition := Character canonicalCompositionOf: base and: (combiningCodePoints at: i).
				composition ifNotNil: [
					combiningCodePoints at: 1 put: composition.
					combiningCodePoints removeAt: i.
					continue := combiningCodePoints size > 1 ].
				i := i + 1 ]].
		combiningCodePoints do: [ :e | aStream nextPutCodePoint: e ]].! !
!UniFileStream methodsFor: 'private' stamp: 'jmv 1/9/2024 11:23:45' prior: 16992088!
               nextCodePoint
	| answer |
	answer := nil.
	self nextUtf8BytesAndCodePointInto: nil into: [ :codePoint |
		answer := Character codePoint: codePoint ].

	"If we'd skipped BOM, try again. See comment at
	utf8BytesAndCodePointFor:byte2:byte3:byte4:into:into:
	Feel free to blame Microsoft for this nonsense."
	answer ifNil: [
		(self position = 3 and: [self atEnd not]) ifTrue: [
			answer := self nextCodePoint ]].

	^answer! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 1/9/2024 11:37:11' prior: 16945229!
                          xLetter
	"Form a word or keyword."

	| type |
	buffer reset.
	[(type := self typeTableAt: hereChar) == #xLetter
		or: [type == #xDigit
		or: [type == #xUnderscore
		or: [type == #xDiacritical
		or: [ hereChar = $′ ]]]]  						"Also see #isValidInIdentifiers"
	] whileTrue: [
			"open code step for speed"
			buffer nextPut: hereChar.
			hereChar := aheadChar.
			aheadChar := source atEnd
				ifTrue: [DoItCharacter "doit"]
				ifFalse: [source next]].
	tokenType := (type == #colon or: [type == #xColon and: [aheadChar ~= $=]])
		ifTrue: [
			buffer nextPut: self step.
			"Allow any number of embedded colons in literal symbols"
			[(self typeTableAt: hereChar) == #xColon]
				whileTrue:
					[buffer nextPut: self step].
			#keyword]
		ifFalse: [
			#word].
	token := buffer contents.! !
!Scanner class methodsFor: 'testing' stamp: 'jmv 1/9/2024 11:35:09' prior: 16945411!
                 typeTable: aTypeTable at: aCharacterOrCodePoint

	"Prebuilt tables for the ASCII range"
	aCharacterOrCodePoint asciiValue ifNotNil: [ :ascii |
		^aTypeTable at: ascii ].

	"For CodePoints not in the ASCII range"
	aCharacterOrCodePoint isDiacriticalMark ifTrue: [ ^#xDiacritical ].
	aCharacterOrCodePoint isLetter ifTrue: [ ^#xLetter ].
	aCharacterOrCodePoint isSymbolLike ifTrue: [ ^#xBinary ].
	aCharacterOrCodePoint = $­ ifTrue: [ ^#xBinary ].
	aCharacterOrCodePoint isSeparator ifTrue: [ ^#xDelimiter ].
	"Many should actually be #xIllegal"
	^#xLetter! !
!Scanner class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:34:21' prior: 50341864 overrides: 16916096!
                           initialize
	"
	Scanner initialize.
	"
	self initTypeTable.
	self initializeDoitCharacter! !
!Scanner class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:23:19' prior: 16945448!
  initializeDoitCharacter

	DoItCharacter := Character codePoint: self doItCharacterValue ! !
!Encoder methodsFor: 'encoding' stamp: 'jmv 1/9/2024 11:23:12' prior: 50343796!
                    asciiStringLiteral: literalObject
	"Convert UnicodeStrings to Strings if ASCII.
	Same for UnicodeCodePoint and Character.
	Recursive for Arrays"
	
	literalObject class == Array ifTrue: [
		^literalObject collect: [ :each | self asciiStringLiteral: each ]].

	"Prefer String over UnicodeString for literals, if ASCII only."
	(literalObject class == UnicodeString and: [ literalObject isAscii ]) ifTrue: [
		^ literalObject asByteString ].
	
	"Prefer Character over UnicodeCodePoint for literals, if ASCII only."
	"bueh......"
	literalObject class == UnicodeCodePoint ifTrue: [
		^ Character codePoint: literalObject codePoint ].

	^literalObject! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 1/9/2024 11:22:20' prior: 16852593!
                            normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| character i replacement |
	"Convert strings like '\+161 ' (š) to unicode"
	aKeyboardEvent isSpace ifTrue: [ | string |
		string := self privateCurrentString.
		self pointIndex - 1 to: (self pointIndex - 7 max: 1) by: -1 do: [ :index |
		string at: index :: = $\ ifTrue: [ | key |
			key := string copyFrom: index + 1 to: self pointIndex - 1.
			key size > 2 and: [ key at: 1 :: = $+ ] ::
				ifTrue: [ | stream number value |
					stream := ReadStream on: key asUppercase from: 2 to: key size.
					[ number := Integer readFrom: stream  base: 16 ] on: Error do: [ ^ false ].
					value := Character codePoint: number.
					self
						selectFrom: index to: self pointIndex - 1;
						replaceSelectionWith: (UnicodeString with: value).
						^ false ] ] ] ].
	character := aKeyboardEvent keyCharacter.
	"Linux VMs don't automatically replace combining marks + space with ASCII,
	as Windows and Mac VMs do. It seems it is an app responsability to do that in Linux."
	character isDiacriticalMark ifTrue: [
		i := self pointIndex-1.
		(i > 0 and: [ (self privateCurrentString at: i) = $  ]) ifTrue: [
			replacement := character caseOf: {
				[ `Character codePoint: 16r300` ] -> [ '`' ].
				[ `Character codePoint: 16r301` ] -> [ '''' ].
				[ `Character codePoint: 16r302` ] -> [ '^' ].
				[ `Character codePoint: 16r303` ] -> [ '~' ].
				[ `Character codePoint: 16r308` ] -> [ '"' ].
			} otherwise: [].
			replacement notNil ifTrue: [
				self selectFrom: i to: i; replaceSelectionWith: replacement.
				^ false ]
			]
		].
	self addString: (UnicodeString with: character).
	^false! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 1/9/2024 11:22:04' prior: 16954936 overrides: 50344766!
        normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| string key |
	aKeyboardEvent keyCharacter isLetter ifTrue: [^ super normalCharacter: aKeyboardEvent].
	"Allow to enter named (otherwise untypable) characters like the alpha greek letter as \alpha."
	string := self privateCurrentString.
	"Look backwards and find a character that is not a letter (we want to find '\' just a few characters behind):"
	self pointIndex - 1 to: (self pointIndex - 20 max: 1) by: -1 do: [:i|
		(string at: i) = $\ ifTrue: 
			[key := string copyFrom: i + 1 to: self pointIndex - 1.
			Character namedCharactersMap at: key ifPresent: [:value| self selectFrom: i to: self pointIndex - 1; replaceSelectionWith: (UnicodeString with: value)].
			^ super normalCharacter: aKeyboardEvent]].
	^ super normalCharacter: aKeyboardEvent! !
!KeyboardEvent methodsFor: 'keyboard' stamp: 'jmv 1/9/2024 11:21:46' prior: 16888338!
            keyCharacter
	"Answer the character corresponding this keystroke. This is defined only for keystroke events."
	| codePoint |
	codePoint := keyValue.
	self isArrowLeft ifTrue: [ codePoint := 16r2190 ].
	self isArrowUp ifTrue: [ codePoint := 16r2191 ].
	self isArrowRight ifTrue: [ codePoint := 16r2192 ].
	self isArrowDown ifTrue: [ codePoint := 16r2193 ].
	^ Character codePoint: codePoint.! !
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'jmv 1/9/2024 11:21:39' prior: 16952000!
          computeMessageEntriesFor: allSource in: contextClass and: specificModel  
	
	| id rangeType |

	canShowSelectorDocumentation := true.
	id := allSource copyFrom: currentRange start to: currentRange end.
	rangeType := currentRange rangeType.

	rangeType == #globalVar
		ifTrue: [ ^self computeMessageEntriesForClass: (Smalltalk at: id asSymbol) class ].
	rangeType == #self
		ifTrue: [ ^self computeMessageEntriesForClass: contextClass ].
	rangeType == #super
		ifTrue: [ ^self computeMessageEntriesForClass: contextClass superclass ].
	rangeType == #true 
		ifTrue: [ ^self computeMessageEntriesForClass: True ].
	rangeType == #false
		ifTrue: [ ^self computeMessageEntriesForClass: False ].
	rangeType == #nil
		ifTrue: [ ^self computeMessageEntriesForClass: UndefinedObject ].
	rangeType == #character
		ifTrue: [ ^self computeMessageEntriesForClass: Character ].
	rangeType == #number
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #string
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #symbol
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #stringSymbol
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #instVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofInstVarNamed: id ].
	rangeType == #methodArg
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id ].
	rangeType == #tempVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id ].
	rangeType == #blockArg
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockArgNamed: id ].
	rangeType == #blockTempVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockTempVarNamed: id ].
	rangeType == #workspaceVar
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (specificModel classOfWorkspaceVarNamed: id) ].
	rangeType == #thisContext
		ifTrue: [ ^self computeMessageEntriesForClass: (specificModel classOfThisContext) ]. 
	rangeType == #classVar
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	rangeType == #poolConstant
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	(rangeType beginsWith: #blockEnd)
		ifTrue: [ ^self computeMessageEntriesForClass: BlockClosure ].
	rangeType == #arrayEnd
		ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	(rangeType beginsWith: #rightBrace)
		ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	rangeType == #unary
		ifTrue: [ ^self computeEntriesOfUnaryMessageReturnNamed: id ].
	(rangeType beginsWith: #rightParenthesis)
		ifTrue: [ ^self computeMessageEntriesOfEnclosedExpressionReturn].
	rangeType == #cascadeSeparator
		ifTrue: [ ^self computeMessageEntriesOfCascadeReceiver]. 

	self computeMessageEntriesForUnknowClass 
	
	! !
!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'jmv 1/9/2024 11:31:52' prior: 16952602 overrides: 16916096!
          initialize
	"
	It takes about 6 seconds, mostly because of the time to fetch method stamps from source files...
	[ SmalltalkCompleter initialize ]timeToRun
	Selectors inspect
	"
	| maxSortValue allImplemented |
	
	EntriesLimit := 100.
	
	SystemChangeNotifier uniqueInstance
		removeActionsWithReceiver: self.	 "avoid double registration"

	SystemChangeNotifier uniqueInstance
		when: #classRemoved send: #classRemoved:fromCategory: to: self;
		when: #methodAddedInProtocol send: #methodAdded:selector:inProtocol:class:requestor: to: self;
		when: #methodRemoved send: #methodRemoved:selector:inProtocol:class: to: self.
	
	self protected: [
		allImplemented := Smalltalk allImplementedMessages.
		Selectors := Trie new.
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				Selectors at: sel ifAbsentPut: [ 0 ].
				method messages do: [ :sentMsg |
					Selectors at: sentMsg put: (Selectors at: sentMsg ifAbsent: [ 0 ]) + 1 ]]].
		"
		Smalltalk allBehaviorsDo: [:class |
			class selectorsAndMethodsDo: [ :sel :method |
				self addSelector: sel method: method allImplemented: allImplemented]].
		""
	
		"The following might not be found in #messages. Give them maximum priority."
		maxSortValue := SmallInteger maxVal.
		"From MessageNode>>#initialize"
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:) do: [ :sel |
				Selectors at: sel put: maxSortValue ].
	
		maxSortValue := SmallInteger maxVal-1.
		"From SystemDictionary >>#recreateSpecialObjectsArray"
		(1 to: Smalltalk specialSelectorSize) do:  [ :i | | sym |
			sym := Smalltalk specialSelectorAt: i.
			(Selectors includesKey: sym)
				ifTrue: [ Selectors at: sym put: maxSortValue ]]]! !
!TTFontReader methodsFor: 'processing' stamp: 'jmv 1/9/2024 11:21:10' prior: 50343650!
      mapAndStoreGlyphsUsing: characterMap
	"
	https://developer.apple.com/fonts/TrueType-Reference-Manual/RM07/appendixB.html
	"
	| glyphsByUTF8 unknownGlyph nullGlyph spaceGlyph mapSize preferredCodePoint arrowGlyphIndexes leftArrowGlyph upArrowGlyph rightArrowGlyph downArrowGlyph carriageReturnGlyph leftArrowGlyphCodePoint upArrowGlyphCodePoint rightArrowGlyphCodePoint downArrowGlyphCodePoint carriageReturnGlyphCodePoint |
	unknownGlyph := glyphs first.
	nullGlyph := glyphs second.
	mapSize := characterMap size.
	glyphsByUTF8 := Array new: 256.
	leftArrowGlyphCodePoint := self class smalltalkAssignmentArrowGlyphCodePoint.
	upArrowGlyphCodePoint := self class smalltalkReturnArrowGlyphCodePoint.
	rightArrowGlyphCodePoint := 8594.
	downArrowGlyphCodePoint := 8595.
	carriageReturnGlyphCodePoint := 8617.
	
	"Store Unicode arrow glyphs for future use if appropriate,"
	(FallbackArrowGlyphs isNil or: [fontDescription name = 'DejaVuSans']) ifTrue: [
		mapSize > 8617 ifTrue: [								"Usually true. Just in case."
			arrowGlyphIndexes := {leftArrowGlyphCodePoint. upArrowGlyphCodePoint. rightArrowGlyphCodePoint. downArrowGlyphCodePoint. carriageReturnGlyphCodePoint}
					collect: [ :codePoint | (characterMap at: codePoint+1)+1 ].
				(arrowGlyphIndexes allSatisfy: [ :i | i > 1 ]) ifTrue: [
					FallbackArrowGlyphs := arrowGlyphIndexes collect: [ :i | glyphs at: i ]]]].
	"Take arrow glyphs if present, or use fallbacks if not."
	leftArrowGlyph := upArrowGlyph := rightArrowGlyph := downArrowGlyph := carriageReturnGlyph := unknownGlyph.
	mapSize > downArrowGlyphCodePoint ifTrue: [
		leftArrowGlyph := glyphs at: (characterMap at: leftArrowGlyphCodePoint+1)+1.
		upArrowGlyph := glyphs at: (characterMap at: upArrowGlyphCodePoint+1)+1.
		rightArrowGlyph := glyphs at: (characterMap at: rightArrowGlyphCodePoint+1)+1.
		downArrowGlyph := glyphs at: (characterMap at: downArrowGlyphCodePoint+1)+1 ].
	leftArrowGlyph == unknownGlyph ifTrue: [ leftArrowGlyph := FallbackArrowGlyphs at: 1 ].
	upArrowGlyph == unknownGlyph ifTrue: [ upArrowGlyph := FallbackArrowGlyphs at: 2 ].
	rightArrowGlyph == unknownGlyph ifTrue: [ rightArrowGlyph := FallbackArrowGlyphs at: 3 ].
	downArrowGlyph == unknownGlyph ifTrue: [ downArrowGlyph := FallbackArrowGlyphs at: 4 ].
	mapSize > carriageReturnGlyphCodePoint ifTrue: [
		carriageReturnGlyph := glyphs at: (characterMap at: carriageReturnGlyphCodePoint+1)+1 ].
	carriageReturnGlyph == unknownGlyph ifTrue: [ carriageReturnGlyph := FallbackArrowGlyphs at: 5 ].

	0 to: mapSize - 1 do: [ :codePoint | | g array prevByte|

		preferredCodePoint := codePoint.
		(codePoint = $- codePoint and: [mapSize > 16r2212]) ifTrue: [ preferredCodePoint := 16r2212 ]. "WIDE MINUS"
		(codePoint = $* codePoint and: [mapSize > 16r2217]) ifTrue: [ preferredCodePoint := 16r2217 ]. "CENTERED ASTERISK"
		g := glyphs at: (characterMap at: preferredCodePoint+1)+1 ifAbsent: [ unknownGlyph ].
		g == unknownGlyph ifTrue: [
			g := glyphs at: (characterMap at: codePoint+1)+1 ifAbsent: [ unknownGlyph ]].

		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ].
					].
				prevByte := byte.
				]
			withUtf8BytesOfUnicodeCodePoint: codePoint.
			array at: prevByte+1 put: g.
		codePoint = 32 ifTrue: [
			spaceGlyph := g ].

		].

	"Synthetic Unicode zero width space glyph. Add others as needed."
	{ Character zeroWidthSpace } do: [ :codePoint | | g array prevByte|
		g := TTGlyph new.					"Suitable as zero width space"
		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ]].
				prevByte := byte ]
			withUtf8BytesOfUnicodeCodePoint: codePoint codePoint.
			array at: prevByte+1 put: g ].

	Character separators do: [ :s |
		s codePoint < 256 ifTrue: [
			glyphsByUTF8 at: s codePoint +1 put: spaceGlyph ]].
	1 to: 4 do: [ :i |			glyphsByUTF8 at: 28+i put: i ].
	glyphsByUTF8 at: 13 +1 put: carriageReturnGlyph.
	fontDescription
		glyphsByUtf8Bytes: glyphsByUTF8
		unknownGlyph: unknownGlyph scaleArrowGlyphs: {leftArrowGlyph.​ upArrowGlyph.​ rightArrowGlyph.​ downArrowGlyph. carriageReturnGlyph}! !

Character initialize!

UnicodeCodePoint initialize!

Scanner initialize!

SmalltalkCompleter initialize!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
DebuggerMethodMap voidMapCache.
ChangeSet zapAllChangeSets.
Smalltalk garbageCollect.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6193-UseCharacter-NotUnicodeCodePoint-JuanVuletich-2024Jan09-11h58m-jmv.002.cs.st----!

'From Cuis6.3 [latest update: #6186] on 9 January 2024 at 12:26:21 pm'!
!Object methodsFor: 'testing' stamp: 'jmv 1/9/2024 12:18:01' prior: 16915240!
   isCharacter
	"Overridden to return true in Character."
	^ false! !
!CodeProvider class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:18:14' prior: 16827052!
  normalizeCodeForCodeFiles: aTextOrString
	"Adapt edited code to be suitable or logging.
	Answer is a plain text.
	Additionally, if code was modified for better look and edition experience, normalize it.
	This may include reverting to ':=' for assignment, '^' for return, and any replacements of
	ASCII by Unicode symbols done by Shout.
	See also SHTextStylerST80 >> #privateConvert
	See also Clipboard >> #storeObject:"

	| answer |
	answer := aTextOrString asPlainString.
	answer := answer copyReplaceAll: `Character smalltalkLeftArrow asString, Character zeroWidthSpace asString` with: ':='.
	answer := answer copyReplaceAll: `Character smalltalkLeftArrow asString` with: ':='.
	answer := answer copyReplaceAll: `Character smalltalkUpArrow asString` with: '^'.
	^answer! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 12:18:55' prior: 50343609!
        isSeparator
	"Answer whether the receiver is one of the separator characters"
	"Also see #separators"

	^ #(32 "space"
		9 "tab"
		10 "line feed"
		13 "cr"
		12 "form feed"
		8203 "Character zeroWidthSpace")
			statePointsTo: self codePoint! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 12:19:02' prior: 50343634!
           separators
	"Answer the separator characters"
	"Also see #isSeparator"

	^ #(32 "space"
		9 "tab"
		10 "line feed"
		13 "cr"
		12 "form feed"
		8203 "Character zeroWidthSpace")
			collect: [ :v | Character codePoint: v ]! !
!EventSensor methodsFor: 'private-I/O' stamp: 'jmv 1/9/2024 12:19:23' prior: 50341628!
         fetchMoreEventsDiscardingMouseEvents: discardMouseEvents
	"Fetch more events from the VM"
	| eventBuffer type |

	"Reset input semaphore so clients can wait for the next events after this one."
	inputSemaphore isSignaled
		ifTrue: [
			hasInputSemaphore := true.
			inputSemaphore initSignals ].

	"DebuggingAid""
	dd := Time localMillisecondClock - lastEventPoll.
	"

	eventBuffer := Array new: 8.
	[
		self primGetNextEvent: eventBuffer.
		"DebuggingAid""
		eventBuffer first = 2 ifTrue: [
			k1 := eventBuffer third.
			u1 := eventBuffer sixth.
			pressType := eventBuffer fourth.
			typeS := 'unknown'.
			pressType = EventSensor eventKeyDown ifTrue: [
				typeS := #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				typeS := #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				typeS := #keystroke].
			dd >100 ifTrue: ['-' print. dd := 0 ].
			{ k1 < 256 ifTrue: [Character codePoint: k1] ifFalse: [ '[]']. Character codePoint: k1. k1. k1 hex. '-----'. 
				Character codePoint: u1. u1. u1 hex. '----'. pressType. typeS } print.
			].
		"
		type := eventBuffer at: 1.
		type = EventSensor eventTypeNone ]
			whileFalse: [
				self
					processSensorEvent: eventBuffer
					discardingMouseEvents: discardMouseEvents ].

	"Remember the last time that I checked for events."
	lastEventPoll := Time localMillisecondClock.! !
!EventSensor methodsFor: 'test' stamp: 'jmv 1/9/2024 12:25:41' prior: 50344361!
           printEventBuffer: evtBuf
	"Print the event buffer, currently only used by the method `test`."

	| type buttons macRomanCode modifiers pressType stamp codePoint |
	type := evtBuf first.
	stamp := evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	type = EventSensor eventTypeMouse
		ifTrue: [ | position |
			position := evtBuf third @ evtBuf fourth.
			buttons := evtBuf fifth.
			modifiers := evtBuf sixth.
			Transcript
				newLine;
				show: 'Mouse';
				show: ' position:', position printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeMouseScroll
		ifTrue: [ | delta |
			delta := evtBuf third @ evtBuf fourth.
			buttons := evtBuf fifth.
			modifiers := evtBuf sixth.
			Transcript
				newLine;
				show: 'Scroll';
				show: ' delta:', delta printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeKeyboard 
		ifTrue: [
			macRomanCode := evtBuf third.
			codePoint := evtBuf sixth.
			pressType := evtBuf fourth.
			modifiers := evtBuf fifth.
			pressType = EventSensor eventKeyDown ifTrue: [
				type := #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				type := #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				type := #keystroke].
			{type. 'macRoman:'. macRomanCode. macRomanCode hex.
				'Unicode CodePoint:'. codePoint. codePoint hex. Character codePoint: codePoint} print.
			Transcript nextPutAll: ' modifiers: ', modifiers printString.
			(modifiers anyMask: 8) ifTrue: [ Transcript nextPutAll: ' [commandWinAlt]' ].
			(modifiers anyMask: 4) ifTrue: [ Transcript nextPutAll: ' [macOption]' ].
			(modifiers anyMask: 2) ifTrue: [ Transcript nextPutAll: ' [control]' ].
			(modifiers anyMask: 1) ifTrue: [ Transcript nextPutAll: ' [shift]' ].
			''print.
			].! !
!String methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:12:34' prior: 50342387 overrides: 16913367!
                              at: index put: aCharacter 
	"Primitive. Store the Character in the field of the receiver indicated by
	the index. Fail if the index is not an Integer or is out of bounds, or if
	the argument is not a Character. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 64>
	aCharacter isCharacter
		ifTrue: [	
			aCharacter codePoint > 255 ifTrue: [
				self error: 'String only store Latin-1 Characters'].
			index isInteger
				ifTrue: [self errorSubscriptBounds: index]
				ifFalse: [self errorNonIntegerIndex]]
		ifFalse: [self error: 'Strings only store Characters']! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:20:43' prior: 50344461 overrides: 16913349!
          at: codePointIndex
	"Answer the Character with the CodePoint at code point index codePointIndex.
	(not a byte index!!)"

	| byteIndex |
	self boundsCheck: codePointIndex.
	self isAscii ifTrue: [ ^ Character codePoint: (bytes at: codePointIndex) ].
	byteIndex := self byteIndexAt: codePointIndex.
	Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
		^Character codePoint: codePoint ].
	^nil "Invalid UTF-8"! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:21:30' prior: 16993225 overrides: 16913367!
                        at: codePointIndex put: aCharacter
	"Store argument at position codePointIndex "

	| byteIndex currentByteCount argumentBytes newBytes |

	self boundsCheck: codePointIndex.
	byteIndex := self byteIndexAt: codePointIndex.
	currentByteCount := self encodedByteCountAt: byteIndex.

	"Fastest path if both old and new are ASCII"
	currentByteCount = 1 ifTrue: [
		aCharacter asciiValue ifNotNil: [ :newAscii |
			bytes at: 	byteIndex put: newAscii.
			^ aCharacter ]].

	argumentBytes := Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint.

	"Avoid creating new bytes object if both old and new require same number of bytes"
	argumentBytes size = currentByteCount ifTrue: [
		bytes replaceFrom: byteIndex to: byteIndex + currentByteCount - 1 with: argumentBytes startingAt: 1.
		strideIndex := nil.
		hash := nil.
		^ aCharacter ].

	"More expensive: needs a new bytes object of different size"
	newBytes := ByteArray new: bytes size - currentByteCount + argumentBytes size.
	newBytes
		replaceFrom: 1 to: byteIndex-1 with: bytes startingAt: 1;
		replaceFrom: byteIndex to: byteIndex + argumentBytes size - 1 with: argumentBytes startingAt: 1;
		replaceFrom: byteIndex + argumentBytes size to: newBytes size with: bytes startingAt: byteIndex + currentByteCount.

	self privateBytes: newBytes codePointCount: count.
	^ aCharacter.! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:22:32' prior: 16993333 overrides: 16947063!
                            indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| codePointBytes startByteIndex foundByteIndex answer |
	aCharacter isCharacter ifFalse: [ ^ aBlock value ].
	codePointBytes := Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint.
	startByteIndex := self byteIndexAt: start.
	foundByteIndex := String findString: codePointBytes in: bytes startingAt: startByteIndex.
	answer := self codePointIndexAt: foundByteIndex.
	^answer = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ answer ]! !
!UnicodeString methodsFor: 'copying' stamp: 'jmv 1/9/2024 12:22:13' prior: 16993501 overrides: 16947652!
        copyWith: aCharacter

	^UnicodeString
		fromUtf8Bytes: bytes, (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint)
		codePointCount: self size + 1.! !
!UnicodeString methodsFor: 'comparing' stamp: 'jmv 1/9/2024 12:20:06' prior: 16993509!
         < aString
	"Answer whether the receiver sorts before aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) = 1].
		(aString isUnicodeString and: [aString isAscii]) ifTrue: [
			"aString is also an ascii UnicodeString. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) = 1]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (UnicodeString compare: self with: aString) = 1! !
!UnicodeString methodsFor: 'comparing' stamp: 'jmv 1/9/2024 12:20:12' prior: 16993539!
                    <= aString
	"Answer whether the receiver sorts before or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) <= 2].
		(aString isUnicodeString and: [aString isAscii]) ifTrue: [
			"aString is also an ascii UnicodeString. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) <= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (UnicodeString compare: self with: aString) <= 2! !
!UnicodeString methodsFor: 'comparing' stamp: 'jmv 1/9/2024 12:20:17' prior: 16993604!
     > aString
	"Answer whether the receiver sorts after aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ false ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) = 3].
		(aString isUnicodeString and: [aString isAscii]) ifTrue: [
			"aString is also an ascii UnicodeString. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) = 3]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (UnicodeString compare: self with: aString) = 3! !
!UnicodeString methodsFor: 'comparing' stamp: 'jmv 1/9/2024 12:20:22' prior: 16993634!
                     >= aString
	"Answer whether the receiver sorts after or equal to aString.
	The collation order is case sensitive."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If we are ascii, we have same bytes as equivalent String."
	self isAscii ifTrue: [
		aString isByteString ifTrue: [
			"Do comparison like String does it."
			^ (String compare: bytes with: aString) >= 2].
		(aString isUnicodeString and: [aString isAscii]) ifTrue: [
			"aString is also an ascii UnicodeString. Their bytes are also same as equiv String."
			^ (String compare: bytes with: aString bytes) >= 2]].

"This needs a reasonable implementation for Unicode (this behavior is INCORRECT).
It is also slow.
At least, it is consistent with #< in Character"
self flag: #unicodeNeedsImprovement.
self flag: #slowUnicode.
	^ (UnicodeString compare: self with: aString) >= 2! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 1/9/2024 12:21:51' prior: 16994544 overrides: 16814949!
      canonicalDecomposition
	"
	https://unicode.org/reports/tr15/#Norm_Forms
	Answer a String in the NFD form 'Normalization Form Decomposed'.

	(Character codePoint: 16r1EBF) asString
	(Character codePoint: 16r1EBF) asString asUtf8Bytes
	(Character codePoint: 16r1EBF) asString basicCanonicalDecomposition asUtf8Bytes
	(Character codePoint: 16r1EBF) asString asCodePoints asArray collect: [ :e | e hex ]
	(Character codePoint: 16r1EBF) asString basicCanonicalDecomposition asCodePoints asArray collect: [ :e | e hex ]

	(UnicodeString fromUtf8Bytes: #[195 160 204 155 204 149]).
	(UnicodeString fromUtf8Bytes: #[195 160 204 155 204 149]) asUtf8Bytes.
	(UnicodeString fromUtf8Bytes: #[195 160 204 155 204 149]) basicCanonicalDecomposition asUtf8Bytes.
	(UnicodeString fromUtf8Bytes: #[195 160 204 155 204 149]) asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromUtf8Bytes: #[195 160 204 155 204 149]) basicCanonicalDecomposition asCodePoints asArray collect: [ :e | e hex ]

	(Character codePoint: 119137) asString basicCanonicalDecomposition asCodePoints
	(Character codePoint: 119135) asString basicCanonicalDecomposition asCodePoints
	"
	^self basicCanonicalDecomposition basicCanonicallyOrdered! !
!UnicodeString class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 12:22:49' prior: 16994733 overrides: 16787780!
            new: n
	"Answer will contain n null Characters"

	^self fromUtf8Bytes: (ByteArray new: n) codePointCount: n! !
!Encoder methodsFor: 'encoding' stamp: 'jmv 1/9/2024 12:23:23' prior: 50344742!
 asciiStringLiteral: literalObject
	"Convert UnicodeStrings to Strings if ASCII.
	Recursive for Arrays"
	
	literalObject class == Array ifTrue: [
		^literalObject collect: [ :each | self asciiStringLiteral: each ]].

	"Prefer String over UnicodeString for literals, if ASCII only."
	(literalObject class == UnicodeString and: [ literalObject isAscii ]) ifTrue: [
		^ literalObject asByteString ].

	^literalObject! !
!SmalltalkEditor methodsFor: 'clipboard' stamp: 'jmv 1/9/2024 12:23:46' prior: 16952965 overrides: 16852199!
                   clipboardStringOrText
	| clipContents |
	clipContents := super clipboardStringOrText.
	self replaceUnicodeArrowsWithSmalltalkArrows ifTrue: [
		clipContents := clipContents copyReplaceAll: `(Character codePoint: 16r2190) asString` with: `(Character smalltalkLeftArrow ) asString`.
		clipContents := clipContents copyReplaceAll: `(Character codePoint: 16r2191) asString` with: `(Character smalltalkUpArrow ) asString`.
		].
	^clipContents.! !
!UnicodeReadAdaptor methodsFor: 'reading' stamp: 'jmv 1/9/2024 12:24:18' prior: 16993135 overrides: 16992401!
                        next: n
	"Read n Characters (i.e. n Unicode CodePoints), or until the end of the file.
	Answer them, from current postion to end, seen from our perspective:
	Stream bytes as CodePoints (prefer UTF-8, but answer ISO-8859-15 if invalid UTF-8).
	Answer is an instance of UnicodeString."

	| utf8 codePointCount |
	codePointCount := 0.
	utf8 := ByteArray streamContents: [ :utf8Stream |
		[ codePointCount = n or: [stream atEnd] ] whileFalse: [
			stream
				nextUtf8BytesAndCodePointInto: [ :byte1 :byte2 :byte3 :byte4 |
					utf8Stream nextPut: byte1.
					byte2 ifNotNil: [
						utf8Stream nextPut: byte2.
						byte3 ifNotNil: [
							utf8Stream nextPut: byte3.
							byte4 ifNotNil: [
								utf8Stream nextPut: byte4 ]]].
					codePointCount := codePointCount + 1]
				into: nil ]].
	^UnicodeString fromUtf8Bytes: utf8 codePointCount: codePointCount.! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:24:29' prior: 16821689!
                 storeObject: anObject
	"Set new contents on the clipboard. Also export to OS.
	anObject can be a:
		String
		Text
		Form
		Morph
		Object.
	OS clipboard supports String. Other formats might be supported if ExtendedClipboardInterface is present and operative."

	| primitiveFormat id |

	"Store a copy of the object. This is appropriate in case the original object is modified after being copied to the clipboard.
	Another copy must be made again when pasting, as the same object could be pasted many times.
	Besides, store the original object, but weakly (so we don't prevent it GCed). The original object might be used in workspaces."
	(anObject isString or: [ anObject is: #Text])
		ifTrue: [
			contents := anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: nil ]
		ifFalse: [
			contents := anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: anObject ].
	
	self noteRecentClipping: contents.

	"Store on OS clipboard using ExtendedClipboardInterface if present.
	Warning: This has not yet been adapted to UTF-8 Unicode"
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			id := self idFor: contents.
			contents isString
				ifTrue: [ ^interface storeString: contents id: id ].
			(contents is: #Text)
				ifTrue: [ ^interface storeText: contents id: id ].
			(contents is: #Form)
				ifTrue: [ ^interface storeForm: contents id: id ].
			(contents is: #Morph)
				ifTrue: [ ^interface storeForm: (contents imageForm: 32) id: id ].
			^interface storeString: contents asString id: id ]].

	"Otherwise use the clipboard primitives in the VM"
	"The VM uses UTF-8 for clipboard"
	primitiveFormat := self stringOrIdFor: contents.
	"See also SHTextStylerST80 >> #privateConvert
	See also CodeProvider class >> #normalizeCodeForCodeFiles:	"
	primitiveFormat := primitiveFormat copyReplaceAll: `Character smalltalkLeftArrow asString, Character zeroWidthSpace asString` with: ':='.
	primitiveFormat := primitiveFormat copyReplaceAll: Character smalltalkLeftArrow asString with: ':='.
	primitiveFormat := primitiveFormat copyReplaceAll: Character smalltalkUpArrow asString with: '^'.
	primitiveFormat := primitiveFormat asUtf8Bytes.
	self primitiveClipboardString: primitiveFormat! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 1/9/2024 12:24:36' prior: 16943612 overrides: 16943390!
   privateConvertAssignmentsOffset: delta
	"See also CodeProvider class >> #normalizeCodeForCodeFiles:	
	See also Clipboard >> #storeObject:"
	"Turn $_ into a left arrow"

	self
		replaceStringForRangesWithType: #assignment
		with: `Character smalltalkLeftArrow asString`
		offset: delta.
	(Preferences at: #showAssignmentAsLeftArrow)
		ifTrue: [
			"Turn := into a left arrow. Include a #zeroWidthSpace so as not to modify ranges, etc."
			self
				replaceStringForRangesWithType: #ansiAssignment
				with: `Character smalltalkLeftArrow asString, Character zeroWidthSpace asString`
				offset: delta.
			"Turn $^into up arrow"
			self
				replaceStringForRangesWithType: #return
				with: `Character smalltalkUpArrow asString`
				offset: delta ].! !

Character removeSelector: #=!

!methodRemoval: Character #= stamp: 'Install-6194-Remove-UnicodeCodePoint-JuanVuletich-2024Jan09-12h12m-jmv.001.cs.st 1/30/2024 19:37:29'!
= aCodePointOrCharacter

	self == aCodePointOrCharacter ifTrue: [ ^true ].

	"Just remove this method and use inherited version when we remove UnicodeCodePoint ?"
	aCodePointOrCharacter class == UnicodeCodePoint ifFalse: [ ^false ].

	aCodePointOrCharacter isCharacter ifFalse: [ ^false ].
	^self codePoint = aCodePointOrCharacter codePoint!

Smalltalk removeClassNamed: #UnicodeCodePoint!

!classRemoval: #UnicodeCodePoint stamp: 'Install-6194-Remove-UnicodeCodePoint-JuanVuletich-2024Jan09-12h12m-jmv.001.cs.st 1/30/2024 19:37:29'!
Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value'
	classVariableNames: 'CanonicalCombiningClasses CompositionMapping DecompositionMapping DiacriticalMarksTable LowercaseLettersTable NamedCharactersMap SymbolsLikeTable UppercaseLettersTable'
	poolDictionaries: ''
	category: 'Kernel-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6194-Remove-UnicodeCodePoint-JuanVuletich-2024Jan09-12h12m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6187] on 9 January 2024 at 12:36:19 pm'!
!Character class methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:26:50'!
       evaluate: aBlock withUtf16WordsOf: aCodePoint
	"See senders for typical usage"

	| highSurrogate lowSurrogate |
	(aCodePoint between: 16rD800 and: 16rDFFF) ifTrue: [
		self error: 'invalid CodePoint' ].

	aCodePoint <= 16rFFFF ifTrue: [
		^aBlock value: aCodePoint ].

	highSurrogate := (aCodePoint - 16r10000) >> 10 + 16rD800.
	lowSurrogate := ((aCodePoint - 16r10000) bitAnd: 1023) + 16rDC00.
	aBlock value: highSurrogate.
	aBlock value: lowSurrogate.! !
!Character class methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:27:12'!
             evaluate: aBlock withUtf8BytesOf: aCodePoint
	"See senders for typical usage"

	| mask nBytes shift |
	aCodePoint < 128 ifTrue: [
		^aBlock value: aCodePoint ].
	nBytes := aCodePoint highBit + 3 // 5.
	mask := #(128 192 224 240 248 252 254 255) at: nBytes.
	shift := nBytes - 1 * -6.
	aBlock value: (aCodePoint bitShift: shift) + mask.
	2 to: nBytes do: [ :i | 
		shift := shift + 6.
		aBlock value: ((aCodePoint bitShift: shift) bitAnd: 63) + 128 ]! !
!Character class methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:30:39'!
                 evaluateOnce: aBlock withUtf8BytesOf: aCodePoint
	"Similar to #evaluate:withUtf8BytesOf:, but aBlock is evaluated just once, and must have 4 parameters."

	| mask nBytes shift byte1 byte2 byte3 byte4 |
	aCodePoint < 128 ifTrue: [
		^aBlock value: aCodePoint value: nil value: nil value: nil ].
	nBytes := aCodePoint highBit + 3 // 5.
	mask := #(128 192 224 240 248 252 254 255) at: nBytes.
	shift := nBytes - 1 * -6.
	byte1 := (aCodePoint bitShift: shift) + mask.
	nBytes >= 2 ifTrue: [
		shift := shift + 6.
		byte2 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
		nBytes >= 3 ifTrue: [
			shift := shift + 6.
			byte3 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
			nBytes = 4 ifTrue: [
				shift := shift + 6.
				byte4 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
				].
			].
		].
		^aBlock value: byte1 value: byte2 value: byte3 value: byte4.! !
!Character class methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:29:28'!
            utf8BytesOf: aCodePoint

	^ ByteArray streamContents: [ :strm |
		Character
			evaluate: [ :byte |
				strm nextPut: byte ]
			withUtf8BytesOf: aCodePoint ]! !
!Character class methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:28:42' prior: 50339993!
      utf8BytesAndCodePointForIso8859s1: byte into: bytesBlock into: codePointBlock
	"Latin-1"
	| codePoint |
	codePoint := byte.
	bytesBlock ifNotNil: [
		Character
			evaluateOnce: bytesBlock
			withUtf8BytesOf: codePoint ].
	codePointBlock ifNotNil: [
		codePointBlock value: codePoint ].
	^1! !
!String methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:27:25' prior: 16960131 overrides: 16813593!
                      asUtf8Bytes
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray with a valid UTF-8 sequence."

	| inStream nextChar codePoint |
	"Fast lane."
	self isAscii ifTrue: [ ^self asByteArray ].

	"Need to do UTF-8 encoding."
	^ByteArray streamContents: [ :outStream |
		inStream := self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar := inStream next.
			codePoint := nextChar codePoint.
			Character
				evaluate: [ :byte | outStream nextPut: byte ]
				withUtf8BytesOf: codePoint ]]! !
!String methodsFor: 'converting' stamp: 'jmv 1/9/2024 12:27:29' prior: 16960151 overrides: 16813597!
                    asUtf8BytesOrByteString
	"Similar to #asUtf8Bytes.
	May answer an instance of String as an optimization.
	See senders"

	| inStream nextChar codePoint |
	"Fast lane."
	self isAscii ifTrue: [ ^self ].

	"Need to do UTF-8 encoding."
	^ByteArray streamContents: [ :outStream |
		inStream := self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar := inStream next.
			codePoint := nextChar codePoint.
			Character
				evaluate: [ :byte | outStream nextPut: byte ]
				withUtf8BytesOf: codePoint ]]! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:29:33' prior: 50345391 overrides: 16913367!
                           at: codePointIndex put: aCharacter
	"Store argument at position codePointIndex "

	| byteIndex currentByteCount argumentBytes newBytes |

	self boundsCheck: codePointIndex.
	byteIndex := self byteIndexAt: codePointIndex.
	currentByteCount := self encodedByteCountAt: byteIndex.

	"Fastest path if both old and new are ASCII"
	currentByteCount = 1 ifTrue: [
		aCharacter asciiValue ifNotNil: [ :newAscii |
			bytes at: 	byteIndex put: newAscii.
			^ aCharacter ]].

	argumentBytes := Character utf8BytesOf: aCharacter codePoint.

	"Avoid creating new bytes object if both old and new require same number of bytes"
	argumentBytes size = currentByteCount ifTrue: [
		bytes replaceFrom: byteIndex to: byteIndex + currentByteCount - 1 with: argumentBytes startingAt: 1.
		strideIndex := nil.
		hash := nil.
		^ aCharacter ].

	"More expensive: needs a new bytes object of different size"
	newBytes := ByteArray new: bytes size - currentByteCount + argumentBytes size.
	newBytes
		replaceFrom: 1 to: byteIndex-1 with: bytes startingAt: 1;
		replaceFrom: byteIndex to: byteIndex + argumentBytes size - 1 with: argumentBytes startingAt: 1;
		replaceFrom: byteIndex + argumentBytes size to: newBytes size with: bytes startingAt: byteIndex + currentByteCount.

	self privateBytes: newBytes codePointCount: count.
	^ aCharacter.! !
!UnicodeString methodsFor: 'accessing' stamp: 'jmv 1/9/2024 12:29:40' prior: 50345437 overrides: 16947063!
            indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| codePointBytes startByteIndex foundByteIndex answer |
	aCharacter isCharacter ifFalse: [ ^ aBlock value ].
	codePointBytes := Character utf8BytesOf: aCharacter codePoint.
	startByteIndex := self byteIndexAt: start.
	foundByteIndex := String findString: codePointBytes in: bytes startingAt: startByteIndex.
	answer := self codePointIndexAt: foundByteIndex.
	^answer = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ answer ]! !
!UnicodeString methodsFor: 'copying' stamp: 'jmv 1/9/2024 12:29:36' prior: 50345456 overrides: 16947652!
                        copyWith: aCharacter

	^UnicodeString
		fromUtf8Bytes: bytes, (Character utf8BytesOf: aCharacter codePoint)
		codePointCount: self size + 1.! !
!UnicodeString class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 12:29:43' prior: 16994774 overrides: 16829606!
                       with: aCharacter 
	"Answer a new instance of me, containing utf bytes for aCharacter.
	UnicodeString with: $a
	UnicodeString with: $á
	UnicodeString with: Character euro
	"
	^self
		fromUtf8Bytes: (Character utf8BytesOf: aCharacter codePoint)
		codePointCount: 1.! !
!UnicodeString class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 12:29:48' prior: 16994786 overrides: 16829612!
                           with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter and otherCharacter.
	UnicodeString with: $a
	UnicodeString with: $á with: Character euro
	"
	^self
		fromUtf8Bytes: (Character utf8BytesOf: aCharacter codePoint),
			(Character utf8BytesOf: otherCharacter codePoint)
		codePointCount: 2.! !
!UnicodeString class methodsFor: 'instance creation' stamp: 'jmv 1/9/2024 12:29:54' prior: 16994801 overrides: 16829620!
             with: aCharacter with: otherCharacter with: thirdCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter, otherCharacter and thirdCharacter.
	UnicodeString with: $a
	UnicodeString with: $á with: Character euro
	UnicodeString with: $á with: Character euro with: $¿
	"
	^self
		fromUtf8Bytes: (Character utf8BytesOf: aCharacter codePoint),
			(Character utf8BytesOf: otherCharacter codePoint),
			(Character utf8BytesOf: thirdCharacter codePoint)
		codePointCount: 3.! !
!UnicodeString class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:26:57' prior: 16994862!
                       utf16BytesFromUtf8: utf8ByteArray bigEndian: bigEndian includeBOM: wantsBOM
	"Convert the given string from UTF-8 to UTF-16.
	Honor requested endianess. Include BOM if requested."

	^ByteArray streamContents: [ :strm | | s byteIndex n |
		wantsBOM ifTrue: [
			strm nextUint16Put: 16rFEFF bigEndian: bigEndian ].
		s := utf8ByteArray size.
		byteIndex := 1.
		[  byteIndex <= s ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: utf8ByteArray
				into: nil
				into: [ :codePoint |
					Character
						evaluate: [ :word | strm nextUint16Put: word bigEndian: bigEndian ]
						withUtf16WordsOf: codePoint  ].
			byteIndex := byteIndex + n ]].! !
!UnicodeString class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:27:01' prior: 16994886!
         utf16WordsFromUtf8: utf8ByteArray  includeBOM: wantsBOM
	"Convert the given string from UTF-8 to UTF-16.
	Include BOM if requested.
	https://en.wikipedia.org/wiki/UTF-16
	UnicodeString codePointsFromUtf8: #[36 226 130 172 240 144 144 183 240 164 173 162].
	(UnicodeString utf16WordsFromUtf8: #[36 226 130 172 240 144 144 183 240 164 173 162]
		includeBOM: false) asArray collect: [ :w | w hex ].
	(UnicodeString utf16WordsFromUtf8: #[36 226 130 172 240 144 144 183 240 164 173 162]
		includeBOM: true) asArray collect: [ :w | w hex ].
	Note: Answer is a ShortArray, which can only have even size. Add a trailing zero if needed."

	^ShortWordArray streamContents: [ :strm | | s byteIndex n |
		wantsBOM ifTrue: [
			strm nextPut: 16rFEFF ].
		s := utf8ByteArray size.
		byteIndex := 1.
		[  byteIndex <= s ] whileTrue: [
			n := Character utf8BytesAndCodePointAt: byteIndex in: utf8ByteArray
				into: nil
				into: [ :codePoint |
					Character
						evaluate: [ :word | strm nextPut: word ]
						withUtf16WordsOf: codePoint ].
			byteIndex := byteIndex + n ].
		strm position odd ifTrue: [ strm nextPut: 0 ]].! !
!UnicodeString class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:27:34' prior: 16994924!
         utf8FromCodePoints: aWordArray
	"Convert the given string from UTF-32 to UTF-8"

	^ByteArray streamContents: [ :strm |
		aWordArray do: [ :codePoint |
			Character
				evaluate: [ :byte | strm nextPut: byte ]
				withUtf8BytesOf: codePoint ]]! !
!UnicodeString class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:28:13' prior: 16994945!
              utf8FromUtf16Bytes: utf16ByteArray bigEndianHint: bigEndianHintOrNil
	"Convert the given string from UTF-16 to UTF-8.
	Use BOM if present to detect endianess, or bigEndianHintOrNil ifnotNil.
	If no BOM and bigEndianHintOrNil is nil, assume little endian."

	| isBigEndian startIndex |
	isBigEndian := bigEndianHintOrNil ifNil: [false]. "best guess"
	startIndex := 1.
	(utf16ByteArray uint16At: 1 bigEndian: true) = 16rFEFF ifTrue: [
		isBigEndian := true.
		startIndex := 3 ].
	(utf16ByteArray uint16At: 1 bigEndian: false) = 16rFEFF  ifTrue: [
		isBigEndian := false.
		startIndex := 3 ].
	^ByteArray streamContents: [ :strm | | s byteIndex word |
		s := utf16ByteArray size.
		byteIndex := startIndex.
		[ byteIndex <= s ] whileTrue: [
			word := utf16ByteArray uint16At: byteIndex bigEndian: isBigEndian.
			(word between: 16rD800 and: 16rDFFF)
				ifFalse: [
					Character
						evaluate: [ :byte | strm nextPut: byte ]
						withUtf8BytesOf: word.
					byteIndex := byteIndex + 2 ]
				ifTrue: [ | highSurrogatePart lowSurrogatePart codePoint |
					(word between: 16rD800 and: 16rDBFF) ifFalse: [ self error: 'Invalid UTF-16' ].
					highSurrogatePart := word - 16rD800.
					word := utf16ByteArray uint16At: byteIndex+2 bigEndian: isBigEndian.
					(word between: 16rDC00 and: 16rDFFF) ifFalse: [ self error: 'Invalid UTF-16' ].
					lowSurrogatePart := word - 16rDC00.
					codePoint := highSurrogatePart << 10 + lowSurrogatePart + 16r10000.
					Character
						evaluate: [ :byte | strm nextPut: byte ]
						withUtf8BytesOf: codePoint.
					byteIndex := byteIndex + 4 ]]].! !
!UnicodeString class methodsFor: 'services' stamp: 'jmv 1/9/2024 12:28:18' prior: 16994999!
                 utf8FromUtf16Words: utf16WordArray
	"Convert the given string from UTF-16 to UTF-8.
	Skip BOM if present."

	| startIndex |
	startIndex := 1.
	(utf16WordArray at: 1) = 16rFEFF ifTrue: [
		startIndex := 2 ].
	^ByteArray streamContents: [ :strm | | s wordIndex word |
		s := utf16WordArray size.
		wordIndex := startIndex.
		[ wordIndex <= s ] whileTrue: [
			word := utf16WordArray at: wordIndex.
			(word between: 16rD800 and: 16rDFFF)
				ifFalse: [
					Character
						evaluate: [ :byte | strm nextPut: byte ]
						withUtf8BytesOf: word.
					wordIndex := wordIndex + 1 ]
				ifTrue: [ | highSurrogatePart lowSurrogatePart codePoint |
					(word between: 16rD800 and: 16rDBFF) ifFalse: [ self error: 'Invalid UTF-16' ].
					highSurrogatePart := word - 16rD800.
					word := utf16WordArray at: wordIndex+1.
					(word between: 16rDC00 and: 16rDFFF) ifFalse: [ self error: 'Invalid UTF-16' ].
					lowSurrogatePart := word - 16rDC00.
					codePoint := highSurrogatePart << 10 + lowSurrogatePart + 16r10000.
					Character
						evaluate: [ :byte | strm nextPut: byte ]
						withUtf8BytesOf: codePoint.
					wordIndex := wordIndex + 2 ]]].! !
!UniFileStream methodsFor: 'read, write, position' stamp: 'jmv 1/9/2024 12:27:45' prior: 16991691!
   nextPutCodePoint: aNumber
	"UTF-8 encoded"

	Character
		evaluate: [ :byte | self nextPutByte: byte ]
		withUtf8BytesOf: aNumber! !
!Utf8EncodedWriteStream methodsFor: 'read, write, position' stamp: 'jmv 1/9/2024 12:27:49' prior: 16996001!
                nextPutCodePoint: aNumber
	"UTF-8 encoded"

	| n |
	"Save in a temp because #nextPutByte: smashes the ivar."
	n := numberOfCodePointsWritten ifNotNil: [ numberOfCodePointsWritten + 1 ].
	Character
		evaluate: [ :byte | self nextPutByte: byte ]
		withUtf8BytesOf: aNumber.
	numberOfCodePointsWritten := n.! !
!TTFontDescription methodsFor: 'glyph properties' stamp: 'jmv 1/9/2024 12:28:46' prior: 16972464!
          widthOf: aCharacterOrCodePoint

	Character
		evaluateOnce: [ :byte1 :byte2OrNil :byte3OrNil :byte4OrNil |
			^self widthOfUtf8Byte1: byte1 b2: byte2OrNil b3: byte3OrNil b4: byte4OrNil ]
		withUtf8BytesOf: aCharacterOrCodePoint codePoint.! !
!TTFontReader methodsFor: 'processing' stamp: 'jmv 1/9/2024 12:28:01' prior: 50345028!
                        mapAndStoreGlyphsUsing: characterMap
	"
	https://developer.apple.com/fonts/TrueType-Reference-Manual/RM07/appendixB.html
	"
	| glyphsByUTF8 unknownGlyph nullGlyph spaceGlyph mapSize preferredCodePoint arrowGlyphIndexes leftArrowGlyph upArrowGlyph rightArrowGlyph downArrowGlyph carriageReturnGlyph leftArrowGlyphCodePoint upArrowGlyphCodePoint rightArrowGlyphCodePoint downArrowGlyphCodePoint carriageReturnGlyphCodePoint |
	unknownGlyph := glyphs first.
	nullGlyph := glyphs second.
	mapSize := characterMap size.
	glyphsByUTF8 := Array new: 256.
	leftArrowGlyphCodePoint := self class smalltalkAssignmentArrowGlyphCodePoint.
	upArrowGlyphCodePoint := self class smalltalkReturnArrowGlyphCodePoint.
	rightArrowGlyphCodePoint := 8594.
	downArrowGlyphCodePoint := 8595.
	carriageReturnGlyphCodePoint := 8617.
	
	"Store Unicode arrow glyphs for future use if appropriate,"
	(FallbackArrowGlyphs isNil or: [fontDescription name = 'DejaVuSans']) ifTrue: [
		mapSize > 8617 ifTrue: [								"Usually true. Just in case."
			arrowGlyphIndexes := {leftArrowGlyphCodePoint. upArrowGlyphCodePoint. rightArrowGlyphCodePoint. downArrowGlyphCodePoint. carriageReturnGlyphCodePoint}
					collect: [ :codePoint | (characterMap at: codePoint+1)+1 ].
				(arrowGlyphIndexes allSatisfy: [ :i | i > 1 ]) ifTrue: [
					FallbackArrowGlyphs := arrowGlyphIndexes collect: [ :i | glyphs at: i ]]]].
	"Take arrow glyphs if present, or use fallbacks if not."
	leftArrowGlyph := upArrowGlyph := rightArrowGlyph := downArrowGlyph := carriageReturnGlyph := unknownGlyph.
	mapSize > downArrowGlyphCodePoint ifTrue: [
		leftArrowGlyph := glyphs at: (characterMap at: leftArrowGlyphCodePoint+1)+1.
		upArrowGlyph := glyphs at: (characterMap at: upArrowGlyphCodePoint+1)+1.
		rightArrowGlyph := glyphs at: (characterMap at: rightArrowGlyphCodePoint+1)+1.
		downArrowGlyph := glyphs at: (characterMap at: downArrowGlyphCodePoint+1)+1 ].
	leftArrowGlyph == unknownGlyph ifTrue: [ leftArrowGlyph := FallbackArrowGlyphs at: 1 ].
	upArrowGlyph == unknownGlyph ifTrue: [ upArrowGlyph := FallbackArrowGlyphs at: 2 ].
	rightArrowGlyph == unknownGlyph ifTrue: [ rightArrowGlyph := FallbackArrowGlyphs at: 3 ].
	downArrowGlyph == unknownGlyph ifTrue: [ downArrowGlyph := FallbackArrowGlyphs at: 4 ].
	mapSize > carriageReturnGlyphCodePoint ifTrue: [
		carriageReturnGlyph := glyphs at: (characterMap at: carriageReturnGlyphCodePoint+1)+1 ].
	carriageReturnGlyph == unknownGlyph ifTrue: [ carriageReturnGlyph := FallbackArrowGlyphs at: 5 ].

	0 to: mapSize - 1 do: [ :codePoint | | g array prevByte|

		preferredCodePoint := codePoint.
		(codePoint = $- codePoint and: [mapSize > 16r2212]) ifTrue: [ preferredCodePoint := 16r2212 ]. "WIDE MINUS"
		(codePoint = $* codePoint and: [mapSize > 16r2217]) ifTrue: [ preferredCodePoint := 16r2217 ]. "CENTERED ASTERISK"
		g := glyphs at: (characterMap at: preferredCodePoint+1)+1 ifAbsent: [ unknownGlyph ].
		g == unknownGlyph ifTrue: [
			g := glyphs at: (characterMap at: codePoint+1)+1 ifAbsent: [ unknownGlyph ]].

		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ].
					].
				prevByte := byte.
				]
			withUtf8BytesOf: codePoint.
			array at: prevByte+1 put: g.
		codePoint = 32 ifTrue: [
			spaceGlyph := g ].

		].

	"Synthetic Unicode zero width space glyph. Add others as needed."
	{ Character zeroWidthSpace } do: [ :codePoint | | g array prevByte|
		g := TTGlyph new.					"Suitable as zero width space"
		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ]].
				prevByte := byte ]
			withUtf8BytesOf: codePoint codePoint.
			array at: prevByte+1 put: g ].

	Character separators do: [ :s |
		s codePoint < 256 ifTrue: [
			glyphsByUTF8 at: s codePoint +1 put: spaceGlyph ]].
	1 to: 4 do: [ :i |			glyphsByUTF8 at: 28+i put: i ].
	glyphsByUTF8 at: 13 +1 put: carriageReturnGlyph.
	fontDescription
		glyphsByUtf8Bytes: glyphsByUTF8
		unknownGlyph: unknownGlyph scaleArrowGlyphs: {leftArrowGlyph.​ upArrowGlyph.​ rightArrowGlyph.​ downArrowGlyph. carriageReturnGlyph}! !

Character class removeSelector: #evaluateOnce:withUtf8BytesOfUnicodeCodePoint:!

!methodRemoval: Character class #evaluateOnce:withUtf8BytesOfUnicodeCodePoint: stamp: 'Install-6195-Cleanup-JuanVuletich-2024Jan09-12h33m-jmv.001.cs.st 1/30/2024 19:37:29'!
evaluateOnce: aBlock withUtf8BytesOfUnicodeCodePoint: aCodePoint
	"Similar to #evaluate:withUtf8BytesOfUnicodeCodePoint:, but aBlock is evaluated just once, and must have 4 parameters."

	| mask nBytes shift byte1 byte2 byte3 byte4 |
	aCodePoint < 128 ifTrue: [
		^aBlock value: aCodePoint value: nil value: nil value: nil ].
	nBytes := aCodePoint highBit + 3 // 5.
	mask := #(128 192 224 240 248 252 254 255) at: nBytes.
	shift := nBytes - 1 * -6.
	byte1 := (aCodePoint bitShift: shift) + mask.
	nBytes >= 2 ifTrue: [
		shift := shift + 6.
		byte2 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
		nBytes >= 3 ifTrue: [
			shift := shift + 6.
			byte3 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
			nBytes = 4 ifTrue: [
				shift := shift + 6.
				byte4 :=  ((aCodePoint bitShift: shift) bitAnd: 63) + 128.
				].
			].
		].
		^aBlock value: byte1 value: byte2 value: byte3 value: byte4.!

Character class removeSelector: #evaluate:withUtf8BytesOfUnicodeCodePoint:!

!methodRemoval: Character class #evaluate:withUtf8BytesOfUnicodeCodePoint: stamp: 'Install-6195-Cleanup-JuanVuletich-2024Jan09-12h33m-jmv.001.cs.st 1/30/2024 19:37:29'!
evaluate: aBlock withUtf8BytesOfUnicodeCodePoint: aCodePoint
	"See senders for typical usage"

	| mask nBytes shift |
	aCodePoint < 128 ifTrue: [
		^aBlock value: aCodePoint ].
	nBytes := aCodePoint highBit + 3 // 5.
	mask := #(128 192 224 240 248 252 254 255) at: nBytes.
	shift := nBytes - 1 * -6.
	aBlock value: (aCodePoint bitShift: shift) + mask.
	2 to: nBytes do: [ :i | 
		shift := shift + 6.
		aBlock value: ((aCodePoint bitShift: shift) bitAnd: 63) + 128 ]!

Character class removeSelector: #evaluate:withUtf16WordsOfUnicodeCodePoint:!

!methodRemoval: Character class #evaluate:withUtf16WordsOfUnicodeCodePoint: stamp: 'Install-6195-Cleanup-JuanVuletich-2024Jan09-12h33m-jmv.001.cs.st 1/30/2024 19:37:29'!
evaluate: aBlock withUtf16WordsOfUnicodeCodePoint: aCodePoint
	"See senders for typical usage"

	| highSurrogate lowSurrogate |
	(aCodePoint between: 16rD800 and: 16rDFFF) ifTrue: [
		self error: 'invalid CodePoint' ].

	aCodePoint <= 16rFFFF ifTrue: [
		^aBlock value: aCodePoint ].

	highSurrogate := (aCodePoint - 16r10000) >> 10 + 16rD800.
	lowSurrogate := ((aCodePoint - 16r10000) bitAnd: 1023) + 16rDC00.
	aBlock value: highSurrogate.
	aBlock value: lowSurrogate.!

Character class removeSelector: #utf8BytesOfUnicodeCodePoint:!

!methodRemoval: Character class #utf8BytesOfUnicodeCodePoint: stamp: 'Install-6195-Cleanup-JuanVuletich-2024Jan09-12h33m-jmv.001.cs.st 1/30/2024 19:37:29'!
utf8BytesOfUnicodeCodePoint: aCodePoint

	^ ByteArray streamContents: [ :strm |
		Character
			evaluate: [ :byte |
				strm nextPut: byte ]
			withUtf8BytesOfUnicodeCodePoint: aCodePoint ]!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
ChangeSet zapAllChangeSets.
Smalltalk garbageCollect.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6195-Cleanup-JuanVuletich-2024Jan09-12h33m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6188] on 9 January 2024 at 3:56:35 pm'!
!Base64MimeConverter class methodsFor: 'additional services' stamp: 'jmv 1/9/2024 15:54:19' prior: 16786632!
             mimeDecodeToBytes: aStream 
	"Return a ReadWriteStream of the original ByteArray.  aStream has only 65 innocuous character values.  aStream is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."

	| me |
	aStream position: 0.
	me := self new mimeStream: aStream.
	me dataStream: (ReadWriteStream on: (ByteArray new: aStream size * 3 // 4)).
	me mimeDecodeToByteArray.
	me dataStream position: 0.
	^ me dataStream! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 1/9/2024 15:53:54' prior: 16927065!
       nextLine
	"Answer next line (may be empty), or nil if at end"

"	self atEnd ifTrue: [^nil].
	^self upTo: Character cr
"
	^self crLfNextLine! !

ReferenceStream class removeSelector: #on:!

!methodRemoval: ReferenceStream class #on: stamp: 'Install-6196-Cleanup-JuanVuletich-2024Jan09-15h53m-jmv.001.cs.st 1/30/2024 19:37:29'!
on: aStream
	"Open a new ReferenceStream on a place to put the raw data."

	aStream class == ReadWriteStream ifTrue: [
		self inform: 'Please consider using a RWBinaryOrTextStream 
instead of a ReadWriteStream'].

	^ super on: aStream
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6196-Cleanup-JuanVuletich-2024Jan09-15h53m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6196] on 29 January 2024 at 11:32:37 am'!
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 1/29/2024 11:28:11' prior: 50336615!
                  reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	self at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w submorphsDo: [ :a | a delete ]].
	Preferences at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	self garbageCollect.

	self removeEmptyMessageCategories.
	self organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := self unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(self at: c) removeFromSystem]. 
		n := self removeAllUnSentMessages.
		unused := self unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	self garbageCollect.

	self removeEmptyMessageCategories.
	self organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	self garbageCollect.
	oldDicts := MethodDictionary allInstances.
	newDicts := Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts := newDicts := nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   Smalltalk browseAllUnimplementedCalls"! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/29/2024 11:26:08' prior: 50336681!
filenameForUpdatedImage: aBoolean
	"If aBoolean, include highest update number	"
	| fileName newName changesName systemVersion |
	systemVersion := SystemVersion current.
	fileName := String streamContents: [ :strm |
		strm nextPutAll: systemVersion versionString.
		aBoolean ifTrue: [
			strm
				nextPut: $-;
				print: systemVersion highestUpdate ].
		self wordSize = 4 ifTrue: [
			strm nextPutAll: '-32' ]].
	newName := fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName := DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName := self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		self inform:
'There is already .changes file of the desired name,
', changesName, '
curiously already present, even though there is no
corresponding .image file.
Please remedy manually and then repeat your request.'.
		^nil  ].
	^newName! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/29/2024 11:28:17' prior: 50336719!
setGCParameters
	"Adjust the VM's default GC parameters to avoid premature tenuring, and too frequent scavenging.
	Parameters set here don't persist, so we set them on startup.
	See #setDefaultGCParameters"

	| proportion edenSize survivorSize averageObjectSize numObjects |

	"Grow old memory in chunks of: "
	self vmParameterAt: 25 put: `32*1024*1024`.
	"Shrink heap when unused memory is at least: "
	self vmParameterAt: 24 put: `64*1024*1024`.

	"Note: (jmv, 9/2021) It seems modern Spur VMs ignore parameter 6. This all seems to be bogus."
	proportion := 0.9. "tenure when 90% of pastSpace is full"
	edenSize := self vmParameterAt: 44.
	survivorSize := edenSize / 5.0. "David's paper uses 140Kb eden + 2 x 28kb survivor spaces; Spur uses the same ratios :-)"
	averageObjectSize := 8 * self wordSize. "a good approximation"
	numObjects := (proportion * survivorSize / averageObjectSize) rounded.
	self vmParameterAt: 6 put: numObjects.  "tenure when more than this many objects survive the GC"
	"/Note: (jmv, 9/2021)"
	
	"Do a full GC when used memory grows by this factor.
	Default is 0.333.
	2.0 means gull GC when heap size triples."
	self vmParameterAt: 55 put: 2.0.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6197-DontRefSmalltalkInSystemDictionary-JuanVuletich-2024Jan29-11h22m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6197] on 29 January 2024 at 11:55:38 am'!
!ChangeRecord methodsFor: 'accessing' stamp: 'jmv 1/29/2024 11:51:02' prior: 16805919 overrides: 16805392!
fileOutOn: aFileStream
	"File the receiver out on the given file stream"

	| aString |
	type == #method
		ifTrue: [
			aFileStream newLine; nextPut: $!!.
			aString :=  class asString
							, (meta ifTrue: [' class methodsFor: ']
									ifFalse: [' methodsFor: '])
							, category asString printString.
			stamp ifNotNil: [
				aString := aString, ' stamp: ''', stamp, ''''].
			aFileStream nextChunkPut: aString.
			aFileStream newLine ].

	type == #preamble ifTrue: [ aFileStream nextPut: $!! ].

	type == #classComment
		ifTrue: [
			aFileStream nextPut: $!!.
			aFileStream nextChunkPut: class asString, ' commentStamp: ', stamp storeString.
			aFileStream newLine ].
		
	type == #classDefinition ifTrue: [
		aFileStream nextPut: $!!.
		aFileStream nextChunkPut: 
			'classDefinition: ', 
			(self isMetaClassChange ifTrue: [self changeClassName, ' class'] ifFalse: [self changeClassName]) printString,
			' category: ', self category printString.
		aFileStream newLine ].

	aFileStream nextChunkPut: self string.
	
	type == #method ifTrue: [ aFileStream nextChunkPut: ' '; newLine ].
	type == #classComment ifTrue: [ aFileStream newLine ].
	aFileStream newLine! !
!ChangeRecord methodsFor: 'initialization' stamp: 'jmv 1/29/2024 11:49:34' prior: 16806043 overrides: 16805388!
                          fileIn
	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it."
	| s |
	type == #method ifTrue: [
		self changeClass ifNotNil: [ :methodClass |
			methodClass
				compile: self text
				classified: category
				withStamp: stamp
				notifying: nil ]].
	self isDoIt ifTrue: [
		((s := self string) beginsWith: '----') ifFalse: [ Compiler evaluate: s ]].
	type == #classDefinition ifTrue: [ Compiler evaluate: self string ].
	type == #classComment ifTrue: [
		(Smalltalk at: class)
			comment: self text
			stamp: stamp ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6198-ChangeRecord-FileoutsFix-ClassNameWithoutHash-JuanVuletich-2024Jan29-11h54m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6189] on 10 January 2024 at 12:46:19 pm'!
!Float commentStamp: '<historical>' prior: 16864195!
                          A note About Floating Point numbers and Floating Point Arithmetic.

The following is not specific to Cuis or Smalltalk at all. This is about the properties of Float numbers in any computer implementation.

If you haven't done so already, read https://en.wikipedia.org/wiki/Floating-point_arithmetic

But if you find the Wikipedia article too detailed, or hard to read, then try http://fabiensanglard.net/floating_point_visually_explained/ (get past "How Floating Point are usually explained" and read "A different way to explain...").

Other great reads are:
	"Why don't my numbers add up?":
		http://floating-point-gui.de/
and
	"What Every Computer Scientist Should Know About Floating-Point Arithmetic":
		http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
and also maybe
	"Comparing floating point numbers"
		https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/

Now that you read them, and we are on the same boat, some further comments (from jmv):

Floats are (conceptually) approximate real numbers. That's why trig and other transcendental functions always answer Floats. That's why it is ok to round the result of operations. That's why Float is considered more general than Fraction in ST-80 and most Smalltalks. So, when we have a Float value, we must not think about it as a Rational but as a Real (actually as some unknown Real that could hopefully be close to the Rational we can actually represent). Keep this in mind when dealing with Floats, and especially avoid comparing them for equality.

When doing mixed operations with Floats and Fractions, Cuis, as most other Smalltalks, converts all values to Floats. Some other systems, including Pharo Smalltalk, Scheme and Lisp have two rules: when the answer is a Number, they convert to Float. But when the answer is a boolean (#<, #=, #<=, etc.) they convert to Fraction. We think this is a mistake. There should never be implicit conversions from Float to Fraction. Fractions are to hold exact values, and people expect Fractions to be exact. On the other hand, Floats are to hold approximations (and people should be aware of that!!). But an implicit conversion from Float to Fraction would give a Fraction that should not be considered an exact value (the value comes from an inexact Float), but that knowledge is lost, as it is an instance of Fraction.

If you want exact arithmetic, usual mathematical properties (like transitivity of equality), can live in the limited world of Rational numbers, and can afford a slight performance penalty, use Fraction instead. Avoid trascendental functions and never convert to Float.

In any case, most numeric computation is done on Float numbers. There are good reasons for that. One is that in most cases we don't need an exact answer. And in many cases we can't really have it: the inputs to algorithms already have a limited precision, or they use transcendental functions. And even when exact arithmetic is possible, if we are doing sound synthesis, 24 bits of resolution is enough. For image processing and graphics, the result is never more than 16 bits per channel. So, these fields don't really need 64 bit Doubles. 32 bit Floats are enough. Other fields do need 64 bit Doubles, like physics simulations and geometry. Games usually prefer special, faster 32 bit Float operations in GPUs that have greater errors but are faster.

There are some things that can be done to increase the confidence you can have on Float results. One is to do an error propagation analysis on the code you are running. This is not easy, but it is done for any widely used numerical method. Then, you can know real bounds and/or estimates of the errors made. So, understanding your inputs and your algorithms (for example error propagation, condition number, numeric stability), and using Float number if appropriate, is the usual advice.

Perhaps you have heard about "interval arithmetic". It is a bit better than simple Float, but doesn't really fix the problems.

The ultimate solution is to do Monte Carlo analysis, with random perturbation of inputs. After the Monte Carlo run, it is needed to do statistical analysis of possible correlations between the distributions of the random noise added to imputs and the result of the algorithm.

Additional food for thought: http://www.cs.berkeley.edu/~wkahan/Mindless.pdf . According to this, doing Monte Carlo as described above attacks a slightly different problem. This might be yet another reason (besides performance) to try something like the next paragraph. I (jmv) came up with it, and I don't really know if it has been described and or tried before or not. Mhhh. Maybe a defensive publication is in order.

A possibility that could be a practical solution, being much cheaper than Monte Carlo, but better than interval arithmetic, is to represent each value by 2 Floats: an estimation of the real value (i.e. an estimation of the mean value of the distribution of the corresponding Monte Carlo result), and an estimation of the error (i.e. an estimation of the standard deviation of the corresponding Monte Carlo result). Or perhaps even 3 of them. In addition to the estimation of the real value and an estimation of the error, we could add a hard bound on the error. In many cases it will be useless, because the error can not really be bound. But in those cases where it is possible to bound it, applications could really know about the quality of computed values.

=======================================================================

My instances represent IEEE 754 floating-point double-precision numbers. They have about 16 decimal digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:
	
	8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12

Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point. It is actually possible to specify a radix for Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:

	3r20.2 --> 6.66666666666667
	8r20.2 --> 16.25

If you don't have access to the definition of IEEE754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...
	sign		1 bit
	exponent	11 bits with bias of 1023 (16r3FF), substracted to produce an actual exponent in the range -1022 .. +1023
				- 16r000:
					significand = 0: Float zero
					significand ~= 0: Denormal number (actual exponent is -1022, not -1023. No implicit leading '1' bit in mantissa)
				- 16r7FF:
					significand = 0: Infinity
					significand ~= 0: Not A Number (NaN) representation
	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE 754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.

The single-precision format is...
	sign		1 bit
	exponent	8 bits with bias of 127 (16r7F, substracted to produce an actual exponent in the range -126 .. +127
				- 16r00:
					significand = 0: Float zero
					significand ~= 0: Denormal number (actual exponent is -126, not -127. No implicit leading '1' bit in mantissa)
				- 16rFF:
					significand = 0: Infinity
					significand ~= 0: Not A Number (NaN) representation
	mantissa	24 bits, but only 23 are stored
This format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.

You might also check https://en.wikipedia.org/wiki/IEEE_754_revision

Other great reads (covering broader but interesting issues):
https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/
https://web.archive.org/web/20150909015114/http://www.ima.umn.edu/2010-2011/W1.10-14.11/activities/Leeser-Miriam/Leeser-GPU-IMA-Jan2011.pdf
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6199-Typo-JuanVuletich-2024Jan10-12h46m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6189] on 10 January 2024 at 2:27:55 pm'!
!SystemDictionary methodsFor: 'special objects' stamp: 'jmv 1/10/2024 14:27:47' prior: 50338844!
          recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active processor (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).
	newArray at: 25 put: nil. "This is nil in Spur, which has immediate Characters."
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	newArray at: 29 put: nil. "This is nil in Spur, no compact classes."
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization.
	In Squeak these are: DoubleByteArray, WordArray, DoubleWordArray.
	Understand why."
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.
	newArray at: 36 put: nil. "was the prototype MethodContext"
	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: []).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).

	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: []).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6200-Tweak-JuanVuletich-2024Jan10-12h46m-jmv.001.cs.st----!

'From Haver6.3 [latest update: #6163] on 4 January 2024 at 4:10:13 pm'!
!StringRequestMorph methodsFor: 'initialization' stamp: 'KLG 1/4/2024 16:06:50' prior: 16961191!
                       addTextPane
	"Add a text pane and two buttons."
	
	| textPane controlsContainer |
	textPane := (TextModelMorph
		textProvider: self
		textGetter: #response
		textSetter: #response:
		selectionGetter: #selectionInterval) emptyTextDisplayMessage: 'Enter response'.
	self
		valueOfProperty: #emptyTextDisplayMessage
		ifPresentDo: [ :msg |
			textPane emptyTextDisplayMessage: msg ].
	textPane
		hasUnacceptedEdits: true;
		acceptOnCR: true;
		escAction: [ self cancel ].
	(controlsContainer := LayoutMorph newRow)
		addMorphUseAll: textPane;
		addMorph: 
			(PluggableButtonMorph model: textPane scroller action: #acceptContents ::
				setBalloonText: 'OK' bold, ' (accept input)';
				icon: Theme current acceptIcon);
		addMorph:
			(PluggableButtonMorph model: self action: #cancel ::
				setBalloonText: 'Cancel' bold, '  (discard input)';
				icon: Theme current cancelIcon).
	self addMorphUseAll: controlsContainer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6201-StringRequestMorphWithButtons-GeraldKlix-2024Jan04-16h10m-KLG.001.cs.st----!

'From Cuis6.3 [latest update: #6201] on 30 January 2024 at 2:19:51 pm'!

LayoutMorph subclass: #StringRequestMorph
	instanceVariableNames: 'response acceptBlock cancelBlock validationBlock textMorph '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!

!classDefinition: #StringRequestMorph category: #'Morphic-Composite Widgets' stamp: 'Install-6202-StringRequestMorph-fix-JuanVuletich-2024Jan30-14h18m-jmv.001.cs.st 1/30/2024 19:37:30'!
LayoutMorph subclass: #StringRequestMorph
	instanceVariableNames: 'response acceptBlock cancelBlock validationBlock textMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!
!StringRequestMorph methodsFor: 'initialization' stamp: 'jmv 1/30/2024 14:18:40' prior: 50347244!
           addTextPane
	"Add a text pane and two buttons."
	
	| controlsContainer |
	textMorph := (TextModelMorph
		textProvider: self
		textGetter: #response
		textSetter: #response:
		selectionGetter: #selectionInterval) emptyTextDisplayMessage: 'Enter response'.
	self
		valueOfProperty: #emptyTextDisplayMessage
		ifPresentDo: [ :msg |
			textMorph emptyTextDisplayMessage: msg ].
	textMorph
		hasUnacceptedEdits: true;
		acceptOnCR: true;
		escAction: [ self cancel ].
	(controlsContainer := LayoutMorph newRow)
		addMorphUseAll: textMorph;
		addMorph: 
			(PluggableButtonMorph model: textMorph scroller action: #acceptContents ::
				setBalloonText: 'OK' bold, ' (accept input)';
				icon: Theme current acceptIcon);
		addMorph:
			(PluggableButtonMorph model: self action: #cancel ::
				setBalloonText: 'Cancel' bold, '  (discard input)';
				icon: Theme current cancelIcon).
	self addMorphUseAll: controlsContainer! !
!StringRequestMorph methodsFor: 'private' stamp: 'jmv 1/30/2024 14:18:27' prior: 16961310!
                textBox
	
	^textMorph! !

LayoutMorph subclass: #StringRequestMorph
	instanceVariableNames: 'response acceptBlock cancelBlock validationBlock textMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!

!classDefinition: #StringRequestMorph category: #'Morphic-Composite Widgets' stamp: 'Install-6202-StringRequestMorph-fix-JuanVuletich-2024Jan30-14h18m-jmv.001.cs.st 1/30/2024 19:37:30'!
LayoutMorph subclass: #StringRequestMorph
	instanceVariableNames: 'response acceptBlock cancelBlock validationBlock textMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6202-StringRequestMorph-fix-JuanVuletich-2024Jan30-14h18m-jmv.001.cs.st----!

----QUIT----(30 January 2024 19:38:14) Cuis6.3-6202.image priorSource: 648!

----STARTUP---- (8 February 2024 12:44:32) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis6.3-6202.image!


'From Cuis6.3 [latest update: #6202] on 31 January 2024 at 11:59:13 am'!
!Transcript class methodsFor: 'displaying' stamp: 'jmv 1/31/2024 11:55:48' prior: 16988201!
  display
	showOnDisplay ifTrue: [
		self displayOnDisplay.
		DisplayScreen screenUpdateRequired: bounds ].
	"So any morph in front of us is repaired when Morphic cycles.
	This includes, for instance, the TranscriptWindow that shows our contents if showOnDisplay is false"
	UISupervisor whenUIinSafeState: [ self triggerEvent: #redrawTranscriptArea ].! !
!TranscriptWindow class methodsFor: 'GUI building' stamp: 'jmv 1/31/2024 11:21:33' prior: 16988594!
                           openTranscript
	"
	TranscriptWindow openTranscript
	"
	| win m |
	win := TranscriptWindow new.
	win
		setLabel: 'Transcript';
		model: Transcript.
	m := TranscriptMorph new.
	win layoutMorph addMorph: m proportionalHeight: 1.
	win model when: #redrawTranscriptArea send: #invalidateBounds to: win.
	^ win openInWorld.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
TranscriptWindow allInstancesDo: [ :tw |
	tw model removeActionsForEvent: #redraw.
	tw model when: #redrawTranscriptArea send: #invalidateBounds to: tw ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6203-AvoidDisplayArtifactsDueToDebuggerTranscriptInterference-JuanVuletich-2024Jan31-11h51m-jmv.001.cs.st----!

'From Haver6.3 [latest update: #6202] on 1 February 2024 at 9:37:36 pm'!
!SequenceableCollection methodsFor: 'copying' stamp: 'KLG 2/1/2024 21:27:41' prior: 16947551!
                              copyFrom: start count: n
	"Answer a copy of a subset of the receiver, starting from element at 
	index start and of size n."

	^(self species ofSize: n)
		replaceFrom: 1
		to: n
		with: self
		startingAt: start! !
!SequenceableCollection methodsFor: 'copying' stamp: 'KLG 2/1/2024 21:30:13' prior: 16947560!
            copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize |
	newSize := stop - start + 1 max: 0.
	^(self species ofSize: newSize)
		replaceFrom: 1
		to: newSize
		with: self
		startingAt: start! !
!SequenceableCollection methodsFor: 'copying' stamp: 'KLG 2/1/2024 21:31:30' prior: 16947586!
                               copyReplaceFrom: start to: stop with: replacementCollection 
	"Answer a copy of the receiver satisfying the following conditions: 
	+ stop is less than start, then this is an insertion; stop should be exactly start-1, 
	+ start = 1 means insert before the first character,
	+ start = size+1 means append after last character. 
	+ Otherwise, this is a replacement; start and stop have to be within the receiver's bounds."

	| newSequenceableCollection newSize endReplacement |
	newSize := self size - (stop - start + 1) + replacementCollection size.
	endReplacement := start - 1 + replacementCollection size.
	newSequenceableCollection := self species ofSize: newSize.
	start > 1 ifTrue:[
		newSequenceableCollection
			replaceFrom: 1
			to: start - 1
			with: self
			startingAt: 1].
	start <= endReplacement ifTrue:[
		newSequenceableCollection
			replaceFrom: start
			to: endReplacement
			with: replacementCollection
			startingAt: 1].
	endReplacement < newSize ifTrue:[
		newSequenceableCollection
			replaceFrom: endReplacement + 1
			to: newSize
			with: self
			startingAt: stop + 1].
	^newSequenceableCollection! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6204-UseOfSizeForCopy-GeraldKlix-2024Feb01-21h27m-KLG.001.cs.st----!

'From Cuis6.3 [latest update: #6205] on 2 February 2024 at 4:00:12 pm'!
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 2/2/2024 15:44:51' prior: 16890237!
    heightsFor: visibleSubs within: overallHeight minLayoutExtentCache: cache
	"Answer array of morphHeights for visibleSubs."
	"Preconditions: 
		ySepararations already subtracted from overallHeight.
		overallHeight is large enough to contain minimumLayoutHeights of visibleSubs."

	| numSubs scaleFactor heightToAllocate
	  sumOfPropMin sumOfPropDesired sumOfPropOriginallyDesired sumOfFixedMin
	  allocatedHeights propIndices desiredProps
	  maxOfMinAllocHeight |
	numSubs := visibleSubs size.
	sumOfFixedMin := 0.  "pixels"
	sumOfPropMin := 0.  "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	sumOfPropOriginallyDesired := 0. "Different from sumOfPropDesired if some #maximumLayoutHeight"
	allocatedHeights := Array new: numSubs.
	desiredProps := Array new: numSubs.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: numSubs do: [ :index | | sm layoutHeightMin |
		sm := visibleSubs at: index.
		layoutHeightMin := (sm minimumLayoutExtent: cache) y.
		allocatedHeights at: index put: layoutHeightMin.
		(sm isProportionalHeight)
			ifTrue:  [ | propDesired maxHeight |
				propDesired := sm layoutSpec privateProportionalHeight.
				sumOfPropOriginallyDesired := sumOfPropOriginallyDesired + propDesired.
				maxHeight := sm maximumLayoutHeight.
				(maxHeight notNil and: [ maxHeight < (propDesired * overallHeight)])
					ifTrue: [
						allocatedHeights at: index put: maxHeight.
						sumOfFixedMin := sumOfFixedMin + maxHeight ]
					ifFalse: [
						propIndices add: index.
						desiredProps at: index put: propDesired.
						sumOfPropDesired := sumOfPropDesired + propDesired.
						sumOfPropMin := sumOfPropMin + layoutHeightMin ]]
			ifFalse: [ "Allocate height for non-proportional-height morphs"
				sumOfFixedMin := sumOfFixedMin + layoutHeightMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallHeight - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedHeights ]. 
			
	"All fixed heights allocated; rest is for proportional + leftOver"
	heightToAllocate := (overallHeight - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional heights is more than 1.0,
	scale to make it all fit."
	sumOfPropOriginallyDesired > 0.999 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].

	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedHeights at: morphIndex 
			put:  ((allocatedHeights at: morphIndex) max:
				(heightToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding height is above max of minHeights
	 Keep the proportions over the minHeights at this allocation."
	maxOfMinAllocHeight := propIndices max: [ :morphIndex | 
		(visibleSubs at: morphIndex) allocHeightForFactor: scaleFactor minLayoutExtentCache: cache ].

	"Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(heightToAllocate <= maxOfMinAllocHeight) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ heightToAllocate := heightToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleSubs size.
		propIndices do: [ :morphIndex | | heightAtBalance | 
			heightAtBalance := maxOfMinAllocHeight * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: heightAtBalance "delta above min height"
			 	  	- (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) y)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex | 
				allocatedHeights at: morphIndex
					put: (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) y)
						+ (((heightToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedHeights! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 2/2/2024 15:44:56' prior: 16890532!
              widthsFor: visibleSubs within: overallWidth minLayoutExtentCache: cache
	"Answer array of morphWidths for visibleSubs."
	"Preconditions: 
		xSepararations already subtracted from overallWidth.
		overallWidth is large enough to contain minimumLayoutWidths of visibleSubs."
	
	| numSubs scaleFactor widthToAllocate
	  sumOfPropMin sumOfPropDesired sumOfFixedMin
	  allocatedWidths propIndices desiredProps
	  maxOfMinAllocWidth |
	numSubs := visibleSubs size.
	sumOfFixedMin := 0. "pixels"
	sumOfPropMin := 0. "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	allocatedWidths := Array new: numSubs.
	desiredProps := Array new: numSubs.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: numSubs do: [ :index | | sm layoutWidthMin |
		sm := visibleSubs at: index.
		layoutWidthMin := (sm minimumLayoutExtent: cache) x.
		allocatedWidths at: index put: layoutWidthMin.
		(sm isProportionalWidth)
			ifTrue:  [ | propDesired |
				propIndices add: index.
				propDesired := sm layoutSpec privateProportionalWidth.
				desiredProps at: index put: propDesired.
				sumOfPropDesired := sumOfPropDesired + propDesired.
				sumOfPropMin := sumOfPropMin + layoutWidthMin ]
			ifFalse: [ "Allocate width for non-proportional-width morphs"
				sumOfFixedMin := sumOfFixedMin + layoutWidthMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallWidth - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedWidths ]. 
			
	"All fixed widths allocated; rest is for proportional + leftOver"
	widthToAllocate := (overallWidth - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional widths is more than 1.0,
	scale to make it all fit."
	sumOfPropDesired > 1.0 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].
	
	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedWidths at: morphIndex 
			put:  ((allocatedWidths at: morphIndex) max:
				(widthToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding width is above max of minWidths
	 Keep the proportions over the minWidths at this allocation."
	maxOfMinAllocWidth := propIndices max: [ :morphIndex | 
		(visibleSubs at: morphIndex) allocWidthForFactor: scaleFactor minLayoutExtentCache: cache ].

     "Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(widthToAllocate <= maxOfMinAllocWidth) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ widthToAllocate := widthToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleSubs size.
		propIndices do: [ :morphIndex | | widthAtBalance | 
			widthAtBalance := maxOfMinAllocWidth * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: widthAtBalance "delta above min width"
					- (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) x)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex |
				allocatedWidths at: morphIndex
					put: (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) x) 
						+ (((widthToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedWidths! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6205-cleanup-JuanVuletich-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6205] on 3 February 2024 at 9:30:40 pm'!
!InlineMethod methodsFor: 'initialization' stamp: 'jmv 2/3/2024 21:30:21' prior: 16878028!
methodToInline: aCompiledMethod usages: aCollectionOfMesageNodeReferences removingMethod: removingMethod

	methodToInline := aCompiledMethod.
	messageSendsToInline := aCollectionOfMesageNodeReferences.
	replacementsByMessageSend := Dictionary new.
	temporariesDeclarationsByNode := Dictionary new.
	temporariesToDeclareByInsertionPoint := Dictionary new.
	updatedSendersCode := Dictionary new: ((messageSendsToInline groupBy: [:aMessageNodeReference | aMessageNodeReference methodReference]) keys) size.
	methodNodeToInline := methodToInline notOptimizedMethodNode.
	implementorCompleteSourceRanges := methodNodeToInline completeSourceRanges.
	removeMethod := removingMethod.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6206-tweak-JuanVuletich-2024Feb03-21h29m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6206] on 5 February 2024 at 5:33:10 pm'!
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 2/5/2024 17:31:16'!
                   browseSendersOf: aSymbol notTo: classes
	"
	Smalltalk browseSendersOf: #new: notTo: {}
	Smalltalk browseSendersOf: #new: notTo: {ArrayedCollection. CharacterSequence. Number. ThirtyTwoBitSlotsObject. BlockClosure. AdditionalMethodState. WeakMessageSend. WeakValueAssociation}
	"
	| hasMatch visitor thisMethod |
	thisMethod := nil.
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node | | receiverClass |
			(node isMessageNode and: [node selector key = aSymbol]) ifTrue: [
"thisMethod selector = #bitReverse: ifTrue: [self halt]."
				receiverClass := nil.
				Smalltalk at: node receiver name ifPresent: [ :referencedClass |
					receiverClass := referencedClass ].
				(node receiver name = #self and: [ thisMethod methodClass isMeta ]) ifTrue: [
					receiverClass := thisMethod methodClass theNonMetaClass ].
				node receiver name = '{self class}' ifTrue: [
					receiverClass := thisMethod methodClass ].
				node receiver name = '{self species}' ifTrue: [
					receiverClass := thisMethod methodClass ].
				(node receiver name = #super and: [ thisMethod methodClass isMeta ]) ifTrue: [
					receiverClass := thisMethod methodClass theNonMetaClass superclass ].
				(receiverClass isNil or: [ classes noneSatisfy: [ :c | receiverClass includesBehavior: c ] ]) ifTrue: [
					hasMatch := true ].
			]]
		select: [ :node |
			hasMatch not ].

	self
		browseAllSelect: [ :method |
			hasMatch := false.
			thisMethod := method.
			method decompile accept: visitor.
			hasMatch ]
		name: 'Senders of: ', aSymbol printString, ' but not to: ', classes printString
		autoHighlight: aSymbol.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6207-browseSendersOf-notTo-JuanVuletich-2024Feb05-17h19m-jmv.005.cs.st----!

'From Cuis6.3 [latest update: #6207] on 6 February 2024 at 9:11:37 am'!
!Set class methodsFor: 'instance creation' stamp: 'Squeak1.0 9/20/1996 10:50:05'!
                    newWithRoomForMoreThan: nElements
	"Create a Set large enough to hold nElements without growing"
	^ self basicNew init: (self sizeFor: nElements)! !
!MethodDictionary class methodsFor: 'instance creation' stamp: 'di 11/4/97 20:11' overrides: 50347825!
    newWithRoomForMoreThan: nElements
	"Create a Dictionary large enough to hold nElements without growing.
	Note that the basic size must be a power of 2.
	It is VITAL (see grow) that size gets doubled if nElements is a power of 2"
	| size |
	size := 1 bitShift: nElements highBit.
	^ (self basicNew: size) init: size! !
!Bag class methodsFor: 'instance creation' stamp: 'jmv 2/6/2024 09:07:13' prior: 16786340 overrides: 16787780!
                   new: nElements
	^ super new setContents: (self contentsClass newWithRoomForMoreThan: nElements)! !
!Set methodsFor: 'enumerating' stamp: 'jmv 2/6/2024 09:05:49' prior: 16949121 overrides: 16828617!
                          collect: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.  
	Collect the resulting values into a collection like the receiver. Answer  
	the new collection."

	| newSet |
	newSet := self species newWithRoomForMoreThan: self size.
	array do: [ :each | each ifNotNil: [ newSet add: (aBlock value: each)]].
	^ newSet! !
!Set methodsFor: 'private' stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16949254 overrides: 16932495!
                              rehash
	| newSelf |
	newSelf := self species newWithRoomForMoreThan: self size.
	self do: [:each | newSelf noCheckAdd: each].
	array := newSelf array! !
!Set class methodsFor: 'instance creation' stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16949354 overrides: 16787772!
                 new
	^ self newWithRoomForMoreThan: 4! !
!Set class methodsFor: 'instance creation' stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16949358 overrides: 16787780!
 new: nElements
	"Create a Set large enough to hold nElements without growing"
	^ super new init: (self sizeFor: nElements)! !
!Dictionary methodsFor: 'removing' stamp: 'jmv 2/6/2024 09:08:10' prior: 16848465!
               unreferencedKeys
	| currentClass associations referencedAssociations |
	currentClass := nil.
	associations := self associations asIdentitySet.
	referencedAssociations := IdentitySet newWithRoomForMoreThan: associations size.
	Smalltalk allSelect: [ :m |
		m methodClass ~~ currentClass ifTrue: [
			currentClass := m methodClass ].
		m literalsDo: [ :l |
			(l isVariableBinding and: [associations includes: l]) ifTrue: [
				referencedAssociations add: l]].
		false ].
	^((associations reject: [:assoc | referencedAssociations includes: assoc]) collect: [:assoc| assoc key]) asSet! !
!Dictionary methodsFor: 'enumerating' stamp: 'jmv 2/6/2024 09:07:34' prior: 16848491 overrides: 50347854!
             collect: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect the resulting values into a collection that is like me. Answer with the new collection."
	
	| newCollection |
	newCollection := self species newWithRoomForMoreThan: self size.
	self associationsDo: [ :each |
		newCollection at: each key put: (aBlock value: each value) ].
	^newCollection! !
!Dictionary methodsFor: 'private' stamp: 'jmv 2/6/2024 09:08:03' prior: 16848604 overrides: 50347869!
   rehash
	"Smalltalk rehash."
	| newSelf |
	newSelf := self species newWithRoomForMoreThan: self size.
	self associationsDo: [:each | newSelf noCheckAdd: each].
	array := newSelf array! !
!Dictionary class methodsFor: 'instance creation' stamp: 'jmv 2/6/2024 09:07:54' prior: 16848745 overrides: 16829586!
                newFrom: aDict 
	"Answer an instance of me containing the same associations as aDict.
	 Error if any key appears twice."
	| newDictionary |
	newDictionary := self newWithRoomForMoreThan: aDict size.
	aDict associationsDo:
		[:x |
		(newDictionary includesKey: x key)
			ifTrue: [self error: 'Duplicate key: ', x key printString]
			ifFalse: [newDictionary add: x copy]].
	^ newDictionary

"	NewDictionary newFrom: {1->#a. 2->#b. 3->#c}
	{1->#a. 2->#b. 3->#c} as: NewDictionary
	NewDictionary newFrom: {1->#a. 2->#b. 1->#c}
	{1->#a. 2->#b. 1->#c} as: NewDictionary
"! !
!Dictionary class methodsFor: 'instance creation' stamp: 'jmv 2/6/2024 09:07:58' prior: 16848765!
     newFromPairs: anArray 

	"Answer an instance of me associating (anArray at:i) to (anArray at: i+1)
	 for each odd i.  anArray must have an even number of entries."

	| newDictionary |

	newDictionary := self newWithRoomForMoreThan: (anArray size/2).
	1 to: (anArray size-1) by: 2 do: [ :i|
		newDictionary at: (anArray at: i) put: (anArray at: i+1).
	].
	^ newDictionary

	"  Dictionary newFromPairs: {'Red' . Color red . 'Blue' . Color blue . 'Green' . Color green}. "! !
!MethodDictionary methodsFor: 'removing' stamp: 'jmv 2/5/2024 18:26:53' prior: 16900714 overrides: 16949311!
                          removeAll
	"This provides a faster way than repeated become.
	a single become is still in use to prevent system crash."
	
	| newSelf |
	tally = 0 ifTrue: [^self].
	newSelf := self species newWithRoomForMoreThan: self size.  "This will preserve the capacity"
	self become: newSelf! !
!MethodDictionary methodsFor: 'private' stamp: 'jmv 2/5/2024 18:26:41' prior: 16900797 overrides: 16949215!
                         grow 
	| newSelf |
	newSelf := self species newWithRoomForMoreThan: self basicSize.  "This will double the size"
	1 to: self basicSize do: [ :i |
		(self basicAt: i)
			ifNotNil: [ :key | newSelf at: key put: (array at: i)]].
	self become: newSelf! !
!MethodDictionary methodsFor: 'private' stamp: 'jmv 2/5/2024 18:26:47' prior: 16900829 overrides: 50347927!
                         rehash 
	| newSelf |
	newSelf := self species newWithRoomForMoreThan: self size.
	1 to: self basicSize do: [ :i |
		(self basicAt: i) ifNotNil: [ :key |
			newSelf at: key put: (array at: i)]].
	self become: newSelf! !
!MethodDictionary methodsFor: 'private' stamp: 'jmv 2/5/2024 18:26:50' prior: 16900838!
             rehashWithoutBecome
	| newSelf |
	newSelf := self species newWithRoomForMoreThan: self size.
	1 to: self basicSize do: [ :i |
		(self basicAt: i) ifNotNil: [ :key |
			newSelf at: key put: (array at: i)]].
	^newSelf! !
!MethodDictionary class methodsFor: 'instance creation' stamp: 'jmv 2/5/2024 18:26:44' prior: 16900902 overrides: 50347878!
         new
	"change the default size to be a bit bigger to help reduce the number of #grows while filing in"
	^self newWithRoomForMoreThan: 16! !
!WeakSet methodsFor: 'public' stamp: 'jmv 2/6/2024 09:09:02' prior: 17006089 overrides: 50347854!
                   collect: aBlock
	| each newSet |
	newSet := self species newWithRoomForMoreThan: self size.
	tally = 0 ifTrue: [^newSet ].
	1 to: array size do:
		[:index |
			((each := array at: index) == nil or: [each == flag])
				ifFalse: [newSet add: (aBlock value: each)]
		].
	^newSet! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6208-Set-Dictionary-creation-Cleanup-JuanVuletich-2024Feb06-09h01m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6208] on 6 February 2024 at 9:30:16 am'!
!Bag class methodsFor: 'instance creation' stamp: 'jmv 2/5/2024 18:07:32' overrides: 16829586!
                   newFrom: aCollection
	"Create a new collection containing all the elements from aCollection"

	^ self new
		addAll: aCollection;
		yourself! !
!FileList methodsFor: 'file list menu' stamp: 'jmv 2/5/2024 17:58:33' prior: 16862214!
                          itemsForNoFile

	| services |
	services := OrderedCollection new.
	services add: self serviceSortByName.
	services add: self serviceSortBySize.
	services add: (self serviceSortByDate useLineAfter: true).
	services add: self serviceAddNewFile.
	services add: self serviceAddNewDirectory.
	^ services

		! !
!CPUWatcher methodsFor: 'startup-shutdown' stamp: 'jmv 2/5/2024 17:58:38' prior: 16802911!
                   monitorProcessPeriod: secs sampleRate: msecs suspendPorcine: aBoolean
	| delay |
	self stopMonitoring.
	watcher := [
		delay := Delay forMilliseconds: msecs truncated.
		[
			| thisTally |
			thisTally := IdentityBag new.
			secs * 1000 // msecs timesRepeat: [
				"Could happen if process is halted and resumed."
				delay beingWaitedOn ifTrue: [ delay := Delay forMilliseconds: delay delayDuration ].
				delay wait.
				thisTally add: Processor nextReadyProcess ].
			tally := thisTally.
			aBoolean ifTrue: [ self findThePig ]
		] repeat
	] newProcess.
	watcher
		priority: Processor highestPriority;
		name: 'CPUWatcher monitor';
		resume.
	Processor yield.! !
!MessageTally methodsFor: 'printing' stamp: 'jmv 2/5/2024 17:58:44' prior: 16899100!
                 leavesPrintExactOn: aStream

	| dict |
	dict := IdentityDictionary new.
	self leavesInto: dict fromSender: nil.
	dict asArray sort
		do: [ :node |
			node printOn: aStream.
			node printSenderCountsOn: aStream ]! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 2/5/2024 17:58:49' prior: 16803472!
                    elementCategoryDict
	| dict firstIndex lastIndex |
	elementArray ifNil: [^ nil].
	dict := Dictionary new.
	1to: categoryStops size do: [:cat |
		firstIndex := self firstIndexOfCategoryNumber: cat.
		lastIndex := self lastIndexOfCategoryNumber: cat.
		firstIndex to: lastIndex do: [:el |
			dict at: (elementArray at: el) put: (categoryArray at: cat)].
	].
	^ dict.! !
!ClassBuilder methodsFor: 'validation' stamp: 'jmv 2/5/2024 17:58:56' prior: 16816824!
                         validateClassvars: classVarArray from: oldClass forSuper: newSuper
	"Check if any of the classVars of oldClass conflict with the new superclass"
	| usedNames classVars temp |
	classVarArray isEmpty ifTrue:[^true]. "Okay"

	"Validate the class var names"
	usedNames := classVarArray asSet.
	usedNames size = classVarArray size 
		ifFalse:[	classVarArray do:[:var|
					usedNames remove: var ifAbsent:[temp := var]].
				self error: temp,' is multiply defined'. ^false].
	(usedNames includesAnyOf: self reservedNames) 
		ifTrue:[	self reservedNames do:[:var|
					(usedNames includes: var) ifTrue:[temp := var]].
				self error: temp,' is a reserved name'. ^false].

	newSuper ifNotNil: [
		usedNames := newSuper allClassVarNames asSet.
		classVarArray do:[:iv|
			(usedNames includes: iv) ifTrue:[
				newSuper withAllSuperclassesDo:[:cl|
					(cl classVarNames includes: iv) ifTrue:[temp := cl]].
				self error: iv, ' is already defined in ', temp name.
				^false]]].

	oldClass ifNotNil: [
		usedNames := Set new.
		oldClass allSubclassesDo:[:cl| usedNames addAll: cl classVarNames].
		classVars := classVarArray.
		newSuper ifNotNil: [ classVars := classVars, newSuper allClassVarNames asArray].
		classVars do: [ :iv |
			(usedNames includes: iv) ifTrue: [
				self error: iv, ' is already defined in a subclass of ', oldClass name.
				^false]]].
	^true! !
!ClassBuilder methodsFor: 'validation' stamp: 'jmv 2/5/2024 17:59:04' prior: 16816869!
                      validateInstvars: instVarArray from: oldClass forSuper: newSuper
	"Check if any of the instVars of oldClass conflict with the new superclass"
	| instVars usedNames temp |
	instVarArray isEmpty ifTrue:[^true]. "Okay"
	newSuper allowsSubInstVars ifFalse: [
		self error: newSuper printString, ' does not allow subclass inst vars. See allowsSubInstVars.'. ^ false].

	"Validate the inst var names"
	usedNames := instVarArray asSet.
	usedNames size = instVarArray size 
		ifFalse:[	instVarArray do:[:var|
					usedNames remove: var ifAbsent:[temp := var]].
				self error: temp,' is multiply defined'. ^false].
	(usedNames includesAnyOf: self reservedNames) 
		ifTrue:[	self reservedNames do:[:var|
					(usedNames includes: var) ifTrue:[temp := var]].
				self error: temp,' is a reserved name'. ^false].

	newSuper ifNotNil: [
		usedNames := newSuper allInstVarNames asSet.
		instVarArray do:[:iv|
			(usedNames includes: iv) ifTrue:[
				newSuper withAllSuperclassesDo:[:cl|
					(cl instVarNames includes: iv) ifTrue:[temp := cl]].
				self error: iv,' is already defined in ', temp name.
				^false]]].
	oldClass ifNotNil: [
		usedNames := Set new.
		oldClass allSubclassesDo:[:cl| usedNames addAll: cl instVarNames].
		instVars := instVarArray.
		newSuper ifNotNil: [instVars := instVars, newSuper allInstVarNames].
		instVars do:[:iv|
			(usedNames includes: iv) ifTrue:[
				self error: iv, ' is already defined in a subclass of ', oldClass name.
				^false]]].
	^true! !
!Decompiler methodsFor: 'public access' stamp: 'jmv 2/5/2024 17:59:21' prior: 16847012!
    decompile: aSelector in: aClass method: aMethod using: aConstructor

	| block node |
	constructor := aConstructor.
	method := aMethod.
	self initSymbols: aClass.  "create symbol tables"
	method isQuick
		ifTrue: [block := self quickMethod]
		ifFalse: 
			[stack := OrderedCollection new.
			lastJumpIfPcStack := OrderedCollection new.
			caseExits := OrderedCollection new.
			statements := OrderedCollection new.
			numLocalTemps := 0.
			super method: method pc: method initialPC.
			"skip primitive error code store if necessary"
			(method primitive ~= 0 and: [self skipCallPrimitive; willStore]) ifTrue:
				[pc := pc + (method encoderClass bytecodeSize: self firstByte).
				 tempVars := tempVars asOrderedCollection].
			block := self blockTo: method endPC + 1.
			stack isEmpty ifFalse: [self error: 'stack not empty']].
	node := constructor
				codeMethod: aSelector
				block: block
				tempVars: tempVars
				primitive: method primitive
				class: aClass.
	method primitive > 0 ifTrue:
		[node removeAndRenameLastTempIfErrorCode].
	^node preen! !
!ProcessorScheduler methodsFor: 'CPU usage tally' stamp: 'jmv 2/5/2024 17:59:27' prior: 16931559!
                            tallyCPUUsageFor: seconds every: msec
	"Start a high-priority process that will tally the next ready process for the given
	number of seconds. Answer a Block that will return the tally (a Bag) after the task
	is complete" 
	| tally sem delay endDelay |
	tally := IdentityBag new.
	delay := Delay forMilliseconds: msec truncated.
	endDelay := Delay forSeconds: seconds.
	endDelay schedule.
	sem := Semaphore new.
	[
		[ endDelay isExpired ] whileFalse: [
			delay wait.
			tally add: Processor nextReadyProcess
		].
		sem signal.
	] forkAt: self highestPriority named: 'Processor CPU Usage Tallier'.

	^[ sem wait. tally ]! !
!Collection methodsFor: 'converting' stamp: 'jmv 2/5/2024 19:13:56' prior: 16828516!
                          asSortedCollection: aSortBlock 
	"Answer a SortedCollection whose elements are the elements of the 
	receiver. The sort order is defined by the argument, aSortBlock."

	| aSortedCollection |
	aSortedCollection := SortedCollection sortBlock: aSortBlock.
	aSortedCollection addAll: self.
	^ aSortedCollection! !
!Symbol class methodsFor: 'services' stamp: 'jmv 2/5/2024 17:59:33' prior: 16962038!
                     possibleSelectorsFor: misspelled 
	"Answer an ordered collection of possible corrections
	for the misspelled selector in order of likelyhood"

	| numArgs candidates lookupString best binary short long first ss |
	lookupString := misspelled asLowercase. "correct uppercase selectors to lowercase"
	numArgs := lookupString numArgs.
	(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollection new].
	first := lookupString first.
	short := lookupString size - (lookupString size // 4 max: 3) max: 2.
	long := lookupString size + (lookupString size // 4 max: 3).

	"First assemble candidates for detailed scoring"
	candidates := OrderedCollection new.
	self allSymbolTablesDo: [:s | (((ss := s size) >= short	"not too short"
			and: [ss <= long			"not too long"
					or: [(s at: 1) = first]])	"well, any length OK if starts w/same letter"
			and: [s numArgs = numArgs])	"and numArgs is the same"
			ifTrue: [candidates add: s]].

	"Then further prune these by correctAgainst:"
	best := lookupString correctAgainst: candidates.
	((misspelled last ~= $:) and: [misspelled size > 1]) ifTrue: [
		binary := misspelled, ':'.		"try for missing colon"
		Symbol hasInterned: binary ifTrue: [:him | best addFirst: him]].
	^ best! !
!CompiledMethod methodsFor: 'literals' stamp: 'jmv 2/5/2024 17:59:39' prior: 16834214!
                           literalStrings
	| litStrs |
	litStrs := OrderedCollection new.
	self literalsDo:
		[:lit | 
		(lit isVariableBinding)
			ifTrue: [litStrs addLast: lit key]
			ifFalse: [(lit isSymbol)
				ifTrue: [litStrs addAll: lit keywords]
				ifFalse: [litStrs addLast: lit printString]]].
	^ litStrs! !
!Heap class methodsFor: 'instance creation' stamp: 'jmv 2/5/2024 18:04:24' prior: 16874196 overrides: 16787772!
            new
	^self basicNew setCollection: (Array new: 10)! !
!OrderedCollection methodsFor: 'copying' stamp: 'jmv 2/5/2024 18:00:25' prior: 16917126 overrides: 50347433!
                             copyFrom: startIndex to: endIndex 
	"Answer a copy of the receiver that contains elements from position
	startIndex to endIndex."

	| targetCollection |
	endIndex < startIndex ifTrue: [^self species new ].
	targetCollection := self species new.
	startIndex to: endIndex do: [:index | targetCollection addLast: (self at: index)].
	^ targetCollection! !
!OrderedCollection methodsFor: 'copying' stamp: 'jmv 2/5/2024 18:01:25' prior: 16917141 overrides: 50347446!
                   copyReplaceFrom: start to: stop with: replacementCollection 
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| newOrderedCollection startIndex stopIndex |
	"if start is less than 1, ignore stop and assume this is inserting at the front. 
	if start greater than self size, ignore stop and assume this is appending. 
	otherwise, it is replacing part of me and start and stop have to be within my 
	bounds. "
	startIndex := start.
	stopIndex := stop.
	start < 1
		ifTrue: [startIndex := stopIndex := 0]
		ifFalse: [startIndex > self size
				ifTrue: [startIndex := stopIndex := self size + 1]
				ifFalse: 
					[(stopIndex < (startIndex - 1) or: [stopIndex > self size])
						ifTrue: [ self errorOutOfBounds ]]].
	newOrderedCollection := self species new.
	1 to: startIndex - 1 do: [:index | newOrderedCollection add: (self at: index)].
	1 to: replacementCollection size do: 
		[:index | newOrderedCollection add: (replacementCollection at: index)].
	stopIndex + 1 to: self size do: [:index | newOrderedCollection add: (self at: index)].
	^newOrderedCollection! !
!OrderedCollection methodsFor: 'enumerating' stamp: 'jmv 2/5/2024 18:00:09' prior: 16917206 overrides: 16947729!
                       collect: aBlock 
	"Evaluate aBlock with each of my elements as the argument. Collect the 
	resulting values into a collection that is like me. Answer the new 
	collection. Override superclass in order to use addLast:, not at:put:."

	| newCollection |
	newCollection := self species new.
	newCollection resetTo: 1.
	firstIndex to: lastIndex do: [ :index |
		newCollection addLast: (aBlock value: (array at: index))].
	^ newCollection! !
!OrderedCollection methodsFor: 'enumerating' stamp: 'jmv 2/5/2024 18:00:18' prior: 16917223 overrides: 16947739!
                          collect: aBlock from: fromIndex to: toIndex
	"Override superclass in order to use addLast:, not at:put:."
	| result |
	(fromIndex < 1 or:[toIndex + firstIndex - 1 > lastIndex])
		ifTrue: [^self errorNoSuchElement].
	result := self species new.
	firstIndex + fromIndex - 1 to: firstIndex + toIndex - 1 do:
		[:index | result addLast: (aBlock value: (array at: index))].
	^ result
! !
!OrderedCollection methodsFor: 'enumerating' stamp: 'jmv 2/5/2024 18:05:33' prior: 16917308 overrides: 16948182!
                with: otherCollection collect: twoArgBlock 
	"Collect and return the result of evaluating twoArgBlock with 
	corresponding elements from this collection and otherCollection."
	| result |
	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].
	result := self species new.
	1 to: self size do:
		[:index | result addLast: (twoArgBlock value: (self at: index)
									value: (otherCollection at: index))].
	^ result! !
!OrderedCollection methodsFor: 'enumerating' stamp: 'jmv 2/5/2024 18:05:44' prior: 16917326 overrides: 16948242!
   with: otherCollection with: thirdCollection collect: threeArgBlock
	"Collect and return the result of evaluating twoArgBlock with 
	corresponding elements from this collection and otherCollection."
	| result |
	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].
	result := self species new.
	1 to: self size do: [ :index |
		result addLast:
			(threeArgBlock
				value: (self at: index)
				value: (otherCollection at: index)
				value: (thirdCollection at: index) )].
	^ result! !
!OrderedCollection methodsFor: 'enumerating' stamp: 'jmv 2/5/2024 18:05:51' prior: 16917346 overrides: 16948284!
                               withIndexCollect: elementAndIndexBlock 
	"Just like with:collect: except that the iteration index supplies the second argument to the block. Override superclass in order to use addLast:, not at:put:."

	| newCollection |
	newCollection := self species new.
	firstIndex to: lastIndex do:
		[:index |
		newCollection addLast: (elementAndIndexBlock
			value: (array at: index)
			value: index - firstIndex + 1)].
	^ newCollection! !
!OrderedCollection class methodsFor: 'instance creation' stamp: 'jmv 2/5/2024 18:02:39' prior: 16917649 overrides: 16787772!
                     new
	^self basicNew setCollection: (Array new: 10)! !
!OrderedCollection class methodsFor: 'instance creation' stamp: 'jmv 2/5/2024 18:05:23' prior: 16917661 overrides: 16829586!
             newFrom: aCollection
	"Create a new collection containing all the elements from aCollection"

	^self new
		resetTo: 1;
		addAll: aCollection;
		yourself! !
!SortedCollection class methodsFor: 'instance creation' stamp: 'jmv 2/5/2024 18:06:11' prior: 16957106!
                            sortBlock: aBlock 
	"Answer an instance of me such that its elements are sorted according to 
	the criterion specified in aBlock."

	^ self new sortBlock: aBlock! !
!Dictionary methodsFor: 'accessing' stamp: 'jmv 2/5/2024 18:09:12' prior: 16848272!
       keysSortedSafely
	"Answer a sorted Collection containing the receiver's keys."
	| sortedKeys |
	sortedKeys := OrderedCollection new.
	self keysDo: [:each | sortedKeys addLast: each].
	sortedKeys sort:
		[ :x :y |  "Should really be use <obj, string, num> compareSafely..."
		((x isString and: [y isString])
			or: [x isNumber and: [y isNumber]])
			ifTrue: [x < y]
			ifFalse: [x class == y class
				ifTrue: [x printString < y printString]
				ifFalse: [x class name < y class name]]].
	^ sortedKeys! !
!SystemDictionary methodsFor: 'class names' stamp: 'jmv 2/5/2024 18:11:02' prior: 16962705!
            fillCaches
	"Fill cachedClassNames and cachedNonClassNames. Return an array with the calculated values."

	| classNames nonClassNames |
	classNames := IdentitySet new.
	nonClassNames := IdentitySet new.
	self keysAndValuesDo: [ :key :value |
		value isInMemory ifTrue: [
			"The key == value name test below addresses two separate issues:
				1) Obsolete classes, where key = #Foo and value name = 'AnObsoleteFoo'
				2) Aliases, i.e., Smalltalk at: #OtherName put: aClass"
			(value class isMeta and: [ key == value name ])
				ifTrue: [ classNames add: key ]
				ifFalse: [ nonClassNames add: key ] ] ].
	classNames := classNames asArray sort.
	nonClassNames := nonClassNames asArray sort.
	cachedClassNames := classNames.
	cachedNonClassNames := nonClassNames.
	^{ classNames. nonClassNames }! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 2/5/2024 18:10:08' prior: 16964976!
      allGlobalRefsWithout: classesAndMessagesPair
	"Answer a set of symbols that may be refs to Global names. 
	This method computes its result in the absence of specified classes and messages.
	Does not include references from a class to itself"

	| globalRefs absentClasses absentSelectors |
	globalRefs := IdentitySet new.
	absentClasses := classesAndMessagesPair first.
	absentSelectors := classesAndMessagesPair second.
	self classNames do: [ :cName |
		((absentClasses includes: cName)
					ifTrue: [#()]
					ifFalse: [{(self at: cName). (self at: cName) class}]) do: [ :cl | 
			(absentSelectors isEmpty
					ifTrue: [cl selectors]
					ifFalse: [cl selectors copyWithoutAll: absentSelectors]) do: [ :sel |
				"Include all capitalized symbols for good measure"
				self allSymbolsIn: (cl compiledMethodAt: sel) literals do: [ :m | 
					(m isSymbol and: [ m size > 0] and: [m first isUppercase]) ifTrue: [
						m = cl name ifFalse: [
							globalRefs add: m]].
					(m isVariableBinding) ifTrue:
						[m key ifNotNil: [
							m key = cl name ifFalse: [
								globalRefs add: m key]]]]]]].
	^ globalRefs! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 2/5/2024 18:10:14' prior: 16965022!
         allImplementedMessagesWithout: classesAndMessagesPair
	"Answer a Set of all the messages that are implemented in the system, computed in the absence of the supplied classes and messages.  Note this reports messages that are in the absent selectors set."
	| messages absentClasses |
	messages := IdentitySet new.
	absentClasses := classesAndMessagesPair first.
	self classNames do: [ :cName |
		((absentClasses includes: cName)
			ifTrue: [#()]
			ifFalse: [{(self at: cName). (self at: cName) class}]) do: [ :cl |
				messages addAll: cl selectors]].
	^ messages! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 2/5/2024 18:10:20' prior: 16965234!
               allPrimitiveMessages
	"Answer an OrderedCollection of all the methods that are implemented by 
	primitives."

	| aColl method | 
	aColl := OrderedCollection new.
	self allBehaviorsDo: [ :class |
		class selectorsDo: [ :sel | 
			method := class compiledMethodAt: sel.
			method primitive ~= 0 ifTrue: [
				aColl addLast: class name , ' ' , sel 
					, ' ' , method primitive printString]]].
	^aColl! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 2/5/2024 18:10:25' prior: 16965250!
                  allPrimitiveMethodsInCategories: aList
	"Answer an OrderedCollection of all the methods that are implemented by primitives in the given categories.  1/26/96 sw"

	| aColl method | 
	aColl := OrderedCollection new.
	self allBehaviorsDo: [ :aClass |
		(aList includes: (SystemOrganization categoryOfElement: aClass theNonMetaClass name asPlainString) asPlainString)
			ifTrue: [
				aClass selectorsDo: [ :sel | 
					method := aClass compiledMethodAt: sel.
					method primitive ~= 0
						ifTrue: [
							aColl addLast: aClass name , ' ' , sel 
								, ' ' , method primitive printString]]]].
	^ aColl

"Smalltalk allPrimitiveMethodsInCategories: #('Collections-Streams' 'Files-Streams' 'Files-Abstract' 'Files-Macintosh')"! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 2/5/2024 18:10:31' prior: 50333357!
           allSentMessagesWithout: classesAndMessagesPair
	"Answer the set of selectors which are sent somewhere in the system, 
	computed in the absence of the supplied classes and messages."

	| sent absentClasses absentSelectors |
	sent := IdentitySet new.
	absentClasses := classesAndMessagesPair first.
	absentSelectors := classesAndMessagesPair second.
	self classNames do: [ :cName | 
		((absentClasses includes: cName)
				ifTrue: [#()]
				ifFalse: [{(self at: cName). (self at: cName) class}]) do: [ :cl |
			 (absentSelectors isEmpty
					ifTrue: [cl selectors]
					ifFalse: [cl selectors copyWithoutAll: absentSelectors]) do: [ :sel |
				 "Include all sels, but not if sent by self"
				self allSymbolsIn: (cl compiledMethodAt: sel) literals do: [ :m |
					m == sel ifFalse: [sent add: m] ]]]].
		"The following may be sent without being in any literal frame"
		1 to: self specialSelectorSize do: [ :index | 
			sent add: (self specialSelectorAt: index)].
	self presumedSentMessages do: [ :sel | sent add: sel].
	^ sent! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 2/5/2024 18:11:09' prior: 16965575!
  unimplemented
	"Answer an Array of each message that is sent by an expression in a method but is not implemented by any object in the system."

	| all unimplemented entry |
	all := IdentitySet new.
	self allBehaviorsDo: [ :cl | cl selectorsDo: [ :aSelector | all add: aSelector]].

	unimplemented := IdentityDictionary new.
	self allBehaviorsDo: [:cl |
		 cl selectorsDo: [:sel |
			(cl compiledMethodAt: sel) messages do: [ :m |
				(all includes: m) ifFalse: [
					entry := unimplemented at: m ifAbsent: [Array new].
					entry := entry copyWith: (cl name, '>', sel).
					unimplemented at: m put: entry]]]].

	"remove some clutter from the result:"
	#(doPrimitive: primitiveFail success:) do: [ :sel |
		unimplemented removeKey: sel ifAbsent: nil].

	^ unimplemented! !
!OrderedDictionary methodsFor: 'private' stamp: 'jmv 2/5/2024 18:11:20' prior: 16917776 overrides: 16949229!
             init: n

	super init: n.
	orderedKeys := OrderedCollection new! !
!SharedQueue class methodsFor: 'instance creation' stamp: 'jmv 2/5/2024 18:15:07' prior: 16949784 overrides: 16787772!
       new
	"Answer a new instance of SharedQueue."

	^self basicNew initialize: 10! !
!Encoder methodsFor: 'initialization' stamp: 'jmv 2/5/2024 18:16:43' prior: 16854066!
                          init: aClass context: aContext notifying: req
	requestor := req.
	class := aClass.
	nTemps := 0.
	supered := false.
	self initScopeAndLiteralTables.
	"No Tweak Fields in Cuis"
	class variablesAndOffsetsDo: [ :variable "<String>" :offset "<Integer>" |
		scopeTable
			at: variable
			put: (offset >= 0
					ifTrue: [InstanceVariableNode new
								name: variable index: offset]
					ifFalse: [MaybeContextInstanceVariableNode new
								name: variable index: offset negated])].
	aContext ifNotNil: [
		| homeNode |
		homeNode := self bindTemp: Encoder doItInContextName.
		"0th temp = aContext passed as arg"
		aContext tempNames withIndexDo: [ :variable :index |
			variable ~= Encoder doItInContextName ifTrue: [
				scopeTable
					at: variable
					put: (MessageAsTempNode new
						receiver: homeNode
						selector: #namedTempAt:
						arguments: (Array with: (self encodeLiteral: index))
						precedence: 3
						from: self)]]].
	sourceRanges := Dictionary new.
	globalSourceRanges := OrderedCollection new.! !
!Encoder methodsFor: 'initialization' stamp: 'jmv 2/5/2024 18:16:50' prior: 16854101!
              initScopeAndLiteralTables

	scopeTable := StdVariables copy.
	litSet := StdLiterals copy.
	"comments can be left hanging on nodes from previous compilations.
	 probably better than this hack fix is to create the nodes afresh on each compilation."
	scopeTable do:
		[:varNode| varNode comment: nil].
	litSet do:
		[:varNode| varNode comment: nil].
	selectorSet := StdSelectors copy.
	litIndSet := IdentityDictionary new.
	literalStream := WriteStream on: (Array new: 32).
	addedSelectorAndMethodClassLiterals := false.
	optimizedSelectors := Set new! !
!Encoder methodsFor: 'initialization' stamp: 'jmv 2/5/2024 18:16:59' prior: 16854121!
  temps: tempVars literals: lits class: cl 
	"Decompile."

	supered := false.
	class := cl.
	nTemps := tempVars size.
	tempVars do: [:node | scopeTable at: node name put: node].
	literalStream := ReadStream on: lits.
	literalStream position: lits size.
	sourceRanges := Dictionary new.
	globalSourceRanges := OrderedCollection new.
! !
!FileIOAccessor methodsFor: 'private' stamp: 'jmv 2/5/2024 18:18:21' prior: 16861530!
                            entriesIn: parentEntryOrNil
	"
	Warning: Private. Only to be called from within FileMan.
	Accepts nil as argument, but behavior depends on platform.

Windows (nil means root)
FileIOAccessor default entriesIn: nil #(C:\ D:\)
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(\$Recycle.Bin \Config.Msi \Documents and Settings \gratMusic \hiberfil.sys \Intel \pagefile.sys \PerfLogs \Program Files \Program Files (x86) \ProgramData \Python27 \Recovery \SimuloHoy \System Volume Information \totalcmd \Users \Windows)

Linux  (nil means current dir, like '' and '.')
FileIOAccessor default entriesIn: nil #(Lots of stuff in current directory)
(FileIOAccessor default entriesIn: nil) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(/vmlinuz /boot /sbin /srv /lib /lib32 /tmp /sys /home /etc /initrd.img /bin /dev /opt /proc /lost+found /var /root /lib64 /mnt /usr /run /media)

MacOsX (nil means current dir, like '' and '.')
FileIOAccessor default entriesIn: nil #(/Volumes/SanDisk32-NTFS/CuisTest/2554-REVISAR-JuanVuletich-2015Oct21-16h40m-jmv.1.cs.st /Volumes/SanDisk32-NTFS/CuisTest/Cog.app /Volumes/SanDisk32-NTFS/CuisTest/Cog.app.tgz /Volumes/SanDisk32-NTFS/CuisTest/Cuis4.2-2553.changes /Volumes/SanDisk32-NTFS/CuisTest/Cuis4.2-2553.image /Volumes/SanDisk32-NTFS/CuisTest/CuisV4.sources)
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(/.dbfseventsd /.DocumentRevisions-V100 /.DS_Store /.file /.fseventsd /.hotfiles.btree /.Spotlight-V100 /.Trashes /.vol /Applications /bin /cores /dev /etc /home /installer.failurerequests /Library /net /Network /opt /private /sbin /System /tmp /Users /usr /var /Volumes)

	"
	| entries index done entryArray entry isDirectory lookIn |
	entries := OrderedCollection new.
	index := 1.
	done := false.
	lookIn := parentEntryOrNil ifNil: [''] ifNotNil: [parentEntryOrNil pathName].
	[done] whileFalse: [
		entryArray := self primFixedNameLookupEntryIn: lookIn asUtf8Bytes index: index.
		#badDirectoryPath == entryArray ifTrue: [
			^#()].
		entryArray == nil
			ifTrue: [done := true]
			ifFalse: [
				isDirectory := entryArray at: 4.
				entry := isDirectory ifTrue: [DirectoryEntry new] ifFalse: [FileEntry new].
				entry name: (entryArray at: 1) parent: parentEntryOrNil.
				entry updateFrom: entryArray entryInParent: index.
				entries addLast: entry ].
		index := index + 1].

	^entries asArray! !
!Form class methodsFor: 'examples' stamp: 'jmv 2/5/2024 18:17:15' prior: 16870352!
      toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors := `Color red wheel: 12`.
	color := 8.
	[ true ] whileTrue: [
		queue := OrderedCollection new.
		16 timesRepeat: [queue addLast: `-40@ -40`].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point := Sensor mousePoint.
		colr := colors atWrap: (color := color + 5).  "choose increment relatively prime to colors size"
		colr2 := colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point := point * 4 + Sensor mousePoint // 5.
			point := point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q := queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!IndentingListItemMorph methodsFor: 'accessing' stamp: 'jmv 2/5/2024 18:17:27' prior: 16876832!
                        beFullyExpandedAsPer: aBlock

	| allChildren |
	allChildren := OrderedCollection new.
	self recursiveAddTo: allChildren.
	allChildren do:
		[:each |
			| shouldExpandEach |
			shouldExpandEach := each canExpand and: [aBlock value: each].
			shouldExpandEach ~= each isExpanded ifTrue:
				[
					each toggleExpandedState.
					each beFullyExpandedAsPer: aBlock
				]
		]! !
!TextComposition methodsFor: 'composition' stamp: 'jmv 2/5/2024 18:17:33' prior: 16979538!
               recomposeFrom: startArg to: stopArg delta: delta
	"Recompose this text.  The altered portion is between start and stop.
	Recomposition may continue to the end of the text, due to a ripple effect.
	Delta is the amount by which the current text is longer than it was
	when its current lines were composed.
	Expand the requested interval to include whole paragraphs because there could be paragraph attributes."
	| intervalToFix start stop startLine newLines partialMaxRightX |
	"Have to recompose line above in case a word-break was affected."
	intervalToFix := model actualContents encompassParagraph: (startArg to: stopArg).
	start := intervalToFix first.
	stop := intervalToFix last.
	startLine := (self lineIndexFor: start) - 1 max: 1.
	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]
		whileTrue: [startLine := startLine - 1].  "Find leftmost of line pieces"
	newLines := OrderedCollection new.
	1 to: startLine-1 do: [:i | newLines addLast: (lines at: i)].
	partialMaxRightX := self composeLinesFrom: (lines at: startLine) first to: stop delta: delta
			into: newLines priorLines: lines
			atY: (lines at: startLine) top.
	"Partial recomposition computes actual right border only of recompsed text,
	so, it could make maxRightX larger but not smaller.
	This means that if the longest line gets shortened, we won't know, and maxRightX will be erroneously large"
	maxRightX := maxRightX max: partialMaxRightX! !
!TestResult methodsFor: 'accessing' stamp: 'jmv 2/5/2024 18:17:44' prior: 16976027!
       tests

	^ OrderedCollection new
		addAll: self passed;
		addAll: self errors;
		addAll: self failures;
		yourself
			! !
!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 2/5/2024 18:18:27' prior: 50339385!
                     printSpaceAnalysis: threshold on: aStream
	"Warning!!
	This is most likely wrong. It was written for 32 bit V3 images.
	Please take a look at #spaceForInstancesOf:
	Review both methods, and any other one that might be related.
	"
	"
	SpaceTally new printSpaceAnalysis: 1 on:(FileStream forceNewFileNamed: 'STspace.text')
	"
	"sd-This method should be rewrote to be more coherent within the rest of the class 
	ie using preAllocate and spaceForInstanceOf:"

	"If threshold > 0, then only those classes with more than that number
	of instances will be shown, and they will be sorted by total instance space.
	If threshold = 0, then all classes will appear, sorted by name."

	| codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |
	Smalltalk garbageCollect.
	totalCodeSpace := totalInstCount := totalInstSpace := n := 0.
	results := OrderedCollection new.
	'Taking statistics...'
		displayProgressAt: Sensor mousePoint
		from: 0 to: Smalltalk classNames size
		during: [ :barBlock |
			Smalltalk allClassesDo: [ :cl |
				codeSpace := cl spaceUsed.
				barBlock value: (n := n+1).
				Smalltalk garbageCollectMost.
				instCount := cl instanceCount.
				instSpace := 8 * instCount. "Object headers""Warning: The 3rd header word for big objects is not considered!!"
				cl isVariable
					ifTrue: [
						eltSize := cl isBytes ifTrue: [1] ifFalse: [4].
						cl allInstancesDo: [ :x |
							instSpace := instSpace + (x basicSize * eltSize)]]
					ifFalse: [instSpace := instSpace + (cl instSize * instCount * 4)].
				results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).
				totalCodeSpace := totalCodeSpace + codeSpace.
				totalInstCount := totalInstCount + instCount.
				totalInstSpace := totalInstSpace + instSpace]].
	totalPercent := 0.0.

	aStream timeStamp.
	aStream
		nextPutAll: ('Class' padded: #right to: 30 with: $ );
		nextPutAll: ('code space' padded: #left to: 12 with: $ );
		nextPutAll: ('# instances' padded: #left to: 12 with: $ );
		nextPutAll: ('inst space' padded: #left to: 12 with: $ );
		nextPutAll: ('percent' padded: #left to: 8 with: $ ); newLine.

	threshold > 0 ifTrue: [
		"If inst count threshold > 0, then sort by space"
		results := (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])
			asArray sort: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].

	results do: [:s |
		aStream
			nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );
			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );
			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );
			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).
		percent := s spaceForInstances*100.0/totalInstSpace.
		totalPercent := totalPercent + percent.
		percent >= 0.1 ifTrue: [
			percent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil ].
		aStream newLine].

	aStream
		newLine; nextPutAll: ('Total' padded: #right to: 30 with: $ );
		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ ).
	totalPercent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil! !
!SpaceTally methodsFor: 'class analysis' stamp: 'jmv 2/5/2024 18:17:48' prior: 16958336!
           preAllocateResultsFor: classes

	results := OrderedCollection new.
	classes do: [:cl | results add: (SpaceTallyItem analyzedClassName: cl name)].
	results := results asArray.
! !
!SHParserST80 methodsFor: 'parse support' stamp: 'jmv 2/5/2024 18:19:49' prior: 16941890!
                   pushArgument: aString 
	(arguments at: blockDepth ifAbsentPut: [OrderedCollection new]) 
		add: aString! !
!SHParserST80 methodsFor: 'parse support' stamp: 'jmv 2/5/2024 18:19:57' prior: 16941896!
                           pushTemporary: aString 
	(temporaries at: blockDepth ifAbsentPut: [OrderedCollection new]) 
		add: aString! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 2/5/2024 18:19:42' prior: 16942277!
parse: isAMethod 
	"Parse the receiver's text. If isAMethod is true
    then treat text as a method, if false as an
    expression with no message pattern"

	| continue prevSourcePosition |
	self initializeInstanceVariables.
	sourcePosition := 1.
	arguments := Dictionary new.
	temporaries := Dictionary new.
	blockDepth := bracketDepth := braceDepth := 0.
	blockDepths := OrderedCollection with: blockDepth.
	blockDepthsStartIndexes := OrderedCollection with: sourcePosition.
	ranges ifNil: [ ranges := OrderedCollection new] ifNotNil: [ ranges reset].
	errorBlock := [^false].
	[
		self scanNext.
		isAMethod 
			ifTrue: [
				self parseMessagePattern.
				self parsePragmaSequence].
		self parseMethodTemporaries.
		isAMethod ifTrue: [self parsePragmaSequence].
		"Iterate once for methods, but pontentially several times for workspaces
		(to recover after errors, for possible good next lines or chunks)"
		continue := true.
		[ continue ] whileTrue: [
			prevSourcePosition := sourcePosition.
			self parseStatementList.
			continue := sourcePosition > prevSourcePosition.
			isAMethod
				ifTrue: [
					"Only if we are parsing a method, consider everything after this point as error."
					currentToken ifNotNil: [ self error ].
					continue := false]
				ifFalse: [
					sourcePosition > source size ifTrue: [continue := false]]].
	] ensure: [errorBlock := nil].
	^true! !
!InlineMethod methodsFor: 'temporaries declaration - private' stamp: 'jmv 2/5/2024 18:20:40' prior: 16877258!
            renameTemporariesIfNeeded: temporariesToDeclare accordingToNode: aMethodOrBlockNode of: aSenderMethod

	"If a temporary to declare already exists in the scope, a new fresh name
	will be found for it. The method returns an OrderedCollection of (variableNode -> newVariableName)
	replacements. If the variable does not need a rename, it will still be added to the collection.
	This method also adds the new name to the map that tracks temporaries
	names in scope for the requested method or block node across the whole refactoring - Fernando"

	| alreadyDeclaredTemporaries newTemporaries |

	newTemporaries := OrderedCollection new.
	alreadyDeclaredTemporaries := self declaredTemporariesFor: aMethodOrBlockNode ofSender: aSenderMethod.
	temporariesToDeclare do: [:temporary |
		| finalTemporaryName index |
		finalTemporaryName := temporary name.
		index := 1.
		[alreadyDeclaredTemporaries includes: finalTemporaryName] whileTrue: [
			finalTemporaryName := temporary name, index asString.
			index := index + 1.
		].
		alreadyDeclaredTemporaries add: finalTemporaryName.
		newTemporaries add: (temporary -> finalTemporaryName).
	].

	^newTemporaries.! !
!InlineMethod methodsFor: 'initialization' stamp: 'jmv 2/5/2024 18:20:33' prior: 50347733!
 methodToInline: aCompiledMethod usages: aCollectionOfMesageNodeReferences removingMethod: removingMethod

	methodToInline := aCompiledMethod.
	messageSendsToInline := aCollectionOfMesageNodeReferences.
	replacementsByMessageSend := Dictionary new.
	temporariesDeclarationsByNode := Dictionary new.
	temporariesToDeclareByInsertionPoint := Dictionary new.
	updatedSendersCode := Dictionary new.
	methodNodeToInline := methodToInline notOptimizedMethodNode.
	implementorCompleteSourceRanges := methodNodeToInline completeSourceRanges.
	removeMethod := removingMethod.! !

SortedCollection class removeSelector: #new:sortBlock:!

!methodRemoval: SortedCollection class #new:sortBlock: stamp: 'Install-6209-newColon-removeManySenders-JuanVuletich-2024Feb06-09h22m-jmv.001.cs.st 2/8/2024 12:44:36'!
new: anInteger sortBlock: aBlock 
	"Answer an instance of me such that its elements are sorted according to 
	the criterion specified in aBlock."

	^(self new: anInteger) sortBlock: aBlock!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6209-newColon-removeManySenders-JuanVuletich-2024Feb06-09h22m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6208] on 6 February 2024 at 9:45:51 am'!
!Set class methodsFor: 'instance creation' stamp: 'jmv 2/6/2024 09:44:16' overrides: 16829586!
                       newFrom: aCollection
	"Create a new collection containing all the elements from aCollection"

	^(self newWithRoomForMoreThan: aCollection size)
		addAll: aCollection;
		yourself! !
!WeakRegistry class methodsFor: 'instance creation' stamp: 'jmv 2/6/2024 09:44:01' overrides: 16829586!
   newFrom: aCollection
	"Create a new collection containing all the elements from aCollection"

	^(self newWithRoomForMoreThan: aCollection size)
		addAll: aCollection;
		yourself! !
!WeakRegistry class methodsFor: 'instance creation' stamp: 'jmv 2/6/2024 09:41:03'!
                       newWithRoomForMoreThan: n
	| registry |
	registry := super new initialize: n.
	WeakArray addWeakDependent: registry.
	^registry! !
!WeakRegistry methodsFor: 'initialization' stamp: 'jmv 2/6/2024 09:31:15' prior: 17006042!
  initialize: n
	valueDictionary := WeakIdentityKeyDictionary newWithRoomForMoreThan: n.
	accessLock := Semaphore forMutualExclusion! !
!WeakRegistry class methodsFor: 'instance creation' stamp: 'jmv 2/6/2024 09:31:33' prior: 17006054 overrides: 16787772!
  new
	^self newWithRoomForMoreThan: 5! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'jmv 2/6/2024 09:31:47' prior: 16842220!
                    initCachedState
	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  
	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)
	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"
	"
	DataStream initCachedState
	"

	| refTypes t |
	refTypes := OrderedCollection new.
	t := TypeMap := Dictionary newWithRoomForMoreThan: 80. "sparse for fast hashing"

	t at: UndefinedObject put: 1.   refTypes add: 0.
	t at: True put: 2.   refTypes add: 0.
	t at: False put: 3.   refTypes add: 0.
	t at: SmallInteger put: 4.	 refTypes add: 0.
	t at: String put: 5.   refTypes add: 1.
	t at: Symbol put: 6.   refTypes add: 1.
	t at: ByteArray put: 7.   refTypes add: 1.
	t at: Array put: 8.   refTypes add: 1.
	"(type ID 9 is for arbitrary instances of any class, cf. typeIDFor:)"
		refTypes add: 1.
	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"
		refTypes add: 0.
	t at: Bitmap put: 11.   refTypes add: 1.

	t at: Metaclass put: 12.   refTypes add: 0.
	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."
		refTypes add: 1.

	t at: Float put: 14.  refTypes add: 1.
	t at: BoxedFloat64 put: 14.
	t at: SmallFloat64 put: 14.

	"15: Deprecated compact Rects."
		refTypes add: 1.

	"type ID 16 is an instance with short header.  See beginInstance:size:"
		refTypes add: 1.

	t at: String put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"
	t at: WordArray put: 18.  refTypes add: 1.	"bitmap-like"
	"t at: WordArrayForSegment put: 19."  refTypes add: 1.		"bitmap-like"
	t at: Float32Array put: 20.  refTypes add: 1.	"And all other word arrays, both 16-bit and 32-bit.  See methods in ArrayedCollection.  Overridden in SoundBuffer."
	"For all classes that are like WordArrays, store them the way ColorArray is stored.  As bits, and able to change endianness."
	Smalltalk do: [:cls |
		cls isInMemory ifTrue: [
			cls isBehavior ifTrue: [
				cls isPointers not & cls isVariable & cls isWords ifTrue: [
					(t includesKey: cls) ifFalse: [t at: cls put: 20]]]]].

	t at: CompiledMethod put: 21.  refTypes add: 1.	"special creation method"

	t at: Character put: 22. refTypes add: 0.

	t at: UnicodeString put: 23.   refTypes add: 1.
	t at: UnicodeSymbol put: 24.   refTypes add: 1.

	"t at:  put: 25.  refTypes add: 0."
	ReferenceTypes := refTypes.		"save it"! !
!ReferenceStream methodsFor: 'writing' stamp: 'jmv 2/6/2024 09:32:04' prior: 16937516 overrides: 16842108!
                  reset
	"PRIVATE -- Reset my internal state.
	   11/15-17/92 jhm: Added transients and fwdRefEnds.
	   7/11/93 sw: Give substantial initial sizes to avoid huge time spent growing.
	   9/3/93 sw: monster version for Sasha"

	super reset.
	references := IdentityDictionary newWithRoomForMoreThan: 4096 * 5.
"	objects := IdentityDictionary newWithRoomForMoreThan: 4096 * 5.
	fwdRefEnds := IdentityDictionary new.
"
	blockers ifNil: [blockers := IdentityDictionary new].
 ! !
!ReferenceStream methodsFor: 'writing' stamp: 'jmv 2/6/2024 09:32:11' prior: 16937540 overrides: 16842123!
                              setStream: aStream
	"PRIVATE -- Initialization method."

	super setStream: aStream.
	references := IdentityDictionary newWithRoomForMoreThan: 4096 * 5.
	objects := IdentityDictionary newWithRoomForMoreThan: 4096 * 5.
	fwdRefEnds := IdentityDictionary new.
	skipping := IdentitySet new.
	blockers ifNil: [blockers := IdentityDictionary new].	"keep blockers we just passed in"
! !
!ReferenceStream methodsFor: 'writing' stamp: 'jmv 2/6/2024 09:32:17' prior: 16937553 overrides: 16842134!
                          setStream: aStream reading: isReading
	"PRIVATE -- Initialization method."

	super setStream: aStream reading: isReading.
	"isReading ifFalse: [  when we are sure"
	references := IdentityDictionary newWithRoomForMoreThan: 4096 * 5.
	isReading ifTrue: [
		objects := IdentityDictionary newWithRoomForMoreThan: 4096 * 5.
		skipping := IdentitySet new.
		fwdRefEnds := IdentityDictionary new].
	blockers ifNil: [blockers := IdentityDictionary new].	"keep blockers we just passed in"
! !
!ReferenceStream methodsFor: 'statistics' stamp: 'jmv 2/6/2024 09:32:24' prior: 16937789!
  statisticsOfRefs
	"Analyze the information in references, the objects being written out"

	| parents n kids nm ownerBags tallies owners objParent normalReferences |
	normalReferences := self references.	"Exclude unrealized weaks"
	parents := IdentityDictionary newWithRoomForMoreThan: normalReferences size * 2.
	n := 0.
	'Finding Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:
		[ :parent | barBlock value: (n := n+1).
		kids := parent class isFixed
			ifTrue: [(1 to: parent class instSize) collect: [:i | parent instVarAt: i]]
			ifFalse: [parent class isBits ifTrue: [Array new]
					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt: i]]].
		(kids select: [:x | normalReferences includesKey: x])
			do: [:child | parents at: child put: parent]]].
	ownerBags := Dictionary new.
	tallies := Bag new.
	n := 0.
	'Tallying Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:  "For each class of obj, tally a bag of owner classes"
		[ :obj | barBlock value: (n := n+1).
		nm := obj class name.
		tallies add: nm.
		owners := ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].
		(objParent := parents at: obj ifAbsent: nil) ifNotNil: [
			owners add: objParent class name]]].
	^ String streamContents: [ :strm | 
		tallies sortedCounts do: [ :assn |
			n := assn key.  nm := assn value.
			owners := ownerBags at: nm.
			strm newLine; nextPutAll: nm; space; print: n.
			owners size > 0 ifTrue: [
				strm newLine; tab; print: owners sortedCounts]]]! !
!VariableNode class methodsFor: 'class initialization' stamp: 'jmv 2/6/2024 09:39:13' prior: 16997889 overrides: 16918959!
                          initClassCachedState
	"
	VariableNode initialize. Decompiler initialize
	"
	| encoder |
	encoder := Encoder new.
	StdVariables := Dictionary newWithRoomForMoreThan: 16.
	encoder
		fillDict: StdVariables
		with: VariableNode
		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )
		to: (Array with: LdSelf with: LdThisContext with: LdSuper)
				, (Array with: LdNil with: LdFalse with: LdTrue).
	StdSelectors := Dictionary newWithRoomForMoreThan: 64.
	encoder
		fillDict: StdSelectors
		with: SpecialSelectorNode
		mapping: ((1 to: Smalltalk specialSelectorSize) collect: 
							[:i | Smalltalk specialSelectorAt: i])
		to: (1 to: Smalltalk specialSelectorSize) asArray.
	StdLiterals := LiteralDictionary newWithRoomForMoreThan: 16.
	encoder
		fillDict: StdLiterals
		with: LiteralNode
		mapping: #(-1 0 1 2 )
		to: (LdMinus1 to: LdMinus1 + 3).
	encoder initScopeAndLiteralTables.

	NodeNil := encoder encodeVariable: 'nil'.
	NodeTrue := encoder encodeVariable: 'true'.
	NodeFalse := encoder encodeVariable: 'false'.
	NodeSelf := encoder encodeVariable: 'self'.
	NodeThisContext := encoder encodeVariable: 'thisContext'.
	NodeSuper := encoder encodeVariable: 'super'! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 2/6/2024 09:32:38' prior: 16906889!
          removeAllMorphsIn: aCollection
	"greatly speeds up the removal of *lots* of submorphs"
	| set |
	aCollection isEmpty ifTrue: [ ^self ].
	set := IdentitySet newWithRoomForMoreThan: aCollection size * 4 // 3.
	aCollection do: [ :each | each owner == self ifTrue: [ set add: each ]].
	set isEmpty ifTrue: [ ^self ].
	set do: [ :m | m privateOwner: nil ].
	submorphs := submorphs reject: [ :each | set includes: each].
	set do: [ :m | self removedMorph: m ].
	self someSubmorphPositionOrExtentChanged.
	self redrawNeeded.! !
!ClosureScanner methodsFor: 'private - closure scan storage' stamp: 'SqR 7/16/2015 05:54' prior: 16822414!
            newNodes

	^IdentitySet newWithRoomForMoreThan: self storagePreallocatedCapacity! !
!ClosureScanner methodsFor: 'private - depth first scan queue' stamp: 'sqr 12/23/2013 22:30' prior: 16822454!
                              newScanQueueSegment
	"Segment the scan queue, otherwise the GC will be forced to scan the whole
	queue every time (obviously, the scan queue will be in the remember table)"

	| newScanQueue |
	newScanQueue := OrderedCollection ofSize: self scanQueueSegmentTargetSize.
	newScanQueue resetTo: 1.
	^newScanQueue! !

WeakRegistry class removeSelector: #new:!

!methodRemoval: WeakRegistry class #new: stamp: 'Install-6210-Set-Dictionary-newColon-cleanup-JuanVuletich-2024Feb06-09h30m-jmv.001.cs.st 2/8/2024 12:44:36'!
new: n
	| registry |
	registry := super new initialize: n.
	WeakArray addWeakDependent: registry.
	^registry!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6210-Set-Dictionary-newColon-cleanup-JuanVuletich-2024Feb06-09h30m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6208] on 6 February 2024 at 9:49:53 am'!
!String class methodsFor: 'instance creation' stamp: 'jmv 2/4/2024 21:05:06' overrides: 16787780!
                       new: sizeRequested 
	"Answer an initialized instance of this class with the number of indexable
	variables specified by the argument, sizeRequested."

	^ (self basicNew: sizeRequested) initialize  ! !
!ArrayedCollection class methodsFor: 'instance creation' stamp: 'jmv 2/5/2024 17:43:28' overrides: 16787780!
          new: sizeRequested
	"Answer an initialized instance of this class with the number of indexable
	variables specified by the argument, sizeRequested."

	^ (self basicNew: sizeRequested) initialize  ! !
!Bag class methodsFor: 'instance creation' stamp: 'jmv 2/5/2024 18:07:20' prior: 16786337 overrides: 16787772!
         new
	^ self basicNew setContents: self contentsClass new! !
!SharedQueue class methodsFor: 'instance creation' stamp: 'jmv 2/5/2024 18:32:59' prior: 16949790 overrides: 16787780!
             new: size

	self error: 'Instances of ', self name, ' can not be created with the #new: message. Just call #new instead.'! !

MethodDictionary class removeSelector: #new:!

!methodRemoval: MethodDictionary class #new: stamp: 'Install-6211-removeMisleadingImplementations-newColon-JuanVuletich-2024Feb06-09h45m-jmv.001.cs.st 2/8/2024 12:44:36'!
new: nElements
	"Create a Dictionary large enough to hold nElements without growing.
	Note that the basic size must be a power of 2.
	It is VITAL (see grow) that size gets doubled if nElements is a power of 2"
	| size |
	size := 1 bitShift: nElements highBit.
	^ (self basicNew: size) init: size!

Set class removeSelector: #new:!

!methodRemoval: Set class #new: stamp: 'Install-6211-removeMisleadingImplementations-newColon-JuanVuletich-2024Feb06-09h45m-jmv.001.cs.st 2/8/2024 12:44:36'!
new: nElements
	"Create a Set large enough to hold nElements without growing"
	^ super new init: (self sizeFor: nElements)!

Bag class removeSelector: #new:!

!methodRemoval: Bag class #new: stamp: 'Install-6211-removeMisleadingImplementations-newColon-JuanVuletich-2024Feb06-09h45m-jmv.001.cs.st 2/8/2024 12:44:36'!
new: nElements
	^ super new setContents: (self contentsClass newWithRoomForMoreThan: nElements)!

OrderedCollection class removeSelector: #new:!

!methodRemoval: OrderedCollection class #new: stamp: 'Install-6211-removeMisleadingImplementations-newColon-JuanVuletich-2024Feb06-09h45m-jmv.001.cs.st 2/8/2024 12:44:36'!
new: anInteger 
	"If a subclass adds fields, then it is necessary for that subclass to
	reimplement new:."

	^ super new setCollection: (Array new: anInteger)!

Heap class removeSelector: #new:!

!methodRemoval: Heap class #new: stamp: 'Install-6211-removeMisleadingImplementations-newColon-JuanVuletich-2024Feb06-09h45m-jmv.001.cs.st 2/8/2024 12:44:36'!
new: n
	^super new setCollection: (Array new: n)!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6211-removeMisleadingImplementations-newColon-JuanVuletich-2024Feb06-09h45m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6208] on 6 February 2024 at 9:50:40 am'!
!Collection class methodsFor: 'instance creation' stamp: 'jmv 2/5/2024 18:35:18' overrides: 16787780!
        new: size

	self error: 'Instances of ', self name, ' can not be created with the #new: message. Just call #new instead.'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6212-ErrorOnMisleadingCallsTo-newColon-JuanVuletich-2024Feb06-09h49m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6211] on 5 February 2024 at 6:57:27 pm'!
!ArrayedCollection methodsFor: 'math functions' stamp: 'jmv 2/5/2024 18:54:09' overrides: 16948574!
      derivative
	| displaced answer |
	displaced := self class new: self size.
	displaced replaceFrom: 2 to: self size with: self startingAt: 1.
	displaced at: 1 put: self first - self first.	"Some reasonable zero"
	answer := self copy.
	answer -= displaced.
	^answer! !
!ArrayedCollection methodsFor: 'math functions' stamp: 'jmv 2/5/2024 18:54:42' overrides: 16948585!
                  incrementFraction
	"
	#(10 12.5 15 20) incrementFraction
	"
	| displaced answer |
	displaced := self class new: self size.
	displaced replaceFrom: 2 to: self size with: self startingAt: 1.
	displaced at: 1 put: self first.
	answer := self copy.
	answer -= displaced.
	^answer / displaced! !
!ArrayedCollection methodsFor: 'math functions' stamp: 'jmv 2/5/2024 18:54:52' overrides: 16948597!
                         integral
	| answer |
	answer := self copy.
	2 to: answer size do: [ :i |
		answer at: i put: (answer at: i) + (answer at: i-1) ].
	^answer! !
!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 2/5/2024 18:52:28' prior: 16947529!
                    copyAfter: anElement
	"Answer a copy of the receiver from after the first occurence
	of anElement up to the end. If no such element exists, answer 
	an empty copy."

	^ self allButFirst: (self indexOf: anElement ifAbsent: [^ self species new ])! !
!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 2/5/2024 18:52:24' prior: 16947540!
          copyAfterLast: anElement
	"Answer a copy of the receiver from after the last occurence
	of anElement up to the end. If no such element exists, answer 
	an empty copy."

	^ self allButFirst: (self lastIndexOf: anElement ifAbsent: [^ self species new ])! !

SequenceableCollection removeSelector: #integral!

!methodRemoval: SequenceableCollection #integral stamp: 'Install-6213-MathFunctionMethods-moveToArrayedCollection-YourName-2024Feb05-18h49m-j1mv.001.cs.st 2/8/2024 12:44:36'!
integral
	| answer |
	answer := self copy.
	2 to: answer size do: [ :i |
		answer at: i put: (answer at: i) + (answer at: i-1) ].
	^answer!

SequenceableCollection removeSelector: #derivative!

!methodRemoval: SequenceableCollection #derivative stamp: 'Install-6213-MathFunctionMethods-moveToArrayedCollection-YourName-2024Feb05-18h49m-j1mv.001.cs.st 2/8/2024 12:44:36'!
derivative
	| displaced answer |
	displaced := self class new: self size.
	displaced replaceFrom: 2 to: self size with: self startingAt: 1.
	displaced at: 1 put: self first - self first.	"Some reasonable zero"
	answer := self copy.
	answer -= displaced.
	^answer!

SequenceableCollection removeSelector: #incrementFraction!

!methodRemoval: SequenceableCollection #incrementFraction stamp: 'Install-6213-MathFunctionMethods-moveToArrayedCollection-YourName-2024Feb05-18h49m-j1mv.001.cs.st 2/8/2024 12:44:36'!
incrementFraction
	"
	#(10 12.5 15 20) incrementFraction
	"
	| displaced answer |
	displaced := self class new: self size.
	displaced replaceFrom: 2 to: self size with: self startingAt: 1.
	displaced at: 1 put: self first.
	answer := self copy.
	answer -= displaced.
	^answer / displaced!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6213-MathFunctionMethods-moveToArrayedCollection-YourName-2024Feb05-18h49m-j1mv.001.cs.st----!

'From Cuis6.3 [latest update: #6213] on 6 February 2024 at 12:01:40 pm'!
!Array methodsFor: 'converting' stamp: 'BAP 2/6/2024 12:01:10' prior: 16782777!
                            evalStrings
	   "Allows you to construct literal arrays.
    #(true false nil '5@6' 'Set new' '''text string''') evalStrings
    gives an array with true, false, nil, a Point, a Set, and a String
    instead of just a bunch of Symbols"

    ^ self collect: [:each |  | it |
        it := each.
        each == #true ifTrue: [it := true].
		      each == #false ifTrue: [it := false].
        each == #nil ifTrue: [it := nil].
        each isString ifTrue: [
		it := Compiler evaluate: each].
        each class == Array ifTrue: [it := it evalStrings].
        it]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6214-evalStrings-fix-BarryPerryman-2024Feb06-12h01m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6203] on 4 February 2024 at 6:22:13 pm'!
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'bp 2/4/2024 18:16:16' prior: 16925450!
     scrollToShow: aRectangle
	"scroll to include as much of aRectangle as possible, where aRectangle is in the scroller's local space.
	This means that 0@0 is scrolling all the way top and all the way left"
	| deltaX deltaY |
	deltaX := (aRectangle amountToTranslateWithin: (`0@0` extent: self viewableExtent)) x.
	deltaY := (aRectangle amountToTranslateWithin: (`0@0` extent: self viewableExtent)) y.
	(deltaX ~= 0 or: [deltaY ~= 0]) ifTrue: [
		self scrollBy: deltaX@deltaY ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6215-FixHorizontalScrolling-BernhardPieber-2024Feb04-18h16m-bp.001.cs.st----!

'From Cuis6.3 [latest update: #6215] on 6 February 2024 at 12:59:05 pm'!
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 2/6/2024 12:55:22' prior: 16881640!
                             fit
	"Adjust my bounds to fit the text.
	Required after the text changes,
	or if wrapFlag is true and the user attempts to change the extent."

	| newExtent newHeight newWidth oldExtent |
	(owner is: #ScrollPane) ifFalse: [
		^self ].

	newWidth := extent x.
	"Adjust width only if we don't wrap text to own width!!"
	wrapFlag ifFalse: [
		newWidth := self textComposition usedWidth + 3 max: 9 ].
	newHeight := self textComposition usedHeight max: FontFamily defaultLineSpacing + 2.
	newExtent := newWidth @ newHeight.
	extent = newExtent 
		ifTrue: [
			"Too conservative: only text composition (because of changes in text or styles, etc)
			should cause invalidation.
			Try to avoid calling #fit unless needed."
			self redrawNeeded ]
		ifFalse: [
			oldExtent := extent.
			extent := newExtent.
			self extentChanged: oldExtent.
			owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
			self redrawNeeded ].

	owner innerHeight: newExtent y.! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 2/6/2024 12:58:46' prior: 16881763!
          updateFromTextComposition
	"A change has taken place in my textComposition, as a result of editing and I must be updated. "

	textComposition ifNotNil: [
		wrapFlag ifFalse: [
			textComposition
				initialize;
				extentForComposing: self extentForComposing;
				composeAll ].
		editor storeSelectionInComposition.
		needsFit ifTrue: [
			self fit.
			needsFit := false ]].

	(owner is: #ScrollPane) ifTrue: [
		owner
			updateScrollBarsBounds;
			setScrollDeltas ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6216-NonWrappedText-fixes-JuanVuletich-2024Feb06-12h57m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6216] on 6 February 2024 at 4:47:33 pm'!
!Collection class methodsFor: 'instance creation' stamp: 'jmv 2/6/2024 16:06:44' prior: 50349704 overrides: 16787780!
       new: size
	"Redefined in subclasses as appropriate."

	self error: 'Instances of ', self name, ' can not be created with the #new: message. Better call #new instead.'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6217-tweak-JuanVuletich-2024Feb06-16h46m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6217] on 7 February 2024 at 3:53:32 pm'!
!TaskbarMorph methodsFor: 'geometry' stamp: 'jmv 2/7/2024 15:41:51' overrides: 16904848!
basicDisplayBounds

	self visible ifFalse: [ ^nil ].
	^self morphPosition extent: extent! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 2/7/2024 15:45:52' prior: 16966739!
aboutThisSystem 
	"Identify software version"

	Utilities defaultTextEditorContents edit.
	^ self inform: self systemInformationString! !
!Transcript class methodsFor: 'preferred protocol' stamp: 'jmv 2/7/2024 15:50:51' prior: 16987903!
                   clear

	accessSemaphore critical: [
		"Having at least one entry simplifies handling of the entries circular collection"
		firstIndex := 1.
		lastIndex := 0.
		entries atAllPut: nil.
		Smalltalk systemInformationString linesDo: [ :l |
			lastIndex := lastIndex + 1.
			entries at: lastIndex put: l ].
		unfinishedEntry reset.
		lastDisplayPosition := 0.
		
		logToFile ifTrue: [
			DirectoryEntry logsDirectory // self filename forceWriteStreamDo: [ :stream |
				stream nextPutAll: 'Transcript log started: '.
				DateAndTime now printOn: stream.
				stream
					newLine;
					nextPutAll: '------------------------------------------------------------------------';
					newLine ]]].
	self display! !
!WorldMorph methodsFor: 'defaul desktop' stamp: 'jmv 2/7/2024 15:43:18' prior: 17007727!
          recreateDefaultDesktop
	"
	self runningWorld recreateDefaultDesktop
	"
	self whenUIinSafeState: [
		self hideTaskbar.
		(submorphs
			select: [ :ea | ea class == SystemWindow or: [ea class == TranscriptWindow]])
				do: [ :ea | ea delete ].
		Theme current useTaskbar ifTrue: [self showTaskbar].
		Transcript clear.
		TranscriptWindow openTranscript
			resizeBottomLeft
	].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6218-AboutThisSystem-defaultDesktop-tweaks-JuanVuletich-2024Feb07-15h52m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6218] on 7 February 2024 at 4:36:58 pm'!
!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 2/7/2024 16:13:49'!
                            copyBlank: requestedSize
	"Answer an instance like me, of size n, but without content.
	All elements may be nil, zero or some other default value if needed."

	^self species new: requestedSize! !
!OrderedCollection methodsFor: 'copying' stamp: 'jmv 2/7/2024 16:14:31' overrides: 50350016!
                               copyBlank: requestedSize
	"Answer an instance like me, of size n, but without content.
	All entries are nil."

	^self species basicNew initializeOfSize: requestedSize! !
!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 2/7/2024 16:12:32' prior: 50347423!
                        copyFrom: start count: n
	"Answer a copy of a subset of the receiver, starting from element at 
	index start and of size n."

	^(self copyBlank: n)
		replaceFrom: 1
		to: n
		with: self
		startingAt: start! !
!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 2/7/2024 16:14:06' prior: 50347433!
                 copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize |
	newSize := stop - start + 1 max: 0.
	^(self copyBlank: newSize)
		replaceFrom: 1
		to: newSize
		with: self
		startingAt: start! !
!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 2/7/2024 16:14:40' prior: 50347446!
    copyReplaceFrom: start to: stop with: replacementCollection 
	"Answer a copy of the receiver satisfying the following conditions: 
	+ stop is less than start, then this is an insertion; stop should be exactly start-1, 
	+ start = 1 means insert before the first character,
	+ start = size+1 means append after last character. 
	+ Otherwise, this is a replacement; start and stop have to be within the receiver's bounds."

	| newSequenceableCollection newSize endReplacement |
	newSize := self size - (stop - start + 1) + replacementCollection size.
	endReplacement := start - 1 + replacementCollection size.
	newSequenceableCollection := self copyBlank: newSize.
	start > 1 ifTrue:[
		newSequenceableCollection
			replaceFrom: 1
			to: start - 1
			with: self
			startingAt: 1].
	start <= endReplacement ifTrue:[
		newSequenceableCollection
			replaceFrom: start
			to: endReplacement
			with: replacementCollection
			startingAt: 1].
	endReplacement < newSize ifTrue:[
		newSequenceableCollection
			replaceFrom: endReplacement + 1
			to: newSize
			with: self
			startingAt: stop + 1].
	^newSequenceableCollection! !
!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 2/7/2024 16:15:40' prior: 16947665!
   grownTo: newSize

	| grownCollection |
	grownCollection := self copyBlank: newSize.
	grownCollection replaceFrom: 1 to: self size with: self startingAt: 1.
	^grownCollection! !
!ClosureScanner methodsFor: 'private - depth first scan queue' stamp: 'jmv 2/7/2024 16:21:05' prior: 50349577!
newScanQueueSegment
	"Segment the scan queue, otherwise the GC will be forced to scan the whole
	queue every time (obviously, the scan queue will be in the remember table)"

	| newScanQueue |
	newScanQueue := OrderedCollection basicNew.
	newScanQueue setContents: (Array new: self scanQueueSegmentTargetSize).
	newScanQueue resetTo: 1.
	^newScanQueue! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6219-copyBlank-not-ofSize-JuanVuletich-2024Feb07-16h33m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6218] on 7 February 2024 at 4:41:56 pm'!
!SequenceableCollection class methodsFor: 'stream creation' stamp: 'jmv 2/7/2024 16:28:16'!
                      streamContents: blockWithArg on: aCollection

	| stream originalContents |
	
	stream := aCollection writeStream.
	blockWithArg value: stream.
	originalContents := stream originalContents.
	
	^stream position = originalContents size
		ifTrue: [ originalContents asStreamResult ]
		ifFalse: [ stream contents ]! !
!OrderedCollection class methodsFor: 'stream creation' stamp: 'jmv 2/7/2024 16:29:14' overrides: 16948632!
                             streamContents: blockWithArg

	^self streamContents: blockWithArg on: self new! !
!OrderedCollection class methodsFor: 'stream creation' stamp: 'jmv 2/7/2024 16:39:22' overrides: 16948638!
   streamContents: blockWithArg estimatedSize: estimatedSize
	"Compatibility. Simply ignore size hint."

	^self streamContents: blockWithArg! !
!SequenceableCollection class methodsFor: 'stream creation' stamp: 'jmv 2/7/2024 16:30:56' prior: 16948638!
       streamContents: blockWithArg estimatedSize: estimatedSize

	^self streamContents: blockWithArg on: (self new: estimatedSize)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6220-StreamCreation-dontCall-ofSize-JuanVuletich-2024Feb07-16h36m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6218] on 7 February 2024 at 4:42:15 pm'!

OrderedCollection class removeSelector: #ofSize:!

!methodRemoval: OrderedCollection class #ofSize: stamp: 'Install-6221-ofSize-remove-JuanVuletich-2024Feb07-16h41m-jmv.001.cs.st 2/8/2024 12:44:36'!
ofSize: aSize

	"See superclass implementation"
	
	^ super new initializeOfSize: aSize!

Collection class removeSelector: #ofSize:!

!methodRemoval: Collection class #ofSize: stamp: 'Install-6221-ofSize-remove-JuanVuletich-2024Feb07-16h41m-jmv.001.cs.st 2/8/2024 12:44:36'!
ofSize: aSize

	"Create a new collection of size aSize with nil as its elements.
	This method exists because OrderedCollection new: aSize creates an
	empty collection,  not one of size aSize that it is necesary for #streamContents: 
	when sent to OrderedCollection"
	
	^ self new: aSize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6221-ofSize-remove-JuanVuletich-2024Feb07-16h41m-jmv.001.cs.st----!

'From Haver6.3 [latest update: #6206] on 8 February 2024 at 3:10:35 pm'!
!OrderedDictionary methodsFor: 'enumerating' stamp: 'KLG 2/8/2024 14:50:59'!
                             reverseDo: aBlock
	"Evaluate aBlock for each of the receiver's values in reverse order."

	orderedKeys reverseDo: [ :key |
		aBlock value: (self at: key ifAbsent: nil) ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6222-OrderedDictionaryReverseDo-GeraldKlix-2024Feb08-15h10m-KLG.001.cs.st----!

----QUIT----(8 February 2024 12:44:44) Cuis6.3-6222.image priorSource: 502787!

----STARTUP---- (23 February 2024 17:14:54) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis6.3-6222.image!


'From Cuis6.3 [latest update: #6156] on 8 February 2024 at 8:38:57 pm'!
!Array methodsFor: 'converting' stamp: 'tb 2/8/2024 20:24:02' prior: 50349826!
                            evalStrings
	   "Allows you to construct literal arrays.
    #(true false nil '5@6' 'Set new' '''text string''') evalStrings
    gives an array with true, false, nil, a Point, a Set, and a String
    instead of just a bunch of Symbols"
   
  
    ^ self collect: [:each |  
	each isSymbol 
		ifTrue: [each == #true 
			ifTrue: [true]
			ifFalse: [each == #false 
				ifTrue: [false]
				ifFalse:[each == #nil 
					ifTrue: [nil]
					ifFalse: [each]]]] 
		ifFalse: [each isString 
				ifTrue: [Compiler evaluate: each]
				ifFalse: [each isArray 
					ifTrue: [each evalStrings]
					ifFalse:[each]]]
        ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6223-evalStrings-moreRobust-ToddBlanchard-2024Feb08-16h44m-tb.001.cs.st----!

'From Cuis6.3 [latest update: #6222] on 9 February 2024 at 3:44:50 pm'!
!Text methodsFor: 'copying' stamp: 'len 2/9/2024 10:46:51' overrides: 50350016!
                            copyBlank: requestedSize
	"Answer an instance like me, of size n, but without content.
	The underlying string of the new instance matches the type of the receiver's string (for example String or UnicodeString)."
	^ Text fromString: (string class new: requestedSize)! !
!SequenceableCollection methodsFor: 'converting' stamp: 'len 2/9/2024 10:52:40' prior: 16947497!
                  reversed
	"Answer a copy of the receiver with element order reversed."
	"Example: 'frog' reversed"

	| n result src |
	n := self size.
	result := self copyBlank: n.
	src := n + 1.
	1 to: n do: [:i | result at: i put: (self at: (src := src - 1))].
	^ result
! !
!SequenceableCollection methodsFor: 'copying' stamp: 'len 2/9/2024 11:03:28' prior: 16947652 overrides: 16828547!
         copyWith: newElement
	"Answer a copy of the receiver that is 1 bigger than the receiver and has 
	newElement at the last element."

	| answer |
	answer := self copyBlank: self size + 1.
	answer replaceFrom: 1 to: self size with: self startingAt: 1.
	answer at: answer size put: newElement.
	^answer! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'len 2/9/2024 10:51:44' prior: 16947729 overrides: 16828617!
                            collect: aBlock
	"Refer to the comment in Collection|collect:."
	| result |
	result := self copyBlank: self size.
	1 to: self size do:
		[:index | result at: index put: (aBlock value: (self at: index))].
	^ result! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'len 2/9/2024 10:51:55' prior: 16947739!
     collect: aBlock from: firstIndex to: lastIndex
	"Refer to the comment in Collection|collect:."

	| size result j |
	size := lastIndex - firstIndex + 1.
	result := self copyBlank: size.
	j := firstIndex.
	1 to: size do: [:i | result at: i put: (aBlock value: (self at: j)). j := j + 1].
	^ result! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'len 2/9/2024 10:53:11' prior: 16948182!
                   with: otherCollection collect: twoArgBlock
	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."
	| result |
	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].
	result := self copyBlank: self size.
	1 to: self size do:
		[:index | result at: index put:
		(twoArgBlock
			value: (self at: index)
			value: (otherCollection at: index))].
	^ result! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'len 2/9/2024 10:53:27' prior: 16948242!
       with: otherCollection with: thirdCollection collect: threeArgBlock
	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."
	| n result |
	n := self size.
	otherCollection size = n ifFalse: [ self error: 'otherCollection must be the same size' ].
	thirdCollection size = n ifFalse: [ self error: 'thirdCollection must be the same size' ].
	result := self copyBlank: n.
	1 to: n do: [ :index | 
		result at: index put:
			(threeArgBlock
				value: (self at: index)
				value: (otherCollection at: index)
				value: (thirdCollection at: index) )].
	^ result! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'len 2/9/2024 10:53:35' prior: 16948284!
       withIndexCollect: elementAndIndexBlock
	"Just like with:collect: except that the iteration index supplies the second argument to the block."
	| result |
	result := self copyBlank: self size.
	1 to: self size do:
		[:index | result at: index put:
		(elementAndIndexBlock
			value: (self at: index)
			value: index)].
	^ result! !
!OrderedCollection methodsFor: 'copying' stamp: 'len 2/9/2024 11:07:47' prior: 50348350 overrides: 50350045!
          copyFrom: startIndex to: endIndex
	"Answer a copy of the receiver that contains elements from position startIndex to endIndex."
	self flag: #fix. "TODO: copy the underlying array, that uses a primitive and its much faster; or implement replaceFrom:to:with:startingAt: in OrderedCollection in a smart way"
	^ super copyFrom: startIndex to: endIndex! !

Text removeSelector: #grownTo:!

!methodRemoval: Text #grownTo: stamp: 'Install-6224-OrderedCollection-cleanup-LucianoEstebanNotarfrancesco-2024Feb09-10h46m-len.001.cs.st 2/23/2024 17:15:04'!
grownTo: newSize
	"Accommodate for the fact that string could hold a String or an ArrayOfCharactersAndCodePoints
	when being streamed to."

	| grownText |
	grownText := Text fromString: (string class new: newSize).
	grownText replaceFrom: 1 to: self size with: self startingAt: 1.
	^grownText!

OrderedCollection removeSelector: #collect:!

!methodRemoval: OrderedCollection #collect: stamp: 'Install-6224-OrderedCollection-cleanup-LucianoEstebanNotarfrancesco-2024Feb09-10h46m-len.001.cs.st 2/23/2024 17:15:04'!
collect: aBlock 
	"Evaluate aBlock with each of my elements as the argument. Collect the 
	resulting values into a collection that is like me. Answer the new 
	collection. Override superclass in order to use addLast:, not at:put:."

	| newCollection |
	newCollection := self species new.
	newCollection resetTo: 1.
	firstIndex to: lastIndex do: [ :index |
		newCollection addLast: (aBlock value: (array at: index))].
	^ newCollection!

OrderedCollection removeSelector: #collect:from:to:!

!methodRemoval: OrderedCollection #collect:from:to: stamp: 'Install-6224-OrderedCollection-cleanup-LucianoEstebanNotarfrancesco-2024Feb09-10h46m-len.001.cs.st 2/23/2024 17:15:04'!
collect: aBlock from: fromIndex to: toIndex
	"Override superclass in order to use addLast:, not at:put:."
	| result |
	(fromIndex < 1 or:[toIndex + firstIndex - 1 > lastIndex])
		ifTrue: [^self errorNoSuchElement].
	result := self species new.
	firstIndex + fromIndex - 1 to: firstIndex + toIndex - 1 do:
		[:index | result addLast: (aBlock value: (array at: index))].
	^ result
!

OrderedCollection removeSelector: #reversed!

!methodRemoval: OrderedCollection #reversed stamp: 'Install-6224-OrderedCollection-cleanup-LucianoEstebanNotarfrancesco-2024Feb09-10h46m-len.001.cs.st 2/23/2024 17:15:04'!
reversed
	"Answer a copy of the receiver with element order reversed.  "
	| newCol |
	newCol := self species new.
	self reverseDo:
		[:elem | newCol addLast: elem].
	^ newCol

"#(2 3 4 'fred') reversed"!

OrderedCollection removeSelector: #with:with:collect:!

!methodRemoval: OrderedCollection #with:with:collect: stamp: 'Install-6224-OrderedCollection-cleanup-LucianoEstebanNotarfrancesco-2024Feb09-10h46m-len.001.cs.st 2/23/2024 17:15:04'!
with: otherCollection with: thirdCollection collect: threeArgBlock
	"Collect and return the result of evaluating twoArgBlock with 
	corresponding elements from this collection and otherCollection."
	| result |
	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].
	result := self species new.
	1 to: self size do: [ :index |
		result addLast:
			(threeArgBlock
				value: (self at: index)
				value: (otherCollection at: index)
				value: (thirdCollection at: index) )].
	^ result!

OrderedCollection removeSelector: #copyWith:!

!methodRemoval: OrderedCollection #copyWith: stamp: 'Install-6224-OrderedCollection-cleanup-LucianoEstebanNotarfrancesco-2024Feb09-10h46m-len.001.cs.st 2/23/2024 17:15:04'!
copyWith: newElement 
	"Answer a copy of the receiver that is 1 bigger than the receiver and 
	includes the argument, newElement, at the end."

	| newCollection |
	newCollection := self copy.
	newCollection add: newElement.
	^newCollection!

OrderedCollection removeSelector: #withIndexCollect:!

!methodRemoval: OrderedCollection #withIndexCollect: stamp: 'Install-6224-OrderedCollection-cleanup-LucianoEstebanNotarfrancesco-2024Feb09-10h46m-len.001.cs.st 2/23/2024 17:15:04'!
withIndexCollect: elementAndIndexBlock 
	"Just like with:collect: except that the iteration index supplies the second argument to the block. Override superclass in order to use addLast:, not at:put:."

	| newCollection |
	newCollection := self species new.
	firstIndex to: lastIndex do:
		[:index |
		newCollection addLast: (elementAndIndexBlock
			value: (array at: index)
			value: index - firstIndex + 1)].
	^ newCollection!

OrderedCollection removeSelector: #with:collect:!

!methodRemoval: OrderedCollection #with:collect: stamp: 'Install-6224-OrderedCollection-cleanup-LucianoEstebanNotarfrancesco-2024Feb09-10h46m-len.001.cs.st 2/23/2024 17:15:04'!
with: otherCollection collect: twoArgBlock 
	"Collect and return the result of evaluating twoArgBlock with 
	corresponding elements from this collection and otherCollection."
	| result |
	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].
	result := self species new.
	1 to: self size do:
		[:index | result addLast: (twoArgBlock value: (self at: index)
									value: (otherCollection at: index))].
	^ result!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6224-OrderedCollection-cleanup-LucianoEstebanNotarfrancesco-2024Feb09-10h46m-len.001.cs.st----!

'From Cuis6.3 [latest update: #6223] on 9 February 2024 at 1:16:59 pm'!
!OrderedCollection methodsFor: 'copying' stamp: 'len 2/9/2024 13:15:46' prior: 50350369 overrides: 50350045!
                            copyFrom: startIndex to: endIndex
	"Answer a copy of the receiver that contains elements from position startIndex to endIndex."
	| delta newArray |
	delta := firstIndex - 1.
	newArray := array copyFrom: startIndex + delta to: endIndex + delta.
	^ OrderedCollection basicNew setContents: newArray.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6225-OrderedCollection-optimized-copyFromto-LucianoEstebanNotarfrancesco-2024Feb09-13h09m-len.001.cs.st----!

'From Cuis6.3 [latest update: #6225] on 11 February 2024 at 3:50:10 pm'!
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 2/11/2024 15:48:37'!
                            logStartupNotice: stuff
	"
	Smalltalk logStartupNotice: 'stuff'
	"
	[
		Transcript
			logToFile: true;
			logToStdout: true.
		stuff print.
	] forkAt: Processor activePriority - 1! !
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 2/11/2024 15:49:27' prior: 16969323!
                logStartupDebugAid: stuff
	"
	Transcript
		showOnDisplay: false;
		logToFile: true;
		logToStdout: true.
	Smalltalk at: #LogStartupDebugAids put: true.
	Smalltalk logStartupDebugAid: 'stuff'
	"
	self logStartupDebugAids ifTrue: [
		self logStartupNotice: stuff ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6226-LogStartupNotice-JuanVuletich-2024Feb11-15h48m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6225] on 11 February 2024 at 4:25:48 pm'!
!Workspace class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 11:57:14'!
        open
	^self new
		contents: '';
		openLabel: 'Workspace'! !
!Browser class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 12:00:45'!
  open
	| browser |
	browser := self new.
	^ BrowserWindow open: browser label: browser defaultBrowserTitle! !
!HierarchyBrowser class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 12:15:30' overrides: 50350593!
                    open
	^ HierarchyBrowserWindow onClass: Object selector: nil! !
!MessageSet class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 12:22:06' overrides: 50350593!
       open
	^ MessageSetWindow openFullProtocolForClass: Object! !
!MessageNames class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 12:09:25' overrides: 50350605!
        open
"Bring a MessageNames window to the front"
	^ MessageNamesWindow 
		open: MessageNames new
		label: 'Message Names'! !
!ChangeSorter class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 12:36:17'!
                             open
	^ ChangeSorterWindow 
		open: self new
		label: nil! !
!FileList class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 12:53:16'!
open
	"
	FileList open
	"
	self open: DirectoryEntry userBaseDirectory! !
!FileList class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 12:52:49'!
                   open: aDirectory
	"
	FileList open: '/' asDirectoryEntry
	"
	| win |
	win := FileListWindow open: (self new directory: aDirectory) label: nil.
	win model when: #updateButtonRow send: #updateButtonRow to: win.
	^ win! !
!CodePackageList class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 12:32:11'!
                           open
	^ CodePackageListWindow open: self new! !
!TestRunner class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 12:55:12'!
           open
	^ TestRunnerWindow open: self new label: nil! !
!ProcessBrowser class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 12:39:01'!
 open
	"
	ProcessBrowser open
	"
	"Create and schedule a ProcessBrowser."
	Smalltalk garbageCollect.
	^ ProcessBrowserWindow open: self new label: nil! !
!TextEditor class methodsFor: 'ui' stamp: 'hlsf 2/11/2024 11:55:08'!
  open

	^ SystemWindow editText: TextModel new label: 'Text Editor' wrap: true! !
!Transcript class methodsFor: 'ui' stamp: 'jmv 2/11/2024 16:04:23'!
           open
	"
	Transcript open
	"
	| win m |
	win := TranscriptWindow new.
	win
		setLabel: 'Transcript';
		model: Transcript.
	m := TranscriptMorph new.
	win layoutMorph addMorph: m proportionalHeight: 1.
	win model when: #redrawTranscriptArea send: #invalidateBounds to: win.
	^ win openInWorld! !
!Workspace class methodsFor: 'menu-world' stamp: 'hlsf 2/11/2024 11:57:14' prior: 17007507!
                              worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		20.
			#label 			->			'Workspace'.
			#object 			-> 		Workspace.
			#selector 		-> 		#open.
			#icon 			-> 		#terminalIcon.
			#balloonText 	-> 		'A window for evaluating Smalltalk expressions'.
		} asDictionary}`! !
!CPUWatcher methodsFor: 'porcine capture' stamp: 'hlsf 2/11/2024 12:39:12' prior: 16802873!
                            openMorphicWindowForSuspendedProcess: aProcess
	| menu rule |
	menu := MenuMorph new.
	"nickname  allow-stop  allow-debug"
	rule := (ProcessBrowser rulesFor: aProcess) second.
	menu add: 'Dismiss this menu' target: menu action: #delete; addLine.
	menu add: 'Open Process Browser' target: ProcessBrowser action: #open.
	menu add: 'Resume'
		target: self
		action: #resumeProcess:fromMenu:
		argumentList: { aProcess . menu }.
	menu add: 'Terminate'
		target: self
		action: #terminateProcess:fromMenu:
		argumentList: { aProcess . menu }.
	rule ifTrue: [
		menu add: 'Debug at a lower priority'
			target: self
			action: #debugProcess:fromMenu:
			argumentList: { aProcess . menu }.
	].
	menu addTitle: aProcess identityHash printString,
		' ', aProcess name,
		' is taking too much time and has been suspended.
What do you want to do with it?'.
	menu stayUp.
	menu popUpInWorld! !
!Collection methodsFor: 'converting' stamp: 'hlsf 2/11/2024 12:03:41' prior: 16828437!
                       asDictionary
	"Answer a Dictionary. Assume our elements are Associations.
	{
			#itemGroup 		-> 	10.
			#itemOrder 		-> 	30.
			#label 			-> 	'Browser'.
			#object 			-> 	Browser.
			#selector 		-> 	#open.
			#icon 			-> 	#editFindReplaceIcon.
			#balloonText 	-> 	'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary
	"

	^ self as: Dictionary! !
!TextEditor class methodsFor: 'menu-world' stamp: 'hlsf 2/11/2024 11:55:08' prior: 16981992!
        worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		10.
			#label 			->			'Text Editor'.
			#object 			-> 		TextEditor.
			#selector 		-> 		#open.
			#icon 			-> 		#textEditorIcon.
			#balloonText 	-> 		'A window for composing text'.
		} asDictionary}`! !
!WorldMorph methodsFor: 'defaul desktop' stamp: 'jmv 2/11/2024 16:05:43' prior: 50349993!
           recreateDefaultDesktop
	"
	self runningWorld recreateDefaultDesktop
	"
	self whenUIinSafeState: [
		self hideTaskbar.
		(submorphs
			select: [ :ea | ea class == SystemWindow or: [ea class == TranscriptWindow]])
				do: [ :ea | ea delete ].
		Theme current useTaskbar ifTrue: [self showTaskbar].
		Transcript clear.
		Transcript open
			resizeBottomLeft
	].! !
!WorldMorph methodsFor: 'events' stamp: 'hlsf 2/11/2024 12:01:35' prior: 17007882 overrides: 16904050!
                keyStroke: aKeyboardEvent
	self flag: #definesKeyboardShortcuts.
	"Handle a keystroke event."
	(aKeyboardEvent commandAltKeyPressed or: [ aKeyboardEvent controlKeyPressed ])
		ifTrue: [
			aKeyboardEvent keyCharacter = $b ifTrue: [ Browser open ].
			aKeyboardEvent keyCharacter = $f ifTrue: [ BrowserWindow findClass ].
			aKeyboardEvent keyCharacter = $F ifTrue: [ MessageSetWindow findInSourceCode ].
		].
	"aKeyboardEvent keyCharacter print."
	^ super keyStroke: aKeyboardEvent! !
!WorldMorph methodsFor: 'windows' stamp: 'hlsf 2/11/2024 12:27:45' prior: 17008584!
       findATranscript
	"Locate a transcript, open it, and bring it to the front.  Create one if necessary"

	self
		findAWindowSatisfying: [ :aWindow | aWindow model == Transcript]
		orMakeOneUsing: [ Transcript open ]! !
!WorldMorph methodsFor: 'world menu' stamp: 'hlsf 2/11/2024 12:53:47' prior: 17008637!
                 findAFileList: evt
	"Locate a file list, open it, and bring it to the front.
	Create one if necessary, respecting the Preference."
	self
		findAWindowSatisfying: [ :aWindow |
			aWindow model class == FileList ]
		orMakeOneUsing: [
			FileList open ]! !
!CodePackageListWindow class methodsFor: 'menu-world' stamp: 'hlsf 2/11/2024 12:32:25' prior: 16825719!
                          worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		10.
			#label 			->			'Installed Packages'.
			#object 			-> 		CodePackageList.
			#selector 		-> 		#open.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for managing Packages (optional units of code) installed in the system'.
		} asDictionary}`! !
!BrowserWindow class methodsFor: 'menu-world' stamp: 'hlsf 2/11/2024 12:02:21' prior: 16800780!
          worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		30.
			#label 			->			'Browser'.
			#object 			-> 		Browser.
			#selector 		-> 		#open.
			#icon 			-> 		#editFindReplaceIcon.
			#balloonText 	-> 		'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary}`! !
!MessageNamesWindow methodsFor: 'GUI building' stamp: 'hlsf 2/11/2024 12:10:17' prior: 16895409 overrides: 16898684!
              buildMorphicWindow
	"Answer a morphic window with the given initial search string, nil if none"
	"MessageNames open"
	| selectorListView firstRow searchButton secondRow |
	textMorph := (TextModelMorph
		textProvider: model
		textGetter: #searchString
		textSetter: #searchString:
		selectionGetter: #contentsSelection)
		setBalloonText: 'See MessageNames class comment for search string options';
		emptyTextDisplayMessage: 'Type here, then hit Search'.
	textMorph askBeforeDiscardingEdits: false.
	textMorph acceptOnCR: true.
	textMorph hideScrollBarsIndefinitely.
	searchButton := PluggableButtonMorph new
		model: textMorph innerTextMorph;
		label: 'Search';
		action: #acceptContents.
	searchButton setBalloonText: 'Type some letters into the pane at right, and then press this Search button (or hit RETURN) and all method selectors that match what you typed will appear in the list pane below.  Click on any one of them, and all the implementors of that selector will be shown in the right-hand pane, and you can view and edit their code without leaving this tool.'.
	firstRow := LayoutMorph newRow.
	firstRow color: self windowColor.
	firstRow
		doAdoptWidgetsColor;
		
			addMorph: searchButton
			proportionalWidth: 0.25;
		
			addMorph: textMorph
			proportionalWidth: 0.75.
	selectorListView := PluggableListMorph
		model: model
		listGetter: #selectorList
		indexGetter: #selectorListIndex
		indexSetter: #selectorListIndex:
		mainView: self
		menuGetter: #selectorListMenu
		keystrokeAction: #selectorListKey:from:.
	secondRow := LayoutMorph newRow.
	secondRow
		
			addMorph: selectorListView
			proportionalWidth: 0.5;
		
			addAdjusterAndMorph: self buildMorphicMessageList
			proportionalWidth: 0.5.
	self layoutMorph
		
			addMorph: firstRow
			fixedHeight: self defaultButtonPaneHeight + 4;
		
			addAdjusterAndMorph: secondRow
			proportionalHeight: 0.5;
		
			addAdjusterAndMorph: self buildLowerPanes
			proportionalHeight: 0.5.
	model changed: #editSelection! !
!MessageNamesWindow class methodsFor: 'menu-world' stamp: 'hlsf 2/11/2024 12:09:42' prior: 16895514 overrides: 50350812!
       worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		10.
			#itemOrder 		-> 		40.
			#label 			->			'Message Names'.
			#object 			-> 		MessageNames.
			#selector 		-> 		#open.
			#icon 			-> 		#inspectIcon.
			#balloonText 	-> 		'A tool for finding and editing methods that contain any given keyword in their names.'.
		} asDictionary}`! !
!ChangeSorterWindow class methodsFor: 'menu-world' stamp: 'hlsf 2/11/2024 12:36:35' prior: 16810714!
     worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		20.
			#label 			->			'Change Sorter'.
			#object 			-> 		ChangeSorter.
			#selector 		-> 		#open.
			#icon 			-> 		#halfRefreshIcon.
			#balloonText 	-> 		'A tool allowing you to view the methods in a Change Set, especially changes to the Base System'.
		} asDictionary}`! !
!FileListWindow class methodsFor: 'menu-world' stamp: 'hlsf 2/11/2024 12:53:58' prior: 16863361!
                            worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		40.
			#itemOrder 		-> 		10.
			#label 			->			'File List'.
			#object 			-> 		FileList.
			#selector 		-> 		#open.
			#icon 			-> 		#systemFileManagerIcon.
			#balloonText 	-> 		'An explorer of the File System'.
		} asDictionary}`! !
!ProcessBrowserWindow class methodsFor: 'menu-world' stamp: 'hlsf 2/11/2024 12:39:23' prior: 16931262!
                        worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		30.
			#itemOrder 		-> 		10.
			#label 			->			'Process Browser'.
			#object 			-> 		ProcessBrowser.
			#selector 		-> 		#open.
			#icon 			-> 		#systemMonitorIcon.
			#balloonText 	-> 		'A tool to monitor and manage Smalltalk processes'.
		} asDictionary}`! !
!TestRunnerWindow class methodsFor: 'menu-world' stamp: 'hlsf 2/11/2024 12:55:26' prior: 16977056!
  worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 		-> 		40.
			#itemOrder 		-> 		20.
			#label 			->			'SUnit Test Runner'.
			#object 			-> 		TestRunner.
			#selector 		-> 		#open.
			#icon 			-> 		#weatherFewCloudsIcon.
			#balloonText 	-> 		'Smalltalk''s testing framework'.
		} asDictionary}`! !
!TranscriptWindow class methodsFor: 'menu-world' stamp: 'hlsf 2/11/2024 12:28:46' prior: 16988607!
                   worldMenuOptions
	^ `{{
			#submenuOf -> TheWorldMenu openLabel.
			#itemGroup 				-> 	10.
			#itemOrder 				-> 	50.
			#label 				->	'Transcript'.
			#object 				-> 	Transcript.
			#selector 				-> 	#open.
			#icon 				-> 	#printerIcon.
			#balloonText 				-> 	'A window showing contents of the System Transcript'.
		} asDictionary}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'hlsf 2/11/2024 12:36:44' prior: 16984127!
            changesMenuOptions

	^`{
			{
				#submenuOf  -> 					TheWorldMenu changesLabel.
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'Change Sorter'.
				#object 			-> 		ChangeSorter.
				#selector 		-> 		#open.
				#icon 			-> 		#halfRefreshIcon.
				#balloonText 	-> 		'Open a 3-paned changed-set viewing tool'.
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu changesLabel.
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Install New Updates'.
				#object 			-> 		ChangeSet.
				#selector 		-> 		#installNewUpdates.
				#icon 			-> 		#updateIcon.
				#balloonText 	-> 		'Install in the current image the new updates available
in directory named ./CoreUpdates
or in directory named ../Cuis-Smalltalk-Dev/CoreUpdates'.
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu changesLabel.
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'Browse my Changes'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#browseMyChanges.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Browse all of my changes since the last time #condenseSources was run.'.
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu changesLabel.
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Recently logged Changes...'.
				#object 			-> 		ChangeList.
				#selector 		-> 		#browseRecentLog.
				#icon 			-> 		#clockIcon.
				#balloonText 	-> 		'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'.
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu changesLabel.
				#itemGroup 	-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'Save World as morph file'.
				#selector 		-> 		#saveWorldInFile.
				#icon 			-> 		#morphsIcon.
				#balloonText 	-> 		'Save a file that, when reloaded, reconstitutes the current World.'.
			} asDictionary.
		}`! !

TranscriptWindow class removeSelector: #openTranscript!

!methodRemoval: TranscriptWindow class #openTranscript stamp: 'Install-6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st 2/23/2024 17:15:04'!
openTranscript
	"
	TranscriptWindow openTranscript
	"
	| win m |
	win := TranscriptWindow new.
	win
		setLabel: 'Transcript';
		model: Transcript.
	m := TranscriptMorph new.
	win layoutMorph addMorph: m proportionalHeight: 1.
	win model when: #redrawTranscriptArea send: #invalidateBounds to: win.
	^ win openInWorld.!

TestRunnerWindow class removeSelector: #openTestRunner!

!methodRemoval: TestRunnerWindow class #openTestRunner stamp: 'Install-6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st 2/23/2024 17:15:04'!
openTestRunner
	TestRunnerWindow open: TestRunner new label: nil!

ProcessBrowserWindow class removeSelector: #openProcessBrowser!

!methodRemoval: ProcessBrowserWindow class #openProcessBrowser stamp: 'Install-6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st 2/23/2024 17:15:04'!
openProcessBrowser
	"
	ProcessBrowserWindow openProcessBrowser
	"
	"Create and schedule a ProcessBrowser."
	Smalltalk garbageCollect.
	self open: ProcessBrowser new label: nil!

FileListWindow class removeSelector: #openFileList!

!methodRemoval: FileListWindow class #openFileList stamp: 'Install-6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st 2/23/2024 17:15:04'!
openFileList
	"
	FileListWindow openFileList
	"
	self openFileList: (FileList new directory: DirectoryEntry userBaseDirectory)!

FileListWindow class removeSelector: #openFileList:!

!methodRemoval: FileListWindow class #openFileList: stamp: 'Install-6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st 2/23/2024 17:15:04'!
openFileList: aDirectory
	"
	FileListWindow openFileList
	"
	| win |
	
	win := FileListWindow open: aDirectory label: nil.
	win model when: #updateButtonRow send: #updateButtonRow to: win.
	^ win!

ChangeSorterWindow class removeSelector: #openChangeSorter!

!methodRemoval: ChangeSorterWindow class #openChangeSorter stamp: 'Install-6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st 2/23/2024 17:15:04'!
openChangeSorter
	self
		open: ChangeSorter new
		label: nil.!

MessageNamesWindow class removeSelector: #openMessageNames!

!methodRemoval: MessageNamesWindow class #openMessageNames stamp: 'Install-6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st 2/23/2024 17:15:04'!
openMessageNames
	"Bring a MessageNames tool to the front"
	^self
		open: MessageNames new
		label: 'Message Names'.!

BrowserWindow class removeSelector: #openBrowser!

!methodRemoval: BrowserWindow class #openBrowser stamp: 'Install-6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st 2/23/2024 17:15:04'!
openBrowser
	| browser |
	browser := Browser new.
	^ self open: browser label: browser defaultBrowserTitle!

CodePackageListWindow class removeSelector: #openPackageList!

!methodRemoval: CodePackageListWindow class #openPackageList stamp: 'Install-6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st 2/23/2024 17:15:04'!
openPackageList
	self open: CodePackageList new!

TextEditor class removeSelector: #openTextEditor!

!methodRemoval: TextEditor class #openTextEditor stamp: 'Install-6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st 2/23/2024 17:15:04'!
openTextEditor

	^ SystemWindow editText: TextModel new label: 'Text Editor' wrap: true!

Workspace class removeSelector: #openWorkspace!

!methodRemoval: Workspace class #openWorkspace stamp: 'Install-6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st 2/23/2024 17:15:04'!
openWorkspace
	^self new
		contents: '';
		openLabel: 'Workspace'.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6227-ToolProtocols-HilaireFernandes-2024Feb11-16h02m-hlsf.001.cs.st----!

'From Cuis6.3 [latest update: #6227] on 14 February 2024 at 10:29:03 am'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6228-RemoveEmptyCategories-JuanVuletich-2024Feb14-10h28m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6227] on 14 February 2024 at 10:31:08 am'!
!TranscriptWindow class methodsFor: 'please-remove' stamp: 'jmv 2/14/2024 10:30:50'!
                          openTranscript
	"Only required for GitHub CI unti we push updated images"
	^ Transcript open! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6229-addBack-openTranscript-JuanVuletich-2024Feb14-10h29m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6229] on 16 February 2024 at 4:45:55 am'!
!Sample09Clock methodsFor: 'drawing' stamp: 'jmv 2/16/2024 04:42:56' prior: 16944490 overrides: 16903763!
       drawOn: aCanvas

	| f |
	aCanvas
		strokeWidth: 10 color: Color lightCyan
		fillColor: Color veryVeryLightGray do: [ :canvas |
			canvas circleCenter:  0@0 radius: 100 ].
	f := FontFamily familyName: 'DejaVu Sans' pointSize: 14.
	aCanvas drawString: 'XII' at: -13 @ 58 font: f color: Color brown.
	aCanvas drawString: 'III' at: 73 @ -24 font: f color: Color brown.
	aCanvas drawString: 'VI' at: -9 @ -106 font: f color: Color brown.
	aCanvas drawString: 'IX' at: -90 @ -24 font: f color: Color brown.

	f := FontFamily familyName: 'Alex Brush' pointSize: 16.
	aCanvas drawString: 'Chaque Heure' atCenterX: 0@ 18 font: f color: Color black.
	f := FontFamily familyName: 'Alex Brush' pointSize: 8.
	aCanvas drawString: 'pour la Minorie' atCenterX: 0@ -60 font: f color: Color black.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6230-VGClock-fixLookForLargeSystemFonts-JuanVuletich-2024Feb16-04h35m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6229] on 21 February 2024 at 10:49:12 am'!
!TextEditor methodsFor: 'typing support' stamp: 'jmv 2/21/2024 10:43:48' prior: 16981211!
                          setEmphasisHereFromTextForward: f

	| i forward attributeIndex prevIsLineSeparator nextIsLineSeparator prevIsSeparator nextIsSeparator nextChar prevChar |
	i := self pointIndex.
	"Try to set emphasisHere correctly after whitespace.
	Most important after a cr, i.e. at the start of a new line"
	prevIsLineSeparator :=  i > 1 and: [ (prevChar := model actualContents at: i-1) isLineSeparator ].
	nextIsLineSeparator := i <= model textSize and: [ (nextChar := model actualContents at: i) isLineSeparator ].
	prevIsSeparator :=  i > 1 and: [ prevChar isSeparator ].
	nextIsSeparator := i <= model textSize and: [ nextChar isSeparator ].
	prevIsLineSeparator & nextIsLineSeparator
		ifTrue: [
			"Empty paragraph: take emphasis from the newLine character"
			forward := false ]
		ifFalse: [
			prevIsSeparator == nextIsSeparator
				ifTrue: [
					"Space at both sides, or non-space at both sides, take emphasis used where the cursor comes from"
					forward := f ]
				ifFalse: [
					"Space at one side and non-space at the other, take emphasis from the non-space character"
					forward := nextIsSeparator ]].
	attributeIndex := i - (forward ifTrue: [ 1 ] ifFalse: [ 0 ]).
	attributeIndex > 0 
		ifTrue: [
			emphasisHere := (model actualContents attributesAt: attributeIndex)
						select: [ :att | att mayBeExtended ].
			morph possiblyChanged ].! !
!TextEditor methodsFor: 'initialization' stamp: 'jmv 2/21/2024 10:43:11' prior: 16981851 overrides: 16932297!
            initialize
	emphasisHere := #().
	initialSelectionStart := nil.
	initialSelectionStop := nil.
	doWordSelection := false.
	doParagraphSelection := false.
	defaultFont := FontFamily defaultFamilyAndPointSize.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6231-TextEditor-KeepDefaultEmphasisWhenEmptied-JuanVuletich-2024Feb21-10h48m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6234] on 21 February 2024 at 4:17:19 pm'!
!DirectoryEntry class methodsFor: 'base directories' stamp: 'jmv 2/21/2024 14:29:39' prior: 16849790!
      currentDirectory
	"Answer the current directory.

	In Unix it is the current directory in the OS shell that started us.
	In Windows the same happens if the image file is in a subree of the Windows current directory.

	But it defaults to the directory in wich this Smalltalk image was started (or last saved) if this fails
	(this usually happens, for example, if the image is dropped on the VM in a Windows explorer).
	See #getCurrentWorkingDirectory

	DirectoryEntry currentDirectory
	"
	CurrentDirectory notNil ifTrue: [
		^ CurrentDirectory ].

	Smalltalk getCurrentWorkingDirectory ifNotNil: [ :wd |
		^ CurrentDirectory := self withPathName: wd ].

	^ CurrentDirectory := self userBaseDirectory.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
DirectoryEntry classPool at: #CurrentDirectory put: nil!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6232-lastResort-currentDirectory-isUsers-2024Feb21-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6222] on 21 February 2024 at 4:13:36 pm'!
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 2/21/2024 15:36:26'!
absolutePathComponentsFor: aString relativeTo: baseDirectory
	"aString is a relative path, and will be applied to baseDirectory
	See comment at #isAbsolutePathName"

	| tokens curDirPathComponents |

	"Basic tilde expansion. Consider $~ to mean user's home folder, if possible.
	See, for example, https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html"
	(aString size > 0 and: [aString first = $~]) ifTrue: [
		Smalltalk at: #OSProcess
			ifPresent: [ :osProcess |
				(osProcess thisOSProcess environmentAt: 'HOME')
					ifNotNil: [ :homeVariable |
						^self absolutePathComponentsFor: homeVariable, (aString withoutPrefix: '~') relativeTo: DirectoryEntry currentDirectory]
					ifNil: [ self error: 'The $HOME variable could not be resolved' ]]
			ifAbsent: [
				self error: 'Use of tilde (~) to mean $HOME folder requires OSProcess' ]].

	tokens := aString asPathTokens.

	aString isAbsolutePathName ifTrue: [ ^ tokens asArray ].

	curDirPathComponents := DirectoryEntry currentDirectory pathComponents.
	aString = '.' ifTrue: [ ^ curDirPathComponents copy ].
	aString = '..' ifTrue:  [^ curDirPathComponents allButLast ].

	[ tokens notEmpty and: [ tokens first = '..' ]] whileTrue: [
		curDirPathComponents := curDirPathComponents allButLast.
		tokens removeFirst ].

	^ Array streamContents: [ :strm |
		strm nextPutAll: curDirPathComponents.
		tokens do: [ :each |
			each = '.' ifFalse: [ strm nextPut: each ]]].! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 2/21/2024 15:37:28'!
                   expandTildeFor: aString

	aString size = 0 ifTrue: [ ^aString ].
	aString first = $~ifFalse: [ ^aString ].
	"Basic tilde expansion. Consider $~ to mean user's home folder, if possible.
	See, for example, https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html"
	Smalltalk at: #OSProcess
		ifPresent: [ :osProcess |
			(osProcess thisOSProcess environmentAt: 'HOME')
				ifNotNil: [ :homeVariable |
					^homeVariable, (aString copyFrom: 2 to: aString size) ]
				ifNil: [ self error: 'The $HOME variable could not be resolved' ]]
		ifAbsent: [
			self error: 'Use of tilde (~) to mean $HOME folder requires OSProcess' ]! !
!CharacterSequence methodsFor: 'fileman-testing' stamp: 'jmv 2/21/2024 15:09:00' prior: 16814332!
                               isAbsolutePathName
	"Note: On Windows, both 'C:\Users\Someone\file.txt' and '\Users\Someone\file.txt'
	and even '/Users/Someone/file.txt' are considered an absolute pathName.
	This is essentially because FilePlugin can handle them. The gained uniformity with Unix is nice."
	
	self isEmpty ifTrue: [^ false].
	self first isPathSeparator ifTrue: [^ true].
	
	"tilde means user's home folder, if possible.
	https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html"
	self first = $~ ifTrue: [^ true ].

	FileIOAccessor default onWindows
		ifTrue: [
			^ self beginsWithWindowsDriveName and: [ self size = 2 or: [ (self at: 3) isPathSeparator ]]].

	^ false! !
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 2/21/2024 15:19:01' prior: 16863648!
                             pathString: aString
	"Argument can be an absolute or relative path"

	| tokens |
	tokens := aString isAbsolutePathName
		ifTrue: [ (FileIOAccessor default expandTildeFor: aString) asPathTokens ]
		ifFalse: [ FileIOAccessor default absolutePathComponentsFor: aString relativeTo: DirectoryEntry currentDirectory ].
	(tokens notEmpty and: [self fileAccessor isDriveSupported])
		 ifTrue: [
			tokens first asDriveName ifNotNil: [ :guessedDriveName |
				^ self pathComponents: (tokens copyFrom: 2 to: tokens size) drive: guessedDriveName ]].
	self pathComponents: tokens drive: nil! !

FileIOAccessor removeSelector: #unresolvedHomeEnvironmentVariableDescription!

!methodRemoval: FileIOAccessor #unresolvedHomeEnvironmentVariableDescription stamp: 'Install-6233-AbsolutePathsRefactor-p1-JuanVuletich-2024Feb21-16h11m-jmv.001.cs.st 2/23/2024 17:15:04'!
unresolvedHomeEnvironmentVariableDescription

	^'The $HOME variable could not be resolved'!

FileIOAccessor removeSelector: #tildeFolderRequiresOSProcessDescription!

!methodRemoval: FileIOAccessor #tildeFolderRequiresOSProcessDescription stamp: 'Install-6233-AbsolutePathsRefactor-p1-JuanVuletich-2024Feb21-16h11m-jmv.001.cs.st 2/23/2024 17:15:04'!
tildeFolderRequiresOSProcessDescription

	^'Use of tilde (~) to mean $HOME folder requires OSProcess'!

FileIOAccessor removeSelector: #absolutePathComponentsFor:!

!methodRemoval: FileIOAccessor #absolutePathComponentsFor: stamp: 'Install-6233-AbsolutePathsRefactor-p1-JuanVuletich-2024Feb21-16h11m-jmv.001.cs.st 2/23/2024 17:15:04'!
absolutePathComponentsFor: aString
	"Not complete, but OK in most cases.
	See comment at #isAbsolutePathName"

	| tokens curDirPathComponents |

	"Basic tilde expansion. Consider $~ to mean user's home folder, if possible.
	See, for example, https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html"
	(aString size > 0 and: [aString first = $~]) ifTrue: [
		Smalltalk at: #OSProcess
			ifPresent: [ :osProcess |
				(osProcess thisOSProcess environmentAt: 'HOME')
					ifNotNil: [ :homeVariable |
						^self absolutePathComponentsFor: homeVariable, (aString withoutPrefix: '~')]
					ifNil: [ self error: self unresolvedHomeEnvironmentVariableDescription ]]
			ifAbsent: [
				self error: self tildeFolderRequiresOSProcessDescription ]].

	tokens := aString asPathTokens.

	aString isAbsolutePathName ifTrue: [ ^ tokens asArray ].

	curDirPathComponents := DirectoryEntry currentDirectory pathComponents.
	aString = '.' ifTrue: [ ^ curDirPathComponents copy ].
	aString = '..' ifTrue:  [^ curDirPathComponents allButLast ].

	[ tokens notEmpty and: [ tokens first = '..' ]] whileTrue: [
		curDirPathComponents := curDirPathComponents allButLast.
		tokens removeFirst ].

	^ Array streamContents: [ :strm |
		strm nextPutAll: curDirPathComponents.
		tokens do: [ :each |
			each = '.' ifFalse: [ strm nextPut: each ]]].!

CharacterSequence removeSelector: #asAbsolutePathName!

!methodRemoval: CharacterSequence #asAbsolutePathName stamp: 'Install-6233-AbsolutePathsRefactor-p1-JuanVuletich-2024Feb21-16h11m-jmv.001.cs.st 2/23/2024 17:15:04'!
asAbsolutePathName
	"See comment at #isAbsolutePathName"

	^ self species streamContents: [ :childPath |
		childPath nextPut: $/.
		(FileIOAccessor default absolutePathComponentsFor: self)
			do: [ :each | childPath nextPutAll: each]
			separatedBy: [childPath nextPut: $/]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6233-AbsolutePathsRefactor-p1-JuanVuletich-2024Feb21-16h11m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6231] on 21 February 2024 at 3:44:46 pm'!
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 2/21/2024 15:19:59' prior: 50351335!
             absolutePathComponentsFor: aString relativeTo: baseDirectory
	"aString is a relative path, and will be applied to baseDirectory
	See comment at #isAbsolutePathName"

	| baseDirectoryPathComponents tokens |

	baseDirectoryPathComponents := baseDirectory pathComponents.
	aString = '.' ifTrue: [ ^ baseDirectoryPathComponents copy ].
	aString = '..' ifTrue:  [^ baseDirectoryPathComponents allButLast ].

	tokens := aString asPathTokens.
	[ tokens notEmpty and: [ tokens first = '..' ]] whileTrue: [
		baseDirectoryPathComponents := baseDirectoryPathComponents allButLast.
		tokens removeFirst ].

	^ Array streamContents: [ :strm |
		strm nextPutAll: baseDirectoryPathComponents.
		tokens do: [ :each |
			each = '.' ifFalse: [ strm nextPut: each ]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6234-AbsolutePathsRefactor-p2-JuanVuletich-2024Feb21-15h41m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6235] on 21 February 2024 at 4:54:14 pm'!
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 2/21/2024 16:48:48'!
          absolutePathString: aString
	"Argument must be an absolute path"

	^self pathTokens: (FileIOAccessor default expandTildeFor: aString) asPathTokens.! !
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 2/21/2024 16:46:43'!
                      pathTokens: tokens
	"Argument can be an absolute or relative path"

	(tokens notEmpty and: [self fileAccessor isDriveSupported])
		 ifTrue: [
			tokens first asDriveName ifNotNil: [ :guessedDriveName |
				^ self pathComponents: (tokens copyFrom: 2 to: tokens size) drive: guessedDriveName ]].
	self pathComponents: tokens drive: nil.! !
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 2/21/2024 16:53:20'!
                           relativePathString: aString to: aDirectoryEntry
	"Argument must be a relative path"

	^self pathTokens: (FileIOAccessor default
		absolutePathComponentsFor: aString
		relativeTo: aDirectoryEntry).! !
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 2/21/2024 16:53:25' prior: 50351432!
                     pathString: aString
	"Argument can be an absolute or relative path"

	^aString isAbsolutePathName
		ifTrue: [ self absolutePathString: aString ]
		ifFalse: [ self relativePathString: aString to: DirectoryEntry currentDirectory ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6235-AbsolutePathsRefactor-p3-JuanVuletich-2024Feb21-16h52m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6236] on 22 February 2024 at 8:28:39 am'!
!FileSystemEntry class methodsFor: 'instance creation' stamp: 'jmv 2/21/2024 16:59:35'!
              withAbsolutePathName: aString
	"May exist or not
	aString must be an absolute path name"

	| instance |
	instance := self new.
	instance absolutePathString: aString.
	^instance! !
!FileSystemEntry class methodsFor: 'instance creation' stamp: 'jmv 2/21/2024 17:04:54'!
                    withRelativePathName: aString to: aDirectoryEntry
	"May exist or not.
	aString must be a relative path name"

	| instance |
	instance := self new.
	instance relativePathString: aString to: aDirectoryEntry.
	^instance! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 2/21/2024 17:09:00' prior: 16814225!
                               asDirectoryEntry
	"See examples in #asFileEntry method comment"

	^self isAbsolutePathName
		ifTrue: [
			DirectoryEntry withAbsolutePathName: self ]
		ifFalse: [
			DirectoryEntry withRelativePathName: self to: DirectoryEntry currentDirectory ].
! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 2/21/2024 17:08:55' prior: 16814249!
asFileEntry
	"

Windows	
	'C:\Windows' asFileEntry exists false
	'C:\Windows' asDirectoryEntry exists true
	'/' asFileEntry exists false
	'/' asDirectoryEntry exists false
	'C:\' asFileEntry exists false
	'C:\' asDirectoryEntry exists true
	('C:' asDirectoryEntry // 'Windows') exists false
	('C:' asDirectoryEntry / 'Windows') exists true
	
Linux
    '/var' asFileEntry exists
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists true
    '/media/cdrom' asFileEntry exists false
    '/media/cdrom' asDirectoryEntry exists true
    ('/bin' asDirectoryEntry / 'more') exists false
    ('/bin' asDirectoryEntry // 'more') exists true

MacOsX
    '/var' asFileEntry exists false
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists  true
    '/Volumes/SanDisk32-NTFS' asFileEntry exists false
    '/Volumes/SanDisk32-NTFS' asDirectoryEntry exists true
    'SanDisk32-NTFS' asFileEntry exists false
    'SanDisk32-NTFS' asDirectoryEntry exists false
	
	"
	self isRelativeMark ifTrue: [ ^self error: 'Maybe you need to call #asDirectoryEntry!!' ].
	^self isAbsolutePathName
		ifTrue: [
			FileEntry withAbsolutePathName: self ]
		ifFalse: [
			FileEntry withRelativePathName: self to: DirectoryEntry currentDirectory ].
! !
!FileSystemEntry methodsFor: 'accessing' stamp: 'jmv 2/21/2024 17:06:49' prior: 16863527!
                           name: aString parent: parentEntryOrNil



"inlinear tal cual en el sender.
juntar los 2 conocimientos de #currentDirectory."



	name := aString.
	parentEntryOrNil
		ifNil: [
			aString isAbsolutePathName
				ifTrue: [ self absolutePathString: aString ]
				ifFalse: [ self relativePathString: aString to: DirectoryEntry currentDirectory ]]
		ifNotNil: [
			parent := parentEntryOrNil.
			drive := parentEntryOrNil drive. "harmless if no drive supported, as in Unix"
			pathComponents := parentEntryOrNil pathComponents copyWith: name ].
	self invalidate! !
!FileSystemEntry class methodsFor: 'instance creation' stamp: 'jmv 2/22/2024 08:24:34' prior: 16863699!
          withPathName: aString
	"Note: It is generally advisable to call one or the more specific messages:
	#withAbsolutePathName: or #withRelativePathName:to:"

	^aString isAbsolutePathName
		ifTrue: [ self withAbsolutePathName: aString ]
		ifFalse: [
			self
				withRelativePathName: aString
				to: DirectoryEntry currentDirectory ].! !
!DirectoryEntry class methodsFor: 'base directories' stamp: 'jmv 2/21/2024 17:02:12' prior: 16849754!
             cuisBaseDirectory
	"The main folder with the directory structure where the files provided with Cuis reside.
	Usually will not contain user files, that belong to the project using Cuis and not to Cuis itself.
	See #projectBaseDirectory.
	cuisBaseDirectory/CoreUpdates: 								Default folder to look for updates to Cuis
	cuisBaseDirectory/Packages: 								Folder for code packages included with Cuis
	cuisBaseDirectory/TrueTypeFonts: 								Default folder to look for TrueType Fonts
	DirectoryEntry cuisBaseDirectory
	"

	| imageDirectory baseDirectory |
	CuisBaseDirectory notNil ifTrue: [
		^ CuisBaseDirectory ].

	imageDirectory := self withAbsolutePathName: Smalltalk imagePath.
	baseDirectory := imageDirectory.
	[ baseDirectory notNil ] whileTrue: [
		(baseDirectory / 'CoreUpdates') exists | (baseDirectory / 'Packages') exists
			ifTrue: [ ^ CuisBaseDirectory := baseDirectory ].
		baseDirectory := baseDirectory parent ].
	"Could not find it. Just use the directory containing the image."
	^ CuisBaseDirectory := imageDirectory.! !
!DirectoryEntry class methodsFor: 'base directories' stamp: 'jmv 2/21/2024 17:02:16' prior: 50351293!
       currentDirectory
	"Answer the current directory.

	In Unix it is the current directory in the OS shell that started us.
	In Windows the same happens if the image file is in a subree of the Windows current directory.

	But it defaults to the directory in wich this Smalltalk image was started (or last saved) if this fails
	(this usually happens, for example, if the image is dropped on the VM in a Windows explorer).
	See #getCurrentWorkingDirectory

	DirectoryEntry currentDirectory
	"
	CurrentDirectory notNil ifTrue: [
		^ CurrentDirectory ].

	Smalltalk getCurrentWorkingDirectory ifNotNil: [ :wd |
		^ CurrentDirectory := self withAbsolutePathName: wd ].

	^ CurrentDirectory := self userBaseDirectory.! !
!DirectoryEntry class methodsFor: 'base directories' stamp: 'jmv 2/21/2024 17:02:19' prior: 16849843!
                   smalltalkImageDirectory
	"Answer the directory on which this Smalltalk image was started (or last saved)

	DirectoryEntry smalltalkImageDirectory
	"

	ImageDirectory ifNil: [
		ImageDirectory := self withAbsolutePathName: Smalltalk imagePath ].
	^ ImageDirectory! !
!DirectoryEntry class methodsFor: 'base directories' stamp: 'jmv 2/21/2024 17:02:22' prior: 16849880!
                vmDirectory
	"Answer the directory containing the VM that runs us.

	DirectoryEntry vmDirectory
	"

	VMDirectory ifNil: [
		VMDirectory := self withAbsolutePathName: Smalltalk vmPath ].
	^ VMDirectory! !

FileSystemEntry removeSelector: #pathString:!

!methodRemoval: FileSystemEntry #pathString: stamp: 'Install-6236-AbsolutePathsRefactor-p4-JuanVuletich-2024Feb22-08h17m-jmv.001.cs.st 2/23/2024 17:15:05'!
pathString: aString
	"Argument can be an absolute or relative path"

	^aString isAbsolutePathName
		ifTrue: [ self absolutePathString: aString ]
		ifFalse: [ self relativePathString: aString to: DirectoryEntry currentDirectory ].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6236-AbsolutePathsRefactor-p4-JuanVuletich-2024Feb22-08h17m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6236] on 22 February 2024 at 10:00:08 am'!
!DirectoryEntry methodsFor: 'accessing' stamp: 'jmv 2/22/2024 09:52:43'!
      driveName: driveString
	"For instance, 'C:' or 'C:\'"

	name := driveString.
	drive := driveString.
	pathComponents := #().
	self invalidate! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 2/22/2024 09:59:50' prior: 50351663!
           asFileEntry
	"
Windows	
	'C:\Windows' asFileEntry exists false
	'C:\Windows' asDirectoryEntry exists true
	'/' asFileEntry exists false
	'/' asDirectoryEntry exists false
	'C:\' asFileEntry exists false
	'C:\' asDirectoryEntry exists true
	('C:' asDirectoryEntry // 'Windows') exists false
	('C:' asDirectoryEntry / 'Windows') exists true
	
Linux
    '/var' asFileEntry exists
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists true
    '/media/cdrom' asFileEntry exists false
    '/media/cdrom' asDirectoryEntry exists true
    ('/bin' asDirectoryEntry / 'more') exists false
    ('/bin' asDirectoryEntry // 'more') exists true

MacOsX
    '/var' asFileEntry exists false
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists  true
    '/Volumes/SanDisk32-NTFS' asFileEntry exists false
    '/Volumes/SanDisk32-NTFS' asDirectoryEntry exists true
    'SanDisk32-NTFS' asFileEntry exists false
    'SanDisk32-NTFS' asDirectoryEntry exists false
	
	"
	self isRelativeMark ifTrue: [ ^self error: 'Maybe you need to call #asDirectoryEntry!!' ].
	^self isAbsolutePathName
		ifTrue: [
			FileEntry withAbsolutePathName: self ]
		ifFalse: [
			FileEntry withRelativePathName: self to: DirectoryEntry currentDirectory ].
! !
!FileIOAccessor methodsFor: 'private' stamp: 'jmv 2/22/2024 09:55:20' prior: 50348815!
                               entriesIn: parentEntry
	"
	Warning: Private. Only to be called from within FileMan.
	Accepts nil as argument, but behavior depends on platform.
	parentEntryOrNil can only be nil if #isDriveSupported:

Windows (parentEntry = nil means root)
FileIOAccessor default entriesIn: nil #(C:\ D:\)
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(\$Recycle.Bin \Config.Msi \Documents and Settings \gratMusic \hiberfil.sys \Intel \pagefile.sys \PerfLogs \Program Files \Program Files (x86) \ProgramData \Python27 \Recovery \SimuloHoy \System Volume Information \totalcmd \Users \Windows)

Linux  (parentEntry = nil means current dir, like '' and '.')
FileIOAccessor default entriesIn: nil #(Lots of stuff in current directory)
(FileIOAccessor default entriesIn: nil) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
(FileIOAccessor default entriesIn: '' asDirectoryEntry) = (FileIOAccessor default entriesIn: '.' asDirectoryEntry) true
FileIOAccessor default entriesIn: '/' asDirectoryEntry #(/vmlinuz /boot /sbin /srv /lib /lib32 /tmp /sys /home /etc /initrd.img /bin /dev /opt /proc /lost+found /var /root /lib64 /mnt /usr /run /media)

MacOsX - parentEntry = nil answers an empty array
FileIOAccessor default entriesIn: nil #() .

	"
	| entries index done entryArray entry isDirectory lookIn lookForDrives |
	parentEntry isNil
		ifTrue: [
			self isDriveSupported ifFalse: [ self error: 'Only for platforms that have the concept of Disk Drive' ].
			lookIn := ''.
			lookForDrives := true ]
		ifFalse: [
			lookIn := parentEntry pathName.
			lookForDrives := false ].
	
	entries := OrderedCollection new.
	index := 1.
	done := false.
	[done] whileFalse: [
		entryArray := self primFixedNameLookupEntryIn: lookIn asUtf8Bytes index: index.
		#badDirectoryPath == entryArray ifTrue: [
			^#()].
		entryArray == nil
			ifTrue: [done := true]
			ifFalse: [
				isDirectory := entryArray at: 4.
				entry := isDirectory ifTrue: [DirectoryEntry new] ifFalse: [FileEntry new].
				lookForDrives
					ifTrue: [entry driveName: (entryArray at: 1)]
					ifFalse: [entry name: (entryArray at: 1) parent: parentEntry].
				entry updateFrom: entryArray entryInParent: index.
				entries addLast: entry ].
		index := index + 1].

	^entries asArray! !
!FileIOAccessor methodsFor: 'accessing' stamp: 'jmv 2/22/2024 09:19:43' prior: 16861836!
   drives
	"
	Answer a collection of Strings
	Meaningful only on Windows. Answers an empty array elsewhere.
	FileIOAccessor default drives
	"
	drives := nil. 		"will change if you mount or unmount drives!!"
	drives ifNil: [
		drives := self onWindows
			ifTrue: [ (self entriesIn: nil)]
			ifFalse: [ #() ]].
	^drives! !
!FileSystemEntry methodsFor: 'accessing' stamp: 'jmv 2/22/2024 09:57:22' prior: 50351708!
        name: aName parent: parentEntry

	name := aName.
	parent := parentEntry.
	drive := parentEntry drive. "harmless if no drive supported, as in Unix"
	pathComponents := parentEntry pathComponents copyWith: name.
	self invalidate! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6237-AbsolutePathsRefactor-p5-JuanVuletich-2024Feb22-08h28m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6236] on 22 February 2024 at 10:11:07 am'!
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 2/22/2024 10:10:10'!
                    asFullDirectoryEntry
	"Only for fully qualified path names"

	"See examples in #asFullFileEntry method comment"
	self isAbsolutePathName ifFalse: [ self error: 'Only for fully qualified (absolute) path names' ].
	^ DirectoryEntry withAbsolutePathName: self.! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 2/22/2024 10:09:43'!
      asFullFileEntry
	"Only for fully qualified path names"
	"
Windows	
	'C:\Windows' asFileEntry exists false
	'C:\Windows' asDirectoryEntry exists true
	'/' asFileEntry exists false
	'/' asDirectoryEntry exists false
	'C:\' asFileEntry exists false
	'C:\' asDirectoryEntry exists true
	('C:' asDirectoryEntry // 'Windows') exists false
	('C:' asDirectoryEntry / 'Windows') exists true
	
Linux
    '/var' asFileEntry exists
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists true
    '/media/cdrom' asFileEntry exists false
    '/media/cdrom' asDirectoryEntry exists true
    ('/bin' asDirectoryEntry / 'more') exists false
    ('/bin' asDirectoryEntry // 'more') exists true

MacOsX
    '/var' asFileEntry exists false
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists  true
    '/Volumes/SanDisk32-NTFS' asFileEntry exists false
    '/Volumes/SanDisk32-NTFS' asDirectoryEntry exists true
    'SanDisk32-NTFS' asFileEntry exists false
    'SanDisk32-NTFS' asDirectoryEntry exists false
	
	"
	self isAbsolutePathName ifFalse: [ self error: 'Only for fully qualified (absolute) path names' ].
	^ FileEntry withAbsolutePathName: self.! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 2/22/2024 10:05:20' prior: 50351652!
  asDirectoryEntry
	"See examples in #asFileEntry method comment"

	^self isAbsolutePathName
		ifTrue: [
			DirectoryEntry withAbsolutePathName: self ]
		ifFalse: [
			DirectoryEntry withRelativePathName: self to: DirectoryEntry currentDirectory ].! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 2/22/2024 10:05:42' prior: 50351855!
 asFileEntry
	"
Windows	
	'C:\Windows' asFileEntry exists false
	'C:\Windows' asDirectoryEntry exists true
	'/' asFileEntry exists false
	'/' asDirectoryEntry exists false
	'C:\' asFileEntry exists false
	'C:\' asDirectoryEntry exists true
	('C:' asDirectoryEntry // 'Windows') exists false
	('C:' asDirectoryEntry / 'Windows') exists true
Linux
    '/var' asFileEntry exists
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists true
    '/media/cdrom' asFileEntry exists false
    '/media/cdrom' asDirectoryEntry exists true
    ('/bin' asDirectoryEntry / 'more') exists false
    ('/bin' asDirectoryEntry // 'more') exists true
MacOsX
    '/var' asFileEntry exists false
    '/var' asDirectoryEntry exists true
    '/' asFileEntry exists false
    '/' asDirectoryEntry exists  true
    '/Volumes/SanDisk32-NTFS' asFileEntry exists false
    '/Volumes/SanDisk32-NTFS' asDirectoryEntry exists true
    'SanDisk32-NTFS' asFileEntry exists false
    'SanDisk32-NTFS' asDirectoryEntry exists false
	"
	self isRelativeMark ifTrue: [ ^self error: 'Maybe you need to call #asDirectoryEntry!!' ].
	^self isAbsolutePathName
		ifTrue: [
			FileEntry withAbsolutePathName: self ]
		ifFalse: [
			FileEntry withRelativePathName: self to: DirectoryEntry currentDirectory ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6238-AbsolutePathsRefactor-p6-JuanVuletich-2024Feb22-10h00m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6236] on 22 February 2024 at 2:13:49 pm'!
!FileSystemEntry commentStamp: 'jmv 2/22/2024 14:00:01' prior: 16863418!
  I represent a single file entry (including directory).

You can write data by #fileContents: , and read the data by #fileContents.

---
mu 11/6/2006 20:21

--------------
See examples class category.

See DirectoryEntry.

See categories starting with '*fileman-' in String.
	Smalltalk imageName asFullFileEntry fileSize
	Smalltalk imageName asFullFileEntry parent directories do: [ :a | a print ]!
!FileEntry commentStamp: 'jmv 2/22/2024 14:00:07' prior: 16860978!
               I represent a single file entry.

You can write data by #fileContents: , and read the data by #fileContents.

---
mu 11/6/2006 20:21

--------------
See examples class category.

See DirectoryEntry.

See categories starting with '*fileman-' in String.
	Smalltalk imageName asFullFileEntry fileSize
	Smalltalk imageName asFullFileEntry parent directories do: [ :a | a print ]!
!ChangeList class methodsFor: 'public access' stamp: 'jmv 2/22/2024 10:19:25' prior: 16805189!
         browseRecentLog
	"ChangeList browseRecentLog"
	"Prompt with a menu of how far back to go to browse the current image's changes log file"
	^ self
		browseRecentLogOn: Smalltalk currentChangesName asFullFileEntry
		startingFrom: Smalltalk lastQuitLogPosition! !
!VersionsBrowser methodsFor: 'init & update' stamp: 'jmv 2/22/2024 13:50:41' prior: 17003891!
                              scanVersionsOf: method class: class meta: meta category: category selector: selector
	| position stamp prevPos prevFileIndex preamble tokens sourceFilesCopy |
	selectorOfMethod := selector.
	currentCompiledMethod := method.
	classOfMethod := meta ifTrue: [class class] ifFalse: [class].
	changeList := OrderedCollection new.
	list := OrderedCollection new.
	addedChangeRecord ifNotNil: [ :change |
		self addItem: change text: ('{1} (in {2})' format: { change stamp. change fileName }) ].
	listIndex := 0.
	position := method filePosition.
	sourceFilesCopy := SourceFiles collect:
		[:x | x ifNotNil: [ x name asFullFileEntry readStream ]].
	method fileIndex = 0 ifTrue: [^ nil].
	file := sourceFilesCopy at: method fileIndex.
	[position notNil & file notNil] whileTrue: [
		"Skip back filler"
		file position: position.
		file backChunk.
		"Get preamble"
		preamble := file backChunk.
		"Preamble is likely a linked method preamble, if we're in
			a changes file (not the sources file).  Try to parse it
			for prior source position and file index"
		prevFileIndex := nil.
		prevPos := nil.
		stamp := ''.
		(preamble includesSubString: 'methodsFor:')
			ifTrue: [
				tokens := Scanner new scanTokens: preamble.
				stamp := CompiledMethod stampFrom: tokens.
				(CompiledMethod priorReferenceFrom: tokens) ifNotNil: [ :priorMethodRef |
					prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: priorMethodRef.
					prevPos := sourceFilesCopy filePositionFromSourcePointer: priorMethodRef ]].
 		self addItem:
				(ChangeRecord new file: file position: position type: #method
						class: class name category: category meta: meta stamp: stamp)
			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.
		position := prevPos.
		prevPos notNil ifTrue: [
			file := sourceFilesCopy at: prevFileIndex]].
	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].
	self clearSelections! !
!ClassCommentVersionsBrowser methodsFor: 'basic function' stamp: 'jmv 2/22/2024 13:50:48' prior: 16818535!
                  scanVersionsOf: class
	"Scan for all past versions of the class comment of the given class"

	| oldCommentRemoteStr sourceFilesCopy position prevPos stamp preamble tokens prevFileIndex |

	classOfMethod := class.
	oldCommentRemoteStr := class  organization commentRemoteStr.
	currentCompiledMethod := oldCommentRemoteStr.
	selectorOfMethod := #Comment.
	changeList := OrderedCollection new.
	list := OrderedCollection new.
	listIndex := 0.
	oldCommentRemoteStr ifNil:[^ nil] ifNotNil: [oldCommentRemoteStr sourcePointer].

	sourceFilesCopy := SourceFiles collect: [ :x | x ifNotNil: [x name asFullFileEntry readStream]].
	position := oldCommentRemoteStr position.
	file := sourceFilesCopy at: oldCommentRemoteStr sourceFileNumber.
	[ position notNil & file notNil]  whileTrue: [
		"Skip back filler"
		file position: position.
		file backChunk.
		"Get preamble"
		preamble := file backChunk.
		prevPos := nil.
		stamp := ''.
		(preamble includesSubString: 'commentStamp:')
			ifTrue: [
				tokens := Scanner new scanTokens: preamble.
				stamp := CompiledMethod field: #commentStamp: from: tokens ifAbsentOrNil: [ '' ].
				(CompiledMethod priorReferenceFrom: tokens) ifNotNil: [ :priorRef |
					prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: priorRef.
					prevPos := sourceFilesCopy filePositionFromSourcePointer: priorRef ]]
			ifFalse: [
				"The stamp get lost, maybe after a condenseChanges"
				stamp := '<historical>'].
 		self addItem:
				(ChangeRecord new file: file position: position type: #classComment
						class: class name category: nil meta: class isMeta stamp: stamp)
			text: stamp , ' ' , class name , ' class comment'. 
		prevPos = 0 ifTrue: [ prevPos := nil ].
		position := prevPos.
		prevPos notNil ifTrue: [ file := sourceFilesCopy at: prevFileIndex ]].
	sourceFilesCopy do: [ :x | x notNil ifTrue: [ x close ]].
	self clearSelections! !
!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 2/22/2024 13:50:54' prior: 16834553!
  getPreamble
	| file preamble |
	self fileIndex = 0 ifTrue: [^ String new].  "no source pointer for this method"
	file := SourceFiles at: self fileIndex.
	file ifNil: [^ ''].  "sources file not available"
	"file does not exist happens in secure mode"
	[
		file name asFullFileEntry readStreamDo: [ :stream | | p |
			preamble := ''.
			p := 0 max: self filePosition.
			p < stream size ifTrue: [
				"It appears that on Linux systems, immediately after adding a new method, the OS file cache may not be updated, so contents may still not be accessible. Protect against that."
				stream position: p.
				"Skip back blank space."
				stream backChunk.
				"Find and answer preamble chunk."
				preamble := stream backChunk ]]
	] on: FileDoesNotExistException do: [ :ex | preamble := '' ].
	^ preamble! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 2/22/2024 13:46:22' prior: 50332688!
condenseChanges
	"Move all the changes onto a compacted sources file."
	"
	Smalltalk condenseChanges
	"

	| oldChanges classCount oldChangesLocalName oldChangesPathName |
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' forceWriteStreamDo: [ :f |
		f timeStamp.
		'Condensing Changes File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: self classNames size
			during: [ :barBlock |
				classCount := 0.
				self allClassesDo: [ :class | 
					barBlock value: (classCount := classCount + 1).
					class moveChangesTo: f.
					class putClassCommentToCondensedChangesFile: f.
					class class moveChangesTo: f ]].
		LastQuitLogPosition := f position ].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	oldChanges := SourceFiles at: 2.
	oldChangesPathName := oldChanges name.
	oldChangesLocalName := oldChanges localName.
	oldChanges close.
	(oldChangesPathName, '.old') asFullFileEntry delete.
	oldChangesPathName asFullFileEntry rename: oldChangesLocalName, '.old'.
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' rename: oldChangesLocalName.
	
	SourceFiles
			at: 2 put: oldChangesPathName asFullFileEntry appendStream.

	self inform: 'Changes file has been rewritten!!

Check that all is well, and then save/quit.
 
Otherwise, remove new changes,
replace it with the former one, and
exit without saving the image.
 '! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 2/22/2024 13:47:32' prior: 50332735!
                condenseSources: newVersionString
	"Move all the changes onto a compacted sources file."
	"Smalltalk condenseSources"

	| classCount oldChanges oldChangesLocalName oldChangesPathName newChangesPathName newSourcesName |
	SourceFileVersionString := newVersionString.

	"Write all sources with fileIndex 1"
	newSourcesName := self defaultSourcesName.
	newSourcesName asFullFileEntry writeStreamDo: [ :f |
		f timeStamp.
		'Condensing Sources File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: self classNames size
			during: [ :barBlock |
				classCount := 0.
				self allClassesDo: [ :class |
					barBlock value: (classCount := classCount + 1).
					class fileOutOn: f moveSource: true toFile: 1]]].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	"Make a new empty changes file"
	oldChanges := SourceFiles at: 2.
	oldChangesPathName := oldChanges name.
	oldChangesLocalName := oldChanges localName.
	self closeSourceFiles.
	oldChangesPathName ifNotNil: [
		(oldChangesPathName, '.old') asFullFileEntry delete.
	oldChangesPathName asFullFileEntry rename: oldChangesLocalName, '.old' ].
	newChangesPathName := self defaultChangesName.
	newChangesPathName asFullFileEntry writeStreamDo: [ :stream |
		stream timeStamp ].
	LastQuitLogPosition := 0.

	self openSourceFiles.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 2/22/2024 13:51:17' prior: 50346638!
      filenameForUpdatedImage: aBoolean
	"If aBoolean, include highest update number	"
	| fileName newName changesName systemVersion |
	systemVersion := SystemVersion current.
	fileName := String streamContents: [ :strm |
		strm nextPutAll: systemVersion versionString.
		aBoolean ifTrue: [
			strm
				nextPut: $-;
				print: systemVersion highestUpdate ].
		self wordSize = 4 ifTrue: [
			strm nextPutAll: '-32' ]].
	newName := fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName := DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName := self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFullFileEntry exists ifTrue: [
		self inform:
'There is already .changes file of the desired name,
', changesName, '
curiously already present, even though there is no
corresponding .image file.
Please remedy manually and then repeat your request.'.
		^nil  ].
	^newName! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 2/22/2024 13:56:14' prior: 16966187!
                            saveAndQuitAs: newName clearAllClassState: clearAllStateFlag
	"Save the image  under a new name. Don't quit.
	See senders."

	| newChangesName |
	self currentChangesName ifNotNil: [ :oldChangesName |
		self closeSourceFiles. "so copying the changes file will always work"
		newChangesName := self fullNameForChangesNamed: newName.
		FileIOAccessor default copy: oldChangesName asFullFileEntry to: newChangesName asFullFileEntry.
		ChangesInitialFileSize ifNotNil: [
			oldChangesName asFullFileEntry appendStreamDo: [ :strm | strm truncate: ChangesInitialFileSize ]]].

	ChangeSet zapAllChangeSets.
	self 
		changeImageNameTo: (self fullNameForImageNamed: newName);
		closeSourceFiles; openSourceFiles;  "so SNAPSHOT appears in new changes file"
		snapshot: true andQuit: true embedded: false clearAllClassState: clearAllStateFlag.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 2/22/2024 13:56:20' prior: 16966216!
                          saveAndStayAs: newName clearAllClassState: clearAllStateFlag
	"Save the image  under a new name. Don't quit.
	See senders."

	| newChangesName |
	self currentChangesName ifNotNil: [ :oldChangesName |
		self closeSourceFiles. "so copying the changes file will always work"
		newChangesName := self fullNameForChangesNamed: newName.
		FileIOAccessor default copy: oldChangesName asFullFileEntry to: newChangesName asFullFileEntry.
		ChangesInitialFileSize ifNotNil: [
			oldChangesName asFullFileEntry appendStreamDo: [ :strm | strm truncate: ChangesInitialFileSize ]]].

	ChangeSet zapAllChangeSets.
	self 
		changeImageNameTo: (self fullNameForImageNamed: newName);
		closeSourceFiles; openSourceFiles;  "so SNAPSHOT appears in new changes file"
		snapshot: true andQuit: false embedded: false clearAllClassState: clearAllStateFlag.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 2/22/2024 13:59:49' prior: 16966245!
                         saveAs
	"Put up the 'saveAs' prompt, obtain a name, and save the image  under that new name."

	self request: 'New file name?' initialAnswer: self imageName asFullFileEntry name do: [:newName|
		((((self fullNameForImageNamed: newName) asFullFileEntry exists not
			and: [(self fullNameForChangesNamed: newName) asFullFileEntry exists not])
			or: [self confirm: ('{1} already exists. Overwrite?' format: {newName})]))
					ifTrue: [
						self saveAs: newName clearAllClassState: false]]! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 2/22/2024 13:56:25' prior: 16966263!
                 saveAs: newName clearAllClassState: clearAllStateFlag
	"Save the image  under a new name. Don't quit.
	See senders."

	| newChangesName |
	self currentChangesName ifNotNil: [ :oldChangesName |
		self closeSourceFiles. "so copying the changes file will always work"
		newChangesName := self fullNameForChangesNamed: newName.
		FileIOAccessor default copy: oldChangesName asFullFileEntry to: newChangesName asFullFileEntry.
		ChangesInitialFileSize ifNotNil: [
			oldChangesName asFullFileEntry appendStreamDo: [ :strm | strm truncate: ChangesInitialFileSize ]]].

	ChangeSet zapAllChangeSets.
	self 
		changeImageNameTo: (self fullNameForImageNamed: newName);
		closeSourceFiles; openSourceFiles;  "so SNAPSHOT appears in new changes file"
		snapshot: true andQuit: false embedded: false clearAllClassState: clearAllStateFlag.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 2/22/2024 13:59:53' prior: 16966661!
snapshotMessageFor: save andQuit: quit

	| dateAndTime |
	dateAndTime := DateAndTime now.
	^String streamContents: [ :stream |
		stream 
			nextPutAll: self tagHeader;
			nextPutAll: (self snapshotTagFor: save andQuit: quit);
			nextPutAll: self tagTail.
		stream nextPut: $(.
		dateAndTime date printOn: stream.
		stream space.
		dateAndTime time print24: true showSeconds: true on: stream.
		stream nextPut: $).
		stream
			space;
			nextPutAll: self imageName asFullFileEntry name;
			nextPutAll: ' priorSource: ';
			print: LastQuitLogPosition ].! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 2/22/2024 13:49:06' prior: 16966855!
                 externalizeSources   
	"Write the sources and changes streams onto external files."
	"
	Smalltalk externalizeSources
	"

	| sourcesName changesName |

	sourcesName := self defaultSourcesName.
	sourcesName asFullFileEntry writeStreamDo: [ :stream |
		stream nextPutAll: SourceFiles first originalContents ].
	SourceFiles at: 1 put: sourcesName asFullFileEntry readStream.

	changesName := self defaultChangesName.
	changesName asFullFileEntry writeStreamDo: [ :stream |
		stream nextPutAll: SourceFiles last contents ].
	SourceFiles at: 2 put: changesName asFullFileEntry appendStream.

	self inform: 'Sources successfully externalized'! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 2/22/2024 13:49:25' prior: 50334006!
                            openSourcesAndChanges
	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems.
	Note: SourcesName and imageName are full paths; changesName is a  
	local name."
	| sources changes entry msg lastQuitLogPosition snapshotChunk entryPathName |

	"Do not open source files if internalized (i.e. notNil)"
	sources := SourceFiles at: 1.
	sources ifNil: [
		entry := self defaultSourcesName asFullFileEntry.
		entry exists ifFalse: [
			entry := self alternativeSourcesName asFullFileEntry ].
		entry exists ifTrue: [
			sources := [ entry readStream ] on: FileDoesNotExistException do: [ nil ]]].
	(sources isNil and: [ Preferences at: #warnIfNoSourcesFile ])
		ifTrue: [
				msg := 'Cuis cannot locate the sources file named ' , entry pathName, '.', String newLineString,
					'Please check that the file is properly named and is in the same directory as this image.'.
			self logStartupError: msg.
		].

	"Do not open source files if internalized (i.e. notNil)"
	changes := SourceFiles at: 2.
	changes ifNil: [
		entry := self defaultChangesName asFullFileEntry.
		entryPathName := entry pathName.
		"Read the last snapshot chunk. Validate that the .changes file is appropriate for this image."
		entry exists
			ifTrue: [
				lastQuitLogPosition := self lastQuitLogPosition.
				lastQuitLogPosition > 0 ifTrue: [
					entry readStreamDo: [ :changesFile |
						changesFile position: lastQuitLogPosition.
						snapshotChunk := changesFile nextChunk ].
					((snapshotChunk beginsWith: self tagHeader) and: [
						snapshotChunk includesSubString: 'priorSource: ']) ifFalse: [
							(Preferences at: #warnIfNoChangesFile) ifTrue: [
								self logStartupError:
									'Incorrect changes file: ', entryPathName, String newLineString,
									'Missing code will be decompiled', String newLineString,
									'New source code will not be saved' ].
							entry := nil ]]]
			ifFalse: [
				(Preferences at: #warnIfNoChangesFile) ifTrue: [
					self logStartupError:
						'Could not find changes file: ', entryPathName, String newLineString,
						'Missing code will be decompiled', String newLineString,
						'New source code will not be saved' ].
				entry := nil ].
		entry ifNotNil: [
			changes := [ entry appendStream ]
				on: FileWriteError
				do: [
					self logStartupError:
						'Could not write to changes file: ', entryPathName, String newLineString,
						'Changes file will not be used.', String newLineString,
						'Missing code will be decompiled', String newLineString,
						'New source code will not be saved'.
					nil ]]].
	ChangesInitialFileSize := changes ifNotNil: [ changes position ].

	SourceFiles := Array with: sources with: changes.! !
!SystemDictionary methodsFor: 'image format' stamp: 'jmv 2/22/2024 13:59:44' prior: 50334260!
           imageFormatVersionFromFileAsIs
	"Answer an integer identifying the type of image on file. The image version number may
	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements
	of the image (e.g. block closure support required). If the image file has a different
	endianness than the VM, the format version will appear byte-swapped."
	"
	Smalltalk imageFormatVersionFromFileAsIs
	"
	^ self imageName asFullFileEntry readStreamDo: [ :stream |
		(stream binary; next: 4)
			uint32At: 1
			bigEndian: self isBigEndian ]! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'jmv 2/22/2024 13:52:21' prior: 16969655!
        restoreLostChangesManually

	ChangeList browseFrom: LastQuitLogPosition on: self currentChangesName asFullFileEntry labeled: 'Lost changes'
! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'jmv 2/22/2024 13:52:26' prior: 16969683!
withChangesFileDo: aBlock

	^self currentChangesName asFullFileEntry readStreamDo: aBlock! !
!UniFileStream methodsFor: 'access' stamp: 'jmv 2/22/2024 14:09:10' prior: 16991356!
              fileEntry
	^ self fullName asFullFileEntry! !
!UniFileStream class methodsFor: 'error handling' stamp: 'jmv 2/22/2024 14:06:34' prior: 16992275!
               fileDoesNotExistUserHandling: fullFileName

	| selection newName |
	selection := (PopUpMenu labels:
'create a new file
choose another name
cancel')
			startUpWithCaption: fullFileName asFullFileEntry name, '
does not exist.'.
	selection = 1 ifTrue: [
		^ self new open: fullFileName forWrite: true].
	selection = 2 ifTrue: [
		newName := self request: 'Enter a new file name'
						initialAnswer:  fullFileName.
		^ FileIOAccessor default privateWriteableFile: newName asFullFileEntry ].
	^ self error: 'Could not open a file'! !
!UniFileStream class methodsFor: 'error handling' stamp: 'jmv 2/22/2024 14:06:39' prior: 16992319!
           readOnlyFileDoesNotExistUserHandling: fullFileName

	| dir files choices selection newName fileName |
	dir := fullFileName asFullFileEntry parent.
	files := dir fileNames.
	fileName := fullFileName asFullFileEntry name.
	choices := fileName correctAgainst: files.
	choices add: 'Choose another name'.
	choices add: 'Cancel'.
	selection := (PopUpMenu labelArray: choices lines: (Array with: 5) )
		startUpWithCaption: fullFileName asFullFileEntry name, '
does not exist.'.
	selection = choices size ifTrue:["cancel" ^ nil "should we raise another exception here?"].
	selection < (choices size - 1) ifTrue: [
		newName := (dir pathName , '/', (choices at: selection))].
	selection = (choices size - 1) ifTrue: [
		newName := self request: 'Enter a new file name' initialAnswer: fileName.
		"If Cancel was pressed, no file should be opened - Hernan"
		newName isEmpty ifTrue: [ ^nil ]].
	newName = '' ifFalse: [^ FileIOAccessor default privateReadOnlyFile: newName asFullFileEntry ].
	^ self error: 'Could not open a file'! !
!FileIOAccessor methodsFor: 'actions' stamp: 'jmv 2/22/2024 10:14:19' prior: 16861461!
          rename: oldFileFullName to: newFileFullName 
	| selection |
	(self try: [self primRename: oldFileFullName asUtf8Bytes to: newFileFullName asUtf8Bytes ]
			forFileNamed: oldFileFullName) ifTrue: [^ self].

	oldFileFullName asFullFileEntry exists ifFalse: [^ self error: 'Attempt to rename a non-existent file'].
	(newFileFullName asFullFileEntry exists or: [ newFileFullName asFullDirectoryEntry exists ])
		ifTrue: [
			selection := (PopUpMenu labels: 'delete old version
cancel')
						startUpWithCaption: 'Trying to rename a file to be
' , newFileFullName , '
and it already exists.'.
			selection = 1
				ifTrue: [self deleteFile: newFileFullName.
					^ self rename: oldFileFullName to: newFileFullName]].
	^ self error: 'Failed to rename file'! !
!FileIOAccessor methodsFor: 'actions' stamp: 'jmv 2/22/2024 10:15:39' prior: 16861487!
                         renameDirectory: oldFileFullName to: newFileFullName 
	| selection |
	(self try: [self primRename: oldFileFullName asUtf8Bytes to: newFileFullName asUtf8Bytes ]
			forFileNamed: oldFileFullName) ifTrue: [^ self].

	oldFileFullName asFullDirectoryEntry exists ifFalse: [^ self error: 'Attempt to rename a non-existent file'].
	newFileFullName asFullDirectoryEntry exists
		ifTrue: [selection := (PopUpMenu labels: 'delete old version
cancel')
						startUpWithCaption: 'Trying to rename a directory to be
' , newFileFullName , '
and it already exists.'.
			selection = 1
				ifTrue: [newFileFullName asFullDirectoryEntry recursiveDelete.
					^ self renameDirectory: oldFileFullName to: newFileFullName]].
	^ self error: 'Failed to rename file'! !
!DirectoryEntry class methodsFor: 'base directories' stamp: 'jmv 2/22/2024 10:16:22' prior: 16849828!
               roots
	"Appropriate for all systems, including those with several roots, each being a logical 'drive' (Like Windows),
	and for systems having a single root with file systems (i.e. 'drives') mounted anywhere in the tree (Unix, MacOS)
	"
	"
	DirectoryEntry roots
	"
	^ FileIOAccessor default drives
		ifEmpty: [
			"On Linux and MacOsX"
			{ '/' asFullDirectoryEntry } ]! !
!CodePackage methodsFor: 'naming' stamp: 'jmv 2/22/2024 10:18:57' prior: 16824489!
                         packageDirectory

	^self packageDirectoryName asFullDirectoryEntry! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 2/22/2024 10:18:31' prior: 16824570!
       save
	"If we can't save, find a new destination directory."
	fullFileName ifNotNil: [
		fullFileName asFullFileEntry parent exists ifFalse: [
			fullFileName := nil ]].

	"If we were never saved, or never saved since image was moved, or target directory disappeared, then save to image directory."
	fullFileName ifNil: [
		fullFileName :=
			(DirectoryEntry newPackagesDirectory // self packageFileName) pathName ].

	fullFileName asFullFileEntry forceWriteStreamDo: [ :stream |
		stream timeStamp.
		self writeOnStream: stream ].

	self hasUnsavedChanges: false.
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: self)! !
!FeatureRequirement methodsFor: 'accessing' stamp: 'jmv 2/22/2024 14:12:36' prior: 16860359!
                             codePackageFile
	codePackageFile isNil ifTrue: [
		codePackageFile := CodePackageFile onFileEntry: pathName asFullFileEntry.
		"?"
		pathName := nil ].
	^codePackageFile! !
!FeatureRequirement methodsFor: 'requires' stamp: 'jmv 2/22/2024 14:13:04' prior: 16860399!
                       findPackageFileAsReqOf: mainFeatureOrNil
	"Look in known places for packages providing required feature.
	Answer wether search was successful."
	| packageFileName entry |
	pathName ifNotNil: [
		pathName asFullFileEntry exists ifTrue: [ ^ true ]].
	packageFileName := self packageFileName.
	(mainFeatureOrNil ifNil: [ self ]) placesToLookForPackagesDo: [ :directory |
		entry := directory // packageFileName.
		entry exists ifTrue: [
			"Try this one. If success, keep it."
			self pathName: entry pathName.
			self checkRequirement ifTrue: [ ^true ].
			"Nope. Don't keep it."
			self pathName: nil ]].
	^ false! !
!FeatureRequirement methodsFor: 'private' stamp: 'jmv 2/22/2024 14:12:47' prior: 16860646!
                             placesToLookForPackagesDo: aBlock

	| myDir |

	"Look inside my own folder"
	pathName ifNotNil: [
		myDir := pathName asFullFileEntry parent.
		aBlock value: myDir ].

	"Look in codePackageFile folder"
	codePackageFile ifNotNil: [
		myDir := codePackageFile fullName asFullFileEntry parent.
		aBlock value: myDir ].

	"Packages that come included with Cuis"
	aBlock value: DirectoryEntry packagesDirectory.
	DirectoryEntry packagesDirectory allRegularDirectoriesDo: aBlock.

	"Packages created by user"
	aBlock value: DirectoryEntry newPackagesDirectory.

	"Packages in other folders or repos in the project directory"
	aBlock value: DirectoryEntry projectBaseDirectory.
	DirectoryEntry projectBaseDirectory allRegularDirectoriesDo: aBlock.! !
!DropFilesAction methodsFor: 'evaluating - private' stamp: 'jmv 2/22/2024 14:07:20' prior: 16851132!
                   fileNamedDropped: aFileName 

	| options selectionIndex menu |
	
	selectedFileEntry := aFileName asFullFileEntry.
	options := FileList itemsForFileEntry: selectedFileEntry.
	options isEmpty ifTrue: [ ^self inform: 'No action found for ', selectedFileEntry name ].
	menu := self createMenuFor: options.
		
	selectionIndex := menu startUpWithCaption: 'Select action for ', selectedFileEntry name.
	
	selectionIndex = 0 ifTrue: [ ^self ].
	(options isInBounds: selectionIndex) ifTrue: [ ^self performService: (options at: selectionIndex) ].
	"The only available option is 'stop here'. This could change if #createMenuFor: changes - Hernan"
	stopHereBlock value
	
! !
!ChangeSet class methodsFor: 'services' stamp: 'jmv 2/22/2024 14:08:42' prior: 16809616!
               installNewUpdates: updatesFileDirectory

	| warnUser |
	self newUpdates: updatesFileDirectory do: [ :each |
		self install: each ].	

	warnUser := false.
	CodePackage installedPackages keysAndValuesDo: [ :pckName :package |
		package fullFileName ifNotNil: [ :fullFileName | | codePackageFile |
			codePackageFile := CodePackageFile onFileEntry: fullFileName asFullFileEntry.
			(codePackageFile provides isLaterThan: package provides) ifTrue: [
				warnUser := true.
				package hasUnsavedChanges
					ifTrue: [ ('Package: ', pckName, '. Package has unsaved changes, but there is a newer version of the file.') print ]
					ifFalse: [ ('Package: ', pckName, '. There is a newer version than the currently loaded.') print ]]]].
	warnUser
		ifTrue: [
			self inform: Smalltalk versionString, ' - ', Smalltalk lastUpdateString, String newLineString,
'Some package(s) loaded in the image
have updated package file on disk.
Please see Transcript.' ]
		ifFalse: [
			Smalltalk systemInformationString print ]! !
!CodeFile methodsFor: 'accessing' stamp: 'jmv 2/22/2024 14:09:22' prior: 16822736 overrides: 16915326!
          name

	^ self fullName asFullFileEntry name! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 2/22/2024 10:18:08' prior: 16824978!
                        install
	"Create, install and answer a (sub)instance of CodePackage
	Replace all existing code in the possibly existing CodePackage, removing any code that is not included in us."
	| localName newCodePackage pckClass currentCS |

	localName := fullName asFullFileEntry name.
	ChangeSet installing: packageName do: [
		"This change set will capture a possible class definition for a subclass of CodePackage.
		If it only has that, then remove it after package install.
		One example needing this is 'Color-Extras.pck.st'"
		currentCS := ChangeSet changeSetForBaseSystem.
		currentCS isEmpty ifFalse: [ currentCS := nil ].
		pckClass := CodePackage.
		classes do: [ :ee |
			(ee hasDefinition and: [ee superclassName = 'CodePackage']) ifTrue: [
				((self packageName asIdentifier: true), 'Package') = ee name ifTrue: [
					ee fileInDefinitionAndMetaclass.
					pckClass := Smalltalk at: ee name ]]].
		newCodePackage := pckClass
			named: packageName
			createIfAbsent: true
			registerIfNew: true.
		newCodePackage
			fullFileName: fullName;
			sourceSystem: sourceSystem;
			description: description;
			featureSpec: featureSpec.

		fullName asFullFileEntry readStreamDo: [ :stream | stream fileInAnnouncing: 'Installing ', localName, '...' ].
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].
		currentCS ifNotNil: [ ChangeSet removeChangeSet: currentCS ]].

	newCodePackage hasUnsavedChanges: false; triggerEvent: #dirtyFlagChanged.
	DataStream initialize. "Just in case"
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: newCodePackage).
	(Preferences at: #transcriptLogVerbose) ifTrue: [
		Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
		Smalltalk cleanOutUndeclared.
		Undeclared notEmpty ifTrue: [
			('Undeclared: ', Undeclared printString) print ]].
	^newCodePackage! !
!CodePackageFile class methodsFor: 'services' stamp: 'jmv 2/22/2024 14:09:40' prior: 16825246!
                        packageNameFrom: fullName

	^fullName asFullFileEntry nameWithoutExtension! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6239-AbsolutePathsRefactor-p7-JuanVuletich-2024Feb22-10h11m-jmv.002.cs.st----!

'From Cuis6.3 [latest update: #6236] on 22 February 2024 at 3:03:40 pm'!
!FileList methodsFor: 'own services' stamp: 'jmv 2/22/2024 14:31:26' prior: 16862560!
           viewContentsInWorkspace
	"View the contents of my selected file in a new workspace"

	| fileEntry fileContents |
	fileEntry := directory // fileName.
	fileContents := fileEntry textContents.

	(Workspace new contents: fileContents) 
		openLabel: 'Workspace from ', fileName ::
			setProperty: #lastFilenameUsedToSave
			toValue: fileEntry pathName! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 2/22/2024 15:01:04' prior: 50352061!
                            asDirectoryEntry
	"Note: It is generally advisable to call one of the more specific messages:
		#/
		#withAbsolutePathName: 
		#withRelativePathName:to:"
	"See examples in #asFileEntry method comment"

	^self isAbsolutePathName
		ifTrue: [
			DirectoryEntry withAbsolutePathName: self ]
		ifFalse: [
			DirectoryEntry withRelativePathName: self to: DirectoryEntry currentDirectory ].! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 2/22/2024 15:03:14' prior: 50352072!
                        asFileEntry
	"Note: It is generally advisable to call one of the more specific messages:
		#//
		#withAbsolutePathName: 
		#withRelativePathName:to:"
	"
	Windows	
		'C:\Windows' asFileEntry exists false
		'C:\Windows' asDirectoryEntry exists true
		'/' asFileEntry exists false
		'/' asDirectoryEntry exists false
		'C:\' asFileEntry exists false
		'C:\' asDirectoryEntry exists true
		('C:' asDirectoryEntry // 'Windows') exists false
		('C:' asDirectoryEntry / 'Windows') exists true
	Linux
		'/var' asFileEntry exists
		'/var' asDirectoryEntry exists true
		'/' asFileEntry exists false
		'/' asDirectoryEntry exists true
		'/media/cdrom' asFileEntry exists false
		'/media/cdrom' asDirectoryEntry exists true
		('/bin' asDirectoryEntry / 'more') exists false
		('/bin' asDirectoryEntry // 'more') exists true
	MacOsX
		'/var' asFileEntry exists false
		'/var' asDirectoryEntry exists true
		'/' asFileEntry exists false
		'/' asDirectoryEntry exists  true
		'/Volumes/SanDisk32-NTFS' asFileEntry exists false
		'/Volumes/SanDisk32-NTFS' asDirectoryEntry exists true
		'SanDisk32-NTFS' asFileEntry exists false
		'SanDisk32-NTFS' asDirectoryEntry exists false
	"
	self isRelativeMark ifTrue: [ ^self error: 'Maybe you need to call #asDirectoryEntry!!' ].
	^self isAbsolutePathName
		ifTrue: [
			FileEntry withAbsolutePathName: self ]
		ifFalse: [
			FileEntry withRelativePathName: self to: DirectoryEntry currentDirectory ].! !
!UniFileStream class methodsFor: 'error handling' stamp: 'jmv 2/22/2024 14:52:26' prior: 50352730!
    fileDoesNotExistUserHandling: fullFileName

	| selection newName |
	selection := (PopUpMenu labels:
'create a new file
choose another name
cancel')
			startUpWithCaption: fullFileName asFullFileEntry name, '
does not exist.'.
	selection = 1 ifTrue: [
		^ self new open: fullFileName forWrite: true].
	selection = 2 ifTrue: [
		newName := self request: 'Enter a new file name'
						initialAnswer:  fullFileName.
		^ FileIOAccessor default privateWriteableFile: newName asFileEntry ].
	^ self error: 'Could not open a file'! !
!UniFileStream class methodsFor: 'error handling' stamp: 'jmv 2/22/2024 14:51:45' prior: 16992294!
               fileExistsUserHandling: fullFileName
	| dir localName choice newName entry |
	entry := fullFileName asFullFileEntry.
	dir := entry parent.
	localName := entry name.
	choice := (PopUpMenu
		labels:
'overwrite that file\choose another name\cancel' withNewLines)
		startUpWithCaption: localName, '
already exists.'.

	choice = 1 ifTrue: [
		dir removeKey: localName
			ifAbsent: [self error: 'Could not delete the old version of that file'].
		^ self new open: fullFileName forWrite: true].

	choice = 2 ifTrue: [
		newName := self request: 'Enter a new file name' initialAnswer: fullFileName.
		^ FileIOAccessor default privateNewFile: newName asFileEntry ].

	self error: 'Please close this to abort file opening'! !
!UniFileStream class methodsFor: 'error handling' stamp: 'jmv 2/22/2024 14:52:35' prior: 50352750!
                 readOnlyFileDoesNotExistUserHandling: fullFileName

	| dir files choices selection newName fileName |
	dir := fullFileName asFullFileEntry parent.
	files := dir fileNames.
	fileName := fullFileName asFullFileEntry name.
	choices := fileName correctAgainst: files.
	choices add: 'Choose another name'.
	choices add: 'Cancel'.
	selection := (PopUpMenu labelArray: choices lines: (Array with: 5) )
		startUpWithCaption: fullFileName asFullFileEntry name, '
does not exist.'.
	selection = choices size ifTrue:["cancel" ^ nil "should we raise another exception here?"].
	selection < (choices size - 1) ifTrue: [
		newName := (dir pathName , '/', (choices at: selection))].
	selection = (choices size - 1) ifTrue: [
		newName := self request: 'Enter a new file name' initialAnswer: fileName.
		"If Cancel was pressed, no file should be opened - Hernan"
		newName isEmpty ifTrue: [ ^nil ]].
	newName = '' ifFalse: [^ FileIOAccessor default privateReadOnlyFile: newName asFileEntry ].
	^ self error: 'Could not open a file'! !
!DirectoryEntry class methodsFor: 'base directories' stamp: 'jmv 2/22/2024 14:48:07' prior: 50351779!
                               currentDirectory
	"Answer the current directory.

	In Unix it is the current directory in the OS shell that started us.
	In Windows the same happens if the image file is in a subree of the Windows current directory.

	But it defaults to the directory in wich this Smalltalk image was started (or last saved) if this fails
	(this usually happens, for example, if the image is dropped on the VM in a Windows explorer).
	See #getCurrentWorkingDirectory

	DirectoryEntry currentDirectory
	"
	CurrentDirectory notNil ifTrue: [
		^ CurrentDirectory ].

	Smalltalk getCurrentWorkingDirectory ifNotNil: [ :wd |
		^ CurrentDirectory := self withAbsolutePathName: wd ].

	^ CurrentDirectory := self userBaseDirectory.! !
!SystemWindow methodsFor: 'user interface' stamp: 'jmv 2/22/2024 14:42:28' prior: 16971640!
                             forceSaveContents
	"Saves the contents to the file name in the #lastFilenameUsedToSave property.
	
	If none exists ask the user for a filename."
	
	self hasSaveAs ifFalse: [ ^ self ].
	self valueOfProperty: #lastFilenameUsedToSave
		ifPresentDo: [ :pathName | self forceSaveContentsTo: pathName asFullFileEntry ]
		ifAbsent: [
			self
				request: 'Enter file name'
				initialAnswer: ''
				verifying: [ :aString | aString notEmpty ]
				do: [ :fileName | self saveContentsTo: fileName asFileEntry ] ]! !
!SystemWindow methodsFor: 'user interface' stamp: 'jmv 2/22/2024 14:39:57' prior: 16971658!
          forceSaveContentsTo: aFileEntry
	"Saves the contents to the given filename.
	
	Force overwrting the file if it exists."

	self hasSaveAs ifFalse: [^self ].
	aFileEntry forceWriteStreamDo: [ :stream |
		model saveOn: stream ].
	self 
		setProperty: #lastFilenameUsedToSave toValue: aFileEntry pathName.! !
!SystemWindow methodsFor: 'user interface' stamp: 'jmv 2/22/2024 14:44:03' prior: 16971699!
                   saveContents
	"Prompts the user for a file name and saves the contents to the file"

	self hasSaveAs ifFalse: [ ^ self ].
	self
		request: 'Enter file name'
		initialAnswer: (self valueOfProperty: #lastFilenameUsedToSave ifAbsent: [ '' ])
		verifying: [ :aString |
			aString notEmpty ]
		do: [ :fileName |
			self saveContentsTo: fileName asFileEntry ].! !
!SystemWindow methodsFor: 'user interface' stamp: 'jmv 2/22/2024 14:40:08' prior: 16971713!
                              saveContentsTo: aFileEntry
	"Saves the contents to the given filename"

	self hasSaveAs ifFalse: [^self].
	aFileEntry writeStreamDo: [ :stream |
		model saveOn: stream ].
	self 
		setProperty: #lastFilenameUsedToSave toValue: aFileEntry pathName;
		notifyUserWith: 'Contents saved'.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6240-AbsolutePathsRefactor-p8-JuanVuletich-2024Feb22-14h13m-jmv.002.cs.st----!

'From Cuis6.3 [latest update: #6240] on 22 February 2024 at 4:10:08 pm'!
!FileSystemEntry methodsFor: 'initialize-release' stamp: 'jmv 2/22/2024 15:59:56' prior: 16863633!
              pathComponents: tokens drive: driveStringOrNil
	| firstToken |
	drive := driveStringOrNil.
	pathComponents := tokens asArray.
	(driveStringOrNil isNil and: [
		pathComponents notEmpty and: [ (firstToken := pathComponents first) isDriveName ]]) ifTrue: [
			drive := firstToken.
			pathComponents := pathComponents allButFirst ].
	pathComponents ifNotEmpty: [ name := pathComponents last ].
	self invalidate.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6241-Fix-JuanVuletich-2024Feb22-16h06m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6241] on 22 February 2024 at 4:29:04 pm'!
!Transcript class methodsFor: 'displaying' stamp: 'jmv 2/22/2024 16:28:42' prior: 16988228!
             displayTextOn: aCanvasOrSelf in: aRectangle
	"See senders"
	| font count x y fh innerR index |
	font := FontFamily defaultFamilyAndPointSize.
	innerR := aRectangle insetBy: self padding.
	x := innerR left.
	y := innerR top.
	fh := font lineSpacing.
	count := lastIndex - firstIndex \\ self maxEntries + 1 min: innerR height // fh - 1.
	index := lastIndex - count \\ self maxEntries + 1.
	count timesRepeat: [
		(entries at: index) ifNotNil: [ :string |
			aCanvasOrSelf drawString: string at: x@y font: font color: Theme current text.
			y := y + fh ].
		index := index \\ self maxEntries + 1 ].
	aCanvasOrSelf drawString: unfinishedEntry contents at: x@y font: font color: Theme current text! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6242-MoreRobustTranscript-JuanVuletich-2024Feb22-16h28m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6242] on 23 February 2024 at 9:45:00 am'!
!SystemWindow methodsFor: 'user interface' stamp: 'jmv 2/23/2024 06:10:06' prior: 50353277!
                               forceSaveContents
	"Saves the contents to the file name in the #lastFilenameUsedToSave property.
	
	If none exists ask the user for a filename."
	
	self hasSaveAs ifFalse: [ ^ self ].
	self valueOfProperty: #lastFilenameUsedToSave
		ifPresentDo: [ :pathName | self forceSaveContentsTo: pathName asFullFileEntry ]
		ifAbsent: [
			self
				request: 'Enter file name'
				initialAnswer: ''
				verifying: [ :aString | aString notEmpty ]
				do: [ :fileName | | file |
					file := fileName asFileEntry.
					self saveContentsTo: file.
					self setLabel: file pathName ]].! !
!SystemWindow methodsFor: 'user interface' stamp: 'jmv 2/23/2024 06:10:46' prior: 50353309!
      saveContents
	"Prompts the user for a file name and saves the contents to the file"

	self hasSaveAs ifFalse: [ ^ self ].
	self
		request: 'Enter file name'
		initialAnswer: (self valueOfProperty: #lastFilenameUsedToSave ifAbsent: [ '' ])
		verifying: [ :aString |
			aString notEmpty ]
		do: [ :fileName | | file |
			file := fileName asFileEntry.
			self saveContentsTo: file.
			self setLabel: file pathName ].! !
!SystemWindow methodsFor: 'user interface' stamp: 'jmv 2/23/2024 06:05:42' prior: 50353324!
   saveContentsTo: aFileEntry
	"Saves the contents to the given filename"

	self hasSaveAs ifFalse: [^self].
	aFileEntry writeStreamDo: [ :stream |
		model saveOn: stream ].
	self 
		setProperty: #lastFilenameUsedToSave toValue: aFileEntry pathName;
		notifyUserWith: 'Contents saved to', String newLineString, aFileEntry pathName.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6243-SetWindowLabelWhenSavingToFile-JuanVuletich-2024Feb23-09h43m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6242] on 23 February 2024 at 10:15:07 am'!
!DirectoryEntry class methodsFor: 'base directories' stamp: 'jmv 2/23/2024 10:12:04' prior: 50351743!
                      cuisBaseDirectory
	"The main folder with the directory structure where the files provided with Cuis reside.
	Usually will not contain user files, that belong to the project using Cuis and not to Cuis itself.
	Could be made read-only.
		cuisBaseDirectory/CoreUpdates: 								Default folder to look for updates to Cuis
		cuisBaseDirectory/Packages: 								Folder for code packages included with Cuis
		cuisBaseDirectory/TrueTypeFonts: 								Default folder to look for TrueType Fonts
	DirectoryEntry cuisBaseDirectory
	See #currentDirectory. See #userBaseDirectory."

	| imageDirectory |
	CuisBaseDirectory notNil ifTrue: [
		^ CuisBaseDirectory ].

	imageDirectory := self withAbsolutePathName: Smalltalk imagePath.

	"If the directory containing the image has siblings named CoreUpdates or Packages,
	it means that the parent is the Cuis Base Directory. This is the case for the directory
	structure provided in the Cuis repo."
	imageDirectory parent ifNotNil: [ :parentDirectory |
		(parentDirectory / 'CoreUpdates') exists | (parentDirectory / 'Packages') exists ifTrue: [
			^ CuisBaseDirectory := parentDirectory ]].

	"Otherwise, hopefully the required folders shold be inside the image folder.
	But if not, at least fail while looking for them in a reasonable place."
	^ CuisBaseDirectory := imageDirectory.! !
!DirectoryEntry class methodsFor: 'base directories' stamp: 'jmv 2/23/2024 10:00:30' prior: 50353251!
                  currentDirectory
	"The current directory.
	
	It is used, for unqualified names: `'stuff.txt' asFileEntry`, `'subfldr' asDirectoryEntry`. It is also used for relative paths if the full path is not specified: `'../sibling/data.txt'`.

	In Linux and MacOS, it is the current directory in the OS shell that started us.

	Same in Windows if Cuis is started from a command line. But, for instance, if the image is dropped on the VM in a Windows explorer, and no OS current directory is available, it defaults to #userBaseDirectory.

	DirectoryEntry currentDirectory
	See #cuisBaseDirectory. See #userBaseDirectory.
	See #getCurrentWorkingDirectory"

	CurrentDirectory notNil ifTrue: [
		^ CurrentDirectory ].

	Smalltalk getCurrentWorkingDirectory ifNotNil: [ :wd |
		^ CurrentDirectory := self withAbsolutePathName: wd ].

	^ CurrentDirectory := self userBaseDirectory.! !
!DirectoryEntry class methodsFor: 'base directories' stamp: 'jmv 2/23/2024 10:04:27' prior: 16849854!
                      userBaseDirectory
	"The top directory for files generated by the system on behalf of the user
		userBaseDirectory/SavedChangeSets 									Default folder for saving new ChangeSets
		userBaseDirectory/Packages: 									Default folder for new code packages
		userBaseDirectory/UserChanges: 									Folder to store user changes files
		userBaseDirectory/FileOuts: 									Default folder for filed out code
		userBaseDirectory/Logs: 									Default folder for error logs and other logs
	DirectoryEntry userBaseDirectory
	See #cuisBaseDirectory. See #currentDirectory."

	UserBaseDirectory notNil ifTrue: [
		^ UserBaseDirectory ].

	Smalltalk getCurrentWorkingDirectory ifNotNil: [ :wd |
		UserBaseDirectory := self withAbsolutePathName: wd ].

	"If no OS current directory, use a sibling of #cuisBaseDirectory
	If OS current directory is same as #cuisBaseDirectory, take a sibling too"
	(UserBaseDirectory isNil or: [ UserBaseDirectory = self cuisBaseDirectory ]) ifTrue: [
		UserBaseDirectory := self cuisBaseDirectory parent / (self cuisBaseDirectory name, '-UserFiles') ].

	^ UserBaseDirectory! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
DirectoryEntry classPool at: #CurrentDirectory put: nil.
DirectoryEntry classPool at: #UserBaseDirectory put: nil.
DirectoryEntry classPool at: #CuisBaseDirectory put: nil.
DirectoryEntry classPool at: #ProjectBaseDirectory put: nil.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6244-BetterDefaultDirectories-JuanVuletich-2024Feb23-09h45m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6244] on 23 February 2024 at 10:47:39 am'!
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 2/23/2024 10:36:18'!
                  rootClasses
	"
	Answer class hierarchy roots. This is, classes without superclass.
	Smalltalk rootClasses
	"
	^Array streamContents: [ :strm |
		self do: [ :root |
			(root isBehavior and: [root superclass isNil]) ifTrue: [	"Grab ProtoObject and any other alike"
				strm nextPut: root ]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6245-Smalltalk-rootclasses-JuanVuletich-2024Feb23-10h47m-jmv.001.cs.st----!

----QUIT----(23 February 2024 17:15:13) Cuis6.3-6245.image priorSource: 594003!

----STARTUP---- (4 March 2024 18:17:09) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis6.3-6245.image!


'From Cuis6.3 [latest update: #6245] on 1 March 2024 at 3:02:53 pm'!
!Rectangle class methodsFor: 'instance creation' stamp: 'jmv 3/1/2024 15:02:44' prior: 16936123!
                           center: centerPoint extent: extentPoint
	"Answer an instance of me whose center is centerPoint and width 
	by height is extentPoint.  "

	^self origin: centerPoint - (extentPoint/2) extent: extentPoint! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6246-Rectangle-centerextent-dontRoundToInteger-JuanVuletich-2024Mar01-15h02m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6246] on 1 March 2024 at 5:18:39 pm'!
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 3/1/2024 17:14:14'!
          subStrings: separators 
	"Answer an array containing the substrings in the receiver separated 
	by any of the elements of separators.
	Answer will not include empty strings
	'Hello World' subStrings: ' '
	'1Hello12World1This1211Are31Words1' subStrings: '123'
	'1Hello12World1This1211Are31Words1' subStrings: #($1 $2 $3)
	"

	| delimiterCharacters char in out |
	delimiterCharacters := separators asArray.
	^Array streamContents: [ :answer |
		in := self readStream.
		out := self species writeStream.
		[ in atEnd ] whileFalse: [
			char := in next.
			(delimiterCharacters identityIncludes:			char)
				ifFalse: [ out nextPut: char ]
				ifTrue: [
					out isEmpty ifFalse: [
						answer nextPut: out contents.
						out := self species writeStream ]]].
		out isEmpty ifFalse: [
			answer nextPut: out contents ]].! !
!String methodsFor: 'converting' stamp: 'jmv 3/1/2024 16:56:21' prior: 16960209!
                           substrings
	"Answer an array of the substrings that compose the receiver.
	Whitespace characters are considered separators, and not included in the result."

	^String substringsIn: self! !
!UnicodeString methodsFor: 'converting' stamp: 'jmv 3/1/2024 17:17:14' prior: 16993896!
           substrings
	"Answer an array of the substrings that compose the receiver.
	Whitespace characters are considered separators, and not included in the result.

	'  Hello World!! Some  		1234 more  €s ' substrings

	'  Hello World!!     Some  		1234 more  €s 
	for you
	to play with ' substrings
	"
	^ self isAscii
		ifTrue: [ (String substringsIn: bytes) collect: [ :eachBytes |
				UnicodeString fromUtf8Bytes: eachBytes codePointCount: eachBytes size ]]
		ifFalse: [ (String substringsIn: bytes) collect: [ :eachBytes |
				UnicodeString fromUtf8Bytes: eachBytes ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6247-subStrings-JuanVuletich-2024Mar01-17h15m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6247] on 4 March 2024 at 2:43:25 pm'!
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/4/2024 14:42:58' prior: 16984724!
    worldMainMenuOptions

	^`{
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		10.
			#label 				-> 		TheWorldMenu openLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#openIcon.
			#balloonText				-> 		'Submenu to open various system tools'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		20.
			#label 				-> 		'New morph...'.
			#selector				-> 		#newMorph.
			#icon 				-> 		#morphsIcon.
			#balloonText 				-> 		'Offers a variety of ways to create new objects'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		30.
			#label 				-> 		TheWorldMenu preferencesLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#preferencesIcon.
			#balloonText 				-> 		'Opens a menu offering many controls over appearance and system preferences.'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		40.
			#label 				-> 		TheWorldMenu windowsLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#windowIcon.
			#balloonText 				-> 		'Manage open windows'.
		} asDictionary.
		{
			#itemGroup 				-> 		10.
			#itemOrder 				-> 		50.
			#label 				-> 		TheWorldMenu helpLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#helpIcon.
			#balloonText 				-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		10.
			#label 				-> 		TheWorldMenu changesLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#changesIcon.
			#balloonText 				-> 		'Opens a menu of useful tools for dealing with changes'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		20.
			#label 				-> 		TheWorldMenu debugLabel.
			#selector 				-> 		#yourself.
			#icon 				-> 		#debugIcon.
			#balloonText 				-> 		'a menu of debugging items'.
		} asDictionary.
		{
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		30.
			#label 				-> 		'Restore Display'.
			#object 				-> 		#myWorld.
			#selector 				-> 		#restoreDisplay.
			#icon 				-> 		#displayIcon.
			#balloonText 				-> 		'Repaint the screen -- useful for cleaning unwanted display artifacts.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		10.
			#label 				-> 		'Save Image'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveImage.
			#icon 				-> 		#saveIcon.
			#balloonText 				-> 		'Save the current state of the image on disk. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		20.
			#label 				-> 		'Save Image as...'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAs.
			#icon 				-> 		#saveAsIcon.
			#balloonText 				-> 		'Save the current state of the image on disk under a new name.'.
		} asDictionary.
		{
			#itemGroup 				-> 		30.
			#itemOrder 				-> 		30.
			#label 				-> 		'Save Image and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAndQuit.
			#icon 				-> 		#saveAndQuitIcon.
			#balloonText 				-> 		'Save the image and quit out of Cuis. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 				-> 		40.
			#itemOrder 				-> 		10.
			#label 				-> 		'Save Official Release'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveNumberedRelease.
			#icon 				-> 		#saveAsNewVersionIcon.
			#balloonText 				-> 		('Save as a new numbered release of Cuis.\',
									'Name after #saveNumberedRelease.\',
									'Clear all user preferences and class vars.\',
									'Write new compacted Sources file, an empty\',
									'Changes file, and save the Image on disk.\',
									'Quit Cuis.\') withNewLines.
		} asDictionary.
		{
			#itemGroup 				-> 		40.
			#itemOrder 				-> 		20.
			#label 				-> 		'Save Updated and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveRollingReleaseAndQuit.
			#icon 				-> 		#saveAsNewVersionIcon.
			#balloonText 				-> 		('Save as update of the rolling release of Cuis.\',
									'Clear all user preferences and class vars.\',
									'Save Image and Changes with update number.\',
									'Quit Cuis.\') withNewLines.
		} asDictionary.
		{
			#itemGroup 				-> 		50.
			#itemOrder 				-> 		40.
			#label 				-> 		'Quit without saving'.
			#selector 				-> 		#quitSession.
			#icon 				-> 		#quitIcon.
			#balloonText 				-> 		('Quit out of Cuis without saving the image.\',
									'Ask for confirmation if there are unsaved changes.') withNewLines.
		} asDictionary.
	}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/4/2024 14:43:04' prior: 50332113!
            worldMenuOptions

	^`
		TheWorldMenu worldMainMenuOptions,
		TheWorldMenu additionalMenuOptions,
		TheWorldMenu preferencesMenuOptions,
		TheWorldMenu windowsMenuOptions,
		TheWorldMenu helpMenuOptions,
		TheWorldMenu changesMenuOptions,
		TheWorldMenu debugMenuOptions`.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6248-WorldMenuTweaks-JuanVuletich-2024Mar04-14h42m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6248] on 4 March 2024 at 3:16:12 pm'!
!Number methodsFor: 'truncation and round off' stamp: 'jmv 3/4/2024 15:07:09'!
                          roundedToEven
	"Convenience"
	^self roundTo: 2! !
!Point methodsFor: 'truncation and round off' stamp: 'jmv 3/4/2024 15:07:26'!
roundedToEven
	^ x roundedToEven @ y roundedToEven
! !
!ProgressInitiationException methodsFor: 'exceptionDescription' stamp: 'jmv 3/4/2024 15:09:17' prior: 16931839 overrides: 16856612!
     defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame oldFilledWidth oldFilledWidth2 |
	f := FontFamily defaultFamilyAndPointSize.
	h := f lineSpacing * 3//2.
	textWidth := (f widthOfString: progressTitle) + h.
	width := 150 max: textWidth.

	textForm := Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame := Rectangle center: aPoint extent: (width@h) roundedToEven.
	textFrame := `0@0` extent: width@h.
	textFrame := textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + `0@2`.
	outerFrame := barFrame merge: textFrame.
	delta := outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame := barFrame translatedBy: delta.
	textFrame := textFrame translatedBy: delta.
	outerFrame := outerFrame translatedBy: delta.
	range := maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame := barFrame insetBy: 2.
	textForm displayAt: textFrame topLeft.
	Display fillBlack: barFrame.
	Display fillWhite: innerBarFrame.
	oldFilledWidth := 0.
	oldFilledWidth2 := 0.
	result := workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal := barVal ]
			ifNil: [
				currentVal := currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal := minVal ]].
		filledWidth := ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		filledWidth  > oldFilledWidth ifTrue: [
			textForm displayAt: textFrame topLeft.
			Display fillBlack: barFrame.
			Display fillWhite: innerBarFrame.
			Display fillGray: (barFrame topLeft + `2@2` extent: filledWidth@(h-4)).
			filledWidth -200 > oldFilledWidth2
				ifFalse: [
					"Usually just request an update, to be done asynchronously."
					DisplayScreen screenUpdateRequired: outerFrame ]
				ifTrue: [
					"Once in a while, force a real screen update (warning: really slow on MacOS if done too often)"
					Display forceToScreen: outerFrame. oldFilledWidth2 := filledWidth ].
			oldFilledWidth := filledWidth ]].
	UISupervisor ui ifNotNil: [ :ui | ui invalidateDisplayRect: outerFrame for: nil ].
	self resume: result! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 3/4/2024 15:08:45' prior: 16870160!
             fakeSphereAt: aPoint diameter: diameter color: aColor
	"Create a form which contains a round black dot."
	| bb rect d p |
	bb := BitBltCanvasEngine toForm: Display.
	bb fillColor: aColor.
	bb combinationRule: Form blend.
	rect := aPoint extent: diameter.
	bb fillOval: rect.
	p := (diameter * 2 // 5) asPoint + aPoint.
	#(2 3 4 5 6 ) do: [ :i |
		"simulate facade by circles of gray"
		bb fillColor: `Color white alpha: 0.3`.
		d := i * diameter // 10.
		rect := Rectangle
			center: p
			extent: d roundedToEven.
		bb fillOval: rect ].
	DisplayScreen screenUpdateRequired: nil.
"
	Form fakeSphereAt: 50@50 diameter: 30 color:  (Color red alpha: 0.5)
"! !
!WorldMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 3/4/2024 15:10:25' prior: 17008317!
                 addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	| trialRect delta |
	trialRect := Rectangle center: aPoint extent: aMorph morphExtent.
	delta := trialRect amountToTranslateWithin: self displayBounds.
	self addMorph: aMorph.
	aMorph morphPositionInWorld: (trialRect origin + delta) rounded.! !
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 3/4/2024 15:12:33' prior: 16998390!
         imageUnrotated: srcForm at: aPoint
	"Workaround using WarpBlt until properly implemented in VectorEngine.
	Scale and position like #image:at:, but don't rotate srcForm:
	Display it in its natural orientation."

	| cellSize srcBox dstBox srcQuad bb |

	"If no rotation or scaling, BitBlt is enough. But there's no need to repeat the code:
	If no rotation, 'unrotated' is the same as 'defaultlyRotated'."
	currentTransformation isPureTranslation ifTrue: [
		^self image: srcForm at: aPoint ].

	"Compute bounds, set morphIds for affected pixels."
	self fillRectangle: (srcForm boundingBox translatedBy: aPoint) color: `Color gray alpha: 0.01`.

	cellSize := 4.
	srcBox := srcForm boundingBox.
	srcQuad := srcBox corners.
	dstBox := Rectangle
		center: (currentTransformation transform: srcBox center + aPoint) roundedHAFZ
		extent: (srcBox extent * currentTransformation scale) roundedHAFZ roundedToEven.
	bb := WarpBlt toForm: form.
	bb
		sourceForm: srcForm; combinationRule: Form blend;
		colorMap: (srcForm colormapIfNeededFor: form);
		clipRect: clipRect;
		cellSize: cellSize;
		copyQuad: srcQuad toRect: dstBox.
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6249-AvoidSomeBitBltRoundingWarnings-JuanVuletich-2024Mar04-15h14m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6248] on 4 March 2024 at 3:21:51 pm'!
!CharacterSequence class methodsFor: 'fileman-constants' stamp: 'jmv 3/4/2024 15:19:36'!
                  pathSeparators
	^'\/'! !
!Character methodsFor: 'fileman-testing' stamp: 'jmv 3/4/2024 15:20:36' prior: 16811130!
              isPathSeparator

	^CharacterSequence pathSeparators includes: self! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 3/4/2024 15:20:00' prior: 16814297!
                      asPathTokens

	^self beginsWithWindowsDriveName
		ifTrue: [
			(OrderedCollection with: (self copyFrom: 1 to: 2)), 
				((self copyFrom: 3 to: self size) findTokens: CharacterSequence pathSeparators) ]
		ifFalse: [
			self findTokens: CharacterSequence pathSeparators ]! !
!CharacterSequence methodsFor: 'fileman-testing' stamp: 'jmv 3/4/2024 15:21:01' prior: 16814359!
              isPathSeparator
	^self size = 1 and: [ self first isPathSeparator ]! !

String class removeSelector: #pathSeparators!

!methodRemoval: String class #pathSeparators stamp: 'Install-6250-ColonNoLongerAPathSeparator-JuanVuletich-2024Mar04-15h16m-jmv.001.cs.st 3/4/2024 18:17:15'!
pathSeparators
	^'\:/'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6250-ColonNoLongerAPathSeparator-JuanVuletich-2024Mar04-15h16m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6248] on 4 March 2024 at 3:22:23 pm'!
!Array methodsFor: 'printing' stamp: 'chaider 3/3/2024 11:51:39' prior: 16782812 overrides: 16783353!
                             storeOn: aStream 
	"Use the literal form if possible."

	self isLiteral
		ifTrue: [
			aStream nextPut: $#; nextPut: $(.
			self
				do: [ :element | 
					element storeOn: aStream ]
				separatedBy: [.
					aStream space ].
			aStream nextPut: $)]
		ifFalse: [super storeOn: aStream]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6251-Array-storeOn-removeTrailingBlank-ChristianHaider-2024Mar04-15h21m-chaider.001.cs.st----!

'From Cuis6.3 [latest update: #6251] on 4 March 2024 at 3:33:50 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 3/4/2024 15:32:42' prior: 16963981!
      knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 						'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 						'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'						'Christian Haider')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 						'Fernando Olivero')
	#('FernanodOlivero' 						'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 						'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 						'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 						'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 						'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 						'Marcus Denker')
	#('marcus.denker' 						'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 						'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 					'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 						'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('pmon'						'Paolo Montrasi')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 		'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 						'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'						'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'						'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'						'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'						'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'						'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 						'Stephane Ducasse')
	#('stephaneducasse'	 					'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 						'Masato Sumi')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 						'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 						'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6252-AddChristianHaiderAsKnownAuthor-JuanVuletich-2024Mar04-15h32m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6252] on 4 March 2024 at 5:38:06 pm'!
!TheWorldMenu methodsFor: 'menu' stamp: 'jmv 3/4/2024 17:23:34'!
    openPackageInstaller
	"In PackageInstaller.pck"
	Smalltalk at: #PackageInstallerWindow ifAbsent: [ 
		(PopUpMenu 
		confirm: 'The Package Installer is not loaded', String newLineString, 'Would you like me to load it for you now?')
		ifTrue: [Feature require: #PackageInstaller ] 
	].
	Smalltalk at: #PackageInstallerWindow ifPresent: [ :cls | ^cls open ].
	self inform: 'Please install optional package PackageInstaller.pck.st', String newLineString, 'Feature require: #''PackageInstaller'' '! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/4/2024 17:29:19' prior: 16984109!
                additionalMenuOptions

	^`{
		{
			#submenuOf  				-> 		TheWorldMenu openLabel.
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		30.
			#label 				->		'Package Installer'.
			#selector 				-> 		#openPackageInstaller.
			#icon 				-> 		#packageIcon.
			#balloonText 				-> 		'A tool for installing Cuis packages from the local file system.'.
		} asDictionary.
		{
			#submenuOf  				-> 		TheWorldMenu openLabel.
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		40.
			#label 				->		'Package Downloader'.
			#selector 				-> 		#openPackageDownloader.
			#icon 				-> 		#packageIcon.
			#balloonText 				-> 		'A tool for downloading Cuis packages from the internet.'.
		} asDictionary.
	}`	
	! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/4/2024 17:29:57' prior: 50353849!
        worldMenuOptions

	^`
		TheWorldMenu worldMainMenuOptions,
		"TheWorldMenu additionalMenuOptions,"
		TheWorldMenu preferencesMenuOptions,
		TheWorldMenu windowsMenuOptions,
		TheWorldMenu helpMenuOptions,
		TheWorldMenu changesMenuOptions,
		TheWorldMenu debugMenuOptions`.! !

Smalltalk removeClassNamed: #PackageInstaller!

!classRemoval: #PackageInstaller stamp: 'Install-6253-RemovePackageInstallerFromBaseImage-JuanVuletich-2024Mar04-17h35m-jmv.001.cs.st 3/4/2024 18:17:15'!
Object subclass: #PackageInstaller
	instanceVariableNames: 'packageList'
	classVariableNames: 'PackageList'
	poolDictionaries: ''
	category: 'Tools-Packages'!

Smalltalk removeClassNamed: #PackageInstallerWindow!

!classRemoval: #PackageInstallerWindow stamp: 'Install-6253-RemovePackageInstallerFromBaseImage-JuanVuletich-2024Mar04-17h35m-jmv.001.cs.st 3/4/2024 18:17:15'!
SystemWindow subclass: #PackageInstallerWindow
	instanceVariableNames: 'filterString filterInput currentIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Packages'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6253-RemovePackageInstallerFromBaseImage-JuanVuletich-2024Mar04-17h35m-jmv.001.cs.st----!

----QUIT----(4 March 2024 18:17:20) Cuis6.3-6253.image priorSource: 702792!

----STARTUP---- (11 March 2024 16:01:55) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis6.3-6253.image!


'From Cuis6.3 [latest update: #6253] on 6 March 2024 at 11:08:43 am'!
!Sample04Pacman methodsFor: 'updating' stamp: 'jmv 3/6/2024 11:08:05' prior: 16944345 overrides: 16907028!
                          redrawNeeded
	"for experimenting with collision detection"

	self isOwnedByHand ifTrue: [
		self world ifNotNil: [ :w |
			w submorphsDo: [ :m |
				((m is: #SystemWindow) not and: [self collides: m]) ifTrue: [
					m class == self class
						ifTrue: [ m colorize ]
						ifFalse: [ m delete ]]]]].
	super redrawNeeded.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6254-Sample04Pacman-fix-JuanVuletich-2024Mar06-11h08m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6254] on 11 March 2024 at 12:54:19 pm'!
!FileSystemEntry methodsFor: 'accessing' stamp: 'jmv 3/11/2024 11:41:44'!
         ancestors
	| ord par |
	par := self parent.
	ord := OrderedCollection with: par.
	[par isRoot] whileFalse: [
		par := par parent.
		ord add: par.
	].
	^ord! !
!FileSystemEntry methodsFor: 'accessing' stamp: 'jmv 3/11/2024 11:16:38'!
                       commonAncestorWith: aFileSystemEntry
	"
	DirectoryEntry currentDirectory commonAncestorWith:  DirectoryEntry projectBaseDirectory
	"
	| i lastI theirPathComponents |
	self drive = aFileSystemEntry drive
		ifFalse: [ ^nil ].
	i := 1.
	theirPathComponents := aFileSystemEntry pathComponents.
	lastI := pathComponents size min: theirPathComponents size.
	[i <= lastI and: [(pathComponents at: i) = (theirPathComponents at: i)]] whileTrue: [
		i := i + 1 ].
	^DirectoryEntry
				withPathComponents: (pathComponents copyFrom: 1 to: i-1)
				drive: self drive
		! !
!DirectoryEntry methodsFor: 'accessing' stamp: 'jmv 3/11/2024 11:48:34'!
       isAncestorOf: aFileSystemEntry
	| theirPathComponents size |
	size := pathComponents size.
	theirPathComponents := aFileSystemEntry pathComponents.
	theirPathComponents size > size ifFalse: [
		^false ].
	1 to: size do: [ :index |
		(pathComponents at: index) = (theirPathComponents at: index) ifFalse: [^ false]].
	^ true! !

FileSystemEntry removeSelector: #parents!

!methodRemoval: FileSystemEntry #parents stamp: 'Install-6255-FileSystemEntry-tweaks-JuanVuletich-2024Mar11-12h52m-jmv.001.cs.st 3/11/2024 16:02:00'!
parents
	| ord par |
	par := self parent.
	ord := OrderedCollection with: par.
	[par isRoot] whileFalse: [
		par := par parent.
		ord add: par.
	].
	^ord!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6255-FileSystemEntry-tweaks-JuanVuletich-2024Mar11-12h52m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6255] on 11 March 2024 at 1:09:46 pm'!
!FileListWindow methodsFor: 'menu building' stamp: 'jmv 3/11/2024 13:07:16' prior: 16863269!
                    volumeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu := MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon :: setBalloonText: 'Delete the selected directory'.
	aMenu
		add: model showHidden asMenuItemTextPrefix, 'show hidden folders and files'
		action: #toggleShowHidden ::
		setBalloonText: 'show or hide files and directories that begin with a dot'.
	initialDirectoriesMenu := MenuMorph new.
	#(
		(roots  'default roots' 'Use the usual root directories. Drives on Windows; "/" on Unix')
	   	(image 'image directory' 'Use the directory with Smalltalk image')
		(vm 'VM directory' 'Use the virtual machine directory')
		(current 'current directory' 'Use the current directory; usually the directory the VM was started in')
	)
		do: [ :entry |
			initialDirectoriesMenu
				add: entry second
				target: Preferences
				action: #at:put:
				argumentList: {#initialFileListDirectories . entry first} ::
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu! !

PreferenceSet class removeSelector: #isInitialFileListDirectory:!

!methodRemoval: PreferenceSet class #isInitialFileListDirectory: stamp: 'Install-6256-Cleanup-JuanVuletich-2024Mar11-13h07m-jmv.001.cs.st 3/11/2024 16:02:00'!
isInitialFileListDirectory: aDirectoryEntry
	"Answer true if aDirectoryEntry is an initial directory entry."

	| currentValue |
	(currentValue := Preferences at: #initialFileListDirectories) isSymbol 		ifTrue: [ ^ false ].
	^ currentValue includes: aDirectoryEntry!

FileList removeSelector: #toggleInitialDirectory!

!methodRemoval: FileList #toggleInitialDirectory stamp: 'Install-6256-Cleanup-JuanVuletich-2024Mar11-13h07m-jmv.001.cs.st 3/11/2024 16:02:00'!
toggleInitialDirectory
	"Toggle the initial directory setting of the currently selected directory."
	
	
"
	Preferences isInitialFileListDirectory: (directoryEntry := currentDirectorySelected item)::
		ifTrue: [
			Preferences removeInitialFileListDirectory: directoryEntry ]
		ifFalse: [
			Preferences addInitialFileListDirectory: directoryEntry ]
"!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6256-Cleanup-JuanVuletich-2024Mar11-13h07m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6255] on 11 March 2024 at 1:28:15 pm'!

TextProvider subclass: #FileList
	instanceVariableNames: 'acceptedContentsCache fileName directory list listIndex pattern sortMode brevityState sortAscending showDirsInFileList currentDirectorySelected showHidden topDirectories '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

!classDefinition: #FileList category: #'Tools-FileList' stamp: 'Install-6257-FileList-topDirectories-JuanVuletich-2024Mar11-13h09m-jmv.001.cs.st 3/11/2024 16:02:00'!
TextProvider subclass: #FileList
	instanceVariableNames: 'acceptedContentsCache fileName directory list listIndex pattern sortMode brevityState sortAscending showDirsInFileList currentDirectorySelected showHidden topDirectories'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!
!FileList methodsFor: 'initialization' stamp: 'jmv 3/11/2024 13:18:25' prior: 16862362!
          initialDirectoryList

	topDirectories := (Preferences at: #initialFileListDirectories) 
		caseOf: {
			[ #cuis ]  		-> 	[ | topDirectoryToUse |
				topDirectoryToUse := directory. "must be inside the tree of some of the included!!"
				topDirectoryToUse := topDirectoryToUse commonAncestorWith: DirectoryEntry projectBaseDirectory.
				topDirectoryToUse := topDirectoryToUse commonAncestorWith: DirectoryEntry userBaseDirectory.
				topDirectoryToUse := topDirectoryToUse commonAncestorWith: DirectoryEntry cuisBaseDirectory.
				topDirectoryToUse := topDirectoryToUse commonAncestorWith: DirectoryEntry currentDirectory.
				{ topDirectoryToUse} ].
			[ #roots ] -> [ DirectoryEntry roots ].
			}.
	^topDirectories collect: [ :dir |
		FileDirectoryWrapper with: dir name: (dir name ifNil: [ '/' ]) model: self ]! !
!FileList methodsFor: 'private' stamp: 'jmv 3/11/2024 13:27:49' prior: 16862805!
                               postOpen
"Ojo, ver que pasa con drive en Windows"
| top |
	directory ifNotNil: [
		top := topDirectories detect: [ :any | any isAncestorOf: directory ].
		top pathComponents size = 0 ifTrue: [
			^self changed: #(openPath), {directory drive}, directory pathComponents
			].
		self changed: #(openPath), 
		(
		directory pathComponents copyFrom: (top pathComponents size
		) to: directory pathComponents size)
		]! !
!FileList methodsFor: 'private' stamp: 'jmv 7/20/2016 10:34:35' prior: 16862943!
               setSelectedDirectoryTo: aFileDirectoryWrapper
	currentDirectorySelected := aFileDirectoryWrapper.
	self directory: aFileDirectoryWrapper withoutListWrapper.
	brevityState := #FileList.
	self changed: #fileList.
	self acceptedContentsChanged.
	self changed: #currentDirectorySelected! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 3/11/2024 13:18:41' prior: 50331891!
     prefSystem
	^ #( #(allowNonLocalReturnsInExceptionHandlers true )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges true )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #cuis #(cuis roots) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(useUserPrefsFile true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
	)! !
!FileListWindow methodsFor: 'menu building' stamp: 'jmv 3/11/2024 13:20:42' prior: 50354526!
               volumeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu := MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon :: setBalloonText: 'Delete the selected directory'.
	aMenu
		add: model showHidden asMenuItemTextPrefix, 'show hidden folders and files'
		action: #toggleShowHidden ::
		setBalloonText: 'show or hide files and directories that begin with a dot'.
	initialDirectoriesMenu := MenuMorph new.
	#(
		(cuis  		'Cuis top' 'Use the default Cuis top directory')
		(roots  		'OS roots' 'Use the host OS root directories. Drives on Windows; "/" on Unix')
	)
		do: [ :entry |
			initialDirectoriesMenu
				add: entry second
				target: Preferences
				action: #at:put:
				argumentList: {#initialFileListDirectories . entry first} ::
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu! !

TextProvider subclass: #FileList
	instanceVariableNames: 'acceptedContentsCache fileName directory list listIndex pattern sortMode brevityState sortAscending showDirsInFileList currentDirectorySelected showHidden topDirectories'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

!classDefinition: #FileList category: #'Tools-FileList' stamp: 'Install-6257-FileList-topDirectories-JuanVuletich-2024Mar11-13h09m-jmv.001.cs.st 3/11/2024 16:02:00'!
TextProvider subclass: #FileList
	instanceVariableNames: 'acceptedContentsCache fileName directory list listIndex pattern sortMode brevityState sortAscending showDirsInFileList currentDirectorySelected showHidden topDirectories'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-FileList'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Preferences at: #initialFileListDirectories put: #cuis!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6257-FileList-topDirectories-JuanVuletich-2024Mar11-13h09m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6257] on 11 March 2024 at 2:52:01 pm'!
!FileList methodsFor: 'initialization' stamp: 'jmv 3/11/2024 14:45:13'!
                            topDirectoryWrappers

	topDirectories := (Preferences at: #initialFileListDirectories) 
		caseOf: {
			[ #cuis ]  		-> 	[ | topDirectoryToUse |
				topDirectoryToUse := directory. "must be inside the tree of some of the included"
				(topDirectoryToUse commonAncestorWith: DirectoryEntry projectBaseDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				(topDirectoryToUse commonAncestorWith: DirectoryEntry userBaseDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				(topDirectoryToUse commonAncestorWith: DirectoryEntry cuisBaseDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				(topDirectoryToUse commonAncestorWith: DirectoryEntry currentDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				{ topDirectoryToUse} ].
			[ #roots ] -> [ DirectoryEntry roots ].
			}.
	^topDirectories collect: [ :dir |
		FileDirectoryWrapper with: dir name: (dir name ifNil: [ '/' ]) model: self ]! !
!FileListWindow methodsFor: 'menu building' stamp: 'jmv 3/11/2024 14:45:52'!
                             directoryTreeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu := MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon :: setBalloonText: 'Delete the selected directory'.
	aMenu
		add: model showHidden asMenuItemTextPrefix, 'show hidden folders and files'
		action: #toggleShowHidden ::
		setBalloonText: 'show or hide files and directories that begin with a dot'.
	initialDirectoriesMenu := MenuMorph new.
	#(
		(cuis  		'Cuis top' 'Use the default Cuis top directory')
		(roots  		'OS roots' 'Use the host OS root directories. Drives on Windows; "/" on Unix')
	)
		do: [ :entry |
			initialDirectoriesMenu
				add: entry second
				target: Preferences
				action: #at:put:
				argumentList: {#initialFileListDirectories . entry first} ::
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu! !
!FileList methodsFor: 'file menu action' stamp: 'jmv 3/11/2024 14:46:59' prior: 16862249!
       addNewDirectory

	self 
		addNew: 'directory'
		byEvaluating: [ :newName | (directory / newName) assureExistence ].
	self updateDirectory.
	self changed: #topDirectoryWrappers! !
!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 3/11/2024 14:47:05' prior: 16862576!
            deleteDirectory
	"Remove the currently selected directory"

	| newSelection |
	directory children isEmpty ifFalse: [ ^self inform:'Directory must be empty' ].
	(self confirm: 'Really delete ' , directory name , '?') ifFalse: [ ^ self ].
	newSelection := directory parent.
	directory delete.
	self directory: newSelection.
	self updateFileList.
	self updateDirectory.
	self changed: #topDirectoryWrappers! !
!FileList methodsFor: 'private' stamp: 'jmv 3/11/2024 14:51:44' prior: 50354656!
                        postOpen
	| pathRoot pathElements |
	directory ifNotNil: [
		pathRoot := topDirectories detect: [ :any | any isAncestorOf: directory ].
		pathElements := pathRoot pathComponents size = 0
			ifTrue: [ {directory drive}, directory pathComponents ]
			ifFalse: [ (directory pathComponents
					copyFrom: (pathRoot pathComponents size)
					to: directory pathComponents size) ].
		self changed: #(openPath), pathElements ]! !
!FileList methodsFor: 'user interface' stamp: 'jmv 3/11/2024 14:47:09' prior: 16863059!
  toggleShowHidden
	showHidden := showHidden not.
	self changed: #topDirectoryWrappers.
	self updateFileList.! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 3/11/2024 14:45:58' prior: 16863162!
                     morphicDirectoryTreePane

	^(HierarchicalListMorph
		model: model
		listGetter: #topDirectoryWrappers
		indexGetter: #currentDirectorySelected
		indexSetter: #setSelectedDirectoryTo:
		mainView: self
		menuGetter: #directoryTreeMenu
		keystrokeAction: nil)
			autoDeselect: false;
			yourself! !

FileListWindow removeSelector: #volumeMenu!

!methodRemoval: FileListWindow #volumeMenu stamp: 'Install-6258-cleanup-JuanVuletich-2024Mar11-14h45m-jmv.001.cs.st 3/11/2024 16:02:00'!
volumeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu := MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon :: setBalloonText: 'Delete the selected directory'.
	aMenu
		add: model showHidden asMenuItemTextPrefix, 'show hidden folders and files'
		action: #toggleShowHidden ::
		setBalloonText: 'show or hide files and directories that begin with a dot'.
	initialDirectoriesMenu := MenuMorph new.
	#(
		(cuis  		'Cuis top' 'Use the default Cuis top directory')
		(roots  		'OS roots' 'Use the host OS root directories. Drives on Windows; "/" on Unix')
	)
		do: [ :entry |
			initialDirectoriesMenu
				add: entry second
				target: Preferences
				action: #at:put:
				argumentList: {#initialFileListDirectories . entry first} ::
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu!

FileList removeSelector: #initialDirectoryList!

!methodRemoval: FileList #initialDirectoryList stamp: 'Install-6258-cleanup-JuanVuletich-2024Mar11-14h45m-jmv.001.cs.st 3/11/2024 16:02:00'!
initialDirectoryList

	topDirectories := (Preferences at: #initialFileListDirectories) 
		caseOf: {
			[ #cuis ]  		-> 	[ | topDirectoryToUse |
				topDirectoryToUse := directory. "must be inside the tree of some of the included!!"
				topDirectoryToUse := topDirectoryToUse commonAncestorWith: DirectoryEntry projectBaseDirectory.
				topDirectoryToUse := topDirectoryToUse commonAncestorWith: DirectoryEntry userBaseDirectory.
				topDirectoryToUse := topDirectoryToUse commonAncestorWith: DirectoryEntry cuisBaseDirectory.
				topDirectoryToUse := topDirectoryToUse commonAncestorWith: DirectoryEntry currentDirectory.
				{ topDirectoryToUse} ].
			[ #roots ] -> [ DirectoryEntry roots ].
			}.
	^topDirectories collect: [ :dir |
		FileDirectoryWrapper with: dir name: (dir name ifNil: [ '/' ]) model: self ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6258-cleanup-JuanVuletich-2024Mar11-14h45m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6254] on 10 March 2024 at 8:22:31 pm'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 3/10/2024 20:18:30' prior: 16885290!
              tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results
	0 tinyBenchmarks

For Pre-Squeak systems, measurements or estimations from
	https://smalltalkzoo.computerhistory.org/papers/EvolutionOfSmalltalk.pdf
										('The evolution of Smalltalk: from Smalltalk-72 through Squeak' by Dan Ingalls, p.98)
	http://wiki.c2.com/?GreenBook
	http://www.wirfs-brock.com/allen/things/smalltalk-things/tektronix-smalltalk-document-archive/1982-qtr4-magnolia-perf-graph.pdf
	http://www.wirfs-brock.com/allen/things/smalltalk-things/tektronix-smalltalk-document-archive/1983-Magnolia-st-perf.pdf

Xerox PARC systems
	Alto Smalltalk-72 5MHz µcode								694 bytecodes/sec						54 sends/sec					7200 µclocks/bytecode
	Alto Smalltalk-74 5MHz µcode								607 bytecodes/sec						46 sends/sec					8200 µclocks/bytecode
	Alto Smalltalk-76 5MHz µcode								16k bytecodes/sec						118 sends/sec					310 µclocks/bytecode
	NoteTaker Smalltalk-78 5MHz 8086								30k bytecodes/sec						250 sends/sec					166.67 clocks/bytecode
	Dorado Smalltalk-76 16.67MHz µcode								1M bytecodes/sec						50k sends/sec					16.67 µClocks/bytecode

Green Book systems
	DEC PDP-11/23								5k bytecodes/sec (Green Book, p.128)
	Apple 5MHz 68000								11k bytecodes/sec (Green Book, p.187, awb)											5000 clocks/bytecode
	VAX-11/780 5MHz C HP Smalltalk								10k bytecodes/sec (Green Book, p.235)											450 clocks/bytecode
	VAX-11/780 5MHz C Berkeley St								17k bytecodes/sec (Green Book, p.203, awb)											300 clocks/bytecode
	DEC VAX-11/780 5MHz assembly								20k bytecodes/sec (Green Book, p.149, awb)											250 clocks/bytecode
	TEK Magnolia 10MHz 68000								50k bytecodes/sec (awb)											200 clocks/bytecode

Squeak & Cuis
	110 MHz PowerPC Mac 8100								4.1M bytecodes/sec;						175k sends/sec					26.8 clocks/bytecode 
	292 MHz G3 Mac:								23M bytecodes/sec;						984k sends/sec					12.7 clocks/bytecode
	400 MHz PII/Win98:								18M bytecodes/sec;						1.08M sends/sec					22.2 clocks/bytecode

	1GHz RISCV Sipeed Lichee RV StackSpur64 35.56M bytecodes/sec;  														1.56M sends/sec  					28.1 clocks/bytecode

	900MHz RasPi2 - StackVM:								38M bytecodes/sec;						2.41M sends/sec					23.7 clocks/bytecode
	900MHz RasPi2- CogSSpur:								157M bytecodes/sec;						10.95M sends/sec					5.7 clocks/bytecode
	
	1GHz C.H.I.P. (*1) - StackVM:								55M bytecodes/sec;						3.35M sends/sec					18.2 clocks/bytecode
	1GHz C.H.I.P. (*1) - CogSpur:								254M bytecodes/sec;						16.85M sends/sec					3.9 clocks/bytecode
	
	1.2GHz RasPi3B - StackSpur:								44M bytecodes/sec;						2.77M sends/sec					27.2 clocks/bytecode
	1.2GHz RasPi3B - CogSpur:								282M bytecodes/sec;						16.40M sends/sec					4.3 clocks/bytecode

	1.66GHz Atom N450 - Cog:								244M bytecodes/sec;						28.80M sends/sec					6.8 clocks/bytecode
	1.66GHz Atom N450 - CogSpur:								470M bytecodes/sec;						30.75M sends/sec					3.5 clocks/bytecode

	1.33GHz Atom 3735G - Cog:								326M bytecodes/sec;						34.99M sends/sec					4.1 clocks/bytecode
	1.33GHz Atom 3735G - CogSpur:								632M bytecodes/sec;						33.69M sends/sec					2.1 clocks/bytecode

	1.5GHz AMD A4-5000 - Cog:								390M bytecodes/sec;						47.51M sends/sec					3.8 clocks/bytecode
	1.5GHz AMD A4-5000 - CogSpur:								676M bytecodes/sec;						40.67M sends/sec					2.2 clocks/bytecode
	1.5GHz AMD A4-5000 - CogSpur64:								659M bytecodes/sec;						50.34M sends/sec					2.3 clocks/bytecode

	1.5GHz ARM64 RasberryPi4 - CogSpur64: 732.5M bytecodes/sec;  														53.95M sends/sec					2.0 clocks/bytecode

	2.3GHz Tegra ARM64 (*2) - StackVM:								259M bytecodes/sec;						13.01M sends/sec					8.9 clocks/bytecode
	2.3GHz Tegra ARM64(*2) - CogSpur:								1.08G bytecodes/sec;						64.29M sends/sec					2.1 clocks/bytecode
	2.4GHz RasPi5 (ARM64)  								1.60G bytecodes/sec;  						140.00M sends/sec  					1.5 clocks/bytecode

	3.1GHz Core i3-2100 - Cog:								1.20G bytecodes/sec;						165.72M sends/sec					2.6 clocks/bytecode
	3.1GHz Core i3-2100 - CogSpur:								2.04G bytecodes/sec;						127.84M sends/sec					1.5 clocks/bytecode

	2.70GHz Core i5-6400 -CogSpur64								3.16G bytecodes/sec;						243.32M sends/sec					0.85 clocks/bytecode

	(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
	(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
	
It is interesting to note that Cog for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance,
i.e. around 100 Dorados.
	"
	| t1 t2 r n1 n2 |
	n1 := 1.
	[
		t1 := Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue: [n1 := n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 := 28.
	[
		t2 := Time millisecondsToRun: [r := n2 benchFib].
		t2 < 1000] 
			whileTrue: [n2 := n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^String streamContents: [ :strm |
		(n1 * 500000 * 1000) // t1 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Bytecodes/second; ' ].
		(r * 1000) // t2 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Sends/second' ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6259-AddRasPi5To-tinyBenchmarks-JuanVuletich-2024Mar10-20h18m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6259] on 11 March 2024 at 3:31:16 pm'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
MessageSetWindow allSubInstancesDo: [ :w | w delete ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6260-MessageSet-closeAllWindows-JuanVuletich-2024Mar11-15h31m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6254] on 8 March 2024 at 2:57:02 pm'!

CodeProvider subclass: #MethodSet
	instanceVariableNames: 'selectedMessage messageList shouldAutoHighlight autoHighlightString autoHighlightAllOccurrences'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

!classDefinition: #MethodSet category: #'Tools-Browser' stamp: 'Install-6261-MethodSet-JuanVuletich-2024Mar08-14h56m-jmv.002.cs.st 3/11/2024 16:02:00'!
CodeProvider subclass: #MethodSet
	instanceVariableNames: 'selectedMessage messageList shouldAutoHighlight autoHighlightString autoHighlightAllOccurrences'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!
!MethodSet commentStamp: '<historical>' prior: 0!
                I represent a query path of the retrieval result of making a query about methods in the system. The result is a set of methods, denoted by a message selector and the class in which the method was found. As a TextProvider, the string I represent is the source code of the currently selected method. I am typically viewed in a Message Set Browser consisting of a MessageListView and a BrowserCodeView.

Ivar messageList is a collection of MethodReferences.
Ivar selectedMessage is not as symbol (as in superclasses) but the selected MethodReference.!
!MethodSet methodsFor: 'accessing' stamp: 'jmv 3/8/2024 14:50:57'!
                        contents: input notifying: aRequestor 
	"Compile the code in aString. Notify aRequestor of any syntax errors. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."

	| codeString category selector class oldSelector |
	codeString := input string.
	self okayToAccept ifFalse: [^ false].
	selectedMessage ifNil: [^ false].
	class := selectedMessage actualClass.
	oldSelector := selectedMessage methodSymbol.
	(oldSelector notNil and: [oldSelector first isUppercase]) ifTrue: [
		oldSelector == #Comment ifTrue: [
			class comment: codeString stamp: Utilities changeStamp.
			self triggerEvent: #annotationChanged.
 			self changed: #clearUserEdits.
			^ false].
		oldSelector == #Definition ifTrue: [
			Compiler
				evaluate: codeString
				notifying: aRequestor
				logged: true.
			self changed: #clearUserEdits.
 			^ false]].
	"Normal method accept"
	category := class organization categoryOfElement: oldSelector.
	selector := class compile: codeString
				classified: category
				notifying: aRequestor.
	selector
		ifNil: [^ false].
	selector == oldSelector ifFalse: [
		self reformulateListNoting: selector].
	shouldAutoHighlight := true.
	self triggerEvent: #annotationChanged.
	^ true! !
!MethodSet methodsFor: 'accessing' stamp: 'jmv 3/8/2024 14:52:03' overrides: 16983543!
  contentsSelection
	"Return the interval of text in the code pane to select when I set the pane's contents"

	^nil! !
!MethodSet methodsFor: 'accessing' stamp: 'jmv 3/8/2024 14:52:09'!
        doItReceiver
	"This class's classPool has been jimmied to be the classPool of the class 
	being browsed. A doIt in the code pane will let the user see the value of 
	the class variables."

	^ self selectedClass! !
!MethodSet methodsFor: 'accessing' stamp: 'jmv 3/8/2024 14:50:57'!
       labelString
	^'Filtered: [',
		messageList size printString,
		']'.! !
!MethodSet methodsFor: 'accessing' stamp: 'jmv 3/8/2024 14:50:57'!
                      reformulateListNoting: newSelector
	"A method has possibly been submitted for the receiver with newSelector as its selector; If the receiver has a way of reformulating its message list, here is a chance for it to do so"

	^ self reformulateList! !
!MethodSet methodsFor: 'annotation' stamp: 'jmv 3/8/2024 14:52:24' overrides: 16825763!
                annotation
	"Provide a line of content for an annotation pane, representing information about the method associated with the selected class and selector in the receiver."

	|  aSelector aClass |
	(aClass := self selectedClassOrMetaClass)
		ifNil: [ ^ ''].
	(aSelector := self selectedMessageName)
		ifNil: [ ^ ''].
	^ self annotationForSelector: aSelector ofClass: aClass.! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
  addMethodReference: aMethodReference
	"Append a aMethodReference to the list.  Select the new item."

	messageList add: aMethodReference.
	self changed: #messageList.
	self messageListIndex: messageList size! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
       addMethodReference: aMethodReferenceToAdd ifIncluded: aBlockClosure

	(messageList includes: aMethodReferenceToAdd)
		ifTrue: aBlockClosure
		ifFalse: [ self addMethodReference: aMethodReferenceToAdd ]! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
             growable
	"Answer whether the receiver is capable of growing/shrinking dynamically"

	^ true! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
                          messageList
	"Answer the current list of messages."

	^messageList! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:53:02'!
                    messageListIndex
	"Answer the index of the selected message selector into the currently 
	selected message category."

	selectedMessage ifNil: [ ^0 ].
	^self messageList indexOf: selectedMessage! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
                    messageListIndex: anInteger

	"Set the index of the selected item to be anInteger."

	| list |
	
	list := self messageList.
	selectedMessage := (list isInBounds: anInteger) ifTrue: [ list at: anInteger ].
	shouldAutoHighlight := true.
	self changed: #messageListIndex.	 "update my selection"
	self changed: #editSelection.
	self acceptedContentsChanged! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
                      removeMessageFromBrowser
	"Remove the selected message from the browser."

	self removeMessageFromBrowserKeepingLabel.
	self changed: #relabel! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
        removeMessageFromBrowserKeepingLabel

	selectedMessage ifNil: [ ^nil ].
	self deleteFromMessageList: self selection.
	self reformulateList.
! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56' overrides: 16826822!
                      selectedMessage
	"Answer the source method for the currently selected message."

	| class selector |
	selectedMessage ifNil: [^ 'Class vanished'].
	
	class := selectedMessage actualClass.
	selector := selectedMessage methodSymbol.
	selector ifNil: [ ^'prims'].

	selector first isUppercase ifTrue: [
		selector == #Comment ifTrue: [
			currentCompiledMethod := class organization commentRemoteStr.
			^ class comment ].
		selector == #Definition ifTrue: [
			^ class definition ].].

	(class notNil and: [ class includesSelector: selector]) ifFalse: [
		currentCompiledMethod := nil.
		^ 'Missing'].

	self showingDecompile ifTrue: [
		^ self decompiledSource ].

	currentCompiledMethod := class compiledMethodAt: selector ifAbsent: nil.
	self showingDocumentation ifTrue: [
		^ self commentContents ].

	^self sourceStringPrettifiedAndDiffed! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56' overrides: 16826978!
                        selectedMessageName
	"Answer the name of the currently selected message."

	^selectedMessage ifNotNil: [ :methodReference | methodReference methodSymbol ]! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
                            sortByClassHierarchy
	"Sort the message-list by class / selector. List classes in hierarchical order."
	
	| aClass bClass classes classesAndPositions i |

	classes := Set new.
	messageList do: [ :methodReference |
		methodReference actualClass ifNotNil: [ :actualClass | classes add: actualClass ]].
	classesAndPositions := Dictionary new.
	i := 1.
	Smalltalk hierarchySorted: classes do: [ :each |
		classesAndPositions at: each put: i.
		i := i + 1 ].
	
	messageList := messageList sort: [ :a :b |
		(a classSymbol = b classSymbol and: [ b classIsMeta = b classIsMeta ])
			ifTrue: [
				a methodSymbol == #Comment
					ifTrue: [ true ]
					ifFalse: [
						b methodSymbol == #Comment
							ifTrue: [ false ]
							ifFalse: [ a methodSymbol < b methodSymbol ]]]
			ifFalse: [
				aClass := a actualClass.
				bClass := b actualClass.
				aClass isNil == bClass isNil
					ifTrue: [
						aClass isNil
							ifTrue: [a classSymbol < b classSymbol]
							ifFalse: [(classesAndPositions at: aClass) < (classesAndPositions at: bClass)]]
					ifFalse: [aClass isNil]]].
	messageList do: [ :each |
		each indentLevel:
			(each actualClass theNonMetaClass allSuperclasses select: [ :c |
				classesAndPositions includesKey: c ]) size ].
	self changed: #messageList.! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
     sortByClassName
	"Sort the message-list by class / selector"
	
	messageList := messageList sort: [ :a :b |
		a classSymbol = b classSymbol
			ifTrue: [
				a methodSymbol == #Comment
					ifTrue: [ true ]
					ifFalse: [
						b methodSymbol == #Comment
							ifTrue: [ false ]
							ifFalse: [
								a classIsMeta = b classIsMeta
									ifTrue: [ a methodSymbol < b methodSymbol ]
									ifFalse: [ a classIsMeta ]	]]]
			ifFalse: [ a classSymbol < b classSymbol ]
		].
	messageList do: [ :each | each removeStringVersionPrefix ].
	self changed: #messageList! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
                               sortByDate
	"Sort the message-list by date of time-stamp"

	| assocs aCompiledMethod aDate inOrder |
	assocs := messageList collect: [ :aRef |
		aDate := aRef methodSymbol == #Comment
			ifTrue: [
				aRef actualClass organization dateCommentLastSubmitted]
			ifFalse: [
				aCompiledMethod := aRef actualClass compiledMethodAt: aRef methodSymbol ifAbsent: nil.
				aCompiledMethod ifNotNil: [aCompiledMethod dateMethodLastSubmitted]].
		aRef -> (aDate ifNil: [Date fromString: '01/01/1996'])].  "The dawn of Squeak history"
	inOrder := assocs asArray sort: [ :a :b | a value < b value].

	inOrder do: [ :each | each key prefixStringVersionWith: each value yyyymmdd ].
	messageList := inOrder collect: [ :assoc | assoc key ].
	self changed: #messageList! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
     sortBySelector
	"Sort the message-list by selector / class"
	
	messageList := messageList sort: [ :a :b |
		a methodSymbol == #Comment
			ifTrue: [ true ]
			ifFalse: [
				b methodSymbol == #Comment
					ifTrue: [ false ]
					ifFalse: [
						a methodSymbol = b methodSymbol
							ifTrue: [
								a classSymbol = b classSymbol
									ifTrue: [ a classIsMeta ]
									ifFalse: [ a classSymbol < b classSymbol ]]
							ifFalse: [ a methodSymbol < b methodSymbol ]]]
		].
	messageList do: [ :each | each prefixStringVersionWith: each methodSymbol ].
	self changed: #messageList! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:50:56'!
              sortReverse
	"Reverse the current sort order"
	messageList := messageList reversed .
	self changed: #messageList! !
!MethodSet methodsFor: 'message functions' stamp: 'jmv 3/8/2024 14:50:56'!
 deleteFromMessageList: aMethodReference
	"Delete the given message from the receiver's message list"

	messageList := messageList copyWithout: aMethodReference! !
!MethodSet methodsFor: 'message functions' stamp: 'jmv 3/8/2024 14:50:57' overrides: 16826093!
                              methodCategoryChanged
	self triggerEvent: #annotationChanged! !
!MethodSet methodsFor: 'message functions' stamp: 'jmv 3/8/2024 14:50:57'!
                     reformulateList
	"The receiver's messageList has been changed; rebuild it"

	self messageListIndex: 0.
	self initializeMessageList: messageList.
	self changed: #messageList.
	self changed: #messageListIndex.
	self acceptedContentsChanged! !
!MethodSet methodsFor: 'message functions' stamp: 'jmv 3/8/2024 14:50:57'!
    removeMessage
	"Remove the selected message from the system. 1/15/96 sw"
	| messageName confirmation |
	selectedMessage ifNil: [ ^self ].
	messageName := self selectedMessageName.
	confirmation := Smalltalk confirmRemovalOf: messageName on: self selectedClassOrMetaClass.
	confirmation = 3
		ifTrue: [^ self].
	self selectedClassOrMetaClass removeSelector: messageName.
	self deleteFromMessageList: self selection.
	self reformulateList.
	confirmation = 2
		ifTrue: [Smalltalk browseAllCallsOn: messageName]! !
!MethodSet methodsFor: 'class list' stamp: 'jmv 3/8/2024 14:50:57'!
                             metaClassIndicated
	"Answer the boolean flag that indicates whether
	this is a class method."

	^ self selectedClassOrMetaClass isMeta! !
!MethodSet methodsFor: 'class list' stamp: 'jmv 3/8/2024 14:50:57' overrides: 16826970!
                              selectedClass 
	"Return the base class for the current selection.  1/17/96 sw fixed up so that it doesn't fall into a debugger in a msg browser that has no message selected"

	^ self selectedClassOrMetaClass
		ifNotNil: [ :c | c theNonMetaClass]! !
!MethodSet methodsFor: 'class list' stamp: 'jmv 3/8/2024 14:50:57' overrides: 16826973!
               selectedClassOrMetaClass
	"Answer the currently selected class (or metaclass)."

	^selectedMessage ifNotNil: [ :methodReference | methodReference actualClass ]! !
!MethodSet methodsFor: 'class list' stamp: 'jmv 3/8/2024 14:50:57' overrides: 16826098!
     selectedMessageCategoryName 
	"Answer the name of the selected message category or nil."
	"Ver si esta implementacion loca se usa. Si no se usa, eliminar todas (intentarlo!!)"
	selectedMessage ifNil: [ ^nil ].
	^ self selectedClassOrMetaClass organization categoryOfElement: self selectedMessageName! !
!MethodSet methodsFor: 'contents' stamp: 'jmv 3/8/2024 14:50:57' overrides: 16826114!
                           acceptedStringOrText
	"Answer the contents of the receiver"
	^selectedMessage
		ifNil: [
			currentCompiledMethod := nil.
			'']
		ifNotNil: [
			self showingByteCodes
				ifTrue: [ self selectedBytecodes ]
				ifFalse: [ self selectedMessage ]]! !
!MethodSet methodsFor: 'breakpoints' stamp: 'jmv 3/8/2024 14:52:49'!
  toggleBreakOnEntry
	"Install or uninstall a halt-on-entry breakpoint"

	| selectedMethod |
	self selectedClassOrMetaClass ifNil: [ ^self ].
	selectedMethod := self selectedClassOrMetaClass >> self selectedMessageName.
	selectedMethod hasBreakpoint
		ifTrue:
			[ selectedMethod uninstall ]
		ifFalse:
			[ BreakingMethodWrapper on: selectedMethod :: install ].
	self
		changed: #messageList;
		changed: #annotation! !
!MethodSet methodsFor: 'testing' stamp: 'jmv 3/8/2024 14:53:53' overrides: 16826962!
         isEditingMethod

	^selectedMessage notNil! !
!MethodSet methodsFor: 'testing' stamp: 'jmv 3/8/2024 14:53:57'!
                  isEditingNone

	^selectedMessage isNil! !
!MethodSet methodsFor: 'private' stamp: 'jmv 3/8/2024 14:50:57'!
                     initializeMessageList: anArray

	messageList := anArray.
	messageList isEmpty
		ifTrue: [ selectedMessage := nil ]
		ifFalse: [ self messageListIndex: 1 ]! !
!MethodSet methodsFor: 'private' stamp: 'jmv 3/8/2024 14:50:57'!
 selection
	"Answer the item in the list that is currently selected, or nil if no selection is present"

	^ selectedMessage! !
!MethodSet methodsFor: 'private' stamp: 'jmv 3/8/2024 14:50:57'!
 setFilteredList: newList
	"Establish newList as the new list if appropriate, and adjust the window title accordingly; if the new list is of the same size as the old, warn and do nothing"

	newList isEmpty
		ifTrue: [
			^ self inform: 'Nothing would be left in the list if you did that'].
	newList size = messageList size
		ifTrue: [
			^ self inform: 'That leaves the list unchanged'].
	self initializeMessageList: newList.
	self changed: #relabel! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                         filterFrom: aBlock
	"Filter the receiver's list down to only those items that satisfy aBlock, which takes a class an a selector as its arguments."
	
	self setFilteredList: (messageList select: [ :methodReference |
		aBlock
			value: methodReference actualClass
			value: methodReference methodSymbol ])! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
           filterToAnyChangeSet
	"Filter down only to messages present in ANY change set"

	self filterFrom: [ :aClass :aSelector |
		ChangeSet doesAnyChangeSetHaveClass: aClass andSelector: aSelector ]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                          filterToCommentedMethods
	"Filter the receiver's list down to only those items which have comments"

	self filterFrom:
		[:aClass :aSelector |
			(aClass selectors includes: aSelector) and:
						[(aClass firstPrecodeCommentFor: aSelector) isEmptyOrNil not]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                       filterToCurrentAuthor
	"Filter down only to messages with my initials as most recent author"

	| myInitials aMethod aTimeStamp |
	(myInitials := Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].
	self filterFrom:
		[:aClass :aSelector |
			(aClass notNil and: [aSelector notNil]) and:			
				[aMethod := aClass compiledMethodAt: aSelector ifAbsent: nil.
				aMethod notNil and:
					[(aTimeStamp := aMethod timeStamp) notNil and:
						[aTimeStamp beginsWith: myInitials]]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                  filterToImplementorsOf
	"Filter the receiver's list down to only those items with a given selector."

	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol | 
				self filterFrom:
					[:aClass :aSelector |
						aSelector == aSymbol]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                    filterToMessagesInChangesFile
	"Filter down only to messages whose source code risides in the Changes file.  This allows one to ignore long-standing methods that live in the .sources file."

	| cm |
	self filterFrom:
		[:aClass :aSelector |
			aClass notNil and: [aSelector notNil and:
				[(self class isPseudoSelector: aSelector) not and:
					[(cm := aClass compiledMethodAt: aSelector ifAbsent: nil) notNil and:
					[cm fileIndex ~= 1]]]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                             filterToMessagesInSourcesFile
	"Filter down only to messages whose source code resides in the .sources file."

	| cm |
	self filterFrom: [:aClass :aSelector |
		(aClass notNil and: [aSelector notNil]) and:
			[(self class isPseudoSelector: aSelector) not and:
				[(cm := aClass compiledMethodAt: aSelector ifAbsent: nil) notNil and:
					[cm fileIndex = 1]]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                 filterToMessagesWithPriorVersions
	"Filter down only to messages which have at least one prior version"

	self filterFrom:
		[:aClass :aSelector |
			(aClass notNil and: [aSelector notNil]) and:
				[(self class isPseudoSelector: aSelector) not and:
					[(VersionsBrowser versionCountForSelector: aSelector class: aClass) > 1]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                filterToMessagesWithoutPriorVersions
	"Filter down only to messages which have no prior version stored"

	self filterFrom:
		[:aClass :aSelector |
			(aClass notNil and: [aSelector notNil]) and:
				[(self class isPseudoSelector: aSelector) not and:
					[(VersionsBrowser versionCountForSelector: aSelector class: aClass) <= 1]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
               filterToNotAnyChangeSet
	"Filter down only to messages present in NO change set"

	self filterFrom: [ :aClass :aSelector |
		(ChangeSet doesAnyChangeSetHaveClass: aClass andSelector: aSelector) not ]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                  filterToNotCurrentAuthor
	"Filter down only to messages not stamped with my initials"

	| myInitials aMethod aTimeStamp |
	(myInitials := Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].
	self filterFrom:
		[:aClass :aSelector |
			(aClass notNil and: [aSelector notNil]) and:			
				[aMethod := aClass compiledMethodAt: aSelector ifAbsent: nil.
				aMethod notNil and:
					[(aTimeStamp := aMethod timeStamp) isNil or:
						[(aTimeStamp beginsWith: myInitials) not]]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                     filterToNotImplementorsOf
	"Filter the receiver's list down to only those items whose selector is NOT one solicited from the user."

	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol | 
				self filterFrom:
					[:aClass :aSelector |
						aSelector ~~ aSymbol]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                     filterToNotSendersOf
	"Filter the receiver's list down to only those items which do not send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol |
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) isNil or:
							[(aMethod hasLiteralThorough: aSymbol) not]]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
     filterToSendersOf
	"Filter the receiver's list down to only those items which send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol | 
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) notNil and:
							[aMethod hasLiteralThorough: aSymbol]]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                  filterToUncommentedMethods
	"Filter the receiver's list down to only those items which lack comments"

	self filterFrom:
		[:aClass :aSelector |
			(aClass selectors includes: aSelector) and:
						[(aClass firstPrecodeCommentFor: aSelector) isEmptyOrNil]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 3/8/2024 14:50:57'!
                         filterToUnsentMessages
	"Filter the receiver's list down to only those items which have no  
	senders"
	self filterFrom: [ :aClass :aSelector |
		(Smalltalk isThereAReferenceTo: aSelector) not ].! !
!MethodSet methodsFor: 'shout styling' stamp: 'jmv 3/8/2024 14:50:57'!
                  autoHighlightAllOccurrences
	"Should also highlight any and all occurrences of the string?"

	^ autoHighlightAllOccurrences.! !
!MethodSet methodsFor: 'shout styling' stamp: 'jmv 3/8/2024 14:50:57'!
                         autoHighlightString
	"Return the string to be automatically highlighted."

	^ autoHighlightString.! !
!MethodSet methodsFor: 'shout styling' stamp: 'jmv 3/8/2024 14:50:57'!
                   autoHighlightString: aString allOccurrences: aBoolean
	"Set the string to be automatically highlighted."

	shouldAutoHighlight := true.
	autoHighlightString := aString.
	autoHighlightAllOccurrences := aBoolean.! !
!MethodSet methodsFor: 'shout styling' stamp: 'jmv 3/8/2024 14:50:57'!
   justDidAutoHighlight
	"Don't do autoHighlight unless accepted contents are updated."
	shouldAutoHighlight := false! !
!MethodSet methodsFor: 'shout styling' stamp: 'jmv 3/8/2024 14:50:57'!
   messageSendsRangesOf: aSelector

	^ selectedMessage 
		ifNil: [ #() ]
		ifNotNil: [selectedMessage messageSendsRangesOf: aSelector ]! !
!MethodSet methodsFor: 'shout styling' stamp: 'jmv 3/8/2024 14:50:57' overrides: 16983567!
                             shouldAutoHighlight
	"Answer true if we do auto highlight, and it is appropriate to do it now."
	^shouldAutoHighlight! !
!MethodSet methodsFor: 'shout styling' stamp: 'jmv 3/8/2024 14:50:57' overrides: 16826996!
            shouldStyle: text with: anSHTextStyler
	"This is a notification that anSHTextStyler is about to re-style its text.
	Set the classOrMetaClass in anSHTextStyler, so that identifiers
	will be resolved correctly.
	Answer true to allow styling to proceed, or false to veto the styling"
	
	self isModeStyleable ifFalse: [ ^false ].
	anSHTextStyler classOrMetaClass: self selectedClassOrMetaClass.
	^true! !
!MethodSet methodsFor: 'initialization' stamp: 'jmv 3/8/2024 14:50:57' overrides: 16932297!
                   initialize

	super initialize.
	shouldAutoHighlight := false.! !
!MethodSet methodsFor: 'run tests' stamp: 'jmv 3/8/2024 14:53:24'!
                            debugMethodTest
	
	currentCompiledMethod isTestMethod ifTrue: [
		currentCompiledMethod methodClass debugAsFailure: currentCompiledMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]
! !
!MethodSet methodsFor: 'run tests' stamp: 'jmv 3/8/2024 14:53:29'!
                          runMethodTest
	
	| suite |
	
	suite := TestSuite forCompiledMethod: currentCompiledMethod.
	(ProgressiveTestRunner for: suite) value! !
!MethodSet class methodsFor: 'instance creation' stamp: 'jmv 3/8/2024 14:50:57'!
       messageList: anArray 
	"Answer an instance of me with message list anArray."

	^self new initializeMessageList: anArray! !
!MethodSet class methodsFor: 'utilities' stamp: 'jmv 3/8/2024 14:50:57'!
                            isPseudoSelector: aSelector
	"Answer whether the given selector is a special marker"

	^ #(Comment Definition) statePointsTo: aSelector! !
!MethodSet class methodsFor: 'ui' stamp: 'jmv 3/8/2024 14:50:57'!
                   open
	^ MessageSetWindow openFullProtocolForClass: Object! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6261-MethodSet-JuanVuletich-2024Mar08-14h56m-jmv.002.cs.st----!

'From Cuis6.3 [latest update: #6254] on 8 March 2024 at 3:06:13 pm'!

MethodSet subclass: #MessageNames
	instanceVariableNames: 'searchString selectorList selectedSelector '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

!classDefinition: #MessageNames category: #'Tools-Browser' stamp: 'Install-6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st 3/11/2024 16:02:00'!
MethodSet subclass: #MessageNames
	instanceVariableNames: 'searchString selectorList selectedSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

MethodSet subclass: #ProtocolBrowser
	instanceVariableNames: 'baseClass selectiveClassList selectiveClassListIndex selectedName exclude '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

!classDefinition: #ProtocolBrowser category: #'Tools-Browser' stamp: 'Install-6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st 3/11/2024 16:02:00'!
MethodSet subclass: #ProtocolBrowser
	instanceVariableNames: 'baseClass selectiveClassList selectiveClassListIndex selectedName exclude'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

MethodSet subclass: #TimeProfileBrowser
	instanceVariableNames: 'tally talliesList '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!

!classDefinition: #TimeProfileBrowser category: #'Tools-Profiling' stamp: 'Install-6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st 3/11/2024 16:02:00'!
MethodSet subclass: #TimeProfileBrowser
	instanceVariableNames: 'tally talliesList'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!

MethodSet subclass: #ExtractMethodMessageSet
	instanceVariableNames: 'finder selectedIndex '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodMessageSet category: #'Tools-Refactoring' stamp: 'Install-6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st 3/11/2024 16:02:00'!
MethodSet subclass: #ExtractMethodMessageSet
	instanceVariableNames: 'finder selectedIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

MethodSet subclass: #InlineMethodMessageSendsSet
	instanceVariableNames: 'applier selectedIndex '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodMessageSendsSet category: #'Tools-Refactoring' stamp: 'Install-6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st 3/11/2024 16:02:00'!
MethodSet subclass: #InlineMethodMessageSendsSet
	instanceVariableNames: 'applier selectedIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!Browser methodsFor: 'testing' stamp: 'jmv 3/8/2024 14:15:03'!
                          isEditingNone

	^self editSelection = #none! !
!CodeProvider methodsFor: 'commands' stamp: 'jmv 3/8/2024 14:58:41' prior: 16826195!
                            hierarchyBrowser
	"Create and schedule a new hierarchy browser on the currently selected class or meta."

	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |
	(selectedClassOrMetaClass := self selectedClassOrMetaClass)
		ifNil: [^ nil].
	newBrowser := HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.
	((aSymbol := self selectedMessageName) notNil and: [(MethodSet isPseudoSelector: aSymbol) not])
		ifTrue: [
			aBehavior := selectedClassOrMetaClass.
			messageCatIndex := aBehavior organization numberOfCategoryOfElement: aSymbol.
			messageCatIndex = 0 ifFalse: [
				newBrowser messageCategoryListIndex: messageCatIndex + 1.
				newBrowser messageListIndex:
					((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol) ]].
	^newBrowser! !
!TimeProfileBrowser methodsFor: 'message list' stamp: 'jmv 3/8/2024 14:25:47' prior: 16987460 overrides: 50355356!
messageListIndex: anInteger

	"Set the index of the selected item to be anInteger."
	
	selectedMessage := (talliesList isInBounds: anInteger) ifTrue: [ talliesList at: anInteger ].
	self changed: #messageListIndex.	 "update my selection"
	self changed: #editSelection.
	self acceptedContentsChanged! !
!ChangeList methodsFor: 'accessing' stamp: 'jmv 3/8/2024 14:58:45' prior: 16805048 overrides: 16826966!
          currentCompiledMethod
	"Actually, the CompiledMethod installed in the system that correspond to current selection"
	| selector |
	selector := self selectedMessageName.
	(selector isNil or: [ MethodSet isPseudoSelector: selector ]) ifTrue: [
		^nil ].
	^self selectedClassOrMetaClass compiledMethodAt: selector! !
!Behavior methodsFor: 'accessing method dictionary' stamp: 'jmv 3/8/2024 14:58:52' prior: 16788082!
   firstPrecodeCommentFor:  selector
	"If there is a comment in the source code at the given selector that preceeds the body of the method, return it here, else return nil"

	| parser source tree |
	"Behavior firstPrecodeCommentFor: #firstPrecodeCommentFor:"
	(MethodSet isPseudoSelector: selector)
		ifTrue: [
			"Not really a selector"
			^ nil].
	source := self sourceCodeAt: selector asSymbol ifAbsent: [^ nil].
	parser := self parserClass new.
	tree := 
		parser
			parse: source readStream
			class: self
			noPattern: false
			context: nil
			notifying: nil
			ifFail: [^ nil].
	^ (tree comment ifNil: [^ nil]) first! !
!SmartRefStream methodsFor: 'class changed shape' stamp: 'jmv 3/8/2024 14:59:00' prior: 16956237!
              conversionMethodsFor: classList
	| oldStruct newStruct list |
	"Each of these needs a conversion method.  Hard part is the comment in it.  Return a MethodSet."

	list := OrderedCollection new.
	classList do: [:cls |
		oldStruct := structures at: cls name ifAbsent: [#()].
		newStruct := (Array with: cls classVersion), (cls allInstVarNames).
		self writeConversionMethodIn: cls fromInstVars: oldStruct to: newStruct 
				renamedFrom: nil.
		list add: cls name, ' convertToCurrentVersion:refStream:'.
		].

	^ MethodSet new initializeMessageList: list.! !
!BrowserWindow methodsFor: 'updating' stamp: 'jmv 3/8/2024 12:48:07' prior: 16799804!
                               editSelectionChanged
	
	model isEditingNone
		ifTrue: [ self disableCodePaneEditing ]
		ifFalse: [ self enableCodePaneEditing]! !
!MessageSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 14:59:15' prior: 16898903!
openMessageList: methodReferences label: aString
	"Create a standard system view for the message set on the list, anArray.
	The label of the view is aString."

	| methodSet |
	methodSet := MethodSet messageList: methodReferences asArray.
	methodSet sortByClassHierarchy.
	^self open: methodSet label: aString.! !
!MessageSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 14:59:51' prior: 16898916!
         openMessageList: methodReferences label: labelString autoHighlight: autoHighlightString allOccurrences: aBoolean
	"Open a system view for a MethodSet on messageList."

	| methodSet |

	methodSet := MethodSet messageList: methodReferences asArray.
	methodSet sortByClassHierarchy.
	methodSet autoHighlightString: autoHighlightString allOccurrences: aBoolean.

	^self open: methodSet label: labelString ! !
!MessageSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 15:00:02' prior: 16898932!
             openMessageListUnsorted: methodReferences label: labelString
	"Open a system view for a MethodSet on messageList.
	Don't sort entries by default."

	| methodSet |

	methodSet := MethodSet messageList: methodReferences asArray.

	^self open: methodSet label: labelString ! !
!MessageSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 15:00:15' prior: 16898944!
                openMessageListUnsorted: methodReferences label: labelString autoHighlight: autoHighlightString allOccurrences: aBoolean
	"Open a system view for a MethodSet on messageList.
	Don't sort entries by default."

	| methodSet |

	methodSet := MethodSet messageList: methodReferences asArray.
	methodSet autoHighlightString: autoHighlightString allOccurrences: aBoolean.

	^self open: methodSet label: labelString ! !
!ChangeSorterWindow methodsFor: 'menu commands' stamp: 'jmv 3/8/2024 14:59:33' prior: 16810597!
    browseMethodConflicts
	"Check to see if any other change set also holds changes to any methods in the selected change set; if so, open a browser on all such."

	| aList |

	aList := model methodConflicts.
	aList isEmpty ifTrue: [
		^ self inform: 'No other change set has changes for any method in this change set.' ].

	MessageSetWindow
		open: (MethodSet messageList: aList)
		label: 'Methods in "', model changeSet name, '" that are also in other change sets (', aList size printString, ')'! !

BrowserWindow removeSelector: #isEditSelectionNone!

!methodRemoval: BrowserWindow #isEditSelectionNone stamp: 'Install-6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st 3/11/2024 16:02:00'!
isEditSelectionNone
		
	^ model editSelection = #none!

MethodSet subclass: #MessageNames
	instanceVariableNames: 'searchString selectorList selectedSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

!classDefinition: #MessageNames category: #'Tools-Browser' stamp: 'Install-6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st 3/11/2024 16:02:00'!
MethodSet subclass: #MessageNames
	instanceVariableNames: 'searchString selectorList selectedSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

MethodSet subclass: #ProtocolBrowser
	instanceVariableNames: 'baseClass selectiveClassList selectiveClassListIndex selectedName exclude'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

!classDefinition: #ProtocolBrowser category: #'Tools-Browser' stamp: 'Install-6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st 3/11/2024 16:02:00'!
MethodSet subclass: #ProtocolBrowser
	instanceVariableNames: 'baseClass selectiveClassList selectiveClassListIndex selectedName exclude'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

MethodSet subclass: #TimeProfileBrowser
	instanceVariableNames: 'tally talliesList'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!

!classDefinition: #TimeProfileBrowser category: #'Tools-Profiling' stamp: 'Install-6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st 3/11/2024 16:02:00'!
MethodSet subclass: #TimeProfileBrowser
	instanceVariableNames: 'tally talliesList'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Profiling'!

MethodSet subclass: #ExtractMethodMessageSet
	instanceVariableNames: 'finder selectedIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodMessageSet category: #'Tools-Refactoring' stamp: 'Install-6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st 3/11/2024 16:02:00'!
MethodSet subclass: #ExtractMethodMessageSet
	instanceVariableNames: 'finder selectedIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

MethodSet subclass: #InlineMethodMessageSendsSet
	instanceVariableNames: 'applier selectedIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodMessageSendsSet category: #'Tools-Refactoring' stamp: 'Install-6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st 3/11/2024 16:02:00'!
MethodSet subclass: #InlineMethodMessageSendsSet
	instanceVariableNames: 'applier selectedIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6262-useMethodSet-JuanVuletich-2024Mar08-14h57m-jmv.002.cs.st----!

'From Cuis6.3 [latest update: #6256] on 8 March 2024 at 3:44:43 pm'!

CodeWindow subclass: #MethodSetWindow
	instanceVariableNames: 'codePane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #MethodSetWindow category: #'Morphic-Tool Windows' stamp: 'Install-6263-MethodSetWindow-JuanVuletich-2024Mar08-15h43m-jmv.001.cs.st 3/11/2024 16:02:00'!
CodeWindow subclass: #MethodSetWindow
	instanceVariableNames: 'codePane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!
!MethodSetWindow commentStamp: '<historical>' prior: 0!
           Morphic view for MessageSet models. See category 'GUI building'.!
!MethodSetWindow methodsFor: 'GUI building' stamp: 'jmv 3/8/2024 15:31:36' overrides: 16827102!
                              buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons := LayoutMorph newColumn.
	(Preferences at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations := LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!MethodSetWindow methodsFor: 'GUI building' stamp: 'jmv 3/8/2024 15:37:02'!
  buildMorphicMessageList
	"Build a morphic message list, with #messageList as its list-getter"

	^PluggableListMorph
		model: model
		listGetter: #messageList
		indexGetter: #messageListIndex
		indexSetter: #messageListIndex:
		mainView: self
		menuGetter: #messageListMenu
		keystrokeAction: #messageListKey:from:! !
!MethodSetWindow methodsFor: 'GUI building' stamp: 'jmv 3/8/2024 15:31:36'!
                       buildMorphicWindow
	"Answer a morphic window with the given label that can display the receiver"

	| listPane desiredExtent desiredHeight wine availableHeight |
	listPane := self buildMorphicMessageList.
	desiredExtent := listPane desiredExtent.
	desiredHeight := desiredExtent y.
	wine := RealEstateAgent standardWindowExtent.
	availableHeight := wine y - self labelHeight - (borderWidth * 2).
	desiredExtent x > wine x ifTrue: [
		desiredHeight := desiredHeight + ScrollBar scrollbarThickness ].
	desiredHeight / availableHeight < 0.4
		ifTrue: [		"Number of items is small enough to make for a fixed list regardless of Window resize"
			self layoutMorph
				addMorph: listPane fixedHeight: desiredHeight;
				addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 1.0 ]
		ifFalse: [		"Number of items is large enough to prefer a list proportional to Window resize"
			self layoutMorph
				addMorph: listPane proportionalHeight: 0.4;
				addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.6.
			listPane limitLayoutHeight ].
	model changed: #editSelection! !
!MethodSetWindow methodsFor: 'GUI building' stamp: 'jmv 3/8/2024 15:32:26' overrides: 16827154!
       createCodePaneMorph
	
	codePane := super createCodePaneMorph.
	^codePane! !
!MethodSetWindow methodsFor: 'GUI building' stamp: 'jmv 3/8/2024 15:31:36' overrides: 16970691!
                    windowColor
	^ Theme current messageSet! !
!MethodSetWindow methodsFor: 'menu building' stamp: 'jmv 3/8/2024 15:31:36'!
        addExtraMenu2ItemsTo: options
	"The shifted selector-list menu is being built.  Add items specific to MessageSet"

	model growable ifTrue: [
		options add: `{
			#itemGroup 			-> 		40.
			#itemOrder 			-> 		31.		
			#label 			-> 		'remove from this browser'.
			#object 			-> 		#model.
			#selector 			-> 		#removeMessageFromBrowser.
			#icon 			-> 		#listRemoveIcon 
		} asDictionary`.
		options add:`{
			#itemGroup 			-> 		40.
			#itemOrder 			-> 		32.		
			#label 			-> 		'filter message list...'.
			#selector 			-> 		#filterMessageList.
			#icon 			-> 		#findIcon
		} asDictionary`	].

	options add: `{
			#itemGroup 			-> 		41.
			#itemOrder 			-> 		33.		
			#label 			-> 		'sort by class hierarchy'.
			#object 			-> 		#model.	
			#selector 			-> 		#sortByClassHierarchy.
			#icon 			-> 		#classIcon
		} asDictionary`.
	options add: `{
			#itemGroup 			-> 		41.
			#itemOrder 			-> 		34.		
			#label 			-> 		'sort by class name'.
			#object 			-> 		#model.	
			#selector 			-> 		#sortByClassName.
			#icon 			-> 		#classIcon
		} asDictionary`.
	options add: `{
			#itemGroup 			-> 		41.
			#itemOrder 			-> 		35.		
			#label 			-> 		'sort by selector'.
			#object 			-> 		#model.	
			#selector 			-> 		#sortBySelector.
			#icon 			-> 		#scriptIcon
		} asDictionary`.
	options add: `{
			#itemGroup 			-> 		41.
			#itemOrder 			-> 		36.		
			#label 			-> 		'sort by date'.
			#object 			-> 		#model.	
			#selector 			-> 		#sortByDate.
			#icon 			-> 		#dateIcon
		} asDictionary`.
	options add: `{
			#itemGroup 			-> 		41.
			#itemOrder 			-> 		37.		
			#label 			-> 		'reverse sort'.
			#object 			-> 		#model.	
			#selector 			-> 		#sortReverse.
			#icon 			-> 		#redoIcon
		} asDictionary`.

! !
!MethodSetWindow methodsFor: 'menu building' stamp: 'jmv 3/8/2024 15:36:56'!
        messageListMenu
	"Answer the message-list menu"

	^DynamicMenuBuilder buildTitled: 'Message Set' targeting: self collectingMenuOptionsWith: #messageSetMenuOptions.
	! !
!MethodSetWindow methodsFor: 'menu building' stamp: 'jmv 3/8/2024 15:32:42'!
          messageListMenu2
	"Fill aMenu with the items appropriate when the shift key is held down"

	self flag: #assumesKeyboardShortcuts.
	^DynamicMenuBuilder 
		buildTitled: 'Message Set' 
		targeting: self 
		collectingMenuOptionsWith: #messageSetMenu2Options 
		changingThemWith: [ :options |
			self addExtraMenu2ItemsTo: options.
			model canShowMultipleMessageCategories ifTrue: [	
				options add: `{ 
					#itemGroup 			-> 		40.
					#itemOrder 			-> 		45.		
					#label 			-> 		'show category (C)'.
					#object 			-> 		#model.
					#selector 			-> 		#showHomeCategory.
					#icon 			-> 		#packageIcon
				} asDictionary` ]].
		
	! !
!MethodSetWindow methodsFor: 'menu commands' stamp: 'jmv 3/8/2024 15:33:26'!
                        browseCategoryOfCurrentMethod

	model categoryOfCurrentMethod ifNotNil: [:category| |catIndex selectedMessage|
		selectedMessage := model selectedMessageName.
		catIndex := model classOrMetaClassOrganizer categories indexOf: category.
		model messageCategoryListIndex: catIndex + 1.
		model selectedMessageName: selectedMessage]! !
!MethodSetWindow methodsFor: 'menu commands' stamp: 'jmv 3/8/2024 15:31:36'!
       filterMessageList
	"Allow the user to refine the list of messages."

	| aMenu |
	model messageList size <= 1 
		ifTrue: [ ^self inform: 'this is not a propitious filtering situation' ].

	aMenu := MenuMorph new defaultTarget: model.
	aMenu addTitle: 'Filter by only showing...'.
	aMenu addStayUpIcons.
	aMenu 
		add: 'unsent messages' action: #filterToUnsentMessages balloonText: 'filter to show only messages that have no senders';
		addLine;
		add: 'messages that send...' action: #filterToSendersOf balloonText: 'filter to show only messages that send a selector I specify';
		add: 'messages that do not send...' action: #filterToNotSendersOf balloonText: 'filter to show only messages that do not send a selector I specify';
		addLine;
		add: 'messages whose selector is...' action: #filterToImplementorsOf balloonText: 'filter to show only messages with a given selector I specify';
		add: 'messages whose selector is NOT...' action: #filterToNotImplementorsOf balloonText: 'filter to show only messages whose selector is NOT a seletor I specify';
		addLine;
		add: 'messages in any change set' action: #filterToAnyChangeSet balloonText: 'filter to show only messages that occur in at least one change set';
		add: 'messages not in any change set' action: #filterToNotAnyChangeSet balloonText: 'filter to show only messages that do not occur in any change set in the system';
		addLine;
		add: 'messages authored by me' action: #filterToCurrentAuthor balloonText: 'filter to show only messages whose authoring stamp has my initials';
		add: 'messages not authored by me' action: #filterToNotCurrentAuthor balloonText: 'filter to show only messages whose authoring stamp does not have my initials';
		addLine;
		add: 'messages logged in .changes file' action: #filterToMessagesInChangesFile balloonText: 'filter to show only messages whose latest source code is logged in the .changes file';
		add: 'messages only in .sources file' action: #filterToMessagesInSourcesFile balloonText: 'filter to show only messages whose latest source code is logged in the .sources file';
		addLine;
		add: 'messages with prior versions' action: #filterToMessagesWithPriorVersions balloonText: 'filter to show only messages that have at least one prior version';
		add: 'messages without prior versions' action: #filterToMessagesWithoutPriorVersions balloonText: 'filter to show only messages that have no prior versions';
		addLine;
		add: 'uncommented messages' action: #filterToUncommentedMethods balloonText: 'filter to show only messages that do not have comments at the beginning';
		add: 'commented messages' action: #filterToCommentedMethods balloonText: 'filter to show only messages that have comments at the beginning'.
	aMenu popUpInWorld: self world! !
!MethodSetWindow methodsFor: 'updating' stamp: 'jmv 3/8/2024 15:34:12'!
                       disableCodePaneEditing

	codePane ifNotNil: [ codePane disableEditing ]! !
!MethodSetWindow methodsFor: 'updating' stamp: 'jmv 3/8/2024 15:34:15'!
             editSelectionChanged
	
	model isEditingNone
		ifTrue: [ self disableCodePaneEditing ]
		ifFalse: [ self enableCodePaneEditing]! !
!MethodSetWindow methodsFor: 'updating' stamp: 'jmv 3/8/2024 15:34:18'!
                      enableCodePaneEditing

	codePane ifNotNil: [ codePane enableEditing ]! !
!MethodSetWindow methodsFor: 'updating' stamp: 'jmv 3/8/2024 15:34:20' overrides: 16971010!
                           update: anEvent
	super update: anEvent.
	anEvent = #editSelection ifTrue: [self editSelectionChanged ] ! !
!MethodSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 15:31:36'!
        findInSourceCode
	self request: 'Text to search source code for?' do: [:aString|
		Smalltalk browseMethodsWithSourceString: aString]! !
!MethodSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 15:31:36' overrides: 16971793!
                       open: model label: aString

	| window |
	
	window := super open: model label: aString.
	model messageListIndex: 1.
	
	^window! !
!MethodSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 15:31:36'!
                  openFullProtocolForClass: aClass
	"Create and schedule a browser for the entire protocol of the class."
	"ProtocolBrowser openFullProtocolForClass: ProtocolBrowser."

	| aPBrowser label |

	aPBrowser := ProtocolBrowser new on: aClass.
	label := 'Entire protocol of: ', aClass name.

	^self open: aPBrowser label: label! !
!MethodSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 15:31:36'!
                 openMessageList: methodReferences label: aString
	"Create a standard system view for the message set on the list, anArray.
	The label of the view is aString."

	| methodSet |
	methodSet := MethodSet messageList: methodReferences asArray.
	methodSet sortByClassHierarchy.
	^self open: methodSet label: aString.! !
!MethodSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 15:31:36'!
                          openMessageList: methodReferences label: labelString autoHighlight: autoHighlightString allOccurrences: aBoolean
	"Open a system view for a MethodSet on messageList."

	| methodSet |

	methodSet := MethodSet messageList: methodReferences asArray.
	methodSet sortByClassHierarchy.
	methodSet autoHighlightString: autoHighlightString allOccurrences: aBoolean.

	^self open: methodSet label: labelString ! !
!MethodSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 15:31:36'!
                              openMessageListUnsorted: methodReferences label: labelString
	"Open a system view for a MethodSet on messageList.
	Don't sort entries by default."

	| methodSet |

	methodSet := MethodSet messageList: methodReferences asArray.

	^self open: methodSet label: labelString ! !
!MethodSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 15:31:36'!
 openMessageListUnsorted: methodReferences label: labelString autoHighlight: autoHighlightString allOccurrences: aBoolean
	"Open a system view for a MethodSet on messageList.
	Don't sort entries by default."

	| methodSet |

	methodSet := MethodSet messageList: methodReferences asArray.
	methodSet autoHighlightString: autoHighlightString allOccurrences: aBoolean.

	^self open: methodSet label: labelString ! !
!MethodSetWindow class methodsFor: 'opening' stamp: 'jmv 3/8/2024 15:31:36'!
                       openSubProtocolForClass: aClass
	"Create and schedule a browser for the entire protocol of the class."
	"ProtocolBrowser openSubProtocolForClass: ProtocolBrowser."

	| aPBrowser label |

	aPBrowser := ProtocolBrowser new onSubProtocolOf: aClass.
	label := 'Sub-protocol of: ', aClass name.

	^self open: aPBrowser label: label! !
!MethodSetWindow class methodsFor: 'browser menues' stamp: 'jmv 3/8/2024 15:34:41'!
  messageSetMenu2Options
	
	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'toggle diffing (D)'.
				#object 			-> 		#model.
				#selector 		-> 		#toggleDiffing.
				#icon 			-> 		#switchIcon
			} asDictionary.
			{
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'implementors of sent messages'.
				#selector 		-> 		#browseAllMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'local senders of...'.
				#selector 		-> 		#browseLocalSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'local implementors of...'.
				#selector 		-> 		#browseLocalImplementors.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'spawn sub-protocol'.
				#selector 		-> 		#browseProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'spawn full protocol'.
				#selector 		-> 		#browseFullProtocol.
				#icon 			-> 		#speadsheetTemplateIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 			-> 		'sample instance'.
				#selector 		-> 		#makeSampleInstance.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 			-> 		'inspect instances'.
				#selector 		-> 		#inspectInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 			-> 		'inspect subinstances'.
				#selector 		-> 		#inspectSubInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		40.
				#label 			-> 		'change category...'.
				#object 			-> 		#model.
				#selector 		-> 		#changeCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		50.
				#label 			-> 		'change sets with this method'.
				#selector 		-> 		#findMethodInChangeSets.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		60.
				#label 			-> 		'revert to previous version'.
				#object 			-> 		#model.
				#selector 		-> 		#revertToPreviousVersion.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 			-> 		'more...'.
				#selector 		-> 		#openMessageListMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.			
		}`! !
!MethodSetWindow class methodsFor: 'browser menues' stamp: 'jmv 3/8/2024 15:34:44'!
               messageSetMenuOptions

	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'what to show...'.
				#selector 			-> 		#offerWhatToShowMenu.
				#icon 			-> 		#preferencesIcon
			} asDictionary.
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'toggle break on entry'.
				#object 			-> 		#model.
				#selector 			-> 		#toggleBreakOnEntry.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 			-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 			-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'browse method (O)'.
				#selector 			-> 		#openSingleMessageBrowser.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		40.
				#label 			-> 		'browse protocol (p)'.
				#selector 			-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{	#itemGroup  			-> 		20.
				#itemOrder  			-> 		50.
				#label            			-> 		'browse method category (c)'.
				#selector       		-> 			#browseCategoryOfCurrentMethod.
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 			-> 		#fileOutMessage.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'inspect CompiledMethod'.
				#object 			-> 		#model.
				#selector 			-> 		#inspectCompiledMethod.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'senders of... (n)'.
				#selector 			-> 		#browseSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'implementors of... (m)'.
				#selector 			-> 		#browseMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'inheritance (i)'.
				#selector 			-> 		#methodInheritance.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		40.
				#label 			-> 		'versions (v)'.
				#selector 			-> 		#browseVersions.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 			-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 			-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		30.
				#label 			-> 		'class var refs...'.
				#selector 			-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		40.
				#label 			-> 		'class variables'.
				#selector 			-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		50.
				#label 			-> 		'class refs (N)'.
				#selector 			-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		10.
				#label 			-> 		'remove method (x)'.
				#object 			-> 		#model.
				#selector 			-> 		#removeMessage.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		20.
				#label 			-> 		'run test (t)'.
				#object 			-> 		#model.
				#selector 			-> 		#runMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		30.
				#label 			-> 		'debug test (r)'.
				#object 			-> 		#model.
				#selector 			-> 		#debugMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		70.
				#itemOrder 			-> 		10.
				#label 			-> 		'more...'.
				#selector 			-> 		#openMessageListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6263-MethodSetWindow-JuanVuletich-2024Mar08-15h43m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6256] on 8 March 2024 at 3:45:55 pm'!

MethodSetWindow subclass: #MessageNamesWindow
	instanceVariableNames: 'textMorph '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #MessageNamesWindow category: #'Morphic-Tool Windows' stamp: 'Install-6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st 3/11/2024 16:02:00'!
MethodSetWindow subclass: #MessageNamesWindow
	instanceVariableNames: 'textMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

MethodSetWindow subclass: #ProtocolBrowserWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #ProtocolBrowserWindow category: #'Morphic-Tool Windows' stamp: 'Install-6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st 3/11/2024 16:02:00'!
MethodSetWindow subclass: #ProtocolBrowserWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

MethodSetWindow subclass: #TestResultWindow
	instanceVariableNames: 'testResult '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #TestResultWindow category: #'Tools-Testing' stamp: 'Install-6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st 3/11/2024 16:02:00'!
MethodSetWindow subclass: #TestResultWindow
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

MethodSetWindow subclass: #ChangeSelectorWizardStepWindow
	instanceVariableNames: 'applier '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelectorWizardStepWindow category: #'Tools-Refactoring' stamp: 'Install-6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st 3/11/2024 16:02:00'!
MethodSetWindow subclass: #ChangeSelectorWizardStepWindow
	instanceVariableNames: 'applier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

MethodSetWindow subclass: #ExtractMethodReplacementsWindow
	instanceVariableNames: 'applier finder '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacementsWindow category: #'Tools-Refactoring' stamp: 'Install-6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st 3/11/2024 16:02:00'!
MethodSetWindow subclass: #ExtractMethodReplacementsWindow
	instanceVariableNames: 'applier finder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

MethodSetWindow subclass: #InlineMethodWizardStepWindow
	instanceVariableNames: 'applier '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodWizardStepWindow category: #'Tools-Refactoring' stamp: 'Install-6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st 3/11/2024 16:02:01'!
MethodSetWindow subclass: #InlineMethodWizardStepWindow
	instanceVariableNames: 'applier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!MethodSet class methodsFor: 'ui' stamp: 'jmv 3/8/2024 15:39:12' prior: 50356000!
                      open
	^ MethodSetWindow openFullProtocolForClass: Object! !
!TimeProfileBrowser class methodsFor: 'instance creation' stamp: 'jmv 3/8/2024 15:39:15' prior: 16987511!
                          onBlock: block
	"Open a profile browser on the given block, thereby running the block and 
	 collecting the message tally."
	"TimeProfileBrowser onBlock: [20 timesRepeat: 
			[Transcript show: 100 factorial printString]]"

	| inst result |
	inst := self new.
	result := inst runBlock: block.
	MethodSetWindow open: inst label: 'Time Profile'.
	^ result! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 3/8/2024 15:39:20' prior: 16967920!
   browseMessageList: methodReferences name: labelString autoHighlight: autoHighlightString allOccurrences: aBoolean
	"Create and schedule a MessageSet browser on the message list."

	| messageListSize title |

	messageListSize := methodReferences size.
	messageListSize = 0 ifTrue: [^ PopUpMenu inform: ('There are no\' , labelString) withNewLines ].

	title := messageListSize > 1
		ifFalse: [ labelString ]
		ifTrue: [ '[', messageListSize printString, '] ', labelString].

	^ MethodSetWindow
		openMessageList: methodReferences
		label: title
		autoHighlight: autoHighlightString
		allOccurrences: aBoolean! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 3/8/2024 15:39:23' prior: 16967942!
    browseMessageListUnsorted: methodReferences name: labelString autoHighlight: autoHighlightString
	"Create and schedule a MessageSet browser on the message list.
	Don't sort entries by default."

	| messageListSize title |

	messageListSize := methodReferences size.
	messageListSize = 0 ifTrue: [^ PopUpMenu inform: ('There are no\' , labelString) withNewLines ].

	title := messageListSize > 1
		ifFalse: [ labelString ]
		ifTrue: [ '[', messageListSize printString, '] ', labelString].

	MethodSetWindow
		openMessageListUnsorted: methodReferences
		label: title
		autoHighlight: autoHighlightString
		allOccurrences: true! !
!WorldMorph methodsFor: 'events' stamp: 'jmv 3/8/2024 15:39:27' prior: 50350757 overrides: 16904050!
       keyStroke: aKeyboardEvent
	self flag: #definesKeyboardShortcuts.
	"Handle a keystroke event."
	(aKeyboardEvent commandAltKeyPressed or: [ aKeyboardEvent controlKeyPressed ])
		ifTrue: [
			aKeyboardEvent keyCharacter = $b ifTrue: [ Browser open ].
			aKeyboardEvent keyCharacter = $f ifTrue: [ BrowserWindow findClass ].
			aKeyboardEvent keyCharacter = $F ifTrue: [ MethodSetWindow findInSourceCode ].
		].
	"aKeyboardEvent keyCharacter print."
	^ super keyStroke: aKeyboardEvent! !
!ChangeListWindow methodsFor: 'menu commands' stamp: 'jmv 3/8/2024 15:39:31' prior: 16805508!
                              browseCurrentVersionsOfSelections
	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"

	| currentVersions |
	currentVersions := model currentVersionsOfSelections.
	currentVersions isEmpty ifTrue: [
		^ self inform: 'no selected methods have in-memory counterparts' ].
	MethodSetWindow
		openMessageListUnsorted: currentVersions
		label: 'Current versions of selected methods in ', model file localName.! !
!ChangeSorterWindow methodsFor: 'menu commands' stamp: 'jmv 3/8/2024 15:39:33' prior: 50356262!
                  browseMethodConflicts
	"Check to see if any other change set also holds changes to any methods in the selected change set; if so, open a browser on all such."

	| aList |

	aList := model methodConflicts.
	aList isEmpty ifTrue: [
		^ self inform: 'No other change set has changes for any method in this change set.' ].

	MethodSetWindow
		open: (MethodSet messageList: aList)
		label: 'Methods in "', model changeSet name, '" that are also in other change sets (', aList size printString, ')'! !
!ChangeSelectorApplier methodsFor: 'refactoring - changes' stamp: 'jmv 3/8/2024 15:39:36' prior: 16806680!
     messageSetWindowClass
		
	^MethodSetWindow 
	! !
!InlineMethodApplier methodsFor: 'refactoring - changes' stamp: 'jmv 3/8/2024 15:39:43' prior: 16878773!
      messageSetWindowClass

	^MethodSetWindow
	! !
!RenameClassApplier methodsFor: 'refactoring - changes' stamp: 'jmv 3/8/2024 15:39:46' prior: 16939758!
          openChangedMethods

	changes ifNotEmpty: [ 
		MethodSetWindow openMessageList: changes label: 'Renamed references'  autoHighlight: newClassName allOccurrences: false ]
! !
!RenameGlobalApplier methodsFor: 'refactoring - changes' stamp: 'jmv 3/8/2024 15:39:49' prior: 16939961!
           openChangedMethods

	changes ifNotEmpty: [ 
		MethodSetWindow openMessageList: changes label: 'Renamed references' autoHighlight: newName allOccurrences: false ]
! !

MethodSetWindow subclass: #MessageNamesWindow
	instanceVariableNames: 'textMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #MessageNamesWindow category: #'Morphic-Tool Windows' stamp: 'Install-6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st 3/11/2024 16:02:01'!
MethodSetWindow subclass: #MessageNamesWindow
	instanceVariableNames: 'textMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

MethodSetWindow subclass: #TestResultWindow
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #TestResultWindow category: #'Tools-Testing' stamp: 'Install-6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st 3/11/2024 16:02:01'!
MethodSetWindow subclass: #TestResultWindow
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

MethodSetWindow subclass: #ChangeSelectorWizardStepWindow
	instanceVariableNames: 'applier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelectorWizardStepWindow category: #'Tools-Refactoring' stamp: 'Install-6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st 3/11/2024 16:02:01'!
MethodSetWindow subclass: #ChangeSelectorWizardStepWindow
	instanceVariableNames: 'applier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

MethodSetWindow subclass: #ExtractMethodReplacementsWindow
	instanceVariableNames: 'applier finder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacementsWindow category: #'Tools-Refactoring' stamp: 'Install-6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st 3/11/2024 16:02:01'!
MethodSetWindow subclass: #ExtractMethodReplacementsWindow
	instanceVariableNames: 'applier finder'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

MethodSetWindow subclass: #InlineMethodWizardStepWindow
	instanceVariableNames: 'applier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodWizardStepWindow category: #'Tools-Refactoring' stamp: 'Install-6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st 3/11/2024 16:02:01'!
MethodSetWindow subclass: #InlineMethodWizardStepWindow
	instanceVariableNames: 'applier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6264-useMethodSetWindow-JuanVuletich-2024Mar08-15h44m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6256] on 8 March 2024 at 3:46:02 pm'!

Smalltalk removeClassNamed: #MessageSet!

!classRemoval: #MessageSet stamp: 'Install-6265-remove-MessageSet-MessageSetWindow-JuanVuletich-2024Mar08-15h45m-jmv.001.cs.st 3/11/2024 16:02:01'!
Browser subclass: #MessageSet
	instanceVariableNames: 'messageList shouldAutoHighlight autoHighlightString autoHighlightAllOccurrences'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

Smalltalk removeClassNamed: #MessageSetWindow!

!classRemoval: #MessageSetWindow stamp: 'Install-6265-remove-MessageSet-MessageSetWindow-JuanVuletich-2024Mar08-15h45m-jmv.001.cs.st 3/11/2024 16:02:01'!
BrowserWindow subclass: #MessageSetWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6265-remove-MessageSet-MessageSetWindow-JuanVuletich-2024Mar08-15h45m-jmv.001.cs.st----!

----QUIT----(11 March 2024 16:02:05) Cuis6.3-6265.image priorSource: 729121!

----STARTUP---- (14 March 2024 11:13:53) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis6.3-6265.image!


'From Cuis6.3 [latest update: #6265] on 12 March 2024 at 10:58:15 am'!

FileSystemEntry subclass: #DirectoryEntry
	instanceVariableNames: 'children lastChildrenSync '
	classVariableNames: 'CuisBaseDirectory CurrentDirectory ImageDirectory ProjectBaseDirectory UserBaseDirectory VMDirectory '
	poolDictionaries: ''
	category: 'System-File System'!

!classDefinition: #DirectoryEntry category: #'System-File System' stamp: 'Install-6266-DirectoryEntry-cachedChildrenFix-JuanVuletich-2024Mar12-10h57m-jmv.001.cs.st 3/14/2024 11:14:04'!
FileSystemEntry subclass: #DirectoryEntry
	instanceVariableNames: 'children lastChildrenSync'
	classVariableNames: 'CuisBaseDirectory CurrentDirectory ImageDirectory ProjectBaseDirectory UserBaseDirectory VMDirectory'
	poolDictionaries: ''
	category: 'System-File System'!
!DirectoryEntry methodsFor: 'private' stamp: 'jmv 3/12/2024 10:50:06' prior: 16849549!
           initChildren

	self exists ifFalse: [ ^children := #()] .
	children := self fileAccessor entriesIn: self.
	lastChildrenSync := DateAndTime now.
	^children! !
!DirectoryEntry methodsFor: 'accessing' stamp: 'jmv 3/12/2024 10:51:14' prior: 16849622!
         children
	(lastChildrenSync isNil or: [
		(DateAndTime now - lastChildrenSync) totalSeconds > 2]) ifTrue: [
			children := nil ].
	children ifNil: [self initChildren].
	^children! !

DirectoryEntry removeSelector: #invalidate!

!methodRemoval: DirectoryEntry #invalidate stamp: 'Install-6266-DirectoryEntry-cachedChildrenFix-JuanVuletich-2024Mar12-10h57m-jmv.001.cs.st 3/14/2024 11:14:04'!
invalidate
	"Assume we know nothing about current state in the File System.
	This might be because we're just created.
	Or it might be because there is a chance the File System changed and we don't know current state."
	super invalidate.
	self invalidateChildren!

FileSystemEntry subclass: #DirectoryEntry
	instanceVariableNames: 'children lastChildrenSync'
	classVariableNames: 'CuisBaseDirectory CurrentDirectory ImageDirectory ProjectBaseDirectory UserBaseDirectory VMDirectory'
	poolDictionaries: ''
	category: 'System-File System'!

!classDefinition: #DirectoryEntry category: #'System-File System' stamp: 'Install-6266-DirectoryEntry-cachedChildrenFix-JuanVuletich-2024Mar12-10h57m-jmv.001.cs.st 3/14/2024 11:14:04'!
FileSystemEntry subclass: #DirectoryEntry
	instanceVariableNames: 'children lastChildrenSync'
	classVariableNames: 'CuisBaseDirectory CurrentDirectory ImageDirectory ProjectBaseDirectory UserBaseDirectory VMDirectory'
	poolDictionaries: ''
	category: 'System-File System'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6266-DirectoryEntry-cachedChildrenFix-JuanVuletich-2024Mar12-10h57m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6265] on 12 March 2024 at 10:59:13 am'!
!Transcript class methodsFor: 'displaying' stamp: 'jmv 3/12/2024 10:58:45' prior: 50347372!
  display
	showOnDisplay ifTrue: [
		self displayOnDisplay.
		"DisplayScreen screenUpdateRequired: bounds"
		"Better do it right now!!"
		Display forceToScreen: bounds. ].
	"So any morph in front of us is repaired when Morphic cycles.
	This includes, for instance, the TranscriptWindow that shows our contents if showOnDisplay is false"
	UISupervisor whenUIinSafeState: [ self triggerEvent: #redrawTranscriptArea ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6267-Transcript-fix-JuanVuletich-2024Mar12-10h58m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6265] on 12 March 2024 at 11:07:33 am'!
!FileListWindow methodsFor: 'preferences' stamp: 'jmv 3/12/2024 11:04:44'!
               initialFileListDirectories: aSymbol
	Preferences at: #initialFileListDirectories put: aSymbol.
	Preferences saveToDisk: #initialFileListDirectories.! !
!FileListWindow methodsFor: 'menu building' stamp: 'jmv 3/12/2024 11:05:45' prior: 50354824!
           directoryTreeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu := MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon :: setBalloonText: 'Delete the selected directory'.
	aMenu
		add: model showHidden asMenuItemTextPrefix, 'show hidden folders and files'
		action: #toggleShowHidden ::
		setBalloonText: 'show or hide files and directories that begin with a dot'.
	initialDirectoriesMenu := MenuMorph new.
	#(
		(cuis  		'Cuis top' 'Use the default Cuis top directory')
		(roots  		'OS roots' 'Use the host OS root directories. Drives on Windows; "/" on Unix')
	)
		do: [ :entry |
			initialDirectoriesMenu
				add: entry second
				target: self
				action: #initialFileListDirectories:
				argument: entry first ::
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6268-FileList-RememberTopDirectoriesPreference-JuanVuletich-2024Mar12-10h59m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6265] on 12 March 2024 at 4:38:18 pm'!
!Preference methodsFor: 'accessing' stamp: 'jmv 3/12/2024 16:34:05' prior: 16928303!
    value: aValueOrString

	| aValue |
	aValue := aValueOrString.
	self isTypeAClass 
		ifTrue: [
			((aValueOrString isKindOf: self type) not and: [ aValueOrString isString ])
				ifTrue: [ aValue := self type readFrom: aValueOrString readStream ].
			(aValue isKindOf: self type) ifFalse: [
				self error: aValue printString, ' is not a ', type printString ].
			value := aValue ]
		ifFalse: [ "Should be handled somehow by the preference editor "
			value := aValue.
			value first = $# ifTrue: [
				value := (value withoutPrefix: '#') asSymbol ]].
	self triggerEvent: #preferenceChanged with: self.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
(Preferences instanceAt: #initialFileListDirectories) name: #initialFileListDirectories description: 'Top Directories in FileList' category: #system type: #(cuis roots) value: #cuis!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6269-Preferences-fix-JuanVuletich-2024Mar12-16h34m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6269] on 12 March 2024 at 5:37:31 pm'!
!FileSystemEntry methodsFor: 'accessing' stamp: 'jmv 3/12/2024 17:20:06'!
       allParents
	| ord par |
	par := self parent.
	ord := OrderedCollection with: par.
	[par isRoot] whileFalse: [
		par := par parent.
		ord add: par.
	].
	^ord! !
!FileSystemEntry methodsFor: 'accessing' stamp: 'jmv 3/12/2024 17:32:49'!
                      commonPathWith: aFileSystemEntry
	"
	DirectoryEntry currentDirectory commonPathWith: DirectoryEntry projectBaseDirectory
	"
	| i lastI theirPathComponents |
	self drive = aFileSystemEntry drive
		ifFalse: [ ^nil ].
	i := 1.
	theirPathComponents := aFileSystemEntry pathComponents.
	lastI := pathComponents size min: theirPathComponents size.
	[i <= lastI and: [(pathComponents at: i) = (theirPathComponents at: i)]] whileTrue: [
		i := i + 1 ].
	^DirectoryEntry
				withPathComponents: (pathComponents copyFrom: 1 to: i-1)
				drive: self drive
		! !
!DirectoryEntry methodsFor: 'accessing' stamp: 'jmv 3/12/2024 17:30:40'!
                isInPathTo: aFileSystemEntry
	| theirPathComponents size |
	size := pathComponents size.
	theirPathComponents := aFileSystemEntry pathComponents.
	theirPathComponents size > size ifFalse: [
		^false ].
	1 to: size do: [ :index |
		(pathComponents at: index) = (theirPathComponents at: index) ifFalse: [^ false]].
	^ true! !
!FileList methodsFor: 'initialization' stamp: 'jmv 3/12/2024 17:32:59' prior: 50354790!
    topDirectoryWrappers

	topDirectories := (Preferences at: #initialFileListDirectories) 
		caseOf: {
			[ #cuis ]  		-> 	[ | topDirectoryToUse |
				topDirectoryToUse := directory. "must be inside the tree of some of the included"
				(topDirectoryToUse commonPathWith: DirectoryEntry projectBaseDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				(topDirectoryToUse commonPathWith: DirectoryEntry userBaseDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				(topDirectoryToUse commonPathWith: DirectoryEntry cuisBaseDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				(topDirectoryToUse commonPathWith: DirectoryEntry currentDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				{ topDirectoryToUse} ].
			[ #roots ] -> [ DirectoryEntry roots ].
			}.
	^topDirectories collect: [ :dir |
		FileDirectoryWrapper with: dir name: (dir name ifNil: [ '/' ]) model: self ]! !
!FileList methodsFor: 'private' stamp: 'jmv 3/12/2024 17:31:02' prior: 50354881!
         postOpen
	| pathRoot pathElements |
	directory ifNotNil: [
		pathRoot := topDirectories detect: [ :any | any isInPathTo: directory ].
		pathElements := pathRoot pathComponents size = 0
			ifTrue: [ {directory drive}, directory pathComponents ]
			ifFalse: [ (directory pathComponents
					copyFrom: (pathRoot pathComponents size)
					to: directory pathComponents size) ].
		self changed: #(openPath), pathElements ]! !

DirectoryEntry removeSelector: #isAncestorOf:!

!methodRemoval: DirectoryEntry #isAncestorOf: stamp: 'Install-6270-FileList-Fix-JuanVuletich-2024Mar12-17h34m-jmv.001.cs.st 3/14/2024 11:14:04'!
isAncestorOf: aFileSystemEntry
	| theirPathComponents size |
	size := pathComponents size.
	theirPathComponents := aFileSystemEntry pathComponents.
	theirPathComponents size > size ifFalse: [
		^false ].
	1 to: size do: [ :index |
		(pathComponents at: index) = (theirPathComponents at: index) ifFalse: [^ false]].
	^ true!

FileSystemEntry removeSelector: #commonAncestorWith:!

!methodRemoval: FileSystemEntry #commonAncestorWith: stamp: 'Install-6270-FileList-Fix-JuanVuletich-2024Mar12-17h34m-jmv.001.cs.st 3/14/2024 11:14:04'!
commonAncestorWith: aFileSystemEntry
	"
	DirectoryEntry currentDirectory commonAncestorWith:  DirectoryEntry projectBaseDirectory
	"
	| i lastI theirPathComponents |
	self drive = aFileSystemEntry drive
		ifFalse: [ ^nil ].
	i := 1.
	theirPathComponents := aFileSystemEntry pathComponents.
	lastI := pathComponents size min: theirPathComponents size.
	[i <= lastI and: [(pathComponents at: i) = (theirPathComponents at: i)]] whileTrue: [
		i := i + 1 ].
	^DirectoryEntry
				withPathComponents: (pathComponents copyFrom: 1 to: i-1)
				drive: self drive
		!

FileSystemEntry removeSelector: #ancestors!

!methodRemoval: FileSystemEntry #ancestors stamp: 'Install-6270-FileList-Fix-JuanVuletich-2024Mar12-17h34m-jmv.001.cs.st 3/14/2024 11:14:04'!
ancestors
	| ord par |
	par := self parent.
	ord := OrderedCollection with: par.
	[par isRoot] whileFalse: [
		par := par parent.
		ord add: par.
	].
	^ord!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6270-FileList-Fix-JuanVuletich-2024Mar12-17h34m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6270] on 12 March 2024 at 8:24:30 pm'!
!DirectoryEntry methodsFor: 'accessing' stamp: 'fgz 3/12/2024 20:21:31' prior: 50357625!
    isInPathTo: aFileSystemEntry
	| theirPathComponents size |
	size := pathComponents size.
	theirPathComponents := aFileSystemEntry pathComponents.
	theirPathComponents size >= size ifFalse: [
		^false ].
	1 to: size do: [ :index |
		(pathComponents at: index) = (theirPathComponents at: index) ifFalse: [^ false]].
	^ true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6271-isInPathTo-fix-felipeZak-2024Mar12-20h20m-fgz.003.cs.st----!

'From Cuis6.3 [latest update: #6270] on 13 March 2024 at 10:58:25 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 3/13/2024 10:57:43' prior: 50354105!
                           knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 						'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 						'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'						'Christian Haider')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 						'Fernando Olivero')
	#('FernanodOlivero' 						'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 						'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 						'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 						'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 						'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 						'Marcus Denker')
	#('marcus.denker' 						'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 						'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 					'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 						'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('pmon'						'Paolo Montrasi')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 		'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 						'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'						'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'						'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'						'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'						'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'						'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 						'Stephane Ducasse')
	#('stephaneducasse'	 					'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 						'Masato Sumi')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 						'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 						'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6272-AddFelipeAsKnownAuthor-JuanVuletich-2024Mar13-10h57m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6272] on 14 March 2024 at 10:51:56 am'!
!Browser methodsFor: 'breakpoints' stamp: 'jmv 3/14/2024 10:09:31' prior: 16797537!
                            toggleBreakOnEntry
	"Install or uninstall a halt-on-entry breakpoint"

	| selectedMethod |
	self selectedClassOrMetaClass ifNil: [ ^self ].
	selectedMethod := self selectedClassOrMetaClass >> self selectedMessageName.
	selectedMethod hasBreakpoint
		ifTrue:
			[ selectedMethod uninstall ]
		ifFalse:
			[ (BreakingMethodWrapper on: selectedMethod) install ].
	self
		changed: #messageList;
		changed: #annotation! !
!Browser methodsFor: 'message category functions' stamp: 'jmv 3/14/2024 10:32:52' prior: 16798070!
                            addExtensionCategory
	"Present a choice package names and let the user enter a new category suffx.
	Take the suffix form the selected category."

	| packageNames packageNameIndex |
	
	selectedClassName ifNil: [ ^self ].

	packageNames := (CodePackage installedPackages collect: [ :package |
		package packageName ]) sorted.
	packageNames ifEmpty: [ ^ self ].
	
	packageNameIndex := PopUpMenu 
		withCaption: 'Which package to extend?'
		chooseFrom: packageNames.
	packageNameIndex = 0 ifTrue: [ ^ self ].

	self 
		request: 'Enter the category name'
		initialAnswer: 
			(String streamContents: [ :stream |
				stream
					nextPut: $*;
					nextPutAll: (packageNames at: packageNameIndex).
				selectedMessageCategory ifNotNil: [
					stream
						nextPut: $-;
						nextPutAll: selectedMessageCategory ] ])
		 verifying: [ :newCategoryName | 
			((newCategoryName at: 1) = $* or: [
				self confirm:
					"I know about with #withNewlines ..."
					`'The selected category does not start with an asterix (*).',
					String newLineString,
					'Do you want to use it anyway?'` ]) and: [
						(packageNames includes:				(newCategoryName copyUpTo: $-) allButFirst) or: [
							self confirm:
								`'The selected prefix does not match any package name.', 
								String newLineString,
								'Do you want to use it anyway?'` ] ] ]
		do: [ :newCategoryName | | oldMessageCategoryListIndex |
			oldMessageCategoryListIndex := self messageCategoryListIndex.
			self classOrMetaClassOrganizer
				addCategory: newCategoryName
				before: selectedMessageCategory.
			self changed: #messageCategoryList.
			self messageCategoryListIndex:
				(oldMessageCategoryListIndex = 0
					ifTrue: [ self classOrMetaClassOrganizer categories size + 1 ]
					ifFalse: [ oldMessageCategoryListIndex ]).
			self changed: #messageCategoryList ]! !
!SinglePackageBrowser methodsFor: 'system category functions' stamp: 'jmv 3/14/2024 10:09:42' prior: 16950789 overrides: 16798864!
                       newSystemCategoryNameInitialAnswer
	"Make a suggestion for a new sytems category.
	
	Provide something more usefull, e.g. the package name or a sensible derivate of it."

	| packageName | 
	^ (self systemCategoryList includes: (packageName := package packageName))
		ifTrue: [ packageName, ' - Sub-Category-Name' ]
		ifFalse: [ packageName ]
! !
!MethodSet methodsFor: 'breakpoints' stamp: 'jmv 3/14/2024 10:09:53' prior: 50355632!
                toggleBreakOnEntry
	"Install or uninstall a halt-on-entry breakpoint"

	| selectedMethod |
	self selectedClassOrMetaClass ifNil: [ ^self ].
	selectedMethod := self selectedClassOrMetaClass >> self selectedMessageName.
	selectedMethod hasBreakpoint
		ifTrue:
			[ selectedMethod uninstall ]
		ifFalse:
			[ (BreakingMethodWrapper on: selectedMethod) install ].
	self
		changed: #messageList;
		changed: #annotation! !
!Debugger methodsFor: 'breakpoints' stamp: 'jmv 3/14/2024 10:10:01' prior: 16843966!
          toggleBreakOnEntry
	"Install or uninstall a halt-on-entry breakpoint"

	| selectedMethod |
	self selectedClassOrMetaClass ifNil: [ ^self ].
	selectedMethod := self selectedClassOrMetaClass >> self selectedMessageName.
	selectedMethod hasBreakpoint
		ifTrue:
			[ selectedMethod uninstall ]
		ifFalse:
			[ (BreakingMethodWrapper on: selectedMethod) install ].
	self changed: #annotation! !
!FileList methodsFor: 'own services' stamp: 'jmv 3/14/2024 10:10:12' prior: 50353090!
    viewContentsInWorkspace
	"View the contents of my selected file in a new workspace"

	| fileEntry fileContents |
	fileEntry := directory // fileName.
	fileContents := fileEntry textContents.

	((Workspace new contents: fileContents) 
		openLabel: 'Workspace from ', fileName)
			setProperty: #lastFilenameUsedToSave
			toValue: fileEntry pathName! !
!Float methodsFor: 'comparing' stamp: 'jmv 3/14/2024 10:10:20' prior: 16865994!
                  isWithin: anInteger floatsFrom: aNumber

	^(self floatsAwayFrom: aNumber) abs <= anInteger! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 3/14/2024 10:11:24' prior: 16831116!
    fromArray: colorDef

	| answer |
	colorDef size = 0 ifTrue: [^ `Color transparent` ].
	(colorDef size between: 3 and: 4) ifFalse: [self error: 'Undefined color definition'].
	answer := self r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3).
	^colorDef size = 3
		ifTrue: [answer]
		ifFalse: [answer alpha: (colorDef at: 4)]! !
!Random methodsFor: 'accessing' stamp: 'jmv 3/14/2024 10:14:16' prior: 16934843!
                              nextBits: anInteger
	"Answer a random integer in the interval [0, 2^anInteger - 1]"

	| remainder answer |
	anInteger negative ifTrue: [self error: 'invalid interval'].
	remainder := anInteger \\ self nextChunkSize.
	answer := remainder > 0
		ifTrue: [self nextChunkBits bitShift: remainder - self nextChunkSize]
		ifFalse: [0].
	anInteger // self nextChunkSize timesRepeat:
		[answer := (answer bitShift: self nextChunkSize) bitXor: self nextChunkBits].
	^answer! !
!LaggedFibonacciRandom methodsFor: 'private' stamp: 'jmv 3/14/2024 10:14:27' prior: 16888899 overrides: 16934874!
                           nextChunkBits
	"This method generates random instances of Integer in the interval
	0 to 16r1FFFFFFFFFFFFF (53 bits)."
	
	^(self next timesTwoPower: self nextChunkSize) truncated! !
!ParkMiller88Random methodsFor: 'private' stamp: 'jmv 3/14/2024 10:15:42' prior: 16918331!
                privateNextChunk
	"This method generates random instances of Integer in the interval
	1 to 16r7FFFFFFF (almost 31 bits).  Note the calculations cannot
	result in seed = 0 because a is a primitive generator of the integers
	modulo m."

	seed := (seed asFloat * self a \\ self m) truncated.
	^seed! !
!SymbolSet methodsFor: 'lookup' stamp: 'jmv 3/14/2024 10:16:01' prior: 16962135 overrides: 16913501!
                size

	^buckets inject: 0 into: [ :t :x | (x count: [:s | s notNil]) + t ]! !
!String class methodsFor: 'services' stamp: 'jmv 3/14/2024 10:19:02' prior: 50339697!
                            string: aString lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"
	
	| charSetLineEnders start end endWithoutDelimiters |
	charSetLineEnders := `(ByteArray new: 256) at: Character cr asciiValue + 1 put: 1; at: Character lf asciiValue + 1 put: 1; yourself`.
	start := 1.
	[
		end := aString indexOfAnyIn: charSetLineEnders startingAt: start ifAbsent: [ 0 ].
		end = 0
			ifTrue: [
				"Last line was found. Evaluate and exit.
				Note. If last char in receiver is a line separator, there's an extra empty line"
				endWithoutDelimiters := end := aString size.
				aBlock value: start value: endWithoutDelimiters value: end.
				^aString ].

		"Account for CrLf sequence"
		endWithoutDelimiters := end - 1.
		(end < aString size
			and: [(aString basicAt: end + 1) = `Character lf asciiValue`
			and: [(aString basicAt: end) = `Character cr asciiValue` ]])
				ifTrue: [ end := end + 1].

		aBlock value: start value: endWithoutDelimiters value: end.
		start := end + 1 ] repeat! !
!String class methodsFor: 'services' stamp: 'jmv 3/14/2024 10:19:11' prior: 50339736!
                             string: aByteStringOrByteArray withLineEndings: newLineEndingString
	"assume the string is textual, and that CR, LF, and CRLF are all valid line endings. 
	Answer a new String, where each occurence with is replaced with lineEndingString"
	| cr lf charSetLineEnders inPos outPos outString lineEndPos newOutPos lineEndingSize |
	cr := Character cr.
	lf := Character lf.
	charSetLineEnders := `(ByteArray new: 256) at: Character cr asciiValue + 1 put: 1; at: Character lf asciiValue + 1 put: 1; yourself`.
	(aByteStringOrByteArray is: #ByteArray)
		ifTrue: [
			cr := cr asciiValue.
			lf := lf asciiValue ].

	inPos := 1.
	outPos := 1.
	lineEndingSize := newLineEndingString size.
	"This could be extremely inefficient if lineEndingString size > 1"
	outString := aByteStringOrByteArray class new: aByteStringOrByteArray size * lineEndingSize.

	[
		lineEndPos := aByteStringOrByteArray indexOfAnyIn: charSetLineEnders startingAt: inPos ifAbsent: [0].
		lineEndPos ~= 0 ] whileTrue: [
			newOutPos := outPos + (lineEndPos - inPos).
			outString replaceFrom: outPos to: newOutPos - 1 with: aByteStringOrByteArray startingAt: inPos.
			1 to: lineEndingSize do: [ :i |
				outString at: newOutPos put: (newLineEndingString at: i).
				newOutPos := newOutPos + 1 ].
			outPos := newOutPos.
			((aByteStringOrByteArray at: lineEndPos) = cr and: [
					lineEndPos < aByteStringOrByteArray size and: [ (aByteStringOrByteArray at: lineEndPos+1) = lf ] ]) ifTrue: [
				"CRLF ending"
				inPos := lineEndPos + 2 ]
			ifFalse: [ 
				"CR or LF ending"
				inPos := lineEndPos + 1 ]].

	"no more line endings.  copy the rest"
	newOutPos := outPos + (aByteStringOrByteArray size - inPos).
	outString replaceFrom: outPos to: newOutPos with: aByteStringOrByteArray startingAt: inPos.

	^outString copyFrom: 1 to: newOutPos! !
!String class methodsFor: 'services' stamp: 'jmv 3/14/2024 10:19:29' prior: 50339796!
                         substringsIn: aByteStringOrByteArray
	"Answer an array of the substrings that compose the argument.
	If argument is an UTF-8 encoded ByteArray, answer is an array of same."

	| end beginning charSetNonSeparators charSetSeparators |
	charSetSeparators := `(ByteArray new: 256)
		at: Character space asciiValue + 1 put: 1;
		at: Character tab asciiValue + 1 put: 1;
		at: Character lf asciiValue + 1 put: 1;
		at: Character cr asciiValue + 1 put: 1;
		at: Character newPage asciiValue + 1 put: 1;
		yourself`.
	charSetNonSeparators := `(ByteArray new: 256) += 1;
		at: Character space asciiValue + 1 put: 0;
		at: Character tab asciiValue + 1 put: 0;
		at: Character lf asciiValue + 1 put: 0;
		at: Character cr asciiValue + 1 put: 0;
		at: Character newPage asciiValue + 1 put: 0;
		yourself`.
	end := 0.
	^Array streamContents: [ :result |
		"find one substring each time through this loop"
		[ 
			"find the beginning of the next substring"
			beginning := aByteStringOrByteArray indexOfAnyIn: charSetNonSeparators startingAt: end+1 ifAbsent: nil.
			beginning notNil ] 
		whileTrue: [
			"find the end"
			end := aByteStringOrByteArray indexOfAnyIn: charSetSeparators startingAt: beginning ifAbsent: [ aByteStringOrByteArray size + 1 ].
			end := end - 1.
			result nextPut: (aByteStringOrByteArray copyFrom: beginning to: end).
		]
	].! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 3/14/2024 10:21:34' prior: 50344766!
     normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| character i replacement |
	"Convert strings like '\+161 ' (š) to unicode"
	aKeyboardEvent isSpace ifTrue: [ | string |
		string := self privateCurrentString.
		self pointIndex - 1 to: (self pointIndex - 7 max: 1) by: -1 do: [ :index |
		(string at: index) = $\ ifTrue: [ | key |
			key := string copyFrom: index + 1 to: self pointIndex - 1.
			(key size > 2 and: [ (key at: 1) = $+ ])
				ifTrue: [ | stream number value |
					stream := ReadStream on: key asUppercase from: 2 to: key size.
					[ number := Integer readFrom: stream  base: 16 ] on: Error do: [ ^ false ].
					value := Character codePoint: number.
					self
						selectFrom: index to: self pointIndex - 1;
						replaceSelectionWith: (UnicodeString with: value).
						^ false ] ] ] ].
	character := aKeyboardEvent keyCharacter.
	"Linux VMs don't automatically replace combining marks + space with ASCII,
	as Windows and Mac VMs do. It seems it is an app responsability to do that in Linux."
	character isDiacriticalMark ifTrue: [
		i := self pointIndex-1.
		(i > 0 and: [ (self privateCurrentString at: i) = $  ]) ifTrue: [
			replacement := character caseOf: {
				[ `Character codePoint: 16r300` ] -> [ '`' ].
				[ `Character codePoint: 16r301` ] -> [ '''' ].
				[ `Character codePoint: 16r302` ] -> [ '^' ].
				[ `Character codePoint: 16r303` ] -> [ '~' ].
				[ `Character codePoint: 16r308` ] -> [ '"' ].
			} otherwise: [].
			replacement notNil ifTrue: [
				self selectFrom: i to: i; replaceSelectionWith: replacement.
				^ false ]
			]
		].
	self addString: (UnicodeString with: character).
	^false! !
!SmalltalkEditor methodsFor: 'temp to inst var' stamp: 'jmv 3/14/2024 10:21:46' prior: 16954822!
   temporaryToInstanceVariable

	self
		withNodeUnderCursorDo: [ :nodeUnderCursor |
			(nodeUnderCursor isTemp and: [nodeUnderCursor isArg not])
				ifTrue: [ (TemporaryToInstanceVariableApplier on: self for: nodeUnderCursor name) value ]
				ifFalse: [ morph flash ]]
		ifAbsent: [ morph flash ].! !
!DirectoryEntry class methodsFor: 'user default directories' stamp: 'jmv 3/14/2024 10:21:55' prior: 16849907!
        fileOutsDirectory
	^ (DirectoryEntry userBaseDirectory / 'FileOuts') assureExistence! !
!DirectoryEntry class methodsFor: 'user default directories' stamp: 'jmv 3/14/2024 10:22:05' prior: 16849913!
                          logsDirectory
	^ (DirectoryEntry userBaseDirectory / 'Logs') assureExistence! !
!DirectoryEntry class methodsFor: 'user default directories' stamp: 'jmv 3/14/2024 10:22:13' prior: 16849919!
  newPackagesDirectory
	^ (DirectoryEntry userBaseDirectory / 'NewPackages') assureExistence! !
!DirectoryEntry class methodsFor: 'user default directories' stamp: 'jmv 3/14/2024 10:22:20' prior: 16849926!
                    savedChangeSetsDirectory
	^ (DirectoryEntry userBaseDirectory / 'ChangeSets') assureExistence! !
!DirectoryEntry class methodsFor: 'user default directories' stamp: 'jmv 3/14/2024 10:22:28' prior: 16849933!
                 userChangesDirectory
	^ (DirectoryEntry userBaseDirectory / 'UserChanges') assureExistence! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 3/14/2024 10:24:58' prior: 50332278!
              promptUserForSize: currentSize fontFamily: fontFamily
	| menu |
	menu := MenuMorph entitled: 'Font Sizes'.
	menu defaultTarget: menu.
	fontFamily pointSizes do: [ :pt | | itemText sizeToUse |
		itemText := pt printString.
		sizeToUse := pt.
		(menu
			add: (pt = currentSize) asMenuItemTextPrefix, itemText
			action: #modalSelection:
			argument: pt)
				font: (fontFamily atPointSize: sizeToUse) ].
	^ menu invokeModal! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 3/14/2024 10:25:22' prior: 16891292!
                             iconsExample
	"
	LayoutMorph iconsExample
	"
	| lm ilm counter |
	lm := LayoutMorph newColumn.
	ilm := LayoutMorph newRow.
	counter := 1.
	Theme methodsDo: [ :method | | sel | 
		(sel := method selector) numArgs = 0 ifTrue: [
			(sel endsWith: 'Icon') ifTrue: [ | mayBeForm |
				mayBeForm := Theme current perform: sel.
				(mayBeForm isKindOf: Form) ifTrue: [ | imageMorph |
					counter \\ 10 = 0 ifTrue: [
						lm addMorph: ilm.
						ilm := LayoutMorph newRow ].
					counter := counter + 1.
					ilm addMorph: (imageMorph := ImageMorph new image: (mayBeForm magnifyBy: 2)).
					imageMorph 
						setBalloonText: 'Copy ''', sel storeString bold, ''' to the Clipboard';
						setProperty: #'handlesMouseDown:' toValue: true;
						setProperty: #mouseButton1Down:localPosition:  toValue: [ :event :pos |
							Clipboard storeObject: sel storeString ] ] ] ] ].
	lm 
		setProperty: #taskbarButtonIcon toValue: Theme current imageIcon;
		setBalloonText: 'Drag me here!!'.
	lm openInWorld
! !
!StringRequestMorph methodsFor: 'initialization' stamp: 'jmv 3/14/2024 10:25:45' prior: 50347303!
                           addTextPane
	"Add a text pane and two buttons."
	
	| controlsContainer |
	textMorph := (TextModelMorph
		textProvider: self
		textGetter: #response
		textSetter: #response:
		selectionGetter: #selectionInterval) emptyTextDisplayMessage: 'Enter response'.
	self
		valueOfProperty: #emptyTextDisplayMessage
		ifPresentDo: [ :msg |
			textMorph emptyTextDisplayMessage: msg ].
	textMorph
		hasUnacceptedEdits: true;
		acceptOnCR: true;
		escAction: [ self cancel ].
	(controlsContainer := LayoutMorph newRow)
		addMorphUseAll: textMorph;
		addMorph: 
			((PluggableButtonMorph model: textMorph scroller action: #acceptContents)
				setBalloonText: 'OK' bold, ' (accept input)';
				icon: Theme current acceptIcon);
		addMorph:
			((PluggableButtonMorph model: self action: #cancel)
				setBalloonText: 'Cancel' bold, '  (discard input)';
				icon: Theme current cancelIcon).
	self addMorphUseAll: controlsContainer! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 3/14/2024 10:25:54' prior: 16881475!
               processKeystrokeEvent: evt
	| action |

	(acceptOn = #enter and: [evt isReturnKey]) ifTrue: [^ self acceptContents].

	self pauseBlinking.
	
	"Return - check for special action"
	evt isReturnKey ifTrue: [	
		action := self crAction.
		action ifNotNil: [ ^action value ] ].
	
	"Esc - check for special action"
	evt isEsc ifTrue: [			
		action := self escAction.
		action ifNotNil: [ ^action value ] ].
	
	self handleInteraction: [ editor processKeystrokeEvent: evt ].	
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].

	"Only accept (on any) if we have unaccepted edits, otherwise the morph will flash."
	(hasUnacceptedEdits and: [ acceptOn == #any ]) ifTrue: [ self acceptContents ].! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 3/14/2024 10:26:23' prior: 16893334 overrides: 16904111!
                   mouseButton2Up: aMouseButtonEvent localPosition: localEventPosition
	"Create a copy of me or my submenu."

	aMouseButtonEvent shiftPressed ifTrue: [
		(subMenu
			ifNil: [ self duplicate ]
			ifNotNil: [
				(subMenu duplicate)
					addTitle: contents;
					addStayUpIcons;
					stayUp;
					adjustSubmorphsLayout;
					yourself ])
						openInHand ].
	^ super mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 3/14/2024 10:26:43' prior: 16825536!
           buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout updateReqButton |
	requirements := PluggableListMorph
		model: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
		
	deleteReqButton := (PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete')
							setBalloonText: 'Remove selected Feature requirement'.
	deleteReqButton color: self widgetsColor.
	updateReqButton := (PluggableButtonMorph 
							model: requirements model
							action: #updateSelectedRequirement 
							label: 'update')
							setBalloonText: 'Update requirement to current Feature revision'.
	updateReqButton color: self widgetsColor.
							
	buttonLayout := LayoutMorph newRow.
	buttonLayout 
		addMorph: deleteReqButton 
		layoutSpec: (LayoutSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						offAxisEdgeWeight: #leftOrTop);
		color: self widgetsColor quiteWhiter;
		addMorph: updateReqButton 
		layoutSpec: (LayoutSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						offAxisEdgeWeight: #leftOrTop);
		color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.8
							proportionalHeight: 1.0 
							offAxisEdgeWeight: #leftOrTop);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.2 
							proportionalHeight: 1.0 
							offAxisEdgeWeight: #rightOrBottom);
		color: `Color transparent`;
		yourself
		! !
!FileListWindow methodsFor: 'menu building' stamp: 'jmv 3/14/2024 10:27:51' prior: 50357515!
 directoryTreeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu := MenuMorph new defaultTarget: model.
	(aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon)
			setBalloonText: 'Delete the selected directory'.
	(aMenu
		add: model showHidden asMenuItemTextPrefix, 'show hidden folders and files'
		action: #toggleShowHidden)
			setBalloonText: 'show or hide files and directories that begin with a dot'.
	initialDirectoriesMenu := MenuMorph new.
	#(
		(cuis  		'Cuis top' 'Use the default Cuis top directory')
		(roots  		'OS roots' 'Use the host OS root directories. Drives on Windows; "/" on Unix')
	)
		do: [ :entry |
			(initialDirectoriesMenu
				add: entry second
				target: self
				action: #initialFileListDirectories:
				argument: entry first)
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 3/14/2024 10:28:20' prior: 16784905!
                            drawDownArrowOn: aCanvas thickness: scrollbarThickness

	downButtonForm ifNil: [
		downButtonForm := (ScrollBar new instVarNamed: 'downButton') imageForm: 32 ].
	aCanvas
		image: downButtonForm
		at: self downButtonPosition.
! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 3/14/2024 10:28:38' prior: 16784995!
drawUpArrowOn: aCanvas thickness: scrollbarThickness

	upButtonForm ifNil: [
		upButtonForm := (ScrollBar new instVarNamed: 'upButton') imageForm: 32 ].
	aCanvas
		image: upButtonForm
		at: self upButtonPosition.
! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 3/14/2024 10:29:18' prior: 16909665 overrides: 16908710!
                      dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| aMorphHandlesIt grabAMorph handledByInner |
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchWith: aMorph ].

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^ #rejected ].

	"Install the prospective handler for the receiver"
	aMorphHandlesIt := false.
	grabAMorph := false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isWorldMorph or: [
					self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler := aMorph.
					aMorphHandlesIt := true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self) ifTrue: [
				eventHandler := aMorph.
				aMorphHandlesIt := true ].
			"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
			self mouseButton1Pressed ifTrue: [
				aMorph owner ifNotNil: [ :o |
					(o allowsSubmorphDrag and: [ aMorph isSticky not ]) ifTrue: [
						grabAMorph := true ]]]].

	"Now give submorphs a chance to handle the event"
	handledByInner := false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner := true ]]].

	(handledByInner or: [ (aMorph rejectsEvent: self) not and: [ aMorph fullIncludesPixel: position ] ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt
			ifTrue: [ ^self sendEventTo: aMorph ]
			ifFalse: [
				(grabAMorph and: [ handledByInner not ]) ifTrue: [
					self hand
						waitForClicksOrDrag: aMorph event: self
						dragSel: ((Preferences at: #clickGrabsMorphs) ifFalse: [#dragEvent:localPosition:])
						clkSel: ((Preferences at: #clickGrabsMorphs) ifTrue: [#dragEvent:localPosition:]).
					"false ifTrue: [ self hand grabMorph: aMorph ]."
					(Preferences at: #clickGrabsMorphs) ifFalse: [
						self shiftPressed
							ifTrue: [ (aMorph is: #SystemWindow) ifTrue: [ aMorph sendToBack ] ]
							ifFalse: [ aMorph activateWindow ] ].
					self wasHandled: true.
					^ self ]]].

	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected! !
!MouseScrollEvent methodsFor: 'dispatching' stamp: 'jmv 3/14/2024 10:29:28' prior: 16910422 overrides: 16908710!
   dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	"Try to get out quickly"
	| aMorphHandlesIt handledByInner |
	"FIXME - this works in all tested cases but one: when the window directly under the mouse doesn't have keyboard focus (i.e. a Transcript window)"
	(aMorph fullIncludesPixel: position) ifFalse: [ ^ #rejected ].
	"Install the prospective handler for the receiver"
	aMorphHandlesIt := false.
	(aMorph handlesMouseScroll: self) ifTrue: [
		eventHandler := aMorph.
		aMorphHandlesIt := true ].
	"Now give submorphs a chance to handle the event"
	handledByInner := false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner := true ]]].
	(handledByInner or: [
		 (aMorph rejectsEvent: self) not and: [aMorph fullIncludesPixel: position]]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt ifTrue: [ ^ self sendEventTo: aMorph ]].
	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected.! !
!TheWorldMenu class methodsFor: 'instance creation' stamp: 'jmv 3/14/2024 10:29:38' prior: 16984879!
        getMenuIn: aWorld at: anActiveHand
	^ (self new world: aWorld 	hand: anActiveHand)
		buildWorldMenu! !
!ObjectExplorerWrapper methodsFor: 'converting' stamp: 'jmv 3/14/2024 10:30:30' prior: 16916651 overrides: 16892216!
    asString
	| explorerString |
	explorerString := [ item shortPrintString ]
		on: UnhandledError 
		do: [:ex | ex return: '<error in printString: evaluate "' , itemName , ' printString" to debug>'].
	^(itemName , ': ' , explorerString) withBlanksCondensed! !
!SelectionMenu methodsFor: 'basic control sequence' stamp: 'jmv 3/14/2024 10:30:40' prior: 16946042 overrides: 16926714!
      startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean
	"Overridden to return value returned by manageMarker.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"

	| index |
	index := super startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.
	selections ifNil: [ ^index ].  "If there are no selections defined, show the super class' behavior."
	(index between: 1 and: selections size) ifFalse: [ ^nil ].
	^ selections at: index! !
!TemporaryToInstanceVariable methodsFor: 'applying' stamp: 'jmv 3/14/2024 10:30:48' prior: 16974818!
                            addInstanceVariable

	(AddInstanceVariable named: variable to: method methodClass) apply.! !
!TemporaryToInstanceVariable class methodsFor: 'assertions' stamp: 'jmv 3/14/2024 10:31:01' prior: 16974951!
                      assertSubclassesOf: aClass haventGotInstanceVariableNamed: anInstanceVariableName
	
	aClass allSubclassesDo: [ :subclass | 
		(subclass instVarNames includes: anInstanceVariableName) ifTrue: [
			self refactoringError: self temporaryExistsAsInstVarInSubclassesErrorDescription ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6273-Compatibility-preferParenthesisOverColonColon-JuanVuletich-2024Mar14-10h43m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6272] on 14 March 2024 at 10:53:34 am'!
!ThirtyTwoBitSlotsObject methodsFor: 'private' stamp: 'jmv 3/14/2024 10:10:58' prior: 16986372!
bytesAt: index
	"Answer a ByteArray of 4 elements.
	The 32-bit word is split in 4 bytes, in little endian format
	((ThirtyTwoBitSlotsObject new: 1) at: 1 put: 16rFF32791B ; bytesAt: 1) hex
	"

	| bytes word |
	bytes := ByteArray new: 4.
	word := self basicAt: index. "Usually a SmallInteger, but may be a Large Integer in 32-bit images"
	1 to: 4 do: [ :i | bytes at: i put: (word digitAt: i) ].
	^ bytes! !
!ThirtyTwoBitSlotsObject methodsFor: 'private' stamp: 'jmv 3/14/2024 10:52:31' prior: 16986388!
         bytesAt: index put: aByteArray
	"Takes a ByteArray of 4 elements.
	Store the 32-bit word made with those byes, in little endian format
	((ThirtyTwoBitSlotsObject new: 1) bytesAt: 1 put: #[16r1B 16r79 16r32 16rFF]; basicAt: 1) hex
	"

	| word |
	word := 0.
	4 to: 1 by: -1 do: [ :i | word := word * 256 + (aByteArray at: i) ].
	self basicAt: index put: word! !
!WordArray methodsFor: 'accessing' stamp: 'jmv 3/14/2024 10:52:38' prior: 17007193!
    bytesAt: index
	"Answer a ByteArray of 4 elements.
	The 32-bit word is split in 4 bytes, in little endian format
	((WordArray with: 16rFF32791B) bytesAt: 1) hex
	"

	| bytes word |
	bytes := ByteArray new: 4.
	word := self at: index. "Usually a SmallInteger, but may be a Large Integer in 32-bit images"
	1 to: 4 do: [ :i | bytes at: i put: (word digitAt: i) ].
	^ bytes! !
!WordArray methodsFor: 'accessing' stamp: 'jmv 3/14/2024 10:52:43' prior: 17007207!
                      bytesAt: index put: aByteArray
	"Takes a ByteArray of 4 elements.
	Store the 32-bit word made with those byes, in little endian format
	((WordArray new: 1) bytesAt: 1 put: #[16r1B 16r79 16r32 16rFF]) first hex
	"

	| word |
	word := 0.
	4 to: 1 by: -1 do: [ :i | word := word * 256 + (aByteArray at: i) ].
	self at: index put: word! !
!Bitmap methodsFor: 'accessing' stamp: 'jmv 3/14/2024 10:52:48' prior: 16792696!
bytesAt: index
	"Answer a ByteArray of 4 elements.
	The 32-bit word is split in 4 bytes, in little endian format
	((WordArray with: 16rFF32791B) bytesAt: 1) hex
	"

	| bytes word |
	bytes := ByteArray new: 4.
	word := self at: index. "Usually a SmallInteger, but may be a Large Integer in 32-bit images"
	1 to: 4 do: [ :i | bytes at: i put: (word digitAt: i) ].
	^ bytes! !
!Bitmap methodsFor: 'accessing' stamp: 'jmv 3/14/2024 10:52:52' prior: 16792710!
                         bytesAt: index put: aByteArray
	"Takes a ByteArray of 4 elements.
	Store the 32-bit word made with those byes, in little endian format
	((WordArray new: 1) bytesAt: 1 put: #[16r1B 16r79 16r32 16rFF]) first hex
	"

	| word |
	word := 0.
	4 to: 1 by: -1 do: [ :i | word := word * 256 + (aByteArray at: i) ].
	self at: index put: word! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6274-ClarityInAFewComments-JuanVuletich-2024Mar14-10h51m-jmv.001.cs.st----!

----QUIT----(14 March 2024 11:14:17) Cuis6.3-6274.image priorSource: 823651!

----STARTUP---- (20 March 2024 15:34:18) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis6.3-6274.image!


'From Cuis6.3 [latest update: #6274] on 14 March 2024 at 11:59:22 am'!
!AssignmentNode methodsFor: 'printing' stamp: 'jmv 3/14/2024 11:54:17' prior: 16784011 overrides: 16918533!
      printOn: aStream indent: level 
	variable printOn: aStream indent: level.
	aStream nextPutAll: ' := '.
	value printOn: aStream indent: level! !
!AssignmentNode methodsFor: 'printing' stamp: 'jmv 3/14/2024 11:54:06' prior: 16784025 overrides: 16918563!
    printWithClosureAnalysisOn: aStream indent: level 
	variable printWithClosureAnalysisOn: aStream indent: level.
	aStream nextPutAll: ' := '.
	value printWithClosureAnalysisOn: aStream indent: level! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6275-decompile-prettyPrint-fixAssignment-JuanVuletich-2024Mar14-11h54m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6275] on 15 March 2024 at 9:11:02 am'!
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 3/15/2024 09:09:46' prior: 16994503 overrides: 16814945!
      canonicalComposition
	"
	https://unicode.org/reports/tr15/#Norm_Forms
	Answer a String in the NFC form 'Normalization Form Composed'.

	The canonical composition is cached. Therefor it doesn't need to be computed every time it is needed.
	This makes it actually cheaper than #canonicalDecomposition!!

	UnicodeString fromUtf8Bytes: #[195 162].
	(UnicodeString fromUtf8Bytes: #[195 162]) asUtf8Bytes
	(UnicodeString fromUtf8Bytes: #[195 162]) canonicalDecomposition asUtf8Bytes
	(UnicodeString fromUtf8Bytes: #[195 162]) canonicalComposition asUtf8Bytes

	UnicodeString fromUtf8Bytes: #[97 204 130].
	(UnicodeString fromUtf8Bytes: #[97 204 130]) asUtf8Bytes.
	(UnicodeString fromUtf8Bytes: #[97 204 130]) canonicalDecomposition asUtf8Bytes
	(UnicodeString fromUtf8Bytes: #[97 204 130]) canonicalComposition asUtf8Bytes
	"

	"Lazy initialization."
	hash isNil ifTrue: [
		self findCanonicalCompositionAndHash ].

	^hash isNumber
		ifTrue: [
			"If 'hash' is a number it means we are already in canonicalComposition form (NFC)."
			self ]
		ifFalse: [
			"If 'hash' is not a number, it actually contains our #canonicalComposition."
			hash ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6276-canonicalDecomposition-tweak-JuanVuletich-2024Mar15-09h09m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6276] on 15 March 2024 at 4:01:30 pm'!
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 3/15/2024 15:59:03' prior: 50353105!
                  asDirectoryEntry
	"Note: It is generally advisable to call one of the more specific messages:
		#/
		#withAbsolutePathName: 
		#withRelativePathName:to:"
	"See examples in #asFileEntry method comment"

	^ DirectoryEntry withPathName: self! !
!CharacterSequence methodsFor: 'fileman-converting' stamp: 'jmv 3/15/2024 16:00:45' prior: 50353121!
         asFileEntry
	"Note: It is generally advisable to call one of the more specific messages:
		#//
		#withAbsolutePathName: 
		#withRelativePathName:to:"
	"
	Windows	
		'C:\Windows' asFileEntry exists false
		'C:\Windows' asDirectoryEntry exists true
		'/' asFileEntry exists false
		'/' asDirectoryEntry exists false
		'C:\' asFileEntry exists false
		'C:\' asDirectoryEntry exists true
		('C:' asDirectoryEntry // 'Windows') exists false
		('C:' asDirectoryEntry / 'Windows') exists true
	Linux
		'/var' asFileEntry exists
		'/var' asDirectoryEntry exists true
		'/' asFileEntry exists false
		'/' asDirectoryEntry exists true
		'/media/cdrom' asFileEntry exists false
		'/media/cdrom' asDirectoryEntry exists true
		('/bin' asDirectoryEntry / 'more') exists false
		('/bin' asDirectoryEntry // 'more') exists true
	MacOsX
		'/var' asFileEntry exists false
		'/var' asDirectoryEntry exists true
		'/' asFileEntry exists false
		'/' asDirectoryEntry exists  true
		'/Volumes/SanDisk32-NTFS' asFileEntry exists false
		'/Volumes/SanDisk32-NTFS' asDirectoryEntry exists true
		'SanDisk32-NTFS' asFileEntry exists false
		'SanDisk32-NTFS' asDirectoryEntry exists false
	"

	self isRelativeMark ifTrue: [ ^self error: 'Maybe you need to call #asDirectoryEntry!!' ].
	^ FileEntry withPathName: self! !
!FileSystemEntry class methodsFor: 'instance creation' stamp: 'jmv 3/15/2024 15:58:20' prior: 50351729!
          withPathName: aString
	"Note: It is generally advisable to call one or the more specific messages:
	#withAbsolutePathName: or #withRelativePathName:to:"

	^aString isAbsolutePathName
		ifTrue: [ self withAbsolutePathName: aString ]
		ifFalse: [
			self
				withRelativePathName: aString
				to: DirectoryEntry userBaseDirectory ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6277-userBaseDirectoryIfPathUnspecified-JuanVuletich-2024Mar15-15h42m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6277] on 15 March 2024 at 6:09:12 pm'!
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 3/15/2024 18:08:22' prior: 50334280!
 processCommandLineOption: optionString optionArgument: optionArgument raiseExceptions: aBoolean
	"
	A possible example (duplicated single quotes: '' should be double quotes, but not allowed in a Smalltalk comment):
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -h
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -v
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -q
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -e -d''0 zope''
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -r YAXO -rJSON -d ''Smalltalk startUpScriptArguments print'' xx YY 3492 -d'' 'here comes another' print'' -d ''{'The answer is: '. Smalltalk startUpScriptArguments first asNumber + Smalltalk startUpScriptArguments second asNumber} print'' 3 4 -- -d'' 'not this' print' ''

Squeak.exe Cuis4.2-2211x.image -r RequiredFeature1 -r RequiredFeature2 -d ''Transcript show: 'popo1'; newLine'' -d ''Transcript show: 'popo2'; newLine'' -s smalltalkScript.st param1ToScript param2ToSCript ''parametro 3 to script ->>>--// 3''
	"
	"You can use 'Smalltalk startUpScriptArguments' inside the startUp script:"


	| exceptionToIgnoreOrNil file directory |
	exceptionToIgnoreOrNil := aBoolean ifFalse: [UnhandledError] ifTrue: [nil].
	optionString caseOf: {
		[ '-h' ] -> [
			self displayCommandLineUsageOn: StdIOWriteStream stdout.
			self quit ].

		[ '-v' ] -> [ 
			self displaySystemInformationStringOn: StdIOWriteStream stdout.
			self quit ].

		[ '-q' ] -> [ self quit ].

		[ '-r' ] -> [		"as in 		-rRequiredFeature2        or         -r RequiredFeature2"
			{ 'Feature require: '. optionArgument } print.
			[ Feature require: optionArgument ] on: exceptionToIgnoreOrNil do: [:ex | ex return] ].

		[ '-d' ] -> [		"as in 		-d ''Transcript show: 'popo1'; newLine'' -d''Transcript show: 'popo2'; newLine''        (duplicated singleQuotes should read doubleQuote)"
			{ 'Compiler evaluate: '. optionArgument } print.
			[ Compiler evaluate: optionArgument ] on: exceptionToIgnoreOrNil do: [:ex | ex return] ].

		['-l' ] -> ["file in the file"
			file := optionArgument isAbsolutePathName
				ifTrue: [ FileEntry withAbsolutePathName: optionArgument ]
				ifFalse: [FileEntry withRelativePathName: optionArgument to: DirectoryEntry currentDirectory ].
			{ 'File in: '. optionArgument. ' -> '. file} print.
			[(CodeFile newFromFile: file) fileIn] on: exceptionToIgnoreOrNil do: [ :ex | ex return]].

		[ '-s' ] -> [		"as in 		-s smalltalkScript.st paramAlScript1 paramAlSCript2 ''parameter to script script ->>>--// 3'' 			(duplicated singleQuotes should read doubleQuote)"
			file := optionArgument isAbsolutePathName
				ifTrue: [ FileEntry withAbsolutePathName: optionArgument ]
				ifFalse: [FileEntry withRelativePathName: optionArgument to: DirectoryEntry currentDirectory ].
			{ 'Compiler evaluate contents of file named: '. optionArgument. ' -> '. file. ' arguments: '. self startUpScriptArguments } print.
			file exists ifTrue: [
				file readStreamDo: [ :stream |
					[ Compiler evaluate: stream contentsOfEntireFile ] on: exceptionToIgnoreOrNil do: [ :ex | ex return]]]].

		[ '-ud' ] -> [
			directory := optionArgument asDirectoryEntry.
			DirectoryEntry setUserBaseDirectory: directory ].

		[ '-udIsBase' ] -> [ DirectoryEntry setUserBaseDirectoryAsCuisBase ].
	}
	otherwise: [].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6278-commandLineFileArgumentsRelativeToCurrentDirectory-JuanVuletich-2024Mar15-18h02m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6278] on 17 March 2024 at 2:48:41 pm'!

ReadWriteStream removeSelector: #next:into:startingAt:!

!methodRemoval: ReadWriteStream #next:into:startingAt: stamp: 'Install-6279-ReadWriteStream-fix-JuanVuletich-2024Mar17-14h48m-jmv.001.cs.st 3/20/2024 15:34:35'!
next: n into: aCollection startingAt: startIndex
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."
	| max |
	max := (readLimit - position) min: n.
	aCollection 
		replaceFrom: startIndex 
		to: startIndex+max-1
		with: collection
		startingAt: position+1.
	position := position + max.
	max = n
		ifTrue:[^aCollection]
		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6279-ReadWriteStream-fix-JuanVuletich-2024Mar17-14h48m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6278] on 16 March 2024 at 6:22:03 pm'!
!BMPReadWriter methodsFor: 'reading' stamp: '' prior: 16785558!
                    read24BmpFile
	"Read 24-bit pixel data from the given a BMP stream."
	| form formBits pixelLine bitsIndex |
	form := Form extent: biWidth@biHeight depth: 32.
	pixelLine := ByteArray new: (((24 * biWidth) + 31) // 32) * 4.
	bitsIndex := form height - 1 * biWidth + 1.
	formBits := form bits.
	1 to: biHeight do: [:i | 
		stream readInto: pixelLine startingAt: 1 count: pixelLine size.
		self read24BmpLine: pixelLine into: formBits startingAt: bitsIndex width: biWidth.
		bitsIndex := bitsIndex - biWidth.
	].
	form makeAllPixelsOpaque.
	^ form
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6280-read24BmpFile-codefrau-2024Mar16-17h33m-codefrau.001.cs.st----!

'From Cuis6.3 [latest update: #6280] on 17 March 2024 at 3:30:04 pm'!
!Preference methodsFor: 'accessing' stamp: 'jmv 4/18/2023 10:23:40' prior: 50357554!
   value: aValueOrString

	| aValue |
	aValue := aValueOrString.
	self isTypeAClass 
		ifTrue: [
			((aValueOrString isKindOf: self type) not and: [ aValueOrString isString ])
				ifTrue: [ aValue := self type readFrom: aValueOrString readStream ].
			(aValue isKindOf: self type) ifFalse: [
				self error: aValue printString, ' is not a ', type printString ].
			value := aValue ]
		ifFalse: [ "Should be handled somehow by the preference editor "
			value := aValue].
	self triggerEvent: #preferenceChanged with: self.! !
!PreferenceSet class methodsFor: 'services' stamp: 'jmv 3/17/2024 15:29:25' prior: 16928995!
                         readAndApplyUserPrefs
	"
	PreferenceSet readAndApplyUserPrefs
	"
	| file line parts pref value |
	file := DirectoryEntry userBaseDirectory // 'UserPrefs.txt'.
	file exists ifTrue: [
		file readStreamDo: [ :stream |
			[ stream atEnd ] whileFalse: [
				line := stream nextLine.
				parts := line substringsSeparatedBy: $=.
				[
					pref := Preferences instanceAt: parts first asSymbol.
					value := parts second.
					value first = $# ifTrue: [ value := (value withoutPrefix: '#') asSymbol ].
					pref value: value.
					pref justReadFromDisk.
				]
					on: Error
					do: [ :error |
						'--- UserPrefts.txt Error' print.
						error print.
						line print ].
				]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6281-PreferencesFix-JuanVuletich-2024Mar17-15h11m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6281] on 18 March 2024 at 10:08:42 am'!
!Browser methodsFor: 'message functions' stamp: 'jmv 3/18/2024 10:07:52'!
         removeMessageInHierarchy
	"If a message is selected, create a Confirmer so the user can verify that  
	the currently selected message should be removed from the system. If so,  
	remove it. If the Preference 'confirmMethodRemoves' is set to false, the 
	confirmer is bypassed."
	
	| messageName confirmation selectedClass |
	selectedMessage ifNil: [ ^self ].
	
	messageName := self selectedMessageName.
	selectedClass := self selectedClassOrMetaClass.
	confirmation := Smalltalk confirmRemovalOf: messageName on: selectedClass andSubclasses: true.
	confirmation = 3
		ifTrue: [^ self].

	selectedClass withAllSubclassesDo: [ :eachClass | eachClass removeSelector: messageName ].
	
	self reformulateList.
	self changed: #messageList.
	self setClassOrganizer.
	confirmation = 2
		ifTrue: [Smalltalk browseAllCallsOn: messageName]! !
!SystemDictionary methodsFor: 'ui' stamp: 'jmv 3/18/2024 10:05:45'!
                             confirmRemovalOf: aSelector on: aClass andSubclasses: aBoolean
	"Determine if it is okay to remove the given selector. Answer 1 if it  
	should be removed, 2 if it should be removed followed by a senders  
	browse, and 3 if it should not be removed."
	| count aMenu labels answer caption allCalls |
	allCalls := self allCallsOn: aSelector.
	(count := allCalls size) = 0
		ifTrue: [^ 1].
	"no senders -- let the removal happen without warning"
	count = 1
		ifTrue: [(allCalls first actualClass == aClass
					and: [allCalls first methodSymbol == aSelector])
				ifTrue: [^ 1]].
	"only sender is itself"
	labels := aBoolean
		ifTrue: [
'Remove from ', aClass name, ' and subclasses
Remove them, then browse senders
Don''t remove, but show me those senders
Forget it -- do nothing -- sorry I asked']
		ifFalse: [
'Remove it
Remove, then browse senders
Don''t remove, but show me those senders
Forget it -- do nothing -- sorry I asked'].
	aMenu := PopUpMenu labels: labels
		icons: #(acceptIcon acceptIcon cancelIcon cancelIcon).

	caption := 'This message has ' , count printString , ' sender'.
	count > 1
		ifTrue: [caption := caption copyWith: $s].
	answer := aMenu startUpWithCaption: caption.
	answer = 3
		ifTrue: [self
				browseMessageList: allCalls
				name: 'Senders of ' , aSelector
				autoHighlight: aSelector keywords first
				allOccurrences: false ].
	answer = 0
		ifTrue: [answer := 3].
	"If user didn't answer, treat it as cancel"
	^ answer min: 3! !
!SystemDictionary methodsFor: 'ui' stamp: 'jmv 3/18/2024 10:02:47' prior: 16967476!
                   confirmRemovalOf: aSelector on: aClass 
	"Determine if it is okay to remove the given selector. Answer 1 if it  
	should be removed, 2 if it should be removed followed by a senders  
	browse, and 3 if it should not be removed."

	^self confirmRemovalOf: aSelector on: aClass andSubclasses: false! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'PB 3/16/2024 17:18:31' prior: 16800462!
                   messageListMenuOptions

	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'what to show...'.
				#selector 			-> 		#offerWhatToShowMenu.
				#icon 			-> 		#preferencesIcon
			} asDictionary.
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'toggle break on entry'.
				#object 			-> 		#model.
				#selector 			-> 		#toggleBreakOnEntry.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 			-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 			-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'browse method (O)'.
				#selector 			-> 		#openSingleMessageBrowser.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		40.
				#label 			-> 		'browse protocol (p)'.
				#selector 			-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{	#itemGroup  			-> 		20.
				#itemOrder  			-> 		50.
				#label            			-> 		'browse method category (c)'.
				#selector       		-> 			#browseCategoryOfCurrentMethod.
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 			-> 		#fileOutMessage.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'inspect CompiledMethod'.
				#object 			-> 		#model.
				#selector 			-> 		#inspectCompiledMethod.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'senders of... (n)'.
				#selector 			-> 		#browseSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'implementors of... (m)'.
				#selector 			-> 		#browseMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'inheritance (i)'.
				#selector 			-> 		#methodInheritance.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		40.
				#label 			-> 		'versions (v)'.
				#selector 			-> 		#browseVersions.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 			-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 			-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		30.
				#label 			-> 		'class var refs...'.
				#selector 			-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		40.
				#label 			-> 		'class variables'.
				#selector 			-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		50.
				#label 			-> 		'class refs (N)'.
				#selector 			-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		10.
				#label 			-> 		'remove method (x)'.
				#object 			-> 		#model.
				#selector 			-> 		#removeMessage.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		20.
				#label 			-> 		'remove method in hierarchy'.
				#object 			-> 		#model.
				#selector 			-> 		#removeMessageInHierarchy.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		30.
				#label 			-> 		'run test (t)'.
				#object 			-> 		#model.
				#selector 			-> 		#runMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		40.
				#label 			-> 		'debug test (r)'.
				#object 			-> 		#model.
				#selector 			-> 		#debugMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		70.
				#itemOrder 			-> 		10.
				#label 			-> 		'more...'.
				#selector 			-> 		#openMessageListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6282-RemoveMessageFromHierarchy-PaoloBelforte-JuanVuletich-2024Mar18-09h47m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6282] on 20 March 2024 at 12:27:30 pm'!

Object subclass: #TestCase
	instanceVariableNames: 'testSelector failureString raisedError assertCount '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #TestCase category: #'Tools-Testing' stamp: 'Install-6283-SUnit-Enhancements-MichaelRueger-2024Mar20-12h16m-mir.001.cs.st 3/20/2024 15:34:35'!
Object subclass: #TestCase
	instanceVariableNames: 'testSelector failureString raisedError assertCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!
!TestCase methodsFor: 'running - private' stamp: 'mir 3/20/2024 15:53:46'!
                        incrementAssertionCount
	assertCount := assertCount + 1! !
!TestResult methodsFor: 'printing' stamp: 'mir 3/20/2024 17:11:11'!
 description
	" Return the description of the receiver. "

	| stream |
	stream := '' writeStream.
	"stream lf; nextPutAll: 'passed:'; lf.
	self passed do: [:stage|
		stream lf;nextPutAll: '	',stage
	]."
	stream lf; nextPutAll: 'failures:';lf.
	self failures do: [:testCase |
		stream lf;nextPutAll: '	',testCase selector ,'	' ,testCase failureString
	].
	stream lf; nextPutAll: 'errors:';lf.
	self errors do: [:testCase|
		stream lf;
			nextPutAll: '	',testCase selector ,'	' ,(testCase failureString ifNil: ['']); lf;
			"nextPutAll: tuple first stack;"
			yourself
	].
	stream lf; nextPutAll: 'passed: '; nextPutAll: self correctCount asString; lf.
	stream nextPutAll: 'failures: '; nextPutAll: self failureCount asString; lf.
	stream nextPutAll: 'errors: '; nextPutAll: self errorCount asString; lf.
	^stream contents! !
!TestCase methodsFor: 'assertions' stamp: 'mir 3/20/2024 15:48:23' prior: 16975250 overrides: 16913884!
 assert: aBooleanOrBlock

	self assert: aBooleanOrBlock description: nil
			! !
!TestCase methodsFor: 'assertions' stamp: 'mir 3/20/2024 16:08:50' prior: 16975284 overrides: 16913891!
         assert: aBooleanOrBlock description: aStringOrBlock
	self incrementAssertionCount.
	aBooleanOrBlock value ifFalse: [
		failureString := String streamContents: [:stream |
			stream 	nextPutAll: 'Assertion ('.
			assertCount printOn: stream.
			stream nextPutAll: ') failed. '.
			aStringOrBlock value ifNotNil: [:description | stream nextPutAll: description]].
		self logFailure: failureString.
		TestResult failure sunitSignalWith: failureString]! !
!TestCase methodsFor: 'assertions' stamp: 'mir 3/20/2024 16:10:36' prior: 16975385 overrides: 16913907!
                      deny: aBooleanOrBlock

	self deny: aBooleanOrBlock description: nil! !
!TestCase methodsFor: 'assertions' stamp: 'mir 3/20/2024 16:11:03' prior: 16975389!
     deny: aBooleanOrBlock description: aStringOrBlock

	self assert: aBooleanOrBlock value not description: aStringOrBlock
			! !
!TestCase methodsFor: 'setUp/tearDown' stamp: 'mir 3/20/2024 15:54:16' prior: 16975661!
          setUp
	assertCount := 0! !

Object subclass: #TestCase
	instanceVariableNames: 'testSelector failureString raisedError assertCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #TestCase category: #'Tools-Testing' stamp: 'Install-6283-SUnit-Enhancements-MichaelRueger-2024Mar20-12h16m-mir.001.cs.st 3/20/2024 15:34:35'!
Object subclass: #TestCase
	instanceVariableNames: 'testSelector failureString raisedError assertCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6283-SUnit-Enhancements-MichaelRueger-2024Mar20-12h16m-mir.001.cs.st----!

'From Cuis6.3 [latest update: #6283] on 20 March 2024 at 3:26:04 pm'!
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 3/20/2024 15:23:31' prior: 50359186!
                            processCommandLineOption: optionString optionArgument: optionArgument raiseExceptions: aBoolean
	"
	A possible example (duplicated single quotes: '' should be double quotes, but not allowed in a Smalltalk comment):
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -h
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -v
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -q
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -e -d''0 zope''
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -r YAXO -rJSON -d ''Smalltalk startUpScriptArguments print'' xx YY 3492 -d'' 'here comes another' print'' -d ''{'The answer is: '. Smalltalk startUpScriptArguments first asNumber + Smalltalk startUpScriptArguments second asNumber} print'' 3 4 -- -d'' 'not this' print' ''

Squeak.exe Cuis4.2-2211x.image -r RequiredFeature1 -r RequiredFeature2 -d ''Transcript show: 'popo1'; newLine'' -d ''Transcript show: 'popo2'; newLine'' -s smalltalkScript.st param1ToScript param2ToSCript ''parametro 3 to script ->>>--// 3''
	"
	"You can use 'Smalltalk startUpScriptArguments' inside the startUp script:"


	| exceptionToIgnoreOrNil file directory |
	exceptionToIgnoreOrNil := aBoolean ifFalse: [UnhandledError] ifTrue: [nil].
	optionString caseOf: {
		[ '-h' ] -> [
			self displayCommandLineUsageOn: StdIOWriteStream stdout.
			self quit ].

		[ '-v' ] -> [ 
			self displaySystemInformationStringOn: StdIOWriteStream stdout.
			self quit ].

		[ '-q' ] -> [ self quit ].

		[ '-r' ] -> [		"as in 		-rRequiredFeature2        or         -r RequiredFeature2"
			{ 'Feature require: '. optionArgument } print.
			[ Feature require: optionArgument ] on: exceptionToIgnoreOrNil do: [:ex | ex return] ].

		[ '-d' ] -> [		"as in 		-d ''Transcript show: 'popo1'; newLine'' -d''Transcript show: 'popo2'; newLine''        (duplicated singleQuotes should read doubleQuote)"
			{ 'Compiler evaluate: '. optionArgument } print.
			[ Compiler evaluate: optionArgument ] on: exceptionToIgnoreOrNil do: [:ex | ex return] ].

		['-l' ] -> ["file in the file"
			file := optionArgument isAbsolutePathName
				ifTrue: [ FileEntry withAbsolutePathName: optionArgument ]
				ifFalse: [FileEntry withRelativePathName: optionArgument to: DirectoryEntry currentDirectory ].
			{ 'File in: '. optionArgument. ' -> '. file} print.
			[file readStreamDo: [ :stream | stream fileIn ]] on: exceptionToIgnoreOrNil do: [ :ex | ex return]].

		[ '-s' ] -> [		"as in 		-s smalltalkScript.st paramAlScript1 paramAlSCript2 ''parameter to script script ->>>--// 3'' 			(duplicated singleQuotes should read doubleQuote)"
			file := optionArgument isAbsolutePathName
				ifTrue: [ FileEntry withAbsolutePathName: optionArgument ]
				ifFalse: [FileEntry withRelativePathName: optionArgument to: DirectoryEntry currentDirectory ].
			{ 'Compiler evaluate contents of file named: '. optionArgument. ' -> '. file. ' arguments: '. self startUpScriptArguments } print.
			file exists ifTrue: [
				file readStreamDo: [ :stream |
					[ Compiler evaluate: stream contentsOfEntireFile ] on: exceptionToIgnoreOrNil do: [ :ex | ex return]]]].

		[ '-ud' ] -> [
			directory := optionArgument asDirectoryEntry.
			DirectoryEntry setUserBaseDirectory: directory ].

		[ '-udIsBase' ] -> [ DirectoryEntry setUserBaseDirectoryAsCuisBase ].
	}
	otherwise: [].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6284-processCommandLineOption-fix-JuanVuletich-2024Mar20-15h25m-jmv.001.cs.st----!

----QUIT----(20 March 2024 15:34:42) Cuis6.3-6284.image priorSource: 876050!

----STARTUP---- (22 March 2024 14:39:46) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis6.3-6284.image!


'From Cuis6.3 [latest update: #6284] on 20 March 2024 at 4:15:59 pm'!
!TestCase methodsFor: 'assertions' stamp: 'HAW 3/20/2024 16:13:51' prior: 50359707 overrides: 16913884!
            assert: aBooleanOrBlock

	self assert: aBooleanOrBlock description: ''
			! !
!TestCase methodsFor: 'assertions' stamp: 'HAW 3/20/2024 16:14:30' prior: 50359713 overrides: 16913891!
          assert: aBooleanOrBlock description: aStringOrBlock
	self incrementAssertionCount.
	aBooleanOrBlock value ifFalse: [
		failureString := String streamContents: [:stream |
			stream 	nextPutAll: 'Assertion ('.
			assertCount printOn: stream.
			stream nextPutAll: ') failed. '.
			stream nextPutAll: aStringOrBlock value].
		self logFailure: failureString.
		TestResult failure sunitSignalWith: failureString]! !
!TestCase methodsFor: 'assertions' stamp: 'HAW 3/20/2024 16:14:39' prior: 50359731 overrides: 16913907!
                             deny: aBooleanOrBlock

	self deny: aBooleanOrBlock description: ''! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6285-RemoveNilAsPossibleParameterOfAsssertDescription-HernanWilkinson-2024Mar20-16h13m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6285] on 20 March 2024 at 7:09:18 pm'!
!TestResult methodsFor: 'printing' stamp: 'mir 3/20/2024 17:11:11'!
             fullDescription
	" Return the description of the receiver. "

	| stream |
	stream := '' writeStream.
	stream lf; nextPutAll: 'passed:'; lf.
	self passed do: [:stage|
		stream lf;nextPutAll: '	',stage
	].
	stream lf; nextPutAll: 'failures:';lf.
	self failures do: [:testCase |
		stream lf;nextPutAll: '	',testCase selector ,'	' ,testCase failureString
	].
	stream lf; nextPutAll: 'errors:';lf.
	self errors do: [:testCase|
		stream lf;
			nextPutAll: '	',testCase selector ,'	' ,(testCase failureString ifNil: ['']); lf;
			yourself
	].
	stream lf; nextPutAll: 'passed: '; nextPutAll: self correctCount asString; lf.
	stream nextPutAll: 'failures: '; nextPutAll: self failureCount asString; lf.
	stream nextPutAll: 'errors: '; nextPutAll: self errorCount asString; lf.
	^stream contents! !
!TestResult methodsFor: 'printing' stamp: 'mir 3/20/2024 17:11:11' prior: 50359678!
                       description
	" Return the description of the receiver. "

	| stream |
	stream := '' writeStream.
	stream lf; nextPutAll: 'failures:';lf.
	self failures do: [:testCase |
		stream lf;nextPutAll: '	',testCase selector ,'	' ,testCase failureString
	].
	stream lf; nextPutAll: 'errors:';lf.
	self errors do: [:testCase|
		stream lf;
			nextPutAll: '	',testCase selector ,'	' ,(testCase failureString ifNil: ['']); lf;
			yourself
	].
	stream lf; nextPutAll: 'passed: '; nextPutAll: self correctCount asString; lf.
	stream nextPutAll: 'failures: '; nextPutAll: self failureCount asString; lf.
	stream nextPutAll: 'errors: '; nextPutAll: self errorCount asString; lf.
	^stream contents! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6286-TestResult-tweaks-MichaelRueger-2024Mar20-19h06m-mir.001.cs.st----!

'From Cuis6.3 [latest update: #6286] on 21 March 2024 at 9:46:16 am'!
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'jmv 3/21/2024 09:45:51'!
                             lastCharacterWantsAutoComplete

	| lastCharIndex lastCharacter |
	textMorph editor hasSelection ifTrue: [ ^ false ].

	lastCharIndex := textMorph editor startIndex-1.
	lastCharIndex <= 0 ifTrue: [ ^ false ].
	lastCharacter := model actualContents at: lastCharIndex.

	^ lastCharacter isAlphaNumeric or: [
		lastCharacter isValidInBinarySelectors or: [ lastCharacter = $: ]]! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'jmv 3/21/2024 09:37:20'!
                      openCompletionMenuFor: kbEvent

	"Ctrl-Space or Tab for open"
	kbEvent isCtrlSpace ifTrue: [
		self openCompletionMenu.
		^ true].
	(kbEvent isTab and: [ self opensWithTab ]) ifTrue: [
		self openCompletionMenu.
		^ true].
		
	"Auto-open - currently deactivated"
"	(ctrl not & cmd not & alphanum) ifTrue: [ self openCompletionMenu ]."
	
	^ false! !
!AutoCompleter methodsFor: 'keyboard' stamp: 'jmv 3/21/2024 09:42:22' prior: 16784401!
            handleKeystrokeBefore: kbEvent
	"I return a boolean. true when I have handled the event and no futher processing is needed by the caller."

	"Stuff to do if the menu is not open"
	menuMorph ifNil: [
		self lastCharacterWantsAutoComplete ifFalse: [ ^false ]. "Further processing needed"
		^ self openCompletionMenuFor: kbEvent ].

	"Starting here, stuff to do if the menu is open"
	menuMorph stillActive.

	kbEvent isEsc ifTrue: [ self closeMenu. ^ true].
	kbEvent isBackspace ifTrue: [
		self lastCharacterWantsAutoComplete ifFalse: [ self closeMenu ].
		^ false ]."Further processing needed"
	kbEvent isHome ifTrue: [ menuMorph goHome. ^ true ].
	kbEvent isEnd ifTrue: [ menuMorph goToEnd. ^ true].
	kbEvent isQuestionMark ifTrue: [ menuMorph help. ^true].
	kbEvent isArrowUp ifTrue: [ menuMorph goUp. ^ true].
	kbEvent isArrowDown ifTrue: [ menuMorph goDown. ^ true].
	kbEvent isPageUp ifTrue: [ menuMorph goPageUp. ^ true].
	kbEvent isPageDown ifTrue: [ menuMorph goPageDown. ^ true].

	kbEvent isArrowRight ifTrue: [ ^self handleRightArrowKeystrokeBefore: kbEvent ].
	kbEvent isArrowLeft ifTrue: [ ^self handleLeftArrowKeystrokeBefore: kbEvent ].

	(self shouldInsertSelected: kbEvent) ifTrue: [ self insertSelected ifTrue: [^ true]].
	(self shouldCloseMenu: kbEvent) ifTrue: [ self closeMenu ].

	"Further processing needed"
	^false! !

AutoCompleter removeSelector: #openCompletionMenuFor:if:!

!methodRemoval: AutoCompleter #openCompletionMenuFor:if: stamp: 'Install-6287-AutoCompleterCleanup-JuanVuletich-2024Mar21-09h05m-jmv.001.cs.st 3/22/2024 14:39:51'!
openCompletionMenuFor: kbEvent if: shouldOpenMorph

	"Ctrl-Space or Tab for open"
	"Mac specific note: Using option-space (actually option+160) effectively disables the non-breaking space character 160"
	(kbEvent isCtrlSpace or: [self isTab: kbEvent and: shouldOpenMorph]) ifTrue: [ self openCompletionMenu. ^ true].
		
	"Auto-open - currently deactivated"
"	(ctrl not & cmd not & alphanum) ifTrue: [ self openCompletionMenu ]."
	
	^ false!

AutoCompleter removeSelector: #shouldOpenMorph!

!methodRemoval: AutoCompleter #shouldOpenMorph stamp: 'Install-6287-AutoCompleterCleanup-JuanVuletich-2024Mar21-09h05m-jmv.001.cs.st 3/22/2024 14:39:51'!
shouldOpenMorph

	| currentPos currentChar |
	
	textMorph editor hasSelection ifTrue: [ ^ false ].
	
	currentPos := textMorph editor startIndex-1.
	currentPos <= 0 ifTrue: [ ^ false ].
	currentChar := model actualContents at: currentPos.
	
	^ currentChar = Character space
		ifTrue: [ self shouldOpenMorphWhenNoPrefixAt: currentPos-1 ]
		ifFalse: [ self shouldOpenMorphWhenPrefixAt: currentPos and: currentChar ].!

AutoCompleter removeSelector: #shouldOpenMorphWhenPrefixAt:and:!

!methodRemoval: AutoCompleter #shouldOpenMorphWhenPrefixAt:and: stamp: 'Install-6287-AutoCompleterCleanup-JuanVuletich-2024Mar21-09h05m-jmv.001.cs.st 3/22/2024 14:39:51'!
shouldOpenMorphWhenPrefixAt: currentPos and: currentChar 
	
	^ model textSize >= currentPos and: [ currentChar isAlphaNumeric or: [ currentChar isValidInBinarySelectors or: [ currentChar = $: ]]]!

AutoCompleter removeSelector: #shouldOpenMorphWhenNoPrefixFor:!

!methodRemoval: AutoCompleter #shouldOpenMorphWhenNoPrefixFor: stamp: 'Install-6287-AutoCompleterCleanup-JuanVuletich-2024Mar21-09h05m-jmv.001.cs.st 3/22/2024 14:39:51'!
shouldOpenMorphWhenNoPrefixFor: currentChar 
	
	^currentChar isAlphaNumeric 
		or: [ currentChar = $]
		or: [ currentChar = $) 
		or: [ currentChar = $; ]]]!

AutoCompleter removeSelector: #shouldOpenMorphWhenNoPrefixAt:!

!methodRemoval: AutoCompleter #shouldOpenMorphWhenNoPrefixAt: stamp: 'Install-6287-AutoCompleterCleanup-JuanVuletich-2024Mar21-09h05m-jmv.001.cs.st 3/22/2024 14:39:51'!
shouldOpenMorphWhenNoPrefixAt: currentPos 
	
	^  model textSize >= currentPos 
		and: [ currentPos > 0
		and: [ self shouldOpenMorphWhenNoPrefixFor: (model actualContents at: currentPos) ]]!

AutoCompleter removeSelector: #isTab:and:!

!methodRemoval: AutoCompleter #isTab:and: stamp: 'Install-6287-AutoCompleterCleanup-JuanVuletich-2024Mar21-09h05m-jmv.001.cs.st 3/22/2024 14:39:51'!
isTab: kbEvent and: shouldOpenMoprh
	
	^ self opensWithTab 
		and: [ kbEvent isTab 
		and: [ shouldOpenMoprh ]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6287-AutoCompleterCleanup-JuanVuletich-2024Mar21-09h05m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6287] on 21 March 2024 at 11:38:30 am'!
!CharacterScanner methodsFor: 'private' stamp: 'jmv 3/21/2024 11:36:18' prior: 16812510!
  setFont
	| attributes |
	"Set the font and other emphasis.
	In fact set actual ParagraphStyle (or nil), alignment, font and emphasis"

	self setActualFont: (text fontAt: lastIndex default: defaultFont).
	attributes := text attributesAt: lastIndex.
	text
		withAttributeValues: attributes
		do: [ :familyNameInText :pointSizeInText :emphasisInText :colorInText :alignmentInText :characterStyleInText :paragraphStyleInText :backgroundColorInText |
			colorInText ifNotNil: [ self textColor: colorInText ].
			self backgroundColor: backgroundColorInText.
			alignment := alignmentInText.
			paragraphStyle := paragraphStyleInText ].
	
	"Hardcoded color for TextAction"
	attributes do: [ :attribute |
		attribute forTextActionInfoDo: [ :info |
			self textColor: TextAction textActionColor ]].

	"Install various parameters from the font."
	spaceWidth := font widthOf: Character space.
	tabWidth := font pointSize * 3.! !
!CharacterScanner methodsFor: 'stop conditions' stamp: 'jmv 3/21/2024 11:37:01' prior: 16812622!
         tabDestX
	"This is the basic method of adjusting destX for a tab."

	^paragraphStyle
		ifNotNil: [
			paragraphStyle
				nextTabXFrom: destX
				leftMargin: leftMargin
				rightMargin: rightMargin ]
		ifNil: [
			(tabCount+1 * tabWidth max: destX) min: rightMargin ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6288-TabColumnAlignmentTweaks-JuanVuletich-2024Mar21-11h36m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6288] on 21 March 2024 at 11:44:55 am'!
!Workspace class methodsFor: 'menu-world' stamp: 'jmv 3/21/2024 11:42:00' prior: 50350669!
       worldMenuOptions
	^ `{{
			#submenuOf 				-> 	TheWorldMenu openLabel.
			#itemGroup 				-> 	10.
			#itemOrder 				-> 	20.
			#label 				-> 	'Workspace'.
			#object 				-> 	Workspace.
			#selector 				-> 	#open.
			#icon 				-> 	#terminalIcon.
			#balloonText 				-> 	'A window for evaluating Smalltalk expressions'.
		} asDictionary}`! !
!Collection methodsFor: 'converting' stamp: 'jmv 3/21/2024 10:49:13' prior: 50350714!
                        asDictionary
	"Answer a Dictionary. Assume our elements are Associations.
	{
			#itemGroup 			-> 	10.
			#itemOrder 			-> 	30.
			#label 			-> 	'Browser'.
			#object 			-> 	Browser.
			#selector 			-> 	#open.
			#icon 			-> 	#editFindReplaceIcon.
			#balloonText 			-> 	'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary
	"

	^ self as: Dictionary! !
!Transcripter class methodsFor: 'menu-world' stamp: 'jmv 3/21/2024 11:42:31' prior: 16988788!
  worldMenuOptions
	^ `{{
			#submenuOf 				-> 	TheWorldMenu openLabel.
			#itemGroup 				-> 	30.
			#itemOrder 				-> 	20.
			#label 				-> 	'Emergency Evaluator'.
			#object 				-> 	Transcripter.
			#selector 				-> 	#emergencyEvaluator.
			#icon 				-> 	#emblemImportantIcon.
			#balloonText 				-> 	'When all else fails...'.
		} asDictionary}`! !
!TextEditor class methodsFor: 'menu-world' stamp: 'jmv 3/21/2024 11:42:46' prior: 50350729!
       worldMenuOptions
	^ `{{
			#submenuOf 				-> 	TheWorldMenu openLabel.
			#itemGroup 				-> 	10.
			#itemOrder 				-> 	10.
			#label 				-> 	'Text Editor'.
			#object 				-> 	TextEditor.
			#selector 				-> 	#open.
			#icon 				-> 	#textEditorIcon.
			#balloonText 				-> 	'A window for composing text'.
		} asDictionary}`! !
!SmalltalkEditor class methodsFor: 'menu' stamp: 'jmv 3/21/2024 11:24:01' prior: 16955360!
smalltalkEditorMenuOptions
	
	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Help...'.
				#selector 			-> 		#openHelp.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Do it (d)'.
				#selector 			-> 		#doIt.
				#icon 			-> 		#doItIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Print it (p)'.
				#selector 			-> 		#printIt.
				#icon 			-> 		#printIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'Inspect it (i)'.
				#selector 			-> 		#inspectIt.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		40.
				#label 			-> 		'Explore it (I)'.
				#selector 			-> 		#exploreIt.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		50.
				#label 			-> 		'Debug it (D)'.
				#selector 			-> 		#debugIt.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		60.
				#label 			-> 		'Profile it'.
				#selector 			-> 		#profileIt.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		5.
				#label 			-> 		SmalltalkEditor editMenuLabel.
				#selector 			-> 		#yourself.
				#icon 			-> 		#textEditorIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'Explain'.
				#selector 			-> 		#explain.
				#icon 			-> 		#helpIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'Browse it (b)'.
				#selector 			-> 		#browseIt.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		30.
				#label 			-> 		'Senders of it (n)'.
				#selector 			-> 		#sendersOfIt.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		40.
				#label 			-> 		'Implementors of it (m)'.
				#selector 			-> 		#implementorsOfIt.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		50.
				#label 			-> 		'References to it (N)'.
				#selector 			-> 		#referencesToIt.
				#icon 			-> 		#addressBookIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Method Strings with it (E)'.
				#selector 			-> 		#methodStringsContainingIt.
				#icon 			-> 		#genericTextIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Method Source with it (e)'.
				#selector 			-> 		#methodSourceContainingIt.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'Class Comments with it'.
				#selector 			-> 		#classCommentsContainingIt.
				#icon 			-> 		#chatIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'Accept (s)'.
				#selector 			-> 		#acceptContents.
				#icon 			-> 		#acceptIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		30.
				#label 			-> 		'Accept & Run Test in Class (t)'.
				#selector 			-> 		#acceptAndTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		40.
				#label 			-> 		'Accept & Run Test in Category (y)'.
				#selector 			-> 		#acceptAndTestAll.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		50.
				#label 			-> 		'Accept & Debug Test (r)'.
				#selector 			-> 		#acceptAndDebugTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}, SmalltalkEditor smalltalkEditorEditingMenuOptions `. ! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 3/21/2024 11:24:17' prior: 16924886 overrides: 16904202!
        mouseScroll: aMouseEvent localPosition: localEventPosition
	aMouseEvent direction
		caseOf: {
			[ #up ] 			-> 		[ scrollBar scrollUp: 1 ].
			[ #down ] 			-> 		[ scrollBar scrollDown: 1 ].
			[ #left ] 			-> 		[ hScrollBar scrollUp: 1 ].
			[ #right ] 			-> 		[ hScrollBar scrollDown: 1 ] }! !
!CodePackageListWindow class methodsFor: 'menu-world' stamp: 'jmv 3/21/2024 10:59:06' prior: 50350797!
                  worldMenuOptions
	^ `{{
			#submenuOf 			-> TheWorldMenu openLabel.
			#itemGroup 			-> 	20.
			#itemOrder 			-> 	10.
			#label 			-> 	'Installed Packages'.
			#object 			-> 	CodePackageList.
			#selector 			-> 	#open.
			#icon 			-> 	#packageIcon.
			#balloonText 			-> 	'A tool for managing Packages (optional units of code) installed in the system'.
		} asDictionary}`! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'jmv 3/21/2024 10:55:52' prior: 16800204!
      classListMoreMenuOptions

	^ `{			
			{
				#submenuOf 				-> 		BrowserWindow moreMenuLabel.
				#itemGroup 				-> 		10.
				#itemOrder 				-> 		10.
				#label 				-> 		'unsent methods'.
				#selector 				-> 		#browseUnusedMethods.
				#icon 				-> 		#junkIcon.
				#balloonText 				-> 		'browse all methods defined by this class that have no senders'
			} asDictionary.
			{
				#submenuOf 				-> 		BrowserWindow moreMenuLabel.
				#itemGroup 				-> 		10.
				#itemOrder 				-> 		20.
				#label 				-> 		'unreferenced inst vars'.
				#selector 				-> 		#showUnreferencedInstVars.
				#icon 				-> 		#junkIcon.
				#balloonText 				-> 		'show a list of all instance variables that are not referenced in methods'
			} asDictionary.
			{
				#submenuOf 				-> 		BrowserWindow moreMenuLabel.
				#itemGroup 				-> 		10.
				#itemOrder 				-> 		30.
				#label 				-> 		'unreferenced class vars'.
				#selector 				-> 		#showUnreferencedClassVars.
				#icon 				-> 		#junkIcon.
				#balloonText 				-> 		'show a list of all class variables that are not referenced in methods'
			} asDictionary.
			{
				#submenuOf 				-> 		BrowserWindow moreMenuLabel.
				#itemGroup 				-> 		10.
				#itemOrder 				-> 		40.
				#label 				-> 		'subclass template'.
				#object 				-> 		#model.
				#selector 				-> 		#makeNewSubclass.
				#icon 				-> 		#classIcon.
				#balloonText 				-> 		'put a template into the code pane for defining of a subclass of this class'
			} asDictionary.
			{
				#submenuOf 				-> 		BrowserWindow moreMenuLabel.
				#itemGroup 				-> 		20.
				#itemOrder 				-> 		10.
				#label 				-> 		'sample instance'.
				#selector 				-> 		#makeSampleInstance.
				#icon 				-> 		#instanceIcon.
				#balloonText 				-> 		'give me a sample instance of this class, if possible'
			} asDictionary.
			{
				#submenuOf 				-> 		BrowserWindow moreMenuLabel.
				#itemGroup 				-> 		20.
				#itemOrder 				-> 		20.
				#label 				-> 		'inspect instances'.
				#selector 				-> 		#inspectInstances.
				#icon 				-> 		#inspectIcon.
				#balloonText 				-> 		'open an inspector on all the extant instances of this class'
			} asDictionary.
			{
				#submenuOf 				-> 		BrowserWindow moreMenuLabel.
				#itemGroup 				-> 		20.
				#itemOrder 				-> 		30.
				#label 				-> 		'inspect subinstances'.
				#selector 				-> 		#inspectSubInstances.
				#icon 				-> 		#inspectIcon.
				#balloonText 				-> 		'open an inspector on all the extant instances of this class and of all of its subclasses'
			} asDictionary.
			{
				#submenuOf 				-> 		BrowserWindow moreMenuLabel.
				#itemGroup 				-> 		30.
				#itemOrder 				-> 		10.
				#label 				-> 		'create inst var accessors'.
				#object 				-> 		#model.
				#selector 				-> 		#createInstVarAccessors.
				#icon 				-> 		#sendReceiveIcon.
				#balloonText 				-> 		'compile instance-variable access methods for any instance variables that do not yet have them'
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'jmv 3/21/2024 11:09:48' prior: 16800375!
    messageListMenu2Options
	
	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'toggle diffing (D)'.
				#object 			-> 		#model.
				#selector 			-> 		#toggleDiffing.
				#icon 			-> 		#switchIcon
			} asDictionary.
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'implementors of sent messages'.
				#selector 			-> 		#browseAllMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'local senders of...'.
				#selector 			-> 		#browseLocalSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'local implementors of...'.
				#selector 			-> 		#browseLocalImplementors.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'spawn sub-protocol'.
				#selector 			-> 		#browseProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'spawn full protocol'.
				#selector 			-> 		#browseFullProtocol.
				#icon 			-> 		#speadsheetTemplateIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'sample instance'.
				#selector 			-> 		#makeSampleInstance.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'inspect instances'.
				#selector 			-> 		#inspectInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'inspect subinstances'.
				#selector 			-> 		#inspectSubInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		40.
				#label 			-> 		'change category...'.
				#object 			-> 		#model.
				#selector 			-> 		#changeCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		50.
				#label 			-> 		'change sets with this method'.
				#selector 			-> 		#findMethodInChangeSets.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		60.
				#label 			-> 		'revert to previous version'.
				#object 			-> 		#model.
				#selector 			-> 		#revertToPreviousVersion.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'more...'.
				#selector 			-> 		#openMessageListMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.			
		}`! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'jmv 3/21/2024 11:10:04' prior: 50359500!
                        messageListMenuOptions

	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'what to show...'.
				#selector 			-> 		#offerWhatToShowMenu.
				#icon 			-> 		#preferencesIcon
			} asDictionary.
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'toggle break on entry'.
				#object 			-> 		#model.
				#selector 			-> 		#toggleBreakOnEntry.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 			-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 			-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'browse method (O)'.
				#selector 			-> 		#openSingleMessageBrowser.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		40.
				#label 			-> 		'browse protocol (p)'.
				#selector 			-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{	#itemGroup  			-> 		20.
				#itemOrder  			-> 		50.
				#label            			-> 		'browse method category (c)'.
				#selector       			-> 		#browseCategoryOfCurrentMethod.
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 			-> 		#fileOutMessage.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'inspect CompiledMethod'.
				#object 			-> 		#model.
				#selector 			-> 		#inspectCompiledMethod.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'senders of... (n)'.
				#selector 			-> 		#browseSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'implementors of... (m)'.
				#selector 			-> 		#browseMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'inheritance (i)'.
				#selector 			-> 		#methodInheritance.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		40.
				#label 			-> 		'versions (v)'.
				#selector 			-> 		#browseVersions.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 			-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 			-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		30.
				#label 			-> 		'class var refs...'.
				#selector 			-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		40.
				#label 			-> 		'class variables'.
				#selector 			-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		50.
				#label 			-> 		'class refs (N)'.
				#selector 			-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		10.
				#label 			-> 		'remove method (x)'.
				#object 			-> 		#model.
				#selector 			-> 		#removeMessage.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		20.
				#label 			-> 		'remove method in hierarchy'.
				#object 			-> 		#model.
				#selector 			-> 		#removeMessageInHierarchy.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		30.
				#label 			-> 		'run test (t)'.
				#object 			-> 		#model.
				#selector 			-> 		#runMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		40.
				#label 			-> 		'debug test (r)'.
				#object 			-> 		#model.
				#selector 			-> 		#debugMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		70.
				#itemOrder 			-> 		10.
				#label 			-> 		'more...'.
				#selector 			-> 		#openMessageListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'browser menues' stamp: 'jmv 3/21/2024 11:10:27' prior: 16800658!
       systemCategoryMenuOptions

	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'find class... (f)'.
				#selector 			-> 		#findClass.
				#icon 			-> 		#findIcon
			} asDictionary.
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'recent classes... (r)'.
				#object 			-> 		#model.
				#selector 			-> 		#recent.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'browse all (B)'.
				#selector 			-> 		#browseAllClasses.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'browse (b)'.
				#selector 			-> 		#openSystemCategoryBrowser.
				#icon 			-> 		#packageIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'fileOut (o)'.
				#object 			-> 		#model.
				#selector 			-> 		#fileOutSystemCategory.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'reorganize'.
				#object 			-> 		#model.
				#selector 			-> 		#editSystemCategories.
				#icon 			-> 		#sendReceiveIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'alphabetize (A)'.
				#object 			-> 		#model.
				#selector 			-> 		#alphabetizeSystemCategories.
				#icon 			-> 		#fontXGenericIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'update (u)'.
				#object 			-> 		#model.
				#selector 			-> 		#updateSystemCategories.
				#icon 			-> 		#updateIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		20.
				#label 			-> 		'add item... (a)'.
				#object 			-> 		#model.
				#selector 			-> 		#addSystemCategory.
				#icon 			-> 		#newIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		30.
				#label 			-> 		'rename... (R)'.
				#object 			-> 		#model.
				#selector 			-> 		#renameSystemCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		35.
				#label 			-> 		'move to... (m)'.
				#object 			-> 		#model.
				#selector 			-> 		#moveAllToOtherSystemCategory.
				#icon 			-> 		#saveAsIcon.
				#balloonText 			-> 		'Move all classes in this category to another category'       
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		40.
				#label 			-> 		'remove (x)'.
				#object 			-> 		#model.
				#selector 			-> 		#removeSystemCategory.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		10.
				#label 			-> 		'move to top'.
				#object 			-> 		#model.
				#selector 			-> 		#moveSystemCategoryTop.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		20.
				#label 			-> 		'move up'.
				#object 			-> 		#model.
				#selector 			-> 		#moveSystemCategoryUp.
				#icon 			-> 		#goUpIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		30.
				#label 			-> 		'move down'.
				#object 			-> 		#model.
				#selector 			-> 		#moveSystemCategoryDown.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		40.
				#label 			-> 		'move to bottom'.
				#object 			-> 		#model.
				#selector 			-> 		#moveSystemCategoryBottom.
				#icon 			-> 		#goBottomIcon
			} asDictionary.
			{
				#itemGroup 			-> 		70.
				#itemOrder 			-> 		10.
				#label 			-> 		'run tests (t)'.
				#object 			-> 		#model.
				#selector 			-> 		#runSystemCategoryTests.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
		}`.
	! !
!BrowserWindow class methodsFor: 'menu-world' stamp: 'jmv 3/21/2024 10:59:13' prior: 50350812!
               worldMenuOptions
	^ `{{
			#submenuOf 			-> 		TheWorldMenu openLabel.
			#itemGroup 			-> 		10.
			#itemOrder 			-> 		30.
			#label 			-> 		'Browser'.
			#object 			-> 		Browser.
			#selector 			-> 		#open.
			#icon 			-> 		#editFindReplaceIcon.
			#balloonText 			-> 		'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary}`! !
!ChangeListWindow methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:15:05' prior: 16805544!
                          listMenu
	"Fill aMenu up so that it comprises the primary changelist-browser menu"

	| aMenu |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Change List'.
	aMenu addStayUpIcons.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'fileIn selections'.
				#object 			-> 		#model.
				#selector 			-> 		#fileInSelections.
				#balloonText 		-> 		'import the selected items into the image'.
			} asDictionary.
			{
				#label 			-> 		'fileOut selections...	'.
				#object 			-> 		#model.
				#selector 			-> 		#fileOutSelections.
				#balloonText 		-> 		'create a new file containing the selected items'.
			} asDictionary.
			{
				#label 			-> 		'fileOut current version of selections...'.
				#object 			-> 		#model.
				#selector 			-> 		#fileOutCurrentVersionsOfSelections.
				#balloonText 		-> 		'create a new file containing the current (in-image) counterparts of the selected methods'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'compare to current'.
				#object 			-> 		#model.
				#selector 			-> 		#compareToCurrentVersion.
				#balloonText 		-> 		'open a separate window which shows the text differences between the on-file version and the in-image version.'.
			} asDictionary.
			{
				#label 			-> 		'toggle diffing (D)'.
				#object 			-> 		#model.
				#selector 			-> 		#toggleDiffing.
				#balloonText 	-> 			'start or stop showing diffs in the code pane.'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'select new methods'.
				#object 			-> 		#model.
				#selector 			-> 		#selectNewMethods.
				#balloonText 	-> 			'select methods in the file that do not currently exist in the image'.
			} asDictionary.
			{
				#label 			-> 		'select changes for absent classes'.
				#object 			-> 		#model.
				#selector 			-> 		#selectAllForAbsentClasses.
				#balloonText 	-> 			'select methods in the file for classes that are not defined in the image'.
			} asDictionary.
			{
				#label 			-> 		'select all changes for this class'.
				#object 			-> 		#model.
				#selector 			-> 		#selectAllForThisClass.
				#balloonText 	-> 			'select all methods in the file that belong to the currently-selected class'.
			} asDictionary.
			{
				#label 			-> 		'select unchanged methods'.
				#object 			-> 		#model.
				#selector 		-> 		#selectUnchangedMethods.
				#balloonText 	-> 		'select methods in the file whose in-image versions are the same as their in-file counterparts'.
			} asDictionary.
			{
				#label 			-> 		'select methods equivalent to current'.
				#object 			-> 		#model.
				#selector 			-> 		#selectEquivalentMethods.
				#balloonText 	-> 			'select methods in the file whose in-image versions have the same behavior as their in-file counterparts'.
			} asDictionary.
			{
				#label 			-> 		'select methods older than current'.
				#object 			-> 		#model.
				#selector 			-> 		#selectMethodsOlderThanCurrent.
				#balloonText 	-> 			'select methods in the file that are older than the one currently in the image'.
			} asDictionary.
			{
				#label 			-> 		'select removals of sent methods'.
				#object 			-> 		#model.
				#selector 			-> 		#selectRemovalsOfSent.
				#balloonText 	-> 			'select all method removals of methods that have some sender in the image'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'select all (a)'.
				#object 			-> 		#model.
				#selector 			-> 		#selectAll.
				#balloonText 	-> 			'select all the items in the list'.
			} asDictionary.
			{
				#label 			-> 		'deselect all (A)'.
				#object 			-> 		#model.
				#selector 			-> 		#deselectAll.
				#balloonText 	-> 			'deselect all the items in the list'.
			} asDictionary.
			{
				#label 			-> 		'invert selections'.
				#object 			-> 		#model.
				#selector 			-> 		#invertSelections.
				#balloonText 	-> 			'select every item that is not currently selected, and deselect every item that *is* currently selected'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse class and method'.
				#selector 			-> 		#browseMethodFull.
				#balloonText 	-> 			'open a full browser showing the selected method'.
			} asDictionary.
			{
				#label 			-> 		'browse all versions of single selection'.
				#selector 			-> 		#browseVersions.
				#balloonText 	-> 			'open a version browser showing the versions of the currently selected method'.
			} asDictionary.
			{
				#label 			-> 		'browse current versions of selections'.
				#selector 			-> 		#browseCurrentVersionsOfSelections.
				#balloonText 	-> 			'open a message-list browser showing the current (in-image) counterparts of the selected methods'.
			} asDictionary.
			{
				#label 			-> 		'destroy current methods of selections'.
				#object 			-> 		#model.
				#selector 			-> 		#destroyCurrentCodeOfSelections.
				#balloonText 	-> 			'remove (*destroy*) the in-image counterparts of all selected methods'.
			} asDictionary.
			nil.
			{
				#label 			-> 		'remove doIts'.
				#object 			-> 		#model.
				#selector 			-> 		#removeDoIts.
				#balloonText 	-> 			'remove all items that are doIts rather than definitions'.
			} asDictionary.
			{
				#label 			-> 		'remove older versions'.
				#object 			-> 		#model.
				#selector 			-> 		#removeOlderMethodVersions.
				#balloonText 	-> 			'remove all but the most recent versions of methods in the list'.
			} asDictionary.
			{
				#label 			-> 		'remove up-to-date versions'.
				#object 			-> 		#model.
				#selector 			-> 		#removeUpToDate.
				#balloonText 	-> 			'remove all items whose code is the same as the counterpart in-image code'.
			} asDictionary.
			{
				#label 			-> 		'remove empty class comments'.
				#object 			-> 		#model.
				#selector 			-> 		#removeEmptyClassComments.
				#balloonText 	-> 			'remove all empty class comments'.
			} asDictionary.
			{
				#label 			-> 		'remove selected items'.
				#object 			-> 		#model.
				#selector 			-> 		#removeSelections.
				#balloonText 	-> 			'remove the selected items from the change-list'.
			} asDictionary.
			{
				#label 			-> 		'remove unselected items'.
				#object 			-> 		#model.
				#selector 			-> 		#removeNonSelections.
				#balloonText 	-> 			'remove all the items not currently selected from the change-list'.
			} asDictionary.
		}`.
	^ aMenu! !
!VersionsBrowserWindow methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:14:16' prior: 17004320!
                    classCommentVersionsMenu
	| aMenu |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: model.				"all commands are implemented by the model, not the view"
	aMenu addTitle: 'versions'.
	aMenu addStayUpIcons.
	aMenu addItemsFromDictionaries: `{
		{
			#label 			-> 		'compare to current'.
			#selector 			-> 		#compareToCurrentVersion.
			#balloonText 	-> 			'compare selected version to the current version'
		} asDictionary.
		{
			#label 			-> 		'revert to selected version'.
			#selector 			-> 		#fileInSelections.
			#balloonText 	-> 			'resubmit the selected version, so that it becomes the current version'
		} asDictionary.
		nil.
		{
			#label 			-> 		'toggle diffing (D)'.
			#selector 			-> 		#toggleDiffing.
			#balloonText 	-> 			'toggle whether or not diffs should be shown here'
		} asDictionary.
		{
			#label 			-> 		'update list'.
			#selector 			-> 		#reformulateList.
			#balloonText 	-> 			'reformulate the list of versions, in case it somehow got out of synch with reality'
		} asDictionary.
		nil.
		{
			#label 			-> 		'help...'.
			#selector 			-> 		#offerVersionsHelp.
			#balloonText 	-> 			'provide an explanation of the use of this tool'
		} asDictionary.
	}`.
	^aMenu! !
!VersionsBrowserWindow methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:15:32' prior: 17004369!
                  methodVersionsMenu
	"Fill aMenu with menu items appropriate to the receiver"

	| aMenu |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Versions'.
	aMenu addStayUpIcons.
	model listIndex > 0 ifTrue:[
		(model list size > 1 ) ifTrue: [
			aMenu addItemsFromDictionaries: `{
				{
					#label 			-> 			'compare to current'.
					#object 			-> 			#model.
					#selector 			-> 			#compareToCurrentVersion.
					#balloonText 	-> 			'compare selected version to the current version'
				} asDictionary.
				{
					#label 			-> 			'compare to version...'.
					#object 			-> 			#model.
					#selector 			-> 			#compareToOtherVersion.
					#balloonText 	-> 			'compare selected version to another selected version'
				} asDictionary.
			}` ].
		"Note: Revert to selected should be visible for lists of length one for having the ability to revert to an accidentally deleted method"
		aMenu addItemsFromDictionaries: `{
			{
				#label 			-> 			'revert to selected version (z)'.
				#object 			-> 			#model.
				#selector 			-> 			#fileInSelections.
				#balloonText 	-> 			'resubmit the selected version, so that it becomes the current version'
			} asDictionary.
		}` ].

	aMenu addItemsFromDictionaries: `{
		{
			#label 			-> 			'edit current method (O)'.
			#selector 			-> 			#openSingleMessageBrowser.
			#balloonText 	-> 			'open a single-message browser on the current version of this method'
		} asDictionary.
		nil.
		{
			#label 			-> 			'toggle diffing (D)'.
			#object 			-> 			#model.
			#selector 			-> 			#toggleDiffing.
			#balloonText 	-> 			'toggle whether or not diffs should be shown here'
		} asDictionary.
		{
			#label 			-> 			'update list'.
			#object 			-> 			#model.
			#selector 			-> 			#reformulateList.
			#balloonText 	-> 			'reformulate the list of versions, in case it somehow got out of synch with reality'
		} asDictionary.
		nil.
		{
			#label 			-> 			'senders (n)'.
			#selector 			-> 			#browseSenders.
			#balloonText 	-> 			'browse all senders of this selector'
		} asDictionary.
		{
			#label 			-> 			'implementors (m)'.
			#selector 			-> 			#browseImplementors.
			#balloonText 	-> 			'browse all implementors of this selector'
		} asDictionary.
		nil.
		{
			#label 			-> 			'help...'.
			#object 			-> 			#model.
			#selector 			-> 			#offerVersionsHelp.
			#balloonText 	-> 			'provide an explanation of the use of this tool'
		} asDictionary.
	}`.
	^aMenu! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:15:56' prior: 16810477!
      classListMenu
	"Fill aMenu with items appropriate for the class list"

	| aMenu |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu addTitle: 'Class List'.
	aMenu 
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'delete class from change set (d)'.
				#object 			-> 		#model.
				#selector 			-> 		#forgetClass.
				#icon 			-> 		#warningIcon
			} asDictionary.
			{
				#label 			-> 		'remove class from system (x)'.
				#object 			-> 		#model.
				#selector 			-> 		#removeClass.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse full (b)'.
				#selector 			-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#label 			-> 		'browse hierarchy (h)'.
				#selector 			-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#label 			-> 		'browse protocol (p)'.
				#selector 			-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			nil.
			{
				#label 			-> 		'inst var refs...'.
				#selector 			-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#label 			-> 		'inst var defs...'.
				#selector 			-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#label 			-> 		'class var refs...'.
				#selector 			-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#label 			-> 		'class vars'.
				#selector 			-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#label 			-> 		'class refs (N)'.
				#selector 			-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
		}`.
	^ aMenu! !
!ChangeSorterWindow class methodsFor: 'menu-world' stamp: 'jmv 3/21/2024 10:59:19' prior: 50350908!
                  worldMenuOptions
	^ `{{
			#submenuOf 			-> 		TheWorldMenu openLabel.
			#itemGroup 			-> 		20.
			#itemOrder 			-> 		20.
			#label 			-> 		'Change Sorter'.
			#object 			-> 		ChangeSorter.
			#selector 			-> 		#open.
			#icon 			-> 		#halfRefreshIcon.
			#balloonText 			-> 		'A tool allowing you to view the methods in a Change Set, especially changes to the Base System'.
		} asDictionary}`! !
!DebuggerWindow methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:16:08' prior: 16845756!
                      contextFieldListMenu
	"Arm the supplied menu with items for the field-list of the receiver"

	| aMenu |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'explore (I)'.
				#selector 			-> 		#exploreContextSelection
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse hierarchy (h)'.
				#selector 			-> 		#contextClassHierarchy
			} asDictionary.
		}`.
	^ aMenu! !
!DebuggerWindow methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:16:21' prior: 16845773!
              contextStackMenu
	"Set up the menu appropriately for the context-stack-list, either shifted or unshifted as per the parameter provided"

	| aMenu |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'fullStack (f)'.
				#selector 			-> 		#fullStack
			} asDictionary.
			{
				#label 			-> 		'restart (r)'.
				#selector 			-> 		#restart
			} asDictionary.
			{
				#label 			-> 		'proceed (p)'.
				#selector 			-> 		#proceed
			} asDictionary.
			{
				#label 			-> 		'step (t)'.
				#selector 			-> 		#doStep
			} asDictionary.
			{
				#label 			-> 		'step through (T)'.
				#selector 			-> 		#stepIntoBlock
			} asDictionary.
			{
				#label 			-> 		'send (e)'.
				#selector 			-> 		#send
			} asDictionary.
			{
				#label 			-> 		'where (w)'.
				#selector 			-> 		#where
			} asDictionary.
			{
				#label 			-> 		'peel to first like this'.
				#selector 			-> 		#peelToFirst
			} asDictionary.
			nil.
			{
				#label 			-> 		'return entered value'.
				#selector 			-> 		#returnValue
			} asDictionary.
			{
				#label 			-> 		'toggle break on entry'.
				#object 			-> 		#model.
				#selector 			-> 		#toggleBreakOnEntry
			} asDictionary.
		}`.
	^aMenu! !
!DebuggerWindow methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:16:27' prior: 16845815!
                   receiverFieldListMenu
	"Arm the supplied menu with items for the field-list of the receiver"

	| aMenu |
	self flag: #assumesKeyboardShortcuts.
	aMenu := MenuMorph new defaultTarget: self.
	aMenu
		addItemsFromDictionaries: `{
			{
				#label 			-> 		'explore (I)'.
				#selector 			-> 		#exploreReceiverSelection
			} asDictionary.
			nil.
			{
				#label 			-> 		'browse hierarchy (h)'.
				#selector 			-> 		#receiverClassHierarchy
			} asDictionary.
		}`.
	^ aMenu! !
!MethodSetWindow class methodsFor: 'browser menues' stamp: 'jmv 3/21/2024 11:17:31' prior: 50356792!
   messageSetMenu2Options
	
	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'toggle diffing (D)'.
				#object 			-> 		#model.
				#selector 			-> 		#toggleDiffing.
				#icon 			-> 		#switchIcon
			} asDictionary.
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'implementors of sent messages'.
				#selector 			-> 		#browseAllMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'local senders of...'.
				#selector 			-> 		#browseLocalSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'local implementors of...'.
				#selector 			-> 		#browseLocalImplementors.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'spawn sub-protocol'.
				#selector 			-> 		#browseProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'spawn full protocol'.
				#selector 			-> 		#browseFullProtocol.
				#icon 			-> 		#speadsheetTemplateIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'sample instance'.
				#selector 			-> 		#makeSampleInstance.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'inspect instances'.
				#selector 			-> 		#inspectInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'inspect subinstances'.
				#selector 			-> 		#inspectSubInstances.
				#icon 			-> 		#inspectIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		40.
				#label 			-> 		'change category...'.
				#object 			-> 		#model.
				#selector 			-> 		#changeCategory.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		50.
				#label 			-> 		'change sets with this method'.
				#selector 			-> 		#findMethodInChangeSets.
				#icon 			-> 		#changesIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		60.
				#label 			-> 		'revert to previous version'.
				#object 			-> 		#model.
				#selector 			-> 		#revertToPreviousVersion.
				#icon 			-> 		#undoIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'more...'.
				#selector 			-> 		#openMessageListMenu.
				#icon 			-> 		#listAddIcon
			} asDictionary.			
		}`! !
!MethodSetWindow class methodsFor: 'browser menues' stamp: 'jmv 3/21/2024 11:17:40' prior: 50356879!
                       messageSetMenuOptions

	self flag: #assumesKeyboardShortcuts.
	^`{
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'what to show...'.
				#selector 			-> 		#offerWhatToShowMenu.
				#icon 			-> 		#preferencesIcon
			} asDictionary.
			{
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'toggle break on entry'.
				#object 			-> 		#model.
				#selector 			-> 		#toggleBreakOnEntry.
				#icon 			-> 		#debugIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'browse full (b)'.
				#selector 			-> 		#browseMethodFull.
				#icon 			-> 		#editFindReplaceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'browse hierarchy (h)'.
				#selector 			-> 		#browseHierarchy.
				#icon 			-> 		#goTopIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'browse method (O)'.
				#selector 			-> 		#openSingleMessageBrowser.
				#icon 			-> 		#scriptIcon
			} asDictionary.
			{
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		40.
				#label 			-> 		'browse protocol (p)'.
				#selector 			-> 		#browseFullProtocol.
				#icon 			-> 		#spreadsheetIcon
			} asDictionary.
			{	#itemGroup  			-> 		20.
				#itemOrder  			-> 		50.
				#label            			-> 		'browse method category (c)'.
				#selector       			-> 			#browseCategoryOfCurrentMethod.
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'fileOut'.
				#object 			-> 		#model.
				#selector 			-> 		#fileOutMessage.
				#icon 			-> 		#fileOutIcon
			} asDictionary.
			{
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'inspect CompiledMethod'.
				#object 			-> 		#model.
				#selector 			-> 		#inspectCompiledMethod.
				#icon 			-> 		#exploreIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'senders of... (n)'.
				#selector 			-> 		#browseSendersOfMessages.
				#icon 			-> 		#mailForwardIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'implementors of... (m)'.
				#selector 			-> 		#browseMessages.
				#icon 			-> 		#developmentIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'inheritance (i)'.
				#selector 			-> 		#methodInheritance.
				#icon 			-> 		#goDownIcon
			} asDictionary.
			{
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		40.
				#label 			-> 		'versions (v)'.
				#selector 			-> 		#browseVersions.
				#icon 			-> 		#clockIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'inst var refs...'.
				#selector 			-> 		#browseInstVarRefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		20.
				#label 			-> 		'inst var defs...'.
				#selector 			-> 		#browseInstVarDefs.
				#icon 			-> 		#instanceIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		30.
				#label 			-> 		'class var refs...'.
				#selector 			-> 		#browseClassVarRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		40.
				#label 			-> 		'class variables'.
				#selector 			-> 		#browseClassVariables.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		50.
				#label 			-> 		'class refs (N)'.
				#selector 			-> 		#browseClassRefs.
				#icon 			-> 		#classIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		10.
				#label 			-> 		'remove method (x)'.
				#object 			-> 		#model.
				#selector 			-> 		#removeMessage.
				#icon 			-> 		#deleteIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		20.
				#label 			-> 		'run test (t)'.
				#object 			-> 		#model.
				#selector 			-> 		#runMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		30.
				#label 			-> 		'debug test (r)'.
				#object 			-> 		#model.
				#selector 			-> 		#debugMethodTest.
				#icon 			-> 		#weatherFewCloudsIcon
			} asDictionary.
			{
				#itemGroup 			-> 		70.
				#itemOrder 			-> 		10.
				#label 			-> 		'more...'.
				#selector 			-> 		#openMessageListMenu2.
				#icon 			-> 		#listAddIcon
			} asDictionary.
		}`.
	! !
!MessageNamesWindow class methodsFor: 'menu-world' stamp: 'jmv 3/21/2024 10:59:22' prior: 50350893!
                worldMenuOptions
	^ `{{
			#submenuOf 			-> 		TheWorldMenu openLabel.
			#itemGroup 			-> 		10.
			#itemOrder 			-> 		40.
			#label 			-> 		'Message Names'.
			#object 			-> 		MessageNames.
			#selector 			-> 		#open.
			#icon 			-> 		#inspectIcon.
			#balloonText 			-> 		'A tool for finding and editing methods that contain any given keyword in their names.'.
		} asDictionary}`! !
!FileListWindow class methodsFor: 'menu-world' stamp: 'jmv 3/21/2024 10:59:26' prior: 50350924!
worldMenuOptions
	^ `{{
			#submenuOf 			-> 		TheWorldMenu openLabel.
			#itemGroup 			-> 		40.
			#itemOrder 			-> 		10.
			#label 			-> 		'File List'.
			#object 			-> 		FileList.
			#selector 			-> 		#open.
			#icon 			-> 		#systemFileManagerIcon.
			#balloonText 			-> 		'An explorer of the File System'.
		} asDictionary}`! !
!ProcessBrowserWindow class methodsFor: 'menu-world' stamp: 'jmv 3/21/2024 10:59:30' prior: 50350938!
               worldMenuOptions
	^ `{{
			#submenuOf 			-> 		TheWorldMenu openLabel.
			#itemGroup 			-> 		30.
			#itemOrder 			-> 		10.
			#label 			-> 		'Process Browser'.
			#object 			-> 		ProcessBrowser.
			#selector 			-> 		#open.
			#icon 			-> 		#systemMonitorIcon.
			#balloonText 			-> 		'A tool to monitor and manage Smalltalk processes'.
		} asDictionary}`! !
!TestRunnerWindow class methodsFor: 'menu-world' stamp: 'jmv 3/21/2024 10:59:33' prior: 50350952!
                         worldMenuOptions
	^ `{{
			#submenuOf 			-> 		TheWorldMenu openLabel.
			#itemGroup 			-> 		40.
			#itemOrder 			-> 		20.
			#label 			-> 		'SUnit Test Runner'.
			#object 			-> 		TestRunner.
			#selector 			-> 		#open.
			#icon 			-> 		#weatherFewCloudsIcon.
			#balloonText 			-> 		'Smalltalk''s testing framework'.
		} asDictionary}`! !
!TranscriptWindow class methodsFor: 'menu-world' stamp: 'jmv 3/21/2024 10:58:51' prior: 50350966!
          worldMenuOptions
	^ `{{
			#submenuOf 			-> 	TheWorldMenu openLabel.
			#itemGroup 			-> 	10.
			#itemOrder 			-> 	50.
			#label 			-> 	'Transcript'.
			#object 			-> 	Transcript.
			#selector 			-> 	#open.
			#icon 			-> 	#printerIcon.
			#balloonText 			-> 	'A window showing contents of the System Transcript'.
		} asDictionary}`! !
!Sample10PythagorasTree methodsFor: 'as yet unclassified' stamp: 'jmv 3/21/2024 11:27:20' prior: 16944666 overrides: 16904202!
                 mouseScroll: aMouseEvent localPosition: localEventPosition
	aMouseEvent direction
		caseOf: {
			[ #up ] 		-> 	[ angle := angle + 0.02. self redrawNeeded ].
			[ #down ] 		-> 	[ angle := (angle - 0.02) max: 0. self redrawNeeded ].
			[ #left ] 		-> 	[ depthLimit := depthLimit - 1 max: 1. self redrawNeeded].
			[ #right ] 		-> 	[ depthLimit := depthLimit + 1 min: 15. self redrawNeeded]
		}! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 3/21/2024 11:31:16' prior: 16891460!
offAxisEdgeWeight: aSymbolOrNumber
	"A LayoutSpec may indicate a weighting perpendicular to the Layout Axis.   
	
	 This is the LayoutSpec's offAxisEdgeWeight which is between 0.0 and 1.0.

	As with LayoutSpec's a symbol may be used.

	If in a Row (preferred): { #rowTop (0.0), #center (0.5), #rowBottom (1.0)}

	If in a Column (preferred): { #columnLeft (0.0), #center (0.5), #columnRight (1.0) }

	Also accepted: { #leftOrTop (0.0), #center (0.5), #rightOrBottom (1.0) }
	"
	| edgeWeight |
	edgeWeight := (aSymbolOrNumber is: #Number)
		ifTrue: [ (aSymbolOrNumber between: 0.0 and: 1.0)
			ifTrue: [ aSymbolOrNumber ] 
			ifFalse: [self error: 'axisEdgeWeight ', aSymbolOrNumber printString, ' is out of range 0.0 to 1.0']
		]
		ifFalse: [ aSymbolOrNumber
			caseOf: {
				[ #leftOrTop ] 				-> [ 0.0 ].
				[ #rowTop ] 				-> [ 0.0 ].
				[ #columnLeft ] 				-> [ 0.0 ].
				[ #center ] 				-> [ 0.5 ].
				[ #rightOrBottom ] 				-> [ 1.0 ].
				[ #rowBottom ] 				-> [ 1.0 ].
				[ #columnRight ] 				-> [ 1.0 ]
			}
			otherwise: [ self error: 'bad offAxisEdgeWeight specifier: ', aSymbolOrNumber  printString ]
		].
	offAxisEdgeWeight := edgeWeight.
	self updateContainingLayout.! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/21/2024 10:59:47' prior: 50354370!
                          additionalMenuOptions

	^`{
		{
			#submenuOf  				-> 		TheWorldMenu openLabel.
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		30.
			#label 				-> 		'Package Installer'.
			#selector 				-> 		#openPackageInstaller.
			#icon 				-> 		#packageIcon.
			#balloonText 				-> 		'A tool for installing Cuis packages from the local file system.'.
		} asDictionary.
		{
			#submenuOf  				-> 		TheWorldMenu openLabel.
			#itemGroup 				-> 		20.
			#itemOrder 				-> 		40.
			#label 				-> 		'Package Downloader'.
			#selector 				-> 		#openPackageDownloader.
			#icon 				-> 		#packageIcon.
			#balloonText 				-> 		'A tool for downloading Cuis packages from the internet.'.
		} asDictionary.
	}`	
	! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:20:09' prior: 50350980!
     changesMenuOptions

	^`{
			{
				#submenuOf  			-> 		TheWorldMenu changesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Change Sorter'.
				#object 			-> 		ChangeSorter.
				#selector 			-> 		#open.
				#icon 			-> 		#halfRefreshIcon.
				#balloonText 	-> 		'Open a 3-paned changed-set viewing tool'.
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu changesLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Install New Updates'.
				#object 			-> 		ChangeSet.
				#selector 			-> 		#installNewUpdates.
				#icon 			-> 		#updateIcon.
				#balloonText 	-> 		'Install in the current image the new updates available
in directory named ./CoreUpdates
or in directory named ../Cuis-Smalltalk-Dev/CoreUpdates'.
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu changesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'Browse my Changes'.
				#object 			-> 		Smalltalk.
				#selector 			-> 		#browseMyChanges.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Browse all of my changes since the last time #condenseSources was run.'.
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu changesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'Recently logged Changes...'.
				#object 			-> 		ChangeList.
				#selector 			-> 		#browseRecentLog.
				#icon 			-> 		#clockIcon.
				#balloonText 	-> 		'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'.
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu changesLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Save World as morph file'.
				#selector 			-> 		#saveWorldInFile.
				#icon 			-> 		#morphsIcon.
				#balloonText 	-> 		'Save a file that, when reloaded, reconstitutes the current World.'.
			} asDictionary.
		}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:01:02' prior: 16984197!
                debugMenuOptions

	^`{
			{
				#submenuOf  			-> 		TheWorldMenu debugLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Inspect World'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#inspect.
				#icon 			-> 		#inspectIcon.
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu debugLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Explore World'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#explore.
				#icon 			-> 		#exploreIcon.
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu debugLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		30.
				#label 			-> 		'MessageTally all Processes'.
				#selector 			-> 		#startMessageTally.
				#icon 			-> 		#systemMonitorIcon.
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu debugLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Start drawing all again'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#removeAllKnownFailing.
				#icon 			-> 		#graphicsIcon.
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu debugLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Start stepping again'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#resumeAfterStepError.
				#icon 			-> 		#mediaPlaybackStartIcon.
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu debugLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'Close all Debuggers'.
				#object 			-> 		DebuggerWindow.
				#selector 			-> 		#closeAllDebuggers.
				#icon 			-> 		#closeIcon.
			} asDictionary.
		}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:03:15' prior: 16984255!
               helpMenuOptions

	^ `{
			{
				#submenuOf 			-> 		TheWorldMenu helpLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'About this System...'.
				#object 			-> 		Smalltalk.
				#selector 			-> 		#aboutThisSystem.
				#icon 			-> 		#helpIcon.
				#balloonText 			-> 		'current version information.'
			} asDictionary.
			{
				#submenuOf 			-> 		TheWorldMenu helpLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Terse Guide to Cuis'.
				#selector 			-> 		#openTerseGuide.
				#icon 			-> 		#helpIcon.
				#balloonText 			-> 		'explore Cuis Smalltalk'
			} asDictionary.
			{
				#submenuOf 			-> 		TheWorldMenu helpLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		30.
				#label 			-> 		'Class Comment Browser'.
				#selector 			-> 		#openCommentGuide.
				#icon 			-> 		#helpIcon.
				#balloonText 			-> 		'search & explore Cuis Class Comments'
			} asDictionary.
			{
				#submenuOf 			-> 		TheWorldMenu helpLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		40.
				#label 			-> 		'Code management in Cuis'.
				#object 			-> 		Utilities.
				#selector 			-> 		#openCodeManagementInCuis.
				#icon 			-> 		#helpIcon.
				#balloonText 			-> 		'Features are kept in Packages.'
			} asDictionary.
			{
				#submenuOf 			-> 		TheWorldMenu helpLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		50.
				#label 			-> 		'Using GitHub to host Cuis packages'.
				#object 			-> 		Utilities.
				#selector 			-> 		#openCuisAndGitHub.
				#icon 			-> 		#helpIcon.
				#balloonText 			-> 		'GitHub usage pattern.'
			} asDictionary.
			{
				#submenuOf 			-> 		TheWorldMenu helpLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Editor keyboard shortcuts'.
				#object 			-> 		SmalltalkEditor.
				#selector 			-> 		#openHelp.
				#icon 			-> 		#keyboardShortcutsIcon.
				#balloonText 			-> 		'summary of keyboard shortcuts in editors for Smalltalk code.'
			} asDictionary.
			{
				#submenuOf 			-> 		TheWorldMenu helpLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Useful Expressions'.
				#object 			-> 		Utilities.
				#selector 			-> 		#openUsefulExpressions.
				#icon 			-> 		#chatIcon.
				#balloonText 			-> 		'a window full of useful expressions.'
			} asDictionary.
			{
				#submenuOf 			-> 		TheWorldMenu helpLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'VM Statistics'.
				#selector 			-> 		#vmStatistics.
				#icon 			-> 		#systemMonitorIcon.
				#balloonText 			-> 		'obtain some intriguing data about the vm.'
			} asDictionary.
			{
				#submenuOf 			-> 		TheWorldMenu helpLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'Space Left'.
				#selector 			-> 		#garbageCollect.
				#icon 			-> 		#removableMediaIcon.
				#balloonText 			-> 		'perform a full garbage-collection and report how many bytes of space remain in the image.'
			} asDictionary.
		}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:20:31' prior: 50331924!
                          preferencesMenuOptions

	^`{
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Focus follows Mouse'.
				#selector 			-> 		#enableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Focus when Click'.
				#selector 			-> 		#disableFocusFollowsMouse.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.

			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Show ST-80 assignments'.
				#selector 			-> 		#enableShowAssignmentAsLeftArrow.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Show ANSI assignments'.
				#selector 			-> 		#disableShowAssignmentAsLeftArrow.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		40.
				#label 			-> 		'Size of GUI elements...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeFontSizes.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		50.
				#label			-> 		'Set System Font...'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#promptUserAndSetDefault.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'change the current system font family.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		60.
				#label			-> 		'Load all TrueType Fonts'.
				#object 			-> 		TrueTypeFontFamily.
				#selector 			-> 		#readAdditionalFonts.
				#icon 			-> 		#preferencesDesktopFontIcon.
				#balloonText 	-> 		'Load additional TrueType fonts included with Cuis.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		70.
				#label 			-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeIcons.
				#icon 			-> 		#worldIcon.
				#balloonText 	-> 		'show more or less icons.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		80.
				#label 			-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeTheme.
				#icon 			-> 		#appearanceIcon.
				#balloonText 	-> 		'switch to another theme.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#showTaskbar.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'show the taskbar'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#hideTaskbar.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'hide the taskbar'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		10.
				#label 			-> 		'Full screen on'.
				#selector 			-> 		#fullScreenOn.
				#icon 			-> 		#viewFullscreenIcon.
				#balloonText 	-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		50.
				#itemOrder 			-> 		20.
				#label 			-> 		'Full screen off'.
				#selector 			-> 		#fullScreenOff.
				#icon 			-> 		#exitFullscreenIcon.
				#balloonText 	-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		10.
				#label 			-> 		'Save Prefs in UserPrefs.txt'.
				#selector 			-> 		#enableUsePrefsFile.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Preferences are saved without need to save the Smalltalk Image.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		20.
				#label 			-> 		'Save Prefs in the Image'.
				#selector 			-> 		#disableUsePrefsFile.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Preferences are lost unless the Smalltalk Image is saved.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		30.
				#label 			-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 			-> 		#setAuthor.
				#icon 			-> 		#usersIcon.
				#balloonText 	-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#submenuOf  			-> 		TheWorldMenu preferencesLabel.
				#itemGroup 			-> 		60.
				#itemOrder 			-> 		40.
				#label 			-> 		'All preferences...'.
				#object 			-> 		PreferenceSet.
				#selector 			-> 		#openPreferencesInspector.
				#icon 			-> 		#preferencesIcon.
				#balloonText 	-> 		'view and change various options.'
			} asDictionary.
		}`.! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/21/2024 11:06:05' prior: 16984530!
                         windowsMenuOptions

	^`{
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Find Window'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findWindow:.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Presents a list of all windows; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Find changed Browsers...'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findDirtyBrowsers:.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		30.
				#label 			-> 		'Find changed Windows...'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findDirtyWindows:.
				#icon 			-> 		#newWindowIcon.
				#balloonText 	-> 		'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  ->  					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Find a Transcript'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findATranscript:.
				#icon 			-> 		#printerIcon.
				#balloonText 	-> 		'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Find a FileList'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAFileList:.
				#icon 			-> 		#systemFileManagerIcon.
				#balloonText 	-> 		'Brings an open fileList  to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'Find a Change Sorter'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAChangeSorter:.
				#icon 			-> 		#changesIcon.
				#balloonText 	-> 		'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		40.
				#label 			-> 		'Find Message Names'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAMessageNamesWindow:.
				#icon 			-> 		#inspectIcon.
				#balloonText 	-> 		'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'Tile open windows'.
				#object          			-> 		TileResizeMorph.
				#selector 			-> 		#tileOpenWindows.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Tile open windows'.
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'Collapse all Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#collapseAll.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'Reduce all open windows to collapsed forms that only show titles.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		30.
				#label 			-> 		'Restore all Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#restoreAll.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'Restore all collapsed windows back to their previous forms.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		40.
				#label 			-> 		'Close top Window'.
				#object 			-> 		SystemWindow.
				#selector 			-> 		#closeTopWindow.
				#icon 			-> 		#closeIcon.
				#balloonText 	-> 		'Close the topmost window if possible.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		50.
				#label 			-> 		'Send top Window to back'.
				#object 			-> 		SystemWindow.
				#selector 			-> 		#sendTopWindowToBack.
				#icon 			-> 		#goBottomIcon.
				#balloonText 	-> 		'Make the topmost window become the backmost one, and activate the window just beneath it.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		60.
				#label 			-> 		'Move Windows onscreen'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#bringWindowsFullOnscreen.
				#icon 			-> 		#displayIcon.
				#balloonText 	-> 		'Make all windows fully visible on the screen'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Delete unchanged Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#closeUnchangedWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all windows that do not have unsaved text edits.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Delete non Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#deleteNonWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all non-window morphs lying on the world.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'Delete Both of the Above'.
				#selector 			-> 		#cleanUpWorld.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all unchanged windows and also all non-window morphs lying on the world, other than flaps.'
			} asDictionary.
		}`! !
!Theme methodsFor: 'shout' stamp: 'jmv 3/21/2024 11:21:30' prior: 16986171!
                        shout
	"Color symbols as an association list.
	SHTextStylerST80 initialize
	"
	^ {
		#selector  					-> nil.
		#arguments 					-> #(cyan muchDarker).
		#comment 					-> #(green muchDarker).
		#tempBar 					-> #gray.
		#tempVars 					-> #(gray muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#pseudoVariables 					-> #(red muchDarker).
		#literals 					-> #(green muchDarker).
		#messages 					-> #(blue darker).
		#incompleteMessages 					-> #(gray veryMuchDarker).
		#blockLevelZero 					-> #black.
		#blockLevelOne 					-> #brown.
		#blockLevelTwo 					-> #magenta.
		#blockLevelThree 					-> #red.
		#blockLevelFour 					-> #(orange darker).
		#blockLevelFive 					-> #(orange muchDarker).
		#blockLevelSix 					-> #(green muchDarker).
		#blockLevelSeven 					-> #blue.
		#defaults 					-> #black.
		#undefined 					-> #red.
		#methodTags 					-> #(green muchDarker).
	}! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 3/21/2024 11:21:59' prior: 16841239 overrides: 50362354!
     shout
	"Color symbols as an association list."

	^ {
		#selector  					-> '#B59F60'.
		#arguments 					-> '#289078'.
		#comment 					-> #(green duller).
		#tempBar 					-> #gray.
		#tempVars 					-> '#767836'.
		#instVar 					-> '#B3695A'.
		#pseudoVariables 					-> '#2070E0'.
		#literals 					-> #green.
		#messages 					-> '#6FB3BD'.
		#incompleteMessages  					-> '#F08060'.
		#blockLevelZero 					-> '#6FB3BD'.
		#blockLevelOne 					-> '#FFB0B0'.
		#blockLevelTwo 					-> '#B0FFB0'.
		#blockLevelThree 					-> '#B0B0FF'.
		#blockLevelFour 					-> '#00B0B0'.
		#blockLevelFive 					-> '#E03030'.
		#blockLevelSix 					-> '#30E030'.
		#blockLevelSeven 					-> '#3030E0'.
		#defaults 					-> '#A1AFBF'.
		#undefined 					-> '#E04020'.
		#methodTags 					-> #green.
	}! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6289-ColumnAlignmentTweaks-JuanVuletich-2024Mar21-11h40m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6289] on 21 March 2024 at 11:49:37 am'!
!TestCase methodsFor: 'assertions' stamp: 'jmv 3/20/2024 18:26:17' prior: 16975474!
                           should: aBlockToFail raise: anExceptionHandlingCondition withMessageText: expectedErrorMessageOrBlock

	self 
		should: aBlockToFail 
		raise: anExceptionHandlingCondition 
		withExceptionDo: [ :anException |
			self assert: anException messageText equals: expectedErrorMessageOrBlock value ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6290-Tweak-JuanVuletich-2024Mar21-11h49m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6290] on 22 March 2024 at 2:36:17 pm'!
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 3/22/2024 14:35:51' prior: 16969235!
    displayCommandLineUsageOn: aStream
	"Display command line usage on standard out."

	[ aStream
		nextPutAll: 'Command line options:'; newLine;
		nextPutAll: '  -h Display this help message and quit'; newLine;
		nextPutAll: '  -v Display the system information, containing the version and quit'; newLine;
		nextPutAll: '  -q Just quit'; newLine;
		nextPutAll: '  -e Do not ignore exceptions, but open a Debugger'; newLine;
		nextPutAll: '  -u Install updates from CoreUpdates directory'; newLine;
		nextPutAll: '  -r <feature> Require <feature>'; newLine;
		nextPutAll: '  -d <code> Evaluate <code>'; newLine;
		nextPutAll: '  -l <codeFile> Load e.g. file in <codeFile>'; newLine;
		nextPutAll: '  -s <scriptFile> Evaluate code in <scriptFile>'; newLine;
		nextPutAll: '  -ud <directory> Set User Directory to be <directory>'; newLine;
		nextPutAll: '  -udIsBase Set User Directory to be Cuis Base directory'; newLine;
		nextPutAll: '  -- end of options; stop processing options'; newLine;
		newLine;
		nextPutAll: 'Arguments for scripts, code files, packages (and <code>):'; newLine;
		nextPutAll: '  are available in ''Smalltalk startUpScriptArguments'''; newLine;
		newLine;
		nextPutAll: 'Multiple options:'; newLine;
		nextPutAll: '  any option can be passed multiple times'; newLine ]
	on: UnhandledError
	do: [ :exception | exception return ].! !
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 3/22/2024 14:34:27' prior: 50359771!
                               processCommandLineOption: optionString optionArgument: optionArgument raiseExceptions: aBoolean
	"
	A possible example (duplicated single quotes: '' should be double quotes, but not allowed in a Smalltalk comment):
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -h
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -v
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -q
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -e -d''0 zope''
Squeak.app/Contents/MacOS/Squeak Cuis-Smalltalk-Dev/Cuis6.0-????.image -r YAXO -rJSON -d ''Smalltalk startUpScriptArguments print'' xx YY 3492 -d'' 'here comes another' print'' -d ''{'The answer is: '. Smalltalk startUpScriptArguments first asNumber + Smalltalk startUpScriptArguments second asNumber} print'' 3 4 -- -d'' 'not this' print' ''

Squeak.exe Cuis4.2-2211x.image -r RequiredFeature1 -r RequiredFeature2 -d ''Transcript show: 'popo1'; newLine'' -d ''Transcript show: 'popo2'; newLine'' -s smalltalkScript.st param1ToScript param2ToSCript ''parametro 3 to script ->>>--// 3''
	"
	"You can use 'Smalltalk startUpScriptArguments' inside the startUp script:"


	| exceptionToIgnoreOrNil file directory |
	exceptionToIgnoreOrNil := aBoolean ifFalse: [UnhandledError] ifTrue: [nil].
	optionString caseOf: {
		[ '-h' ] -> [
			self displayCommandLineUsageOn: StdIOWriteStream stdout.
			self quit ].

		[ '-v' ] -> [ 
			self displaySystemInformationStringOn: StdIOWriteStream stdout.
			self quit ].

		[ '-q' ] -> [ self quit ].

		[ '-u' ] -> [ ChangeSet installNewUpdates ].

		[ '-r' ] -> [		"as in 		-rRequiredFeature2        or         -r RequiredFeature2"
			{ 'Feature require: '. optionArgument } print.
			[ Feature require: optionArgument ] on: exceptionToIgnoreOrNil do: [:ex | ex return] ].

		[ '-d' ] -> [		"as in 		-d ''Transcript show: 'popo1'; newLine'' -d''Transcript show: 'popo2'; newLine''        (duplicated singleQuotes should read doubleQuote)"
			{ 'Compiler evaluate: '. optionArgument } print.
			[ Compiler evaluate: optionArgument ] on: exceptionToIgnoreOrNil do: [:ex | ex return] ].

		['-l' ] -> ["file in the file"
			file := optionArgument isAbsolutePathName
				ifTrue: [ FileEntry withAbsolutePathName: optionArgument ]
				ifFalse: [FileEntry withRelativePathName: optionArgument to: DirectoryEntry currentDirectory ].
			{ 'File in: '. optionArgument. ' -> '. file} print.
			[file readStreamDo: [ :stream | stream fileIn ]] on: exceptionToIgnoreOrNil do: [ :ex | ex return]].

		[ '-s' ] -> [		"as in 		-s smalltalkScript.st paramAlScript1 paramAlSCript2 ''parameter to script script ->>>--// 3'' 			(duplicated singleQuotes should read doubleQuote)"
			file := optionArgument isAbsolutePathName
				ifTrue: [ FileEntry withAbsolutePathName: optionArgument ]
				ifFalse: [FileEntry withRelativePathName: optionArgument to: DirectoryEntry currentDirectory ].
			{ 'Compiler evaluate contents of file named: '. optionArgument. ' -> '. file. ' arguments: '. self startUpScriptArguments } print.
			file exists ifTrue: [
				file readStreamDo: [ :stream |
					[ Compiler evaluate: stream contentsOfEntireFile ] on: exceptionToIgnoreOrNil do: [ :ex | ex return]]]].

		[ '-ud' ] -> [
			directory := optionArgument asDirectoryEntry.
			DirectoryEntry setUserBaseDirectory: directory ].

		[ '-udIsBase' ] -> [ DirectoryEntry setUserBaseDirectoryAsCuisBase ].
	}
	otherwise: [].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6291-u-cmdLineOptionToInstallUpdates-JuanVuletich-2024Mar22-14h34m-jmv.001.cs.st----!

----QUIT----(22 March 2024 14:39:57) Cuis6.3-6291.image priorSource: 903505!

----STARTUP---- (10 April 2024 10:41:22) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis6.3-6291.image!


'From Cuis6.3 [latest update: #6291] on 23 March 2024 at 4:09:10 pm'!
!MenuMorph methodsFor: 'private' stamp: 'jmv 3/23/2024 16:08:47' prior: 16894725!
               fitInWorld

	| delta trialRect |
	trialRect := Rectangle origin: self morphPosition extent: extent.
	delta := trialRect amountToTranslateWithin: owner displayBounds.
	self whenUIinSafeState: [self morphPosition: trialRect origin + delta].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6292-MenuMorph-fitInWorld-fix-JuanVuletich-2024Mar23-16h01m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6292] on 23 March 2024 at 4:49:37 pm'!
!ProtocolBrowser methodsFor: 'private' stamp: 'jmv 3/23/2024 16:46:19' prior: 16932583!
        hierarchyForClass: aClass
	"Set the class hierarchy for the list pane"
	| tab |

	selectiveClassList := OrderedCollection new.
	tab := ''.
	aClass withAllSuperclasses reverse do: [:ea | 
		selectiveClassList add: tab , ea name.
		tab := tab , '  '].
	selectedMessage := nil.! !
!ProtocolBrowser methodsFor: 'private' stamp: 'jmv 3/23/2024 16:42:17' prior: 16932641!
                  protocolFor: anIndex
	"Change the listed protocol"

	exclude := OrderedCollection new.
	anIndex > 0
		ifTrue: [
			selectedName := (selectiveClassList at: anIndex) withBlanksTrimmed.
			(1 to: anIndex - 1) do: [:ix |
				exclude addLast: (selectiveClassList at: ix) withBlanksTrimmed]]
		ifFalse: [
			selectedName := nil.
			].
	self on: baseClass.
	self changed: #messageList.
	self changed: #relabel.
	self acceptedContentsChanged! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6293-ProtocolBrowser-fixes-JuanVuletich-2024Mar23-16h48m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6293] on 25 March 2024 at 11:21:51 am'!
!Color class methodsFor: 'black-white-grays' stamp: 'jmv 3/25/2024 11:16:43' prior: 16831699!
 darkGray
	"Perceptual scale is logarithmic (we see in Gamma space). Color is in Linear Space.
	See other methods in this category.
	Divide the black - white range in 9 intervals of equal distance in gamma space, disregard darkest gray."
	^ `Color white * (Color sRGBGammaToLinear: 0.44)`! !
!Color class methodsFor: 'black-white-grays' stamp: 'jmv 3/25/2024 11:16:57' prior: 16831703!
                               gray
	"Perceptual scale is logarithmic (we see in Gamma space). Color is in Linear Space.
	See other methods in this category.
	Divide the black - white range in 9 intervals of equal distance in gamma space, disregard darkest gray."
	^ `Color white * (Color sRGBGammaToLinear: 0.56)`! !
!Color class methodsFor: 'black-white-grays' stamp: 'jmv 3/25/2024 11:17:09' prior: 16831731!
   lightGray
	"Perceptual scale is logarithmic (we see in Gamma space). Color is in Linear Space.
	See other methods in this category.
	Divide the black - white range in 9 intervals of equal distance in gamma space, disregard darkest gray."
	^ `Color white * (Color sRGBGammaToLinear: 0.67)`! !
!Color class methodsFor: 'black-white-grays' stamp: 'jmv 3/25/2024 11:16:34' prior: 16831806!
                              veryDarkGray
	"Perceptual scale is logarithmic (we see in Gamma space). Color is in Linear Space.
	See other methods in this category.
	Divide the black - white range in 9 intervals of equal distance in gamma space, disregard darkest gray."
	^ `Color white * (Color sRGBGammaToLinear: 0.33)`! !
!Color class methodsFor: 'black-white-grays' stamp: 'jmv 3/25/2024 11:17:19' prior: 16831810!
                           veryLightGray
	"Perceptual scale is logarithmic (we see in Gamma space). Color is in Linear Space.
	See other methods in this category.
	Divide the black - white range in 9 intervals of equal distance in gamma space, disregard darkest gray."
	^ `Color white * (Color sRGBGammaToLinear: 0.78)`! !
!Color class methodsFor: 'black-white-grays' stamp: 'jmv 3/25/2024 11:16:08' prior: 16831814!
                          veryVeryDarkGray
	"Perceptual scale is logarithmic (we see in Gamma space). Color is in Linear Space.
	See other methods in this category.
	Divide the black - white range in 9 intervals of equal distance in gamma space, disregard darkest gray."
	^ `Color white * (Color sRGBGammaToLinear: 0.22)`! !
!Color class methodsFor: 'black-white-grays' stamp: 'jmv 3/25/2024 11:17:31' prior: 16831819!
                       veryVeryLightGray
	"Perceptual scale is logarithmic (we see in Gamma space). Color is in Linear Space.
	See other methods in this category.
	Divide the black - white range in 9 intervals of equal distance in gamma space, disregard darkest gray."
	^ `Color white * (Color sRGBGammaToLinear: 0.89)`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6294-Color-NamedGraysInGammaSpace-JuanVuletich-2024Mar25-11h19m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6294] on 25 March 2024 at 11:55:16 am'!
!DarkTheme methodsFor: 'colors' stamp: 'jmv 3/25/2024 10:18:15' prior: 16841225 overrides: 16985122!
                            defaultWindowColor
	^ `Color hue: 212 chroma: 0.015 luminance: 0.15`! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 3/25/2024 11:24:12' prior: 16841234 overrides: 16985005!
                   paneBackgroundFrom: aColor
	^ aColor alphaMixed: 0.4 with: Color black! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6295-EnhanceContrastInDarkTheme-JuanVuletich-2024Mar25-11h54m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6294] on 25 March 2024 at 11:56:19 am'!
!Transcript class methodsFor: 'displaying' stamp: 'jmv 3/25/2024 11:39:11' prior: 16988261!
         displayUnfinishedEntryOnDisplay

	| font count string x y fh r innerR |
	self displayEngine.
	innerR := bounds insetBy: self padding.
	lastDisplayPosition < innerR right ifTrue: [
		font := FontFamily defaultFamilyAndPointSize.
		fh := font lineSpacing.
		count := innerR height // fh-1.
		x := innerR left.
		string := unfinishedEntry contents.
		y := ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font lineSpacing + innerR top.
		r := innerR left: lastDisplayPosition.
		displayEngine clipRect: r.
		(self drawString: string at: x@y font: font color: `Color darkGray`) ifNotNil: [ :lastPoint |
			lastDisplayPosition := lastPoint x.
			^r ]].
	^nil! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 3/25/2024 11:44:23' prior: 16893189!
       isEnabled: aBoolean

	isEnabled = aBoolean ifTrue: [^ self].
	isEnabled := aBoolean.
	self color: (aBoolean ifTrue: [`Color black`] ifFalse: [`Color lightGray`]).! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 3/25/2024 11:39:03' prior: 16894563!
                               displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr := self valueOfProperty: #matchString.
	allItems := self submorphs select: [ :m |
		m is: #MenuItemMorph ].
	matches := allItems select: [ :m |
		isMatch := matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph := self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph := LabelMorph new color: `Color darkGray`.
		self addMorphBack: feedbackMorph lock position: `0@ -20`.
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self removeProperty: #feedbackMorph ].
	matches notEmpty ifTrue: [
		self selectItem: matches first ]! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 3/25/2024 11:50:07' prior: 16784949!
                      drawScrollBarMovementBarOn: aCanvas thickness: scrollbarThickness
	
	| height top bottom |

	height := extent y - (2 * scrollbarThickness).
	top := (1.0 * self firstVisible-1 / self entryCount * height) ceiling + 1 + scrollbarThickness-1.
	bottom := (1.0 * self lastVisible / self entryCount * height) floor + 1 + scrollbarThickness -1.
	aCanvas
		fillRectangle: (extent x - scrollbarThickness+2@top corner:  extent x-2 @ bottom)
		color: `Color veryLightGray`! !
!Sample03Smiley methodsFor: 'drawing' stamp: 'jmv 3/25/2024 11:30:22' prior: 16944245 overrides: 16903763!
     drawOn: aCanvas
	"Example of the #pathSequence drawing operation, that can represent many drawing operations
			in one compact literal, and draw them at once.
	0.0		x	y									Move pen to position x@y
	1.0		x	y									Draw a line to position x@y
	2.0		toX	toY	controlX		controlY						Draw a Quadratic Bezier Curve
	3.0		toX	toY	control1X	control1Y			control2X	control2Y			Draw a Cubic Bezier Curve
	See #circleApproximationExamples
	Sample03Smiley new openInHand
	"

	aCanvas strokeWidth: 30 color: `Color gray alpha: 0.8` fillColor: `Color lightGreen alpha: 0.7` do: [
		aCanvas
				pathSequence: `#[
					0.0  150.0  150.0
					3.0  300.0  300.0  150.0  233.0  217.0  300.0
					3.0  450.0  150.0  380.3  300.0  450.0  233.0
					3.0  300.0  0.0      450.0  67.0    383.0  0.0
					3.0  150.0  150.0  210.7  0.0      150.0  67.0
					] asFloat32Array`
		].

	aCanvas strokeWidth: 30 color: `Color gray` do: [
		aCanvas
				pathSequence: `#[
					0.0 220.0 190.0
					2.0 300.0 240.0 245.0 240.0
					2.0 380.0 190.0 355.0 240.0
					0.0 250.0 100.0
					1.0 250.0 120.0
					0.0 350.0 100.0
					1.0 350.0 120.0
					] asFloat32Array`
		].! !
!Sample09Clock methodsFor: 'drawing' stamp: 'jmv 3/25/2024 11:53:09' prior: 50351193 overrides: 16903763!
                           drawOn: aCanvas

	| f |
	aCanvas
		strokeWidth: 10 color: Color lightCyan
		fillColor: Color veryVeryLightGray lighter do: [ :canvas |
			canvas circleCenter:  0@0 radius: 100 ].
	f := FontFamily familyName: 'DejaVu Sans' pointSize: 14.
	aCanvas drawString: 'XII' at: -13 @ 58 font: f color: Color brown.
	aCanvas drawString: 'III' at: 73 @ -24 font: f color: Color brown.
	aCanvas drawString: 'VI' at: -9 @ -106 font: f color: Color brown.
	aCanvas drawString: 'IX' at: -90 @ -24 font: f color: Color brown.

	f := FontFamily familyName: 'Alex Brush' pointSize: 16.
	aCanvas drawString: 'Chaque Heure' atCenterX: 0@ 18 font: f color: Color black.
	f := FontFamily familyName: 'Alex Brush' pointSize: 8.
	aCanvas drawString: 'pour la Minorie' atCenterX: 0@ -60 font: f color: Color black.! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 3/25/2024 11:35:11' prior: 16778394 overrides: 16907875!
               drawCloseIcon

	| c s size |
	(currentMorph isPressed or: [ currentMorph mouseIsOver ])
		ifFalse: [
			c := `Color r: 0.996 g: 0.329 b: 0.329`.
			s := `Color darkGray` ]
		ifTrue: [
			c := `(Color r: 0.996 g: 0.329 b: 0.329) * 0.85`.
			s := `Color black` ].

	size := currentMorph morphWidth.
	self strokeWidth: size/30.0 color: `Color gray` fillColor: c do: [
		self pathSequence: (self class windowButtonPathData: size) ].

	self strokeWidth: (size/10.0 max: 1.0) color: s do: [
		self pathSequence: (self class windowButtonClosePathData: size) ].! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 3/25/2024 11:36:27' prior: 16778415 overrides: 16907880!
                          drawCollapseIcon

	| c s size |
	(currentMorph isPressed or: [ currentMorph mouseIsOver ])
		ifFalse: [
			c := `Color r: 0.988 g: 0.557 b: 0.102`.
			s := `Color darkGray` ]
		ifTrue: [
			c := `(Color r: 0.988 g: 0.557 b: 0.102) * 0.85`.
			s := `Color black` ].

	size := currentMorph morphWidth.
	self strokeWidth: size/30.0 color: `Color gray` fillColor: c do: [
		self pathSequence: (self class windowButtonPathData: size) ].

	self strokeWidth: (size/10.0 max: 1.0) color: s do: [
		self pathSequence: (self class windowButtonCollapsePathData: size) ].! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 3/25/2024 11:32:16' prior: 16778436 overrides: 16907885!
                    drawDownIcon
	| c size |
	c := currentMorph isPressed
		ifFalse: [`Color lightGray`]
		ifTrue: [`Color darkGray`].
	size := currentMorph morphWidth.
	self strokeWidth: size/7.2 color: c do: [
		self pathSequence: (self class scrollDownPathData: size) ].! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 3/25/2024 11:36:31' prior: 16778447 overrides: 16907890!
      drawExpandIcon

	| c s size |
	(currentMorph isPressed or: [ currentMorph mouseIsOver ])
		ifFalse: [
			c := `Color r: 0.337 g: 0.604 b: 0.161`.
			s := `Color darkGray` ]
		ifTrue: [
			c := `(Color r: 0.337 g: 0.604 b: 0.161) * 0.85`.
			s := `Color black` ].

	size := currentMorph morphWidth.
	self strokeWidth: size/30.0 color: `Color gray` fillColor: c do: [
		self pathSequence: (self class windowButtonPathData: size) ].

	self strokeWidth: (size/10.0 max: 1.0) color: s do: [
		self pathSequence: (self class windowButtonExpandPathData: size) ].! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 3/25/2024 11:46:26' prior: 16778468 overrides: 16907895!
                        drawExpandedAt: aPoint height: h
	"For Tree View (IndentingListItemMorph)"

	| halfWidth width |
	width := h * 3/4.
	halfWidth := width / 2.
	self fillColor: `Color lightGray` do: [
		self moveTo: aPoint.
		self rel_MoveTo: (h/8) @ (h/4) negated;
			rel_LineTo: halfWidth @ width;
			rel_LineTo: halfWidth @ width negated;
			rel_LineTo: width negated @ 0 ].
		! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 3/25/2024 11:32:30' prior: 16778550 overrides: 16907901!
                          drawLeftIcon
	| c size |
	c := currentMorph isPressed
		ifFalse: [`Color lightGray`]
		ifTrue: [`Color darkGray`].
	size := currentMorph morphWidth.
	self strokeWidth: size/7.2 color: c do: [
		self pathSequence: (self class scrollLeftPathData: size) ].! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 3/25/2024 11:36:34' prior: 16778561 overrides: 16907906!
      drawMenuIcon

	| c s size |
	(currentMorph isPressed or: [ currentMorph mouseIsOver ])
		ifFalse: [
			c := `Color r: 0.212 g: 0.439 b: 0.784`.
			s := `Color darkGray` ]
		ifTrue: [
			c := `(Color r: 0.212 g: 0.439 b: 0.784) * 0.85`.
			s := `Color black` ].

	size := currentMorph morphWidth.
	self strokeWidth: size/30.0 color: `Color gray` fillColor: c do: [
		self pathSequence: (self class windowButtonPathData: size) ].

	self fillColor: s do: [
		self pathSequence: (self class windowButtonMenuPathData: size) ].! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 3/25/2024 11:46:16' prior: 16778581 overrides: 16907911!
                          drawNotExpandedAt: aPoint height: h
	"For Tree View (IndentingListItemMorph)"

	| halfWidth width |
	width := h * 3/4.
	halfWidth := width / 2.
	self fillColor: `Color lightGray` do: [
		self moveTo: aPoint.
		self rel_MoveTo: (h/4) @ halfWidth negated;
			rel_LineTo: width @ halfWidth;
			rel_LineTo: width negated @ halfWidth;
			rel_LineTo: 0 @ width negated.
		].! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 3/25/2024 11:36:38' prior: 16778596 overrides: 16907917!
                   drawPushPinIcon
	"For Menu stay-up button"
	| c s size |
	(currentMorph isPressed or: [ currentMorph mouseIsOver ])
		ifFalse: [
			c := `(Color r: 0.996 g: 0.329 b: 0.329)`.
			s := `Color darkGray` ]
		ifTrue: [
			c := `(Color r: 0.996 g: 0.329 b: 0.329) * 0.85`.
			s := `Color black` ].
	size := currentMorph morphWidth.
	self strokeWidth: size/30.0 color: s fillColor: c do: [
		self pathSequence: (self class pushPinIconData: size) ]! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 3/25/2024 11:32:36' prior: 16778613 overrides: 16907922!
           drawRightIcon
	| c size |
	c := currentMorph isPressed
		ifFalse: [`Color lightGray`]
		ifTrue: [`Color darkGray`].
	size := currentMorph morphWidth.
	self strokeWidth: size/7.2 color: c do: [
		self pathSequence: (self class scrollRightPathData: size) ].! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 3/25/2024 11:32:42' prior: 16778624 overrides: 16907927!
    drawUpIcon
	| c size |
	c := currentMorph isPressed
		ifFalse: [`Color lightGray`]
		ifTrue: [`Color darkGray`].
	size := currentMorph morphWidth.
	self strokeWidth: size/7.2 color: c do: [
		self pathSequence: (self class scrollUpPathData: size) ].! !
!VectorCanvas methodsFor: 'private-framework' stamp: 'jmv 3/25/2024 11:41:34' prior: 16998821 overrides: 16908279!
                privateFrameReverseGlobalRect: rect borderWidth: borderWidth
	"
	(VectorCanvas onForm: Display)
		privateFrameReverseGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	| prevClipRect |
	prevClipRect := auxBitBltEngine clipRect.
	auxBitBltEngine clipRect: rect.
	auxBitBltEngine
		sourceForm: nil;
		fillColor: `Color gray: 0.5`;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth.
	auxBitBltEngine clipRect: prevClipRect.! !
!BitBltCanvas methodsFor: 'private-framework' stamp: 'jmv 3/25/2024 11:41:51' prior: 16791916 overrides: 16908279!
            privateFrameReverseGlobalRect: rect borderWidth: borderWidth
	"
	(BitBltCanvas onForm: Display)
		privateFrameReverseGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	| prevClipRect |
	prevClipRect := engine clipRect.
	engine clipRect: rect.
	engine
		sourceForm: nil;
		fillColor: `Color gray: 0.5`;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth.
	engine clipRect: prevClipRect.! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 3/25/2024 11:42:16' prior: 16985081!
                 menuTitleBar
	Display depth = 1 ifTrue: [^ `Color white`].
	Display depth = 2 ifTrue: [^ `Color gray: 0.5`].
	^ self menu darker! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6296-TweakVariousGrayWidgets-JuanVuletich-2024Mar25-11h55m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6294] on 25 March 2024 at 12:05:03 pm'!
!TextBackgroundColor class methodsFor: 'constants' stamp: 'jmv 3/25/2024 11:42:56' prior: 16979020!
          gray
	^ self new color: `Color gray`! !
!TextColor class methodsFor: 'constants' stamp: 'jmv 3/25/2024 11:43:18' prior: 16979117!
                              gray
	^ self new color: `Color gray`! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/25/2024 11:43:23' prior: 16867952!
          fillGray
	"Set all bits in the receiver to gray."

	self fill: self boundingBox fillColor: `Color gray`! !
!Form methodsFor: 'coloring' stamp: 'jmv 3/25/2024 11:43:26' prior: 16867958!
       fillGray: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to the gray mask."

	self fill: aRectangle rule: Form over fillColor: `Color gray`! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 3/25/2024 11:43:34' prior: 16936026!
  newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay := Delay forMilliseconds: 10.
	buttonStart := buttonNow := Sensor isAnyButtonPressed.
	rect := self.
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow := Sensor isAnyButtonPressed.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			Display border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			rect := newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!BoxedMorph methodsFor: 'initialization' stamp: 'jmv 3/25/2024 11:43:51' prior: 16796534!
  defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ `Color gray`! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 3/25/2024 11:43:54' prior: 16890223 overrides: 16796545!
            defaultColor
	^ `Color lightGray`! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 3/25/2024 11:49:18' prior: 16932067 overrides: 50363233!
          defaultColor
	^ `Color veryLightGray`! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 3/25/2024 11:47:35' prior: 16872210!
     setDismissColor: event with: aHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	event hand obtainHalo: self.
	colorToUse :=  (aHandle includesPixel: event eventPosition)
		ifFalse: [ `Color red muchLighter` ]
		ifTrue: [ `Color lightGray` ].
	aHandle color: colorToUse! !
!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 3/25/2024 11:48:06' prior: 16924719 overrides: 16796545!
       defaultColor
	"answer the default color/fill style for the receiver"
	^ `Color lightGray`! !
!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 3/25/2024 11:47:02' prior: 16931803 overrides: 16796549!
               initialize
	super initialize.
	progressColor := `Color gray`.
	value := 0.0! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 3/25/2024 11:50:07' prior: 50362844!
                      drawScrollBarMovementBarOn: aCanvas thickness: scrollbarThickness
	
	| height top bottom |

	height := extent y - (2 * scrollbarThickness).
	top := (1.0 * self firstVisible-1 / self entryCount * height) ceiling + 1 + scrollbarThickness-1.
	bottom := (1.0 * self lastVisible / self entryCount * height) floor + 1 + scrollbarThickness -1.
	aCanvas
		fillRectangle: (extent x - scrollbarThickness+2@top corner:  extent x-2 @ bottom)
		color: `Color veryLightGray`! !
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 3/25/2024 11:45:24' prior: 16998177 overrides: 16907570!
              image: srcForm at: aPoint
	"Workaround using WarpBlt until properly implemented in VectorEngine.
	 (WarpBlt might not give desired result, i.e. a properly filtered and resamples image)

	In the general case, use WarpBlt to apply currentTransformation.
	Prior to that, set morphIds for affected pixels, and update bounds in engine.
	This is expensive!!

	If No scaling and no rotation, use BitBlt instead (way faster). This is useful, for instance, for halo handles.
	We expect to replace them with vector graphics icons, anyway.

	But if drawing the world background, finding bounds is not needed. Use two BitBlts then:
	One to paint pixels, and a second one to set morphIds.
	In this way, performance is same as in HybridCanvas, and not too different from BitBltCanvas.
	This is especially important, the default World background is a Form!!"

	| p bits |

	"Special case for our world:
	- No bounds needed
	- currentTransformation is identity: No translation, no rotation, no scaling.
	BitBlt is enough, but we need two of them!!"
	(world notNil and: [currentMorph == world]) ifTrue: [
		p := (currentTransformation transform: aPoint) roundedHAFZ.
		auxBitBltEngine
			sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
			colorMap: (srcForm colormapIfNeededFor: form);
			clipRect: clipRect;
			sourceX: 0; sourceY: 0;
			destX: p x destY: p y width: srcForm width height: srcForm height;
			copyBits.
		bits := form bits.
		[
			form bits: engine morphIds.
			auxBitBltEngine
				sourceForm: nil;
				fillBitmap: (Bitmap with: (currentMorph morphId << 8 + 255));
				combinationRule: `Form over`;
				colorMap: nil;
				copyBits.
		] ensure: [ form bits: bits ].
		^self ].

	"Otherwise, we need to compute bounds. While we are at it, set morphID for affected pixels."
	self fillRectangle: (srcForm boundingBox translatedBy: aPoint) color: `Color gray alpha: 0.01`.
	currentTransformation isPureTranslation
		ifTrue: [
			p := (currentTransformation transform: aPoint) roundedHAFZ.
			auxBitBltEngine
				sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				sourceX: 0; sourceY: 0;
				destX: p x destY: p y width: srcForm width height: srcForm height;
				copyBits ]
		ifFalse: [
			| bb cellSize dstBox srcBox srcQuad |
			cellSize := 4.
			srcBox := srcForm boundingBox.
			dstBox := (currentTransformation externalBoundingRectOf: srcBox)
				encompassingIntegerRectangle.
			srcQuad := dstBox corners collect: [ :pt | (currentTransformation inverseTransform: pt) roundedHAFZ ].
			dstBox := (currentTransformation externalBoundingRectOf: (srcBox translatedBy: aPoint-0.5))
				encompassingIntegerRectangle.
			bb := WarpBlt toForm: form.
			bb
				sourceForm: srcForm; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				cellSize: cellSize;
				copyQuad: srcQuad toRect: dstBox ].! !
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 3/25/2024 11:45:20' prior: 16998273!
       image: srcForm at: aPoint sourceRect: sourceRect
	"Workaround using WarpBlt until properly implemented in VectorEngine.
	 (WarpBlt might not give desired result, i.e. a properly filtered and resamples image)

	In the general case, use WarpBlt to apply currentTransformation.
	Prior to that, set morphIds for affected pixels, and update bounds in engine.
	This is expensive!!

	If No scaling and no rotation, use BitBlt instead (way faster). This is useful, for instance, for halo handles.
	We expect to replace them with vector graphics icons, anyway.

	But if drawing the world background, finding bounds is not needed. Use two BitBlts then:
	One to paint pixels, and a second one to set morphIds.
	In this way, performance is same as in HybridCanvas, and not too different from BitBltCanvas.
	This is especially important, the default World background is a Form!!"

	| p bits |

	"Special case for our world:
	- No bounds needed
	- currentTransformation is identity: No translation, no rotation, no scaling.
	BitBlt is enough, but we need two of them!!"
	currentMorph == world ifTrue: [
		p := (currentTransformation transform: aPoint) roundedHAFZ.
		auxBitBltEngine
			sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
			colorMap: (srcForm colormapIfNeededFor: form);
			clipRect: clipRect;
			sourceX: sourceRect left; sourceY: sourceRect top;
			destX: p x destY: p y width: sourceRect width height: sourceRect height;
			copyBits.
		bits := form bits.
		[
			form bits: engine morphIds.
			auxBitBltEngine
				sourceForm: nil;
				fillBitmap: (Bitmap with: (currentMorph morphId << 8 + 255));
				combinationRule: `Form over`;
				colorMap: nil;
				copyBits.
		] ensure: [ form bits: bits ].
		^self ].

	"Otherwise, we need to compute bounds. While we are at it, set morphID for affected pixels."
	self fillRectangle: (sourceRect translatedBy: aPoint) color: `Color gray alpha: 0.01`.
	currentTransformation isPureTranslation
		ifTrue: [
			p := (currentTransformation transform: aPoint) roundedHAFZ.
			auxBitBltEngine
				sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				sourceX: sourceRect left; sourceY: sourceRect top;
				destX: p x destY: p y width: sourceRect width height: sourceRect height;
				copyBits ]
		ifFalse: [
			| bb cellSize dstBox srcBox srcQuad |
			cellSize := 4.
			srcBox := sourceRect.
			dstBox := (currentTransformation externalBoundingRectOf: srcBox)
				encompassingIntegerRectangle.
			srcQuad := dstBox corners collect: [ :pt | (currentTransformation inverseTransform: pt) roundedHAFZ ].
			dstBox := (currentTransformation externalBoundingRectOf: (srcBox translatedBy: aPoint-0.5))
				encompassingIntegerRectangle.
			bb := WarpBlt toForm: form.
			bb
				sourceForm: srcForm; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				cellSize: cellSize;
				copyQuad: srcQuad toRect: dstBox ].! !
!Theme methodsFor: 'colors' stamp: 'pb 4/24/2019 20:46:25' prior: 16985033!
                        textEmptyDisplayMessage
	^ `Color veryLightGray`! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/25/2024 11:52:02' prior: 16985045!
                               textHighlightFocused: focused
	"A nice light blue."
	| textHighlight |
	Display depth = 1 ifTrue: [^ `Color veryLightGray` ].
	Display depth = 2 ifTrue: [^ `Color gray: 0.87` ].
	textHighlight := self textHighlight.
	^focused
		ifTrue: [ textHighlight ]
		ifFalse: [ self unfocusedTextHighlightFrom: textHighlight ]! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 3/25/2024 11:50:23' prior: 16985072!
               menuHighlight
	^ Display depth < 8
		ifTrue: [ `Color veryLightGray` ]
		ifFalse: [ self textHighlight ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/25/2024 11:44:56' prior: 16985093!
  autoCompleterDefaultBorderColor
	"Answer the auto comleters default border color."

	^ `Color gray`! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/25/2024 11:48:26' prior: 16985122!
       defaultWindowColor
	^ `Color lightGray`! !
!Theme methodsFor: 'shout' stamp: 'jmv 3/25/2024 11:42:26' prior: 50362354!
         shout
	"Color symbols as an association list.
	SHTextStylerST80 initialize
	"
	^ {
		#selector  					-> nil.
		#arguments 					-> #(cyan muchDarker).
		#comment 					-> #(green muchDarker).
		#tempBar 					-> #gray.
		#tempVars 					-> #(gray muchDarker).
		#instVar 					-> #(magenta muchDarker).
		#pseudoVariables 					-> #(red muchDarker).
		#literals 					-> #(green muchDarker).
		#messages 					-> #(blue darker).
		#incompleteMessages 					-> #(gray veryMuchDarker).
		#blockLevelZero 					-> #black.
		#blockLevelOne 					-> #brown.
		#blockLevelTwo 					-> #magenta.
		#blockLevelThree 					-> #red.
		#blockLevelFour 					-> #(orange darker).
		#blockLevelFive 					-> #(orange muchDarker).
		#blockLevelSix 					-> #(green muchDarker).
		#blockLevelSeven 					-> #blue.
		#defaults 					-> #black.
		#undefined 					-> #red.
		#methodTags 					-> #(green muchDarker).
	}! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 3/25/2024 11:42:30' prior: 50362385 overrides: 50363515!
     shout
	"Color symbols as an association list."

	^ {
		#selector  					-> '#B59F60'.
		#arguments 					-> '#289078'.
		#comment 					-> #(green duller).
		#tempBar 					-> #gray.
		#tempVars 					-> '#767836'.
		#instVar 					-> '#B3695A'.
		#pseudoVariables 					-> '#2070E0'.
		#literals 					-> #green.
		#messages 					-> '#6FB3BD'.
		#incompleteMessages  					-> '#F08060'.
		#blockLevelZero 					-> '#6FB3BD'.
		#blockLevelOne 					-> '#FFB0B0'.
		#blockLevelTwo 					-> '#B0FFB0'.
		#blockLevelThree 					-> '#B0B0FF'.
		#blockLevelFour 					-> '#00B0B0'.
		#blockLevelFive 					-> '#E03030'.
		#blockLevelSix 					-> '#30E030'.
		#blockLevelSeven 					-> '#3030E0'.
		#defaults 					-> '#A1AFBF'.
		#undefined 					-> '#E04020'.
		#methodTags 					-> #green.
	}! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 3/25/2024 11:52:07' prior: 16841265 overrides: 16985025!
                      text
	^ `Color veryLightGray`! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 3/25/2024 11:42:33' prior: 16841277 overrides: 16985237!
                          textPane
	^ `Color gray`! !
!DarkTheme methodsFor: 'menu colors' stamp: 'jmv 3/25/2024 11:32:47' prior: 16841293 overrides: 16985066!
                          menu
	^ `Color darkGray`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6297-HonorNewGraysInMethodLiterals-JuanVuletich-2024Mar25-11h56m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6297] on 25 March 2024 at 4:39:27 pm'!
!Theme methodsFor: 'widget colors' stamp: 'jmv 3/25/2024 16:38:45'!
             widgetsColorFromToolColor
	"Answer false for subclasses that want to control color of widgets independently of the SystemWindow owning them"
	^true! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 3/25/2024 16:38:59' prior: 16970982 overrides: 16905930!
                         openInWorld
	"Ensure all widgets have proper colors before opening"
	Theme current widgetsColorFromToolColor ifTrue: [
		self widgetsColor: self windowColor ].
	super openInWorld! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6298-DecopleWidgetAndWindowColors-JuanVuletich-2024Mar25-16h38m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6298] on 26 March 2024 at 12:29:03 pm'!

ChangeSet removeSelector: #methodsWithoutClassifications!

!methodRemoval: ChangeSet #methodsWithoutClassifications stamp: 'Install-6299-Cleanup-JuanVuletich-2024Mar26-12h28m-jmv.001.cs.st 4/10/2024 10:41:42'!
methodsWithoutClassifications
	"Return a collection representing methods in the receiver which have not been categorized"

	| slips notClassified |

	notClassified := {'as yet unclassified' asSymbol. #all}.
	slips := OrderedCollection new.
	self changedClasses do: [ :aClass |
		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | aSelector |
			(aClass selectors includes:  (aSelector := mAssoc key)) ifTrue: [
				(notClassified includes: (aClass organization categoryOfElement: aSelector))
					ifTrue: [slips add: aClass name , ' ' , aSelector]]]].
	^ slips

	"
	Smalltalk browseMessageList: (ChangeSet changeSetForBaseSystem methodsWithoutClassifications) name: 'unclassified methods'
	"!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6299-Cleanup-JuanVuletich-2024Mar26-12h28m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6298] on 26 March 2024 at 12:31:34 pm'!
!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'jmv 3/26/2024 11:02:13' prior: 16819311!
                selectorsInCategory: aSymbol 
	"Answer a list of the method selectors of the receiver that are in category named aName"
	
	| aColl |
	aColl := Set withAll: ((aSymbol isNil or: [aSymbol == ClassOrganizer allCategory])
			ifTrue: [self organization allMethodSelectors]
			ifFalse: [self organization listAtCategoryNamed: aSymbol]).
	^ aColl asArray sort! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 3/26/2024 11:01:53' prior: 16819764!
 fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex 
	"File a description of the receiver's category, aString, onto aFileStream. If 
	moveSource, is true, then set the method source pointer to the new file position.
	Note when this method is called with moveSource=true, it is condensing the
	.sources file, and should only write one preamble per method category."

	| selectors |

	aFileStream newLine.
	selectors := (aSymbol isNil or: [aSymbol == ClassOrganizer allCategory])
				ifTrue: [ self organization allMethodSelectors ]
				ifFalse: [ self organization listAtCategoryNamed: aSymbol ].

	"Overridden to preserve author stamps in sources file regardless"
	selectors do: [:sel |
		self printMethodChunk: sel 
			withPreamble: true
			on: aFileStream 
			moveSource: moveSource 
			toFile: fileIndex].
	^ self! !
!ClassDescription methodsFor: 'method dictionary' stamp: 'jmv 3/26/2024 11:01:25' prior: 16820670!
           allMethodsInCategory: aSymbol
	"Answer a list of all the method categories of the receiver and all its superclasses"

	| aColl |
	aColl := OrderedCollection new.
	self withAllSuperclasses do: [ :aClass |
		aColl addAll:
			((aSymbol isNil or: [aSymbol == ClassOrganizer allCategory])
				ifTrue:
					[aClass organization allMethodSelectors]
				ifFalse:
					[aClass organization listAtCategoryNamed: aSymbol])].
	^ aColl asSet sorted

"
Morph allMethodsInCategory: #initialization
Morph allMethodsInCategory: ClassOrganizer allCategory :: size
Morph allMethodsInCategory: nil :: size
"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6300-uncategorizedMethods-tweaks-JuanVuletich-2024Mar26-12h29m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6298] on 26 March 2024 at 12:35:02 pm'!

Object subclass: #Categorizer
	instanceVariableNames: 'categoryArray categoryStops elementArray '
	classVariableNames: 'Default NullCategory '
	poolDictionaries: ''
	category: 'Kernel-Classes'!

!classDefinition: #Categorizer category: #'Kernel-Classes' stamp: 'Install-6301-nullCategory-remove-JuanVuletich-2024Mar26-12h31m-jmv.001.cs.st 4/10/2024 10:41:42'!
Object subclass: #Categorizer
	instanceVariableNames: 'categoryArray categoryStops elementArray'
	classVariableNames: 'Default NullCategory'
	poolDictionaries: ''
	category: 'Kernel-Classes'!
!Browser methodsFor: 'message functions' stamp: 'jmv 3/26/2024 11:59:55' prior: 16798426!
                            defineMessageFrom: aString notifying: aRequestor
	"Compile the expressions in aString. Notify aRequestor if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."
	| selectedMessageName selector category oldMessageList scarySelector |
	selectedMessageName := self selectedMessageName.
	oldMessageList := self messageList.
	 self metaClassIndicated ifTrue: [
		scarySelector := self selectedClassOrMetaClass parserClass selectorFrom: aString.
		((self selectedClassOrMetaClass includesSelector: scarySelector) not
			and: [Metaclass isScarySelector: scarySelector])
			ifTrue: ["A frist-time definition overlaps the protocol of Metaclasses"
					(self confirm: (scarySelector bold, ' is used in the existing class system.
Overriding it could cause serious problems.
Is this really what you want to do?'))
					ifFalse: [^nil]]].
	category := self selectedMessageCategoryName ifNotNil: [ :n | n asSymbol ].
	category == ClassOrganizer allCategory ifTrue: [
		"Current category for existing methods or if a method was selected,
		nil for new methods when no previous method was selected."
		category := self categoryOfCurrentMethod ].
	selector := self selectedClassOrMetaClass
				compile: aString
				classified: category
				notifying: aRequestor.
	selector
		ifNil: [^ nil].
	selector ~~ selectedMessageName
		ifTrue: [
			self setClassOrganizer.  "In case organization not cached"
			(oldMessageList includes: selector)
				ifFalse: [self changed: #messageList].
			self messageListIndex: (self messageList indexOf: selector)].
	^ selector! !
!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'jmv 3/26/2024 11:55:46' prior: 16819193!
                  methodCategories

	^self organization categories! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 3/26/2024 12:14:52' prior: 16803290!
                      categories
	"Answer an Array of categories (names)."
	^categoryArray! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 3/26/2024 11:52:39' prior: 16803413!
  classify: element under: heading suppressIfDefault: aBoolean
	"Store the argument, element, in the category named heading.   If aBoolean is true, then invoke special logic such that the classification is NOT done if the new heading is the Default and the element already had a non-Default classification -- useful for filein"

	| catName catIndex elemIndex realHeading |
	
	realHeading := heading isNil
		ifTrue: [Default]
		ifFalse: [heading withBlanksTrimmed ].
	
	"done if already under that category"
	(catName := self categoryOfElement: element) = realHeading ifTrue: [^ self].  

	catName ifNotNil: [
		"return if non-Default category already assigned in memory"
		(aBoolean and: [realHeading = Default]) ifTrue: [^ self].	 
		"remove if in another category"
		self removeElement: element].

	(categoryArray indexOf: realHeading) = 0 ifTrue: [self addCategory: realHeading].

	catIndex := categoryArray indexOf: realHeading.
	elemIndex := catIndex > 1
		ifTrue: [categoryStops at: catIndex - 1]
		ifFalse: [0].
	[(elemIndex := elemIndex + 1) <= (categoryStops at: catIndex) 
		and: [element >= (elementArray at: elemIndex)]] whileTrue.

	"elemIndex is now the index for inserting the element. Do the insertion before it."
	elementArray := elementArray copyReplaceFrom: elemIndex to: elemIndex-1 with: (Array with: element).

	"add one to stops for this and later categories"
	catIndex to: categoryArray size do: [ :i |
		categoryStops at: i put: (categoryStops at: i) + 1].

	(self listAtCategoryNamed: Default) isEmpty ifTrue: [self removeCategory: Default]! !
!Categorizer class methodsFor: 'class initialization' stamp: 'jmv 3/26/2024 11:58:40' prior: 16803816 overrides: 16916096!
     initialize
	"
	Categorizer initialize	
	"
	Default := 'as yet unclassified' asSymbol.! !
!MethodCategoriesPrompter methodsFor: 'categories initialization - private' stamp: 'jmv 3/26/2024 11:57:57' prior: 16899763!
          createCategories

	| classCategories |
	
	categories := OrderedCollection with: 'new ...'.
	lines := OrderedCollection with: 1. 
	classCategories := startClass methodCategoriesAsSortedCollection.
	
	reject := classCategories asSet.
	reject
		add: ClassOrganizer default.
	
	startClass isMeta ifTrue: [ self initializeCategoriesWhenMeta: classCategories].
	rejectingFirst ifFalse: [ categories addAll: classCategories ]! !

Categorizer class removeSelector: #nullCategory!

!methodRemoval: Categorizer class #nullCategory stamp: 'Install-6301-nullCategory-remove-JuanVuletich-2024Mar26-12h31m-jmv.001.cs.st 4/10/2024 10:41:42'!
nullCategory
	^ NullCategory!

Object subclass: #Categorizer
	instanceVariableNames: 'categoryArray categoryStops elementArray'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Kernel-Classes'!

!classDefinition: #Categorizer category: #'Kernel-Classes' stamp: 'Install-6301-nullCategory-remove-JuanVuletich-2024Mar26-12h31m-jmv.001.cs.st 4/10/2024 10:41:42'!
Object subclass: #Categorizer
	instanceVariableNames: 'categoryArray categoryStops elementArray'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Kernel-Classes'!

Categorizer initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6301-nullCategory-remove-JuanVuletich-2024Mar26-12h31m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6298] on 26 March 2024 at 12:36:15 pm'!
!ClassOrganizer class methodsFor: 'class variables' stamp: 'jmv 3/26/2024 12:09:39'!
          defaultMethodCategory
	^ Default! !
!SystemOrganizer class methodsFor: 'class variables' stamp: 'jmv 3/26/2024 12:15:06'!
      defaultClassCategory
	^ Default! !
!Browser methodsFor: 'message category list' stamp: 'jmv 3/26/2024 12:09:55' prior: 16798322!
                               categorizeAllUncategorizedMethods
	"Categorize methods by looking in parent classes for a method category."

	| organizer organizers |
	organizer := self classOrMetaClassOrganizer.
	organizers := self selectedClassOrMetaClass withAllSuperclasses collect: [:ea | ea organization].
	(organizer listAtCategoryNamed: ClassOrganizer defaultMethodCategory) do: [:sel | | found |
		found := (organizers collect: [ :org | org categoryOfElement: sel])
			detect: [:ea | ea ~= ClassOrganizer defaultMethodCategory and: [ ea notNil]]
			ifNone: nil.
		found ifNotNil: [organizer classify: sel under: found]].

	self changed: #messageCategoryList! !
!Debugger methodsFor: 'method creation' stamp: 'jmv 3/26/2024 12:11:38' prior: 16844561!
         implement: aMessage inClass: aClass context: aContext 
	
	self implement: aMessage inCategory: (self askForCategoryIn: aClass default: ClassOrganizer defaultMethodCategory) fromClass: aClass context: aContext! !
!ClassDescription methodsFor: 'compiling' stamp: 'jmv 3/26/2024 12:10:03' prior: 16819411 overrides: 16787519!
                             compile: code notifying: requestor 
	"Refer to the comment in Behavior|compile:notifying:." 

	^self compile: code
		 classified: ClassOrganizer defaultMethodCategory
		 notifying: requestor! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 3/26/2024 12:10:06' prior: 16819918!
  methods
	"Answer a ClassCategoryReader for compiling messages that are not classified, as in fileouts made with Smalltalk/V"

	^ ClassCategoryReader new setClass: self category: ClassOrganizer defaultMethodCategory! !
!ClassDescription methodsFor: 'organization' stamp: 'jmv 3/26/2024 12:15:46' prior: 16820695!
        category: requested 
	"Categorize the receiver under the system category, cat, removing it from 
	any previous categorization."

	| oldCategory newCategory |
	requested isString ifFalse: [^self errorCategoryName].
	oldCategory := self category.
	newCategory := (requested isNil or: [ requested isEmpty ])
		ifFalse: [requested withBlanksTrimmed]
		ifTrue: [SystemOrganization class defaultClassCategory].
	SystemOrganization classify: self name under: newCategory.
	SystemChangeNotifier uniqueInstance classRecategorized: self from: oldCategory to: newCategory.! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 3/26/2024 12:16:39' prior: 16816315!
             name: className subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe
	"Define a new class.
	If unsafe is true do not run any validation checks.
	This facility is provided to implement important system changes."
	
	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory behaviorClasses |
	
	instVars := Scanner new scanFieldNames: instVarString.
	classVars := (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].

	"Validate the proposed name"
	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].
	oldClass := Smalltalk at: className ifAbsent: nil.
	oldClass isBehavior 
		ifFalse:[oldClass := nil]. "Already checked in #validateClassName:"
	copyOfOldClass := oldClass copy.

	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].
		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].

	"See if we need a new subclass"
	needNew := self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.
	needNew ifNil: [^nil]. "some error"

	(needNew and:[unsafe not]) ifTrue:[
		"Make sure we don't redefine any dangerous classes"
		(self tooDangerousClasses includes: oldClass name) ifTrue:[
			self error: oldClass name, ' cannot be changed'.
		].
		"Check if the receiver should not be redefined"
		(oldClass notNil and:[oldClass shouldNotBeRedefined]) ifTrue:[
			self notify: oldClass name asText allBold, 
						' should not be redefined!! \Proceed to store over it.' withNewLines]].

	needNew ifTrue:[
		"Create the new class"
		newClass := self 
			newSubclassOf: newSuper 
			type: type 
			instanceVariables: instVars
			from: oldClass.
		newClass ifNil: [ ^nil]. "Some error"
		newClass setName: className.
	] ifFalse:[
		"Reuse the old class"
		newClass := oldClass.
	].

	"Install the class variables and pool dictionaries... "
	force := (newClass declareClassVarString: classVarString) | (newClass declareSharedPoolString: poolString).

	"... classify ..."
	organization := Smalltalk organization.
	newCategory := (category isNil or: [ category isEmpty ])
		ifFalse: [category withBlanksTrimmed]
		ifTrue: [organization class defaultClassCategory].
	oldClass ifNotNil: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].
	organization classify: newClass name under: newCategory.

	"... recompile ..."
	(oldClass notNil and: [oldClass includesBehavior: Behavior])
		ifTrue: [
			"This is only true for Behavior, ClassDescription, Class and Metaclass. Special treatment."
			unsafe ifFalse: [
				behaviorClasses := (oldClass withAllSubclasses select: [ :c | c isMeta not ]) asArray.
				(Processor anyReceiverInStackInstanceOfClassIn: behaviorClasses) ifTrue: [
					self error: oldClass name,' has some subInstance running some CompiledMethod.'.
					^nil ]].
			"Please see comment at this method"
			newClass := self recompileSingleRecursion: force from: oldClass to: newClass ]
		ifFalse: [
			"Other classes"
			newClass := self recompile: force from: oldClass to: newClass mutate: false ].
	newClass isNil ifTrue: [ ^nil ].

	"... export if not yet done ..."
	(Smalltalk at: newClass name ifAbsent: nil) == newClass ifFalse:[
		[Smalltalk at: newClass name put: newClass]
			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].
		Smalltalk flushClassNameCache.
	].

	self doneCompiling: newClass.
	
	"... notify interested clients ..."
	oldClass ifNil: [
		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.
		^ newClass].
	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.
	newCategory ~= oldCategory 
		ifTrue: [SystemChangeNotifier uniqueInstance classRecategorized: newClass from: oldCategory to: newCategory ].
	^newClass! !
!CompiledMethod class methodsFor: 'source code management aux' stamp: 'jmv 3/26/2024 12:17:27' prior: 16836313!
                     classCategoryFrom: tokens

	^self field: #category: from: tokens ifAbsentOrNil: [ SystemOrganizer defaultClassCategory ]! !
!MethodCategoriesPrompter methodsFor: 'categories initialization - private' stamp: 'jmv 3/26/2024 12:10:10' prior: 50363875!
       createCategories

	| classCategories |
	
	categories := OrderedCollection with: 'new ...'.
	lines := OrderedCollection with: 1. 
	classCategories := startClass methodCategoriesAsSortedCollection.
	
	reject := classCategories asSet.
	reject
		add: ClassOrganizer defaultMethodCategory.
	
	startClass isMeta ifTrue: [ self initializeCategoriesWhenMeta: classCategories].
	rejectingFirst ifFalse: [ categories addAll: classCategories ]! !
!MethodReference methodsFor: 'services' stamp: 'jmv 3/26/2024 12:10:14' prior: 16902377!
                   updateReferencesTo: oldClassName toBe: newClassName

	| src ts cm |
	src := self actualClass sourceCodeAt: methodSymbol.
	src := src copyReplaceAll: oldClassName with: newClassName.
	cm := self actualClass compiledMethodAt: methodSymbol.
	ts := cm timeStamp.
	ts = '' ifTrue: [ts := nil].
	self actualClass 
		compile: src
		classified: ClassOrganizer defaultMethodCategory
		withStamp: ts 
		notifying: nil.

	^true
! !

Categorizer class removeSelector: #default!

!methodRemoval: Categorizer class #default stamp: 'Install-6302-defaultCategory-removeFalsePolymorphism-JuanVuletich-2024Mar26-12h35m-jmv.001.cs.st 4/10/2024 10:41:42'!
default 
	^ Default!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6302-defaultCategory-removeFalsePolymorphism-JuanVuletich-2024Mar26-12h35m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6302] on 27 March 2024 at 10:42:25 am'!
!WorldMorph methodsFor: 'windows' stamp: 'PB 3/27/2024 10:39:30'!
               cleanUpWorldExceptFor: aMorph 
	
	(SelectionMenu confirm:
'This will remove all windows except the selected one,
and those containing unsaved text.
It will also remove all non-window morphs on the desktop.
Are you sure you want to do this?') ifFalse: [ ^ self ].
	self allNonWindowRelatedSubmorphs do: [ :m |
		m delete ] without: aMorph.
	(SystemWindow
		windowsIn: self
		satisfying: [ :w |
			w visible and: [ w canDiscardEdits ]]) do: [ :w |
		w delete ] without: aMorph.! !
!SystemWindow methodsFor: 'open/close' stamp: 'PB 3/27/2024 10:39:32'!
                          closeOtherWindows
	self world cleanUpWorldExceptFor: self.! !
!SystemWindow methodsFor: 'menu' stamp: 'PB 3/27/2024 09:21:30' prior: 16971151!
                 buildWindowMenu

	| aMenu |

	aMenu := MenuMorph new defaultTarget: self.

	aMenu 
		add: 'change title...' 			action: #relabel 						icon: #saveAsIcon;
		add: 'window color...' 			action: #setWindowColor 			icon: #graphicsIcon;
		add: 'close others...' 			action: #closeOtherWindows 			icon: #closeIcon.
	
	self hasSaveAs
		ifTrue: [ aMenu add: 'Save as ...' action: #saveContents icon: #saveAsIcon ].
		
	aMenu
		addLine.
		
	self addWindowControlTo: aMenu.
	self addTileResizerMenuTo: aMenu.

	^ aMenu! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6303-deleteOtherWindows-PaoloBelforte-2024Mar27-10h35m-PB.001.cs.st----!

'From Cuis6.3 [latest update: #6302] on 27 March 2024 at 10:53:51 am'!
!BasicClassOrganizer methodsFor: 'accessing' stamp: 'jmv 3/27/2024 10:51:29'!
             dateCommentLastSaved
	"Answer a Date object indicating when my class comment was last saved.  If there is no date stamp, or one of the old-time <historical>  guys, return nil"
	"RecentMessageSet organization dateCommentLastSaved"

	| aStamp tokens |
	(aStamp := self commentStamp) isEmptyOrNil ifTrue: [^ nil].
	tokens := aStamp findBetweenSubStrs: ' 
'.  "space is expected delimiter, but cr is sometimes seen, though of mysterious provenance"
	^ tokens size > 1
		ifTrue: [
			[tokens second asDate] ifError: nil]! !
!CompiledMethod methodsFor: 'time stamp' stamp: 'jmv 3/27/2024 10:51:49'!
               dateMethodLastSaved
	"Answer a Date object indicating when a method was last saved.  If there is no date stamp, return nil"
	"
	(CompiledMethod compiledMethodAt: #dateMethodLastSaved) dateMethodLastSaved
	"

	^self class timeStamp: self timeStamp partsDo: [ :authorInitials :dateAndTime | dateAndTime ifNotNil: [ dateAndTime date ]]! !
!CodeProvider methodsFor: 'what to show' stamp: 'jmv 3/27/2024 10:48:57' prior: 16826769!
                      toggleDecompile
	"Toggle the setting of the showingDecompile flag, unless there are unsaved edits that the user declines to discard"

	self showDecompile: self showingDecompile not! !
!CodeProvider methodsFor: 'what to show' stamp: 'jmv 3/27/2024 10:49:02' prior: 16826778!
              toggleShowDocumentation
	"Toggle the setting of the showingDocumentation flag, unless there are unsaved edits that the user declines to discard"

	self showDocumentation: self showingDocumentation not! !
!MethodSet methodsFor: 'accessing' stamp: 'jmv 3/27/2024 10:49:30' prior: 50355293!
reformulateListNoting: newSelector
	"A method has possibly been saved for the receiver with newSelector as its selector.
	If the receiver has a way of reformulating its message list, here is a chance for it to do so"

	^ self reformulateList! !
!MethodSet methodsFor: 'message list' stamp: 'jmv 3/27/2024 10:50:02' prior: 50355486!
                    sortByDate
	"Sort the message-list by date of time-stamp"

	| assocs aCompiledMethod aDate inOrder |
	assocs := messageList collect: [ :aRef |
		aDate := aRef methodSymbol == #Comment
			ifTrue: [
				aRef actualClass organization dateCommentLastSaved]
			ifFalse: [
				aCompiledMethod := aRef actualClass compiledMethodAt: aRef methodSymbol ifAbsent: nil.
				aCompiledMethod ifNotNil: [aCompiledMethod dateCommentLastSaved]].
		aRef -> (aDate ifNil: [Date fromString: '01/01/1996'])].  "The dawn of Squeak history"
	inOrder := assocs asArray sort: [ :a :b | a value < b value].

	inOrder do: [ :each | each key prefixStringVersionWith: each value yyyymmdd ].
	messageList := inOrder collect: [ :assoc | assoc key ].
	self changed: #messageList! !
!VersionsBrowser methodsFor: 'menu' stamp: 'jmv 3/27/2024 10:50:30' prior: 17004025!
                             versionsHelpString
	^ 'Each entry in the list pane represents a version of the source code for the same method; the topmost entry is the current version, the next entry is the next most recent, etc.

To revert to an earlier version, select it (in the list pane) and then do any of the following:
  *  Choose "revert to this version" from the list pane menu.
  *  Hit the "revert" button,
  *  Type Return in the code pane
  *  Type cmd-s (alt-s) in the code pane.

The code pane shows the source for the selected version.  If "diffing" is in effect, then differences betwen the selected version and the version before it are pointed out in the pane.  Turn diffing on and off by choosing "toggle diffing" from the list pane menu, or hitting the "diffs" button, or hitting cmd-D when the cursor is over the list pane.

To get a comparison between the selected version and the current version, choose "compare to current" from the list pane menu or hit the "compare to current" button.  (This is meaningless if the current version is selected, and is unnecessary if you''re interested in diffs from between the current version and the next-most-recent version, since the standard in-pane "diff" feature will give you that.)

You can also compare the selected version with any other version using the "compare to version..." menu choice.

If further versions of the method in question have been saved elsewhere since you launched a particular Versions Browser, it will still stay nicely up-to-date if you''re in Morphic and have asked that smart updating be maintained; if you''re in mvc or in morphic but with smart-updating turned off, a versions browser is only brought up to date when you activate its window (and when you issue "revert" from within it, of course,) and you can also use the "update list" command to make certain the versions list is up to date.

Hit the "remove from changes" button, or choose the corresponding command in the list pane menu, to have the method in question deleted from the current change set.  This is useful if you''ve put debugging code into a method, and now want to strip it out and cleanse your current change set of all memory of the excursion.

Note:  the annotation pane in versions browsers shows information about the *current* version of the method in the image, not about the selected version.'! !
!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 3/27/2024 10:50:49' prior: 16810207!
contents: input notifying: aRequestor 
	"Compile the code in aString. Notify aRequestor of any syntax errors. 
	Create an error if the category of the selected message is unknown. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."

	| codeString category selector class oldSelector |
	codeString := input string.
	(class := self selectedClassOrMetaClass) ifNil:
		[(myChangeSet preambleString == nil or: [codeString isEmpty]) ifTrue: [ ^ false].
		(codeString count: [:char | char = $"]) odd 
			ifTrue: [self inform: 'unmatched double quotes in preamble']
			ifFalse: [(Scanner new scanTokens: codeString) notEmpty ifTrue: [
				self inform: 'Part of the preamble is not within double-quotes.
To put a double-quote inside a comment, type two double-quotes in a row.
(Ignore this warning if you are including a doIt in the preamble.)']].
		myChangeSet preambleString: codeString.
		self currentSelector: nil.  "forces update with no 'unsaved chages' feedback"
		^ true].
	oldSelector := self selectedMessageName.
	category := class organization categoryOfElement: oldSelector.
	selector := class compile: codeString
				classified: category
				notifying: aRequestor.
	selector ifNil: [^ false].
	(self messageList includes: selector)
		ifTrue: [self currentSelector: selector]
		ifFalse: [self currentSelector: oldSelector].
	self update.
	^ true! !
!TextModelMorph methodsFor: 'drawing' stamp: 'jmv 3/27/2024 10:52:52' prior: 16982921 overrides: 16796561!
               drawOn: aCanvas
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"
	| bw bc |
	self flag: #todo.
	"Integrate this method with the Theme system. --cbr"
	super drawOn: aCanvas.
	bw := Preferences at: #focusIndicatorWidth.
	bc := nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [ "Put up feedback showing that code cannot be saved in this state"
				bc := Color tan ]
			ifFalse: [
				scroller hasEditingConflicts
					ifTrue: [
						bw := 3.
						bc := Color red ]
					ifFalse: [
						scroller hasUnacceptedEdits ifTrue: [ bc := Color red ]]]].
	(drawKeyboardFocusIndicator and: [ scroller hasKeyboardFocus ])
		ifTrue: [ bc ifNil: [ bc := Theme current focusIndicator ]]
		ifFalse: [
			bc ifNotNil: [
				bc := bc
					alphaMixed: 0.4
					with: Color white ]].
	bc ifNotNil: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle
			borderWidth: bw
			color: bc ].! !
!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 3/27/2024 10:46:13' prior: 16983765!
              cleanUpWorld
	(SelectionMenu confirm:
'This will remove all windows except those containing unsaved text.
It will also remove all non-window morphs on the desktop.
Are you sure you want to do this?') ifFalse: [ ^ self ].
	myWorld allNonWindowRelatedSubmorphs do: [ :m |
		m delete ].
	(SystemWindow
		windowsIn: myWorld
		satisfying: [ :w |
			w visible and: [ w canDiscardEdits ]]) do: [ :w |
		w delete ]! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/27/2024 10:53:07' prior: 50362160!
     windowsMenuOptions

	^`{
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		10.
				#label 			-> 		'Find Window'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findWindow:.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Presents a list of all windows; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		20.
				#label 			-> 		'Find changed Browsers...'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findDirtyBrowsers:.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Presents a list of browsers that have unsaved changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		10.
				#itemOrder 			-> 		30.
				#label 			-> 		'Find changed Windows...'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findDirtyWindows:.
				#icon 			-> 		#newWindowIcon.
				#balloonText 	-> 		'Presents a list of all windows that have unsaved changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  ->  					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		10.
				#label 			-> 		'Find a Transcript'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findATranscript:.
				#icon 			-> 		#printerIcon.
				#balloonText 	-> 		'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		20.
				#label 			-> 		'Find a FileList'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAFileList:.
				#icon 			-> 		#systemFileManagerIcon.
				#balloonText 	-> 		'Brings an open fileList  to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		30.
				#label 			-> 		'Find a Change Sorter'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAChangeSorter:.
				#icon 			-> 		#changesIcon.
				#balloonText 	-> 		'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		20.
				#itemOrder 			-> 		40.
				#label 			-> 		'Find Message Names'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAMessageNamesWindow:.
				#icon 			-> 		#inspectIcon.
				#balloonText 	-> 		'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		10.
				#label 			-> 		'Tile open windows'.
				#object          			-> 		TileResizeMorph.
				#selector 			-> 		#tileOpenWindows.
				#icon 			-> 		#windowIcon.
				#balloonText 	-> 		'Tile open windows'.
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		20.
				#label 			-> 		'Collapse all Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#collapseAll.
				#icon 			-> 		#collapseIcon.
				#balloonText 	-> 		'Reduce all open windows to collapsed forms that only show titles.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		30.
				#label 			-> 		'Restore all Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#restoreAll.
				#icon 			-> 		#expandIcon.
				#balloonText 	-> 		'Restore all collapsed windows back to their previous forms.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		40.
				#label 			-> 		'Close top Window'.
				#object 			-> 		SystemWindow.
				#selector 			-> 		#closeTopWindow.
				#icon 			-> 		#closeIcon.
				#balloonText 	-> 		'Close the topmost window if possible.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		50.
				#label 			-> 		'Send top Window to back'.
				#object 			-> 		SystemWindow.
				#selector 			-> 		#sendTopWindowToBack.
				#icon 			-> 		#goBottomIcon.
				#balloonText 	-> 		'Make the topmost window become the backmost one, and activate the window just beneath it.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		30.
				#itemOrder 			-> 		60.
				#label 			-> 		'Move Windows onscreen'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#bringWindowsFullOnscreen.
				#icon 			-> 		#displayIcon.
				#balloonText 	-> 		'Make all windows fully visible on the screen'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		10.
				#label 			-> 		'Delete unchanged Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#closeUnchangedWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all windows that do not have unsaved text edits.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		20.
				#label 			-> 		'Delete non Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#deleteNonWindows.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all non-window morphs lying on the world.'
			} asDictionary.
			{
				#submenuOf  -> 					TheWorldMenu windowsLabel.
				#itemGroup 			-> 		40.
				#itemOrder 			-> 		30.
				#label 			-> 		'Delete Both of the Above'.
				#selector 			-> 		#cleanUpWorld.
				#icon 			-> 		#warningIcon.
				#balloonText 	-> 		'Deletes all unchanged windows and all non-window morphs on the world.'
			} asDictionary.
		}`! !

CompiledMethod removeSelector: #dateMethodLastSubmitted!

!methodRemoval: CompiledMethod #dateMethodLastSubmitted stamp: 'Install-6304-cleanup-JuanVuletich-2024Mar27-10h42m-jmv.001.cs.st 4/10/2024 10:41:42'!
dateMethodLastSubmitted
	"Answer a Date object indicating when a method was last saved.  If there is no date stamp, return nil"
	"
	(CompiledMethod compiledMethodAt: #dateMethodLastSubmitted) dateMethodLastSubmitted
	"

	^self class timeStamp: self timeStamp partsDo: [ :authorInitials :dateAndTime | dateAndTime ifNotNil: [ dateAndTime date ]]!

BasicClassOrganizer removeSelector: #dateCommentLastSubmitted!

!methodRemoval: BasicClassOrganizer #dateCommentLastSubmitted stamp: 'Install-6304-cleanup-JuanVuletich-2024Mar27-10h42m-jmv.001.cs.st 4/10/2024 10:41:42'!
dateCommentLastSubmitted
	"Answer a Date object indicating when my class comment was last submitted.  If there is no date stamp, or one of the old-time <historical>  guys, return nil"
	"RecentMessageSet organization dateCommentLastSubmitted"

	| aStamp tokens |
	(aStamp := self commentStamp) isEmptyOrNil ifTrue: [^ nil].
	tokens := aStamp findBetweenSubStrs: ' 
'.  "space is expected delimiter, but cr is sometimes seen, though of mysterious provenance"
	^ tokens size > 1
		ifTrue: [
			[tokens second asDate] ifError: nil]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6304-cleanup-JuanVuletich-2024Mar27-10h42m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6304] on 2 April 2024 at 9:46:36 am'!
!TextEditor methodsFor: 'menu messages' stamp: 'jmv 4/2/2024 09:14:06' prior: 16980863!
                            copySelection
	"Copy the current selection and store it in the Clipboard, unless empty."

	| multiSelection |

	"Copying whitespace to clipboard is OK."
	(self hasSelection and: [self selection isSeparators]) ifFalse: [
		self lineSelectAndEmptyCheck: [^ self]].

	multiSelection := self selection.
	self clipboardTextPut: multiSelection! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6305-AllowCopyOfWhitespace-JuanVuletich-2024Apr02-09h45m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6305] on 2 April 2024 at 9:42:29 am'!
!Theme methodsFor: 'colors' stamp: 'jmv 4/2/2024 09:41:00' prior: 50363481!
                     textEmptyDisplayMessage
	^ `Color veryLightGray`! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 4/2/2024 09:38:55' prior: 50363511!
                           defaultWindowColor
	^ `Color veryLightGray`! !
!Theme methodsFor: 'shout' stamp: 'jmv 4/2/2024 09:14:53' prior: 50363515!
      shout
	"Color symbols as an association list.
	SHTextStylerST80 initialize
	"
	^ {
		#selector  						-> nil.
		#arguments  						-> #(cyan muchDarker).
		#comment 						-> #(green muchDarker).
		#tempBar 						-> #gray.
		#tempVars 						-> #(gray muchDarker).
		#instVar 						-> #(magenta muchDarker).
		#pseudoVariables 						-> #(red muchDarker).
		#literals 						-> #(green muchDarker).
		#messages 						-> #(blue darker).
		#incompleteMessages 						-> #(gray veryMuchDarker).
		#blockLevelZero 						-> #black.
		#blockLevelOne 						-> #brown.
		#blockLevelTwo 						-> #magenta.
		#blockLevelThree 						-> #red.
		#blockLevelFour 						-> #(orange darker).
		#blockLevelFive 						-> #(orange muchDarker).
		#blockLevelSix 						-> #(green muchDarker).
		#blockLevelSeven 						-> #blue.
		#defaults 						-> #black.
		#undefined 						-> #red.
		#methodTags 						-> #(green muchDarker).
	}! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 4/2/2024 09:37:35' prior: 50363546 overrides: 50364784!
                shout
	"Color symbols as an association list."

	^ {
		#selector  						-> '#B59F60'.
		#arguments 						-> '#289078'.
		#comment 						-> #(green duller).
		#tempBar 						-> #gray.
		#tempVars 						-> '#767836'.
		#instVar 						-> '#B3695A'.
		#pseudoVariables 						-> '#2070E0'.
		#literals 						-> #green.
		#messages 						-> '#6FB3BD'.
		#incompleteMessages  					-> '#F08060'.
		#blockLevelZero 						-> '#6FB3BD'.
		#blockLevelOne 						-> '#FFB0B0'.
		#blockLevelTwo 						-> '#B0FFB0'.
		#blockLevelThree 						-> '#B0B0FF'.
		#blockLevelFour 						-> '#00B0B0'.
		#blockLevelFive 						-> '#E03030'.
		#blockLevelSix 						-> '#30E030'.
		#blockLevelSeven 						-> '#3030E0'.
		#defaults 						-> '#A1AFBF'.
		#undefined 						-> '#E04020'.
		#methodTags 						-> #green.
	}! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 4/2/2024 09:41:46' prior: 50363574 overrides: 16985025!
   text
	^ `Color veryVeryLightGray`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6306-ThemesTweaks-JuanVuletich-2024Apr02-09h09m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6306] on 2 April 2024 at 10:23:54 am'!
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 4/2/2024 10:22:20' prior: 16893308 overrides: 16904087!
                 mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse up event. Menu items get activated when the mouse is over them. Do nothing if we're not in a 'valid menu transition', meaning that the current hand focus must be aimed at the owning menu."

	owner hasMouseFocus ifFalse: [ ^self ].
	owner selectedItem == self ifFalse: [ ^self ].
	"This will happen if the menu has toggles in it. (for instance, the 'show...' button)
	Update the look, refresh the world and wait a bit,
	to give the user some visual feedback"
	contentString ifNotNil: [
		self contentsWithMarkers: contentString inverse: true.
		self world ifNotNil: [ :w | w displayWorldOn: w mainCanvas ].  "show myself"
		(Delay forMilliseconds: 200) wait].
	self deselect.
	self invokeWithEvent: aMouseButtonEvent! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 4/2/2024 10:16:48' prior: 50362814!
  displayFiltered: evt
	| matchStr allItems isMatch feedbackMorph |
	matchStr := self valueOfProperty: #matchString.
	allItems := self submorphs select: [ :m |
		m is: #MenuItemMorph ].
	allItems do: [ :m |
		isMatch := matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch ].
	feedbackMorph := self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph := LabelMorph new color: `Color darkGray`.
		self addMorphBack: feedbackMorph lock position: `0@ -20`.
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self removeProperty: #feedbackMorph ].
	self selectItem: nil.! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 8/5/2021 11:43:50' prior: 50362610!
          fitInWorld

	| delta trialRect |
	trialRect := Rectangle origin: self morphPosition extent: extent.
	delta := trialRect amountToTranslateWithin: owner displayBounds.
	self morphPosition: trialRect origin + delta.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6307-CorrectImplementationOf-6292-JuanVuletich-2024Apr02-10h22m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6304] on 30 March 2024 at 8:06:08 pm'!
!CodeProvider methodsFor: 'message list' stamp: 'HAW 3/30/2024 20:02:10'!
            selector: oldSelector refactoredTo: newSelector

	"Used by the refactorings when a selector is renamed, a parameter is added, etc. - Hernan"

	self subclassResponsibility ! !
!Browser methodsFor: 'message list' stamp: 'HAW 3/30/2024 20:02:10' overrides: 50364928!
                        selector: oldSelector refactoredTo: newSelector

	self selectedMessageName = oldSelector ifTrue: [ self setSelector: newSelector ]! !
!MethodSet methodsFor: 'message list' stamp: 'HAW 3/30/2024 20:02:10' overrides: 50364928!
                               selector: oldSelector refactoredTo: newSelector

	self selectedMessageName = oldSelector ifTrue: [ self removeMessageFromBrowserKeepingLabel ]! !
!ChangeList methodsFor: 'message list' stamp: 'HAW 3/30/2024 20:03:41' overrides: 50364928!
                  selector: oldSelector refactoredTo: newSelector 
	
	! !
!ChangeSorter methodsFor: 'message list' stamp: 'HAW 3/30/2024 20:02:10' overrides: 50364928!
          selector: oldSelector refactoredTo: newSelector

	! !
!Debugger methodsFor: 'context stack (message list)' stamp: 'HAW 3/30/2024 20:02:10' overrides: 50364928!
selector: oldSelector refactoredTo: newSelector

	self selectedMessageName = oldSelector ifTrue: [ self down ].
	self currentMethodRefactored ! !
!ChangeSelectorApplier methodsFor: 'refactoring - changes' stamp: 'HAW 3/30/2024 20:02:10' prior: 16806664!
  informChangesToBrowser

	browser selector: oldSelector refactoredTo: refactoring newSelector
	! !

VersionsBrowser removeSelector: #selector:refactoredTo:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6308-ChangeSelectorRefactoringsBetterUX-HernanWilkinson-2024Mar30-18h32m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6308] on 3 April 2024 at 10:16:03 am'!
!DarkTheme methodsFor: 'colors' stamp: 'jmv 4/3/2024 10:15:30' prior: 16841217 overrides: 16984970!
     background
	^ `Color veryVeryDarkGray`! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 4/3/2024 10:14:46' prior: 50364816 overrides: 50364784!
                  shout
	"Color symbols as an association list."

	^ {
		#selector  						-> '#B59F60'.
		#arguments 						-> '#289078'.
		#comment 						-> #(green duller).
		#tempBar 						-> '#707070'.
		#tempVars 						-> '#767836'.
		#instVar 						-> '#B3695A'.
		#pseudoVariables 						-> '#2070E0'.
		#literals 						-> #green.
		#messages 						-> '#6FB3BD'.
		#incompleteMessages  					-> '#F08060'.
		#blockLevelZero 						-> '#6FB3BD'.
		#blockLevelOne 						-> '#FFB0B0'.
		#blockLevelTwo 						-> '#B0FFB0'.
		#blockLevelThree 						-> '#B0B0FF'.
		#blockLevelFour 						-> '#00B0B0'.
		#blockLevelFive 						-> '#E03030'.
		#blockLevelSix 						-> '#30E030'.
		#blockLevelSeven 						-> '#3030E0'.
		#defaults 						-> '#A1AFBF'.
		#undefined 						-> '#E04020'.
		#methodTags 						-> #green.
	}! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6309-DarkThemeTweaks-JuanVuletich-2024Apr03-10h08m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6309] on 3 April 2024 at 11:26:20 am'!
!TestCase methodsFor: 'running - private' stamp: 'HAW 4/3/2024 11:25:23' prior: 16975657!
    performTest

	assertCount := 0.
	self perform: testSelector asSymbol! !
!TestCase methodsFor: 'setUp/tearDown' stamp: 'HAW 4/3/2024 11:25:10' prior: 50359743!
 setUp
	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6310-assertCountMovedToperfomTest-HernanWilkinson-2024Apr03-11h25m-HAW.001.cs.st----!

'From Cuis6.3 [latest update: #6310] on 3 April 2024 at 11:51:57 am'!
!TestCase methodsFor: 'running' stamp: 'jmv 4/3/2024 11:50:49' prior: 16975646!
                runCase

	assertCount := 0.
	[
		self setUp.
		self performTest] ensure: [self tearDown]
			! !
!TestCase methodsFor: 'running' stamp: 'jmv 4/3/2024 11:50:58' prior: 16975651!
                runCaseAsFailure

	assertCount := 0.
	self setUpResources.
	self setUp.
	
	self openDebuggerOnFailingTestMethod! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6311-TestCaseMoreRobust-JuanVuletich-2024Apr03-11h50m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6311] on 4 April 2024 at 10:46:55 am'!
!StringRequestMorph methodsFor: 'initialization' stamp: 'jmv 4/4/2024 10:43:44' prior: 16961251!
    setQuery: queryString initialAnswer: initialAnswer
	| titleMorphExtent titleHeight titleWidth requiredLines lineWidth contentsWidth maxLineWidth extraWidth |
	response := initialAnswer.
	titleMorphExtent := self addTitle: queryString.
	titleWidth := 20 * FontFamily defaultPointSize max: titleMorphExtent x.
	titleHeight := titleMorphExtent y + FontFamily defaultLineSpacing. "Some extra room for borders, etc."
	self addTextPane.

	requiredLines := 0.
	"Single line preferred. For instance, for file names and paths."
	(response noneSatisfy: [ :each | each isSeparator ]) ifTrue: [
		maxLineWidth := Display width * 0.8.
		contentsWidth := FontFamily defaultFamilyAndPointSize widthOfString: response.
		contentsWidth < maxLineWidth ifTrue: [
			"Will fit in the screen. Ok."
			requiredLines := 1.
			extraWidth := (10 * FontFamily defaultPointSize). "Some extra room for edition plus accept/cancel buttons." ]].

	"May need to be multiple lines"
	requiredLines = 0 ifTrue: [
		maxLineWidth := Display width // 3.
		contentsWidth := 0.
		response linesDo: [ :eachLine |
			lineWidth := FontFamily defaultFamilyAndPointSize widthOfString: eachLine.
			contentsWidth := contentsWidth max: (lineWidth min: maxLineWidth).
			requiredLines := requiredLines + (lineWidth / maxLineWidth) ceiling ].
		extraWidth := (6 * FontFamily defaultPointSize). "Some extra room for edition plus accept/cancel buttons."
		requiredLines := requiredLines min: 20. "Use scrollbars if needed." 		].

	self morphExtent: ((titleWidth max: contentsWidth) + extraWidth)@(titleHeight + (FontFamily defaultLineSpacing * requiredLines)).! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6312-StringRequestMorph-BetterInitialExtent-JuanVuletich-2024Apr04-10h46m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6304] on 27 March 2024 at 10:19:52 pm'!
!CodePackage methodsFor: 'saving' stamp: 'MM 3/27/2024 22:16:05' prior: 50352859!
    save
	"If we can't save, find a new destination directory."
	fullFileName ifNotNil: [
		fullFileName asFullFileEntry parent exists ifFalse: [
			fullFileName := nil ]].

	"If we were never saved, or never saved since image was moved, or target directory disappeared, then save to image directory."
	fullFileName ifNil: [
		fullFileName :=
			self request: 'Save on path: ' initialAnswer:
				(DirectoryEntry newPackagesDirectory // self packageFileName) pathName ].

	fullFileName asFullFileEntry forceWriteStreamDo: [ :stream |
		stream timeStamp.
		self writeOnStream: stream ].

	self hasUnsavedChanges: false.
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: self)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6313-AskPathForPackageSave-MarianoMontone-2024Mar27-21h56m-MM.001.cs.st----!

'From Cuis6.3 [latest update: #6313] on 5 April 2024 at 4:29:34 pm'!
!Color methodsFor: 'transformations' stamp: 'jmv 4/5/2024 16:26:20' prior: 16830592!
        adjustSaturation: saturation brightness: brightness
	"Adjust the relative saturation and brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	| v |
	v := self brightness + brightness min: 1.0 max: 0.005.
	self saturation < 0.005 ifTrue: [
		"Don't adjust saturation if gray. Hue is meaningless."
		^ (Color gray: v) alpha: self alpha ].
	^ Color
		h: self hue
		s: (self saturation + saturation min: 1.0 max: 0.005)
		v: v
		alpha: self alpha! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6314-Color-fix-JuanVuletich-2024Apr05-16h28m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6313] on 5 April 2024 at 4:29:58 pm'!

DarkTheme removeSelector: #missingCommentTextColor!

!methodRemoval: DarkTheme #missingCommentTextColor stamp: 'Install-6315-Cleanup-JuanVuletich-2024Apr05-16h29m-jmv.001.cs.st 4/10/2024 10:41:42'!
missingCommentTextColor

	^ TextColor cyan!

Theme removeSelector: #dualChangeSorter!

!methodRemoval: Theme #dualChangeSorter stamp: 'Install-6315-Cleanup-JuanVuletich-2024Apr05-16h29m-jmv.001.cs.st 4/10/2024 10:41:42'!
dualChangeSorter
	^ self changeSorter!

Theme removeSelector: #missingCommentTextColor!

!methodRemoval: Theme #missingCommentTextColor stamp: 'Install-6315-Cleanup-JuanVuletich-2024Apr05-16h29m-jmv.001.cs.st 4/10/2024 10:41:42'!
missingCommentTextColor

	^ TextColor red!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6315-Cleanup-JuanVuletich-2024Apr05-16h29m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6313] on 8 April 2024 at 9:52:34 am'!
!Sample04Pacman methodsFor: 'updating' stamp: 'jmv 4/8/2024 09:50:51' prior: 50354446 overrides: 16907028!
    redrawNeeded
	"for experimenting with collision detection"

	self isOwnedByHand ifTrue: [
		self world ifNotNil: [ :w |
			w submorphsDo: [ :m |
				"In #redrawNeeded, we can't call #delete on a dirty SystemWindow,
				as the confirmation menu can't be opened."
				(((m is: #SystemWindow) not or: [ m canDiscardEdits ]) and: [
						self collides: m]) ifTrue: [
					m class == self class
						ifTrue: [ m colorize ]
						ifFalse: [ m delete ]]]]].
	super redrawNeeded.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6316-Pacman-tweak-JuanVuletich-2024Apr08-09h50m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6316] on 8 April 2024 at 6:54:14 pm'!
!Browser methodsFor: 'class list' stamp: 'jmv 4/8/2024 15:51:00' prior: 16797792!
                 classList

	^ listClassesHierarchically
		ifTrue: [self hierarchicalClassList]
		ifFalse: [self defaultClassList].! !
!Browser methodsFor: 'initialization' stamp: 'jmv 4/8/2024 15:51:51' prior: 16799075 overrides: 16932297!
initialize
	super initialize.
	self systemOrganizer: SystemOrganization.
	listClassesHierarchically := Preferences at: #listClassesHierarchically! !

Browser class removeSelector: #listClassesHierarchically!

!methodRemoval: Browser class #listClassesHierarchically stamp: 'Install-6317-Cleanup-JuanVuletich-2024Apr08-18h53m-jmv.001.cs.st 4/10/2024 10:41:42'!
listClassesHierarchically
	
	^Preferences at: #listClassesHierarchically!

Browser class removeSelector: #new!

!methodRemoval: Browser class #new stamp: 'Install-6317-Cleanup-JuanVuletich-2024Apr08-18h53m-jmv.001.cs.st 4/10/2024 10:41:42'!
new

	^super new systemOrganizer: SystemOrganization!

Browser removeSelector: #listClassesHierarchically!

!methodRemoval: Browser #listClassesHierarchically stamp: 'Install-6317-Cleanup-JuanVuletich-2024Apr08-18h53m-jmv.001.cs.st 4/10/2024 10:41:42'!
listClassesHierarchically 

	"I check for nil to support migration on already opened browser when the change is loaded in image - Hernan"
	^listClassesHierarchically ifNil: [ self initializeListClassesHierachically]!

Browser removeSelector: #initializeListClassesHierachically!

!methodRemoval: Browser #initializeListClassesHierachically stamp: 'Install-6317-Cleanup-JuanVuletich-2024Apr08-18h53m-jmv.001.cs.st 4/10/2024 10:41:42'!
initializeListClassesHierachically

	listClassesHierarchically := self class listClassesHierarchically !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6317-Cleanup-JuanVuletich-2024Apr08-18h53m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6317] on 9 April 2024 at 10:08:45 am'!
!MethodSetWindow class methodsFor: 'opening' stamp: 'jmv 4/9/2024 10:07:47' prior: 50356710!
                     openFullProtocolForClass: aClass
	"Create and schedule a browser for the entire protocol of the class."
	"
	ProtocolBrowserWindow openFullProtocolForClass: Number.
	"

	| aPBrowser label |

	aPBrowser := ProtocolBrowser new on: aClass.
	label := 'Entire protocol of: ', aClass name.

	^self open: aPBrowser label: label! !
!MethodSetWindow class methodsFor: 'opening' stamp: 'jmv 4/9/2024 10:07:42' prior: 50356779!
openSubProtocolForClass: aClass
	"Create and schedule a browser for the entire protocol of the class."
	"
	ProtocolBrowserWindow openSubProtocolForClass: Number.
	"

	| aPBrowser label |

	aPBrowser := ProtocolBrowser new onSubProtocolOf: aClass.
	label := 'Sub-protocol of: ', aClass name.

	^self open: aPBrowser label: label! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6318-MethodSetWindow-comment-fix-JuanVuletich-2024Apr09-10h03m-jmv.001.cs.st----!

'From Cuis6.3 [latest update: #6318] on 9 April 2024 at 3:08:58 pm'!
!CodeFile methodsFor: 'accessing' stamp: 'jmv 4/9/2024 14:46:23' prior: 16822714!
                   description
	^String streamContents:[:s|
		s nextPutAll: 'CodeFile: '.
		s nextPutAll: fullName; newLine; newLine.
		sourceSystem isEmpty ifFalse:[
			s nextPutAll: sourceSystem; newLine; newLine ].
		doIts isEmpty ifFalse:[
			s nextPutAll: 'Unresolvable doIts:'; newLine; newLine.
			doIts do: [ :chgRec |
				s
					nextPut:$!!;
					nextPutAll: chgRec string;
					nextPut: $!!;
					newLine ]]]! !
!CodeFile methodsFor: 'accessing' stamp: 'jmv 4/9/2024 14:46:28' prior: 50353001 overrides: 16915326!
       name

	^ fullName asFullFileEntry name! !
!CodeFile methodsFor: 'reading' stamp: 'jmv 4/9/2024 15:02:30' prior: 16822942!
      buildFrom: aStream

	| changes |
	changes := (ChangeList new scanFile: aStream from: 0 to: aStream size) changeList.
	'Processing ', self name
		displayProgressAt: Sensor mousePoint
		from: 1
		to: changes size
		during: [ :barBlock | self buildFrom: changes informingTo: barBlock ].! !
!CodePackageFile methodsFor: 'services' stamp: 'jmv 4/9/2024 15:05:45' prior: 50353006!
         install
	"Create, install and answer a (sub)instance of CodePackage
	Replace all existing code in the possibly existing CodePackage, removing any code that is not included in us."
	| localName newCodePackage pckClass currentCS |

	localName := self name.
	ChangeSet installing: packageName do: [
		"This change set will capture a possible class definition for a subclass of CodePackage.
		If it only has that, then remove it after package install.
		One example needing this is 'Color-Extras.pck.st'"
		currentCS := ChangeSet changeSetForBaseSystem.
		currentCS isEmpty ifFalse: [ currentCS := nil ].
		pckClass := CodePackage.
		classes do: [ :ee |
			(ee hasDefinition and: [ee superclassName = 'CodePackage']) ifTrue: [
				((self packageName asIdentifier: true), 'Package') = ee name ifTrue: [
					ee fileInDefinitionAndMetaclass.
					pckClass := Smalltalk at: ee name ]]].
		newCodePackage := pckClass
			named: packageName
			createIfAbsent: true
			registerIfNew: true.
		newCodePackage
			fullFileName: fullName;
			sourceSystem: sourceSystem;
			description: description;
			featureSpec: featureSpec.

		fullName asFullFileEntry readStreamDo: [ :stream | stream fileInAnnouncing: 'Installing ', localName, '...' ].
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].
		currentCS ifNotNil: [ ChangeSet removeChangeSet: currentCS ]].

	newCodePackage hasUnsavedChanges: false; triggerEvent: #dirtyFlagChanged.
	DataStream initialize. "Just in case"
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: newCodePackage).
	(Preferences at: #transcriptLogVerbose) ifTrue: [
		Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
		Smalltalk cleanOutUndeclared.
		Undeclared notEmpty ifTrue: [
			('Undeclared: ', Undeclared printString) print ]].
	^newCodePackage! !
!CodePackageFile methodsFor: 'accessing' stamp: 'jmv 4/9/2024 14:46:38' prior: 16825052 overrides: 50365330!
                              description
	^String streamContents: [ :s |
		s nextPutAll: 'Code Package File: '.
		s nextPutAll: fullName; newLine; newLine.
		s nextPutAll: 'Provides: '.
		self provides printDetailsOn: s.
		s newLine.
		self requires ifNotEmpty: [ :requirements | 
			s nextPutAll: 'Requires: '.
			(requirements sorted: [:a :b | a name < b name]) do: [ :req |
				s newLine; space.
				req printDetailsOn: s ].
			s newLine ].
		s newLine.
		sourceSystem isEmpty ifFalse:[
			s nextPutAll: sourceSystem; newLine; newLine ]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6319-cleanup-JuanVuletich-2024Apr09-15h07m-jmv.001.cs.st----!

----QUIT----(10 April 2024 10:42:11) Cuis6.3-6319.image priorSource: 990404!