'From Cuis7.2 [latest update: #6895] on 6 December 2024 at 11:02:12 am'!


----SNAPSHOT----(6 December 2024 11:02:12) Cuis7.2.image priorSource: 0!

Preferences at: #saveReleaseOptionsInWorldMenu put: true!

----QUIT----(6 December 2024 11:04:53) Cuis7.3-6895.image priorSource: 73!

----STARTUP---- (2 January 2025 10:23:05) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.3-6895.image!


'From Cuis7.3 [latest update: #6895] on 6 December 2024 at 4:45:00 pm'!
!MorphicCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:24:28'!
          drawSquareCloseIcon
	"For Window control buttons"

	self subclassResponsibility.! !
!MorphicCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:34:36'!
drawSquareExpandIcon
	"For Window control buttons"

	self subclassResponsibility.! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 12/6/2024 16:33:50' overrides: 50331666!
  drawSquareCloseIcon
"make all colors be parameters!!!!!!!!!!"

	| c s size |
	(currentMorph isPressed or: [ currentMorph mouseIsOver ])
		ifFalse: [
			c := `Color r: 0.996 g: 0.329 b: 0.329`.
			s := `Color darkGray` ]
		ifTrue: [
			c := `(Color r: 0.996 g: 0.329 b: 0.329) * 0.85`.
			s := `Color black` ].

	size := currentMorph morphWidth.
	self strokeWidth: size/20.0 color: `Color gray` fillColor: c do: [
		self pathSequence: (self class windowSquareButtonPathData: size) ].

	self strokeWidth: (size/10.0 max: 1.0) color: s do: [
		self pathSequence: (self class windowButtonClosePathData: size) ].! !
!AbstractVectorCanvas methodsFor: 'drawing - icons' stamp: 'jmv 12/6/2024 16:38:27' overrides: 50331671!
                    drawSquareExpandIcon

	| c s size |
	(currentMorph isPressed or: [ currentMorph mouseIsOver ])
		ifFalse: [
			c := `Color r: 0.337 g: 0.604 b: 0.161`.
			s := `Color darkGray` ]
		ifTrue: [
			c := `(Color r: 0.337 g: 0.604 b: 0.161) * 0.85`.
			s := `Color black` ].

	size := currentMorph morphWidth.
	self strokeWidth: size/20.0 color: `Color gray` fillColor: c do: [
		self pathSequence: (self class windowSquareButtonPathData: size) ].

	self strokeWidth: (size/10.0 max: 1.0) color: s do: [
		self pathSequence: (self class windowButtonExpandPathData: size) ].! !
!AbstractVectorCanvas class methodsFor: 'literal path data' stamp: 'jmv 12/6/2024 16:33:29'!
        windowSquareButtonPathData: aSize
	| scale |
	(IconPathData at: #windowButtonSize ifAbsent: nil) = aSize ifTrue: [
		IconPathData at: #windowSquareButton ifPresent: [ :found | ^found ]].
	IconPathData at: #windowButtonSize put: aSize.
	scale := aSize / 22.0.
	^IconPathData at: #windowSquareButton put: (
		self scalePathData: `#[
			0.0 0 0
			1    0 20
			1    20 20
			1    20 0
			1    0 0
		] asFloat32Array` scale: scale)! !
!BitBltCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:25:24' overrides: 50331666!
                  drawSquareCloseIcon
	| icon |
	icon := self class windowButtonIcon: #squareCloseIcon size: currentMorph morphWidth.
	self pvtDrawButtonFaceForm: icon.! !
!BitBltCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:34:48' overrides: 50331671!
       drawSquareExpandIcon
	| icon |
	icon := self class windowButtonIcon: #squareExpandIcon size: currentMorph morphWidth.
	self pvtDrawButtonFaceForm: icon.! !
!HybridCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:24:35' overrides: 50331738!
     drawSquareCloseIcon
	vectorCanvas  drawSquareCloseIcon! !
!HybridCanvas methodsFor: 'drawing-icons' stamp: 'jmv 12/6/2024 16:34:54' overrides: 50331746!
       drawSquareExpandIcon
	vectorCanvas  drawSquareExpandIcon! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6896-SquareWindowIcons-JuanVuletich-2024Dec06-16h44m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6896] on 6 December 2024 at 7:45:28 pm'!
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 12/6/2024 19:44:09' prior: 16910500!
   displayLine: textLine textTopLeft: textTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"textTopLeft is relative to the morph currently being drawn"
	| stopCondition nowLeftInRun startIndex string lastPos tabBackColor |

	topLeft := textTopLeft.
	line := textLine.
	lineY := line top + textTopLeft y.
	rightMargin := line rightMargin + textTopLeft x.
	lastIndex := line first.
	tabCount := 0.
	leftInRun <= 0 ifTrue:
		[
			self setFont.
			self setStopConditions ].
	leftMargin := (line leftMarginForAlignment: alignment) + textTopLeft x.
	destX := leftMargin.
	destY := lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: 
			[ :ps |
			ps = paragraphStyle ifFalse: 
				[
					foregroundColor := defaultColor.
					self setActualFont: ps font.
					ps color ifNotNil: [ :color | self textColor: color ].
					alignment := ps alignment.
					paragraphStyle := ps.
					spaceWidth := font widthOf: Character space.
					self setStopConditions.
					text ifNotNil: [ destY := lineY + line baseline - font ascent ]]].
		self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.

	leftInRun <= 0
		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun := leftInRun].
	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount := 0.
	string := text string asUnicodeString.

	self placeEmbeddedObject.
	[
		startIndex := lastIndex.
		lastPos := destX@destY.
	
		stopCondition := self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions.
		backgroundColor ifNotNil: [
			"If this is not a #tab, update block nesting information. It it is a #tab, use it to draw background."
			stopCondition = #tab
				ifFalse:
				[ | indexForThisColor |
					
					(text hasShoutBackgroundColorAt: startIndex) ifTrue: [
						indexForThisColor := blockNestingStartX findFirst: [ :pair | pair second = backgroundColor ].
						indexForThisColor > 0
							ifTrue: [
								blockNestingStartX := blockNestingStartX first: indexForThisColor.
								(blockNestingStartX at: indexForThisColor) at: 1 put: (((blockNestingStartX at: indexForThisColor) at: 1) min: lastPos x)]
							ifFalse: [blockNestingStartX add: { lastPos x. backgroundColor }]]]
				ifTrue:
				[
					| indexForThisX |
					indexForThisX := blockNestingStartX findLast: [ :pair | pair first <= destX ].
					indexForThisX > 0 ifTrue: [ tabBackColor := (blockNestingStartX at: indexForThisX) second ].
					tabBackColor ifNotNil: [
						canvas
							fillRectangle: (destX @ lastPos y corner: self tabDestX @ (line bottom + textTopLeft y))
							color: tabBackColor ]].
			canvas
				fillRectangle: (lastPos corner: (startIndex > line last ifFalse: [ destX ] ifTrue: [ rightMargin ]) @ (line bottom + textTopLeft y))
				color: backgroundColor ].
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor ].
		"see setStopConditions for stopping conditions for displaying."
		(self perform: stopCondition) ifTrue: [
			"Number of characters remaining in the current run"
			^ runStopIndex - lastIndex ]
	] repeat! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6897-RectangularBlockHighlightFix-JuanVuletich-2024Dec06-19h43m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6897] on 8 December 2024 at 10:35:01 am'!
!Parser methodsFor: 'primitives' stamp: 'eem 12/8/2024 10:30:17' prior: 16921396!
                  externalType: descriptorClass
	"Parse an return an external type"
	| xType |
	(here == #'.' and: [hereType == #period and: [tokenType == #period]]) ifTrue:
		[[here == #'.'] whileTrue: [self advance].
		 ^descriptorClass punctuatorNamed: #'...'].
	xType := descriptorClass atomicTypeNamed: here.
	xType ifNil: "Look up from class scope"
		[Symbol
			hasInterned: here
			ifTrue:[:sym| xType := descriptorClass structTypeNamed: sym]].
	xType ifNil:
		["Raise an error if user is there"
		self interactive ifTrue:[^nil].
		"otherwise go over it silently"
		xType := descriptorClass forceTypeNamed: here].
	self advance.
	^(self matchToken: #*)
		ifTrue:[xType asPointerType]
		ifFalse:[xType]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6898-CuisCore-EliotEmilioMiranda-2024Dec08-09h56m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6898] on 9 December 2024 at 11:05:58 am'!
!BoxedFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 12/9/2024 11:04:30' overrides: 16864656!
                           cos
	"Answer the cosine of the receiver taken as an angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 150>
	^ super cos! !
!SmallFloat64 methodsFor: 'mathematical functions' stamp: 'jmv 12/9/2024 11:01:37' overrides: 16864656!
                       cos
	"Answer the cosine of the receiver taken as an angle in radians.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 560>
	^ super cos! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6899-UseNew-cos-primitives-JuanVuletich-2024Dec09-10h58m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:04:11 pm'!
!SequenceableCollection methodsFor: 'enumerating' stamp: 'HAW 10/29/2024 16:34:13'!
                              with: otherCollection allSatisfy: twoArgConditionBlock  
	
	self with: otherCollection do: [ :left :right | (twoArgConditionBlock value: left value: right) ifFalse: [ ^false ]].
	^true! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'HAW 10/30/2024 08:11:29'!
                with: otherCollection anySatisfy: twoArgConditionBlock 
	
	self with: otherCollection do: [ :left :right | (twoArgConditionBlock value: left value: right) ifTrue: [ ^true ]].
	^false! !
!SequenceableCollection class methodsFor: 'stream creation' stamp: 'HAW 10/28/2024 13:41:05'!
        writeStream
	
	^WriteStream on: self new! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6900-SequenceableCollection-enh-HernanWilkinson-2024Dec09-13h03m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:05:57 pm'!
!WeakMessageSend methodsFor: 'private' stamp: 'HAW 10/30/2024 08:25:06' prior: 17007109!
      isAnyArgumentGarbage
	"Make sure that my arguments haven't gone away"
	
	^arguments notNil and: [ arguments with: shouldBeNil anySatisfy: [ :arg :flag | flag not and: [arg isNil]]].
	
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6901-tweak-HernanWilkinson-2024Dec09-13h04m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:07:59 pm'!
!Interval methodsFor: 'testing' stamp: 'HAW 11/2/2024 10:50:17'!
   intersectsRange: rightRange
 
	^(self includes: rightRange first) 
		or: [ (self includes: rightRange last)
		or: [ rightRange includes: self first ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6902-Interval-enh-HernanWilkinson-2024Dec09-13h05m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:09:02 pm'!
!FileSystemEntry methodsFor: 'comparing' stamp: 'HAW 10/29/2024 16:40:50' prior: 16863764 overrides: 16915345!
                = aFileEntry
	| isCaseSensitive myDrive otherDrive theirs mine |

	self == aFileEntry ifTrue: [ ^ true ].
	self class == aFileEntry class ifFalse: [ ^false ].

	isCaseSensitive := self fileAccessor isCaseSensitive.

	"Check for drive nil or same."
	myDrive := self drive.
	otherDrive := aFileEntry drive.
	isCaseSensitive
		ifTrue: [ self drive = aFileEntry drive ifFalse: [ ^false ]]
		ifFalse: [
			myDrive isNil = otherDrive isNil ifFalse: [ ^false ].		"only one of them is nil"
			myDrive ifNotNil: [											"none is nil"
				(myDrive sameAs: otherDrive) ifFalse: [ ^false ]]].

	"Check for all path components same."
	mine := self pathComponents.
	theirs := aFileEntry pathComponents.

	isCaseSensitive ifTrue: [
		^mine = theirs ].

	mine size = theirs size ifFalse: [
		^false ].

	^mine 
		with: theirs 
		allSatisfy: [ :m :t | m sameAs: t ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6903-tweak-HernanWilkinson-2024Dec09-13h07m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6899] on 9 December 2024 at 1:17:25 pm'!

ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize nodeVisitedCounter methodNode selectionToKeep'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!classDefinition: #EquivalentNodesFinder category: #'Compiler-Support' stamp: 'Install-6904-ParseNodeEquivalence-HernanWilkinson-2024Dec09-13h09m-HAW.001.cs.st 1/2/2025 10:23:06'!
ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize nodeVisitedCounter methodNode selectionToKeep'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 11/2/2024 10:19:17'!
         methodNodeForLookingEquivalentNodes

	^ self methodNodeWithoutImplicitSelfReturn movingTemporariesDeclarationToBlock! !
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 10/30/2024 09:30:26'!
                            methodNodeWithoutImplicitSelfReturn
	
	^self methodNode withoutImplicitSelfReturn ! !
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 11/2/2024 10:12:37'!
                               sourceRangesOfNodesEquivalentTo: nodesToLookFor 
	
	^self sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: EquivalentNodesFinder noSelection! !
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 11/2/2024 19:25:36'!
                    sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: aSelectionToKeep
	
	^self methodNodeForLookingEquivalentNodes sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: aSelectionToKeep ! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 08:02:23'!
      areNodesOf: leftNodes equivalentTo: rightNodes

	^leftNodes size = rightNodes size and: [ 
		leftNodes with: rightNodes allSatisfy: [ :leftNode :rightNode | leftNode equivalentTo: rightNode ]]! !
!ParseNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 09:27:03'!
                         isImplicitSelfReturnIn: aMethodNode

	^false! !
!BlockNode methodsFor: 'initialization' stamp: 'HAW 10/30/2024 09:27:45'!
      removeImplicitSelfReturnWhenIn: aMethodNode 
	
	| potentiaImplicitSelfReturn |
	
	potentiaImplicitSelfReturn := statements lastIfEmpty: [ ^self ].
	(potentiaImplicitSelfReturn isImplicitSelfReturnIn: aMethodNode) ifTrue: [ statements removeLast ]
	! !
!BlockNode methodsFor: 'testing' stamp: 'HAW 10/31/2024 16:15:24'!
 declaresAnyVariable
	
	^temporariesDeclaration notNil and: [ temporariesDeclaration declaresAnyVariable]! !
!MethodNode methodsFor: 'converting' stamp: 'HAW 10/30/2024 09:22:34'!
             withoutImplicitSelfReturn
	
	block removeImplicitSelfReturnWhenIn: self.
	^self! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 10/29/2024 22:57:09'!
  calculateCompleteSourceRangesOf: nodes	
	
	| sourcesRanges firstNode lastNode interval |
	
	sourcesRanges := nodes collect: [:node | 	self completeSourceRanges at: node ifAbsent: [#()]].
	
	sourcesRanges size = 1 ifTrue: [ ^sourcesRanges first ].
	
	firstNode := sourcesRanges first.
	lastNode := sourcesRanges last.
	
	interval := SourceCodeInterval from: firstNode first first to: lastNode first last.
	
	^OrderedCollection with: interval

! !
!MethodNode methodsFor: 'source mapping' stamp: 'HAW 11/2/2024 19:56:44'!
                        sourceRangesOfNodesEquivalentTo: nodesToLookFor keepingSelection: aSelectionToKeep
	
	| finder |
	
	finder := EquivalentNodesFinder for: nodesToLookFor in: self keepingSelection: aSelectionToKeep.
	self accept: finder.

	^finder equivalentNodesRanges! !
!MethodNode methodsFor: 'initialization' stamp: 'HAW 11/2/2024 10:13:43'!
                        movingTemporariesDeclarationToBlock
	
	block temporariesDeclaration: temporariesDeclaration.
	self temporariesDeclaration: TemporariesDeclarationNode empty.
	
	^self ! !
!TemporariesDeclarationNode methodsFor: 'initialization' stamp: 'HAW 10/31/2024 18:34:37'!
                           withOutDeclarations: aTemporariesDeclarationToRemove

	tempDeclarationNodes := tempDeclarationNodes reject: [ :aTempDeclarationNode | 
		aTemporariesDeclarationToRemove declaresVariable: aTempDeclarationNode variableNode ]! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 10/31/2024 20:45:33'!
    addEquivalentNodesOf: blockStatements 

	| start stop |
	
	start := 1.
	
	[ stop := start + nodesToLookForSize - 1.
	stop <= blockStatements size ] whileTrue: [ 
		start := self 
			nextStartAfterAddingEquivalentNodesOf: blockStatements 
			from: start 
			to: stop ].
		
	! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 19:57:35'!
                  addToEquivalentsIfOneStatementEquivalentTo: aNode

	(self hasOneNodeToLookForAndEquivalentTo: aNode)
		ifTrue: [ equivalentNodesRanges add: (self completeSourceRangeOf: aNode) ].! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 20:04:10'!
                 areNodesToLookForEquivalentTo: nodesToCompareWith
 
	| equivalent |
	
	equivalent := nodesToLookFor 
		with: nodesToCompareWith 
		allSatisfy: [:leftNode :rightNode | leftNode equivalentTo: rightNode ].
		
	^equivalent and: [ self shouldKeepSelection not or: [ self selectionToKeepIsEqualOrHasNoIntersectionWith: nodesToCompareWith ]]	! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/4/2024 18:42:07'!
                    completeSourceRangeOf: aNode

	| sourceRangeIndex completeSourceRanges completeRange trimmedRange |
	
	sourceRangeIndex := nodeVisitedCounter occurrencesOf: aNode.
	sourceRangeIndex = 0 ifTrue: [ sourceRangeIndex := 1 ].
	
	"It should always find the completeSourceRanges of aNode and a range at the sourceRangeIndex - Hernan"
	completeSourceRanges := methodNode completeSourceRanges at: aNode.
	completeRange := completeSourceRanges at: sourceRangeIndex.
	
	"See ExtractMethodFinderTest>>test27FindsInsideParentesis - Hernan"
	trimmedRange := nodesToLookForSize = 1 
		ifTrue: [ completeRange trimToMatchExpressionOn: methodNode sourceText ]
		ifFalse: [ completeRange ].
	
	^trimmedRange! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 10/31/2024 21:14:49'!
                 completeSourceRangesOfAll: aCollectionOfNodes

	| firstRange lastRange |
	
	firstRange := self completeSourceRangeOf: aCollectionOfNodes first.
	lastRange := self completeSourceRangeOf: aCollectionOfNodes last.
	
	^SourceCodeInterval from: firstRange first to: lastRange last! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 10/29/2024 16:26:31'!
               hasOneNodeToLookForAndEquivalentTo: aNode

	^ nodesToLookForSize = 1 and: [ nodesToLookFor first equivalentTo: aNode ]! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 19:57:54'!
             nextStartAfterAddingEquivalentNodesOf: blockStatements from: start to: stop 
	
	| nodesToCompareWith nextStart |
	
	nodesToCompareWith := blockStatements copyFrom: start to: stop.
	
	nextStart := (self areNodesToLookForEquivalentTo: nodesToCompareWith) 
		ifTrue: [ 
			equivalentNodesRanges add: (self completeSourceRangesOfAll: nodesToCompareWith).
			stop + 1 ]
		ifFalse: [ 
			start + 1].
		
	^nextStart! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 20:04:10'!
           selectionToKeepIsEqualOrHasNoIntersectionWith: nodesToCompareWith 

	 | equivalentNodesSourceRanges | 

	equivalentNodesSourceRanges := self completeSourceRangesOfAll: nodesToCompareWith.
		
	^(selectionToKeep = equivalentNodesSourceRanges or: [ (selectionToKeep intersectsRange: equivalentNodesSourceRanges) not ])! !
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 11/2/2024 10:19:08'!
        shouldKeepSelection

	^selectionToKeep ~= self class noSelection ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 11/2/2024 20:12:04' overrides: 16920720!
                        visitBlockNode: blockNode

	| blockStatements |

	super visitBlockNode: blockNode.
	
	nodesToLookForSize > 1 ifTrue: [ 
		blockStatements := blockNode statements. 
		"I need to add temp declaration to statements becuase user could have selected the temp declaration
		See ExtractMethodFinderTest>>test22FindsTemporaryWhenSelectingDefinitionInInnerClosure - Hernan"
		blockNode declaresAnyVariable ifTrue: [ blockStatements addFirst: blockNode temporariesDeclaration ].
		self addEquivalentNodesOf: blockStatements ]
		! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:10' overrides: 16920728!
                  visitBraceNode: aBraceNode 
	
	nodeVisitedCounter add: aBraceNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aBraceNode.
	
	^super visitBraceNode: aBraceNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:22' overrides: 16920734!
                visitCascadeNode: aCascadeNode 

	self addToEquivalentsIfOneStatementEquivalentTo: aCascadeNode.

	 ^super visitCascadeNode: aCascadeNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:34' overrides: 16920741!
              visitInstanceVariableNode: anInstanceVariableNode 

	nodeVisitedCounter add: anInstanceVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: anInstanceVariableNode.

	^super visitInstanceVariableNode: anInstanceVariableNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:43' overrides: 16920745!
            visitLiteralNode: aLiteralNode

	nodeVisitedCounter add: aLiteralNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aLiteralNode.

	^super visitLiteralNode: aLiteralNode! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:50' overrides: 16920749!
        visitLiteralVariableNode: aLiteralVariableNode 
	
	nodeVisitedCounter add: aLiteralVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aLiteralVariableNode.
	
	^super visitLiteralVariableNode: aLiteralVariableNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/28/2024 15:46:23' overrides: 16920753!
                    visitMessageNode: aMessageNode

	self addToEquivalentsIfOneStatementEquivalentTo: aMessageNode.

	 ^super visitMessageNode: aMessageNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 10/31/2024 20:41:59' overrides: 16920795!
               visitTempVariableNode: aTempVariableNode 
	
	nodeVisitedCounter add: aTempVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aTempVariableNode.
	
	^super visitTempVariableNode: aTempVariableNode ! !
!EquivalentNodesFinder methodsFor: 'initialization' stamp: 'HAW 11/2/2024 19:55:28'!
                     initializeFor: aNodesToLookFor in: aMethodNode keepingSelection: aSelectionToKeep

	nodesToLookFor := aNodesToLookFor.
	methodNode := aMethodNode.
	selectionToKeep := aSelectionToKeep.
	
	nodesToLookForSize := nodesToLookFor size.
	nodeVisitedCounter := IdentityBag new.
	equivalentNodesRanges := OrderedCollection new.
	! !
!EquivalentNodesFinder methodsFor: 'ranges' stamp: 'HAW 11/2/2024 19:58:52'!
              equivalentNodesRanges
	
	^equivalentNodesRanges! !
!EquivalentNodesFinder class methodsFor: 'instance creation' stamp: 'HAW 11/2/2024 19:56:18'!
               for: aNodesToLookFor in: aMethodNode keepingSelection: aSelectionToKeep

	^ self new initializeFor: aNodesToLookFor in: aMethodNode keepingSelection: aSelectionToKeep! !
!EquivalentNodesFinder class methodsFor: 'instance creation' stamp: 'HAW 11/2/2024 10:17:37'!
                        noSelection
	
	^`0 to: 0`! !
!Behavior methodsFor: 'methods' stamp: 'HAW 10/30/2024 09:19:58'!
 methodNodeWithoutImplicitSelfReturnFor: aSourceCode

	^(self methodNodeFor: aSourceCode) withoutImplicitSelfReturn! !
!BraceNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:02:55' prior: 16797237!
                       hasEquivalentElementsTo: aBraceNode

	^self areNodesOf: elements equivalentTo: aBraceNode elements ! !
!CascadeNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 08:03:14' prior: 16802900!
    hasEquivalentMessagesWith: aCascadeNode

	^self areNodesOf: messages equivalentTo: aCascadeNode messages! !
!CodeNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:03:35' prior: 16823662!
  hasEquivalentArgumentsWith: aCodeNode

	^self areNodesOf: self arguments equivalentTo: aCodeNode arguments! !
!BlockNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:04:17' prior: 16795473!
                               hasEquivalentStatementsWith: aBlockNode

	^self areNodesOf: statements equivalentTo: aBlockNode statements! !
!MessageNode methodsFor: 'private' stamp: 'HAW 10/30/2024 08:05:44' prior: 16897480!
                             hasEquivalentArgumentsWith: aMessageNode

	^ self isCascade
		ifTrue: [ self areNodesOf: originalArguments equivalentTo: aMessageNode originalArguments ]
		ifFalse: [ self areNodesOf: arguments equivalentTo: aMessageNode arguments ]! !
!TemporariesDeclarationNode methodsFor: 'testing' stamp: 'HAW 10/30/2024 08:06:50' prior: 16976434!
                declaresSameVariablesThan: aTemporariesDeclarationNode

	^self areNodesOf: tempDeclarationNodes equivalentTo: aTemporariesDeclarationNode temporaryDeclarationNodes ! !
!TemporariesDeclarationNode methodsFor: 'testing' stamp: 'HAW 10/31/2024 18:35:34' prior: 16976449!
                    declaresVariable: aVariableNode

	^ tempDeclarationNodes anySatisfy: [ :tempDeclaration | tempDeclaration declaresVariable: aVariableNode ]! !
!ParseNodeVisitor methodsFor: 'visiting' stamp: 'HAW 10/31/2024 19:39:57' prior: 16920808!
                      visitTemporaryDeclarationNode: aTemporaryDeclarationNode

	^aTemporaryDeclarationNode variableNode accept: self! !

MessageNode removeSelector: #compare:with:!

!methodRemoval: MessageNode #compare:with: stamp: 'Install-6904-ParseNodeEquivalence-HernanWilkinson-2024Dec09-13h09m-HAW.001.cs.st 1/2/2025 10:23:06'!
compare: myArguments with: othersArguments

	myArguments size ~= othersArguments size ifTrue: [ ^ false ].

	myArguments with: othersArguments do: [ :myArgument :otherArgument |
		(myArgument equivalentTo: otherArgument) ifFalse: [ ^ false ] ].
	^ true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6904-ParseNodeEquivalence-HernanWilkinson-2024Dec09-13h09m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6904] on 9 December 2024 at 2:04:51 pm'!

Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract sizeToExtract findingStrategy nodesToExtract '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacementsFinder category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract sizeToExtract findingStrategy nodesToExtract'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Object subclass: #NodesInRangeFinder
	instanceVariableNames: 'range sourceMethod sourceMethodNode statements sourceRangeIndexByNode firstNodeFound lastNodeRange sourceCode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #NodesInRangeFinder category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
Object subclass: #NodesInRangeFinder
	instanceVariableNames: 'range sourceMethod sourceMethodNode statements sourceRangeIndexByNode firstNodeFound lastNodeRange sourceCode'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom callingExpression sendCollaboration '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacement category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom callingExpression sendCollaboration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 00:12:58'!
                 defineFindingStrategy
	
	| useStringEquality |
	
	"Sadly, finding the right ranges when extracting literal nodes is almost imposible becuase literal nodes can have many
	ranges. An alternative algorithm could be to create an 'expanded AST' without reused nodes and each node with its own
	source range. Nodes of that AST could be a polimorphic proxy of the real node, adding only the source range, something
	to try ...
	For the moment, if the selection to extract has only literal nodes, uses string comparison - Hernan"
	useStringEquality := nodesToExtract allSatisfy: [ :aNode | aNode isLiteralNode ].
	
	^useStringEquality 
		ifTrue: [ [ :aMethod | self findReplacementsUsingStringEqualityIn: aMethod ]]
		ifFalse: [ [ :aMethod | self findReplacementsUsingNodeEquivalenceIn: aMethod ]]! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 00:09:42'!
                           findReplacementInHierarchy

	sourceMethod methodClass withAllSubclassesDo: [ :aClass | self findReplacementsAt: aClass]! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/2/2024 20:15:03'!
                         findReplacementsUsingNodeEquivalenceIn: aMethod

	| rangesToExtract |
		
	rangesToExtract := sourceMethod compiledMethod = aMethod
		ifTrue: [  aMethod sourceRangesOfNodesEquivalentTo: nodesToExtract keepingSelection: intervalToExtract ]	
		ifFalse: [ aMethod sourceRangesOfNodesEquivalentTo: nodesToExtract ].
		
	rangesToExtract do: [ :sourceRangeToExtract | self addReplacementAt: sourceRangeToExtract in: aMethod ].! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/1/2024 15:58:34'!
             findReplacementsUsingStringEqualityIn: aMethod

	| sourceCode foundIntervalToExtract sourceCodeToExtractStart theSizeToExtract |
	
	sourceCode := aMethod sourceCode.
	theSizeToExtract := intervalToExtract size - 1.
	sourceCodeToExtractStart := 1.
	
	[ sourceCodeToExtractStart := sourceCode indexOfSubCollection: sourceCodeToExtract startingAt: sourceCodeToExtractStart.
	sourceCodeToExtractStart ~= 0 ] whileTrue: [ 
		foundIntervalToExtract := sourceCodeToExtractStart to: sourceCodeToExtractStart + theSizeToExtract.
		self addReplacementAt: foundIntervalToExtract in: aMethod.
		sourceCodeToExtractStart := foundIntervalToExtract last + 1 ] 
		
	 ! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/3/2024 17:36:58'!
     nodesToExtract

	^(NodesInRangeFinder in: sourceMethod for: intervalToExtract) value! !
!NodesInRangeFinder methodsFor: 'initialization' stamp: 'HAW 11/2/2024 20:33:48'!
                      initializeIn: aSourceMethod for: anIntervalToExtract 

	range := anIntervalToExtract.
	sourceMethod := aSourceMethod.
	! !
!NodesInRangeFinder methodsFor: 'evaluating' stamp: 'HAW 11/3/2024 23:48:20' overrides: 16915777!
   value
	
	| nodeAtLastPositionFound |

	"Because some nodes have many ranges, like the literal nodes, we count the time we pass by a node that is equivalent
	to the index in the source ranges collection. sourceRangeIndexByNode is used to count per node - Hernan"
	sourceMethodNode := sourceMethod methodNode.
	sourceCode := sourceMethod sourceCode.
	statements := OrderedCollection new.
	sourceRangeIndexByNode := IdentityBag new.
	firstNodeFound := false.

	sourceMethodNode nodesDo: [ :aNode | | nodeRange |
		sourceRangeIndexByNode add: aNode.
		nodeRange := self completeSourceRangeOf: aNode.
		nodeAtLastPositionFound := self ifInsideRangeAddToStatements: aNode locatedAt: nodeRange.
		nodeAtLastPositionFound ifTrue: [ ^statements ]].
			
	self error: 'nodes not found'
	! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:31:50'!
                            addToStatementsIf: aNode isAtStartingPositionWhenLocatedAt: nodeRange

	(self isFirstInRange: aNode locatedAt: nodeRange)
		ifTrue: [
			firstNodeFound := true.
			statements add: aNode.
			range last <= nodeRange last ifTrue: [ ^true ].
			lastNodeRange := nodeRange ].

	^false! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:35:32'!
             addToStatementsIf: aNode isInsideExtractionWhenLoacatedAt: nodeRange

	(self notSubNodeOfLastNode: nodeRange) ifTrue: [
		statements add: aNode.
		(self isAtEndPosition: nodeRange) ifTrue: [ ^true ].
		lastNodeRange := nodeRange.].
	
	^false! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 23:32:33'!
                   completeSourceRangeOf: aNode

	| nodeRange nodeRanges |
	
	"Some nodes do not have ranges at all like BlockNode - Hernan"
	nodeRanges := sourceMethodNode completeSourceRanges at: aNode ifAbsent: [ #() ].
	nodeRange := nodeRanges at: (sourceRangeIndexByNode occurrencesOf: aNode) ifAbsent: [ `0 to: 0` ].
	nodeRange := nodeRange asSourceCodeInterval trimToMatchExpressionOn: sourceCode.
	
	^nodeRange
		! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:31:50'!
                  ifInsideRangeAddToStatements: aNode locatedAt: nodeRange

	^ firstNodeFound
		ifTrue: [ self addToStatementsIf: aNode isInsideExtractionWhenLoacatedAt: nodeRange]
		ifFalse: [ self addToStatementsIf: aNode isAtStartingPositionWhenLocatedAt: nodeRange]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:35:32'!
         isAtEndPosition: nodeRange

	^ range last = nodeRange last! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 23:55:29'!
          isAtStartPosition: nodeRange

	^ range first <= nodeRange first! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:40:38'!
     isCascadeMessage: aNode insideRange: nodeRange

	^ aNode isCascadeNode and: [ range last + 2 = nodeRange last ]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:34:59'!
                     isFirstInRange: aNode locatedAt: nodeRange

	^(self isAtStartPosition: nodeRange) and: [ self isInsideRange: aNode locatedAt: nodeRange ]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 17:34:49'!
                           isInsideRange: aNode locatedAt: nodeRange

	^ range last >= nodeRange last or: [self isCascadeMessage: aNode insideRange: nodeRange]! !
!NodesInRangeFinder methodsFor: 'evaluating - private' stamp: 'HAW 11/3/2024 00:34:53'!
notSubNodeOfLastNode: nodeRange
	
	^lastNodeRange last < nodeRange first! !
!NodesInRangeFinder class methodsFor: 'instance creation' stamp: 'HAW 11/2/2024 20:34:06'!
                         in: aSourceMethod for: anIntervalToExtract 

	^self new initializeIn: aSourceMethod for: anIntervalToExtract ! !
!ExtractMethodReplacement methodsFor: 'initialization' stamp: 'HAW 11/4/2024 00:17:27'!
                       initializeSendCollaboration

	sendCollaboration := 'self ', self newMessageString.
	self shouldBeEnclosedWithParens ifTrue: [ sendCollaboration := '(' , sendCollaboration , ')' ]
		! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 11/1/2024 16:21:07' prior: 16958184!
        trimNoParentesisStartingWith: initialChar endingWith: endingChar on: aSourceCode

	| startOffset endOffset |

	startOffset := self trimmedOffsetFor: initialChar.
	endOffset := self trimmedOffsetFor: endingChar.
	^(startOffset = 1 or: [ endOffset = 1])
		ifTrue: [ (self trimLeft: startOffset right: endOffset) trimToMatchExpressionOn: aSourceCode ]
		ifFalse: [ self ]! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 00:18:06' prior: 16859277!
                createReplacementAt: foundIntervalToExtract in: aMethod
	
	^ExtractMethodReplacement 
		fromInterval: foundIntervalToExtract asSourceCodeInterval 
		of: aMethod asMethodReference 
		to: newMessage
		! !
!ExtractMethodReplacementsFinder methodsFor: 'private-replacement finding' stamp: 'HAW 11/4/2024 18:47:14' prior: 16859287!
                         findReplacementsAt: aClass

	"I live this implementationt instead of 
	
	aClass methodsDo: findingStrategy
	
	for debugging porpouses. We can do Through with this one - Hernan"
	aClass methodsDo: [ :aMethod | findingStrategy value: aMethod ]
	! !
!ExtractMethodReplacementsFinder methodsFor: 'evaluating' stamp: 'HAW 11/4/2024 00:08:21' prior: 16859363 overrides: 16915777!
          value

	sourceCodeToExtract := sourceMethod sourceCode copyFrom: intervalToExtract first to: intervalToExtract last.
	nodesToExtract := self nodesToExtract.
	replacements := OrderedCollection new.
	findingStrategy := self defineFindingStrategy.
	
	self findReplacementInHierarchy.! !
!ExtractMethodReplacement methodsFor: 'initialization' stamp: 'HAW 11/4/2024 00:16:58' prior: 16859106!
                            initializeFrom: anIntervalToExtract of: aMethodToExtractCodeFrom to: aNewMessage

	intervalToExtract := anIntervalToExtract.
	methodToExtractFrom := aMethodToExtractCodeFrom.
	newMessage := 	aNewMessage.
	self initializeSendCollaboration ! !
!ExtractMethodReplacement methodsFor: 'private - source code' stamp: 'HAW 11/4/2024 00:17:27' prior: 16859167!
                               updatedSourceCodeOfExistingMethod

	^ methodToExtractFrom sourceCode
		copyReplaceFrom: intervalToExtract first  
		to: intervalToExtract last 
		with: sendCollaboration! !
!ExtractMethodReplacement methodsFor: 'adjustment' stamp: 'HAW 11/4/2024 00:17:27' prior: 16859206!
               adjustmentForNextReplacement
	
	^sendCollaboration size - intervalToExtract size! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'private' stamp: 'HAW 11/2/2024 02:27:22' prior: 16958621!
                        initializeParseNodesMatchingSelectionInterval

	initialNodeAncestors := methodNode parseNodesPathAt: intervalToExtract first ifAbsent: [ self signalSourceCodeContainsAnInvalidExpressionError ].
	finalNodeAncestors := methodNode parseNodesPathAt: intervalToExtract last ifAbsent: [ self signalSourceCodeContainsAnInvalidExpressionError ].
	initialNode := initialNodeAncestors detect: [ :aNodeRange | aNodeRange key isCascadeNode ] ifNone: [ initialNodeAncestors first ].
	finalNode := finalNodeAncestors first! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'private' stamp: 'HAW 11/4/2024 00:30:46' prior: 16958638!
            intervalCoversCompleteAstNodes 

	^ (self trimmed: (SourceCodeInterval from: initialNode value first to: finalNode value last)) = intervalToExtract
		or: [ (initialNode value first to: (self trimmed: finalNode value) last) = intervalToExtract ]! !

ExtractMethodReplacement removeSelector: #initializeCallingExpression!

!methodRemoval: ExtractMethodReplacement #initializeCallingExpression stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
initializeCallingExpression

	callingExpression := 'self ', self newMessageString.
	self shouldBeEnclosedWithParens ifTrue: [ callingExpression := '(' , callingExpression , ')' ]
		!

ExtractMethodReplacementsFinder removeSelector: #findReplacementsIn:!

!methodRemoval: ExtractMethodReplacementsFinder #findReplacementsIn: stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
findReplacementsIn: aMethod

	| sourceCode foundIntervalToExtract sourceCodeToExtractStart |
	
	sourceCode := aMethod sourceCode.
	sourceCodeToExtractStart := 1.
	
	[ sourceCodeToExtractStart := sourceCode indexOfSubCollection: sourceCodeToExtract startingAt: sourceCodeToExtractStart.
	sourceCodeToExtractStart ~= 0 ] whileTrue: [ 
		foundIntervalToExtract := sourceCodeToExtractStart to: sourceCodeToExtractStart + sizeToExtract.
		self addReplacementAt: foundIntervalToExtract in: aMethod.
		sourceCodeToExtractStart := foundIntervalToExtract last + 1 ] 
		
	 !

Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract nodesToExtract findingStrategy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacementsFinder category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
Object subclass: #ExtractMethodReplacementsFinder
	instanceVariableNames: 'intervalToExtract sourceMethod replacements newMessage sourceCodeToExtract nodesToExtract findingStrategy'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom sendCollaboration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractMethodReplacement category: #'Tools-Refactoring' stamp: 'Install-6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st 1/2/2025 10:23:06'!
Refactoring subclass: #ExtractMethodReplacement
	instanceVariableNames: 'intervalToExtract newMessage methodToExtractFrom sendCollaboration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6905-ExtractMethodNodeEquivalence-HernanWilkinson-2024Dec09-14h02m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6905] on 9 December 2024 at 3:08:13 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6906-Interval-recategorize-HernanWilkinson-2024Dec09-15h03m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6906] on 9 December 2024 at 5:42:11 pm'!
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 12/9/2024 17:41:40' prior: 16965270!
       getCurrentWorkingDirectory
	"Answer the path from which Cuis was started.
	Smalltalk getCurrentWorkingDirectory
	(Note: Windows VM used to give a bogus answer. This was fixed in 2024.)
	"

	(self primGetCurrentWorkingDirectoryUnix ifNil: [ self primGetCurrentWorkingDirectoryWindows ]) ifNotNil:
		[ :utf8BytesInAStringInstance | | answer |
			"It seems on Mac, when dropping image on VM, we get '/', that is not really meaningful"
			(utf8BytesInAStringInstance = '/' and: [ self platformName = 'Mac OS' ]) ifFalse: [
				
				"Primitive answers an instance of String containing the UTF-8 bytes. If not pure ASCII,
				contents are invalid!! Convert it ASAP into a reasonable ByteArray + UnicodeString."
				answer := utf8BytesInAStringInstance.
				(String isAscii: answer) ifFalse: [
					ByteArray adoptInstance: answer.
					answer := UnicodeString fromUtf8Bytes: answer ].
				
				^ answer ]].

	"If we don't know better, answer nil. If appropriate, senders do:
		Smalltalk getCurrentWorkingDirectory ifNil: [ Smalltalk imagePath ]
	to have, at least, some valid directory
	"
	^ nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6907-getCurrentWorkingDirectory-primitiveFixedOnWindows-JuanVuletich-2024Dec09-17h40m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6907] on 10 December 2024 at 1:36:04 pm'!

Dictionary removeSelector: #valueAtNewKey:put:atIndex:declareFrom:!

!methodRemoval: Dictionary #valueAtNewKey:put:atIndex:declareFrom: stamp: 'Install-6908-Cleanup-JuanVuletich-2024Dec10-13h35m-jmv.001.cs.st 1/2/2025 10:23:06'!
valueAtNewKey: aKey put: anObject atIndex: index declareFrom: aDictionary 
	"Support for coordinating class variable and global declarations
	with variables that have been put in Undeclared so as to
	redirect all references to the undeclared variable."

	(aDictionary includesKey: aKey)
		ifTrue: 
			[self atNewIndex: index 
				put: ((aDictionary associationAt: aKey) value: anObject).
			aDictionary removeKey: aKey]
		ifFalse: 
			[self atNewIndex: index put: (Association key: aKey value: anObject)]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6908-Cleanup-JuanVuletich-2024Dec10-13h35m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6908] on 11 December 2024 at 10:54:30 am'!
!PluggableScrollPane methodsFor: 'access options' stamp: 'jmv 12/10/2024 17:36:50'!
                           alwaysHideHorizontalScrollbar

	hideScrollBars := #alwaysHideHorizontal.
	self hHideScrollBar.! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 12/11/2024 10:43:12' prior: 16926795!
                               hIsScrollbarNeeded
	"Return whether the horz scrollbar is needed"

	self mightNeedHorizontalScrollBar ifFalse: [ ^false ].
	
	"Don't show it if we were told not to."
	hideScrollBars = #hide ifTrue: [ ^false ].
	
	hideScrollBars = #alwaysHideHorizontal  ifTrue: [ ^false ].

	^self hLeftoverScrollRange > 0! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6909-PluggableScrollPane-hideHorizontalScrollbar-JuanVuletich-2024Dec11-10h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6908] on 11 December 2024 at 11:12:08 am'!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st 1/2/2025 10:23:06'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!
!FileListWindow methodsFor: 'updating' stamp: 'jmv 12/11/2024 11:11:04' overrides: 16972685!
               layoutSubmorphs
	super layoutSubmorphs.
	"We are acting as the model of fileListPane,
	and need it to update, as its items are custom built to available width."
	self changed: #fileList! !
!FileListWindow methodsFor: 'updating' stamp: 'jmv 12/11/2024 11:00:46' overrides: 16972660!
      update: aSymbol
	super update: aSymbol.
	aSymbol = #fileList ifTrue: [
		"We are acting as the model of fileListPane"
		self changed: #fileList ].! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:50:33'!
                     dateTimeStringFor: aFileEntry

	^(aFileEntry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			aFileEntry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:35:13'!
fileList
	"Answer the list of display strings for the files in the current volume."

	| list font maxDateWidth maxSizeWidth totalWidth |
	list := model fileList.
	totalWidth := fileListPane ifNotNil: [ :l | l viewableWidth ] ifNil: [200]. "Only during pane creation."
	font := Preferences at: #standardListFont.
	maxDateWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: (self dateTimeStringFor: fileEntry))].
	maxSizeWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: fileEntry fileSize printStringWithCommas)].
	^list collect:
		[ :fileEntry |
			self fileNameFormattedFor: fileEntry
				nameWidth: totalWidth - maxDateWidth - maxSizeWidth
				sizeWidth: maxSizeWidth ].! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:13:30'!
                   fileListIndex
	^model fileListIndex! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:13:38'!
    fileListIndex: i
	^model fileListIndex: i! !
!FileListWindow methodsFor: 'file list formatting' stamp: 'jmv 12/11/2024 10:06:59'!
                              fileNameFormattedFor: fileEntry nameWidth: nameWidth sizeWidth: sizeWidth

	| font dateTimeString nameString sizeString w columnSeparator columnSeparatorsWidth space spaceWidth c hairSpace hairSpaceWidth |
	font := Preferences at: #standardListFont.
	columnSeparator := '   '.
	columnSeparatorsWidth := (font widthOfString: columnSeparator) * 2.
	space := Character space asString.
	spaceWidth := font widthOfString: space.
	hairSpace := (Character codePoint: 16r200A) asString.
	hairSpaceWidth := font widthOfString: hairSpace.

	"Adjust file name string"
	nameString := fileEntry name.
	nameString := nameString.
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	"Truncate if too long"
	w > nameWidth ifTrue: [
		w := (font widthOfString: nameString, '...') + columnSeparatorsWidth.
		[ w > nameWidth and: [nameString notEmpty]] whileTrue: [
			nameString := nameString first: nameString size -1.
			w := (font widthOfString: nameString, '...') + columnSeparatorsWidth ].
		nameString := nameString, '...' ].
	"Pad with spaces and hairSpaces if too short"
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	w < (nameWidth-spaceWidth) ifTrue: [
		c := nameWidth-w // spaceWidth.
		c timesRepeat: [ nameString := nameString, space ]].
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	[ w < (nameWidth-hairSpaceWidth) ] whileTrue: [
		nameString := nameString, hairSpace.
		w := (font widthOfString: nameString) + columnSeparatorsWidth ].

	dateTimeString := self dateTimeStringFor: fileEntry.

	sizeString := fileEntry fileSize printStringWithCommas.
	"Pad with spaces and hairSpaces if too short"
	w := font widthOfString: sizeString.
	w < (sizeWidth-spaceWidth) ifTrue: [
		c := sizeWidth-w // spaceWidth.
		c timesRepeat: [ sizeString := space, sizeString ]].
	w := font widthOfString: sizeString.
	[ w < (sizeWidth-hairSpaceWidth) ] whileTrue: [
		sizeString := hairSpace, sizeString.
		w := font widthOfString: sizeString ].

	^nameString, columnSeparator, dateTimeString, columnSeparator, sizeString! !
!FileList methodsFor: 'file list' stamp: 'jmv 12/11/2024 10:32:14' prior: 16862394!
      fileList
	"Answer the list of files in the current volume."
	^list! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 12/11/2024 10:55:35' prior: 16863509!
                             morphicFileListPane

	^ fileListPane := (PluggableListMorph
		withModel: self
		listGetter: #fileList 
		indexGetter: #fileListIndex
		indexSetter: #fileListIndex: )
			menuNshortcutsKey: #fileListMenuSpec;
			alwaysHideHorizontalScrollbar.! !

FileList removeSelector: #fileNameFormattedFrom:namePad:sizePad:sizeWithCommasPad:!

!methodRemoval: FileList #fileNameFormattedFrom:namePad:sizePad:sizeWithCommasPad: stamp: 'Install-6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st 1/2/2025 10:23:06'!
fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font := Preferences at: #standardListFont.
	spaceWidth := font widthOf: $ .
	nameStr := entry isDirectoryEntry
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd := namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr := nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr := (entry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			entry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).
	sizeDigits := entry fileSize printString size.
	sizeStr := entry fileSize printStringWithCommas.
	sizeDigitsAndCommas := sizeStr size.
	spacesToAdd := sizeWithCommasPad - sizeDigitsAndCommas.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	(font widthOf: Character space) ~= (font widthOf: $, )
		ifTrue: [spacesToAdd := spacesToAdd + sizePad - sizeDigits max: 0].
	sizeStr := (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces := String new: 6 withAll: $ .
	"
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ].
	"
	^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' .!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st 1/2/2025 10:23:06'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6910-FileListWindow-nicerListOfFiles-JuanVuletich-2024Dec11-10h54m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6910] on 12 December 2024 at 2:05:26 pm'!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: 'fileListPane'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!
!FileList methodsFor: 'as yet unclassified' stamp: 'jmv 10/10/2024 11:34:24'!
                        fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font := Preferences at: #standardListFont.
	spaceWidth := font widthOf: $ .
	nameStr := entry isDirectoryEntry
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd := namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr := nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr := (entry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			entry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).
	sizeDigits := entry fileSize printString size.
	sizeStr := entry fileSize printStringWithCommas.
	sizeDigitsAndCommas := sizeStr size.
	spacesToAdd := sizeWithCommasPad - sizeDigitsAndCommas.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	(font widthOf: Character space) ~= (font widthOf: $, )
		ifTrue: [spacesToAdd := spacesToAdd + sizePad - sizeDigits max: 0].
	sizeStr := (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces := String new: 6 withAll: $ .
	"
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ].
	"
	^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' .! !
!FileList methodsFor: 'file list' stamp: 'jmv 11/21/2024 12:33:58' prior: 50333254!
              fileList
	"Answer the list of display strings for the files in the current volume."

	| font namePad sizePad sizeWithCommasPad |
	font := Preferences at: #standardListFont.
	namePad := list inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad := (list inject: 0 into: [ :mx :entry | mx max: entry fileSize]) printString size.
	sizeWithCommasPad := (list inject: 0 into: [ :mx :entry | mx max: entry fileSize]) printStringWithCommas size.
	^list collect: [ :e |
		self fileNameFormattedFrom: e
			namePad: namePad
			sizePad: sizePad
			sizeWithCommasPad: sizeWithCommasPad ].! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 6/4/2024 13:33:43' prior: 50333260!
    morphicFileListPane

	^(PluggableListMorph
		withModel: model 
		listGetter: #fileList 
		indexGetter: #fileListIndex
		indexSetter: #fileListIndex: )
			menuNshortcutsKey: #fileListMenuSpec.! !

FileListWindow removeSelector: #fileList!

!methodRemoval: FileListWindow #fileList stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
fileList
	"Answer the list of display strings for the files in the current volume."

	| list font maxDateWidth maxSizeWidth totalWidth |
	list := model fileList.
	totalWidth := fileListPane ifNotNil: [ :l | l viewableWidth ] ifNil: [200]. "Only during pane creation."
	font := Preferences at: #standardListFont.
	maxDateWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: (self dateTimeStringFor: fileEntry))].
	maxSizeWidth := list inject: 0 into:
		[ :prevMax :fileEntry |
			prevMax max: (font widthOfString: fileEntry fileSize printStringWithCommas)].
	^list collect:
		[ :fileEntry |
			self fileNameFormattedFor: fileEntry
				nameWidth: totalWidth - maxDateWidth - maxSizeWidth
				sizeWidth: maxSizeWidth ].!

FileListWindow removeSelector: #fileListIndex!

!methodRemoval: FileListWindow #fileListIndex stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
fileListIndex
	^model fileListIndex!

FileListWindow removeSelector: #fileListIndex:!

!methodRemoval: FileListWindow #fileListIndex: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
fileListIndex: i
	^model fileListIndex: i!

FileListWindow removeSelector: #update:!

!methodRemoval: FileListWindow #update: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
update: aSymbol
	super update: aSymbol.
	aSymbol = #fileList ifTrue: [
		"We are acting as the model of fileListPane"
		self changed: #fileList ].!

FileListWindow removeSelector: #layoutSubmorphs!

!methodRemoval: FileListWindow #layoutSubmorphs stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
layoutSubmorphs
	super layoutSubmorphs.
	"We are acting as the model of fileListPane,
	and need it to update, as its items are custom built to available width."
	self changed: #fileList!

FileListWindow removeSelector: #dateTimeStringFor:!

!methodRemoval: FileListWindow #dateTimeStringFor: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
dateTimeStringFor: aFileEntry

	^(aFileEntry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			aFileEntry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).!

FileListWindow removeSelector: #fileNameFormattedFor:nameWidth:sizeWidth:!

!methodRemoval: FileListWindow #fileNameFormattedFor:nameWidth:sizeWidth: stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
fileNameFormattedFor: fileEntry nameWidth: nameWidth sizeWidth: sizeWidth

	| font dateTimeString nameString sizeString w columnSeparator columnSeparatorsWidth space spaceWidth c hairSpace hairSpaceWidth |
	font := Preferences at: #standardListFont.
	columnSeparator := '   '.
	columnSeparatorsWidth := (font widthOfString: columnSeparator) * 2.
	space := Character space asString.
	spaceWidth := font widthOfString: space.
	hairSpace := (Character codePoint: 16r200A) asString.
	hairSpaceWidth := font widthOfString: hairSpace.

	"Adjust file name string"
	nameString := fileEntry name.
	nameString := nameString.
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	"Truncate if too long"
	w > nameWidth ifTrue: [
		w := (font widthOfString: nameString, '...') + columnSeparatorsWidth.
		[ w > nameWidth and: [nameString notEmpty]] whileTrue: [
			nameString := nameString first: nameString size -1.
			w := (font widthOfString: nameString, '...') + columnSeparatorsWidth ].
		nameString := nameString, '...' ].
	"Pad with spaces and hairSpaces if too short"
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	w < (nameWidth-spaceWidth) ifTrue: [
		c := nameWidth-w // spaceWidth.
		c timesRepeat: [ nameString := nameString, space ]].
	w := (font widthOfString: nameString) + columnSeparatorsWidth.
	[ w < (nameWidth-hairSpaceWidth) ] whileTrue: [
		nameString := nameString, hairSpace.
		w := (font widthOfString: nameString) + columnSeparatorsWidth ].

	dateTimeString := self dateTimeStringFor: fileEntry.

	sizeString := fileEntry fileSize printStringWithCommas.
	"Pad with spaces and hairSpaces if too short"
	w := font widthOfString: sizeString.
	w < (sizeWidth-spaceWidth) ifTrue: [
		c := sizeWidth-w // spaceWidth.
		c timesRepeat: [ sizeString := space, sizeString ]].
	w := font widthOfString: sizeString.
	[ w < (sizeWidth-hairSpaceWidth) ] whileTrue: [
		sizeString := hairSpace, sizeString.
		w := font widthOfString: sizeString ].

	^nameString, columnSeparator, dateTimeString, columnSeparator, sizeString!

SystemWindow subclass: #FileListWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

!classDefinition: #FileListWindow category: #'Morphic-Tool Windows' stamp: 'Install-6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st 1/2/2025 10:23:06'!
SystemWindow subclass: #FileListWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Tool Windows'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6911-TakeBack6910dueToSeriousSlowdown-JuanVuletich-2024Dec12-14h02m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6911] on 12 December 2024 at 3:49:02 pm'!
!Rectangle methodsFor: 'transforming' stamp: 'jmv 12/12/2024 15:46:55'!
                   newRect2From: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect aHand delay |
	delay := Delay forMilliseconds: 10.
	rect := self.
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	[Sensor isAnyButtonPressed] whileTrue: 
		[delay wait.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			Display border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			rect := newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 3/25/2024 11:43:34' prior: 16937717!
                           newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay := Delay forMilliseconds: 10.
	buttonStart := buttonNow := Sensor isAnyButtonPressed.
	rect := self.
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow := Sensor isAnyButtonPressed.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			Display border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			rect := newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!WindowEdgeAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 12/12/2024 15:47:53' prior: 17008207 overrides: 16890633!
    adjustOwnerAt: aGlobalPoint millisecondSinceLast: millisecondSinceLast

	self basicAdjustOwnerAt: aGlobalPoint.

	"If UI is becoming slow or is optimized for slow systems, resize without
	showing window contents, but only edges. But don't do it for rotated Windows!!"
	(owner isOrAnyOwnerIsRotated not and: [
		(Preferences at: #cheapWindowReframe) or: [millisecondSinceLast > 100]]) ifTrue: [
			owner displayBounds newRect2From: [ :f |
				self stopStepping.
				hand := nil.
				Cursor defaultCursor activateCursor.
				self basicAdjustOwnerAt: Sensor mousePoint.
				owner morphPosition extent: owner extentInWorld ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6912-WindowResizeTweak-JuanVuletich-2024Dec12-15h38m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6912] on 15 December 2024 at 7:04:31 pm'!
!HierarchyBrowserWindow class methodsFor: 'GUI building' stamp: 'KLG 12/12/2024 16:04:08' prior: 16875757!
                         onClass: aClass selector: aSymbol
	"Open a new full browser set to class.
	HierarchyBrowserWindow onClass: Morph selector: #submorphs
	HierarchyBrowserWindow onClass: Morph selector: nil
	"

	| newBrowser newBrowserWindow |
	newBrowser := HierarchyBrowser for: aClass selector: aSymbol.
	newBrowserWindow := self openNoSysCat: newBrowser label: newBrowser labelString.
	newBrowser assureSelectionsShow.
	^ newBrowserWindow! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6913-AnswerNewWindowInOnClassSelector-GeraldKlix-2024Dec15-19h03m-KLG.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 17 December 2024 at 9:26:21 am'!
!Object methodsFor: 'finalization' stamp: 'jmv 12/17/2024 09:12:41'!
                          toFinalizeSend: aSelector to: aFinalizer
	"When I am finalized (e.g., garbage collected) send aSelector to the appropriate finalizer (the guy who knows how to do any needed cleanup).
	WARNING: The finalizer is not allowed to reference me. If they do, then I will NEVER be garbage collected. Since this cannot be validated here, it is up to the client to make sure this invariant is not broken."
	self == aFinalizer ifTrue:[self error: 'I cannot finalize myself'].
	^self finalizationRegistry add: self executor:
		(ObjectFinalizer new
			receiver: aFinalizer
			selector: aSelector)! !
!ObjectFinalizer methodsFor: 'initialization' stamp: 'jmv 12/13/2024 14:36:37'!
      receiver: aReceiver selector: aSelector
	receiver := aReceiver.
	selector := aSelector.
	arguments := #()! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6914-Finalization-Convenience-JuanVuletich-2024Dec17-09h24m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6918] on 13 December 2024 at 12:22:43 pm'!
!WeakRegistry methodsFor: 'adding' stamp: 'jmv 12/13/2024 12:05:32' prior: 17007232 overrides: 16827586!
                        add: anObject
	"Add anObject to the receiver. Store the object as well as the associated executor."
	| executor |
	executor := anObject shallowCopy actAsExecutor.
	self protected:[
		valueDictionary at: anObject put: executor.
	].
	^anObject! !

UniFileStream removeSelector: #actAsExecutor!

!methodRemoval: UniFileStream #actAsExecutor stamp: 'Install-6915-WeakFinalization-Cleaup-JuanVuletich-2024Dec13-12h20m-jmv.001.cs.st 1/2/2025 10:23:06'!
actAsExecutor
	super actAsExecutor.
	name := nil.!

Object removeSelector: #executor!

!methodRemoval: Object #executor stamp: 'Install-6915-WeakFinalization-Cleaup-JuanVuletich-2024Dec13-12h20m-jmv.001.cs.st 1/2/2025 10:23:06'!
executor
	"Return an object which can act as executor for finalization of the receiver"
	^self shallowCopy actAsExecutor!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6915-WeakFinalization-Cleaup-JuanVuletich-2024Dec13-12h20m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6910] on 12 December 2024 at 9:23:17 am'!
!Dictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:19:05'!
            associationClass

	^Association! !
!WeakKeyDictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:19:24' overrides: 50333842!
                            associationClass

	^WeakKeyAssociation! !
!WeakValueDictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:19:43' overrides: 50333842!
                   associationClass

	^WeakValueAssociation! !
!Dictionary methodsFor: 'accessing' stamp: 'JMM 12/2/2024 09:54:17' prior: 16847449 overrides: 16915102!
           at: key put: anObject
	"Set the value at key to be anObject. 
	If key is not found, create a new entry for key and set is value to anObject.
	If key is found, update the existing association.
	Answer anObject."

	| index assoc |
	index := self findElementOrNil: key.
	assoc := array at: index.
	assoc
		ifNil: [ self atNewIndex: index put: (self associationClass key: key value: anObject) ]
		ifNotNil: [ assoc value: anObject ].
	^ anObject! !
!WeakKeyDictionary methodsFor: 'accessing' stamp: 'JMM 12/12/2024 09:08:53' prior: 17006854 overrides: 50333857!
                  at: key put: anObject 
	"Set the value at key to be anObject.  If key is not found, create a new
	entry for key and set is value to anObject. Answer anObject."
	
	key ifNil: [ ^anObject ].
	^super at: key put: anObject! !

WeakValueDictionary removeSelector: #at:put:!

!methodRemoval: WeakValueDictionary #at:put: stamp: 'Install-6916-Dictionary-Refactor-JohnMcIntosh-2024Dec12-09h22m-JMM.001.cs.st 1/2/2025 10:23:06'!
at: key put: anObject 
	"Set the value at key to be anObject.  If key is not found, create a new
	entry for key and set is value to anObject. Answer anObject."
	| index element |
	index := self findElementOrNil: key.
	element := array at: index.
	element
		ifNil: [self atNewIndex: index put: (WeakValueAssociation key: key value: anObject)]
		ifNotNil: [element value: anObject].
	^ anObject!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6916-Dictionary-Refactor-JohnMcIntosh-2024Dec12-09h22m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6910] on 12 December 2024 at 8:58:48 am'!
!Class methodsFor: 'subclass creation' stamp: 'eem 8/25/2015 16:37'!
 ephemeronSubclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 
	"This is the standard initialization message for creating a new class as a 
	subclass of an existing class (the receiver) in which the subclass is to 
	have ephemeron semantics, i.e. where the object will be queued for
	finalization when the key (first) inst var is not reachable other than through
	the other fields of ephemerons with unreachable keys."

	| answer |
	answer := ClassBuilder new
			superclass: self
			ephemeronSubclass: t
			instanceVariableNames: f
			classVariableNames: d
			poolDictionaries: s
			category: cat.
		
	Smalltalk
		logChange: answer definition 
		preamble: answer definitionPreamble.
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6917-Ephemeron-ClassCreationSupport-JohnMcIntosh-2024Dec12-08h57m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 12 December 2024 at 12:16:10 pm'!

IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronIdentityDictionary category: #'System-Finalization' stamp: 'Install-6918-Ephemeron-EphemeronIdentityDictionary-JohnMcIntosh-2024Dec12-12h13m-JMM.001.cs.st 1/2/2025 10:23:06'!
IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!
!EphemeronIdentityDictionary commentStamp: '<historical>' prior: 0!
              I am an identity dictionary holding only weakly on my keys.
When one of my keys is garbage collected, the key->value association is removed from the dictionary.

Internally I use Ephemeron objects that know myself as their container.
Ephemeron are implemented as ephemerons and get mourned when their key is only known from itself.
On mourn, the association asks the container to remove itself.!

Association ephemeronSubclass: #Ephemeron
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #Ephemeron category: #'System-Finalization' stamp: 'Install-6918-Ephemeron-EphemeronIdentityDictionary-JohnMcIntosh-2024Dec12-12h13m-JMM.001.cs.st 1/2/2025 10:23:06'!
Association ephemeronSubclass: #Ephemeron
	instanceVariableNames: 'container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!
!Ephemeron commentStamp: '<historical>' prior: 0!
           An Ephemeron is an association known to the garbage collection system, allowing it to function as a pre-mortem finalizer.

An Ephemeron is intended for uses such as associating an object's dependents with an object without preventing garbage collection.

Consider a traditional implementation of dependents in non-Model classes.  There is a Dictionary in Object, DependentsFields, into which objects wishing to have dependents are entered as keys, with the value being the sequence of their dependents.  Since a key's dependents (if they are like views/morphs, etc in MVC) will refer directly back to the key (e.g. in their model inst var etc), the key remains srongly referenced; there is no way to use weak collections in DependentsFields to allow the cycle of an object and its dependents to be collected.  If DependentsFields were to use a WeakArray to hold the associations from objects to their dependents then those associations, and the dependencies they record, would simply be lost since the only reference to the associations is from DependentsFields.

Ephemeron differs from a normal association in that it is known to the garbage collector and it is involved in tracing.  First, note that an Ephemeron is a *strong* referrer.  The objects it refers to cannot be garbage collected.  It is not weak.  But it is able to discover when it is the *only* reference to an object.  To be accurate, an Ephemeron is notified by the collector when its key is only referenced from the transitive closure of references from ephemerons.  i.e. when an ephemeron is notified we know that there are no reference paths to the ephemeron's key other than through ephemerons; the ephemeron's key is not otherwise reachable from the roots.

Ephemerons are notified by the garage collector placing them in a queue and signalling a semaphore for each element in the queue.  An image level process (the extended finalization process) extracts them from the queue and sends mourn to each ephemeron (since their keys are effectively dead).  What an Ephemeron does in response to the notification is programmable (one can add subclasses of Ephemeron).  But the default behaviour is to send finalize to the key, and then to remove itself from the dictionary it is in, allowing it and the transitive closure of objects reachable from it, to be collected in a subsequent garbage collection.

Implementation: both in scavenging, and in scan-mark, if an ephemeron is encountered its key is examined.  If the key is reachable from the roots (has already been scavenged, or is already marked), then the ephemeron marked and treated as an ordinary object. If the key is not yet known to be reachable the ephemeron is held in an internal queue of maybe triggerable ephemerons, and its objects are not traced.

At the end of the initial scavenge or scan-mark phase, this queue of triggerable ephemerons is examined.  All ephemerons in the list whose key is reachable are traced, and removed from the list.  i.e. what has happened was that their key was found reachable form the roots after they were added in the list (the garbage collector traces the object graph in an arbitrary order, typically breadth first in the scavenger, depth-dirst in teh scan-mark).  This then leaves the list populated only with ephemerons whose keys are as yet untraced, and hence only referenced from the ephemerons in the triggerable ephemeron queue, which now becomes the triggered ephemeron queue.  All these ephemerons are placed in the finalization queue for processing in the image above, and all objects reachable from these ephemerons are traced (scavenged, marked).  This tracing phase may encounter new potentially triggerable ephemerons which will be added to the triggerable ephemeron queue (not likely in practice, but essential for sound semantics).  So the triggering phase continues until the system reaches a fixed point with an empty triggerable ephemeron queue.

Implications and advantages:
Because ephemerons do not allow their object to be collected, they can be, and are, used to implement pre-mortem finalization.  So e.g. a file can flush its buffers and then close its file descriptor before being collected (which may also imply that the system runs the garbage collector *before* snapshotting, not as part of the snapshot primitive).  Ephemerons are conceptually more simple than WeakKeyDictionary et al, since they are about reference paths, not merely the existence of strong references.  They accurately identify when an object is no longer reachable from the roots, no matter how many ephemerons are attached to a specific object for whatever purpose.  Note that the back reference from a dependent to an object renders a weak key dictionary useless in enabling an isolated cycle to be collected since the back reference is string, and keeps the reference from the weak key alive.

History: Ephemerons are like guardians.  They were invented by George Bosworth in the early '90's, to provide pre-mortem finalization and to solve the problem of DependentsFields retaining garbage.

Instance Variables
	container 	<Dictionary|Set> - the container in which the Ephemeron resides.
!
!EphemeronIdentityDictionary methodsFor: 'accessing' stamp: 'JMM 12/6/2024 10:37:01' overrides: 50333842!
        associationClass
	^Ephemeron! !
!EphemeronIdentityDictionary methodsFor: 'adding' stamp: 'JMM 12/12/2024 10:05:22' overrides: 16847595!
                        add: anAssociation
	
	"Installs a copy of the association in myself.
	I cannot add the association because they are not shareable between weak key dictionaries, it needs myself as container.
	Moreover, I can only contain Ephemerons, and not other kinds of Association."
	self at: anAssociation key put: anAssociation value.

	^ anAssociation! !
!EphemeronIdentityDictionary methodsFor: 'private' stamp: 'JMM 12/2/2024 14:47:36' overrides: 16950510!
                               atNewIndex: index put: anEphemeron

	anEphemeron container: self.
	^super atNewIndex: index put: anEphemeron! !
!EphemeronIdentityDictionary methodsFor: 'copying' stamp: 'JMM 12/12/2024 10:02:44' overrides: 16847844!
       postCopy
	"Must copy the associations and tell them I (the copy) am their new container"

	array := array collect: [ :assoc |
		         assoc ifNotNil: [
			         assoc copy
				         container: self ] ]! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'JMM 12/2/2024 15:19:05'!
                 finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"
	
	self removeKey: anEphemeron key ifAbsent: [].
! !
!Ephemeron methodsFor: 'accessing' stamp: 'eem 10/1/2020 12:31'!
                             container
	"Answer the Dictionary containing the receiver, if any."
	^container! !
!Ephemeron methodsFor: 'accessing' stamp: 'eem 10/1/2020 12:33'!
            container: aDictionarySetOrNil
	"Set the Dictionary containing the receiver, or nil it."
	container := aDictionarySetOrNil! !
!Ephemeron methodsFor: 'testing' stamp: 'eem 9/1/2015 10:12'!
    isEphemeron
	^true! !
!Ephemeron methodsFor: 'mourning' stamp: 'JMM 12/9/2024 10:28:28'!
       mourn
	"Triggered ephemerons get sent mourn by EphemeronsFinalizationProcess class's finalizationProcess
	 (via mournLoopWith:) when the only reference(s) to an ephemeron's key is through
	 one or more ephemerons. i.e. the key is not reachable from the roots of the system,
	 only through ephemerons.  So ephemerons get sent mourn when their key would
	 otherwise have been garbage collected.  Respond to the information that the key
	 would have been garbage collected other than through ephemeron references by
	 sending finalize to the key."
	container finalizeEphemeron: self.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6918-Ephemeron-EphemeronIdentityDictionary-JohnMcIntosh-2024Dec12-12h13m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6917] on 12 December 2024 at 4:26:01 pm'!
!Object methodsFor: 'finalization' stamp: 'JMM 11/20/2024 17:29:59'!
                     mourn
	"Sent by the new Finalization mechanism.
	All weak objects (instances of weak classes) and Ephemerons may be mourned if they point to an object that needs to be collected.

	This default implementation does nothing. To override in specific subclasses."! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6919-Object-mourn-JohnMcIntosh-2024Dec12-16h24m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 12 December 2024 at 12:43:01 pm'!

Object subclass: #EphemeronFinalizationProcess
	instanceVariableNames: ''
	classVariableNames: 'FinalizationSemaphore TheFinalizationProcess'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronFinalizationProcess category: #'System-Finalization' stamp: 'Install-6920-EphemeronFinalizationProcess-JohnMcIntosh-2024Dec12-12h16m-JMM.001.cs.st 1/2/2025 10:23:06'!
Object subclass: #EphemeronFinalizationProcess
	instanceVariableNames: ''
	classVariableNames: 'FinalizationSemaphore TheFinalizationProcess'
	poolDictionaries: ''
	category: 'System-Finalization'!
!EphemeronFinalizationProcess commentStamp: 'jmv 12/12/2024 12:21:40' prior: 0!
                  I represent the finalization process that waits for finalization of objects and sends the #mourn message to then. I am registered to the startup to stop/start myself on each start.!
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 12/6/2024 12:16:29'!
                             doWeakFinalizationWork
	"Process the weak registries, in the old finalization style.  Hopefully this will
	 eventually go away when all clients have adopted the new finalization scheme."
	FinalizationLock
		critical:
			[FinalizationDependents do:
				[ :weakDependent |
				weakDependent ifNotNil:
					[weakDependent finalizeValues]]]
		ifError:
			[:msg :rcvr | rcvr error: msg]! !
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: 'jmv 12/12/2024 12:25:03'!
 finalizationProcess
	"The finalization process arranges to send mourn to each element of the VM's finalization queue,
	 which is accessed via primitiveFetchMourner.  The VM signals FinalizationSemaphore whenever
	 the queue is non-empty.  This process loops, waiting on the semaphore, fetches the first element
	 of the queue and then spawns a process at a higher priority to actually send the mourn messages.
	 If an error occurs in the higher priority mourn loop process then this process will simply spawn
	 another process, hence ensuring that errors in finalization methods don't break finalization.

	 In addition this process also runs the old finalization scheme, supporting clients of the older,
	 WeakRegistry based scheme.  Hopefully this will go away when all clients have moved over."
	| throttle firstMourner |
	throttle := Semaphore new.
	[true] whileTrue:
		[FinalizationSemaphore wait; initSignals.
		 "Support the old scheme until things have changed over..."
		 self doWeakFinalizationWork.
		
		 [firstMourner := self primitiveFetchMourner.
		  firstMourner notNil] whileTrue:
			[[throttle signal.
			  self mournLoopWith: firstMourner] forkAt: Processor activePriority + 1  named: '[system] Ephemeron Mourn processing'.
			  throttle wait]]! !
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: '9/24/2024 06:44'!
                        runningFinalizationProcess
	"Answer the FinalizationProcessNewEra I am running, if any"
	^TheFinalizationProcess! !
!EphemeronFinalizationProcess class methodsFor: 'class initialization' stamp: 'jmv 12/12/2024 12:38:36' overrides: 16917943!
               initialize
	"
	SystemDictionary initialize.
	WeakArray restartFinalizationProcess.
	EphemeronFinalizationProcess initialize.
	"

	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.! !
!EphemeronFinalizationProcess class methodsFor: 'private - mourning' stamp: 'JMM 12/12/2024 10:46:41'!
                     mournLoopWith: firstMourner
	"Send mourn to all the objects available in the mourn queue, starting
	 with firstMourner which the sender has already extracted for us.  If
	 an error occurs here, it will break this loop but the sender will spawn
	 another mournLoopWith: so that finalization is not broken by errors in
	 individual cases."
	| mourner |
	mourner := firstMourner.
	[mourner mourn.
	 (mourner := self primitiveFetchMourner) notNil] whileTrue! !
!EphemeronFinalizationProcess class methodsFor: 'private - mourning' stamp: '9/24/2024 06:44'!
                        primitiveFetchMourner
	"Answer the next mourner in the VM's queue of objects to be finalized.
	 The queue contains weak arrays and ephemerons.  If the primitive is
	 not implemented, raise an error telling people to upgrade the VM.  If
	 implemented, the primitive fails if the queue is empty, with the error
	 code #'not found'. Primitive.  Essential."

	<primitive: 172 error: ec>
	ec ifNil: [^self error: 'The primitiveFetchMourner primitive is missing.\Please upgrade your virtual machine to one that has the primitive.' withCRs].
	^nil! !
!EphemeronFinalizationProcess class methodsFor: 'system startup' stamp: '9/24/2024 06:44' overrides: 16789354!
                 startUp: resuming
	resuming ifFalse: [ ^self ].
	self restartFinalizationProcess! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 12/11/2024 12:38:56'!
               doWeakFinalizationWork
	" Fork off the old weak array processing logic" 
	
	[WeakArray doWeakFinalizationWork] forkAt: Processor activePriority + 2 named: '[system] Ephemeron WeakArray processing'! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 11/27/2024 09:48:11'!
                           restartFinalizationProcess
	"kill any old process, just in case"
	TheFinalizationProcess
		ifNotNil: [TheFinalizationProcess terminate.
			TheFinalizationProcess := nil].

	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.
	TheFinalizationProcess := [ self finalizationProcess ] newProcess.
	TheFinalizationProcess priority: Processor userInterruptPriority.
	TheFinalizationProcess name: '[system] Ephemeron finalization'.
	TheFinalizationProcess resume! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 11/20/2024 17:21:58'!
             stopFinalizationProcess
	"kill any old process, just in case"
	TheFinalizationProcess
		ifNotNil: [TheFinalizationProcess terminate.
			TheFinalizationProcess := nil].! !
!EphemeronFinalizationProcess class methodsFor: 'mourning' stamp: 'JMM 11/20/2024 17:24:21'!
                        theFinalizationProcess
	^TheFinalizationProcess! !
!WeakArray class methodsFor: 'services' stamp: 'JMM 11/29/2024 14:30:48' prior: 17006624!
                   ensureFinalizationComplete

	Smalltalk garbageCollect.
	Processor activePriority >= self finalizationProcess priority ifTrue: [
		"Not needed if the default priorities are used. Just in case."
		Processor activeProcess priority: self finalizationProcess priority-1.
		Processor yield ].! !
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 11/29/2024 14:30:21' prior: 17006579!
finalizationProcess
	"nothing here, moved to EphemeronFinalizationProcess class"
	^EphemeronFinalizationProcess theFinalizationProcess! !
!WeakArray class methodsFor: 'finalization' stamp: 'jmv 12/12/2024 12:39:21' prior: 17006597!
                        restartFinalizationProcess

	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.
	FinalizationProcess
		ifNotNil: [ 
			FinalizationProcess terminate.
			FinalizationProcess := nil ].
	FinalizationSemaphore := nil.
	EphemeronFinalizationProcess restartFinalizationProcess! !
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 11/27/2024 09:22:05' prior: 17006560!
   runningFinalizationProcess
	"Answer the FinalizationProcess I am running, if any"
	^EphemeronFinalizationProcess theFinalizationProcess! !
!WeakArray class methodsFor: 'finalization' stamp: 'JMM 11/27/2024 09:22:05' prior: 17006616!
                       stopFinalizationProcess
	"kill old process"
	EphemeronFinalizationProcess stopFinalizationProcess! !
!SystemDictionary class methodsFor: 'initialization' stamp: 'jmv 12/12/2024 12:36:48' prior: 16971714 overrides: 16917943!
initialize
	"
	SystemDictionary initialize
	"

	StartUpList := OrderedCollection new.
	"These get processed from the top down..."
	#(
		#Delay
		#DisplayScreen
		#Cursor
		#InputSensor
		#ProcessorScheduler 	"Starts low space watcher and bkground."
		#EphemeronFinalizationProcess)
			do: [ :clsName | 	
				Smalltalk at: clsName ifPresent: [:cls | Smalltalk addToStartUpList: cls]].
			
	ShutDownList := OrderedCollection new.
	"These get processed from the bottom up..."
	#(
		#Delay
		#DisplayScreen
		#InputSensor
		#ProcessBrowser
		#CPUWatcher)
			do: [ :clsName | 
				Smalltalk at: clsName ifPresent: [:cls | Smalltalk addToShutDownList: cls]]! !

WeakArray class removeSelector: #cleanupForEphemeronFinalizationProcess!

SystemDictionary initialize!

EphemeronFinalizationProcess initialize!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

	SystemDictionary initialize.
	WeakArray restartFinalizationProcess.
	EphemeronFinalizationProcess initialize.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6920-EphemeronFinalizationProcess-JohnMcIntosh-2024Dec12-12h16m-JMM.001.cs.st----!

'From Cuis7.3 [latest update: #6913] on 12 December 2024 at 12:57:17 pm'!

Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock FinalizationProcess FinalizationSemaphore '
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakArray category: #'Collections-Weak' stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock FinalizationProcess FinalizationSemaphore'
	poolDictionaries: ''
	category: 'Collections-Weak'!
!WeakArray class methodsFor: 'class initialization' stamp: 'jmv 12/12/2024 12:50:09' prior: 17006567 overrides: 16917943!
                  initialize
	"
	WeakArray initialize.
	"

	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.! !

WeakArray class removeSelector: #startUp!

!methodRemoval: WeakArray class #startUp stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
startUp
	"Do it even if just continuing after image snapshot"
	self restartFinalizationProcess!

WeakArray class removeSelector: #restartFinalizationProcess!

!methodRemoval: WeakArray class #restartFinalizationProcess stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
restartFinalizationProcess

	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.
	FinalizationProcess
		ifNotNil: [ 
			FinalizationProcess terminate.
			FinalizationProcess := nil ].
	FinalizationSemaphore := nil.
	EphemeronFinalizationProcess restartFinalizationProcess!

WeakArray class removeSelector: #pvtCreateTemporaryObjectIn:!

!methodRemoval: WeakArray class #pvtCreateTemporaryObjectIn: stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
pvtCreateTemporaryObjectIn: tempObject
	"We have to create the temporary object in a separate stack frame"
	tempObject at: 1 put: Object new!

WeakArray class removeSelector: #isFinalizationSupported!

!methodRemoval: WeakArray class #isFinalizationSupported stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
isFinalizationSupported
	"This method is only here for backwards compatibility, all closure VMs support finalization"
	
	^true!

Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock'
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakArray category: #'Collections-Weak' stamp: 'Install-6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st 1/2/2025 10:23:06'!
Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock'
	poolDictionaries: ''
	category: 'Collections-Weak'!

WeakArray initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6921-WeakArray-cleanup-JuanVuletich-2024Dec12-12h43m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6918] on 13 December 2024 at 12:18:56 pm'!

IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronIdentityDictionary category: #'System-Finalization' stamp: 'Install-6922-EphemeronIdentityDictionary-accessProtectFinalizeEphemeron-JuanVuletich-2024Dec13-12h14m-jmv.001.cs.st 1/2/2025 10:23:06'!
IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!
!EphemeronIdentityDictionary commentStamp: 'eem 10/1/2020 16:31' prior: 50333960!
                               An EphemeronIdentityDictionary is an identity dictionary that uses ephemerons for its associations, and hence is able to arrange that its keys are finalizable.  See Ephemeron's class comment.

Instance Variables
	mutex:		<Mutex>

mutex
	- an access protect that prevents the receiver getting corrupted as finalization occurs while lower priority processes are adding and/or rremoving ephemerons.
!
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:45:00' overrides: 16847372!
                       associationAt: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super associationAt: key ifAbsent: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:27:37' overrides: 16847399!
        at: key ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super at: key ifAbsent: absentBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:25:34' overrides: 16847430!
                    at: key ifPresent: presentBlock ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super at: key ifPresent: presentBlock ifAbsent: absentBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:25:23' overrides: 50333857!
    at: key put: anObject
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super at: key put: anObject ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:30:42' overrides: 16847741!
    collect: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super collect: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:30:32' overrides: 16847755!
                do: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super do: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:49:11' overrides: 16847515!
                          keys
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keys ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:31:01' overrides: 16847760!
      keysAndValuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keysAndValuesDo: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:26:43' overrides: 16847651!
keysAndValuesRemove: keyValueBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keysAndValuesRemove: keyValueBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:31:25' overrides: 16847766!
          keysDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super keysDo: aBlock].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:45:40' overrides: 16847851!
                   rehash
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super rehash ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:51:39' overrides: 16950658!
  removeAll
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super removeAll ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:26:30' overrides: 16847692!
                            removeKey: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super removeKey: key ifAbsent: aBlock ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:32:05' overrides: 16847773!
                select: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super select: aBlock].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:46:02' overrides: 16950444!
                   size
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super size ].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 12/13/2024 11:32:16' overrides: 16847786!
      valuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super valuesDo: aBlock].
	^ answer! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'jmv 12/13/2024 11:52:37'!
                finalizeValues
	"legacy systems might invoke this as it's an api on the old WeakRegistry"
	Smalltalk garbageCollect! !
!EphemeronIdentityDictionary methodsFor: 'initialize-release' stamp: 'eem 10/1/2020 10:50' overrides: 16950576!
                         init: n
	mutex := Mutex new.
	super init: n! !
!EphemeronIdentityDictionary methodsFor: 'copying' stamp: 'jmv 12/13/2024 11:15:20' prior: 50334182 overrides: 16847844!
                        postCopy
	"Must copy the associations and tell them I (the copy) am their new container"

	mutex critical:
	[
		array := array collect: 
		[ :assoc |
		         assoc ifNotNil:
				[
				        assoc copy container: self ] ] ]! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'jmv 12/13/2024 11:15:43' prior: 50334192!
               finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"

	mutex critical: [
		self removeKey: anEphemeron key ifAbsent: []].
! !

IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #EphemeronIdentityDictionary category: #'System-Finalization' stamp: 'Install-6922-EphemeronIdentityDictionary-accessProtectFinalizeEphemeron-JuanVuletich-2024Dec13-12h14m-jmv.001.cs.st 1/2/2025 10:23:06'!
IdentityDictionary subclass: #EphemeronIdentityDictionary
	instanceVariableNames: 'mutex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Finalization'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6922-EphemeronIdentityDictionary-accessProtectFinalizeEphemeron-JuanVuletich-2024Dec13-12h14m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6918] on 13 December 2024 at 12:20:51 pm'!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6923-FinalizationRegistry-JohnMcIntosh-JuanVuletich-2024Dec13-12h18m-jmv.001.cs.st 1/2/2025 10:23:06'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!
!FinalizationRegistry commentStamp: '<historical>' prior: 0!
     The default FinalizationRegistry holds objects that need finalization.

Objects added with the #add: message will simply be send #finalize before being collected.
For Objects added with the #add:executor: message, #finalize will be sent to the executor (an instance of ObjectFinalizer) instead.!
!FinalizationRegistry methodsFor: 'adding' stamp: 'jmv 12/13/2024 10:12:24' overrides: 50334160!
                       add: anObject
	"Add an object to be finalized."

	self at: anObject put: nil.! !
!FinalizationRegistry methodsFor: 'adding' stamp: 'jmv 12/13/2024 10:34:51'!
  add: anObject executor: anObjectFinalizer
	"Add an object to be finalized."

	self at: anObject put: anObjectFinalizer.! !
!FinalizationRegistry methodsFor: 'finalization' stamp: 'jmv 12/13/2024 11:16:28' overrides: 50334875!
                              finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"

	mutex critical: [

		self removeKey: anEphemeron key ifAbsent: [].

		"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
		Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value."
		(anEphemeron value ifNil: [ anEphemeron key ])
			finalize ].! !
!FinalizationRegistry class methodsFor: 'accessing' stamp: 'jmv 12/13/2024 11:37:31'!
          default
	^Default ifNil:[Default := self new]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6923-FinalizationRegistry-JohnMcIntosh-JuanVuletich-2024Dec13-12h18m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6924] on 16 December 2024 at 7:10:37 pm'!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler '
	classVariableNames: 'Default '
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6924-FlexibleFinalizationErrorHandling-JohnMcIntosh-JuanVuletich-2024Dec16-19h07m-jmv.001.cs.st 1/2/2025 10:23:06'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!
!FinalizationRegistry methodsFor: 'nil' stamp: 'JMM 12/13/2024 15:34:09' overrides: 50334858!
                  init: n
	super init: n.
	errorHandler := self.! !
!FinalizationRegistry methodsFor: 'accessing' stamp: 'JMM 12/13/2024 15:38:57'!
                              errorHandler: anErrorHandler 
	errorHandler := anErrorHandler! !
!FinalizationRegistry methodsFor: 'private - synchronization' stamp: 'jmv 12/16/2024 19:10:09'!
                               handleErrorsDuring: aBlock

	aBlock on: Error do:[:ex| ex return].! !
!FinalizationRegistry methodsFor: 'finalization' stamp: 'JMM 12/16/2024 08:49:42' prior: 50334954 overrides: 50334875!
   finalizeEphemeron: anEphemeron

	"Finalize the ephemeron finalizer and remove it from myself.
	Avoid errors during the finalization to let the finalization process proceed"

	mutex critical:
	[
	
		self removeKey: anEphemeron key ifAbsent: [].
		errorHandler handleErrorsDuring:
		[ 
			
			"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
			Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value."
			
			(anEphemeron value ifNil: [ anEphemeron key ])
				finalize ]].! !
!ObjectFinalizer methodsFor: 'finalization' stamp: 'JMM 12/16/2024 18:29:01' prior: 16918530 overrides: 16916076!
                        finalize
	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO guarantee that the resource associated with the receiver hasn't been freed already, so take care that you don't run into trouble - this all may happen with interrupt priority."

	receiver perform: selector withArguments: arguments! !

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6924-FlexibleFinalizationErrorHandling-JohnMcIntosh-JuanVuletich-2024Dec16-19h07m-jmv.001.cs.st 1/2/2025 10:23:06'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6924-FlexibleFinalizationErrorHandling-JohnMcIntosh-JuanVuletich-2024Dec16-19h07m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6925] on 16 December 2024 at 7:33:40 pm'!
!BlockClosure methodsFor: 'exceptions' stamp: 'jmv 12/16/2024 19:28:54'!
                      on: exception fork: handlerAction
	"Activate the receiver. In case of exception, fork a new process, which will handle an error.
	An original process will continue running as if receiver evaluation finished and answered nil,
	i.e., an expression like:

	[ self error: 'some error'] on: Error fork: [ :ex |  ex pass ]

	will always answer nil for original process, regardless of the forked block.

	The context stack , starting from context which sent this message to receiver and
	up to the top of the stack will be transferred to forked process, with handlerAction on top.
	(so when the forked process will be resuming, it will enter the handlerAction)
	 "

	^ self
		  on: exception
		  do: [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction valueWithPossibleArgument: ex ] ].

			  bottom := [ Processor activeProcess terminate ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction valueWithPossibleArgument: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ]! !
!FinalizationRegistry methodsFor: 'private - synchronization' stamp: 'jmv 12/16/2024 19:33:35' prior: 50335015!
    handleErrorsDuring: aBlock

	"The following code would silently swallow any errors during finalization.
	This was the behavior in Cuis WeakRegistry prior to December 2024.
	Such errors would likely remain unnoticed.
	At least, printing some warning to Transcript would be better."
	"aBlock on: Error do:[:ex| ex return]."

	"The following code will resume the finalization process, but would a debugger will open
	in a forked process, so finalization is not paused or stopped."
	aBlock on: Error fork: [ :e | e pass ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6925-ForkFinalizationErrors-DebuggingAid-JohnMcIntosh-JuanVuletich-2024Dec16-19h27m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6925] on 17 December 2024 at 10:39:08 am'!

"Change Set:		6926-CuisCore-AuthorName-2024Dec17-10h27m
Date:			17 December 2024
Author:			Juan Vuletich

<your descriptive text goes here>"
WeakRegistry default notEmpty ifTrue: [ self error: 'WeakRegistry default needs to be empty  to install further updates' ].!

Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock '
	classVariableNames: 'Default '
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakRegistry category: #'Collections-Weak' stamp: 'Install-6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st 1/2/2025 10:23:06'!
Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'Collections-Weak'!
!Object methodsFor: 'finalization' stamp: 'jmv 12/13/2024 12:04:39' prior: 16916070!
                             finalizationRegistry
	"Answer the finalization registry associated with the receiver."
	^FinalizationRegistry default! !

WeakRegistry class removeSelector: #default!

!methodRemoval: WeakRegistry class #default stamp: 'Install-6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st 1/2/2025 10:23:06'!
default
	^Default ifNil:[Default := self new]!

Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakRegistry category: #'Collections-Weak' stamp: 'Install-6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st 1/2/2025 10:23:06'!
Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6926-Use-EphemeronRegistry-byDefault-JuanVuletich-2024Dec17-10h27m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6926] on 18 December 2024 at 9:17:49 am'!
!FileList methodsFor: 'file list' stamp: 'eem 12/18/2024 09:15:55' prior: 50333436!
                             fileList
	"Answer the list of display strings for the files in the current volume."

	| font namePad sizePad sizeWithCommasPad |
	font := Preferences at: #standardListFont.
	namePad := list inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad := (list inject: 0 into: [ :mx :entry | entry fileSize ifNil: [mx] ifNotNil: [:fs| mx max: fs]]) printString size.
	sizeWithCommasPad := (list inject: 0 into: [ :mx :entry | mx max: entry fileSize]) printStringWithCommas size.
	^list collect: [ :e |
		self fileNameFormattedFrom: e
			namePad: namePad
			sizePad: sizePad
			sizeWithCommasPad: sizeWithCommasPad ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6927-FileList-fix-EliotEmilioMiranda-2024Dec18-09h15m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:23:02 pm'!
!SystemWindow methodsFor: 'open/close' stamp: 'eem 12/18/2024 11:22:52' prior: 16972922 overrides: 16923980!
       openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| frameRect |
	frameRect := self initialFrameIn: aWorld.
	self morphExtent: frameRect extent.
	aWorld addMorph: self position: frameRect topLeft.
	"Do it deferred. Was needed for text cursor to start blinking if (Preferences disable: #focusFollowsMouse).
	 For strange circumstances such as tests provoking errors, only activate windows that are still in world
	 by the time the action is actually ready to evaluate. "
	UISupervisor whenUIinSafeState:
		[ self isInWorld ifTrue:
			[ self activate ] ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6928-AllowDeletingJustCreatedWindows-EliotEmilioMiranda-2024Dec18-20h22m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:18:48 pm'!
!DebuggerWindow class methodsFor: 'services' stamp: 'eem 12/18/2024 11:12:07'!
                              closeAllDebuggersSuchThat: aBlock
	"DebuggerWindow closeAllDebuggers"

	UISupervisor ui ifNotNil:
		[ :world |
		world submorphsDo:
			[ :morph |
			((morph class == DebuggerWindow or: [morph class == PreDebugWindow ])
			 and: [aBlock value: morph])
				ifTrue: [morph delete ]]]! !
!DebuggerWindow class methodsFor: 'services' stamp: 'eem 12/18/2024 11:12:22' prior: 16845344!
     closeAllDebuggers
	"DebuggerWindow closeAllDebuggers"

	self closeAllDebuggersSuchThat: [:ign| true]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6929-closeDebuggersSuchThar-EliotEmilioMiranda-2024Dec18-20h18m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6929] on 18 December 2024 at 8:29:42 pm'!
!Ephemeron methodsFor: 'mourning' stamp: 'eem 12/18/2024 11:54:12' prior: 50334216 overrides: 50334245!
                           mourn
	"Triggered ephemerons get sent mourn by EphemeronsFinalizationProcess class's finalizationProcess
	 (via mournLoopWith:) when the only reference(s) to an ephemeron's key is through
	 one or more ephemerons. i.e. the key is not reachable from the roots of the system,
	 only through ephemerons.  So ephemerons get sent mourn when their key would
	 otherwise have been garbage collected.  Respond to the information that the key
	 would have been garbage collected other than through ephemeron references by
	 sending finalize to the key.

	 N.B. read #finalizeEphemeron: to understand why #finalize is not sent here."
	container finalizeEphemeron: self.! !
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: 'eem 12/18/2024 09:52:15' prior: 50334306!
                           finalizationProcess
	"The finalization process arranges to send mourn to each element of the VM's finalization queue,
	 which is accessed via primitiveFetchMourner.  The mourn queue contains Ephemerons whose
	 keys should be finalized. The VM signals FinalizationSemaphore whenever the queue is non-empty.
	 This process loops, waiting on the semaphore, fetches the first element of the queue and then
	 spawns a process at a higher priority to actually send the mourn messages. If an error occurs in
	 the higher priority mourn loop process then this process will simply spawn another process, hence
	 ensuring that errors in finalization methods don't break finalization.

	 In addition this process also runs the old finalization scheme, supporting clients of the older,
	 WeakRegistry based scheme.  This may go away if and when all clients have moved over."
	| throttle firstMourner |
	throttle := Semaphore new.
	[true] whileTrue:
		[FinalizationSemaphore wait; initSignals.
		 "Support the old scheme until things have changed over..."
		 self doWeakFinalizationWork.
		
		 [firstMourner := self primitiveFetchMourner.
		  firstMourner notNil] whileTrue:
			[[throttle signal.
			  self mournLoopWith: firstMourner] forkAt: Processor activePriority + 1  named: '[system] Ephemeron Mourning'.
			  throttle wait]]! !
!EphemeronFinalizationProcess class methodsFor: 'class initialization' stamp: 'eem 12/18/2024 11:08:48' prior: 50334357 overrides: 16917943!
        initialize
	"
	SystemDictionary initialize.
	EphemeronFinalizationProcess restartFinalizationProcess.
	EphemeronFinalizationProcess initialize.
	"

	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.! !

EphemeronFinalizationProcess initialize.
EphemeronFinalizationProcess restartFinalizationProcess!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6930-BetterCommentsAndProcessName-EliotEmilioMiranda-2024Dec18-20h29m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:18:11 pm'!
!Ephemeron commentStamp: 'eem 12/18/2024 10:26:19' prior: 50333990!
       An Ephemeron is an association known to the garbage collection system, allowing it to function as a "pre-mortem" finalizer, as opposed to "post-mortem" finalization.

Weak array based finalization schemes work by having a WeakArray of objects whose collection will be observed by a weak array element being nilled, and a parallel array of corresponding copies of the collectable objects. The corresponding object copy is finalized some time after the weakly referenced object is collected. This is known as post-mortem finalization and suffers the problem that the copy is finalized, not the original object. This requires effort to synchronize the original and the copy while avoiding strong references to the original, preventing its collection.

Unlike the weak scheme, ephemerons notice when their key is only referenced through ephemerons, consequenctly they can send #finalize to their key before their key is collected but when it is found to be collectable. So this finalizes the actual object with no need to maintain a copy, and is known as pre-mortem finalization.

Details:

An Ephemeron is intended for uses such as associating an object's dependents with an object without preventing garbage collection.

Consider a traditional implementation of a property table (for example, dependents in MVC).  There is a Dictionary in ActiveModel, ActionMaps, into which objects wishing to have dependents are entered as keys, with the value being the sequence of their dependents.  Since a key's dependents (if they are like views/morphs, etc in MVC) will refer directly back to the key (e.g. in their model inst var etc), the key remains srongly referenced; there is no way to use weak collections in DependentsFields to allow the cycle of an object and its dependents to be collected.  If ActionMaps were to use a WeakArray to hold the associations from objects to their dependents then those associations, and the dependencies they record, would simply be lost since the only reference to the associations is from ActionMaps.

Ephemeron differs from a normal association in that it is known to the garbage collector and it is involved in tracing.  First, note that an Ephemeron is a *strong* referrer.  The objects it refers to cannot be garbage collected.  It is not weak.  But it is able to discover when it is the *only* reference to an object.  To be accurate, an Ephemeron is notified by the collector when its key is only referenced from the transitive closure of references from ephemerons.  i.e. when an ephemeron is notified we know that there are no reference paths to the ephemeron's key other than through ephemerons; the ephemeron's key is not otherwise reachable from the roots.

Ephemerons are notified by the garage collector placing them in a queue and signalling a semaphore for each element in the queue.  An image level process (the extended finalization process) extracts them from the queue and sends mourn to each ephemeron (since their keys are effectively dead).  What an Ephemeron does in response to the notification is programmable (one can add subclasses of Ephemeron).  But the default behaviour is to send #finalize to the key, and then to remove itself from the dictionary it is in, allowing it and the transitive closure of objects reachable from it, to be collected in a subsequent garbage collection.

Implementation:

Both in scavenging, and in mark-sweep, if an ephemeron is encountered its key is examined.  If the key is reachable from the roots (has already been scavenged, or is already marked), then the ephemeron marked and treated as an ordinary object. If the key is not yet known to be reachable the ephemeron is held in an internal set of maybe triggerable ephemerons, and its objects are not traced.

At the end of the initial scavenge or mark-sweep phase, this set of triggerable ephemerons is examined.  All ephemerons in the set whose key is reachable are traced, and removed from the set.  i.e. what has happened was that their key was found reachable from the roots after they were added in set list (the garbage collector traces the object graph in an arbitrary order, typically breadth first in scavenging, depth-first in mark-sweep).  The set is then populated only with ephemerons whose keys are as yet untraced, and hence only referenced from the ephemerons in the set..  All these ephemerons are added to the finalization queue for processing in the image above, and all objects reachable from these ephemerons are traced (scavenged or marked).  This tracing phase may encounter new potentially triggerable ephemerons which will be added to the set (not likely in practice, but essential for sound semantics).  So the triggering phase continues until the system reaches a fixed point with an empty triggerable ephemeron set.

Implications and advantages:

Because ephemerons do not allow their object to be collected, they can be, and are, used to implement pre-mortem finalization.  So e.g. a file can flush its buffers and then close its file descriptor before being collected (which may also imply that the system runs the garbage collector *before* snapshotting, not as part of the snapshot primitive).  Ephemerons are conceptually more simple than WeakKeyDictionary et al, since they are about reference paths, not merely the existence of strong references.  They accurately identify when an object is no longer reachable from the roots, no matter how many ephemerons are attached to a specific object for whatever purpose.  Note that the back reference from a dependent to an object renders a weak key dictionary useless in enabling an isolated cycle to be collected since the back reference is string, and keeps the reference from the weak key alive.

History:

Ephemerons are like guardians.  They were invented by George Bosworth in the early '90's, to provide pre-mortem finalization and to solve the problem of DependentsFields retaining garbage in MVC.

Instance Variables
	container 	<Dictionary|Set> - the container in which the Ephemeron resides.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6931-Ephemeron-classComment-EliotEmilioMiranda-2024Dec18-20h15m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:22:43 pm'!
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:47:15' prior: 50334688 overrides: 16847372!
                    associationAt: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super associationAt: key ifAbsent: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:26:40' prior: 50334699 overrides: 16847399!
                            at: key ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super at: key ifAbsent: absentBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:09' prior: 50334710 overrides: 16847430!
        at: key ifPresent: presentBlock ifAbsent: absentBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super at: key ifPresent: presentBlock ifAbsent: absentBlock ]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:26' prior: 50334722 overrides: 50333857!
                       at: key put: anObject
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super at: key put: anObject]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:41' prior: 50334732 overrides: 16847741!
                        collect: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super collect: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:29:53' prior: 50334742 overrides: 16847755!
    do: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super do: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:30:09' prior: 50334752 overrides: 16847515!
              keys
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keys]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:30:50' prior: 50334761 overrides: 16847760!
                          keysAndValuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keysAndValuesDo: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:31:05' prior: 50334771 overrides: 16847651!
                    keysAndValuesRemove: keyValueBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keysAndValuesRemove: keyValueBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:31:51' prior: 50334782 overrides: 16847766!
                              keysDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super keysDo: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:32:07' prior: 50334792 overrides: 16847851!
      rehash
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super rehash]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:32:49' prior: 50334801 overrides: 16950658!
                      removeAll
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super removeAll]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:39:36' prior: 50334811 overrides: 16847692!
                removeKey: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super removeKey: key ifAbsent: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:44:56' prior: 50334822 overrides: 16847773!
    select: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super select: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:46:26' prior: 50334841 overrides: 16847786!
      valuesDo: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	^mutex critical: [super valuesDo: aBlock]! !
!EphemeronIdentityDictionary methodsFor: 'copying' stamp: 'eem 12/18/2024 12:07:19' prior: 50334864 overrides: 16847844!
                    postCopy
	"Must copy the associations and tell them I (the copy) am their new container"

	mutex := Mutex new.
	mutex critical:
		[array := array collect: 
			[ :assoc |
			assoc ifNotNil:
				[assoc copy container: self ] ] ]! !
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'eem 12/18/2024 11:55:20' prior: 50334875!
                finalizeEphemeron: anEphemeron

	"Remove the ephemeron from myself.  Note that no finalization of the ephemeron's key is done.
	 Here we are using ephemerons to clean up property tables."

	mutex critical:
		[self removeKey: anEphemeron key ifAbsent: []]! !

EphemeronIdentityDictionary removeSelector: #size!

!methodRemoval: EphemeronIdentityDictionary #size stamp: 'Install-6932-EphemeronIdentityDictionary-fixes-EliotEmilioMiranda-2024Dec18-20h18m-eem.001.cs.st 1/2/2025 10:23:07'!
size
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us."

	| answer |
	mutex critical: [
		answer := super size ].
	^ answer!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6932-EphemeronIdentityDictionary-fixes-EliotEmilioMiranda-2024Dec18-20h18m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6922] on 18 December 2024 at 8:25:45 pm'!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler '
	classVariableNames: 'Default '
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: 'errorHandler'
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!
!FinalizationRegistry methodsFor: 'finalization' stamp: 'eem 12/18/2024 12:02:18' prior: 50335021 overrides: 50335766!
                            finalizeEphemeron: anEphemeron
	"Finalize the ephemeron's key and remove the ephemeron from myself.
	 N.B. Here we send #finalize since finalization is called for by placing
	 objects in a FinalizationRegistry. i.e. the response to the ephemeron
	 being triggered is a property of the container of the phemeron, not
	 the ephemeron itself."

	self removeKey: anEphemeron key ifAbsent: [].
	
	"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
	 Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value.
	 N.B. errors here will not stall the finalization process."
	
	(anEphemeron value ifNil: [anEphemeron key]) finalize! !

BlockClosure removeSelector: #on:fork:!

!methodRemoval: BlockClosure #on:fork: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
on: exception fork: handlerAction
	"Activate the receiver. In case of exception, fork a new process, which will handle an error.
	An original process will continue running as if receiver evaluation finished and answered nil,
	i.e., an expression like:

	[ self error: 'some error'] on: Error fork: [ :ex |  ex pass ]

	will always answer nil for original process, regardless of the forked block.

	The context stack , starting from context which sent this message to receiver and
	up to the top of the stack will be transferred to forked process, with handlerAction on top.
	(so when the forked process will be resuming, it will enter the handlerAction)
	 "

	^ self
		  on: exception
		  do: [ :ex |
			  | onDoCtx handler bottom thisCtx |
			  onDoCtx := thisContext.
			  thisCtx := onDoCtx home.

			  "find the context on stack for which this method's is sender"

			  [ onDoCtx sender == thisCtx ] whileFalse: [
				  onDoCtx := onDoCtx sender.
				  onDoCtx ifNil: [ "Can't find our home context. seems like we're already forked
				and handling another exception in new thread. In this case, just pass it through handler."
					  ^ handlerAction valueWithPossibleArgument: ex ] ].

			  bottom := [ Processor activeProcess terminate ] asContext.
			  onDoCtx privSender: bottom.

			  handler := [ handlerAction valueWithPossibleArgument: ex ] asContext.
			  handler privSender: thisContext sender.

			  (Process forContext: handler priority: Processor activePriority) resume.

			  "cut the stack of current process"
			  thisContext privSender: thisCtx.
			  nil ]!

FinalizationRegistry removeSelector: #handleErrorsDuring:!

!methodRemoval: FinalizationRegistry #handleErrorsDuring: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
handleErrorsDuring: aBlock

	"The following code would silently swallow any errors during finalization.
	This was the behavior in Cuis WeakRegistry prior to December 2024.
	Such errors would likely remain unnoticed.
	At least, printing some warning to Transcript would be better."
	"aBlock on: Error do:[:ex| ex return]."

	"The following code will resume the finalization process, but would a debugger will open
	in a forked process, so finalization is not paused or stopped."
	aBlock on: Error fork: [ :e | e pass ].!

FinalizationRegistry removeSelector: #errorHandler:!

!methodRemoval: FinalizationRegistry #errorHandler: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
errorHandler: anErrorHandler 
	errorHandler := anErrorHandler!

FinalizationRegistry removeSelector: #init:!

!methodRemoval: FinalizationRegistry #init: stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
init: n
	super init: n.
	errorHandler := self.!

EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

!classDefinition: #FinalizationRegistry category: #'System-Finalization' stamp: 'Install-6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st 1/2/2025 10:23:07'!
EphemeronIdentityDictionary subclass: #FinalizationRegistry
	instanceVariableNames: ''
	classVariableNames: 'Default'
	poolDictionaries: ''
	category: 'System-Finalization'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6933-FinalizationRegistry-avoidDoubleErrorHandling-EliotEmilioMiranda-2024Dec18-20h23m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6933] on 19 December 2024 at 9:31:22 am'!
!ChangeSorterWindow methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 12/19/2024 09:30:56' prior: 16810086!
changeSetListMenuSpec
	"Spec for the menu and shortcut keys for the changesets list.
	See coment at Morph >> #getMenu
	"
	| answer |
	answer := #(
			#(0 		'Change Set' 						true)
			#(10 		'File out, start a new cs (o)' 			$o 	model 		fileOutAndRemove 				fileOutIcon)
			#(20 		'File out, keep current cs (k)' 			$k 	model 		fileOutAndKeep 				fileOutIcon)
			#(30 		'-----')
			#(40 		'Rename change set (R)' 				$R 	model 		rename 						saveAsIcon)
			#(50 		'Destroy change set (x)' 			 	$x 	model 		remove 						warningIcon)
	).
	model currentCanHavePreambleAndPostscript ifTrue: [
		model currentHasPreamble
			ifTrue: [ answer  := answer, #(
				#(60 	'-----')
				#(70 	'Edit preamble (p)' 					$p 	model 		addPreamble 					textEditorIcon)
				#(80 	'Remove preamble' 					nil 	model 		removePreamble 				listRemoveIcon)) ]
			ifFalse: [ answer  := answer, #(
				#(60 	'-----')
				#(70 	'Add preamble (p)' 					$p 	model 		addPreamble 					listAddIcon) )].
		model currentHasPostscript
			ifTrue: [ answer  := answer, #(
				#(90 	'Edit postscript...' 					nil 	model 		editPostscript 					textEditorIcon)
				#(100 	'Remove postscript' 					nil 	model 		removePostscript 				listRemoveIcon)) ]
			ifFalse: [ answer  := answer, #(
				#(90 	'Add postscript...' 					nil 	model 		editPostscript 					listAddIcon) )].
	].

	answer  := answer, #(
		#(110 			'-----')
		#(120 			'Conflicts with other change sets' 		nil 	window		browseMethodConflicts 		emblemImportantIcon
			'Browse all methods that occur both in this change set and in at least one other change set.')
		#(130 			'-----')
		#(140 			'Trim history' 						nil 	model		trimHistory 					clockIcon
			'Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.
 NOTE: can cause confusion if later filed in over an earlier version of these changes.')
		#(150 			'View affected class categories' 		nil 	model 		viewAffectedClassCategories	packageIcon
			'Show class categories affected by any contained change')
	).
	model csIsForBase ifFalse: [ "Maybe disable a few: Copy them the same as above, but without selector."
		answer := answer, #(
			#(40 		'Rename change set (R)' 				$R 	model 		nil 								saveAsIcon)
			#(50 		'Destroy change set (x)' 		 		$x 	model 		nil 								warningIcon)
			#(140 		'Trim history' 						nil 	model		nil 								clockIcon)) ].
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6934-twoHopefullyBetterMenuItemLabels-JuanVuletich-2024Dec19-09h29m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6933] on 19 December 2024 at 9:49:36 am'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
PreferenceSet installMiscPreferences!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6935-installMiscPreferences-JuanVuletich-2024Dec19-09h43m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6935] on 19 December 2024 at 1:45:57 pm'!
!ProtoObject methodsFor: 'system primitives' stamp: 'jmv 12/19/2024 13:42:07' prior: 16933901!
   become: otherObject 
	"Primitive. Swap the object pointers of the receiver and the argument.
	All variables in the entire system that used to point to the 
	receiver now point to the argument, and vice-versa.
	Fails if either object is a SmallInteger"

	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				| contextReceiver |
				contextReceiver := context receiver.
				(self == contextReceiver or: [ otherObject == contextReceiver ]) ifTrue: [
					| selector selfMethod otherObjectMethod |
					selector := context method selector.
					selfMethod := self class lookupSelector: selector.
					otherObjectMethod := otherObject class lookupSelector: selector.
					selfMethod = otherObjectMethod ifFalse: [
						| errorMessage |
						errorMessage := contextReceiver class name, ' has some instance running #', selector, 
							'. This CompiledMethod would become invalid.'.
						errorMessage print.
						MethodInCallStackToBecomeInvalid signal ifFalse: [
							'#become: aborted.' print.
							Error signal: errorMessage, ' #become: aborted. Please see Transcript.'.
							^nil ]]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsExchangeIdentityWith: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 12/19/2024 13:41:42' prior: 16916752!
     becomeForward: otherObject 
	"Primitive. All variables in the entire system that used to point
	to the receiver now point to the argument.
	Fails if either argument is a SmallInteger.

	Please see comment at #elementsForwardIdentityTo:
	"

	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				self == context receiver ifTrue: [
					| selector oldMethod newMethod |
					selector := context method selector.
					oldMethod := self class lookupSelector: selector.
					newMethod := otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						| errorMessage |
						errorMessage := self class name, ' has some instance running #', selector, 
							'. This CompiledMethod would become invalid.'.
						errorMessage print.
						MethodInCallStackToBecomeInvalid signal ifFalse: [
							'#becomeForward: aborted.' print.
							Error signal: errorMessage, ' #becomeForward: aborted. Please see Transcript.'.
							^nil ]]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsForwardIdentityTo: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 12/19/2024 13:41:53' prior: 16916790!
                      becomeForward: otherObject copyHash: copyHash
	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.
	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.
	Fails if either argument is a SmallInteger.

	Please see comment at #elementsForwardIdentityTo:copyHash:
	"

	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :proces :context |
				self == context receiver ifTrue: [
					| selector oldMethod newMethod |
					selector := context method selector.
					oldMethod := self class lookupSelector: selector.
					newMethod := otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						| errorMessage |
						errorMessage := self class name, ' has some instance running #', selector, 
							'. This CompiledMethod would become invalid.'.
						errorMessage print.
						MethodInCallStackToBecomeInvalid signal ifFalse: [
							'#becomeForward:copyHash: aborted.' print.
							Error signal: errorMessage, ' #becomeForward:copyHash: aborted. Please see Transcript.'.
							^nil ]]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self }
		elementsForwardIdentityTo: { otherObject }
		copyHash: copyHash! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:42:25' prior: 16827934!
                        collect: aBlock andFold: aTwoArgBlock ifEmpty: emptyBlockOrValue
	"Evaluate the block with the first two elements of the receiver,
	 then with the result of the first evaluation and the next element,
	 and so on.  Answer the result of the final evaluation. If the receiver
	 is empty, raise an error. If the receiver has a single element, answer
	 that element."
	"
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each ] andFold: [:a :b | a, ' ', b] ifEmpty:nil
	#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') collect: [ :each | each  size] andFold: [:a :b | a + b] ifEmpty: nil
	#() collect: [ :each | each ] andFold: [:a :b | a, ' ', b] ifEmpty:nil
	"

	| first answer |
	first := true.
	self do: [ :each |
		| eachValue |
		eachValue :=  aBlock value: each.
		first
			ifTrue: [
				first := false.
				answer := eachValue ]
			ifFalse: [
				answer := aTwoArgBlock
					value: answer
					value: eachValue ]].
	first ifTrue: [ answer := emptyBlockOrValue valueWithPossibleArgument: self ].
	^ answer! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:43:03' prior: 16828017!
                          detectMax: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the element for which aBlock evaluates to the highest magnitude.
	If collection empty, return nil.  This method might also be called elect:."

	| maxElement maxValue |
	self do: [ :each | 
		maxValue
			ifNil: ["first element"
				maxElement := each.
				maxValue := aBlock value: each]
				"Note that there is no way to get the first element that works 
				for all kinds of Collections.  Must test every one."
			ifNotNil: [
				| val |
				(val := aBlock value: each) > maxValue ifTrue: [
					maxElement := each.
					maxValue := val]]].
	^ maxElement! !
!Collection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:43:55' prior: 16828040!
                      detectMin: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Answer the element for which aBlock evaluates to the lowest number.
	If collection empty, return nil."

	| minElement minValue |
	self do: [:each | 
		minValue
			ifNil: ["first element"
				minElement := each.
				minValue := aBlock value: each]
				"Note that there is no way to get the first element that works 
				for all kinds of Collections.  Must test every one."
			ifNotNil: [
				| val |
				(val := aBlock value: each) < minValue ifTrue: [
					minElement := each.
					minValue := val]]].
	^ minElement! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:44:32' prior: 16949353!
                         groupsOf: n atATimeDo: aBlock 
	"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end.
	Allows use of a flattened 
	array for things that naturally group into groups of n.
	If aBlock has a single argument, pass it an array of n items,
	otherwise, pass the items as separate arguments.
	See also pairsDo:"
	| passArray |
	passArray := (aBlock numArgs = 1).
	n
		to: self size
		by: n
		do: [:index | 
			| args |
			args := (self copyFrom: index - n + 1 to: index) asArray.
			passArray ifTrue: [ aBlock value: args ]
				ifFalse: [ aBlock valueWithArguments: args ]].! !
!Array methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:44:46' prior: 16782585 overrides: 16827969!
                               collect: collectBlock thenSelect: selectBlock
	"Evaluate collectBlock with each my elements as the argument. Collect the 
	resulting values into a collection that is like me, but only those elements for which
	selectBlock evaluates to true. Answer the new collection.
	Overriden for performance."

	^ self species streamContents: [ :strm |
		1 to: self size do: [ :index |
			| newElement |
			newElement := collectBlock value: (self at: index).
			(selectBlock value: newElement)
				ifTrue: [ strm nextPut: newElement ]]]! !
!Array methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:45:00' prior: 16782604 overrides: 16828235!
          select: selectBlock thenCollect: collectBlock
	"Evaluate selectBlock with each my elements as the argument. For those who evaluate to true,
	collect the result of evaluating collectBlock on them into a collection that is like me.
	Answer the new collection.
	Overriden for performance."

	^ self species streamContents: [ :strm |
		1 to: self size do: [ :index |
			| each |
			each := self at: index.
			(selectBlock value: each) ifTrue: [
				strm nextPut: (collectBlock value: each) ]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6936-MoveTempsToInnerBlocks-JuanVuletich-2024Dec19-13h34m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6935] on 19 December 2024 at 2:05:04 pm'!
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:47:41' prior: 16812435!
       findAnySubStr: delimiters startingAt: start
	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."

	| min |
	min := self size + 1.
	delimiters do: [:delim |	"May be a char, a string of length 1, or a substring"
		| ind |
		ind := delim isCharacter
			ifTrue: [self indexOfSubCollection: (String with: delim) 
						startingAt: start ifAbsent: [min]]
			ifFalse: [self indexOfSubCollection: delim 
						startingAt: start ifAbsent: [min]].
		min := min min: ind].
	^ min! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:49:01' prior: 16812663!
             skipAnySubStr: delimiters startingAt: start 
	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."
	| ii |
	ii := start-1.
	[(ii := ii + 1) <= self size] whileTrue: [ "look for char that does not match"
		| any |
		any := false.
		delimiters do: [ :delim |
			delim isCharacter
				ifTrue: [ (self at: ii) = delim ifTrue: [any := true]]
				ifFalse: ["a substring"
					delim size > (self size - ii + 1) ifFalse: [
						| ind this |
						ind := 0.
						this := true.
						delim do: [ :dd | 
							dd = (self at: ii+ind) ifFalse: [this := false].
							ind := ind + 1].
						this ifTrue: [ii := ii + delim size - 1.  any := true]]
							ifTrue: [any := false] "if the delim is too big, it can't match"]].
		any ifFalse: [^ ii]].
	^ self size + 1! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:49:31' prior: 16812718!
                    subStrings: separators 
	"Answer an array containing the substrings in the receiver separated 
	by any of the elements of separators.
	Answer will not include empty strings
	'Hello World' subStrings: ' '
	'1Hello12World1This1211Are31Words1' subStrings: '123'
	'1Hello12World1This1211Are31Words1' subStrings: #($1 $2 $3)
	"

	| delimiterCharacters |
	delimiterCharacters := separators asArray.
	^Array streamContents: [ :answer |
		| out |
		out := self species writeStream.
		self do: [ :char |
			(delimiterCharacters identityIncludes: char)
				ifFalse: [ out nextPut: char ]
				ifTrue: [
					out isEmpty ifFalse: [
						answer nextPut: out contents.
						out := self species writeStream ]]].
		out isEmpty ifFalse: [
			answer nextPut: out contents ]].! !
!CharacterSequence methodsFor: 'accessing' stamp: 'jmv 12/19/2024 13:49:42' prior: 16812745!
        substringsSeparatedBy: delimiterCharacter
	"Find substrings delimited by aCharacter.
	Answer may include empty strings
	'0063;LATIN SMALL LETTER C;Ll;0;L;;;;;N;;;0043;;0043' substringsSeparatedBy: $;
	"

	^Array streamContents: [ :answer |
		| out |
		out := self species writeStream.
		self do: [ :char |
			char = delimiterCharacter
				ifFalse: [ out nextPut: char ]
				ifTrue: [
					answer nextPut: out contents.
					out := self species writeStream ]].
		answer nextPut: out contents.
		out := nil ].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:50:36' prior: 16813289!
   asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in |
	in := self readStream.
	^self species streamContents: [ :out |
		[ in atEnd ] whileFalse: [
			in peek = $<
				ifTrue: [in unCommand] 	"Absorb <...><...>"
				ifFalse: [
					| char |
					(char := in next) = $&
					ifTrue: [
						| rest did |
						rest := in upTo: $;.
						did := out position.
						rest = 'lt' ifTrue: [out nextPut: $<].
						rest = 'gt' ifTrue: [out nextPut: $>].
						rest = 'amp' ifTrue: [out nextPut: $&].
						rest = 'deg' ifTrue: [out nextPut: $¡].
						rest = 'quot' ifTrue: [out nextPut: $"].
						rest first = $# ifTrue: [ out nextPut: (Character codePoint: rest findPositiveInteger) ].
						did = out position ifTrue: [
							out nextPut: $&; nextPutAll: rest.
							"self error: 'unknown encoded HTML char'."
							"Please add it to this method"]]
					ifFalse: [out nextPut: char]].
			]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:11' prior: 16813625!
    keywords
	"Answer an array of the keywords that compose the receiver."
	| keywords |
	keywords := Array streamContents: [ :kwds |
		| kwd isAllValidInIdentifiers |
		kwd := self species writeStream.
		isAllValidInIdentifiers := true.
		1
			to: self size
			do: [ :i |
				| char |
				char := self at: i.
				kwd nextPut: char.
				char = $: & isAllValidInIdentifiers
					ifTrue: [
						kwds nextPut: kwd contents.
						kwd reset.
						isAllValidInIdentifiers := true ]
					ifFalse: [
						char isValidInIdentifiers ifFalse: [ isAllValidInIdentifiers := false ]]].
		kwd isEmpty ifFalse: [ kwds nextPut: kwd contents ]].
	
	^ keywords.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:31' prior: 16813768!
                            withBlanksCondensed
	"Return a copy of the receiver with leading/trailing blanks removed
	 and consecutive white spaces condensed as a single space."

	| trimmed |
	trimmed := self withBlanksTrimmed.
	^self species streamContents: [ :stream |
		| lastWasBlank |
		lastWasBlank := false.
		trimmed do: [ :c |
			c isSeparator
				ifTrue: [ lastWasBlank ifFalse: [ stream space ]]
				ifFalse: [ stream nextPut: c ].
			lastWasBlank := c isSeparator ]].

	"
	' abc  d   ' withBlanksCondensed
	' abc  d
	s
	as   zz 	q 			q' withBlanksCondensed
	"! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:42' prior: 16813831!
                               withDoubleColonsUndoubled
	"Do the inverse of #withDoubleColonsDoubled"

	^self species streamContents: [ :stream |
		| lastWasDoubleColon |
		lastWasDoubleColon := false.
		self do: [ :c |
			c = $"
				ifTrue: [
					lastWasDoubleColon
						ifFalse: [
							stream nextPut: c.
							lastWasDoubleColon := true ]
						ifTrue: [
							lastWasDoubleColon := false]]
				ifFalse: [
					stream nextPut: c.
					lastWasDoubleColon := false ]]].! !
!CharacterSequence methodsFor: 'private' stamp: 'jmv 12/19/2024 13:52:05' prior: 16814513!
   correctAgainstEnumerator: wordBlock continuedFrom: oldCollection
	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."

	| choices scoreMin results maxChoices |
	scoreMin := self size // 2 min: 3.
	maxChoices := 10.
	choices := oldCollection
		ifNil: [ SortedCollection sortBlock: [ :x :y | x value > y value ] ].
	wordBlock
		ifNil: [
			results := OrderedCollection new.
			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]
		ifNotNil: [
			wordBlock value: [ :word |
				| score |
				(score := self alike: word) >= scoreMin ifTrue: [
					choices add: (Association key: word value: score).
						(choices size >= maxChoices) ifTrue: [ scoreMin := (choices at: maxChoices) value] ] ].
			results := choices ].
	^ results! !
!CharacterSequence methodsFor: 'formatting' stamp: 'jmv 12/19/2024 13:52:18' prior: 16814573!
                      format: aCollection
	"format the receiver with aCollection  
	 
	simplest example:
	'foo {1} bar' format: {Date today}.
	 
	complete example:
	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}..
	"
	^self species streamContents: [ :out |
		| stream |
		stream := self readStream.
		[stream atEnd]
			whileFalse: [| currentChar | 
				currentChar := stream next.
				currentChar = ${
					ifTrue: [| expression | 
						expression := self getEnclosedExpressionFrom: stream.
						out nextPutAll: (self evaluateExpression: expression parameters: aCollection)]
					ifFalse: [
						currentChar = $\
							ifTrue: [stream atEnd ifFalse: [out nextPut: stream next]]
							ifFalse: [out nextPut: currentChar]]]].! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'jmv 12/19/2024 13:52:49' prior: 16814861 overrides: 16917720!
                        readFrom: inStream
	"Answer a new String that is determined by reading the stream, inStream.  Embedded
	double quotes become the quote Character."

	^self streamContents: [ :outStream |
		| done |
		"go to first quote"
		inStream skipTo: $'.
		done := false.
		[done or: [inStream atEnd]]
			whileFalse: 
				[ |char|
				char := inStream next.
				char = $'
					ifTrue: 
						[char := inStream next.
						char = $'
							ifTrue: [outStream nextPut: char]
							ifFalse: [done := true]]
					ifFalse: [outStream nextPut: char]]].! !
!Symbol methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:54:20' prior: 16962598!
                   numArgs: n
	"Answer a string that can be used as a selector with n arguments.
	 TODO: need to be extended to support shrinking and for selectors like #+ 
	
	Note: Unrelated, but remember that we inherit #numArgs " 

	| numArgs |
	(numArgs := self numArgs) >= n ifTrue: [ ^self ].	
	^ (self species streamContents: [ :strm |
		| offs |
		strm nextPutAll: self.
		(numArgs = 0) ifTrue: [ strm nextPutAll: ':'. offs := 0 ] ifFalse: [offs := 1].
		2 to: n - numArgs + offs do: [ :i | strm nextPutAll: 'with:' ]]) asSymbol! !
!UnicodeString methodsFor: 'enumerating' stamp: 'jmv 12/19/2024 13:57:10' prior: 16995179 overrides: 16949345!
        from: startIndex to: stopIndex do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex cpIndex |
	byteIndex := self byteIndexAt: startIndex.
	cpIndex := startIndex.
	[ cpIndex <= stopIndex ] whileTrue: [
		| n |
		n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (Character codePoint: codePoint).
			cpIndex := cpIndex + 1 ].
		byteIndex := byteIndex + n ].! !
!UnicodeString methodsFor: 'private' stamp: 'jmv 12/19/2024 13:57:44' prior: 16995410!
                            computeCountAndIndexFull
	| strideIndexClass |
	count := 0.
	strideIndexClass := bytes size < 256
		ifTrue: [ ByteArray ]
		ifFalse: [ bytes size < 65536
			ifTrue: [ DoubleByteArray ]
			ifFalse: [ bytes size < 4294967296
				ifTrue: [ WordArray ]
				ifFalse: [DoubleWordArray ]]].
	strideIndex := strideIndexClass streamContents: [ :out |
		| byteIndex |
		byteIndex := 1.
		[ byteIndex <= bytes size ] whileTrue: [
			count := count + 1.
			(count > self stride and: [ (count - 1 \\ self stride) = 0 ]) 
				ifTrue: [ out nextPut: byteIndex ].
			byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ] ]! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 12/19/2024 13:59:07' prior: 16995576!
               basicCanonicalComposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalComposition.
	(UnicodeString fromCodePoints: #(119128 119141)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119135 119151)) basicCanonicalComposition asCodePoints
	(UnicodeString fromCodePoints: #(119128 119141 119151)) basicCanonicalComposition asCodePoints
	"
	| byteIndex stopByteIndex combining |
	byteIndex := 1.
	stopByteIndex := bytes size.
	combining := OrderedCollection new.
	^self species streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			| n |
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				(Character combiningClass: codePoint) = 0 ifTrue: [
					self basicCompose: combining on: strm.
					combining := OrderedCollection new ].
				combining add: codePoint ].
			byteIndex := byteIndex + n ].
		self basicCompose: combining on: strm ].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 12/19/2024 13:59:22' prior: 16995612!
                          basicCanonicalDecomposition
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	See examples at #canonicalDecomposition.
	(Character codePoint: 119135) asString basicCanonicalDecomposition asCodePoints
	(Character codePoint: 119137) asString basicCanonicalDecomposition asCodePoints
	"
	| byteIndex stopByteIndex |
	byteIndex := 1.
	stopByteIndex := bytes size.
	^self species streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			| n |
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				Character canonicalDecomposition: codePoint on: strm ].
			byteIndex := byteIndex + n ]].! !
!UnicodeString methodsFor: 'Unicode normalization' stamp: 'jmv 12/19/2024 14:00:26' prior: 16995637!
                  basicCanonicallyOrdered
	"
	Usually prefer #canonicalComposition or #canonicalDecomposition
	https://unicode.org/reports/tr15/#Norm_Forms

	(UnicodeString fromCodePoints: #(16r61  16r0300 16r0315 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0300 16r031B 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r031B 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r0315 16r0300 16r031B)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0300 16r0315)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	(UnicodeString fromCodePoints: #(16r61  16r031B 16r0315 16r0300)) basicCanonicallyOrdered asCodePoints asArray collect: [ :e | e hex ]
	"
	| byteIndex stopByteIndex combining |
	byteIndex := 1.
	stopByteIndex := bytes size.
	combining := OrderedCollection new.
	^self species streamContents: [ :strm |
		[ byteIndex <= stopByteIndex ] whileTrue: [
			| n |
			n := Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
				| cls |
				cls := Character combiningClass: codePoint.
				cls = 0
					ifTrue: [
						combining notEmpty ifTrue: [
							combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
							combining do: [ :e | strm nextPutCodePoint: e third ]].
						strm nextPutCodePoint: codePoint.
						combining := OrderedCollection new ]
					ifFalse: [
						| element |
						element := { cls. combining size+1. codePoint }.
						combining add: element ]].
			byteIndex := byteIndex + n ].
		combining notEmpty ifTrue: [
			combining sort: [ :a :b | a first < b first or: [ a first = b first and: [a second < b second]] ].
			combining do: [ :e | strm nextPutCodePoint: e third ] ]].! !
!UnicodeString class methodsFor: 'instance creation' stamp: 'jmv 12/19/2024 14:02:07' prior: 16995863!
            fromBytesStream: aByteStream
	"Handle UTF-8 bytes, but convert invalid UTF-8 assuming it means ISO-8859-1.
	Argument can be, for example, a InflateStream."

	| utf8 codePointCount buffer readBytes leftover byteIndex |
	buffer := ByteArray new: 10000.
	leftover := nil.
	codePointCount := 0.
	utf8 := ByteArray streamContents: [ :utf8Stream |
		[aByteStream atEnd] whileFalse: [ 
			readBytes := aByteStream nextInto: buffer.
			leftover ifNotNil: [
				readBytes := leftover, readBytes.
				leftover := nil ].
			byteIndex := 1.
			[ byteIndex <= (aByteStream atEnd
						ifFalse: [readBytes size-3] "To be sure we don't break a possible partially read multibyte code point."
						ifTrue: [readBytes size])   						"But do taks _all_ the bytes if they are the last ones."
			] whileTrue: [
				| n |
				n := Character utf8BytesAndCodePointAt: byteIndex in: readBytes
					into: [ :byte1 :byte2 :byte3 :byte4 |
						utf8Stream nextPut: byte1.
						byte2 ifNotNil: [
							utf8Stream nextPut: byte2.
							byte3 ifNotNil: [
								utf8Stream nextPut: byte3.
								byte4 ifNotNil: [
									utf8Stream nextPut: byte4 ]]].
						codePointCount := codePointCount + 1]
					into: nil.
				byteIndex := byteIndex + n ].
			leftover := byteIndex > readBytes size ifFalse: [
				readBytes copyFrom: byteIndex to: readBytes size ].
		].
	].
	^self fromUtf8Bytes: utf8 codePointCount: codePointCount.! !
!UnicodeSymbol methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:54:35' prior: 16996633!
           numArgs: n
	"Answer a string that can be used as a selector with n arguments.
	 TODO: need to be extended to support shrinking and for selectors like #+ 
	
	Note: Unrelated, but remember that we inherit #numArgs " 

	| numArgs |
	(numArgs := self numArgs) >= n ifTrue: [ ^self ].	
	^ (self species streamContents: [ :strm |
		| offs |
		strm nextPutAll: self.
		(numArgs = 0) ifTrue: [ strm nextPutAll: ':'. offs := 0 ] ifFalse: [offs := 1].
		2 to: n - numArgs + offs do: [ :i | strm nextPutAll: 'with:' ]]) asSymbol.! !
!Text methodsFor: 'emphasis' stamp: 'jmv 12/19/2024 14:04:15' prior: 16979735!
       fontIfApplying: textAttributes default: defaultFont
	"Answer the font for characters as specified by the argument."

	self withAttributeValues: textAttributes do: [ :familyName :pointSize :emphasis :color :alignment :characterStyle :paragraphStyle :backgroundColor |
		| font |
		font := defaultFont ifNil: [FontFamily defaultFamilyAndPointSize].
		familyName notNil | pointSize notNil ifTrue: [
			| fn ps |
			fn := familyName ifNil: [ defaultFont familyName ].
			ps := pointSize ifNil: [ defaultFont pointSize ].
			(FontFamily familyName: fn pointSize: ps) ifNotNil: [ :f |
				font := f emphasized: defaultFont emphasis]].
		^font emphasized: (defaultFont emphasis bitOr: emphasis) ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6937-MoveTempsToInnerBlocks-JuanVuletich-2024Dec19-13h45m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6937] on 19 December 2024 at 3:56:36 pm'!
!ReferenceStream class methodsFor: 'as yet unclassified' stamp: 'jmv 12/19/2024 15:54:10' prior: 16939242!
                restoreFromFile: aFileEntry
"
 Note about importing String objects from Squeak: 
	
To make sure Strings can be moved from Squeak use 
           aString utf8Encoded 
to convert the strings to ByteArrays in Squeak before you export the object collection.

In Cuis you need to do then
           UnicodeString fromUtf8Bytes: aByteArray
to get them back.
"
	^aFileEntry readStreamDo: [ :stream |
		(self on: stream) next ].! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 12/19/2024 15:50:09' prior: 16870499!
                          fromFileEntry: aFileEntry
	"Read a Form or ColorForm from the given file."

	^aFileEntry readStreamDo: [ :stream |
		self fromBinaryStream: stream binary ]! !
!ChangeList class methodsFor: 'public access' stamp: 'jmv 12/19/2024 15:54:48' prior: 16804880!
 browsePackageContents: aFileEntry
	"Opens a changeList on a fileStream"
	| changeList packageFile |
	packageFile := CodePackageFile onFileEntry: aFileEntry.
	changeList := aFileEntry readStreamDo: [ :stream |
		self new scanFile: stream from: 0 to: stream size ].
	"Add deletions of methods and classes that are in the CodePackage (i.e., active in the system)
	but are no longer in the CodePackageFile being viewed."
	packageFile methodsToRemove do: [ :methodReference |
		changeList
			addItem: (MethodDeletionChangeRecord new methodReference: methodReference)
			text: 'method no longer in package: ', methodReference stringVersion ].
	packageFile classesToRemove do: [ :clsName |
		changeList
			addItem: (ClassDeletionChangeRecord new className: clsName)
			text: 'class no longer in package: ', clsName ].
	changeList clearSelections.
	ChangeListWindow open: changeList label: aFileEntry name! !
!FileEntry methodsFor: 'actions-file' stamp: 'jmv 12/19/2024 15:47:13' prior: 16861116!
   binaryContents
	^self readStreamDo: [ :stream |
		stream binary contents ].! !
!FileEntry methodsFor: 'actions-file' stamp: 'jmv 12/19/2024 15:48:35' prior: 16861179!
                         textContents
	^self readStreamDo: [ :stream |
		stream contents ].! !
!FileEntry methodsFor: 'accessing-stream' stamp: 'jmv 12/19/2024 15:51:26' prior: 16861214!
                              readStreamDo: blockWithArg 
	"Raise FileDoesNotExistException if not found."
	| stream |
	stream := self readStream.
	^ [ blockWithArg value: stream ]
		ensure: [
			stream
				ifNotNil: [ :s | s close ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6938-readStreamDo-andSenders-Optimize-JuanVuletich-2024Dec19-15h47m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 4:29:46 pm'!
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 12/20/2024 16:13:32' prior: 16827162!
                             methodInheritance
	"Create and schedule a method browser on the inheritance of implementors."

	| list aClassNonMeta isMeta aClass sel |
	aClass := model selectedClassOrMetaClass.
	sel := model selectedMessageName.
	aClass ifNil: [ ^ nil ].
	sel ifNil: [ ^ nil ].
	aClassNonMeta := aClass theNonMetaClass.
	isMeta := aClassNonMeta ~~ aClass.
	list := OrderedCollection new.
	aClass allSuperclasses reverseDo: [ :cl |
		(cl includesSelector: sel) ifTrue: [
			list addLast: (MethodReference class: cl selector: sel) ]].
	aClassNonMeta
		allSubclassesWithLevelDo: [ :cl :level |
			| theClassOrMeta |
			theClassOrMeta := isMeta
				ifTrue: [ cl class ]
				ifFalse: [ cl ].
			(theClassOrMeta includesSelector: sel) ifTrue: [
				list addLast: (MethodReference class: theClassOrMeta selector: sel) ]]
		startingLevel: 0.
	^ Smalltalk
		browseMessageList: list
		name: 'Implementors of ' , sel, ' in ', aClass name, ' and super / sub classes'.! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 12/20/2024 16:15:07' prior: 16932554!
           changePriority
	| rule |
	rule := (model class rulesFor: model selectedProcess) second.
	rule
		ifFalse: [self inform: 'Nope, won''t change priority of ' , model selectedProcess name.
			^ self].
	self request: 'New priority'
		initialAnswer: model selectedProcess priority printString
		verifying: [:aString| ([aString asNumber asInteger] on: Error do: []) isInteger]
		do: [ :aString |
			| newPriority |
			newPriority := aString asNumber asInteger.
			(newPriority between: 1 and: Processor highestPriority)
			ifTrue:
				[model class setProcess: model selectedProcess toPriority: newPriority.
				model updateProcessList]
			ifFalse: [self inform: 'Bad priority']]! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 12/20/2024 16:16:27' prior: 16881190 overrides: 16923705!
     adjustExtent
	"And reposition submorphs"
	| w y |
	"make all items wide, so selection indicator is wide too"
	w := self desiredWidth.
	y := 0.
	self submorphsDo: [ :m | | h |
		h := m morphHeight.
		m position: 0@y extent: w@h.
		y := y + h ].
	self morphExtent: w@y! !
!MorphicCanvas methodsFor: 'morphic world' stamp: 'jmv 12/20/2024 16:17:49' prior: 16909896!
                     drawRoots: rootMorphs rootsDamage: rootsDamage backgroundDamage: backgroundDamage
	"Redraw the damaged areas.
	Draw each morph just once, merging rectanges to be repaired as needed."
	"Iterate from back to front."

	| allDamage newDamageFromMorphsBelow |
	"Don't need a copy just because nobody will use it afterwards"
	newDamageFromMorphsBelow := backgroundDamage.
	allDamage := Rectangle merging: newDamageFromMorphsBelow.
	rootMorphs size to: 1 by: -1 do: [ :i | | morph morphDamage |
		morph := rootMorphs at: i.
		morphDamage := rootsDamage at: i.
		morph displayFullBounds ifNotNil: [ :morphFullBounds |
			newDamageFromMorphsBelow do: [ :r | | intersection |
				intersection := r intersect: morphFullBounds.
				intersection hasPositiveExtent ifTrue: [
					morphDamage
						ifNil: [ morphDamage :=  intersection ]
						ifNotNil: [ morphDamage updateMerging: intersection ]]]].
		morphDamage ifNotNil: [
			self newClipRect: morphDamage.
			self fullDraw: morph.
			newDamageFromMorphsBelow add: morphDamage.
			allDamage
				ifNil: [ allDamage := morphDamage copy ]
				ifNotNil: [ allDamage updateMerging: morphDamage ]]].
	^allDamage! !
!MorphicCanvas methodsFor: 'morphic world' stamp: 'jmv 12/20/2024 16:18:28' prior: 16910119!
     updateAllDamage: allDamage roots: rootMorphs rootsDamage: rootsDamage backgroundDamage: backgroundDamage
	"Detect any morph whose damage would grow because of morphs beneath it.
	If one found, add the new larger damage to allDamage and exit.
	See sender."
	"Iterate from back to front."

	| newDamageFromMorphsBelow |
	newDamageFromMorphsBelow := backgroundDamage copy.
	rootMorphs size to: 1 by: -1 do: [ :i |
		| morph morphPreviousDamage morphDamage |
		morph := rootMorphs at: i.
		morphPreviousDamage := rootsDamage at: i.
		morphDamage := morphPreviousDamage copy.
		morph displayFullBounds ifNotNil: [ :morphFullBounds |
			newDamageFromMorphsBelow do: [ :r | | intersection |
				intersection := r intersect: morphFullBounds.
				intersection hasPositiveExtent ifTrue: [
					morphDamage
						ifNil: [ morphDamage :=  intersection ]
						ifNotNil: [ morphDamage updateMerging: intersection ]]]].
		morphDamage ifNotNil: [
			newDamageFromMorphsBelow add: morphDamage ].
		morphDamage = morphPreviousDamage ifFalse: [
			allDamage add: morphDamage.
			^true 	]].
	^false! !
!AbstractVectorCanvas class methodsFor: 'private' stamp: 'jmv 12/20/2024 16:19:33' prior: 16779308!
 scalePathData: aFloat32Array scale: scale
	"aFloatArray is a #pathSequence: argument. It encodes a sequence of path commands in a Float32Array.
	See #pathSequence:"

	^Float32Array streamContents: [ :scaledStrm | | unscaledStrm kind |
		unscaledStrm := aFloat32Array readStream.
		[ unscaledStrm atEnd ] whileFalse: [
			kind := unscaledStrm next.
			scaledStrm nextPut: kind.
			(kind asInteger *2 max: 2) timesRepeat: [
				scaledStrm nextPut: unscaledStrm next * scale ]]
		].! !
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 12/19/2024 12:41:19' prior: 16999569!
              image: aForm multipliedBy: aColor at: aPoint
	"Multiply aForm and aColor, then blend over destination.
	aForm is a kind of advanced stencil, supplying brightness and opacity at each pixel

	(BitBltCanvas onForm: Display) image: ((Form dotOfSize: 50) asFormOfDepth: 32) multipliedBy: Color red at: 20@20. Display forceToScreen
	"
	aColor isTransparent ifFalse: [
		BitBltCanvas accessProtect critical: [ | f |
			f := BitBltCanvas buildAuxWith: aForm multipliedWith: aColor.
			self image: f at: aPoint sourceRect: aForm boundingBox ]]! !
!VectorEngineBoundsFinder methodsFor: 'primitive algorithms' stamp: 'jmv 12/20/2024 16:25:41' prior: 17001354!
                       arcCenterX: cx centerY: cy radiusX: rx radiusY: ry start: startAngle sweep: sweepAngle rotationCos: thetaCos rotationSin: thetaSin

	| dx dy trx try tcx tcy center angle d hops |
	dx := geometryTransformation externalizeDelta: rx@0.
	dy := geometryTransformation externalizeDelta: 0@ry.
	trx := dx r.
	try := dy r.
	hops := ((trx max: try) * sweepAngle abs / hop) truncated + 2.
	d := sweepAngle / hops.
	center := geometryTransformation externalizePosition: cx@cy.
	tcx := center x.
	tcy := center y.
	(trx = try and: [
		d * hops > 6.28]) ifTrue: [ 	"If a circle, not an ellipse, and a complete circle, or pretty close"
			spanLeft := spanLeft min: tcx - trx.
			spanRight := spanRight max: tcx + trx.
			spanTop := spanTop min: tcy - trx.
			spanBottom := spanBottom max: tcy + trx ]

		ifFalse: [						"Else go the more expensive way"
			angle := startAngle.
			hops := hops+1.
			hops timesRepeat: [
				| x xp y yp |
				xp := angle cos * trx.
				yp := angle sin * try.
				x := thetaCos * xp - (thetaSin * yp) + tcx.
				y := thetaSin * xp + (thetaCos * yp) + tcy.
				spanLeft := spanLeft min: x.
				spanRight := spanRight max: x.
				spanTop := spanTop min: y.
				spanBottom := spanBottom max: y.
				angle := angle + d. ]].! !
!VectorEngineSmalltalk methodsFor: 'primitive algorithms' stamp: 'jmv 9/15/2021 14:47:40' prior: 17002101!
                             arcCenterX: cx centerY: cy radiusX: rx radiusY: ry start: startAngle sweep: sweepAngle rotationCos: thetaCos rotationSin: thetaSin

	| dx dy trx try tcx tcy center angle xp yp x y d hops |
	dx := geometryTransformation externalizeDelta: rx@0.
	dy := geometryTransformation externalizeDelta: 0@ry.
	trx := dx r.
	try := dy r.
	hops := ((trx max: try) * sweepAngle abs / hop) truncated + 2.
	d := hops asFloat.
	center := geometryTransformation externalizePosition: cx@cy.
	tcx := center x.
	tcy := center y.
	0 to: hops do: [ :h |
		angle := h / d * sweepAngle + startAngle.
		xp := angle cos * trx.
		yp := angle sin * try.
		x := thetaCos * xp - (thetaSin * yp) + tcx.
		y := thetaSin * xp + (thetaCos * yp) + tcy.
		spanLeft := spanLeft min: x.
		spanTop := spanTop min: y.
		spanRight := spanRight max: x.
		spanBottom := spanBottom max: y.
		self updateAlphasForX: x y: y.
		fillColor notNil ifTrue: [
			self updateEdgeCountAtX: x y: y ].
		self updateContourForX: x y: y. ].! !
!VectorEngineWithPluginSubPixel methodsFor: 'hacky dashed strokes' stamp: 'jmv 12/19/2024 12:43:08' prior: 17004922!
                   dashedStroke_doPath: pathCommandsBlock ensureClosePath: ensureClosePath
	"Ask a VectorEngineSmalltalk for help"


	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	self class protected: [ | smalltalkVGE |
		self initializePath.
		smalltalkVGE := VectorEngineSubPixel new dashedStroke_ToFollow: self.
		smalltalkVGE initializePath.
		canvas instVarNamed: 'engine' put: smalltalkVGE.
		pathCommandsBlock valueWithPossibleArgument: (canvas ifNil:[smalltalkVGE]).
		self dashedStroke_finishPath: ensureClosePath smalltalkVGE: smalltalkVGE.
		canvas instVarNamed: 'engine' put: self.
		].
! !
!VectorEngineWithPluginWholePixel methodsFor: 'hacky dashed strokes' stamp: 'jmv 12/19/2024 12:43:13' prior: 17005116!
                         dashedStroke_doPath: pathCommandsBlock ensureClosePath: ensureClosePath
	"Ask a VectorEngineSmalltalk for help"


	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	self class protected: [ | smalltalkVGE |
		self initializePath.
		smalltalkVGE := VectorEngineWholePixel new dashedStroke_ToFollow: self.
		smalltalkVGE initializePath.
		canvas instVarNamed: 'engine' put: smalltalkVGE.
		pathCommandsBlock valueWithPossibleArgument: (canvas ifNil:[smalltalkVGE]).
		self dashedStroke_finishPath: ensureClosePath smalltalkVGE: smalltalkVGE.
		canvas instVarNamed: 'engine' put: self.
		].
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6939-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h13m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 4:50:15 pm'!
!PathLineToCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:44:34' prior: 16923435 overrides: 16923291!
               buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	points := Array streamContents: [ :strm | | px py |
		[px := aStream nextNumber.
		py := aStream nextNumber.
		py notNil ] whileTrue:
			[ strm nextPut: px@py ]]! !
!PathLineToHCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:44:43' prior: 16923468 overrides: 16923291!
                  buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	xs := Array streamContents: [ :strm | | px |
		[px := aStream nextNumber.
		px notNil ] whileTrue:
			[ strm nextPut: px ]]! !
!PathLineToVCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:45:11' prior: 16923500 overrides: 16923291!
                        buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	ys := Array streamContents: [ :strm | | py |
		[py := aStream nextNumber.
		py notNil ] whileTrue:
			[ strm nextPut: py ]]! !
!PathMoveToCommand methodsFor: 'building' stamp: 'jmv 12/19/2024 11:45:17' prior: 16923532 overrides: 16923291!
                         buildFrom: commandChar stream: aStream

	super buildFrom: commandChar stream: aStream.
	points := Array streamContents: [ :strm | | px py |
		[px := aStream nextNumber.
		py := aStream nextNumber.
		py notNil ] whileTrue:
			[ strm nextPut: px@py ]]! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 12/20/2024 16:37:37' prior: 16812270!
        scanCharactersFrom: startIndex to: stopIndex in: anUnicodeString rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	lastIndex := startIndex.
	anUnicodeString from: startIndex to: stopIndex doWithUtf8Bytes: [ :byte1 :byte2 :byte3 :byte4 |
		| nextDestX |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil).
		It is OK to just use the first byte in UTF-8"
		(stops at: byte1 + 1) ifNotNil: [ :stop | ^stop ].
		nextDestX := destX + (font widthOfUtf8Byte1: byte1 b2: byte2 b3: byte3 b4: byte4).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX := nextDestX.
			lastIndex := lastIndex + 1 ].
	lastIndex := stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!TTContourConstruction methodsFor: 'primitive format' stamp: 'jmv 12/20/2024 16:38:48' prior: 16973767!
                   addContourDataTo: stream tx: aGeometryTransformationOrNil
	| bezierCount firstPoint prevEndPoint |
	self isEmpty ifTrue: [
		^self ].

	"This bogus iteration could perhaps be avoided at the cost of extra memory."
	bezierCount := 0.
	self
		startPointDo: [ :firstBezierStart | ]
		quadraticBeziersDo: [ :controlPoint :endPoint | bezierCount := bezierCount + 1 ].
	stream nextPut: bezierCount.

	self
		startPointDo: [ :firstBezierStart |
			firstPoint := firstBezierStart.
			aGeometryTransformationOrNil notNil ifTrue: [
				firstPoint := aGeometryTransformationOrNil transform: firstPoint ].
			stream nextPut: firstPoint x; nextPut: firstPoint y.
			prevEndPoint := firstPoint ]
		quadraticBeziersDo: [ :controlPoint :endPoint |
			| cp ep cpr epr |
			cp := controlPoint.
			ep := endPoint.
			aGeometryTransformationOrNil notNil ifTrue: [
				cp := aGeometryTransformationOrNil transform: cp.
				ep := aGeometryTransformationOrNil transform: ep ].
			cpr := cp - prevEndPoint.
			epr := ep - prevEndPoint.
			"Make control point distict from start and end points for the benefit of VectorEnginePlugin"
			(cpr = `0.0@0.0` or: [ cpr = epr ]) ifTrue: [
				cpr := epr * 0.5 ].
			stream nextPut: epr x; nextPut: epr y.
			stream nextPut: cpr x; nextPut: cpr y.
			prevEndPoint := ep ].! !
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 12/19/2024 11:51:50' prior: 16918072 overrides: 16916986!
     stepAt: millisecondSinceLast

	"If there's anything in my monitor list, see if the strings have changed."
	| changes |
	changes := false.
	self monitorList keysAndValuesDo: [ :k :v |
		k ifNotNil: [ | string |
			k refresh.
			(string := k asString) ~= v ifTrue: [
				self monitorList at: k put: string. changes := true ]]].
	changes ifTrue: [ | sel |
		sel := currentSelection.
		self changed: #getList.
		self noteNewSelection: sel ]! !
!DateAndTime methodsFor: 'ansi protocol' stamp: 'jmv 12/19/2024 11:52:50' prior: 16842184!
             dayOfYear
	"This code was contributed by Dan Ingalls. It is equivalent to the terser
		^ jdn - (Year year: self year) start julianDayNumber + 1 but much quicker."

	^ self dayMonthYearDo:
		[ :d :m :y | | monthStart |
			monthStart := #(1 32 60 91 121 152 182 213 244 274 305 335) at: m.
			(m > 2 and: [ Year isLeapYear: y ])
				ifTrue: [ monthStart + d ]
				ifFalse: [ monthStart + d - 1 ]]! !
!Float methodsFor: 'converting' stamp: 'jmv 12/20/2024 16:41:27' prior: 16865214!
partValues: aThreeArgumentBlock ifInfinite: infinityBlock ifNaN: nanBlock
	"
	Float pi hex print
	Float pi partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	0.0 partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	For 0.0, exponent will be the minimum possible, i.e.  -1023, and mantissa will be 0.
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits |
		| sign exponent mantissa |

		"Extract the sign"
		sign := signBit = 0 ifTrue: [1] ifFalse: [-1].

		"Special cases: infinites and NaN"
		exponentBits = 16r7FF ifTrue: [
			^mantissaBits = 0
				ifTrue: [ infinityBlock valueWithPossibleArgument: self ]
				ifFalse: [ nanBlock valueWithPossibleArgument: self and: mantissaBits ]].

		"Unbias exponent: 16r3FF is bias"
		exponent := exponentBits - 16r3FF.
	
		exponentBits ~= 0
			ifTrue: [
				"Add back implicit leading 1 in fraction."
				mantissa := 16r0010000000000000 bitOr: mantissaBits ]
			ifFalse: [
				"If expPart = 0, I am +/-zero or a denormal value. In such cases, no implicit leading bit in mantissa."
				mantissa := mantissaBits.
				exponent := exponent + 1 ].

		"Evaluate the block"
		aThreeArgumentBlock value: sign value: exponent value: mantissa
	]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/19/2024 11:54:47' prior: 16865329!
            floatsAwayFrom: aFloat

	| count2 count1 |
	(self isNaN or: [ aFloat isNaN ]) ifTrue: [ ^ Float nan ].
	count2 := self partBits: [:s :e :m | (e bitShift: self class precision - 1) + m * (s * -2 + 1)].
	count1 := aFloat partBits: [:s :e :m | (e bitShift: self class precision - 1) + m * (s * -2 + 1)].
	^count2 - count1! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/20/2024 16:44:16' prior: 16865383!
                              nextAwayFromZero
	"Answer the Float with smallest magnitude but larger than ours, with the same sign
	Only for finite numbers."

	^ self partValues: [ :sign :myExponent :myMantissa |
		| exponent mantissa |
		myMantissa = 16r1FFFFFFFFFFFFF
			ifTrue: [
				mantissa := 16r10000000000000.
				exponent := myExponent +1 ]
			ifFalse: [
				mantissa := myMantissa+1.
				exponent := myExponent ].
		Float signPart: sign mantissaPart: mantissa exponentPart:  exponent ]! !
!Float methodsFor: 'truncation and round off' stamp: 'jmv 12/20/2024 16:45:10' prior: 16865401!
           nextTowardsZero
	"Answer the Float with largest magnitude but smaller than ours, with the same sign.
	Only for finite, non zero numbers."

	^ self partValues: [ :sign :myExponent :myMantissa |
		| exponent mantissa |
		myMantissa isZero ifTrue: [ self error: 'Not for zero values' ].
		(myMantissa = 16r10000000000000 and: [myExponent > Float emin])
			ifTrue: [
				mantissa := 16r1FFFFFFFFFFFFF.
				exponent := myExponent -1 ]
			ifFalse: [
				mantissa := myMantissa-1.
				exponent := myExponent ].
		Float signPart: sign mantissaPart: mantissa exponentPart:  exponent ]! !
!Fraction methodsFor: 'printing' stamp: 'jmv 12/20/2024 16:46:07' prior: 16871379 overrides: 16914567!
                      storeOn: aStream
	
	"If possible, store as a literal of the form 9999e-99
	If denominator's prime factors are just 2 and 5, then we can be printed as a literal
	of the form 999999e-99"
	"
	123e-12 storeString
	123e-12 printString
	123e-12000 storeString
	123e-12000 printString
	(3/4) storeString
	(3/4) printString
	(-3/4) storeString
	(-3/4) printString
	(1/3) storeString
	(1/3) printString
	"
	denominator
		ifMultipleOf2And5Do: [ :exponent2 :exponent5 |
			| e f |
			exponent2 > exponent5
				ifTrue: [
					e := exponent2.
					f := 5 raisedToInteger: e-exponent5 ]
				ifFalse: [
					e := exponent5.
					f := 2 bitShift: e-exponent2-1 ].
			numerator*f storeOn: aStream base: 10.
			aStream nextPut: $e; nextPut: $-.
			e storeOn: aStream base: 10 ]
		otherwise: [
			super storeOn: aStream ]
! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 12/20/2024 16:48:50' prior: 16891336!
     layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount widths widthToAllocate leftOver x cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleSubmorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * self axisEdgeWeight).

	visibleSubmorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + gap.
	].! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 12/20/2024 16:49:11' prior: 16891373!
                   layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount heights heightToAllocate leftOver y cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleSubmorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * self axisEdgeWeight).

	visibleSubmorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + gap.
	].! !
!TextComposition methodsFor: 'editing' stamp: 'jmv 12/20/2024 16:31:46' prior: 16981562!
            clickAt: clickPoint
	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."
	| action startBlock t |
	action := false.
	startBlock := self characterBlockAtPoint: clickPoint.
	t := model actualContents.
	(t attributesAt: startBlock stringIndex) do: [ :att | 
		att mayActOnClick ifTrue: [ | target range boxes box |
				(target := model) ifNil: [ target := editor morph].
				range := t rangeOf: att startingAt: startBlock stringIndex.
				boxes := self selectionRectsFrom: (self characterBlockForIndex: range first) 
							to: (self characterBlockForIndex: range last+1).
				box := boxes detect: [ :each | each containsPoint: clickPoint] ifNone: nil.
				box ifNotNil: [
					box := editor morph displayBounds.
					editor morph allOwnersDo: [ :m | box := box intersect: (m displayBounds) ].
					Utilities
						awaitMouseUpIn: box
						repeating: nil
						ifSucceed: [(att actOnClickFor: target in: self at: clickPoint editor: editor) ifTrue: [action := true]].
				]]].
	^ action! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 12/20/2024 16:32:24' prior: 16862013!
            splitNameVersionExtensionFor: fileName
	" answer an array with the root name, version # and extension.
	See comment in senders for more details"

	self baseNameAndExtensionFor: fileName do: [ :b :extension |
		| baseName version i j |
		baseName := b.
		i := j := baseName findLast: [:c | c isDigit not].
		i = 0
			ifTrue: [version := 0]
			ifFalse: [
				(baseName at: i) = $.
					ifTrue: [
						version := (baseName copyFrom: i+1 to: baseName size) asNumber.
						j := j - 1]
					ifFalse: [version := 0].
				baseName := baseName copyFrom: 1 to: j ].
		^ Array with: baseName with: version with: extension ]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 12/19/2024 12:47:06' prior: 16823886!
 sortedExtensionMethodsDo: aBlock displayingProgress: aString
	"Include both class and instance methods we define, for classes we don't define."
	| externalClasses |
	externalClasses := self externalClasses.
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: externalClasses size
		during: [ :barBlock |
			externalClasses withIndexDo: [ :classOrMetaClass :i | | methods |
				barBlock value: i.
				methods := Array streamContents: [ :stream |
					(self extensionCategoriesForClass: classOrMetaClass) do: [ :cat |
						self methodsInCategory: cat ofClass: classOrMetaClass do: [ :m |
							stream nextPut: m ]]].
				methods sort: [ :a :b |
					a methodSymbol < b methodSymbol ].
				methods do: aBlock.
				]
			]! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 12/19/2024 12:46:23' prior: 16824420!
named: aString createIfAbsent: neverAnswerNil registerIfNew: doRegisterIfJustCreated
	"Answer the instance with name aString.
	If there's no package named aString, answer nil or a new instance as requested.
	If a new instance is created, register it or not as requested.
	CodePackage named: 'Morphic' createIfAbsent: false registerIfNew: false
	CodePackage named: 'Morphic' createIfAbsent: true registerIfNew: false
	CodePackage named: 'XXXXXTest' createIfAbsent: true registerIfNew: true
	"

	| newInstance |
	^self installedPackages
		at: aString
		ifAbsent: [
			neverAnswerNil ifTrue: [ 
				newInstance := self new packageName: aString.
				doRegisterIfJustCreated ifTrue: [ self register: newInstance ].
				newInstance ]].! !
!FeatureRequirement methodsFor: 'requires' stamp: 'jmv 12/19/2024 12:47:11' prior: 16860502!
      findPackageFileAsReqOf: mainFeatureOrNil
	"Look in known places for packages providing required feature.
	Answer wether search was successful."
	| packageFileName |
	pathName ifNotNil: [
		pathName asFullFileEntry exists ifTrue: [ ^ true ]].
	packageFileName := self packageFileName.
	(mainFeatureOrNil ifNil: [ self ]) placesToLookForPackagesDo: [ :directory | | entry |
		entry := directory // packageFileName.
		entry exists ifTrue: [
			"Try this one. If success, keep it."
			self pathName: entry pathName.
			self checkRequirement ifTrue: [ ^true ].
			"Nope. Don't keep it."
			self pathName: nil ]].
	^ false! !
!Clipboard methodsFor: 'private' stamp: 'jmv 12/19/2024 12:47:24' prior: 16821332!
 extendedClipboardInterface
	"Answer a subinstance of ExtendedClipboardInterface, if present and operational.
	Clipboard default extendedClipboardInterface
	"
	Smalltalk at: #ExtendedClipboardInterface ifPresent: [ :clipboardInterface |
		| interface |
		interface := clipboardInterface current.
		interface isOperational ifTrue: [
			^ interface ]].
	"No operational extended clipboard."
	^nil! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'jmv 12/19/2024 12:47:33' prior: 16930271!
               installHaloPreferencesWith: anArray
	^ self sysPreferences 
		name: #haloSpecifications 
		description: 'Halo specifications describing which halos are to be used, what they should look like, and where they should be situated'
		category: #gui
		type: Array
		value: (anArray collect: [ :each | | aColor |
			aColor := Color.
			each fourth do: [ :sel | aColor := aColor perform: sel].
			HaloSpec new 
				horizontalPlacement: each second
				verticalPlacement: each third 
				color: aColor
				iconSymbol: each fifth
				addHandleSelector: each first
				hoverHelp: each sixth])! !
!PreferenceSet class methodsFor: 'sys fonts' stamp: 'jmv 12/19/2024 12:47:47' prior: 16930381!
                        setDefaultFont: fontFamilyName spec: defaultFontsSpec

	defaultFontsSpec do: [ :triplet | | font |
		font := FontFamily familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [ font := FontFamily defaultFamilyAndPointSize ]. 
		triplet size > 2 ifTrue: [			font := font emphasized: triplet third ].
		self sysPreferences at: triplet first put: font ].
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].! !
!PreferenceSet class methodsFor: 'services' stamp: 'jmv 12/19/2024 12:47:39' prior: 16930474!
                 readAndApplyUserPrefs
	"
	PreferenceSet readAndApplyUserPrefs
	"
	| file |
	file := DirectoryEntry userBaseDirectory // 'UserPrefs.txt'.
	file exists ifTrue: [
		file readStreamDo: [ :stream |
			[ stream atEnd ] whileFalse: [ | line parts |
				line := stream nextLine.
				parts := line substringsSeparatedBy: $=.
				[ | pref value |
					pref := Preferences instanceAt: parts first asSymbol.
					value := parts second.
					value first = $# ifTrue: [ value := (value withoutPrefix: '#') asSymbol ].
					pref value: value.
					pref justReadFromDisk.
				]
					on: Error
					do: [ :error |
						'--- UserPrefts.txt Error' print.
						error print.
						line print ].
				]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6940-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h29m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 4:58:56 pm'!
!WeakActionSequence methodsFor: 'evaluating' stamp: 'jmv 8/2/2016 16:38:32' prior: 17006443!
    valueStartingFrom: startIndex
	"Do the same as my parent, but make sure that all actions that do not 
	give errors are evaluated before resignaling the ones that gave errors 
	(giving the chance to clients to handle them)."

	| each answer |
	startIndex to: self size do: [:index |
		each := self at: index.
		[ answer := each value ]
			on: UnhandledError
			do: [:exc | 
				self valueStartingFrom: index + 1.
				exc pass]].
	^ answer! !
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 12/20/2024 16:53:35' prior: 16832933!
             selector: aSelector
	"Set a method's selector.  This is either the penultimate literal,
	 or, if the method has any properties or pragmas, the selector of
	 the MethodProperties stored in the penultimate literal."
	
	self 
		withPropertiesDo: [ :properties | properties selector: aSelector ] 
		ifSelector: [ :selector | | numberOfLiterals |
			(numberOfLiterals := self numLiterals) < 2 ifTrue: [self error: 'insufficient literals to hold selector'].
			self literalAt: numberOfLiterals - 1 put: aSelector]! !
!CompiledMethod methodsFor: 'printing' stamp: 'jmv 12/20/2024 16:54:39' prior: 16833428!
        symbolicLinesDo: aBlock
	"Evaluate aBlock with each of the lines in the symbolic output."

	| aStream pc |
	aStream := ReadWriteStream on: (String new: 64).
	self isQuick ifTrue:
		[self longPrintOn: aStream.
		 aBlock value: 0 value: aStream contents.
		 ^self].

	self primitive ~= 0 ifTrue:
		[self printPrimitiveOn: aStream.
		 aBlock value: 1 value: aStream contents.
		 aStream resetContents].

	pc := self initialPC.
	(InstructionPrinter on: self)
		indent: 0;
		printPC: false; "explorer provides pc anyway"
		printInstructionsOn: aStream
		do:	[:printer :scanner :stream| | line firstLine index |
			line := stream contents allButLast.
			firstLine := line lines first.
			firstLine size < line size ifTrue: [
				line := firstLine, '...'' (continues)'].
			(index := line indexOf: $>) > 0 ifTrue:
				[[(line at: index + 1) isSeparator] whileTrue: [index := index + 1].
				 line := ((line copyFrom: 1 to: index) copyReplaceAll: (String with: Character tab) with: (String new: 8 withAll: Character space)),
						(line copyFrom: index + 1 to: line size)].
			aBlock value: pc value: line.
			pc := scanner pc.
			stream resetContents]! !
!CompiledMethod class methodsFor: 'services' stamp: 'jmv 9/8/2023 17:26:55' prior: 16835350!
       remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive"

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			aDictionary at: aCompiledMethodOrMethodSpec returnField+1 ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true 	].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			newIvar = oldIvar ifFalse: [
				aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
				^false ]	].
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			aDictionary at: followingByte+1 ifPresent: [ :newIvar |
				newIvar <= 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			aDictionary at: thirdByte+1 ifPresent: [ :newIvar |
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: newIvar-1 ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 						"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true! !
!RunArray methodsFor: 'enumerating' stamp: 'jmv 12/20/2024 16:57:27' prior: 16942665!
                 runsFrom: start to: stop do: aBlock
	"Evaluate aBlock with all existing runs in the range from start to stop"
	start > stop ifTrue:[^self].
	self at: start setRunOffsetAndValue: [ :firstRun :offset :firstValue|
		| run value index |
		run := firstRun.
		value := firstValue.
		index := start + (runs at: run) - offset.
		[aBlock value: value.
		index <= stop] whileTrue:[
			run := run + 1.
			value := values at: run.
			index := index + (runs at: run)]].
! !
!Set class methodsFor: 'initialization' stamp: 'jmv 12/20/2024 16:58:24' prior: 16950729!
                         quickRehashAllSets  "Set rehashAllSets"
	self withAllSubclassesDo:
		[:c |
			| insts |
			insts := c allInstances.
			(insts isEmpty or: [c = MethodDictionary]) ifFalse:
			['Rehashing instances of ' , c name
				displayProgressAt: Sensor mousePoint
				from: 1 to: insts size
				during: [ :barBlock | 1 to: insts size do: [:x | barBlock value: x. (insts at: x) rehash]]]]! !
!Set class methodsFor: 'initialization' stamp: 'jmv 12/20/2024 16:58:13' prior: 16950744!
            rehashAllSets  "Set rehashAllSets"
	self withAllSubclassesDo:
		[:c |
			| insts |
			insts := c allInstances.
			insts isEmpty ifFalse:
			['Rehashing instances of ' , c name
				displayProgressAt: Sensor mousePoint
				from: 1 to: insts size
				during: [ :barBlock |
				1 to: insts size do:
					[ :x | barBlock value: x.
					(insts at: x) rehash]]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6941-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h50m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 5:04:02 pm'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:15' prior: 16928604!
            untilAnySatisfying: aBlock

	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:51' prior: 16928625!
   upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"Answer a subcollection from the current access position to the 
	occurrence of delimiter in the receiver. 

	If delimiterIsTerminator is false, delimiter is considered a separator:
		- Skip delimiter, but don't include it in the answer.
		- If delimiter is not found, answer the entire rest of the receiver.

	If delimiterIsTerminator is true, answer will end with delimeter:
		- Read delimiter, include it in the answer.
		- If delimiter is not found, answer nil and don't advance receiver at all.
	This is especially useful if we are appended new stuff while simultaneusly being read."

	| prevPosition answer |
	prevPosition := self position.
	answer := self collectionSpecies streamContents: [ :newStream | | element |
		[self atEnd or: [(element := self next) = delimiter]]
			whileFalse: [newStream nextPut: element].
		delimiterIsTerminator ifTrue: [
			element = delimiter
				ifTrue: [newStream nextPut: element]
				ifFalse: [
					self position: prevPosition.
					^ nil ]]].
	^answer.! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:13:01' prior: 16928685!
                           upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."

	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:02:45' prior: 16928867!
           backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:03:41' prior: 16929037!
         nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6942-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h58m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6942] on 20 December 2024 at 5:34:45 pm'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/20/2024 17:33:07' prior: 50338136!
     untilAnySatisfying: aBlock
1 print.
	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 10/25/2021 11:18:50' prior: 50338145!
                           upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"Answer a subcollection from the current access position to the 
	occurrence of delimiter in the receiver. 

	If delimiterIsTerminator is false, delimiter is considered a separator:
		- Skip delimiter, but don't include it in the answer.
		- If delimiter is not found, answer the entire rest of the receiver.

	If delimiterIsTerminator is true, answer will end with delimeter:
		- Read delimiter, include it in the answer.
		- If delimiter is not found, answer nil and don't advance receiver at all.
	This is especially useful if we are appended new stuff while simultaneusly being read."

	| prevPosition element answer |
	prevPosition := self position.
	answer := self collectionSpecies streamContents: [ :newStream |
		[self atEnd or: [(element := self next) = delimiter]]
			whileFalse: [newStream nextPut: element].
		delimiterIsTerminator ifTrue: [
			element = delimiter
				ifTrue: [newStream nextPut: element]
				ifFalse: [
					self position: prevPosition.
					^ nil ]]].
	^answer.! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/20/2024 17:33:18' prior: 50338182!
                               upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."
3 print.
	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:33:24' prior: 50338203!
   backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
4 print.
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:33:30' prior: 50338241!
nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
5 print.
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6943-FixNeverendingTestInCI-testUpToTerminator6TerminatedLongRecords-JuanVuletich-2024Dec20-17h33m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6895] on 22 December 2024 at 7:24:31 pm'!
!CompiledMethod commentStamp: 'eem 12/22/2024 19:23:15' prior: 16832642!
        My instances are methods suitable for interpretation by the virtual machine.  This is the only class in the system whose instances intermix both indexable pointer fields and indexable integer fields. The pointer fields are used for literals and metadata, and the bytes are used for bytecodes and a variety of encoded informaton such as source code, source code position, etc.  The first part of a CompiledMethod object is pointers, the second part is bytes.  CompiledMethod inherits from ByteArray to avoid duplicating some of ByteArray's methods, not because a CompiledMethod is a ByteArray.

Instance variables: *indexed* (no named inst vars)

Class variables:
SmallFrame							- the number of stack slots in a small frame Context
LargeFrame							- the number of stack slots in a large frame Context
PrimaryBytecodeSetEncoderClass		- the encoder class that defines the primary instruction set
SecondaryBytecodeSetEncoderClass	- the encoder class that defines the secondary instruction set
	
TThe current format of a CompiledMethod is as follows:

	header (4 or 8 bytes, SmallInteger)
	literals (4 or 8 bytes each, Object, see "The last literal..." below)
	bytecodes  (variable, bytes)
	trailer (variable, bytes)

The header is a SmallInteger (which in the 32-bit system has 31 bits, and in the 64-bit system, 61 bits) in the following format:

	(index 0)		15 bits:	number of literals (#numLiterals)
	(index 15)		  1 bit:	jit without counters - reserved for methods that have been optimized by Sista
	(index 16)		  1 bit:	has primitive
	(index 17)		  1 bit:	whether a large frame size is needed (#frameSize => either SmallFrame or LargeFrame)
	(index 18)		  6 bits:	number of temporary variables (#numTemps)
	(index 24)		  4 bits:	number of arguments to the method (#numArgs)
	(index 28)		  2 bits:	reserved for an access modifier (00-unused, 01-private, 10-protected, 11-public), although accessors for bit 29 exist (see #flag).
	sign bit:			  1 bit:	selects the instruction set, >= 0 Primary, < 0 Secondary (#signFlag)

If the method has a primitive then the first bytecode of the method must be a callPrimitive: bytecode that encodes the primitive index.  This bytecode can encode a primitive index from 0 to 65535.

The trailer has two variant formats.  In the first variant, the last byte is at least 252 and the last four bytes represent a source pointer into one of the sources files (see #sourcePointer).  In the second variant, the last byte is less than 252, and the last several bytes are a compressed version of the names of the method's temporary variables.  The number of bytes used for this purpose is the value of the last byte in the method.

While there are disadvantages to this "flat" representation (it is impossible to add named instance variables to CompiledMethodor its subclasses, but it is possible indirectly; see AdditionalMethodState) it is effective for interpreters.  It means that both bytecodes and literals can be fetched directly from a single method object, and that only one object, the method, must be saved and restored on activation and return.  A more natural representation, in which there are searate instance variables for the bytecode, and (conveniently) the literals, requires either much more work on activation and return setting up references to the literals and bytecodes, or slower access to bytecodes and literals, indirecting on each access.

The last literal of a CompiledMethod is reserved for special use by the kernel and/or the virtual machine.  It must either be the methodClassAssociation, used to implement super sends, or nil, if the method is anonymous.

By convention, the penultimate literal is reserved for special use by the kernel. In CompiledMethod instances it must either be the method selector, or an instance of AdditionalMethodState which holds the selector and any pragmas or properties in the method.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6944-CompiledMethodComment-EliotMiranda-2024Dec22-19h23m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6942] on 23 December 2024 at 10:56:59 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:15' prior: 50338271!
          untilAnySatisfying: aBlock

	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:13:01' prior: 50338318!
   upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."

	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:02:45' prior: 50338339!
           backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:03:41' prior: 50338377!
         nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6945-6943-again-JuanVuletich-2024Dec23-10h55m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6945] on 23 December 2024 at 11:04:32 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/22/2022 21:13:39' prior: 50338549!
                 upToAny: aCollection 
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."
	| element prevPos |
	^self collectionSpecies streamContents: [ :strm |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6946-6943-tweak-JuanVuletich-2024Dec23-11h02m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6946] on 23 December 2024 at 11:11:28 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 5/30/2022 10:18:25' prior: 50338540!
        untilAnySatisfying: aBlock
	| c |
	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				c := self peek.
				(aBlock value: c) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/19/2022 11:57:58' prior: 50338570!
                 backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		prevCh := $$.
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 5/23/2022 17:47:39' prior: 50338608!
                          nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator ch done |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6947-Undo6942-JuanVuletich-2024Dec23-11h10m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6947] on 23 December 2024 at 3:20:03 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 12/23/2024 15:19:46' prior: 16964933!
                        knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !
!Morph methodsFor: 'events-processing' stamp: 'JEC 12/23/2024 09:53:40' prior: 16905820!
         processDropMorph: aDropEvent
	"Handle a dropping morph."
	| aMorph |
	
	aDropEvent wasHandled ifTrue: [ ^self ]. "Do it just once, for one drop destination"
	
	aMorph := aDropEvent contents.
	aDropEvent wasHandled: true.
	aMorph justDroppedInto: self event: aDropEvent.
	self acceptDroppingMorph: aMorph event: aDropEvent.
	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6948-AddJoelAsKnownAuthor-JuanVuletich-2024Dec23-15h15m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6944] on 23 December 2024 at 10:24:59 am'!
!Morph methodsFor: 'events-processing' stamp: 'JEC 12/23/2024 09:53:40' prior: 50338997!
                 processDropMorph: aDropEvent
	"Handle a dropping morph."
	| aMorph |
	
	aDropEvent wasHandled ifTrue: [ ^self ]. "Do it just once, for one drop destination"
	
	aMorph := aDropEvent contents.
	aDropEvent wasHandled: true.
	aMorph justDroppedInto: self event: aDropEvent.
	self acceptDroppingMorph: aMorph event: aDropEvent.
	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6949-DropMethodOnNoCategoryFix-JoelEstebanCamera-2024Dec23-09h53m-JEC.001.cs.st----!

'From Cuis7.3 [latest update: #6949] on 24 December 2024 at 10:34:31 am'!
!CodeWindow methodsFor: 'misc' stamp: 'eem 12/24/2024 10:33:48' prior: 16827299!
               getSelectorAndSendQuery: querySelector to: queryPerformer with: queryArgs
	"Obtain a selector relevant to the current context, and then send the querySelector to the queryPerformer with the selector obtained and queryArgs as its arguments.  If no message is currently selected, then obtain a method name from a user type-in"

	| strm array |
	strm := WriteStream on: (array := Array new: queryArgs size + 1).
	strm nextPut: nil.
	strm nextPutAll: queryArgs.

	model selectedMessageName
		ifNotNil:
			[:messageName|
			querySelector numArgs = 1 ifTrue:
				[Symbol
					hasInterned: messageName
					ifTrue:
						[:messageSymbol|
						^queryPerformer perform: querySelector with: messageSymbol]]]
		ifNil:
			[ | selector |
			selector := self request: 'Type selector:' initialAnswer: 'flag:'.
			^ selector isEmpty ifFalse: [
				(Symbol hasInterned: selector
					ifTrue: [ :aSymbol |
						array at: 1 put: aSymbol.
						queryPerformer perform: querySelector withArguments: array])
					ifFalse: [ self inform: 'no such selector']
			]
		].

	self selectMessageAndEvaluate: [:selector |
		array at: 1 put: selector.
		queryPerformer perform: querySelector withArguments: array
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6950-HaveMessageNamesFindSymbolReferences-EliotMiranda-2024Dec24-10h21m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6938] on 20 December 2024 at 5:04:02 pm'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:15' prior: 50338666!
untilAnySatisfying: aBlock

	^self collectionSpecies streamContents: [ :write |
		[
			self atEnd not and: [
				(aBlock value: self peek) not]]
			whileTrue: [write nextPut: self next]].! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:12:51' prior: 50338281!
   upTo: delimiter delimiterIsTerminator: delimiterIsTerminator
	"Answer a subcollection from the current access position to the 
	occurrence of delimiter in the receiver. 

	If delimiterIsTerminator is false, delimiter is considered a separator:
		- Skip delimiter, but don't include it in the answer.
		- If delimiter is not found, answer the entire rest of the receiver.

	If delimiterIsTerminator is true, answer will end with delimeter:
		- Read delimiter, include it in the answer.
		- If delimiter is not found, answer nil and don't advance receiver at all.
	This is especially useful if we are appended new stuff while simultaneusly being read."

	| prevPosition answer |
	prevPosition := self position.
	answer := self collectionSpecies streamContents: [ :newStream | | element |
		[self atEnd or: [(element := self next) = delimiter]]
			whileFalse: [newStream nextPut: element].
		delimiterIsTerminator ifTrue: [
			element = delimiter
				ifTrue: [newStream nextPut: element]
				ifFalse: [
					self position: prevPosition.
					^ nil ]]].
	^answer.! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 12/19/2024 11:13:01' prior: 50338638!
                           upToAny: aCollection
	"Answer a subcollection from the current access position to the 
	occurrence (if any, but not inclusive) of any objects in the given collection in the receiver. If 
	any of these is not in the collection, answer the entire rest of the receiver."

	^self collectionSpecies streamContents: [ :strm | | element prevPos |
		[self atEnd or: [
			prevPos := self position.
			element := self next.
			aCollection includes: element ]]
				whileFalse: [strm nextPut: element].
		(aCollection includes: element)
			ifTrue: [self position: prevPos]].! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:02:45' prior: 50338676!
           backChunk
	"Answer the contents of the receiver back to the previous terminator character.
	Doubled delimiter indicate an embedded delimiter character."
	
	| answer ch firstPosition delimiter prevCh count delimiterCount |
	delimiter := $!!.
	"Go to end of chunk, not including delimiter."
	ch := self back.
	ch = delimiter ifTrue: [ ch := self back ].

	count := 1.
	prevCh := $$.
	"Go back until non-doubled delimiter, or beginning."
	[ch notNil and: [ ch ~= delimiter or: [self peekBack = delimiter or: [prevCh = delimiter]]]] whileTrue: [
		count := count + 1.
		prevCh := ch.
		ch := self back. ].
	"Skip initial delimiter"
	ch = delimiter ifTrue: [
		self next.
		count := count-1 ].

	"This is where chunk starts. Undouble doubled delimiters."
	firstPosition := self position.
	answer := String streamContents: [ :strm |
		delimiterCount := 0.
		count timesRepeat: [
			ch := self next.
			delimiterCount \\ 2 = 0 ifTrue: [
				strm nextPut: ch ].
			delimiterCount := ch = delimiter
				ifTrue: [ delimiterCount+1]
				ifFalse: [0]]].

	"Re position at start."
	self position: firstPosition.
	^ answer! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 12/20/2024 17:03:41' prior: 50338715!
         nextChunk
	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."
	| terminator |
	terminator := $!!.
	^self collectionSpecies streamContents: [ :strm |
		| ch done |
		self skipSeparators.
		done := false.
		[done not and: [(ch := self next) ~~ nil]] whileTrue: [
			done := false.
			(ch = terminator) ifTrue: [
				self peek = terminator ifTrue: [
					self next.  "skip doubled terminator"
				] ifFalse: [
					done := true  "terminator is not doubled; we're done!!"
				].
			].
			done ifFalse: [
				strm nextPut: ch ].
		]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6951-6942-AGAIN-MoveTempsToInnerBlocks-JuanVuletich-2024Dec20-16h58m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6951] on 27 December 2024 at 9:59:33 am'!
!CompiledMethod methodsFor: 'source code management' stamp: 'eem 12/27/2024 09:55:57' prior: 16834012!
                 messageSendsCount
	"Number of message sends in code.
	A measure of the complexity of code. Alternative to #linesOfCode"

	| count scanner |
	count := 0.
	scanner := InstructionStream on: self.
	scanner scanFor:
		[:x | | selectorOrSelf |
		(selectorOrSelf := scanner selectorToSendOrSelf) == scanner ifFalse:
			[count := count + 1].
		false	"keep scanning"].
	^count! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6952-muchFaster-messageSendsCount-EliotEmilioMiranda-2024Dec27-09h55m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6952] on 27 December 2024 at 10:12:34 am'!
!Delay methodsFor: 'private' stamp: 'jmv 12/27/2024 10:11:02' prior: 16846848!
  setDelay: millisecondCount 
	"Private!! Initialize this delay to signal the given semaphore after the given number of milliseconds."

	delayDuration := millisecondCount asInteger! !
!Delay methodsFor: 'private' stamp: 'jmv 12/27/2024 10:11:39' prior: 16846856!
                           setDelay: millisecondCount forSemaphore: aSemaphore
	"Private!! Initialize this delay to signal the given semaphore after the given number of milliseconds."

	delayDuration := millisecondCount asInteger.
	delaySemaphore := aSemaphore.
	beingWaitedOn := false.
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6953-delayDuration-mustBeAnInteger-JuanVuletich-2024Dec27-10h08m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6953] on 27 December 2024 at 10:58:19 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 12/27/2024 10:57:47' prior: 50338745!
  knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wbsl'						'Wéslleymberg Lisboa')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6954-AddWeslleymbergAsKnownContributor-JuanVuletich-2024Dec27-10h57m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6947] on 23 December 2024 at 6:47:53 pm'!
!EphemeronFinalizationProcess class methodsFor: 'system startup' stamp: 'wbsl 12/23/2024 18:10:14' prior: 50334406 overrides: 16789354!
                         startUp: resuming
	"resuming ifFalse: [ ^self ]."
	"Must restart even if just continuing after a snapshot"
	self restartFinalizationProcess! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6955-EphemeronProcessRestart-afterSnapshot-WeslleymbergLisboa-2024Dec23-12h24m-wbsl.001.cs.st----!

'From Cuis7.3 [latest update: #6955] on 27 December 2024 at 11:28:57 am'!
!Morph methodsFor: 'geometry testing' stamp: 'RMV 12/27/2024 11:28:39' prior: 16906827!
                   clipsSubmorphsReally
	"Currently only one level of clipping is supported.
	This means that if a morph clipsSubmorphs, then no submorph in its tree can do it.
	This is a current limitation of VectorCanvas"

	self clipsSubmorphs ifFalse: [ ^false ].
	self allOwnersDo: [ :o | o clipsSubmorphs ifTrue: [ ^false ]].
	^true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6956-typoFix-R.MarkVolkmann-2024Dec27-11h28m-RMV.001.cs.st----!

'From Cuis7.3 [latest update: #6950] on 27 December 2024 at 8:51:10 am'!
!CodeWindow methodsFor: 'misc' stamp: 'len 5/20/2020 08:09:08' prior: 50339039!
            getSelectorAndSendQuery: querySelector to: queryPerformer with: queryArgs
	"Obtain a selector relevant to the current context, and then send the querySelector to the queryPerformer with the selector obtained and queryArgs as its arguments.  If no message is currently selected, then obtain a method name from a user type-in"

	| strm array |
	strm := WriteStream on: (array := Array new: queryArgs size + 1).
	strm nextPut: nil.
	strm nextPutAll: queryArgs.

	model selectedMessageName ifNil: [ | selector |
		selector := self request: 'Type selector:' initialAnswer: 'flag:'.
		^ selector isEmpty ifFalse: [
			(Symbol hasInterned: selector
				ifTrue: [ :aSymbol |
					array at: 1 put: aSymbol.
					queryPerformer perform: querySelector withArguments: array])
				ifFalse: [ self inform: 'no such selector']
		]
	].

	self selectMessageAndEvaluate: [:selector |
		array at: 1 put: selector.
		queryPerformer perform: querySelector withArguments: array
	]! !
!CodeWindow methodsFor: 'misc' stamp: 'jmv 12/27/2024 08:50:01' prior: 16827332!
             selectMessageAndEvaluate: aBlock
	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"

	| selector method messages |
	(selector := model selectedMessageName) ifNil: [^ self].
	method := (model selectedClassOrMetaClass ifNil: [^ aBlock value: selector])
		compiledMethodAt: selector
		ifAbsent: nil.
	(method isNil or: [(messages := method messages) isEmpty])
		 ifTrue: [^ aBlock value: selector].
	(messages size = 1 and: [messages includes: selector])
		ifTrue:
			[^ aBlock value: selector].  "If only one item, there is no choice"

	Smalltalk
		showMenuOf: messages
		withFirstItem: selector
		ifChosenDo: aBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6957-Better-6950-WorkWithOrWithoutRealMethod-JuanVuletich-2024Dec27-08h36m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6957] on 30 December 2024 at 1:04:30 pm'!
!MethodSet methodsFor: 'testing' stamp: 'jmv 12/30/2024 13:04:04' prior: 16902849 overrides: 16826346!
                  isEditingMethod

	^selectedMessage notNil and: [ selectedMessage selector ~~ #Comment ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6958-isEditingMethod-fix-JuanVuletich-2024Dec30-13h02m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6957] on 30 December 2024 at 1:06:16 pm'!
!SystemDictionary methodsFor: 'browsing' stamp: 'hlsf 12/30/2024 12:55:18'!
             browseMethodsWithSourceString: aString in: aPackage
	" Browse all methods in aPackage whose source code contains aString as a substring."

	| matchingMethods |
	matchingMethods := Set new.
	aPackage classesDo: [ :aPackageClass |
		(aPackageClass organization classComment
			findString: aString
			startingAt: 1
			caseSensitive: false) > 0 ifTrue: [
				matchingMethods add: (MethodReference class: aPackageClass selector: #Comment) ]].
	aPackage methods do: [ :methodReference |
		(methodReference sourceCode 
			findString: aString
			startingAt: 1
			caseSensitive: false) > 0 ifTrue: [
				matchingMethods add: methodReference ]].
		
	^ self 
		browseMessageList: matchingMethods asArray sort
		name: 'Methods containing ' , aString printString, ' in package: ', aPackage packageName
		autoHighlight: aString
		allOccurrences: true.! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'hlsf 12/30/2024 12:57:55' prior: 16956254!
                findMethodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"
	| searchString selection scopeClass scopeClassName includeSubclasses includeSuperclasses labelList package |
	
	searchString := StringRequestMorph
		request: 'Enter search text:'
		initialAnswer: self selectedString
		orCancel: [^self].
	
	scopeClass := self codeProvider selectedClass.
	scopeClassName := scopeClass name asString.
	includeSubclasses := false.
	includeSuperclasses := false.

	labelList := {
		'This method'. 
		'All methods in image'. } asOrderedCollection.
	(scopeClass notNil)
		ifTrue: [
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := self codeProvider isEditingMethod
				ifTrue: [CodePackage packageOfMethod: self codeProvider currentCompiledMethod asMethodReference ifNone: []]
				ifFalse: [CodePackage packageOfClass: scopeClass ifNone: []].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
				
	selection := (SelectionMenu labelList: labelList selections: nil) startUpWithCaption: 'Search Scope'.

	(selection = 0) ifTrue:[^self].
	(selection = 1) "This method"
		ifTrue:[^self find: searchString].
	(selection = 2) "All methods in image"
		ifTrue:[scopeClass := nil].
	"(selection = 3) ifTrue:[]. ""Class only - nothing to do"
	(selection = 4) "Class and subclasses"
		ifTrue:[includeSubclasses := true].
	(selection = 5) "Class, subclasses, and superclasses"
		ifTrue:[
			includeSubclasses := true.
			includeSuperclasses := true].
	(selection = 6) "In my package if any "
		ifTrue: [^ Smalltalk browseMethodsWithSourceString: searchString in: package].
	Smalltalk browseMethodsWithSourceString: searchString scopeClass: scopeClass includeSubclasses: includeSubclasses includeSuperclasses: includeSuperclasses! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6959-findWithScope-PackageScope-HilaireFernandes-2024Dec30-13h04m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #6959] on 30 December 2024 at 9:56:55 pm'!
!CodeProvider methodsFor: 'testing' stamp: 'jmv 12/30/2024 21:54:06'!
        isEditingExistingMethod

	^self isEditingMethod! !
!Browser methodsFor: 'testing' stamp: 'jmv 12/30/2024 21:54:13' overrides: 50339763!
                        isEditingExistingMethod

	^editSelection = #editMessage! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/30/2024 21:56:51' prior: 50339690!
                               findMethodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"
	| searchString selection scopeClass scopeClassName includeSubclasses includeSuperclasses labelList package |
	
	searchString := StringRequestMorph
		request: 'Enter search text:'
		initialAnswer: self selectedString
		orCancel: [^self].
	
	scopeClass := self codeProvider selectedClass.
	scopeClassName := scopeClass name asString.
	includeSubclasses := false.
	includeSuperclasses := false.

	labelList := {
		'This method'. 
		'All methods in image'. } asOrderedCollection.
	(scopeClass notNil)
		ifTrue: [
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := self codeProvider isEditingExistingMethod
				ifTrue: [CodePackage packageOfMethod: self codeProvider currentCompiledMethod asMethodReference ifNone: []]
				ifFalse: [CodePackage packageOfClass: scopeClass ifNone: []].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
				
	selection := (SelectionMenu labelList: labelList selections: nil) startUpWithCaption: 'Search Scope'.

	(selection = 0) ifTrue:[^self].
	(selection = 1) "This method"
		ifTrue:[^self find: searchString].
	(selection = 2) "All methods in image"
		ifTrue:[scopeClass := nil].
	"(selection = 3) ifTrue:[]. ""Class only - nothing to do"
	(selection = 4) "Class and subclasses"
		ifTrue:[includeSubclasses := true].
	(selection = 5) "Class, subclasses, and superclasses"
		ifTrue:[
			includeSubclasses := true.
			includeSuperclasses := true].
	(selection = 6) "In my package if any "
		ifTrue: [^ Smalltalk browseMethodsWithSourceString: searchString in: package].
	Smalltalk browseMethodsWithSourceString: searchString scopeClass: scopeClass includeSubclasses: includeSubclasses includeSuperclasses: includeSuperclasses! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6960-FindWithScope-fix-HernanWilkinson-2024Dec30-21h54m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6960] on 31 December 2024 at 7:01:56 pm'!
!BrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/31/2024 19:00:05' prior: 16799999!
             classListMenuSpec
	"Spec for the menu and shortcut keys for the class list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Class List' 					false)
		#(10	'New Subclass' 				nil 	model 		makeNewSubclass 					classIcon 		'put a template into the code pane for defining of a subclass of this class')
		#(20	'Copy Class...' 				nil 	model 		copyClass 							copyIcon)
		#(30	'Delete (x)' 					$x 	model 		removeClass 						deleteIcon)
		#(40 	'-----')
		#(50	'Browse Hierarchy (h)' 		$h 	window 	browseHierarchy 					goTopIcon)
		#(60	'Full Browse (b)' 				$b 	window 	browseMethodFull 					editFindReplaceIcon)
		#(70	'Browse Protocol (p)' 			$p 	window 	browseFullProtocol 				spreadsheetIcon)
		#(80	'Browse Package' 			nil 	window 	browsePackage 					packageIcon)
		#(90 	'-----')
		#(100	'File Out' 					nil 	model 		fileOutClass 						fileOutIcon)
		#(110	'File Out (alphabetically)' 		nil 	model 		fileOutClassAlphabetically 			fileOutIcon)
		#(120	'Run Tests (t)' 				$t 	model 		runClassTests 						weatherFewCloudsIcon)
		#(130 	'-----')
		#(140	'Refactorings' 				nil 	nil 			1000 								listAddIcon)
		#(150 	'-----')
		#(160	'Show classes Hierarchically' 	nil model 		enableListClassesHierarchically 	goTopIcon)
		#(170	'Show classes Alphabetically' 	nil model 		enableListClassesAlphabetically 	sendReceiveIcon)
		#(180	'Show Definition' 				nil 	model 		editClass 							editFindReplaceIcon)
		#(190	'Show Comment' 			nil 	model 		editComment 						editFindReplaceIcon)
		#(200 	'-----')
		#(210	'Class References (N)' 		$N 	window 	browseClassRefs 					classIcon)
		#(220 	'-----')
		#(230	'More...' 					nil 	nil 			2000 								listAddIcon)

		"Shortcut only. No menu entry."
		#(991	nil 							$r 	model 		recent)

		" 'refactorings' SubMenu"
		#(1010	'Rename Class... (R)' 			$R 	model 		renameClass 						saveAsIcon)
		#(1020	'Insert Superclass...' 			nil 	model 		insertSuperclass 					saveAsIcon)
		#(1030 	'-----')
		#(1040	'Add Inst Var...' 				nil 	model 		addInstVar 							listAddIcon)
		#(1050	'Rename Inst Var...' 			nil 	model 		renameInstVar 						saveAsIcon)
		#(1060	'Remove Inst Var...' 			nil 	model 		removeInstVar 						deleteIcon)
		#(1070	'Remove all Unreferenced Inst Var...' nil model 	removeAllUnreferencedInstVar 	deleteIcon)
		#(1080	'Push Up Inst Var...' 			nil 	model 		pushUpInstanceVariable 			goTopIcon)
		#(1090	'Push Down Inst Var...' 		nil 	model 		pushDownInstanceVariable 		goBottomIcon)
		#(1100 	'-----')
		#(1110	'Rename Global...' 			nil 	model 		renameGlobal 						saveAsIcon)

		" 'more' SubMenu"
		#(2010	'Unsent Methods' 			nil 	window 	browseUnusedMethods 			junkIcon 			'browse all methods defined by this class that have no senders')
		#(2020	'Unreferenced inst Vars' 		nil 	window 	showUnreferencedInstVars 		junkIcon 			'show a list of all instance variables that are not referenced in methods')
		#(2030	'Unreferenced class Vars' 		nil 	window 	showUnreferencedClassVars 		junkIcon 			'show a list of all class variables that are not referenced in methods')
		#(2040 	'-----')
		#(2050	'Sample instance' 			nil 	window 	makeSampleInstance 				instanceIcon 		'give me a sample instance of this class, if possible')
		#(2060	'Inspect instances' 			nil 	window 	inspectInstances 					inspectIcon 		'open an inspector on all the extant instances of this class')
		#(2070	'Inspect subinstances' 		nil 	window 	inspectSubInstances 				inspectIcon 		'open an inspector on all the extant instances of this class and of all of its subclasses')
		#(2080 	'-----')
		#(2090	'Create inst var accessors' 	nil 	model 		createInstVarAccessors 			sendReceiveIcon 	'compile instance-variable access methods for any instance variables that do not yet have them')
	)! !
!BrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/31/2024 18:52:17' prior: 16800118!
                    messageCatListMenuSpec
	"Spec for the menu and shortcut keys for the method categories list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Message Categories' 			false)
		#(5		'Browse Package (p)' 				$p 	window 	browsePackage 						packageIcon)
		#(6		'-----')
		#(10	'File Out (o)' 						$o 	model 		fileOutMessageCategories 				fileOutIcon)
		#(20 	'-----')
		#(30	'Reorganize (r)' 					$r 	model 		editMessageCategories 				sendReceiveIcon)
		#(40	'Alphabetize (a)' 					$a 	model 		alphabetizeMessageCategories 		fontXGenericIcon)
		#(50	'Remove empty Categories (e)' 	$e 	model 		removeEmptyCategories 				listRemoveIcon)
		#(60	'Categorize all Uncategorized (c)' 	$c 	model 		categorizeAllUncategorizedMethods 	packageIcon)
		#(70	'New Category... (n)' 				$n 	model 		addCategory 							newIcon)
		#(80	'New extension Category... (N)' 	$N 	model 		addExtensionCategory 					listAddIcon)
		#(90 	'-----')
		#(100	'Refactorings' 					nil 	nil 			1000 									listAddIcon)
		#(110	'Rename... (R)' 					$R 	model 		renameCategory 						saveAsIcon)
		#(120	'Remove (x)' 					$x 	model 		removeMessageCategory 				deleteIcon)
		#(130 	'-----')
		#(140	'Run Tests (t)' 					$t 	model 		runMessageCategoryTests 			weatherFewCloudsIcon)

		" 'Refactorings' SubMenu"
		#(1010	'Push Up' 									nil 	model 	pushUpCategorySelectors 							goTopIcon)
		#(1020	'Add in Superclass as subclassResponsibility' 	nil	model 	addCategoryAsSubclassResponsibilitySelectors 	goTopIcon)
		#(1030	'Push Down to Subclasses' 					nil 	model 	pushDownCategorySelectorsToSubclasses 		goBottomIcon)
		#(1040	'Push Down to one Subclass' 					nil 	model 	pushDownCategorySelectorsToOneSubclass 		goBottomIcon)
	)! !
!BrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 12/31/2024 19:00:12' prior: 16800174!
                           messageListMenuSpec
	"Spec for the menu and shortcut keys for the messages list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Message List' 						false)
		#(10	'Browse Full (b)' 							$b 	window 	browseMethodFull 							editFindReplaceIcon)
		#(20	'Browse Hierarchy (h)' 					$h 	window 	browseHierarchy 							goTopIcon)
		#(30	'Browse Method (O)' 						$O 	window 	openSingleMessageBrowser 				scriptIcon)
		#(35	'Browse Package (p)' 						$p 	window 	browsePackage 							packageIcon)
		#(40 	'-----')
		#(50	'File Out' 								nil 	model 		fileOutMessage 							fileOutIcon)
		#(60	'Run Test (t)' 							$t 	model 		runMethodTest 							weatherFewCloudsIcon)
		#(70	'Debug Test (r)' 							$r 	model 		debugMethodTest 							weatherFewCloudsIcon)
		#(80	'Inspect CompiledMethod' 				nil 	model 		inspectCompiledMethod 					exploreIcon)
		#(90 	'-----')
		#(100	'Refactorings' 							nil 	nil 			1000 										listAddIcon)
		#(110	'Senders of... (n)' 						nil 	window 	browseSendersOfMessages 				mailForwardIcon)
		#(120	'Implementors of... (m)' 					nil 	window 	browseImplementorsOfMessages 			developmentIcon)
		#(130	'Inheritance (i)' 							$i 	window 	methodInheritance 						goDownIcon)
		#(140	'Versions (v)' 							$v 	window 	browseVersions 							clockIcon)
		#(150 	'-----')
		#(160	'Remove Method (x)' 						$x 	model 		removeMessage 							deleteIcon)
		#(170	'Remove Method in Hierarchy' 			nil 	model 		removeMessageInHierarchy 				deleteIcon)
		#(180	'More...' 								nil 	nil 			2000 										listAddIcon)

		"Shortcut only. No menu entry."
		#(991	nil 										$m 	window 	browseImplementors)
		#(992	nil 										$n 	window 	browseSenders)
		#(993	nil 										$c 	model 		copySelector)

		" 'refactorings' SubMenu"
		#(1010	'Rename... (R)' 							$R 	model 		renameSelector 							saveAsIcon)
		#(1020	'Change keyword Order...' 				nil 	model 		changeKeywordOrder 						sendReceiveIcon)
		#(1030	'Add Parameter... (A)' 					$A 	model 		addParameter 								listAddIcon)
		#(1040	'Remove Parameter... (S)' 				$S 	model 		removeParameter 							listRemoveIcon)
		#(1050 	'-----')
		#(1060	'Inline Method... (F)' 						$F 	model 		inlineMethod 								saveAsIcon)
		#(1070	'Move to Instance/Class Method' 			nil 	model 		moveToInstanceOrClassMethod 			changesIcon)
		#(1080	'Push Up' 								nil 	model 		pushUpSelector 							goTopIcon)
		#(1090	'Add in Superclass as subclassResponsibility' nil model 		addAsSubclassResponsibilitySelector 		goTopIcon)
		#(1100	'Push Down to Subclasses' 				nil 	model 		pushDownSelectorToSubclasses 			goBottomIcon)
		#(1110	'Push Down to One Subclass' 				nil 	model 		pushDownSelectorToOneSubclass 			goBottomIcon)

		" 'more' SubMenu"
		#(2010	'Local Senders of...' 						nil 	window 	browseLocalSendersOfMessages 			mailForwardIcon)
		#(2020	'Local Implementors of...' 					nil 	window 	browseLocalImplementorsOfMessages 	classIcon)
		#(2030 	'-----')
		#(2040	'Sample Instance' 						nil 	window 	makeSampleInstance 						instanceIcon)
		#(2050	'Inspect Instances' 						nil 	window 	inspectInstances 							inspectIcon)
		#(2060	'Inspect Subinstances' 					nil 	window 	inspectSubInstances 						inspectIcon)
		#(2070 	'-----')
		#(2080	'Change Category...' 						nil 	model 		changeCategory 							saveAsIcon)
		#(2090	'Select method Category (C)' 				$C 	model 		showHomeCategory 						editFindReplaceIcon)
		#(2100	'Change sets with this Method' 			nil 	window 	findMethodInChangeSets 					changesIcon)
		#(2110	'Revert to previous Version' 				nil 	model 		revertToPreviousVersion 					undoIcon)
	)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6961-MenuCaseConsistency-HernanWilkinson-2024Dec31-18h44m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #6961] on 1 January 2025 at 10:28:41 am'!
!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 1/1/2025 10:27:43' prior: 16971764!
                  copyright
	"The Cuis Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak project. 1997-2025.
Copyright (c) Contributors to Cuis Smalltalk project. 2009-2025.'.! !
!Utilities class methodsFor: 'default desktop' stamp: 'jmv 1/1/2025 10:28:19' prior: 16997398!
 defaultTextEditorContents
	^ ('
', 
('Cuis Smalltalk

' centered blue pointSize: FontFamily defaultPointSize * 3),
('
"Yay, Juan.  You GO, guy!! ...a great example of malleable software (and a clever mind) at work."
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('Dan Ingalls
' italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('
"I like it... It''s nice and clean and simple and pretty. Nice stuff!!"
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('Alan Kay
' italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('
"I think you have a very elegant design aesthetic."
' rightFlush pointSize: FontFamily defaultPointSize * 0.6),
('John Maloney
'italic rightFlush pointSize: FontFamily defaultPointSize * 0.6),
'

',
'Cuis is a modern, Open Source, multiplatform, Smalltalk-80 system.


',
'Cuis is:

' bold,
'    - Small
    - Clean
    - Appropriable
' blue,
'

Additionally, Cuis is:

' bold, 
'    - Open Source
    - Multiplatform
' blue,
'
 
Like other Smalltalk systems, Cuis is also:

' bold, 
'    - A complete development environment written in itself
    - A pure, dynamic Object Oriented language
' blue,
'

Cuis assumes very little on the underlying platform, and this lets it run out-of-the-box on Windows, macOS, Linux, ChromeOS and WebBrowsers. Cuis shares the [OpenSmalltalk Virtual Machine] (http://www.opensmalltalk.org) with Squeak, Pharo and Newspeak.

What sets Cuis apart from the other members of the Squeak family is the focus on Smalltalk-80 and an active attitude towards system complexity:

Unbound complexity growth, together with development strategies focused only in the short term, are the worst long term enemies of all software systems. As systems grow older, they usually become more complex. New features are added as layers on top of whatever is below, sometimes without really understanding it, and almost always without modifying it. Complexity and size grow without control. Evolution slows down. Understanding the system becomes harder every day. Bugs are harder to fix. Codebases become huge for no clear reason. At some point, the system can''t evolve anymore and becomes "legacy code".

Complexity puts a limit to the level of understanding of the system a person might reach, and therefore limits the things that can be done with it. Dan Ingalls says all this in ["Design Principles Behind Smalltalk"] (http://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html). Even if you have already done so, please go and read it again!!

Cuis Smalltalk is our attempt at this challenge. Furthermore, we believe we are doing something else that no other Smalltalk, commercial or open source, does. We attempt to give the true Smalltalk-80 experience, and keep Smalltalk-80 not as legacy software of historic significance, but as a live, evolving system. We feel we are the keepers of the Smalltalk-80 heritage, and enablers of the Dynabook experience.

As Cuis evolves, we keep on these values. Every update, be it a bug fix or a feature enhancement, is reviewed carefully to avoid adding unneeded complexity to the system. Every opportunity to remove unneeded complexity is followed. As we go, features are enhanced, and any reported bugs fixed. We also adopt selected enhancements from Squeak and Pharo, and share our work with the wider Smalltalk community.


' justified,
'License
' bold,
'
Cuis is distributed subject to the MIT License, as in http://www.opensource.org/licenses/mit-license.php . Any contribution submitted for incorporation into or for distribution with Cuis shall be presumed subject to the same license.

Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982
Copyright (c) Apple Computer, Inc. 1985-1996
Copyright (c) Contributors to Squeak project. 1997-2025
Copyright (c) Contributors to Cuis Smalltalk project. 2009-2025')! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6962-UpdateCopyrightNotice-JuanVuletich-2025Jan01-10h27m-jmv.001.cs.st----!

----QUIT----(2 January 2025 10:23:12) Cuis7.3-6962.image priorSource: 206!

----STARTUP---- (17 January 2025 10:30:48) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.3-6962.image!


'From Cuis7.3 [latest update: #6962] on 2 January 2025 at 4:01:10 pm'!

Random subclass: #XorShiftRandom
	instanceVariableNames: 'a b c mask last'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!

!classDefinition: #XorShiftRandom category: #'Kernel-Numbers' stamp: 'Install-6963-XorShiftRandom-JuanVuletich-2025Jan02-16h00m-jmv.001.cs.st 1/17/2025 10:30:48'!
Random subclass: #XorShiftRandom
	instanceVariableNames: 'a b c mask last'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Numbers'!
!XorShiftRandom commentStamp: '<historical>' prior: 0!
          I implement XorShift pseudo random number generators invented by George Marsaglia.
See https://en.wikipedia.org/wiki/Xorshift . Paper at https://www.jstatsoft.org/article/view/v008i14/916
Most implementations hardcode the a, b, c parameters, and work either on 32 or 64 bit space.
This one allows chosing them. Still, a and c are right shifts and b is a left shift.!
!XorShiftRandom methodsFor: 'accessing' stamp: 'jmv 1/2/2025 14:51:42'!
         nextInteger
	last := last bitXor: (last bitShift: a).
	last := last bitXor: ((last bitShift: b) bitAnd: mask).
	last := last bitXor: (last bitShift: c).
	^last! !
!XorShiftRandom methodsFor: 'initialization' stamp: 'jmv 1/2/2025 14:58:45'!
                a: firstShift b: secondShift c: thirdShift bits: bitsSize

	(firstShift < 0 and: [ secondShift > 0 and: [ thirdShift < 0 ]]) ifFalse: [
		self error: 'Invalid XorShift parameters' ].

	a := firstShift.
	b := secondShift.
	c := thirdShift.
	mask := (2 raisedToInteger: bitsSize) - 1.
	last := 1 bitAnd: mask. "If any other value is used, ensure it is not larger than mask"! !
!XorShiftRandom methodsFor: 'initialization' stamp: 'jmv 1/2/2025 14:58:05' overrides: 16936573!
        seed: aNumber
	last := aNumber.
	mask ifNotNil: [ last := last bitAnd: mask ].! !
!XorShiftRandom methodsFor: 'private' stamp: 'jmv 1/2/2025 15:48:40' overrides: 16936565!
                    nextChunkBits
	^self nextInteger! !
!XorShiftRandom methodsFor: 'private' stamp: 'jmv 1/2/2025 15:49:55' overrides: 16936569!
  nextChunkSize
	^(mask + 1) log2! !
!XorShiftRandom class methodsFor: 'instance creation' stamp: 'jmv 1/2/2025 15:45:18'!
       a: firstShift b: secondShift c: thirdShift bits: bitsSize
	^self basicNew a: firstShift b: secondShift c: thirdShift bits: bitsSize! !
!XorShiftRandom class methodsFor: 'instance creation' stamp: 'jmv 1/2/2025 15:51:58' overrides: 16936587!
               seed: anInteger
	| answer |
	answer := self a: -2 b: 7 c: -3 bits: 22.
	answer seed: anInteger.
	^answer! !
!XorShiftRandom class methodsFor: 'visualizations' stamp: 'jmv 1/2/2025 15:01:01'!
 display22BitsBlackWhite
	"
	self display22BitsBlackWhite
	"
	| bits f generator h w |
	generator := XorShiftRandom a: -2 b: 7 c: -3 bits: 22.
	w := 2048.
	h := 2048.
	bits := ByteArray new: w*h // 8.
	f := Form extent: w@h depth: 1 bits: bits.
	bits atAllPut: 0.
	(2 raisedTo: 22)-1 timesRepeat: [
		bits bitAt: generator nextInteger put: 1.
		Random next > 0.9999 ifTrue: [
			f display. Display forceToScreen ]].
	f display. Display forceToScreen.! !
!XorShiftRandom class methodsFor: 'visualizations' stamp: 'jmv 1/2/2025 15:02:23'!
        display22BitsColor
	"
	self display22BitsColor
	"
	| bits f generator h w |
	generator := XorShiftRandom a: -2 b: 7 c: -3 bits: 22.
	w := 512.
	h := 512.
	bits := ByteArray new: w*h *16 // 8.
	f := Form extent: w@h depth: 16 bits: bits.
	f fillColor: Color black.
	(2 raisedTo: 22)-1 timesRepeat: [
		bits bitAt: generator nextInteger put: 1.
		Random next > 0.9999 ifTrue: [
			f display. Display forceToScreen ]].
	f display. Display forceToScreen.! !
!XorShiftRandom class methodsFor: 'parameter search' stamp: 'jmv 1/2/2025 15:07:58'!
     lookFor22BitCandidateParameters
	"XorShift pseudo Random Number Generator. See https://en.wikipedia.org/wiki/Xorshift
	IdentityHash is a 22 bit number. It is easy to find documented parameters for XorShift covering the whole 32 and 64 bit spaces.
	1. But we need to cover the 22 bit space. The following script lists a set of such parameters.
	Explore parameter space to find (a, b, c) parameters that generate all possible hashes (implying a period = hashMask).
	self lookFor22BitCandidateParameters
	"
	| generator value differentValues expectedDifferentValues |
	expectedDifferentValues := (2 raisedTo: 22) - 1.
	-9 to: -1 do: [ :a |
		1 to: 8 do: [ :b |
			-7 to: -1 do: [ :c |
				generator := XorShiftRandom a: a b: b c: c bits: 22.
				differentValues := Set new.
				[
					value := generator nextInteger.
					differentValues includes: value ]
				whileFalse: [
					differentValues add: value ].
				differentValues size = expectedDifferentValues ifTrue: [
					{a. b. c} print ]]]].! !
!XorShiftRandom class methodsFor: 'parameter search' stamp: 'jmv 1/2/2025 15:39:29'!
      pickBest22BitHashParameters
	"When using this RNG for generating hashes, the next problem we face is that generally we'll not be using the full hash.
	For smaller collections, only the rest of the division by the collection size is actually used.
	For each of the candidates found in #lookFor22BitCandidateParameters, try the rest of the division by 2^k (i.e. take AND with a smaller 'evaluatedMask' and see how many distinct hashes of this size can be generated.
	List those than yield at least half of the full k bits space.
	self pickBest22BitHashParameters
	"
	| candidates |
	candidates := {
		#(-9 5 -7).
		#(-9 5 -3).
		#(-7 7 -3).
		#(-5 3 -2).
		#(-3 7 -7).
		#(-3 7 -2).
		#(-2 3 -5).
		#(-2 7 -3).
	}.
	candidates do: [ :abc |
		| fractions |
		fractions := OrderedCollection new.
		1 to: 21 do: [ :usedMaskSize |
				| evaluatedMask generator hash hashes |
				evaluatedMask := (2 raisedTo: usedMaskSize) - 1.
				generator := XorShiftRandom a: abc first b: abc second c: abc third bits: 22.
				hashes := Set new.
				evaluatedMask timesRepeat: [
					hash := generator nextInteger bitAnd: evaluatedMask.
					hashes add: hash ].
				fractions add: (hashes size / evaluatedMask asFloat) ].
			(fractions min > 0.5 ) ifTrue: [
				{abc. fractions min. fractions average} print ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6963-XorShiftRandom-JuanVuletich-2025Jan02-16h00m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 4:22:57 pm'!
!WorldMorph methodsFor: 'canvas' stamp: 'jmv 1/3/2025 16:22:52' prior: 17008987!
                          recordDamagedRect: damageRect for: aMorph

	damageRect hasPositiveExtent ifFalse: [ ^self ].

	damageRecorder ifNotNil: [
		damageRecorder recordInvalidRect: damageRect for: aMorph ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6964-recordDamageRect-tweak-JuanVuletich-2025Jan03-16h22m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 4:40:41 pm'!
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:39:08' overrides: 16906216!
                               extentChanged: oldExtent
	"Our extent changed.
	- Reposition adjusters
	- Resize our layoutMorph"

	| h thickness w cornerExtent wh ww pos halfThickness |
	thickness := self borderWidth.
	halfThickness := thickness * 0.5.
	cornerExtent := thickness * 5.
	ww := extent x.
	wh := extent y.
	w := ww - cornerExtent - cornerExtent.
	h := wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) position: cornerExtent@halfThickness extent: w@0.
	(adjusters at: #bottomAdjuster) position: cornerExtent@(wh-halfThickness) extent: w@0.
	(adjusters at: #leftAdjuster) position: halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #rightAdjuster) position: ww-halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #topLeftAdjuster) position: `0@0` extent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster) position: ww-cornerExtent@0 extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster) position: 0@(wh-cornerExtent) extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster) position: ww@wh-cornerExtent extent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		pos := borderWidth @ (borderWidth + self labelHeight).
		layoutMorph
			position: pos
			extent: extent - pos - borderWidth ].! !

SystemWindow removeSelector: #layoutSubmorphs!

!methodRemoval: SystemWindow #layoutSubmorphs stamp: 'Install-6965-SystemWindows-dontLayoutButAdjustOnExtentChange-JuanVuletich-2025Jan03-16h22m-jmv.001.cs.st 1/17/2025 10:30:48'!
layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww pos halfThickness |
	thickness := self borderWidth.
	halfThickness := thickness * 0.5.
	cornerExtent := thickness * 5.
	ww := extent x.
	wh := extent y.
	w := ww - cornerExtent - cornerExtent.
	h := wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) position: cornerExtent@halfThickness extent: w@0.
	(adjusters at: #bottomAdjuster) position: cornerExtent@(wh-halfThickness) extent: w@0.
	(adjusters at: #leftAdjuster) position: halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #rightAdjuster) position: ww-halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #topLeftAdjuster) position: `0@0` extent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster) position: ww-cornerExtent@0 extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster) position: 0@(wh-cornerExtent) extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster) position: ww@wh-cornerExtent extent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		pos := borderWidth @ (borderWidth + self labelHeight).
		layoutMorph
			position: pos
			extent: extent - pos - borderWidth ].

	self layoutNeeded: false.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6965-SystemWindows-dontLayoutButAdjustOnExtentChange-JuanVuletich-2025Jan03-16h22m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 4:53:24 pm'!
!BoxMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:50:57' overrides: 16906216!
                   extentChanged: oldExtent
	"Our extent changed. oldExtent is provided in case it is useful."! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:49:14' overrides: 50340611!
         extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	self layoutNeeded: true.! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 1/3/2025 16:42:25' overrides: 16907322!
                               layoutSubmorphsIfNeeded
	"Recompute the layout if necessary."

	self isLayoutNeeded ifTrue: [
		self layoutSubmorphs ].! !
!Morph methodsFor: 'layout' stamp: 'jmv 1/3/2025 16:42:37' prior: 16907322!
                         layoutSubmorphsIfNeeded
	"Recompute the layout if necessary.
	NOP by default"! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:51:11' prior: 16924804 overrides: 50340611!
                              extentChanged: oldExtent
	"Our extent changed."

	super extentChanged: oldExtent.
	icon ifNotNil: [
		magnifiedIcon := nil ]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:51:49' prior: 16923048 overrides: 50340611!
                       extentChanged: oldExtent
	"Our extent changed."

	super extentChanged: oldExtent.
	self buildMagnifiedBackgroundImage.! !
!LayoutSpec methodsFor: 'private' stamp: 'jmv 1/3/2025 16:46:43' prior: 16892709!
                    updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LayoutMorph) ifTrue:
			owningLayout layoutSubmorphs ].! !

Morph removeSelector: #extentChanged:!

!methodRemoval: Morph #extentChanged: stamp: 'Install-6966-OnlyBoxBorphsChangeExtent-OnlyLayoutMorphsDoLayout-JuanVuletich-2025Jan03-16h40m-jmv.001.cs.st 1/17/2025 10:30:48'!
extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	self layoutNeeded: true.!

Morph removeSelector: #layoutSubmorphs!

!methodRemoval: Morph #layoutSubmorphs stamp: 'Install-6966-OnlyBoxBorphsChangeExtent-OnlyLayoutMorphsDoLayout-JuanVuletich-2025Jan03-16h40m-jmv.001.cs.st 1/17/2025 10:30:48'!
layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."
	"Only specific subclasses do layout. They redefine this method.
	Remember to call super, or set layoutNeeded ivar to false!!"

	self layoutNeeded: false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6966-OnlyBoxBorphsChangeExtent-OnlyLayoutMorphsDoLayout-JuanVuletich-2025Jan03-16h40m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 5:01:41 pm'!
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:55:32' overrides: 16907368!
       someSubmorphPositionOrExtentChanged
	"Some submorph changed at any nested level.
	Must layout submorphs again."

	super someSubmorphPositionOrExtentChanged.
	self layoutNeeded: true.! !
!Morph methodsFor: 'layout' stamp: 'jmv 1/3/2025 16:55:41' prior: 16907368!
                          someSubmorphPositionOrExtentChanged
	"Some submorph changed at any nested level."

	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 1/3/2025 17:00:00' prior: 16891319!
                        layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: [].
	
	direction == #horizontal ifTrue: [
		self layoutSubmorphsHorizontallyIn: self layoutBounds ].

	direction == #vertical ifTrue: [
		self layoutSubmorphsVerticallyIn: self layoutBounds ].

	self layoutNeeded: false.! !
!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:57:10' prior: 16874978 overrides: 16926593!
                      someSubmorphPositionOrExtentChanged
	"Our extent, or some submorph changed. Must layout submorphs again."

	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	self updateScrollBarsBounds! !
!PluggableListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 16:57:29' prior: 16925354 overrides: 16926593!
      someSubmorphPositionOrExtentChanged
	"Our extent, or some submorph changed. Must layout submorphs again."

	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	self updateScrollBarsBounds! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6967-OnlyLayoutMorphDoLayout-JuanVuletich-2025Jan03-16h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6963] on 3 January 2025 at 5:11:13 pm'!
!Morph methodsFor: 'layout' stamp: 'jmv 1/3/2025 17:11:04' prior: 50340703!
                           someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Some Morph classes need to adjust for that."! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:19' prior: 50340694 overrides: 50340756!
                       someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	self layoutNeeded: true.! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:24' prior: 16926593 overrides: 50340756!
   someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	scroller ifNotNil: [ | scrollerLocation doIt |
		doIt := false.
		scroller hasVariableExtent ifTrue: [
			theScrollerExtent = scroller extentInOwner ifFalse: [
				theScrollerExtent := scroller extentInOwner.
				doIt := true ]].
		scrollerLocation := scroller location.
		scrollerScale = scrollerLocation scale ifFalse: [
			scrollerScale := scrollerLocation scale.
			doIt := true ].
		scrollerRadians = scrollerLocation radians ifFalse: [
			scrollerRadians := scrollerLocation radians.
			doIt := true ].
		doIt ifTrue: [ self setScrollDeltas ]].! !
!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:28' prior: 50340729 overrides: 50340772!
                   someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Scrollbars are likely affected."

	self updateScrollBarsBounds! !
!PluggableListMorph methodsFor: 'geometry' stamp: 'jmv 1/3/2025 17:09:33' prior: 50340739 overrides: 50340772!
                              someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Scrollbars are likely affected."

	self updateScrollBarsBounds! !
!InnerTextMorph methodsFor: 'notifications' stamp: 'jmv 1/3/2025 17:09:38' prior: 16882626 overrides: 50340756!
                             someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	textComposition ifNotNil: [ 
		textComposition composeAll.
		self fit.
		self selectionChanged ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6968-someSubmorphPositionOrExtentChanged-justOneLevel-JuanVuletich-2025Jan03-17h01m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6968] on 6 January 2025 at 3:21:23 pm'!
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:17:20'!
 coreMethodsDo: aBlock
	self classesDo: [ :cls |
		self coreMethodsOf: cls do: aBlock.
		self coreMethodsOf: cls class do: aBlock ].! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:32:58'!
                      extensionMethodsDo: aBlock
	"Include both class and instance methods we define, for classes we don't define."

	self externalClasses do: [ :classOrMetaClass |
		(self extensionCategoriesForClass: classOrMetaClass) do: [ :cat |
			self methodsInCategory: cat ofClass: classOrMetaClass do: [ :m |
				aBlock value: m ]]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:35:34'!
                           methodsDo: aBlock
	self coreMethodsDo: [ :methodRef |
		methodRef isValid ifTrue: [ aBlock value: methodRef ]].
	self extensionMethodsDo: [ :methodRef |
		methodRef isValid ifTrue: [ aBlock value: methodRef ]].! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:36:49'!
                        extensionMethodCount

	| sum |
	sum := 0.
	self extensionMethodsDo: [ :each |
		sum := sum + 1 ].
	^sum! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:25:16'!
   methodCount

	| sum |
	sum := 0.
	self methodsDo: [ :each |
		sum := sum + 1 ].
	^sum! !
!CodePackageList methodsFor: 'accessing' stamp: 'jmv 1/6/2025 12:37:41' prior: 16824930!
              summary

	| count |
	selection ifNil: [ ^'' ].
	^ String streamContents: [ :strm |
		| methods  linesOfCode |
		strm
			nextPutAll: 'Package: ';
			nextPutAll: selection packageName;
			nextPutAll: ' -- ';
			nextPutAll: selection sourceSystem.
		strm nextPutAll: ' -- Number of system categories '.
		selection systemCategories size printOn: strm.
		strm nextPutAll: '.'.
		strm nextPutAll: ' -- Number of classes: '.
		count := 0.
		selection classesDo: [ :cls | count := count + 1 ].
		count printOn: strm.
		strm nextPutAll: '. Number of extension methods: '.
		selection extensionMethodCount printOn: strm.
		strm nextPutAll: '. Total number of methods: '.
		methods := selection methodCount.
		methods printOn: strm.
		strm nextPutAll: '. Total lines of code: '.
		linesOfCode := selection linesOfCode.
		linesOfCode printOn: strm.
		strm nextPutAll: ' ('.
		linesOfCode / (methods asFloat max: 1.0) printOn: strm fractionDigits: 2.
		strm nextPutAll: ' per method)'.
		strm nextPutAll: '. Total message sends: '.
		linesOfCode := selection messageSendsCount.
		linesOfCode printOn: strm ]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:20:46' prior: 16823841!
  coreMethods
	^Array streamContents: [ :strm |
		self coreMethodsDo: [ :methodRef |
			strm nextPut: methodRef ]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:34:04' prior: 16823862!
                         extensionMethods
	"Include both class and instance methods we define, for classes we don't define."
	^Array streamContents: [ :stream |
		self extensionMethodsDo: [ :methodRef |
			stream nextPut: methodRef ]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:39:48' prior: 16823876!
                        methods

	^Array streamContents: [ :strm |
		self extensionMethodsDo: [ :methodRef |
			methodRef isValid ifTrue: [ strm nextPut: methodRef ]].
		self coreMethodsDo: [ :methodRef |
			methodRef isValid ifTrue: [ strm nextPut: methodRef ]]]! !
!CodePackage methodsFor: 'listing' stamp: 'jmv 1/6/2025 12:29:01' prior: 16823881!
                          selectors

	^ Array streamContents: [ :strm |
		self methodsDo: [ :ea | strm nextPut: ea methodSymbol ]]! !
!CodePackage methodsFor: 'testing' stamp: 'jmv 1/6/2025 12:27:34' prior: 16823992!
 includesAnyCode
	self classesDo: [ :cls |
		^true ].
	self methodsDo: [ :cls |
		^true ].
	^false! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:24:29' prior: 16824109!
                         linesOfCode
	"An approximate measure of lines of code.
	Does not includes comments, or excludes blank lines.
	See comment at CompiledMethod >> #linesOfCode"

	| sum |
	sum := 0.
	self methodsDo: [ :each |
		sum := sum + each compiledMethod linesOfCode ].
	^sum! !
!CodePackage methodsFor: 'source code management' stamp: 'jmv 1/6/2025 12:27:02' prior: 16824120!
                      messageSendsCount
	"See comment at CompiledMethod >> #messageSendsCount"

	| sum |
	sum := 0.
	self methodsDo: [ :each |
		sum := sum + each compiledMethod messageSendsCount ].
	^sum! !
!CodePackage class methodsFor: 'packages access' stamp: 'jmv 1/6/2025 12:36:13' prior: 16824447!
     register: aCodePackage
	"
	Usually call #named:createIfAbsent:registerIfNew: instead
	CodePackage register: (CodePackage newNamed: 'Tests-Files')
	"
	| any base |
	self installedPackages at: aCodePackage packageName put: aCodePackage.

	"Anything that now belongs in this package, was moved out of the base system!!"
	base := ChangeSet changeSetForBaseSystem.
	any := false.
	aCodePackage classesDo: [ :cls |
		any := true.
		base noteClassMoveToOtherPackage: cls ].
	aCodePackage extensionMethodsDo: [ :methodReference |
		methodReference isValid ifTrue: [
			any := true.
			base
				noteMethodMoveToOtherPackage: methodReference selector
				forClass: methodReference actualClass ]].
	any ifTrue: [
		aCodePackage hasUnsavedChanges: true ].

	self triggerEvent: #installedPackagesChanged! !

CodePackage removeSelector: #coreMethodsForClass:!

!methodRemoval: CodePackage #coreMethodsForClass: stamp: 'Install-6969-CodePackage-refactor-JuanVuletich-2025Jan06-15h18m-jmv.001.cs.st 1/17/2025 10:30:48'!
coreMethodsForClass: aClass
	^ (aClass selectors difference:
		((self foreignExtensionMethodsForClass: aClass) collect: [:r | r methodSymbol]))
			asArray collect: [:sel | self referenceForMethod: sel ofClass: aClass]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6969-CodePackage-refactor-JuanVuletich-2025Jan06-15h18m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6962] on 4 January 2025 at 9:03:45 am'!
!CodeWindow methodsFor: 'GUI building' stamp: 'RMV 1/4/2025 09:01:58' prior: 16826573!
                       buildMorphicAnnotationsPane

	| aTextMorph |
	aTextMorph := (TextModelMorph
		textProvider: model
		textGetter: #annotation) emptyTextDisplayMessage: 'Class or method annotation (not selected?)'.
	aTextMorph disableEditing.
	model when: #annotationChanged send: #refetch to: aTextMorph model.
	model when: #decorateButtons send: #decorateButtons to: self.
	aTextMorph
		askBeforeDiscardingEdits: false;
		hideScrollBarsIndefinitely.
	^aTextMorph! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6970-DisableEditingInAnnotationsPane-MarkVolkmann-2025Jan04-09h01m-RMV.001.cs.st----!

'From Cuis7.3 [latest update: #6970] on 6 January 2025 at 6:54:34 pm'!
!FinalizationRegistry methodsFor: 'removing' stamp: 'jmv 1/6/2025 18:47:15' overrides: 16847673!
        remove: anObject
	"Does NOT run finalization."
	self removeKey: anObject! !
!FinalizationRegistry methodsFor: 'removing' stamp: 'jmv 1/6/2025 18:47:19' overrides: 16847677!
                   remove: anObject ifAbsent: exceptionBlock
	"Does NOT run finalization."
	self removeKey: anObject ifAbsent: exceptionBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6971-FinalizationRegistry-remove-removeifAbsent-JuanVuletich-2025Jan06-18h41m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6970] on 6 January 2025 at 4:23:28 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 1/6/2025 16:23:07' prior: 50339273!
    knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jpb' 						'Josef Philip Bernhart')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wbsl'						'Wéslleymberg Lisboa')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6972-AddJosefAsKnownAuthor-JuanVuletich-2025Jan06-16h23m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6971] on 8 January 2025 at 5:42:23 pm'!

Ephemeron removeSelector: #container!

!methodRemoval: Ephemeron #container stamp: 'Install-6973-Cleanup-JuanVuletich-2025Jan08-17h41m-jmv.001.cs.st 1/17/2025 10:30:48'!
container
	"Answer the Dictionary containing the receiver, if any."
	^container!

Ephemeron removeSelector: #isEphemeron!

!methodRemoval: Ephemeron #isEphemeron stamp: 'Install-6973-Cleanup-JuanVuletich-2025Jan08-17h41m-jmv.001.cs.st 1/17/2025 10:30:48'!
isEphemeron
	^true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6973-Cleanup-JuanVuletich-2025Jan08-17h41m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6973] on 10 January 2025 at 10:02:05 am'!

Smalltalk renameClassNamed: #WeakSet as: #OldWeakSet!

!classRenamed: #WeakSet as: #OldWeakSet stamp: 'Install-6974-RenameWeakSetAsOldWeakSet-JuanVuletich-2025Jan10-10h00m-jmv.004.cs.st 1/17/2025 10:30:48'!
Smalltalk renameClassNamed: #WeakSet as: #OldWeakSet!

Smalltalk renameClassNamed: #WeakIdentitySet as: #OldWeakIdentitySet!

!classRenamed: #WeakIdentitySet as: #OldWeakIdentitySet stamp: 'Install-6974-RenameWeakSetAsOldWeakSet-JuanVuletich-2025Jan10-10h00m-jmv.004.cs.st 1/17/2025 10:30:48'!
Smalltalk renameClassNamed: #WeakIdentitySet as: #OldWeakIdentitySet!
!WorldMorph methodsFor: 'errors on draw' stamp: 'jmv 1/10/2025 10:01:18' prior: 17009171!
                  removeAllKnownFailing
	drawingFailingMorphs do: [ :m | m redrawNeeded ].
	drawingFailingMorphs := OldWeakIdentitySet new.
! !
!WorldMorph methodsFor: 'initialization' stamp: 'jmv 1/10/2025 10:01:18' prior: 17009314 overrides: 16832614!
                    initialize

	super initialize.
	activeHand := HandMorph new.
	damageRecorder := DamageRecorder new.
	stepList := Heap sortBlock: self stepListSortBlock.
	alarms := Heap sortBlock: self alarmSortBlock.
	lastAlarmTime := 0.
	deferredUIMessages := SharedQueue new.
	drawingFailingMorphs := OldWeakIdentitySet new.
	pause := 20.
	lastCycleTime := Time localMillisecondClock.
	lastCycleHadAnyEvent := false! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6974-RenameWeakSetAsOldWeakSet-JuanVuletich-2025Jan10-10h00m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6973] on 10 January 2025 at 10:03:16 am'!

Set removeSelector: #withArray:!

!methodRemoval: Set #withArray: stamp: 'Install-6975-cleanup-JuanVuletich-2025Jan10-10h02m-jmv.004.cs.st 1/17/2025 10:30:48'!
withArray: anArray
	"private -- for use only in copy"
	array := anArray!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6975-cleanup-JuanVuletich-2025Jan10-10h02m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6976] on 12 January 2025 at 9:41:18 am'!
!Set methodsFor: 'lookup' stamp: 'jmv 1/10/2025 10:48:11'!
                     lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise."

	^ array at: (self findElementOrNil: anObject).! !
!Dictionary methodsFor: 'testing' stamp: 'jmv 1/10/2025 10:48:44' overrides: 50341414!
              lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise."

	self do: [:each | anObject = each ifTrue: [^each]].
	^nil! !
!Set methodsFor: 'lookup' stamp: 'jmv 1/10/2025 10:49:13' prior: 16950673 overrides: 16828650!
                           includes: anObject 
	^ (self lookup: anObject) ~~ nil! !
!OldWeakSet methodsFor: 'public' stamp: 'jmv 1/10/2025 10:49:49' prior: 17007377 overrides: 50341431!
 includes: anObject 
	^ (self lookup: anObject) ~~ flag! !

Dictionary removeSelector: #includes:!

!methodRemoval: Dictionary #includes: stamp: 'Install-6976-Refactor-JuanVuletich-2025Jan12-09h40m-jmv.004.cs.st 1/17/2025 10:30:48'!
includes: anObject 
	self do: [:each | anObject = each ifTrue: [^true]].
	^false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6976-Refactor-JuanVuletich-2025Jan12-09h40m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6976] on 12 January 2025 at 9:46:33 am'!
!SymbolSet methodsFor: 'lookup' stamp: 'jmv 1/10/2025 11:35:59'!
     add: anObject
	"Include anObject as one of the receiver's elements, but only if
	not already present. Answer anObject."
	
	| hash |
	hash := anObject hash.
	(self basicLookup: anObject withHash: hash) ifNil: [
		self basicAdd: anObject withHash: hash ].
	^anObject! !
!SymbolSet methodsFor: 'lookup' stamp: 'jmv 1/10/2025 11:54:12'!
                   lookup: anObject ifAbsentAddFrom: aBlock
	"Look for an element equal to anObject.
	If found, answer it.
	If not found, evaluate aBlock, add the result and answer it."
	
	| newObject |
	^(self lookup: anObject) ifNil: [
		newObject := aBlock value.
		self basicAdd: newObject withHash: newObject hash.
		newObject ].! !
!Symbol class methodsFor: 'instance creation' stamp: 'jmv 1/10/2025 11:53:15' prior: 16962895!
  intern: aStringOrSymbol

	^self accessProtect critical:
		[
			Symbols lookup: aStringOrSymbol ifAbsentAddFrom:
				[
					| preferByteStringForAscii |
					aStringOrSymbol isSymbol
						ifTrue: [ aStringOrSymbol ]
						ifFalse: [
							preferByteStringForAscii := aStringOrSymbol.
							(aStringOrSymbol isUnicodeString and: [ aStringOrSymbol isAscii ])
								ifTrue: [preferByteStringForAscii := aStringOrSymbol asByteString].
							preferByteStringForAscii class symbolClassToUse basicFromString: preferByteStringForAscii ].
				]
			].! !
!SymbolSet methodsFor: 'private' stamp: 'jmv 1/10/2025 11:16:10' prior: 16963096!
        rehashSymbolClass: aClass
"quisiera eliminar"
	aClass allInstances do:
		[:symbol | self basicInternNew: symbol withHash: symbol hash]! !
!SymbolSet methodsFor: 'private - lookup' stamp: 'jmv 1/10/2025 11:16:05' prior: 16963139!
                           basicInternNew: aStringOrSymbol withHash: anInteger
"quisiera eliminar"
	| interned preferByteStringForAscii |
	interned := aStringOrSymbol isSymbol
		ifTrue: [ aStringOrSymbol ]
		ifFalse: [
			preferByteStringForAscii := aStringOrSymbol.
			(aStringOrSymbol isUnicodeString and: [ aStringOrSymbol isAscii ])
				ifTrue: [preferByteStringForAscii := aStringOrSymbol asByteString].
			preferByteStringForAscii class symbolClassToUse basicFromString: preferByteStringForAscii ].
	self basicAdd: interned withHash: anInteger.
	^interned! !

SymbolSet removeSelector: #basicIntern:withHash:!

!methodRemoval: SymbolSet #basicIntern:withHash: stamp: 'Install-6977-SymbolSet-Refactor-JuanVuletich-2025Jan12-09h41m-jmv.004.cs.st 1/17/2025 10:30:48'!
basicIntern: aString withHash: anInteger
	"Look up again due to possible race conditions"

	| answer |
	answer := self basicLookup: aString withHash: anInteger.
	answer notNil ifTrue: [^answer].
	^self basicInternNew: aString withHash: anInteger!

SymbolSet removeSelector: #intern:!

!methodRemoval: SymbolSet #intern: stamp: 'Install-6977-SymbolSet-Refactor-JuanVuletich-2025Jan12-09h41m-jmv.004.cs.st 1/17/2025 10:30:48'!
intern: aString

	| hash lookup |
	hash := aString hash.
	lookup := self basicLookup: aString withHash: hash.
	lookup notNil ifTrue: [^lookup].
	^self basicIntern: aString withHash: hash.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6977-SymbolSet-Refactor-JuanVuletich-2025Jan12-09h41m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #6977] on 15 January 2025 at 9:40:31 am'!

Collection subclass: #WeakSet
	instanceVariableNames: 'buckets estimatedSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!

!classDefinition: #WeakSet category: #'Collections-Unordered' stamp: 'Install-6978-WeakSet-WeakIdentitySet-JuanVuletich-2025Jan15-09h37m-jmv.001.cs.st 1/17/2025 10:30:48'!
Collection subclass: #WeakSet
	instanceVariableNames: 'buckets estimatedSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!
!WeakSet commentStamp: 'jmv 1/15/2025 09:20:40' prior: 0!
An implementation of WeakSet that gives food performance for large instances.

It is implemented as a two level hash table. The outer level is a closed hash table, and is accessed using the higher bits of each element's hash value. At each position a Bucket is stored.

The lower bits of the hash are used to acess each Bucket. The buckets for an open hash table. Each bucket has a fixed size for direct access using the hash, and after it, a variable size area to store elements with duplicated (partial) hashes.

Currently, the Buckets use 8 positions for O(1) direct access using the lower 3 bits of the hash. The iterable part after it can grow as needed.

Buckets are WeakArrays.

The idea for small WeakArrays as buckets is from a previous SymbolSet by Andrés Valloud.
The idea of buckets having a direct access part, and an variable sized overflow part for (partial) hash collisions is from Juan Vuletich, specific for this class.

Note: An implementations using these ideas, could be good for Set et al.
Note: Perhaps a three level table, with a fixed size outer level, and where the mid level arrays grow as needed, could further improve performance for very large collections.!

WeakSet subclass: #WeakIdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!

!classDefinition: #WeakIdentitySet category: #'Collections-Unordered' stamp: 'Install-6978-WeakSet-WeakIdentitySet-JuanVuletich-2025Jan15-09h37m-jmv.001.cs.st 1/17/2025 10:30:48'!
WeakSet subclass: #WeakIdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Unordered'!
!WeakIdentitySet commentStamp: 'jmv 1/13/2025 09:10:25' prior: 0!
   See class comment at WeakSet.

This subclass only differs from it in using #== and #identityHash instead of #= and #hash.!
!WeakSet methodsFor: 'accessing' stamp: 'jmv 1/13/2025 13:08:52'!
   estimatedSize
	"Actual size may be less: as our references to elements are weak, elements could vanish anytime."

	^estimatedSize! !
!WeakSet methodsFor: 'accessing' stamp: 'jmv 1/12/2025 18:05:02' overrides: 16827542!
     size

	^buckets inject: 0 into: [ :prev :bucket | bucket ifNil:[prev] ifNotNil: [(bucket count: [:s | s notNil]) + prev ]]! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/13/2025 13:11:00' overrides: 16827586!
   add: newObject
	"Include newObject as one of the receiver's elements, but only if
	not already present.
	Answer newObject (even if another, but equal, object is already included)."

	| hash |
	hash := self hashFor: newObject.
	(self basicLookup: newObject withHash: hash) ifNil: [
		self basicAdd: newObject withHash: hash ].
	^newObject! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/10/2025 10:10:53' overrides: 16827595!
            add: newObject withOccurrences: anInteger
	^ self add: newObject! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/10/2025 10:55:11' overrides: 16828650!
                             includes: anObject 
	^ (self lookup: anObject) ~~ nil! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/11/2025 10:14:21'!
                            lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise.
	Note: The hash will be used several times, and it may be expensive. Ask for it just once."

	^self basicLookup: anObject withHash: (self hashFor: anObject)! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/11/2025 10:22:07'!
               lookup: anObject ifAbsentAddFrom: aBlock
	"Look for an element equal to anObject.
	If found, answer it.
	If not found, evaluate aBlock, add the result and answer it.
	Note: Do NOT add anObject to the Set!!"
	
	| newObject |
	^(self lookup: anObject) ifNil: [
		newObject := aBlock value.
		self basicAdd: newObject withHash: (self hashFor: newObject).
		newObject ].! !
!WeakSet methodsFor: 'adding and finding' stamp: 'jmv 1/10/2025 10:21:45' overrides: 16828730!
               occurrencesOf: anObject
	^ (self includes: anObject) ifTrue: [1] ifFalse: [0]! !
!WeakSet methodsFor: 'enumerating' stamp: 'jmv 1/13/2025 13:09:42' overrides: 16827898!
                       collect: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.  
	Collect the resulting values into a collection like the receiver. Answer  
	the new collection."

	| newSet |
	newSet := self species newWithRoomForMoreThan: self size.
	self do:
		[ :each |
			newSet add: (aBlock value: each)].
	^ newSet! !
!WeakSet methodsFor: 'enumerating' stamp: 'jmv 1/13/2025 16:59:24' overrides: 16828068!
                          do: aBlock

	buckets do:
		[:eachBucket |
			eachBucket ifNotNil:
				[
					eachBucket do:
						[:element |
							element notNil ifTrue:
								[aBlock value: element]]]]! !
!WeakSet methodsFor: 'enumerating' stamp: 'jmv 1/13/2025 13:09:14' overrides: 16828250!
                      union: aCollection
	"Answer the set theoretic union of the receiver and aCollection, using the receiver's notion of equality and not side effecting the receiver at all."

	^(self species newWithRoomForMoreThan: estimatedSize + aCollection estimatedSize)
		addAll: self;
		addAll: aCollection;
		yourself.! !
!WeakSet methodsFor: 'comparing' stamp: 'jmv 1/10/2025 10:17:35' overrides: 16827645!
                      emptyCollectionHash
	^ Set hash! !
!WeakSet methodsFor: 'copying' stamp: 'jmv 1/13/2025 13:03:50' overrides: 16915537!
         postCopy

	self rehash! !
!WeakSet methodsFor: 'objects from disk' stamp: 'jmv 1/13/2025 13:02:58' overrides: 16916389!
        comeFullyUpOnReload: smartRefStream
	"Symbols have new hashes in this image."

	self rehash.! !
!WeakSet methodsFor: 'initialization' stamp: 'jmv 1/13/2025 12:44:39'!
                         init: n
	"Initialize array to an array size of n"
	buckets := Array new: n.
	estimatedSize := 0.! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 17:51:20'!
                            basicAdd: anObject withHash: hashValue
	"Add an object.
	Note: It is assumed that the argument is NOT already included. Check senders."

	| bucketIndex bucket indexInBucket bucketSize newBucket |

	"bucket creation is lazy"
	bucketIndex := self bucketIndexFor: hashValue.
	bucket := buckets at: bucketIndex.
	bucket ifNil: [ bucket := buckets at: bucketIndex put: (WeakArray new: self bucketDirectAccessSize)].

	"1. If our direct access spot in the hasheable area is free, just use it and we are done."
	indexInBucket := self indexInBucketFor: hashValue.
	(bucket at: indexInBucket) == nil ifTrue: [
		bucket at: indexInBucket put: anObject.
		estimatedSize := estimatedSize + 1.
		^self ].

	"2. If there is available room in the iterable part of the bucket, add our new element there."
	bucketSize := bucket size.
	self bucketIterablePartStart to: bucketSize do: [ :i |
		(bucket at: i) == nil ifTrue: [
			bucket at: i put: anObject.
			estimatedSize := estimatedSize + 1.
			^self ]].

	"There's no room in this bucket. It may be worth growing the collection.
	I (jmv) could not find a good heuristic on whether to grow the collection based on a single bucket.
	The adopted one was to limit average mean occupation over all buckets."
	estimatedSize > (buckets size * self bucketDesiredMeanOccupation) ifTrue: [
		self grow.
		"Now try again.
		Maybe the new element is added in the first part of the bucket,
		or in already available room in the second part. (1 and 2 above).
		Or maybe growing the bucket as below (3) is needed.
		What is sure is that this won't recurse more than once: buckets size was just doubled by #grow."
		^self basicAdd: anObject withHash: hashValue ].

	"3. We still need to grow the bucket. Grow it and add our new element."
	newBucket := WeakArray new: bucketSize + self bucketIterablePartGrow.
	newBucket replaceFrom: 1 to: bucketSize with: bucket startingAt: 1.
	newBucket at: bucketSize + 1 put: anObject.
	buckets at: bucketIndex put: newBucket.
	estimatedSize := estimatedSize + 1.! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/13/2025 14:56:03'!
                        basicLookup: anObject withHash: hashValue
	"Look for anObject. Assume hashValue is anObject hash, passed as argument to avoid possibly expensive repeated hash computation.
	Answer the element found, or nil if not found."

	| bucket indexInBucketForDirectAccess directAccessElelemt |
	bucket := buckets at: (self bucketIndexFor: hashValue).
	bucket ifNil: [ ^nil ].

	indexInBucketForDirectAccess := self indexInBucketFor: hashValue.
	directAccessElelemt := bucket at: indexInBucketForDirectAccess.
	(self areEqual: directAccessElelemt and: anObject)
		ifTrue: [ ^directAccessElelemt ].

	(self basicLook: anObject inIterablePartOf: bucket)
		ifNotNil: [ :index | | found |
			"We found it at the iterable part of the bucket.
			Move to the the direct access slot if possible."
			found := bucket at: index.
			directAccessElelemt isNil ifTrue: 
				[
					bucket at: indexInBucketForDirectAccess put: found.
					bucket at: index put: nil].
			^found].

	^nil! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/13/2025 14:38:32'!
                             bucketIndexFor: hashValue

	"The lowest few bits are used to index into each bucket.
	Don't use them for finding the bucket.
	See #indexInBucketFor:"
	^ ((hashValue bitShift: self bucketsHashShift)
			"Take only as much bits as we can use."
			bitAnd: buckets size-1)
				"And remember Smalltalk does 1-based indexing."
				+ 1! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 17:20:05'!
                     grow
	"Duplicate size of buckets. Keep old buckets.
	For each old bucket:
	- Duplicate it as a new bucket
	- Move elements that belong in the new bucket to it
	- If possible, move elements in the iterable area to the hasheable area. This is important for search performance.
	
	Note: An alternative implementation is simply
		self rehash: buckets size * 2
	But the current implementation is much faster, at the expense of additional memory consumption."

	| newBuckets oldBucketsSize maskForNewUsedHashBit anOldBucket aNewBucket elementHash diirectAccessIndexInBucket keepdOldBucket |
	estimatedSize := 0.
	oldBucketsSize := buckets size.
	maskForNewUsedHashBit := oldBucketsSize * self bucketDirectAccessSize. "We're directly accessing the full hash, including the lower bits."
	newBuckets := buckets grownTo: oldBucketsSize * 2.
	1 to: oldBucketsSize do:
		[ :indexToOldBucket |
			anOldBucket := buckets at: indexToOldBucket.
			anOldBucket ifNotNil:
				[
					keepdOldBucket := false.
					aNewBucket := nil.
					"Move elements in hasheable area to new bucket if appropriate."
					1 to: self bucketDirectAccessSize do:
						[ :indexInBucket |
							(anOldBucket at: indexInBucket) ifNotNil:
								[ :element |
									estimatedSize := estimatedSize + 1.
									((self hashFor: element) bitAnd: maskForNewUsedHashBit) = 0
									ifTrue:
										[ keepdOldBucket := true ]
									ifFalse:
										[
											aNewBucket ifNil: [
												aNewBucket := WeakArray new: anOldBucket size.
												newBuckets at: oldBucketsSize + indexToOldBucket put: aNewBucket ].
											aNewBucket at: indexInBucket put: (anOldBucket at: indexInBucket).
											anOldBucket at: indexInBucket put: nil ]]].
					"For elements is iterable area, try to move them to the hasheable area."
					self bucketIterablePartStart to: anOldBucket size do:
						[ :indexInBucket |
							(anOldBucket at: indexInBucket) ifNotNil:
								[ :element |
									estimatedSize := estimatedSize + 1.
									elementHash := self hashFor: element.
									diirectAccessIndexInBucket := self indexInBucketFor: elementHash.
									(elementHash bitAnd: maskForNewUsedHashBit) = 0
									ifTrue:
										[ "Stays in old bucket. Try to move to hasheable part."
											keepdOldBucket := true.
											(anOldBucket at: diirectAccessIndexInBucket) ifNil:
												[
													anOldBucket at: diirectAccessIndexInBucket put: element.
													anOldBucket at: indexInBucket put: nil ]]
									ifFalse:
										[ "Moves to new bucket. Try to move to hasheable part, or move to iterable part."
											aNewBucket ifNil: [
												aNewBucket := WeakArray new: anOldBucket size.
												newBuckets at: oldBucketsSize + indexToOldBucket put: aNewBucket ].
											(aNewBucket at: diirectAccessIndexInBucket) ifNil:
												[ aNewBucket at: diirectAccessIndexInBucket put: element ]
											ifNotNil:
												[ aNewBucket at: indexInBucket put: element ].
											anOldBucket at: indexInBucket put: nil ]]].
					keepdOldBucket ifFalse:
						[newBuckets at: indexToOldBucket put: nil ]]].
	buckets := newBuckets.! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/13/2025 14:38:55'!
             indexInBucketFor: hashValue
	"see also #bucketIndexFor:"

	^ (hashValue bitAnd: self bucketDirectAccessMask) + 1! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 11:55:48' overrides: 16934010!
                        rehash
	self rehash: buckets size! !
!WeakSet methodsFor: 'private' stamp: 'jmv 1/14/2025 11:55:25'!
                           rehash: newBucketsSize
	| oldBuckets |
	oldBuckets := buckets.
	self init: newBucketsSize.
	oldBuckets do:
		[:eachBucket |
			eachBucket ifNotNil:
				[
					eachBucket do:
						[:element |
							element notNil
								ifTrue: [self add: element]]]]! !
!WeakSet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:43:19'!
           areEqual: a and: b
	"To make it easy to implement WeakIdentitySet as a subclass."

	^a = b! !
!WeakSet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:32:18'!
             basicLook: anObject inIterablePartOf: aBucket
	"To make it easy to implement WeakIdentitySet as a subclass."
	"Answer the index or nil if not found"

	self bucketIterablePartStart to: aBucket size do: [ :i |
		(aBucket at: i) = anObject ifTrue: [ ^i ]].
	^nil! !
!WeakSet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:08:56'!
    hashFor: anObject
	"To make it easy to implement WeakIdentitySet as a subclass."

	^anObject hash! !
!WeakSet methodsFor: 'removing' stamp: 'jmv 1/13/2025 14:53:46' overrides: 16827821!
      copyWithout: oldElement 
	"Answer a copy of the receiver that does not contain any elements equal
	to oldElement."

	^ self copy
		remove: oldElement ifAbsent: nil;
		yourself! !
!WeakSet methodsFor: 'removing' stamp: 'jmv 1/13/2025 14:53:40' overrides: 16828464!
                        remove: oldObject ifAbsent: aBlock

	| hashValue indexInBucketForDirectAccess |
	hashValue := self hashFor: oldObject.
	(buckets at: (self bucketIndexFor: hashValue)) ifNotNil:
		[ :bucket |
			indexInBucketForDirectAccess := self indexInBucketFor: hashValue.
			(self areEqual: (bucket at: indexInBucketForDirectAccess) and: oldObject) ifTrue:
				[
					bucket at: indexInBucketForDirectAccess put: nil.
					estimatedSize := estimatedSize - 1.
					^oldObject ].
			(self basicLook: oldObject inIterablePartOf: bucket)
				ifNotNil: [ :index |
					bucket at: index put: nil.
					estimatedSize := estimatedSize - 1.
					^oldObject ]].
	^ aBlock value! !
!WeakSet methodsFor: 'removing' stamp: 'jmv 1/13/2025 12:38:32'!
            removeAll

	buckets atAllPut: nil.
	estimatedSize := 0.! !
!WeakSet methodsFor: 'testing' stamp: 'jmv 1/13/2025 12:29:57' overrides: 16827640!
                 = aSet

	self == aSet ifTrue: [^ true].	"Any object is equal to itself"
	(aSet is: #Set) ifFalse: [^ false].
	(aSet is: #Dictionary) ifTrue: [^ false].
	self size = aSet size ifFalse: [^ false].
	self do: [ :each | (aSet includes: each) ifFalse: [^ false]].
	^ true! !
!WeakSet methodsFor: 'testing' stamp: 'jmv 1/10/2025 10:10:13' overrides: 16828691!
                               is: aSymbol
	^aSymbol == #Set or: [ super is: aSymbol ]! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/14/2025 17:56:51'!
                            bucketDesiredMeanOccupation
	"How much of a bucket to use on average.
	Larger values, avoiding waste of memory on empty slots in buckets mean slower access due to hash conflicts forcing iteration on the iterable part of the unlucky buckets.
	Smaller values, avoiding iteration and faster access mean more wasted memory.
	Some experimentation sugges that using in average half of the buckets gives great performance, with some disregard for memory."

	^5! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:29:06'!
              bucketDirectAccessMask
	"The mask to apply to a hash value to index it (+1 due to 1-based indexing).
	Must equal #bucketDirectAccessSize-1.
	See also #bucketDirectAccessSize, #bucketIterablePartStart and #bucketsHashShift"

	^7! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:28:59'!
                bucketDirectAccessSize
	"The size of the initial part of each bucket, that is only used for elements with matching hash bits.
	See also #bucketDirectAccessMask, #bucketIterablePartStart and #bucketsHashShift"

	^8! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/14/2025 17:53:35'!
                              bucketIterablePartGrow
	"Number of slots to add at once to the iterable part of Buckets."

	^1! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:29:13'!
                     bucketIterablePartStart
	"The first index of the iterable area of each Bucket.
	Must equal #bucketDirectAccessSize+1
	See also #bucketDirectAccessSize, #bucketDirectAccessMask and #bucketsHashShift"

	^9! !
!WeakSet methodsFor: 'tuning constants' stamp: 'jmv 1/13/2025 12:29:22'!
        bucketsHashShift
	"The mask to apply to a hash value to index it (+1 due to 1-based indexing).
	Must equal (#bucketDirectAccessMask highBit negated)
	See also #bucketDirectAccessSize, #bucketDirectAccessMask and #bucketIterablePartStart"

	^ -3! !
!WeakSet class methodsFor: 'instance creation' stamp: 'jmv 1/13/2025 13:01:47' overrides: 16787783!
    new
	^ self newWithRoomForMoreThan: 32! !
!WeakSet class methodsFor: 'instance creation' stamp: 'jmv 1/13/2025 12:53:56' overrides: 16828875!
                  newFrom: aCollection
	"Create a new collection containing all the elements from aCollection"

	^(self newWithRoomForMoreThan: aCollection size)
		addAll: aCollection;
		yourself! !
!WeakSet class methodsFor: 'instance creation' stamp: 'jmv 1/13/2025 12:53:33'!
                           newWithRoomForMoreThan: nElements
	"Create a Set large enough to hold nElements without growing
	WeakSet newWithRoomForMoreThan: 31
	WeakSet newWithRoomForMoreThan: 32
	"

	| answer |
	answer := self basicNew.
	answer init: (2 raisedToInteger: (nElements // answer bucketDesiredMeanOccupation) highBit -1).
	^answer! !
!WeakSet class methodsFor: 'experiments - tuning' stamp: 'jmv 1/15/2025 09:22:57'!
              experiment01
	"For measurements and tuning.
	Slow and memory hungry. Adjust a and m paramenters, play with this.
	A nice visualization of hash values is commented out. Play with it.
	self experiment01
	"
| a bits f h m n o pixelsMask s w ws |
n := 1000.
m := 10000.
a := Array new: n.
Transcript clear.
ws := WeakSet new.
Symbol allSymbols do: [ :sym | ws add: sym ].
ws inspect. a inspect.
Smalltalk garbageCollect.
Symbol rehash.
Smalltalk garbageCollect.
"---"
w := 2048.
h := 2048.
bits := ByteArray new: w*h // 8.
f := Form extent: w@h depth: 1 bits: bits.
bits atAllPut: 0.
pixelsMask := w*h-1.
"---"
[
	1 to: n do: [ :i |
		i \\ 10 = 0 ifTrue: [
			{'i: '. i. Time now} print ].
		o := Array new: m.
		a at: i put: o.
		1 to: m do: [ :i2 |
			s := Random next printString.
			o at: i2 put: s.
			ws add: s.
			"
			bits bitAt: (s hash bitAnd: pixelsMask)+1 put: 1.
			Random next > 10.9999 ifTrue: [
				f display. Display forceToScreen ]
			"
	 ]].
] timeToRun print.
ws size print.
ws instVarNamed: 'buckets' :: size print.
(ws instVarNamed: 'buckets') sum: [ :b | b ifNil: [0] ifNotNil: [b size ]] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size > 12 ]] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size > 15 ]] :: print.
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b allSatisfy: [ :e | e isNil ]] ] :: print.
'-----' print.
8 to: 15 do: [ :xx |
	(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size = xx ]] :: print ].
(ws instVarNamed: 'buckets') count: [ :b | b notNil and: [b size > 15 ]] :: print.! !
!WeakIdentitySet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:43:13' overrides: 50341996!
                      areEqual: a and: b
	"To make it easy to implement WeakIdentitySet as a subclass."

	^a == b! !
!WeakIdentitySet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:32:27' overrides: 50342002!
                basicLook: anObject inIterablePartOf: aBucket
	"To make it easy to implement WeakIdentitySet as a subclass."
	"Answer the index or nil if not found"

	self bucketIterablePartStart to: aBucket size do: [ :i |
		(aBucket at: i) == anObject ifTrue: [ ^i ]].
	^nil! !
!WeakIdentitySet methodsFor: 'private-equality or identity' stamp: 'jmv 1/13/2025 09:09:15' overrides: 50342013!
       hashFor: anObject
	"To make it easy to implement WeakIdentitySet as a subclass."

	^anObject identityHash! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6978-WeakSet-WeakIdentitySet-JuanVuletich-2025Jan15-09h37m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6978] on 14 January 2025 at 1:07:30 pm'!
!WorldMorph methodsFor: 'errors on draw' stamp: 'jmv 1/13/2025 17:03:05' prior: 50341369!
          removeAllKnownFailing
	drawingFailingMorphs do: [ :m | m redrawNeeded ].
	drawingFailingMorphs := WeakIdentitySet new.
! !
!WorldMorph methodsFor: 'initialization' stamp: 'jmv 1/13/2025 17:02:57' prior: 50341377 overrides: 16832614!
                       initialize

	super initialize.
	activeHand := HandMorph new.
	damageRecorder := DamageRecorder new.
	stepList := Heap sortBlock: self stepListSortBlock.
	alarms := Heap sortBlock: self alarmSortBlock.
	lastAlarmTime := 0.
	deferredUIMessages := SharedQueue new.
	drawingFailingMorphs := WeakIdentitySet new.
	pause := 20.
	lastCycleTime := Time localMillisecondClock.
	lastCycleHadAnyEvent := false! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
WorldMorph allInstancesDo: [ :w | w removeAllKnownFailing ].
Smalltalk garbageCollect.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6979-UseNew-WeakIdentitySet-JuanVuletich-2025Jan14-13h04m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6978] on 14 January 2025 at 1:09:32 pm'!

Smalltalk removeClassNamed: #OldWeakIdentitySet!

!classRemoval: #OldWeakIdentitySet stamp: 'Install-6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector''-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st 1/17/2025 10:30:48'!
OldWeakSet subclass: #OldWeakIdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

Smalltalk removeClassNamed: #OldWeakSet!

!classRemoval: #OldWeakSet stamp: 'Install-6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector''-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st 1/17/2025 10:30:48'!
Set subclass: #OldWeakSet
	instanceVariableNames: 'flag'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

Smalltalk removeClassNamed: #WeakSetInspector!

!classRemoval: #WeakSetInspector stamp: 'Install-6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector''-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st 1/17/2025 10:30:48'!
SetInspector subclass: #WeakSetInspector
	instanceVariableNames: 'flagObject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6980-Remove-OldWeakSet-OldWeakIdentitySet-WeakSetInspector'-JuanVuletich-2025Jan14-13h07m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6981] on 14 January 2025 at 1:17:53 pm'!
!Symbol class methodsFor: 'class initialization' stamp: 'jmv 1/14/2025 13:13:34' prior: 16962889 overrides: 16917943!
    initialize
	"Rebuild the hash table"
	"
	Symbol initialize.
	"
	self accessProtect critical:
		[ 	| allSymbols |
			allSymbols := self allSymbols.
			Symbols := WeakSet new.
			Symbols addAll: allSymbols ].! !
!Symbol class methodsFor: 'private' stamp: 'jmv 1/14/2025 13:17:28' prior: 16962935 overrides: 16934010!
     rehash
	"Rebuild the hash table"
	"
	Symbol rehash
	"

	
	self accessProtect critical: [
		Symbols rehash ].! !

Symbol initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6981-Use-WeakSet-ForSymbolTable-JuanVuletich-2025Jan14-13h17m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6981] on 15 January 2025 at 9:58:37 am'!
!Integer methodsFor: 'comparing' stamp: 'jmv 1/15/2025 09:56:58'!
        hashMultiply
	self subclassResponsibility! !
!Integer methodsFor: 'comparing' stamp: 'jmv 1/15/2025 09:57:42' prior: 16886667 overrides: 16913818!
             hash
	"Hash is reimplemented because = is implemented.
	Siimply answering self as #hash has bad performance for the following:
	| s |
	s := (1 to: 10000) asSet.
	[s includes: 123456] bench
	"

	"Can only happen in 64 bits images...
	See Float>>#hash, LargePositiveInteger>>#hash and LargeNegativeInteger>>#hash"
	self abs < Float maxExactInteger ifFalse: [
		^ self asFloat hash ].

	"In 32 bit image it will always go this way"
	^self hashMultiply! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6982-CommentTweak-JuanVuletich-2025Jan15-09h56m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6962] on 12 January 2025 at 9:01:29 pm'!
!Random methodsFor: 'accessing' stamp: 'eem 1/12/2025 19:26:00'!
                       next: numberOfElements
	| elements |
	elements := Array new: numberOfElements.
	1 to: numberOfElements do:
		[:i| elements at: i put: self next].
	^elements! !
!Character class methodsFor: 'instance creation' stamp: 'eem 2/5/2014 12:49'!
                  value: anInteger
	"Answer the Character whose value is anInteger."
	<primitive: 170>
	^self primitiveFailed! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6983-Random-next-and-Character-class-value-EliotEmilioMiranda-2025Jan12-19h26m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 11:52:32 am'!
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:37:45'!
recreateObsoleteSubclassesCollection
	"
	Behavior recreateObsoleteSubclassesCollection
	"
	| newOne |
	newOne := EphemeronIdentityDictionary new.
	ObsoleteSubclasses keysAndValuesDo: [ :k :v |
		newOne at: k put: v ].
	ObsoleteSubclasses := newOne.! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:42:49' prior: 16789366!
       addObsoleteSubclass: aClass
	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"
	| obs |
	ObsoleteSubclasses ifNil: [
		ObsoleteSubclasses := EphemeronIdentityDictionary new ].
	obs := ObsoleteSubclasses at: self ifAbsent:[WeakArray new].
	(obs includes: aClass) ifTrue:[^self].
	obs := obs copyWithout: nil.
	obs := obs copyWith: aClass.
	ObsoleteSubclasses at: self put: obs.
! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:46:50' prior: 16789383!
       obsoleteSubclasses
	"Return all the weakly remembered obsolete subclasses of the receiver.
	Clean out the already collected ones."
	| obs |
	ObsoleteSubclasses ifNil: [
		^#() ].
	obs := ObsoleteSubclasses at: self ifAbsent:[^#()].
	obs := obs copyWithout: nil.
	obs isEmpty
		ifTrue: [ ObsoleteSubclasses removeKey: self ifAbsent: nil ]
		ifFalse: [ ObsoleteSubclasses at: self put: obs].
	^obs! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:42:11' prior: 16789399!
                    removeAllObsoleteSubclasses
	"Remove all the obsolete subclasses of the receiver"
	ObsoleteSubclasses ifNotNil: [
		ObsoleteSubclasses removeKey: self ifAbsent: nil ]! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:47:11' prior: 16789409!
                         removeObsoleteSubclass: aClass
	"Remove aClass from the weakly remembered obsolete subclasses.
	Clean out the already collected ones."
	| obs |
	ObsoleteSubclasses ifNil: [
		^ self ].
	obs := ObsoleteSubclasses at: self ifAbsent:[^ self].
	(obs includes: aClass) ifFalse:[^self].
	obs := obs copyWithout: aClass.
	obs := obs copyWithout: nil.
	obs isEmpty
		ifTrue: [ObsoleteSubclasses removeKey: self ifAbsent: nil]
		ifFalse: [ObsoleteSubclasses at: self put: obs]! !
!ClassBuilder methodsFor: 'initialization' stamp: 'jmv 1/16/2025 11:40:05' prior: 16817262!
             doneCompiling: aClass
	"The receiver has finished modifying the class hierarchy.
	Do any necessary cleanup."
	aClass doneCompiling.! !

Behavior class removeSelector: #flushObsoleteSubclasses!

!methodRemoval: Behavior class #flushObsoleteSubclasses stamp: 'Install-6984-ObsoleteClasses-UseEphemeronDictionaries-JuanVuletich-2025Jan16-11h35m-jmv.002.cs.st 1/17/2025 10:30:48'!
flushObsoleteSubclasses
	"Behavior flushObsoleteSubclasses"

	ObsoleteSubclasses ifNotNil: [
		ObsoleteSubclasses keys "need a copy" 
			do: [ :obs| obs ifNotNil:[ obs obsoleteSubclasses ]]. "remove themselves"
		ObsoleteSubclasses finalizeValues ]!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Behavior recreateObsoleteSubclassesCollection!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6984-ObsoleteClasses-UseEphemeronDictionaries-JuanVuletich-2025Jan16-11h35m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 12:09:31 pm'!
!ActiveModel class methodsFor: 'initialization' stamp: 'jmv 1/16/2025 12:06:37'!
                     recreateActionMapsCollection
	"
	ActiveModel recreateActionMapsCollection
	"
	| newOne |
	newOne := EphemeronIdentityDictionary new.
	ActionMaps keysAndValuesDo: [ :k :v |
		newOne at: k put: v ].
	ActionMaps := newOne.! !
!ActiveModel class methodsFor: 'accessing' stamp: 'jmv 1/16/2025 12:06:43' prior: 16779373!
     actionMaps

	ActionMaps ifNil: [
		ActionMaps := EphemeronIdentityDictionary new ].
	^ActionMaps! !
!ActiveModel class methodsFor: 'initialization' stamp: 'jmv 1/16/2025 12:58:12' prior: 16779391!
                           flushEventSystem
	"ActiveModel flushEventSystem"
	self actionMaps keysAndValuesDo: [ :rcvr :evtDict | 
		rcvr ifNotNil:[
			"make sure we don't modify evtDict while enumerating"
			evtDict keys do: [ :evtName | | msgSet |
				msgSet := evtDict at: evtName ifAbsent: nil.
				msgSet ifNil: [ rcvr removeActionsForEvent: evtName]]]].! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
ActiveModel recreateActionMapsCollection!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6985-ActionMaps-UseEphemeronDictionaries-JuanVuletich-2025Jan16-11h52m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6984] on 16 January 2025 at 1:06:58 pm'!
!ObjectExplorer methodsFor: 'monitoring' stamp: 'jmv 1/16/2025 13:04:20' prior: 16918067!
                           monitorList
	^monitorList ifNil: [ monitorList := EphemeronIdentityDictionary new ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6986-ObjectExplorer-UseEphemeronDictionaries-JuanVuletich-2025Jan16-13h04m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6984] on 16 January 2025 at 1:06:58 pm'!
!DebuggerMethodMap class methodsFor: 'class initialization' stamp: 'jmv 1/16/2025 13:04:52' prior: 16844813!
                            voidMapCache

	self protected: [ 
		MapCache := EphemeronIdentityDictionary new.
		MapCacheEntries := 16 ]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
DebuggerMethodMap initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6987-DebuggerMethodMap-UseEphemeronDictionaries-JuanVuletich-2025Jan16-13h04m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 2:53:34 pm'!
!UniFileStream class methodsFor: 'registry' stamp: 'jmv 1/16/2025 14:51:58'!
              recreateRegistry
	"
	UniFileStream recreateRegistry
	"
	| newOne |
	newOne := FinalizationRegistry new.
	Registry do: [ :fileStream |
		newOne add: fileStream ].
	Registry := newOne.! !
!UniFileStream class methodsFor: 'registry' stamp: 'jmv 1/16/2025 14:52:21' prior: 16994237!
         registry
	
	^Registry ifNil: [ Registry := FinalizationRegistry new ]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
UniFileStream recreateRegistry!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6988-FileRegistry-useFinalizationRegistry-notWeakRegistry-JuanVuletich-2025Jan16-14h45m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6988] on 16 January 2025 at 4:35:07 pm'!
!UniFileStream class methodsFor: 'cached state access' stamp: 'jmv 1/16/2025 16:34:16' prior: 16994352 overrides: 16789305!
                        releaseClassCachedState

	Registry ifNotNil: [
		"Make the best effort to empty the registry.
		Only keep files that are still open have references from some object."
		Registry isEmpty ifFalse: [
			Smalltalk garbageCollectMost.
			Registry isEmpty ifFalse: [
				Smalltalk garbageCollect]].

		"No open files. Can nil the Registry."
		Registry isEmpty ifTrue: [
			Registry := nil ]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6989-FileRegistry-Cleanup-JuanVuletich-2025Jan16-16h31m-jmv.001.cs.st----!

----QUIT----(17 January 2025 10:30:51) Cuis7.3-6989.image priorSource: 276466!

----STARTUP---- (23 January 2025 11:11:11) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.3-6989.image!


'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 11:52:32 am'!
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:37:45' prior: 50342413!
                        recreateObsoleteSubclassesCollection
	"
	Behavior recreateObsoleteSubclassesCollection
	"
	| newOne |
	newOne := EphemeronIdentityDictionary new.
	ObsoleteSubclasses ifNotNil:
		[:oldOne|
		oldOne keysAndValuesDo:
			[ :k :v | newOne at: k put: v ] ].
	ObsoleteSubclasses := newOne.! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:42:49' prior: 50342424!
     addObsoleteSubclass: aClass
	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"
	| obs |
	ObsoleteSubclasses ifNil: [
		ObsoleteSubclasses := EphemeronIdentityDictionary new ].
	obs := ObsoleteSubclasses at: self ifAbsent:[WeakArray new].
	(obs includes: aClass) ifTrue:[^self].
	obs := obs copyWithout: nil.
	obs := obs copyWith: aClass.
	ObsoleteSubclasses at: self put: obs.
! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:46:50' prior: 50342440!
       obsoleteSubclasses
	"Return all the weakly remembered obsolete subclasses of the receiver.
	Clean out the already collected ones."
	| obs |
	ObsoleteSubclasses ifNil: [
		^#() ].
	obs := ObsoleteSubclasses at: self ifAbsent:[^#()].
	obs := obs copyWithout: nil.
	obs isEmpty
		ifTrue: [ ObsoleteSubclasses removeKey: self ifAbsent: nil ]
		ifFalse: [ ObsoleteSubclasses at: self put: obs].
	^obs! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:42:11' prior: 50342456!
                    removeAllObsoleteSubclasses
	"Remove all the obsolete subclasses of the receiver"
	ObsoleteSubclasses ifNotNil: [
		ObsoleteSubclasses removeKey: self ifAbsent: nil ]! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 1/16/2025 11:47:11' prior: 50342465!
                         removeObsoleteSubclass: aClass
	"Remove aClass from the weakly remembered obsolete subclasses.
	Clean out the already collected ones."
	| obs |
	ObsoleteSubclasses ifNil: [
		^ self ].
	obs := ObsoleteSubclasses at: self ifAbsent:[^ self].
	(obs includes: aClass) ifFalse:[^self].
	obs := obs copyWithout: aClass.
	obs := obs copyWithout: nil.
	obs isEmpty
		ifTrue: [ObsoleteSubclasses removeKey: self ifAbsent: nil]
		ifFalse: [ObsoleteSubclasses at: self put: obs]! !
!ClassBuilder methodsFor: 'initialization' stamp: 'jmv 1/16/2025 11:40:05' prior: 50342483!
             doneCompiling: aClass
	"The receiver has finished modifying the class hierarchy.
	Do any necessary cleanup."
	aClass doneCompiling.! !

Behavior class removeSelector: #flushObsoleteSubclasses!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Behavior recreateObsoleteSubclassesCollection!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6990-FixForAlreadySavedImages-ObsoleteClasses-UseEphemeronDictionaries-JuanVuletich-2025Jan16-11h35m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #6989] on 17 January 2025 at 5:29:31 pm'!
!AbstractVectorCanvas class methodsFor: 'literal path data' stamp: 'jmv 1/17/2025 17:25:55' prior: 50331721!
                   windowSquareButtonPathData: aSize
	| scale |
	(IconPathData at: #windowSquareButtonSize ifAbsent: nil) = aSize ifTrue: [
		IconPathData at: #windowSquareButton ifPresent: [ :found | ^found ]].
	IconPathData at: #windowSquareButtonSize put: aSize.
	scale := aSize / 22.0.
	^IconPathData at: #windowSquareButton put: (
		self scalePathData: `#[
			0.0 0 0
			1    0 20
			1    20 20
			1    20 0
			1    0 0
		] asFloat32Array` scale: scale)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6991-MultiBrowserButtonRescale-fix-JuanVuletich-2025Jan17-17h29m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6991] on 20 January 2025 at 3:20:43 pm'!
!Morph methodsFor: 'geometry' stamp: 'jmv 1/20/2025 15:20:18' prior: 16906274!
 findFullBoundsInOwner
	"Find and answer full bounds in whatever owner.
	These might not equal #displayFullBounds at all!!
	Note: Answers an integer rectangle"

	| prevNotVisibleFlag w c answer prevOwner |
	(owner notNil and: [owner isWorldMorph]) ifTrue: [
		w := owner ]
	ifFalse: [
		w := UISupervisor ui ].
	c := w mainBoundsFinderCanvas.
	"Hack owner so #displayBoundsSetFrom: will update privateDisplayBounds"
	prevOwner := owner.
	owner := w.
	prevNotVisibleFlag := self privateFlagAt: 3.
	self privateFlagAt: 3 put: false.
	c fullUpdateProtrudingBounds: self.
	answer := self displayFullBounds.
	"Reset owner and privateDisplayBounds (if needed) so no one finds out what we've just done!!"
	prevOwner == owner ifFalse: [
		owner := prevOwner.
		self world = w ifTrue: [
			self privateFlagAt: 3 put: false.
			self allOwnersReverseDo: [ :m | c into: m ].
			c fullUpdateProtrudingBounds: self.
			self allOwnersDo: [ :m | c outOfMorph ]]].
	self privateFlagAt: 3 put: prevNotVisibleFlag.
	^answer origin corner: answer corner -(1@0).! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6992-Tighter-findFullBoundsInOwner-JuanVuletich-2025Jan20-15h19m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6992] on 20 January 2025 at 5:28:36 pm'!
!String methodsFor: 'formatting' stamp: 'eem 1/20/2025 17:30:25'!
                     withCRs
	"Answer a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."

	^ self collect: [ :c | c == $\ ifTrue: [ Character cr ] ifFalse: [ c ]]! !
!WeakArray class methodsFor: 'finalization' stamp: 'eem 1/20/2025 16:59:03' prior: 50334466!
 finalizationProcess
	"nothing here, moved to EphemeronFinalizationProcess class"
	^EphemeronFinalizationProcess runningFinalizationProcess! !
!WeakArray class methodsFor: 'finalization' stamp: 'eem 1/20/2025 16:58:57' prior: 50334488!
                     runningFinalizationProcess
	"Answer the FinalizationProcess I am running, if any"
	^EphemeronFinalizationProcess runningFinalizationProcess! !
!FinalizationRegistry methodsFor: 'finalization' stamp: 'eem 1/20/2025 17:02:57' prior: 50335817 overrides: 50335766!
                           finalizeEphemeron: anEphemeron
	"Finalize the ephemeron's key and remove the ephemeron from myself.
	 N.B. Here we send #finalize since finalization is called for by placing
	 objects in a FinalizationRegistry. i.e. the response to the ephemeron
	 being triggered is a property of the container of the ephemeron, not
	 the ephemeron itself."

	self removeKey: anEphemeron key ifAbsent: [].
	
	"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
	 Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value.
	 N.B. errors here will not stall the finalization process."
	
	(anEphemeron value ifNil: [anEphemeron key]) finalize! !
!ProcessBrowser class methodsFor: 'process control' stamp: 'eem 1/20/2025 16:58:24' prior: 16932289!
                  rulesFor: aProcess
	"Answer two flags: allow-stop, and allow-debug"

	"Don't mess with the process running the ProcessBrowser.
	If we support several active UIs, we'd detect the UI process running us"
	aProcess == Processor activeProcess
		ifTrue: [^{false. false}].

	aProcess name = 'Sound Player'
		ifTrue: [ ^{false. false}].

	^ [aProcess caseOf: {
		[] -> [{false. false}].
		[Smalltalk lowSpaceWatcherProcess] -> [{false. false}].
		[WeakArray runningFinalizationProcess] -> [{false. false}].
		[EphemeronFinalizationProcess runningFinalizationProcess] -> [{false. false}].
		[Processor activeProcess] -> [{false. true}].
		[Processor backgroundProcess] -> [{false. false}].
		[Sensor interruptWatcherProcess] -> [{false. false}].
		[Sensor eventTicklerProcess] -> [{false. false}].
		[CPUWatcher currentWatcherProcess] -> [{false. false}].
		[Delay timerProcess] -> [{false. false}]}
		otherwise: [ {true. true}]]
		ifError: [ :err :rcvr | {true. true}]! !

EphemeronFinalizationProcess class removeSelector: #theFinalizationProcess!

!methodRemoval: EphemeronFinalizationProcess class #theFinalizationProcess stamp: 'Install-6993-EphemeronPreen-EliotEmilioMiranda-2025Jan20-16h56m-eem.001.cs.st 1/23/2025 11:11:11'!
theFinalizationProcess
	^TheFinalizationProcess!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6993-EphemeronPreen-EliotEmilioMiranda-2025Jan20-16h56m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6992] on 20 January 2025 at 5:28:36 pm'!
!ProcessBrowser class methodsFor: 'process control' stamp: 'eem 1/20/2025 16:58:24' prior: 50342895!
                     rulesFor: aProcess
	"Answer two flags: allow-stop, and allow-debug"

	"Don't mess with the process running the ProcessBrowser.
	If we support several active UIs, we'd detect the UI process running us"
	aProcess == Processor activeProcess
		ifTrue: [^{false. false}].

	aProcess name = 'Sound Player'
		ifTrue: [ ^{false. false}].

	^ [aProcess caseOf: {
		[] -> [{false. false}].
		[Smalltalk lowSpaceWatcherProcess] -> [{false. false}].
		[EphemeronFinalizationProcess runningFinalizationProcess] -> [{false. false}].
		[Processor activeProcess] -> [{false. true}].
		[Processor backgroundProcess] -> [{false. false}].
		[Sensor interruptWatcherProcess] -> [{false. false}].
		[Sensor eventTicklerProcess] -> [{false. false}].
		[CPUWatcher currentWatcherProcess] -> [{false. false}].
		[Delay timerProcess] -> [{false. false}]}
		otherwise: [ {true. true}]]
		ifError: [ :err :rcvr | {true. true}]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6994-Preen-EliotEmilioMiranda-2025Jan20-16h56m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6994] on 21 January 2025 at 8:23:18 am'!
!EphemeronFinalizationProcess class methodsFor: 'private - mourning' stamp: 'jmv 1/21/2025 08:19:08' prior: 50334385!
primitiveFetchMourner
	"Answer the next mourner in the VM's queue of objects to be finalized.
	 The queue contains weak arrays and ephemerons.  If the primitive is
	 not implemented, raise an error telling people to upgrade the VM.  If
	 implemented, the primitive fails if the queue is empty, with the error
	 code #'not found'. Primitive.  Essential."

	<primitive: 172 error: ec>
	ec ifNil: [^self error: 'The primitiveFetchMourner primitive is missing.\Please upgrade your virtual machine to one that has the primitive.' withNewLines].
	^nil! !

String removeSelector: #withCRs!

!methodRemoval: String #withCRs stamp: 'Install-6995-DontUse-withCRs-JuanVuletich-2025Jan21-08h22m-jmv.001.cs.st 1/23/2025 11:11:11'!
withCRs
	"Answer a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."

	^ self collect: [ :c | c == $\ ifTrue: [ Character cr ] ifFalse: [ c ]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6995-DontUse-withCRs-JuanVuletich-2025Jan21-08h22m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6995] on 21 January 2025 at 9:00:36 am'!
!EphemeronIdentityDictionary methodsFor: 'as yet unclassified' stamp: 'jmv 1/21/2025 08:57:52'!
           slowSize
	"Careful!! Answer the maximum amount
	of elements in the receiver, not the
	exact amount"

	| count |
	count := 0.
	self keysDo: [ :k | count := count + 1 ].
	^count! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6996-Add-EphemeronIdentityDictionary-slowSize-JuanVuletich-2025Jan21-08h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6983] on 21 January 2025 at 1:27:04 pm'!

'From Cuis7.3 [latest update: #6983] on 21 January 2025 at 12:10:20 pm'!

ByteArray variableByteSubclass: #CompiledMethod
	instanceVariableNames: ''
	classVariableNames: 'LargeFrame PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame PreferredBytecodeSetEncoderClass '
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!classDefinition: #CompiledMethod category: #'Kernel-Methods' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
ByteArray variableByteSubclass: #CompiledMethod
	instanceVariableNames: ''
	classVariableNames: 'LargeFrame PreferredBytecodeSetEncoderClass PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame'
	poolDictionaries: ''
	category: 'Kernel-Methods'!
!CompiledMethod commentStamp: '<historical>' prior: 50338408!
                             My instances are methods suitable for interpretation by the virtual machine.  This is the only class in the system whose instances intermix both indexable pointer fields and indexable integer fields. The pointer fields are used for literals and metadata, and the bytes are used for bytecodes and a variety of encoded informaton such as source code, source code position, etc.  The first part of a CompiledMethod object is pointers, the second part is bytes.  CompiledMethod inherits from ByteArray to avoid duplicating some of ByteArray's methods, not because a CompiledMethod is a ByteArray.

Instance variables: *indexed* (no named inst vars)

Class variables:
SmallFrame							- the number of stack slots in a small frame Context
LargeFrame							- the number of stack slots in a large frame Context
PreferredBytecodeSetEncoderClass	- the encoder class that is used to create new methods (either PrimaryBytecodeSetEncoderClass or SecondaryBytecodeSetEncoderClass)
PrimaryBytecodeSetEncoderClass		- the encoder class that defines the primary instruction set
SecondaryBytecodeSetEncoderClass	- the encoder class that defines the secondary instruction set
	
TThe current format of a CompiledMethod is as follows:

	header (4 or 8 bytes, SmallInteger)
	literals (4 or 8 bytes each, Object, see "The last literal..." below)
	bytecodes  (variable, bytes)
	trailer (variable, bytes)

The header is a SmallInteger (which in the 32-bit system has 31 bits, and in the 64-bit system, 61 bits) in the following format:

	(index 0)		15 bits:	number of literals (#numLiterals)
	(index 15)		  1 bit:	jit without counters - reserved for methods that have been optimized by Sista
	(index 16)		  1 bit:	has primitive
	(index 17)		  1 bit:	whether a large frame size is needed (#frameSize => either SmallFrame or LargeFrame)
	(index 18)		  6 bits:	number of temporary variables (#numTemps)
	(index 24)		  4 bits:	number of arguments to the method (#numArgs)
	(index 28)		  2 bits:	reserved for an access modifier (00-unused, 01-private, 10-protected, 11-public), although accessors for bit 29 exist (see #flag).
	sign bit:			  1 bit:	selects the instruction set, >= 0 Primary, < 0 Secondary (#signFlag)

If the method has a primitive then the first bytecode of the method must be a callPrimitive: bytecode that encodes the primitive index.  This bytecode can encode a primitive index from 0 to 65535.

The trailer has two variant formats.  In the first variant, the last byte is at least 252 and the last four bytes represent a source pointer into one of the sources files (see #sourcePointer).  In the second variant, the last byte is less than 252, and the last several bytes are a compressed version of the names of the method's temporary variables.  The number of bytes used for this purpose is the value of the last byte in the method.

While there are disadvantages to this "flat" representation (it is impossible to add named instance variables to CompiledMethodor its subclasses, but it is possible indirectly; see AdditionalMethodState) it is effective for interpreters.  It means that both bytecodes and literals can be fetched directly from a single method object, and that only one object, the method, must be saved and restored on activation and return.  A more natural representation, in which there are searate instance variables for the bytecode, and (conveniently) the literals, requires either much more work on activation and return setting up references to the literals and bytecodes, or slower access to bytecodes and literals, indirecting on each access.

The last literal of a CompiledMethod is reserved for special use by the kernel and/or the virtual machine.  It must either be the methodClassAssociation, used to implement super sends, or nil, if the method is anonymous.

By convention, the penultimate literal is reserved for special use by the kernel. In CompiledMethod instances it must either be the method selector, or an instance of AdditionalMethodState which holds the selector and any pragmas or properties in the method.
!

BytecodeEncoder subclass: #EncoderForSistaV1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #EncoderForSistaV1 category: #'Compiler-Kernel' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
BytecodeEncoder subclass: #EncoderForSistaV1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Kernel'!
!EncoderForSistaV1 commentStamp: 'eem 12/22/2024 19:07' prior: 0!
                      EncoderForSistaV1 encodes a bytecode set for Smalltalk that lifts limits on the number of literals, branch distances, the number of temporary variables, and provides extended push integer and push character bytecodes.  The bytecode set also supports creating FullBlockClosures, closures whose method is separate from their home method's.  Bytecodes are ordered by length to make decoding easier.  Bytecodes marked with an * are extensible via a prefix extension bytecode.

N.B.  Extension bytecodes can only come before extensible bytecodes, and only if valid (one cannot extend a bytecode extensible by Ext A with an Ext B).  An extensible bytecode consumes (and zeros) its extension(s).  Hence the hidden implicit variables holding extensions are always zero except after a valid sequence of extension bytecodes.  The implication is that a bytecode interpreter should maintain the extension values in static variables initialized to zero at start-up, and live only from the start of a sequence of extension bytecodes to the end of the extended bytecode immediately following.

While the bytecode set lifts limits, it still assumes there are no more than 65535 literals (as of 2020 the CompiledCode header word imposes a 32,767 limit on number of literals), and no more than 256 stack slots (used for arguments, temporaries, and stack contents) in a Context.

EncoderForSistaV1 also includes an extended set of bytecodes for Sista, the Speculative Inlining Smalltalk Architecture, a project by Clément Bera and Eliot Miranda.  Scorch is an optimizer that exists in the Smalltalk image, /not/ in the VM,  and optimizes by substituting normal bytecoded methods by optimized bytecoded methods that may use special bytecodes for which the Cogit can generate faster code.  These bytecodes eliminate overheads such as bounds checks or polymorphic code (indexing Array, ByteArray, String etc).  But the bulk of the optimization performed is in inlining blocks and sends for the common path.  This bytecode set therefore differs from a normal Smalltalk set in providing a set of inlined primitives that do not validate their arguments that the compiler generates only when it can prove that the primitives' arguments are valid.

The basic scheme is that the Cogit generates code containing performance counters.  When these counters trip, a callback into the image is performed, at which point Scorch analyses some portion of the stack, looking at performance data for the methods on the stack, and optimises based on the stack and performance data.  Execution then resumes in the optimized code.

The Sista Cogit (e.g. SistaStackToRegisterMappingCogit) adds counters to conditional branches.  Each branch has an executed and a taken count.  On execution the executed count is decremented and if the count goes below zero the VM sends a message at a special index in the specialObjectsArray (as of writing, conditionalCounterTrippedOn:).  Then if the branch is taken the taken count is decremented.  The two counter values allow the Sista optimizer to collect basic block execution paths and to know what are the "hot" paths through execution that are worth agressively optimizing.  Since conditional branches are about 1/6 as frequent as sends, and since they can be used to determine the hot path through code, they are a better choice to count than, for example, method or block entry.

The VM provides a primitive that fills an Array with the state of the counters, and the state of each linked send in a method.  The optimizer obtains the branch and send data for a method via this primitive.

Instance Variables (inherited)

Here is the list of bytecodes.  An asterisk implies the bytecode takes either extA or extB extensions. Two asterisks imply it takes both extA and extB extensions.  A number in parentheses is a note.  See the notes at the end of the table.

1 Byte Bytecodes
	code	(note)	binary			name
	0-15		0000 iiii 			Push Receiver Variable #iiii
	16-31		0001 iiii			Push Literal Variable #iiii
	32-63		001 iiiii				Push Literal #iiiii
	64-71		01000 iii			Push Temp #iii
	72-75		010010 ii			Push Temp #ii + 8
	76			01001100			Push Receiver
	77			01001101			Push true
	78			01001110			Push false
	79			01001111			Push nil
	80			01010000			Push 0
	81			01010001			Push 1
*	82			01010010			Push thisContext, (then Extend B = 1 => push thisProcess)
	83			01010011			Duplicate Stack Top
	84-87		010101 ii			UNASSIGNED
	88-91		010110 ii			Return Receiver/true/false/nil
	92			01011100			Return top
	93			01011101			BlockReturn nil
*	94			01011110			BlockReturn Top [* return from enclosing block N, N = Extend A, then jump by Ext B ]
*	95			01011111			Nop
	96-111		0110 iiii			Send Arithmetic Message #iiii (+ - < > <= >= = ~= * / \\ @ bitShift: // bitAnd: bitOr:)
	112-119	01110 iii			Send Special Message #iii + 0 (at: at:put: size next nextPut: atEnd == class)
	120-127	01111 iii			Send Special Message #iii + 8 (~~ value value: do: new new: x y)
	128-143	1000 iiii			Send Literal Selector #iiii With 0 Argument
	144-159	1001 iiii			Send Literal Selector #iiii With 1 Arguments
	160-175	1010 iiii			Send Literal Selector #iiii With 2 Arguments
	176-183	10110 iii			Jump iii + 1 (i.e., 1 through 8)
	184-191	10111 iii			Pop and Jump 0n True iii +1 (i.e., 1 through 8)
	192-199	11000 iii			Pop and Jump 0n False iii +1 (i.e., 1 through 8)
	200-207	11001 iii			Pop and Store Receiver Variable #iii
	208-215	11010 iii			Pop and Store Temporary Variable #iii
	216		11011000			Pop Stack Top
	217	(5)	11011001			Unconditional trap
	218-219	1101101 i			UNASSIGNED
	220-223	110111 ii			UNASSIGNED

2 Byte Bytecodes
*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A) A is an unsigned extension.
*	225		11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B) B is a signed extension.
*	226		11100010	iiiiiiii		Push Receiver Variable #iiiiiiii (+ Extend A * 256)
*	227		11100011	iiiiiiii		Push Literal Variable #iiiiiiii (+ Extend A * 256)
*	228		11100100	iiiiiiii		Push Literal #iiiiiiii (+ Extend A * 256)
	229		11100101	iiiiiiii		Push Temporary Variable #iiiiiiii
	230		11100110	iiiiiiii		UNASSIGNED (was pushNClosureTemps)
	231		11100111	jkkkkkkk	Push (Array new: kkkkkkk) (j = 0)
									&	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)
*	232		11101000	iiiiiiii		Push Integer #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, d=0, s=1)
*	233		11101001	iiiiiiii		Push Character #iiiiiiii (+ Extend A * 256)
**	234		11101010	iiiiijjj		Send Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments
**	235	(1)	11101011	iiiiijjj	ExtendB < 64
										ifTrue: [Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments]
										ifFalse: [Send To Superclass of Stacked Class Literal Selector #iiiii (+ Extend A * 32) with jjj (+ (Extend B bitAnd: 63) * 8) Arguments]
	236		11101100	iiiiiiii		UNASSIGNED
*	237		11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, d=0, s=1)
**	238	(4)	11101110	iiiiiiii		Pop and Jump 0n True #iiiiiiii (+ Extend B * 256, where Extend B >= 0)
**	239	(4)	11101111	iiiiiiii		Pop and Jump 0n False #iiiiiiii (+ Extend B * 256, where Extend B >= 0)
**	240	(3)	11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256) 
**	241	(3)	11110001	iiiiiiii		Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256) 
	242		11110010	iiiiiiii		Pop and Store Temporary Variable #iiiiiiii
**	243	(3)	11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256) 
**	244	(3)	11110100	iiiiiiii		Store Literal Variable #iiiiiiii (+ Extend A * 256) 
	245		11110110	iiiiiiii		Store Temporary Variable #iiiiiiii
	246-247	1111011 i	xxxxxxxx	UNASSIGNED

3 Byte Bytecodes
	248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
								m=1 means inlined primitive, no hard return after execution. 
								ss defines the unsafe operation set used to encode the operations. 
								(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are as yet unused)
								Lowcode inlined primitives may have extensions.
*	249		11111001 	xxxxxxxx	siyyyyyy	Push Closure Compiled block literal index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1 ignoreOuterContext: i = 1
**	250		11111010 	eeiiikkk		jjjjjjjj		Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions
	251		11111011 	kkkkkkkk	sjjjjjjj		Push Temp At kkkkkkkk In Temp Vector At: jjjjjjj, s = 1 implies remote inst var access instead of remote temp vector access 
*	252	(3)	11111100 	kkkkkkkk	sjjjjjjj		Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access 
*	253	(3)	11111101 	kkkkkkkk	sjjjjjjj		Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access
**	254	(5)	11111110	kkkkkkkk	jjjjjjjj		branch If Not Instance Of Behavior/Array Of Behavior literal kkkkkkkk (+ Extend A * 256, where Extend A >= 0) distance jjjjjjjj (+ Extend B * 256, where Extend B >= 0 and <= 127)
**	254	(5)	11111110	kkkkkkkk	jjjjjjjj		branch If Instance Of Behavior/Array Of Behavior literal kkkkkkkk (+ Extend A * 256, where Extend A >= 0) distance jjjjjjjj (+ (Extend B bitAnd: 127) * 256, where Extend B >= 128 and <= 255)
*	255		11111111	xxxxxxxx	jjjjjjjj		UNASSIGNED

(1) Bytecode 235 is a super send bytecode that starts the lookup in the superclass of some class.  It has two forms, "normal" and "directed". In the normal form, the class is the value of the method's methodClassAssociation which must be the last literal.  In the directed form the class is the class on top of stack.

(2) The Call Primitive Bytecode (see below) specifies either a primitive in the primitive table (m=0) or an inlined primitive (m=1). Non-inlined primitives from the primitive table have index (jjjjjjj * 256) + iiiiiiii and return from the method if they succeed.  This bytecode is only valid as the first bytecode of a method.  Inline primitives have index (jjjjjjj * 256) + iiiiiiii, cannot fail, and do not return when they succeed, yielding a result (typically on top of stack after popping their arguments, but possibly in a byte data stack, for example for unboxed floating-point primitives).

(3) ExtB lowest bit implies no store check is needed, ExtB second bit implies the object may be a context, ExtB third bit implies no immutability/read-only check is needed, other bits in the extension are unused.

(4) ExtA = 1 implies no mustBeBoolean trampoline is needed, other bits in the extension are unused

(5) these are Scorch/Sista bytecodes generated by an optimizing compiler and not used in normal Smalltalk code.


The CallPrimitive bytecode is divided into two halves, those for normal primtiives, occurring at the beginning of a method, and those for inline primitives, anywhere within the body of a method.  This is a three byte bytecode, the first byte being 248, and the second byte being a big-endian 16-bit primitive index. If the top bit of the first byte of the primitive index is 1 then this is a normal primitive invocation.  If it is zero then the remaining 15 bits define 32k primitives, organized as four 8k "pages".  The first page is used for and reserved by the Sista optimizing compiler.  The second page is usd for and reserved by the Lowcode FFI marshalling primitive set.  The other two sets are unspecified and unused.

Here is the specification of the Sista unsafe instructions (unsafe operations, set 00). The lowcode set uses external specifications.
We sort the inline primitive operations by arity.  Nullary primitives occupy the 0-999 range. Unary primitives occupy the 1-1999 range, up until 8 args. 8191 instructions can be encoded in each unsafe operation set, instructions from 0 to 7 arguments can have 1000 different instructions each, while 8 args instructions can have 192 different instructions.

Sista defines the following inlined primitives (CallPrimitive iiiiiiii 100jjjjj, n = jjjjjiiiiiiii)
1000	class
1001	pointer numSlots
1002	pointer basicSize
1003	byte8Type format numBytes (includes CompiledMethod)
1004	short16Type format numShorts
1005	word32Type format numWords
1006	doubleWord64Type format numDoubleWords
	
1010	ensure number of bytes available.
1011	fixed-sized new. (objects with 0 to n inst vars)
	
1020 	identityHash (non-immediate, non-Behavior)
1021	identityHash (SmallInteger)
1022	identityHash (Character)
1023	identityHash (SmallFloat64)
1024	identityHash (Behavior, has hash?)

1030 	immediateAsInteger (Character)
1031 	immediateAsInteger (SmallFloat64)
1035 	immediateAsFloat 	(Smallinteger)
	
2000	SmallInteger #+.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2001	SmallInteger #-.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2002	SmallInteger #*.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2003	SmallInteger #/.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2004	SmallInteger #//.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2005	SmallInteger #\\.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2006	SmallInteger #quo:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)

2011	Variable-sized pointers new (new:). Array, etc.
2012	Variable-sized byte new (new:). ByteArray, ByteString, etc.
2013	Variable-sized 16-bit new (new:). DoubleByteArray, etc.
2014	Variable-sized 32-bit new (new:). Bitmap, FloatArray, etc.
2015	Variable-sized 64-bit new (new:). DoubleWordArray, etc.

2016	SmallInteger #bitAnd:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2017	SmallInteger #bitOr:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2018	SmallInteger #bitXor:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2019	SmallInteger #bitShiftLeft:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2020	SmallInteger #bitShiftRight:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)

2032	SmallInteger #>.  Both arguments are SmallIntegers
2033	SmallInteger #<.  Both arguments are SmallIntegers
2034	SmallInteger #>=.  Both arguments are SmallIntegers
2035	SmallInteger #<=.  Both arguments are SmallIntegers
2036	SmallInteger #=.  Both arguments are SmallIntegers
2037	SmallInteger #~=.  Both arguments are SmallIntegers

2064	Pointer Object>>at:.		The receiver is guaranteed to be a pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger
2065	Byte Object>>at:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger.
2066	16-bit Word Object>>at:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger.
2067	32-bit DoubleWord Object>>at:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger or a LargePositiveInteger.
2068	64-bit QuadWord Object>>at:.	The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger or a LargePositiveInteger.

The following instructions can have the ExtB check flag (See (3)).
3000	Pointer Object>>at:put:.			The receiver is guaranteed to be a pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger
3001	Byte Object>>at:put:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 8 bits.
3002	Word Object>>at:put:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 16 bits.
3003	DoubleWord Object>>at:put:.	The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 32 bits.
3004	QuadWord Object>>at:put:.		The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 64 bits.
			
3021	Byte Object >> equals:length:	The receiver and the arguments are both byte objects and have both the same size (length). The length argument is a smallinteger. Answers true if all fields are equal, false if not. Comparison is bulked to word comparison.

4000	Pointer Object>> fillFrom:to:with: The receiver is a Pointer object. the middle two arguments are smallintegers. Last argument is any object. Fills the object in between the two indexes with last argument. Receiver is guaranteed to be mutable. The pointer accesses are raw (no inst var check). If ExtB is set to 1, no store check is present. Else a single store check is done for the bulk operation. Answers the receiver.
	
5000	Pointer Object>> replaceFrom:to:with:startingAt: Src and dest are pointer objects. ScrPos, scrLast and destLast are smallintegers. Receiver is guaranteed to be mutable.  Both ranges are in-bounds. The pointer accesses are raw (no inst var check). As for the normal primitive, the copy is linear. Answers the receiver.


Lowcode defines inlined primitives for the range CallPrimitive iiiiiiii 101jjjjj, n = jjjjjiiiiiiii.!
!BraceNode commentStamp: 'eem 12/24/2024 16:24:49' prior: 16796986!
 Used for compiling and decompiling brace constructs.

These now compile into either a fast short form for 8 elements or less (see maxElementsForConsArray)
that uses the pushConsArrayWithElements: nElements bytecode
or a long form of indefinfite length:
	(Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray.

The erstwhile brace assignment form is no longer supported.!
!ParseNodeEnumerator commentStamp: 'eem 3/19/2019 11:58' prior: 16920433!
                          ParseNodeEnumerator implements ParseNode>>nodesDo:.  It can be used to enumerate an entire tree via
	aParseNode accept: (ParseNodeEnumerator ofBlock: aBlock)
or selectively, excluding the node and subnodes for which selectBlock answers false, via
	aParseNode accept: (ParseNodeEnumerator
							ofBlock: aBlock
							select: selectBlock)
Instance Variables
	theBlock:			<BlockClosure>
	theSelectBlock:		<BlockClosure | nil>

theBlock
	- the block that is evaluated with the parse nodes the receiver visits.

theSelectBlock
	- an optional block used to select blocks to visit and descend into.

Here's a doIt that generates and compiles the visiting methods:

self superclass selectors do:
	[:s|
	self compile: (String streamContents:
		[:str| | arg |
		arg := 'a', (s allButFirst: 5) allButLast.
		str nextPutAll: s, ' ', arg; crtab;
			nextPutAll: '(theSelectBlock isNil or: [theSelectBlock value: '; nextPutAll: arg; nextPutAll: ']) ifFalse:'; crtab;
			tab: 2; nextPutAll: '[^nil].'; crtab;
			nextPutAll: 'theBlock value: '; nextPutAll: arg; nextPut: $.; crtab;
			nextPutAll: '^super '; nextPutAll: s, ' ', arg])]!

ParseNodeEnumerator subclass: #ParseNodeWithPrecedingStatementEnumerator
	instanceVariableNames: 'precedingStatement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!classDefinition: #ParseNodeWithPrecedingStatementEnumerator category: #'Compiler-Support' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
ParseNodeEnumerator subclass: #ParseNodeWithPrecedingStatementEnumerator
	instanceVariableNames: 'precedingStatement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!
!ParseNodeWithPrecedingStatementEnumerator commentStamp: 'eem 3/19/2019 11:55' prior: 0!
                    A ParseNodeWithPrecedingStatementEnumerator is a ParseNodeEnumerator that accepts a binary block in ofBlock:, and hence enumerates statement nodes with their preceding statement, or nil if they are the first.

Instance Variables
	precedingStatement:		<ParseNode | nil>

precedingStatement
	- the preceding statement node, if any
!

VariableScopeFinder subclass: #NarrowerVariableScopeFinder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!classDefinition: #NarrowerVariableScopeFinder category: #'Compiler-Support' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
VariableScopeFinder subclass: #NarrowerVariableScopeFinder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!
!NarrowerVariableScopeFinder commentStamp: 'eem 4/3/2017 11:59' prior: 0!
       A NarrowerVariableScopeFinder is used to find a smaller scope for an already declared variable.!

Warning subclass: #SimulationSideEffectWarning
	instanceVariableNames: 'primitiveIndex context method receiver arguments suppressed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Exceptions'!

!classDefinition: #SimulationSideEffectWarning category: #'Kernel-Exceptions' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
Warning subclass: #SimulationSideEffectWarning
	instanceVariableNames: 'primitiveIndex context method receiver arguments suppressed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Exceptions'!
!SimulationSideEffectWarning commentStamp: 'ct 3/3/2024 19:17' prior: 0!
                 I am signaled to notify the client of the simulator (i.e., a sender of Context>>step) about potential side effects of the next instruction to be executed that would escape the control of the simulator. For example, I am signaled before the simulated code starts another process. See Context>>doPrimitive:method:receiver:args:, my messageText, and Parser>>simulationGuard for more information.!

Object subclass: #ImplicitLiteralInstructionClientHook
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!classDefinition: #ImplicitLiteralInstructionClientHook category: #'Kernel-Methods' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
Object subclass: #ImplicitLiteralInstructionClientHook
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!
!ImplicitLiteralInstructionClientHook commentStamp: 'eem 9/16/2021 19:35' prior: 0!
   ImplicitLiteralInstructionClientHook is a hook to allow clients to intercept bytecodes referencing implicit literals, such as special selector sends which have an implicit selector in Smalltalk specialSelectors.  It implements the messages sent by InstructionStream's interpretNextXXXInstructionFor: methods for bytecodes that reference implicit literals as sends of the relevant explciit literal methods.  This allows clients that want to to intercept implicit literal messages while leaving existing clients unchanged.

The class also supports CompiledCode>>abstractBytecodeMessagesFrom:to:do: et al which depend on MessageNotUnderstood to collect bytecode messages.  Use of instances of this class hides the existence of pushSpecialConstant: and sendSpecial:numArgs: since these are understood, but their sends of pushConstant: and send:super:numArgs: are not.

Instance Variables!

ImplicitLiteralInstructionClientHook subclass: #InstructionClient
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!classDefinition: #InstructionClient category: #'Kernel-Methods' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
ImplicitLiteralInstructionClientHook subclass: #InstructionClient
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!
!BlockLocalTempCounter commentStamp: 'eem 1/11/2018 08:30' prior: 16793992!
                             I am a support class for the decompiler that is used to find the number of local temps in a block by finding out what the stack offset is at the end of a block.  I am necessary because in the EncoderForV3PlusClosures bytecode set the only way to initialize block-local temporaries is with pushConstant: nil bytecodes, but such bytecodes are ambiguous with a pushConstant: nil used to pass nil as a parameter or answer it as a result.  By scanning through to the end of the block these can be disambiguated by tracking the stack depth.!

InstructionStream subclass: #Decompiler
	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps blockStartsToTempVars tempVarCount lastJumpIfPcStack tempReadCounts '
	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag OtherwiseFlag '
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Decompiler category: #'Compiler-Kernel' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:11'!
InstructionStream subclass: #Decompiler
	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps blockStartsToTempVars tempVarCount lastJumpIfPcStack tempReadCounts'
	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag OtherwiseFlag'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!
!Decompiler commentStamp: '<historical>' prior: 16845382!
                    I decompile a method in three phases:
	Reverser: postfix byte codes -> prefix symbolic codes (nodes and atoms)
	Parser: prefix symbolic codes -> node tree (same as the compiler)
	Printer: node tree -> text (done by the nodes)
	

instance vars:

	constructor <DecompilerConstructor> an auxiliary knowing how to generate Abstract Syntax Tree (node tree)
	method <CompiledMethod> the method being decompiled
	instVars <Array of: String> the instance variables of the class implementing method
	tempVars <String | (OrderedCollection of: String)> hold the names of temporary variables (if known)
		NOTE: POLYMORPHISM WILL BE RESOLVED IN #initSymbols:
	constTable <Collection of: ParseNode> parse node associated with byte encoded constants (nil true false 0 1 -1 etc...)
	stack <OrderedCollection of: (ParseNode | String | Integer) > multipurpose...
	statements <OrderedCollection of: ParseNode> the statements of the method being decompiled 
	lastPc <Integer>
	exit <Integer>
	caseExits <OrderedCollection of: Integer> - stack of exit addresses that have been seen in the branches of caseOf:'s
	lastJumpPc <Integer>
	lastReturnPc <Integer>
	limit <Integer>
	hasValue <Boolean>
	blockStackBase <Integer>
	numLocaltemps <Integer | Symbol> - number of temps local to a block; also a flag indicating decompiling a block
	blockStartsToTempVars <Dictionary key: Integer value: (OrderedCollection of: String)>
	tempVarCount <Integer> number of temp vars used by the method
	lastJumpIfPcStack <OrderedCollection of: Integer> the value of program counter just before the last encountered conditional jumps
	tempReadCounts <Dictionary key: String value: Integer> the count of reads of temporaries, used to transform whiole lloops to to:[by:]do: loops accurately!
!Object methodsFor: 'testing' stamp: 'eem 1/4/2025 18:34:20'!
             isCompiledCode

	^ false! !
!CompiledMethod methodsFor: 'accessing' stamp: 'eem 2/19/2012 10:59'!
                              clearSignFlag
	"Clear the sign flag bit.  The sign flag bit may be
	 used by the VM to select an alternate bytecode set."

	self signFlag ifTrue:
		[self objectAt: 1 put: self header - SmallInteger minVal]! !
!CompiledMethod methodsFor: 'accessing' stamp: 'eem 2/19/2012 10:59'!
         setSignFlag
	"Set the sign flag bit.  The sign flag bit may be
	 used by the VM to select an alternate bytecode set."

	self signFlag ifFalse:
		[self objectAt: 1 put: self header + SmallInteger minVal]! !
!CompiledMethod methodsFor: 'accessing' stamp: 'eem 2/19/2012 10:59'!
            signFlag
	"Answer the sign flag bit.  The sign flag bit may be
	 used by the VM to select an alternate bytecode set."

	^self header < 0! !
!CompiledMethod methodsFor: 'testing' stamp: 'eem 1/4/2025 18:35:02'!
              isCompiledBlock

	^false! !
!CompiledMethod methodsFor: 'testing' stamp: 'eem 1/4/2025 18:34:53' overrides: 50344089!
          isCompiledCode

	^true! !
!CompiledMethod methodsFor: 'testing' stamp: 'eem 1/4/2025 18:35:10'!
isCompiledMethod

	^true! !
!CompiledMethod class methodsFor: 'method encoding' stamp: 'eem 10/9/2020 11:22'!
                  primaryBytecodeSetEncoderClass
	^PrimaryBytecodeSetEncoderClass! !
!CompiledMethod class methodsFor: 'method encoding' stamp: 'eem 10/9/2020 11:22'!
           secondaryBytecodeSetEncoderClass
	^SecondaryBytecodeSetEncoderClass! !
!CompiledMethod class methodsFor: 'accessing' stamp: 'eem 12/26/2024 13:45:51'!
         preferredBytecodeSetEncoderClass
	^PreferredBytecodeSetEncoderClass! !
!CompiledMethod class methodsFor: 'preferences' stamp: 'mt 10/15/2020 13:45:18.47243'!
  preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass
	"Set the class that determines the bytecode set used to compile methods with.
			[| nPrimary nSecondary |
			nPrimary := nSecondary := 0.
			self allSubInstancesDo:
				[:cm|
				cm header >= 0
					ifTrue: [nPrimary := nPrimary + 1]
					ifFalse: [nSecondary := nSecondary + 1]].
			{nPrimary. nSecondary}]"
	| nPrimary nSecondary |
	aBytecodeEncoderSubclass ifNil: [ "Use default value."
		PreferredBytecodeSetEncoderClass := nil.
		^ self preferredBytecodeSetEncoderClass: self preferredBytecodeSetEncoderClass].
	self assert: (aBytecodeEncoderSubclass includesBehavior: BytecodeEncoder).
	(aBytecodeEncoderSubclass == PrimaryBytecodeSetEncoderClass
	 or: [aBytecodeEncoderSubclass == SecondaryBytecodeSetEncoderClass]) ifTrue:
		[PreferredBytecodeSetEncoderClass := aBytecodeEncoderSubclass.
		 ^self].
	nPrimary := nSecondary := 0.
	self allSubInstancesDo:
		[:cm|
		 cm header >= 0
			ifTrue: [nPrimary := nPrimary + 1]
			ifFalse: [nSecondary := nSecondary + 1]].
	nPrimary = 0 ifTrue:
		[self installPrimaryBytecodeSet: aBytecodeEncoderSubclass.
		 ^self preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass].
	nSecondary = 0 ifTrue:
		[self installSecondaryBytecodeSet: aBytecodeEncoderSubclass.
		 ^self preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass].
	self error: 'Cannot set preferred bytecode set.  Both of the current sets appear to be in use.'! !
!ParseNode methodsFor: 'visiting' stamp: 'eem 1/3/2019 15:46'!
nodesWithPrecedingStatementsDo: aBinaryBlock
	self accept: (ParseNodeWithPrecedingStatementEnumerator ofBlock: aBinaryBlock)! !
!ParseNode methodsFor: 'private' stamp: 'mt 9/4/2019 09:21'!
   ifNilTemporary

	^ nil! !
!BytecodeEncoder methodsFor: 'testing' stamp: 'eem 1/10/2018 13:56'!
 supportsFullBlocks
	"Answer if the instruction set supports full closures (closure creation from
	 specfic methods instead of bytecodes embedded in an outer home method)."

	^self subclassResponsibility! !
!BytecodeEncoder methodsFor: 'special literal encodings' stamp: 'eem 12/26/2024 11:32:36'!
                       isSpecialLiteralForPush: literal

	^self subclassResponsibility! !
!BytecodeEncoder methodsFor: 'special literal encodings' stamp: 'eem 12/26/2024 11:31:27'!
  isSpecialLiteralForReturn: literal
	^literal == false
	  or: [literal == true
	  or: [literal == nil]]! !
!BytecodeEncoder methodsFor: 'accessing' stamp: 'eem 12/24/2024 16:40:27'!
           nextPC
	"Answer the pc to store in a node for source range identification when the node is associated with its following pc."
	^stream position + 1! !
!BytecodeEncoder methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 10:56'!
                         genPushNClosureTemps: numTemps
	"To reduce the number of bytecodes required, the embedded
	 block closure implementation uses explicit push nil instructions
	 to create block-local temps.  In bytecode sets supporting
	 FullBlockClosure/CompiledBlock this isn't needed and the
	 number of temps is derived from the block method header."
	numTemps timesRepeat: [self genPushSpecialLiteral: nil]! !
!BytecodeEncoder class methodsFor: 'bytecode decoding' stamp: 'eem 4/6/2017 14:12' overrides: 16920334!
            pushNilCode
	"Answer the pushNil bytecode."
	^self subclassResponsibility! !
!BytecodeEncoder class methodsFor: 'bytecode decoding' stamp: 'eem 8/8/2014 19:23'!
                               stackDeltaForPrimitive: primitiveIndex in: method
	"This is the default implementation.  Subclasses with inline primitives will need to override."
	^0! !
!BytecodeEncoder class methodsFor: 'instruction stream support' stamp: 'eem 7/5/2022 16:05'!
         isReturnSelfFromMethodAt: pc in: method
	"Answer whether the bytecode at pc is a return self from method."

	self subclassResponsibility! !
!BytecodeEncoder class methodsFor: 'instruction stream support' stamp: 'eem 6/3/2024 10:25'!
                       isSuperSendAt: pc in: method
	"Answer whether the bytecode at pc is a message-send to super."

	self subclassResponsibility! !
!BytecodeEncoder class methodsFor: 'testing' stamp: 'eem 10/9/2021 17:28'!
                      canBeSpecialLiteral: aLiteral
	"This check can be used to prevent unnecessary use of #scanBlockOrNilForLiteral:. For performance, this method summarizes specializations from all known bytecode encoders. It is not meant to be refined per bytecode encoder."

	aLiteral isVariableBinding ifTrue: [^false]. "a common case; don't waste time analysing..."
	
	aLiteral isSymbol ifTrue: [^ Smalltalk specialSelectors identityIncludes: aLiteral].
	aLiteral isCharacter ifTrue: [^ aLiteral asInteger <= 65535].
	aLiteral isInteger ifTrue: [^ aLiteral between: -32768 and: 32767].

	aLiteral == true ifTrue: [^ true].
	aLiteral == false ifTrue: [^ true].
	aLiteral == nil ifTrue: [^ true].

	^ false! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:28'!
                          genBranchPopFalse: distance
	(distance > 0 and: [distance < 9]) ifTrue:
		["192-199	11000 iii			Pop and Jump 0n False iii + 1 (i.e., 1 through 8)"
		 stream nextPut: 191 + distance.
		 ^self].
	^self genBranchPopFalseLong: distance! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:33'!
   genBranchPopFalseLong: distance
	"239		11101111	iiiiiiii		Pop and Jump 0n False #iiiiiiii (+ Extend B * 256, where Extend B >= 0)	"
	| distanceMod256 |
	(distance < 0 or: [distance > 32767]) ifTrue:
		[^self outOfRangeError: 'distance' index: distance range: 0 to: 32767].
	distanceMod256 := (distance < 0 or: [distance > 255])
							ifTrue:
								[self genUnsignedSingleExtendB: (distance bitShift: -8).
								 distance bitAnd: 255]
							ifFalse: [distance].
	stream
		nextPut: 239;
		nextPut: distanceMod256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:31'!
      genBranchPopTrue: distance
	(distance > 0 and: [distance < 9]) ifTrue:
		["184-191	10111 iii			Pop and Jump 0n True iii + 1 (i.e., 1 through 8)"
		 stream nextPut: 183 + distance.
		 ^self].
	^self genBranchPopTrueLong: distance! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:33'!
      genBranchPopTrueLong: distance
	"238		11101110	iiiiiiii		Pop and Jump 0n True #iiiiiiii (+ Extend B * 256, where Extend B >= 0)"
	| distanceMod256 |
	(distance < 0 or: [distance > 32767]) ifTrue:
		[^self outOfRangeError: 'distance' index: distance range: 0 to: 32767].
	(distance > 0 and: [distance < 9]) ifTrue:
		["184-191	10111 iii			Pop and Jump 0n True iii + 1 (i.e., 1 through 8)"
		 stream nextPut: 183 + distance.
		 ^self].
	distanceMod256 := (distance < 0 or: [distance > 255])
							ifTrue:
								[self genUnsignedSingleExtendB: (distance bitShift: -8).
								 distance bitAnd: 255]
							ifFalse: [distance].
	stream
		nextPut: 238;
		nextPut: distanceMod256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 7/25/2016 14:10'!
     genCallInlinePrimitive: primitiveIndex
	"	248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
								m=1 means inlined primitive, no hard return after execution. 
								ss defines the unsafe operation set used to encode the operations. 
								(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are not used)"
	"N.B. We could have made CallPrimitive a 2-byte code taking an extension, but that would
	 complicate the VM's determination of the primitive number and the primitive error code
	 store since the extension, being optional, would make the sequence variable length."
	(primitiveIndex < 1 or: [primitiveIndex > 32767]) ifTrue:
		[self outOfRangeError: 'primitive index' index: primitiveIndex range: 1 to: 32767].
	stream
		nextPut: 248;
		nextPut: (primitiveIndex bitAnd: 255);
		nextPut: (primitiveIndex bitShift: -8) + 128! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 10:11'!
      genCallPrimitive: primitiveIndex
	"248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
								m=1 means inlined primitive, no hard return after execution. 
								ss defines the unsafe operation set used to encode the operations. 
								(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are not used)"
	"N.B. We could have made CallPrimitive a 2-byte code taking an extension, but that would
	 complicate the VM's determination of the primitive number and the primitive error code
	 store since the extension, being optional, would make the sequence variable length."
	(primitiveIndex < 1 or: [primitiveIndex > 32767]) ifTrue:
		[self outOfRangeError: 'primitive index' index: primitiveIndex range: 1 to: 32767].
	stream
		nextPut: 248;
		nextPut: (primitiveIndex bitAnd: 255);
		nextPut: (primitiveIndex bitShift: -8)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:57'!
                   genDup
	"83			01010011			Duplicate Stack Top"
	stream nextPut: 83! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:59'!
         genJump: distance
	(distance > 0 and: [distance < 9]) ifTrue:
		["176-183	10110 iii			Jump iii + 1 (i.e., 1 through 8)"
		 stream nextPut: 175 + distance.
		 ^self].
	"237		11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)"
	^self genJumpLong: distance! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:59'!
                   genJumpLong: distance
	"237		11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)"
	(distance between: -32768 and: 32767) ifFalse:
		[^self outOfRangeError: 'index' index: distance range: -32768 to: 32767].
	(distance < 0 or: [distance > 255]) ifTrue:
		[self genSignedSingleExtendB: (distance bitShift: -8)].
	stream
		nextPut: 237;
		nextPut: (distance bitAnd: 255)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 16:27'!
   genNop
	"95			01011111			Nop"
	stream nextPut: 95! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 17:01'!
                         genPop
	"216		11011000			Pop Stack Top"
	stream nextPut: 216! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 1/4/2025 17:20:44'!
           genPushCharacter: aCharacterOrCode
	"233		11101001	i i i i i i i i	Push Character #iiiiiiii (+ Extend A * 256)"
	"Why restrict the range to 16 bits when we could encode arbitrary 32-bit Characters?
	 Well, 16 bits requires 4 bytes (extA + byte, 233 + byte) and so beyond this range we
	 lose space verses a single-byte pushLiteral and a 4 byte Character literal on 32-bits.
	 And generating the same bytecode on 64-bit and 32-bit versions is important if we
	 want to be able to load binary code from one to the other (e.g. via Fuel)."
	| code |
	code := aCharacterOrCode isInteger ifTrue: [aCharacterOrCode] ifFalse: [aCharacterOrCode codePoint].
	(code < 0 or: [code > 65535]) ifTrue:
		[^self outOfRangeError: 'character' index: code range: 0 to: 65535].
	(code > 255) ifTrue:
		[self genUnsignedSingleExtendA: (code bitShift: -8)].
	stream
		nextPut: 233;
		nextPut: (code bitAnd: 255)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/7/2014 17:01'!
                 genPushClosureCopyNumCopiedValues: numCopied numArgs: numArgs jumpSize: jumpSize
	"250		11111010 eeiiikkk		jjjjjjjj		Push Closure Num Copied iii (+ Ext A // 16 * 8) Num Args kkk (+ Ext A \\ 16 * 8) BlockSize jjjjjjjj (+ Ext B * 256). ee = num extensions"
	"Including numExtensions makes decoding the bytecode quicker since it obviates having to scan from the beginning of a method."
	| numExtensions numCopiedMod8 numArgsMod8 extA |
	(jumpSize < 0 or: [jumpSize > 65535]) ifTrue:
		[^self outOfRangeError: 'block size' index: jumpSize range: 0 to: 65535].
	(numCopied < 0 or: [numCopied > 127]) ifTrue:
		[^self outOfRangeError: 'num copied' index: numCopied range: 0 to: 127].
	(numArgs < 0 or: [numArgs > 127]) ifTrue:
		[^self outOfRangeError: 'num args' index: numArgs range: 0 to: 127].
	extA := numExtensions := 0.
	(numArgsMod8 := numArgs) > 7 ifTrue:
		[extA := numArgs // 8.
		 numArgsMod8 := numArgsMod8 \\ 8].
	(numCopiedMod8 := numCopied) > 7 ifTrue:
		[extA := extA + (numCopied // 8 * 16).
		 numCopiedMod8 := numCopiedMod8 \\ 8].
	extA ~= 0 ifTrue:
		[self genUnsignedSingleExtendA: extA.
		 numExtensions := 1].
	jumpSize > 255 ifTrue:
		[numExtensions := numExtensions + 1.
		 self genUnsignedSingleExtendB: jumpSize // 256].
	stream
		nextPut: 250;
		nextPut: (numExtensions bitShift: 6) + (numCopiedMod8 bitShift: 3) + numArgsMod8;
		nextPut: (jumpSize bitAnd: 16rFF)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/1/2015 10:32'!
 genPushConsArray: size
	(size < 0 or: [size > 127]) ifTrue:
		[^self outOfRangeError: 'size' index: size range: 0 to: 127].
	"231		11100111	jkkkkkkk	Push (Array new: kkkkkkk) (j = 0)
									&	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)"
	stream
		nextPut: 231;
		nextPut: size + 128! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 3/23/2017 16:37'!
 genPushFullClosure: compiledBlockLiteralIndex numCopied: numCopied
	"By default the closure will have an outer context and the receiver will be fetched from the current context"
	self genPushFullClosure: compiledBlockLiteralIndex numCopied: numCopied receiverOnStack: false ignoreOuterContext: false! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 3/23/2017 16:48'!
                              genPushFullClosure: compiledBlockLiteralIndex numCopied: numCopied receiverOnStack: receiverOnStack ignoreOuterContext: ignoreOuterContext
	"*	249		11111001 	xxxxxxxx	siyyyyyy	push Closure Compiled block literal index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1 ignoreOuterContext: i = 1"
	| extendedIndex |
	(numCopied < 0 or: [numCopied > 64]) ifTrue:
		[self outOfRangeError: 'num copied' index: numCopied range: 1 to: 64].
	(compiledBlockLiteralIndex < 0 or: [compiledBlockLiteralIndex > 32767]) ifTrue:
		[^self outOfRangeError: 'index' index: compiledBlockLiteralIndex range: 0 to: 32767].
	(extendedIndex := compiledBlockLiteralIndex) > 255 ifTrue:
		[self genUnsignedSingleExtendA: extendedIndex // 256.
		 extendedIndex := extendedIndex \\ 256].
	stream
		nextPut: 249;
		nextPut: extendedIndex;
		nextPut: receiverOnStack asBit << 7 + (ignoreOuterContext asBit << 6) + numCopied! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 10/12/2012 15:12'!
                      genPushInstVar: instVarIndex
	(instVarIndex between: 0 and: 15) ifTrue:
		["0-15 	0000iiii 	Push Receiver Variable #iiii"
		 stream nextPut: 0 + instVarIndex.
		 ^self].
	self genPushInstVarLong: instVarIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:28'!
                          genPushInstVarLong: instVarIndex
	"226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A * 256)"
	"See also MaybeContextInstanceVariableNode"
	(instVarIndex < 0 or: [instVarIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 65535].
	instVarIndex > 255 ifTrue:
		[self genUnsignedSingleExtendA: instVarIndex // 256].
	stream
		nextPut: 226;
		nextPut: instVarIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 09:22'!
                           genPushInteger: anInteger
	"80			01010000				Push 0
	 81			01010001				Push 1
	 232		11101000	i i i i i i i i	Push Integer #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)"
	"Why restrict the range to 16 bits when we could encode arbitrarily large integers?
	 Well, 16 bits requires 4 bytes (extB + byte, 78 + byte) and so beyond this range we lose space
	 verses a single-byte pushLiteral and a 4 byte integer literal on 32-bits.  And generating the same
	 bytecode on 64-bit and 32-bit is important if we want to be able to load binary code from one to
	 the other (e.g. via Fuel)."
	anInteger = 0 ifTrue:
		[stream nextPut: 80.
		 ^self].
	anInteger = 1 ifTrue:
		[stream nextPut: 81.
		 ^self].
	(anInteger < -32768 or: [anInteger > 32767]) ifTrue:
		[^self outOfRangeError: 'integer' index: anInteger range: -32768 to: 32767].
	(anInteger < 0 or: [anInteger > 255]) ifTrue:
		[self genSignedSingleExtendB: (anInteger bitShift: -8)].
	stream
		nextPut: 232;
		nextPut: (anInteger bitAnd: 255)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 10:25'!
  genPushLiteral: literalIndex
	| extendedIndex |
	(literalIndex < 0 or: [literalIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 65535].
	literalIndex < 32 ifTrue: 
		["32-63 	001iiiii 	Push Literal #iiiii"
		 stream nextPut: 32 + literalIndex.
		 ^self].
	"228		11100100	i i i i i i i i	Push Literal #iiiiiiii (+ Extend A * 256)"
	(extendedIndex := literalIndex) > 255 ifTrue:
		[self genUnsignedSingleExtendA: extendedIndex // 256.
		 extendedIndex := extendedIndex \\ 256].
	stream
		nextPut: 228;
		nextPut: extendedIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 10/18/2012 14:51'!
                genPushLiteralVar: literalIndex
	| extendedIndex |
	(literalIndex < 0 or: [literalIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 65535].
	literalIndex < 16 ifTrue: 
		["16-31		0001 i i i i		Push Literal Variable #iiii"
		 stream nextPut: 16 + literalIndex.
		 ^self].
	"227		11100011	i i i i i i i i	Push Literal Variable #iiiiiiii (+ Extend A * 256)"
	(extendedIndex := literalIndex) > 255 ifTrue:
		[self genUnsignedSingleExtendA: extendedIndex // 256.
		 extendedIndex := extendedIndex \\ 256].
	stream
		nextPut: 227;
		nextPut: extendedIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 11/4/2012 15:01'!
                         genPushNewArray: size
	(size < 0 or: [size > 127]) ifTrue:
		[^self outOfRangeError: 'size' index: size range: 0 to: 127].
	"231		11100111	jkkkkkkk	Push (Array new: kkkkkkk) (j = 0)
									&	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)"
	stream
		nextPut: 231;
		nextPut: size! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 10/18/2012 14:43'!
     genPushReceiver
	"76			01001100		Push Receiver"
	stream nextPut: 76! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/4/2016 18:02'!
        genPushRemoteTemp: tempIndex inVectorAt: tempVectorIndex
	"251		11111011 	kkkkkkkk	sjjjjjjj		Push Temp At kkkkkkkk In Temp Vector At: jjjjjjj, s = 1 implies remote inst var access instead of remote temp vector access"
	(tempIndex < 0 or: [tempIndex >= 256]) ifTrue:
		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].
	(tempVectorIndex < 0 or: [tempVectorIndex >= 128]) ifTrue:
		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 127].
	stream
		nextPut: 251;
		nextPut: tempIndex;
		nextPut: tempVectorIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 1/2/2018 13:16'!
                      genPushSpecialLiteral: aLiteral
	"77			01001101			Push true
	 78			01001110			Push false
	 79			01001111			Push nil
	 80			01010000			Push 0
	 81			01010001			Push 1
	 232		11101000	iiiiiiii		Push Integer #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)
	 233		11101001	i i i i i i i i	Push Character #iiiiiiii (+ Extend B * 256)"
	| index |
	aLiteral isInteger ifTrue:
		[aLiteral == 0 ifTrue:
			[stream nextPut: 80.
			 ^self].
		 aLiteral == 1 ifTrue:
			[stream nextPut: 81.
			 ^self].
		 ^self genPushInteger: aLiteral].
	aLiteral isCharacter ifTrue:
		[^self genPushCharacter: aLiteral].
	index := #(true false nil)
					indexOf: aLiteral
					ifAbsent: [^self error: 'push special literal: ', aLiteral printString,  ' is not one of true false nil'].
	stream nextPut: 76 + index! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 09:52'!
                    genPushTemp: tempIndex
	(tempIndex < 0 or: [tempIndex > 63]) ifTrue:
		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].
	tempIndex < 12 ifTrue: 
		["64-71		01000 i i i		Push Temporary Variable #iii
		   72-75	010010 i i		Push Temporary Variable #ii + 8"
		 stream nextPut: 64 + tempIndex.
		 ^self].
	"229		11100101	i i i i i i i i	Push Temporary Variable #iiiiiiii"
	stream
		nextPut: 229;
		nextPut: tempIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 7/28/2014 20:51'!
                            genPushThisContext
	"82			01010010			Push thisContext, (then e.g. Extend B 1 = push thisProcess)"
	stream nextPut: 82! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 1/5/2018 12:12'!
                     genReturnNilToCaller
	"93			01011101			BlockReturn nil [* return from enclosing block N, ExtA]"
	"If extended, the least significant bit of the extension determines if we return to the caller or not
	 and the most significant bits determine how many levels of the static chain to return from.
		ExtA = iiiiiiij
		iiiiiii=0,j=0	=>	return to caller
		iiiiiii=0,j=1	=>	illegal
		iiiiiii=1,j=0	=>	return to outerContext
		iiiiiii=1,j=1	=>	return to outerContext sender/return from outerContext
		iiiiiii=2,j=0	=>	return to outerContext outerContext
		iiiiiii=2,j=1	=>	return to outerContext outerContext sender/return from outerContext outerContext
		etc"

	stream nextPut: 93! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 09:56'!
          genReturnReceiver
	"88-91		010110 ii			Return Receiver/true/false/nil"
	stream nextPut: 88! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 09:58'!
                genReturnSpecialLiteral: aLiteral
	"88-91		010110 ii			Return Receiver/true/false/nil"
	| index |
	index := #(true false nil) indexOf: aLiteral ifAbsent: 0.
	index = 0 ifTrue:
		[^self error: 'return special literal: ', aLiteral printString,  ' is not one of true false nil'].
	stream nextPut: 88 + index! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:06'!
                          genReturnTop
	"92		1011100		Return Stack Top From Message"
	stream nextPut: 92! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/1/2015 09:59'!
                             genReturnTopToCaller
	"94		01011110		Return Stack Top From Block [* return from enclosing block N, ExtA]"
	"If extended, the least significant bit of the extension determines if we return to the caller or not
	 and the most significant bits determine how many levels of the static chain to return from.
		ExtA = iiiiiiij
		iiiiiii=0,j=0	=>	return to caller
		iiiiiii=0,j=1	=>	illegal
		iiiiiii=1,j=0	=>	return to outerContext
		iiiiiii=1,j=1	=>	return to outerContext sender/return from outerContext
		iiiiiii=2,j=0	=>	return to outerContext outerContext
		iiiiiii=2,j=1	=>	return to outerContext outerContext sender/return from outerContext outerContext
		etc"

	stream nextPut: 94! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 14:27'!
genSend: selectorLiteralIndex numArgs: nArgs
	| extendedIndex extendedNArgs |
	(selectorLiteralIndex < 0 or: [selectorLiteralIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'selectorLiteralIndex' index: selectorLiteralIndex range: 0 to: 65535].
	(nArgs < 0 or: [nArgs > 31]) ifTrue:
		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 "!!!!"].
	(selectorLiteralIndex < 16 and: [nArgs < 3]) ifTrue: 
	 	["128-143	1000 iiii			Send Literal Selector #iiii With 0 Argument
		  144-159	1001 iiii			Send Literal Selector #iiii With 1 Arguments
		  160-175	1010 iiii			Send Literal Selector #iiii With 2 Arguments"
		 stream nextPut: 128 + (nArgs * 16) + selectorLiteralIndex.
		 ^self].
	(extendedIndex := selectorLiteralIndex) > 31 ifTrue:
		[self genUnsignedMultipleExtendA: extendedIndex // 32.
		 extendedIndex := extendedIndex \\ 32].
	(extendedNArgs := nArgs) > 7 ifTrue:
		[self genUnsignedSingleExtendB: extendedNArgs // 8.
		 extendedNArgs := extendedNArgs \\ 8].
	"234		11101010	i i i i i j j j	Send Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"
	stream
		nextPut: 234;
		nextPut: extendedNArgs + (extendedIndex * 8)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 15:26'!
                           genSendDirectedSuper: selectorLiteralIndex numArgs: nArgs
	| extendedIndex |
	(selectorLiteralIndex < 0 or: [selectorLiteralIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'selectorLiteralIndex' index: selectorLiteralIndex range: 0 to: 65535].
	(nArgs < 0 or: [nArgs > 31]) ifTrue:
		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 "!!!!"].
	(extendedIndex := selectorLiteralIndex) > 31 ifTrue:
		[self genUnsignedMultipleExtendA: extendedIndex // 32.
		 extendedIndex := extendedIndex \\ 32].
	"Bit 6 of the ExtB byte is the directed send flag.  Bit 6 allows for future expansion to up to 255 args."
	self genUnsignedSingleExtendB: nArgs // 8 + 64.
	"235		11101011	iiiiijjj		Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"
	stream
		nextPut: 235;
		nextPut: nArgs \\ 8 + (extendedIndex * 8)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:21'!
                genSendSpecial: specialSelectorIndex numArgs: nArgs
	self assert: (specialSelectorIndex between: 1 and: Smalltalk specialSelectorSize).
	self assert: nArgs = (Smalltalk specialNargsAt: specialSelectorIndex).
	"Special selector sends.
		96-111		0110 iiii			Send Arithmetic Message #iiii #(#+ #- #< #> #'<=' #'>=' #= #'~=' #* #/ #'\\' #@ #bitShift: #'//' #bitAnd: #bitOr:)
		112-119	01110 iii			Send Special Message #iii #(#at: #at:put: #size ? ? ? #'==' class ? value value: ? ? ? ? ?)"

	stream nextPut: specialSelectorIndex + 95! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/6/2017 15:26'!
                         genSendSuper: selectorLiteralIndex numArgs: nArgs
	| extendedIndex extendedNArgs |
	(selectorLiteralIndex < 0 or: [selectorLiteralIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'selectorLiteralIndex' index: selectorLiteralIndex range: 0 to: 65535].
	(nArgs < 0 or: [nArgs > 31]) ifTrue:
		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 "!!!!"].
	(extendedIndex := selectorLiteralIndex) > 31 ifTrue:
		[self genUnsignedMultipleExtendA: extendedIndex // 32.
		 extendedIndex := extendedIndex \\ 32].
	(extendedNArgs := nArgs) > 7 ifTrue:
		[self genUnsignedSingleExtendB: extendedNArgs // 8.
		 extendedNArgs := extendedNArgs \\ 8].
	"235		11101011	iiiiijjj		Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"
	stream
		nextPut: 235;
		nextPut: extendedNArgs + (extendedIndex * 8)! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 10/22/2012 16:07'!
                          genSignedSingleExtendB: extendedIndex
	(extendedIndex between: -128 and: 127) ifFalse:
		[^self outOfRangeError: 'index' index: extendedIndex range: -128 to: 127].
	"225		11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)"
	stream
		nextPut: 225;
		nextPut: (extendedIndex >= 0 ifTrue: [extendedIndex] ifFalse: [extendedIndex + 256]) ! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:27'!
                 genStoreInstVar: instVarIndex
	"243		11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	self genStoreInstVarLong: instVarIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:28'!
                      genStoreInstVarLong: instVarIndex
	"243		11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	(instVarIndex < 0 or: [instVarIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 65535].
	instVarIndex > 255 ifTrue:
		[self genUnsignedSingleExtendA: instVarIndex // 256].
	stream
		nextPut: 243;
		nextPut: instVarIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:35'!
             genStoreLiteralVar: literalIndex
	"244		11110100	iiiiiiii		Store Literal Variable #iiiiiiii (+ Extend A * 256)"
	(literalIndex < 0 or: [literalIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 65535].
	literalIndex > 255 ifTrue: 
		[self genUnsignedSingleExtendA: literalIndex // 256].
	stream
		nextPut: 244;
		nextPut: literalIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:37'!
             genStorePopInstVar: instVarIndex
	"200-207	11001 iii			Pop and Store Receiver Variable #iii
	 240		11110000	iiiiiiii	Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	(instVarIndex < 0 or: [instVarIndex > 7]) ifTrue:
		[^self genStorePopInstVarLong: instVarIndex].
	stream nextPut: 200 + instVarIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:37'!
                  genStorePopInstVarLong: instVarIndex
	"240		11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	(instVarIndex < 0 or: [instVarIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 65535].
	instVarIndex > 255 ifTrue:
		[self genUnsignedSingleExtendA: instVarIndex // 256].
	stream
		nextPut: 240;
		nextPut: instVarIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:39'!
  genStorePopLiteralVar: literalIndex
	"241		11110001	iiiiiiii		Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256)"
	(literalIndex < 0 or: [literalIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 65535].
	literalIndex > 255 ifTrue: 
		[self genUnsignedSingleExtendA: literalIndex // 256].
	stream
		nextPut: 241;
		nextPut: literalIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/4/2016 18:01'!
   genStorePopRemoteTemp: tempIndex inVectorAt: tempVectorIndex
	"*	253	(3)	11111101 	kkkkkkkk	sjjjjjjj		Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access"
	(tempIndex < 0 or: [tempIndex >= 256]) ifTrue:
		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].
	(tempVectorIndex < 0 or: [tempVectorIndex >= 128]) ifTrue:
		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 127].
	stream
		nextPut: 253;
		nextPut: tempIndex;
		nextPut: tempVectorIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 4/8/2014 10:43'!
     genStorePopTemp: tempIndex
	"208-215	11010 iii			Pop and Store Temporary Variable #iii
	 242		11110010	iiiiiiii	Pop and Store Temporary Variable #iiiiiiii"
	(tempIndex < 0 or: [tempIndex > 63]) ifTrue:
		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].
	tempIndex < 8 ifTrue:
		[stream nextPut: 208 + tempIndex.
		 ^self].
	stream
		nextPut: 242;
		nextPut: tempIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/4/2016 18:02'!
          genStoreRemoteTemp: tempIndex inVectorAt: tempVectorIndex
	"*252	(3)	11111100 	kkkkkkkk	sjjjjjjj		Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access"
	(tempIndex < 0 or: [tempIndex >= 256]) ifTrue:
		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].
	(tempVectorIndex < 0 or: [tempVectorIndex >= 128]) ifTrue:
		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 127].
	stream
		nextPut: 252;
		nextPut: tempIndex;
		nextPut: tempVectorIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 4/1/2015 09:58'!
                  genStoreTemp: tempIndex
	"245		11110110	iiiiiiii		Store Temporary Variable #iiiiiiii"
	(tempIndex < 0 or: [tempIndex > 63]) ifTrue:
		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].
	stream
		nextPut: 245;
		nextPut: tempIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eem 8/1/2014 06:53'!
                     genTrapIfNotInstanceOf: literalIndex
	"*	236		11101100	iiiiiiii		Trap If Not Instance Of Behavior/Array Of Behavior #iiiiiiii (+ Extend A * 256, where Extend A >= 0)"

	| extendedIndex |
	(literalIndex < 0 or: [literalIndex > 65535]) ifTrue:
		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 65536].
	(extendedIndex := literalIndex) > 255 ifTrue:
		[self genUnsignedSingleExtendA: extendedIndex // 256.
		 extendedIndex := extendedIndex \\ 256].
	stream
		nextPut: 236;
		nextPut: extendedIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'eliot 10/18/2012 14:47'!
       genUnsignedMultipleExtendA: extendedIndex
	"224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)"
	extendedIndex > 255 ifTrue:
		[self genUnsignedMultipleExtendA: extendedIndex // 256].
	stream
		nextPut: 224;
		nextPut: extendedIndex \\ 256! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 7/25/2016 14:23'!
           genUnsignedSingleExtendA: extendedIndex
	(extendedIndex between: 0 and: 255) ifFalse:
		[^self outOfRangeError: 'index' index: extendedIndex range: 0 to: 255].
	"224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	ExtA is normally unsigned."
	stream
		nextPut: 224;
		nextPut: extendedIndex! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'cb 7/25/2016 14:23'!
                        genUnsignedSingleExtendB: extendedIndex
	(extendedIndex between: 0 and: 255) ifFalse:
		[^self outOfRangeError: 'index' index: extendedIndex range: 0 to: 255].
	"225		11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B).
	ExtB is normally signed"
	stream
		nextPut: 225;
		nextPut: extendedIndex! !
!EncoderForSistaV1 methodsFor: 'in-line primitive generation' stamp: 'eem 4/7/2014 16:38'!
                 genInlineSmallIntegerAdd
	^self genCallInlinePrimitive: 0! !
!EncoderForSistaV1 methodsFor: 'special literal encodings' stamp: 'eem 1/4/2025 17:20:28' overrides: 50344210!
                    isSpecialLiteralForPush: literal
	^literal isInteger
		ifFalse:
			[literal isCharacter
				ifFalse:
					[false == literal
					 or: [true == literal
					 or: [nil == literal]]]
				ifTrue:
					[literal codePoint between: 0 and: 65535]]
	 	ifTrue:
			[literal between: -32768 and: 32767]! !
!EncoderForSistaV1 methodsFor: 'accessing' stamp: 'eem 6/15/2016 14:37' overrides: 16853469!
                             maxIndexableLiterals
	"Answer the maximum number of literals supported by the receiver's
	 bytecode set."
	^65536! !
!EncoderForSistaV1 methodsFor: 'testing' stamp: 'eem 12/24/2024 16:35:45' overrides: 50344200!
            supportsFullBlocks
	"Answer if the instruction set supports full closures (closure creation from
	 specfic methods instead of bytecodes embedded in an outer home method).

	N.B. While the Sista set *does* support full blocks we are not using them yet.
	So this implementation, unlike e.g. Squeak, answers false."

	^false! !
!EncoderForSistaV1 methodsFor: 'method generation' stamp: 'eem 8/1/2014 22:45' overrides: 16801958!
                       computeMethodHeaderForNumArgs: numArgs numTemps: numTemps numLits: numLits primitive: primitiveIndex
	numTemps > 63 ifTrue:
		[^self error: 'Cannot compile -- too many temporary variables'].	
	numLits > 65535 ifTrue:
		[^self error: 'Cannot compile -- too many literals'].
	^SmallInteger minVal "sign bit is the flag for the alternative bytecode set"
	+ (numArgs bitShift: 24)
	+ (numTemps bitShift: 18)
	"+ (largeBit bitShift: 17)" "largeBit gets filled in later"
	+ numLits
	+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0])! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:54' overrides: 16802132!
                  bindingReadScanBlockFor: litVarIndex using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of the value of the binding with zero-relative index litVarIndex.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"	16-31		0001 i i i i				Push Literal Variable #iiii
	 *	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	227		11100011	i i i i i i i i	Push Literal Variable #iiiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b < 32 and: [b >= 16 and: [b - 16 = litVarIndex]])
	    or: [b = 227
			and: [scanner followingByte + prevext = litVarIndex]]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:59' overrides: 16802145!
                          bindingWriteScanBlockFor: litVarIndex using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for writes of the value of the binding with zero-relative index litVarIndex.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	241		11110001	iiiiiiii		Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256)
	 *	244		11110100	iiiiiiii		Store Literal Variable #iiiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b = 241 or: [b = 244])
	   and: [scanner followingByte + prevext = litVarIndex]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 6/16/2018 16:29' overrides: 16802158!
         createClosureScanBlock
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for block closure creation bytecodes.  Note that with this interface we can't answer
	 true for the extension in front of a push closure bytecode and so the interface may
	 have to change at some point."

	"*	224	11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	225	11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	**	249	11111001 	xxxxxxxx	siyyyyyy	push Closure Compiled block literal index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1 ignoreOuterContext: i = 1
	 **	250	11111010 	eeiiikkk		jjjjjjjj		Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions"
	^[:b| b >= 249 and: [b <= 250]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:56' overrides: 16802224!
                               extensionsAt: bcpc in: method into: aTrinaryBlock
	"If the bytecode at pc is an extension then evaluate aBinaryBlock with the values of extA and extB and number of extension *bytes*.
	 If the bytecode at pc is not extended then evaluate aBinaryBlock with 0 and 0.
	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	225		11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)"
 
	| scanpc byte extByte extA extB |
	scanpc := bcpc.
	"There may be an extension (it could be a false positive).  We must scan as fast as possible..."
	extA := extB := 0.
	[byte := method at: scanpc.
	 byte >= 224 and: [byte <= 225]] whileTrue: 
		[extByte := method at: scanpc + 1.
		 scanpc := scanpc + 2.
		 byte = 224
			ifTrue:
				[extA := (extA bitShift: 8) + extByte]
			ifFalse:
				[extB := (extB = 0 and: [extByte > 127])
					ifTrue: [extByte - 256]
					ifFalse: [(extB bitShift: 8) + extByte]]].
	^aTrinaryBlock value: extA value: extB value: scanpc - bcpc


"Why use
	byte >= 224 and: [byte <= 225]
 and not
	(byte bitAnd: 16rFE) = 16rE0
 ?
 | n |
 n := 100000000.
 #(0 224) collect:
	[:byte|
	{ Time millisecondsToRun: [1 to: n do: [:i| (byte >= 224 and: [byte <= 225]) ifTrue: []]].
	   Time millisecondsToRun: [1 to: n do: [:i| (byte bitAnd: 16rFE) = 16rE0 ifTrue: []]] }] #(#(297 599) #(702 671))"! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:57' overrides: 16802167!
     instVarReadScanBlockFor: varIndexCode using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of the inst var with zero-relative index varIndexCode.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"	0-15		0000 i i i i 				Push Receiver Variable #iiii
	*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b < 16 and: [b = varIndexCode])
	    or: [b = 226
			and: [scanner followingByte + prevext = varIndexCode]]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:59' overrides: 16802180!
                      instVarWriteScanBlockFor: varIndexCode using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for writes of the inst var with zero-relative index varIndexCode.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"	200-207	11001 iii			Pop and Store Receiver Variable #iii
	*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	240		11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)
	*	243		11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b >= 200
	    and: [b < 208
	    and: [b - 200 = varIndexCode]])
	   or: [(b = 240 or: [b = 243])
		  and: [scanner followingByte + prevext = varIndexCode]]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:59' overrides: 16802266!
             interpretJumpIfCondIn: anInstructionStream
	"Double-dispatch through the encoder to select the correct conditional jump decoder for the instruction set."
	^anInstructionStream interpretSistaV1JumpIfCond! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 19:00' overrides: 16802275!
 interpretJumpIn: anInstructionStream
	"Double-dispatch through the encoder to select the correct unconditional jump decoder for the instruction set."
	^anInstructionStream interpretSistaV1Jump! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'TraitTest 9/2/2019 17:07' overrides: 16802193!
      markerOrNilFor: aMethod
	"If aMethod is a marker method, answer the symbol used to mark it.  Otherwise
	 answer nil.  What is a marker method?  It is method with body like 
		'self subclassResponsibility' or '^ self subclassResponsibility' 
	 used to indicate ('mark') a special property.

	Marker methods compile to two bytecode forms, this:
		self
		send: <literal 1>
		pop
		returnSelf
	or this:
		self
		send: <literal 1>
		returnTop"
	| expectedHeaderPlusLliteralSize e byte |
	expectedHeaderPlusLliteralSize := Smalltalk wordSize * 4.
	^(((e := aMethod endPC - expectedHeaderPlusLliteralSize) = 3 or: [e = 4]) 
	  and: [aMethod numLiterals = 3
	  and: [(aMethod at: expectedHeaderPlusLliteralSize + 1) = 16r4C "push self"
	  and: [(aMethod at: expectedHeaderPlusLliteralSize + 2) = 16r80 "send"
	  and: [(byte := aMethod at: expectedHeaderPlusLliteralSize + 3) = 16rD8 "pop" or: [byte = 16r5C "returnTop"]]]]])
		ifTrue: [aMethod literalAt: 1]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:00' overrides: 16802219!
                   bytecodeSize: bytecode
	"Answer the number of bytes in the bytecode."
	bytecode < 224 ifTrue: [^1].
	bytecode < 248 ifTrue: [^2].
	^3! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:00' overrides: 16802284!
   interpretNextInstructionFor: aClient in: anInstructionStream
	"Double-dispatch through the encoder to select the correct instruction set decoder."
	^anInstructionStream interpretNextSistaV1InstructionFor: aClient! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:01' overrides: 16802294!
                    isBlockReturnAt: pc in: method
	"Answer whether the bytecode at pc is a return from block."
	"	93			01011101			BlockReturn nil
	 *	94			01011110			BlockReturn Top [* return from enclosing block N, N = Extend A, then jump by Ext B ]"
	^(self nonExtensionBytecodeAt: pc in: method) between: 93 and: 94! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:03' overrides: 16802301!
                             isBranchIfFalseAt: pc in: method
	"Answer whether the bytecode at pc is a conditional branch-if-false."

	"	192-199	11000 iii				Pop and Jump 0n False iii +1 (i.e., 1 through 8)
	 *	239		11101111	iiiiiiii		Pop and Jump 0n False #iiiiiiii (+ Extend B * 256, where Extend B >= 0)"
	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 192 and: [byte <= 199 or: [byte = 239]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:04' overrides: 16802309!
 isBranchIfTrueAt: pc in: method
	"Answer whether the bytecode at pc is a conditional branch-if-true."

	"	184-191	10111 iii				Pop and Jump 0n True iii +1 (i.e., 1 through 8)
	 *	238		11101110	iiiiiiii		Pop and Jump 0n True #iiiiiiii (+ Extend B * 256, where Extend B >= 0))"
	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 184 and: [byte <= 191 or: [byte = 238]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:17' overrides: 16802317!
    isExtension: bytecode
	"Answer if the bytecode is an extension bytecode, i.e. one that extends
	 the range of the following bytecode."
	^bytecode >= 16rE0 and: [bytecode <= 16rE1]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:06' overrides: 16802326!
                     isJumpAt: pc in: method
	"Answer whether the bytecode at pc is an (unconditional) jump."

	"	176-183	10110 iii				Jump iii + 1 (i.e., 1 through 8)
	 *	225		11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	 *	237		11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)"
	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 176 and: [byte <= 183 or: [byte = 237]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 13:29' overrides: 16802333!
       isJustPopAt: pc in: method
	"Answer whether the bytecode at pc is a pop."

	^(method at: pc) = 216 "216		11011000			Pop Stack Top"! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:11' overrides: 16802358!
      isReturnAt: pc in: method
	"Answer whether the bytecode at pc is a return from block."
	"	88-91		010110 ii			Return Receiver/true/false/nil
		92			01011100			Return top
		93			01011101			BlockReturn nil
	 *	94			01011110			BlockReturn Top [* return from enclosing block N, N = Extend A, then jump by Ext B ]"
	^(self nonExtensionBytecodeAt: pc in: method) between: 88 and: 94! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 7/5/2022 15:55' overrides: 50344259!
                  isReturnSelfFromMethodAt: pc in: method
	"Answer whether the bytecode at pc is a return self from method."

	^(method at: pc) = 88! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 7/5/2022 15:47' overrides: 16802365!
       isReturnTopFromMethodAt: pc in: method
	"Answer whether the bytecode at pc is a return stack top from method."

	^(method at: pc) = 92! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 7/6/2024 18:53' overrides: 16802373!
   isSendAt: pc in: method
	"Answer whether the bytecode at pc is a message-send."

	"	96-111		0110 iiii			Send Arithmetic Message #iiii #(#+ #- #< #> #'<=' #'>=' #= #'~=' #* #/ #'\\' #@ #bitShift: #'//' #bitAnd: #bitOr:)
		112-119	01110 iii			Send Special Message #iii #(#at: #at:put: #size #next #nextPut: #atEnd #'==' class)
		120-127	01111 iii			Send Special Message #iii + 8 #(#'~~' #value #value: #do: #new #new: #x #y)
		128-143	1000 iiii			Send Literal Selector #iiii With 0 Argument
		144-159	1001 iiii			Send Literal Selector #iiii With 1 Arguments
		160-175	1010 iiii			Send Literal Selector #iiii With 2 Arguments
	 **	234		11101010	iiiiijjj	Send Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments
	 **	235		11101011	iiiiijjj	Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"

	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 96
	  and: [byte <= 175
		 or: [byte >= 234 and: [byte <= 235]]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:19' overrides: 16802380!
  isStoreAt: pc in: method
	"Answer whether the bytecode at pc is a store or store-pop."

	"	200-207	11001 iii						Pop and Store Receiver Variable #iii
		208-215	11010 iii						Pop and Store Temporary Variable #iii
	 *	224		11100000	aaaaaaaa			Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	240		11110000	iiiiiiii				Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)
	 *	241		11110001	iiiiiiii				Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256)
		242		11110010	iiiiiiii				Pop and Store Temporary Variable #iiiiiiii
	 *	243		11110011	iiiiiiii				Store Receiver Variable #iiiiiii (+ Extend A * 256)
	 *	244		11110100	iiiiiiii				Store Literal Variable #iiiiiiii (+ Extend A * 256)
		245		11110110	iiiiiiii				Store Temporary Variable #iiiiiiii

		252		11111100 	kkkkkkkk	jjjjjjjj	Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj
		253		11111101 	kkkkkkkk	jjjjjjjj	Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj"

	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 200
	  and: [byte <= 215
		 or: [(byte between: 240 and: 245)
		 or: [(byte between: 252 and: 253)]]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:18' overrides: 16802387!
      isStorePopAt: pc in: method
	"Answer whether the bytecode at pc is a store or store-pop."

	"	200-207	11001 iii						Pop and Store Receiver Variable #iii
		208-215	11010 iii						Pop and Store Temporary Variable #iii
	 *	224		11100000	aaaaaaaa			Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	240		11110000	iiiiiiii				Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)
	 *	241		11110001	iiiiiiii				Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256)
		242		11110010	iiiiiiii				Pop and Store Temporary Variable #iiiiiiii

		253		11111101 	kkkkkkkk	jjjjjjjj	Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj"

	| byte |
	byte := self nonExtensionBytecodeAt: pc in: method.
	^byte >= 200
	  and: [byte <= 215
		 or: [(byte between: 240 and: 242)
		 or: [byte = 253]]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 6/3/2024 10:29' overrides: 50344267!
               isSuperSendAt: pc in: method
	"Answer whether the bytecode at pc is a message-send to super."

	"**	235		11101011	iiiiijjj	Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"

	^235 = (self nonExtensionBytecodeAt: pc in: method)! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 4/6/2017 11:25' overrides: 16802394!
                       isSyntheticStoreAt: pc in: method for: anInstructionStream
	"Answer whether the bytecode at pc is a store or store-pop of an indirect temp vector,
	 which implement mutable closed-over variables in the the closure implementation.
	 Stores into temp vectors are not real stores.  N.B. pcPreviousTo:in:for: is slow, so filter
	 out any preceding bytecodes other than what looks like a pushNewArrayCode.  But the
	 pcPreviousTo:in:for: is still necessary, since the presence of a pcPreviousTo:in:for: in the
	 right place is potentially ambiguous, possibly part of a different bytecode sequence."

	^(self isTempStoreAt: pc in: method)
	  and: [pc - 2 >= method initialPC
	  and: [(method at: pc - 2) = self pushNewArrayCode
	  and: [(method at: pc - 1) <= 127
	  and: [pc - 2 = (self pcPreviousTo: pc in: method for: anInstructionStream)]]]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 3/19/2019 09:11'!
                     isTempStoreAt: pc in: method
	"Answer if the bytecode at pc is a store or store-pop into a temporary variable.
	 208-215	11010 iii			Pop and Store Temporary Variable #iii
	 242		11110010	iiiiiiii		Pop and Store Temporary Variable #iiiiiiii
	 245		11110110	iiiiiiii		Store Temporary Variable #iiiiiiii"

	| byte |
	byte := method at: pc.
	^byte >= 208
	  and: [byte <= 215
			or: [byte = 242 or: [byte = 245]]]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 12/26/2020 19:27' overrides: 16802407!
              nonExtensionBytecodeAt: pc in: method
	"Answer the actual bytecode at pc in method, skipping past any preceding extensions."
	| thePC bytecode |
	thePC := pc.
	[self isExtension: (bytecode := method at: thePC)] whileTrue:
		[thePC := thePC + (self bytecodeSize: bytecode)].
	^bytecode! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 12/26/2020 19:27' overrides: 16802427!
           selectorToSendOrItselfFor: anInstructionStream in: method at: pc
	"If anInstructionStream is at a send bytecode then answer the send's selector,
	 otherwise answer anInstructionStream itself.  The rationale for answering
	 anInstructionStream instead of, say, nil, is that potentially any existing object
	 can be used as a selector, but since anInstructionStream postdates the method,
	 it can't be one of them.

	 The complication is that for convenience we allow the pc to point to the
	 raw send bytecode after its extension(s), or at the extension(s) preceding it.
	96-111		0110 iiii			Send Arithmetic Message #iiii (+ - < > <= >= = ~= * / \\ @ bitShift: // bitAnd: bitOr:)
	112-119	01110 iii			Send Special Message #iii + 0 (at: at:put: size next nextPut: atEnd == class)
	120-127	01111 iii			Send Special Message #iii + 8 (~~ value value: do: new new: x y)
	128-143	1000 iiii			Send Literal Selector #iiii With 0 Argument
	144-159	1001 iiii			Send Literal Selector #iiii With 1 Arguments
	160-175	1010 iiii			Send Literal Selector #iiii With 2 Arguments
	*	224	11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	225	11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	**	234	11101010	iiiiijjj		Send Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments
	**	235	11101011	iiiiijjj	ExtendB < 64
										ifTrue: [Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments]
										ifFalse: [Send To Superclass of Stacked Class Literal Selector #iiiii (+ Extend A * 32) with jjj (+ (Extend B bitAnd: 63) * 8) Arguments"

	| byte |
	byte := method at: pc.
	byte < 96 ifTrue:
		[^anInstructionStream].
	byte <= 175 ifTrue: 
		["special byte or short send"
		 ^byte >= 128
			ifTrue: [method literalAt: (byte bitAnd: 15) + 1]
			ifFalse: [Smalltalk specialSelectorAt: byte - 95]].
	byte < 234 ifTrue: "need to check for either extension cuz order of extensions is not restricted. so extB could precede extA"
		[(byte >= 224 and: [byte <= 225]) ifTrue:
			[^self extensionsAt: pc in: method into:
				[:extA :extB :nExtBytes| | byteAfter index |
				byteAfter := method at: pc + nExtBytes.
				(byteAfter >= 234 and: [byteAfter <= 235])
					ifTrue:
						[index := ((method at: pc + nExtBytes + 1) bitShift: -3) + (extA bitShift: 5).
						 method literalAt: index + 1]
					ifFalse: [anInstructionStream]]].
		^anInstructionStream].
	byte > 235 ifTrue:
		[^anInstructionStream].
	"they could be extended..."
	^self extensionsFor: pc in: method into:
		[:extA :extB :nExtBytes| | index |
		 index := ((method at: pc + 1) bitShift: -3) + (extA bitShift: 5).
		 method literalAt: index + 1]! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'eem 5/18/2014 19:21' overrides: 16802211!
                  superSendScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor:
	 that answers true for super sends."

	"*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	225		11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	 **	235		11101011	iiiiijjj		Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments"
					
	^[:instr | instr = 235]! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 5/18/2014 19:22' overrides: 16801985!
    callPrimitiveCode
	"Answer the call primitive bytecode, if it exists in the encoder's bytecode set, or nil if not.
	 248	11111000 	iiiiiiii	mjjjjjjj	Call Primitive #iiiiiiii + (jjjjjjj * 256) m=1 means inlined primitive, no hard return after execution."
	^248! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 3/29/2017 09:36' overrides: 16801992!
              createClosureCode
	"Answer the create closure bytecode, if it exists in the encoder's bytecode set, or nil if not.
	 Actually this code is that for a closure whose bytecodes are nested within its home method's."

	^250! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 5/18/2014 19:23' overrides: 16802009!
                       pcOfBlockCreationBytecodeForBlockStartingAt: startpc in: method
	"Answer the pc of the push closure bytecode whose block starts at startpc in method.
	 May need to back up to include extension bytecodes."

	"*	224		11100000	aaaaaaaa			Extend A (Ext A = Ext A prev * 256 + Ext A)
	 *	225		11100001	bbbbbbbb			Extend B (Ext B = Ext B prev * 256 + Ext B)
	 **	250		11111010 	eeiiikkk		jjjjjjjj	Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions"
	| numExtensions |
	self assert: (method at: startpc - 3) = 250.
	numExtensions := (method at: startpc - 2) >> 6.
	^startpc - 3 - (numExtensions * 2)! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 5/18/2014 19:24' overrides: 16802110!
                          pushClosureBytecodeSize
	"Answer the size of the push closure bytecode.
	 **	250		11111010 	eeiiikkk		jjjjjjjj	Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions"
	^3! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 4/6/2017 11:26' overrides: 16802117!
     pushNewArrayCode
	"231		11100111	jkkkkkkk	Push (Array new: kkkkkkk) (j = 0)
									&	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)"
	^231! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 4/6/2017 14:15' overrides: 50344245!
                             pushNilCode
	"Answer the pushNil bytecode.
	 79			01001111			Push nil"
	^79! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 8/8/2014 19:40' overrides: 50344251!
       stackDeltaForPrimitive: primitiveIndex in: method
	"Answer the stack delta for the callPrimitive: bytecode (see my class comment).
	 There is no delta for non-inlined primitives (its implicitly 0 - method numArgs).
	 Inlined primitives are grouped by the thousand by argument count, 32 args max ;-)."
	^primitiveIndex < 32678
		ifTrue: [0]
		ifFalse: [primitiveIndex - 32768 // 1000]! !
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'eem 5/18/2014 19:24' overrides: 16802124!
                  unusedBytecode
	"Answer the opcode of a single-byte unused bytecode, if it exists in the encoder's bytecode set, or nil if not."
	^223! !
!EncoderForSistaV1 class methodsFor: 'scanning' stamp: 'eem 7/6/2024 19:01'!
         scanBlockOrNilForLiteral: aLiteral
	"Answer a block argument for CompiledMethod>>#scanFor: that answers
	 if the method refers to the literal implicitly via a special bytecode.
	 If the literal is not accessible via a special bytecode, answer nil."
	| value hi lo unextended |

	"96-111	0110 iiii			Send Arithmetic Message #iiii (+ - < > <= >= = ~= * / \\ @ bitShift: // bitAnd: bitOr:)
	 112-119	01110 iii			Send Special Message #iii + 0 (at: at:put: size next nextPut: atEnd == class)
	 120-127	01111 iii			Send Special Message #iii + 8 #(#'~~' #value #value: #do: #new #new: #x #y)"
	self flag: #deprecated. "mt: Use CompiledCode>>#implicitLiteralsDo:."
	aLiteral isSymbol ifTrue:
		[value := 96 + ((Smalltalk specialSelectors indexOf: aLiteral ifAbsent: [^nil]) // 2).
		 ^[:byte| byte = value]].

	"80			01010000			Push 0
	 81			01010001			Push 1
	 232		11101000	iiiiiiii	Push Integer #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, d=0, s=1)"
	aLiteral isInteger ifTrue:
		[aLiteral >= 0 ifTrue:
			[aLiteral <= 1 ifTrue:
				[value := aLiteral + 80.
				 ^[:byte| byte = value]].
			 aLiteral <= 255 ifTrue:
				[unextended := true. "Don't be fooled by extended cases with the same least significant byte!!"
				 ^[:b1 :b2| | found |
					found := b1 = 232 and: [b2 = aLiteral and: [unextended]].
					unextended := b1 ~= 16rE1.
					found]]].
		 (aLiteral between: -32768 and: 32767) ifFalse: [^nil].
		 lo := aLiteral bitAnd: 255.
		 hi := (aLiteral bitShift: -8) bitAnd: 255.
		 ^[:b1 :b2 :b3 :b4| b1 = 16rE1 and: [b2 = hi and: [b3 = 232 and: [b4 = lo]]]]].

	"233		11101001	iiiiiiii	Push Character #iiiiiiii (+ Extend B * 256)"
	aLiteral isCharacter ifTrue:
		[(value := aLiteral asInteger) <= 255 ifTrue:
			[unextended := true. "Don't be fooled by extended cases with the same least significant byte!!"
			 ^[:b1 :b2| | found |
				found := b1 = 233 and: [b2 = value and: [unextended]].
				unextended := b1 ~= 16rE1.
				found]].
		 ^value <= 65535 ifTrue:
			[lo := value bitAnd: 255.
			 hi := (value bitShift: -8) bitAnd: 255.
			 [:b1 :b2 :b3 :b4| b1 = 16rE1 and: [b2 = hi and: [b3 = 233 and: [b4 = lo]]]]]].

	"77			01001101			Push true
	 78			01001110			Push false
	 79			01001111			Push nil
	 88-91		010110 ii			Return Receiver/true/false/nil
	 93			01011101			BlockReturn nil"
	aLiteral == true ifTrue:
		[^[:byte| byte = 77 or: [byte = 89]]].
	aLiteral == false ifTrue:
		[^[:byte| byte = 78 or: [byte = 90]]].
	aLiteral == nil ifTrue:
		[^[:byte| byte = 79 or: [byte = 91 or: [byte = 93]]]].
	^nil! !
!EncoderForSistaV1 class methodsFor: 'testing' stamp: 'eem 10/9/2021 17:28' overrides: 50344274!
       canBeSpecialLiteral: aLiteral
	"This check can be used to prevent unnecessary use of #scanBlockOrNilForLiteral:."

	aLiteral isVariableBinding ifTrue: [^false]. "a common case; don't waste time analysing..."
	
	aLiteral isSymbol ifTrue: [^ Smalltalk specialSelectors identityIncludes: aLiteral].
	aLiteral isCharacter ifTrue: [^ aLiteral asInteger <= 65535].
	aLiteral isInteger ifTrue: [^ aLiteral between: -32768 and: 32767].

	aLiteral == true ifTrue: [^ true].
	aLiteral == false ifTrue: [^ true].
	aLiteral == nil ifTrue: [^ true].

	^ false! !
!EncoderForV3PlusClosures methodsFor: 'testing' stamp: 'eem 4/6/2017 10:39' overrides: 50344200!
                         supportsFullBlocks
	"Answer if the instruction set supports full closures (closure creation from
	 specfic methods instead of bytecodes embedded in an outer home method)."
	
	^false! !
!EncoderForV3PlusClosures methodsFor: 'special literal encodings' stamp: 'eem 8/12/2017 15:20' overrides: 50344210!
                   isSpecialLiteralForPush: literal
	^literal isInteger
		ifFalse:
			[false == literal
			 or: [true == literal
			 or: [nil == literal]]]
		ifTrue: [literal between: -1 and: 2]! !
!EncoderForV3PlusClosures class methodsFor: 'bytecode decoding' stamp: 'eem 4/6/2017 14:13' overrides: 50344245!
                            pushNilCode
	"Answer the pushNil bytecode.
	 112-119 	01110iii 	Push (receiver, true, false, nil, -1, 0, 1, 2) [iii]"
	^115! !
!EncoderForV3PlusClosures class methodsFor: 'instruction stream support' stamp: 'eem 7/5/2022 15:55' overrides: 50344259!
       isReturnSelfFromMethodAt: pc in: method
	"Answer whether the bytecode at pc is a return self from method."

	^(method at: pc) = 120! !
!EncoderForV3PlusClosures class methodsFor: 'instruction stream support' stamp: 'eem 6/3/2024 10:25' overrides: 50344267!
                               isSuperSendAt: pc in: method
	"Answer whether the bytecode at pc is a message-send to super."

	"132 		10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj (for sends jjjjj = numArgs)
	 133 		10000101 jjjkkkkk 	Send Literal Selector #kkkkk To Superclass With jjj Arguments"

	| byte |
	byte := method at: pc.
	^byte = 133	"double extended do anything"
	  or: [byte = 132 and: [(method at: pc + 1) // 32 = 1]]! !
!EncoderForV3PlusClosures class methodsFor: 'scanning' stamp: 'mt 12/20/2023 13:51'!
            scanBlockOrNilForLiteral: aLiteral
	"Answer a block argument for CompiledMethod>>#scanFor: that answers
	 if the method refers to the literal implicitly via a special bytecode.
	 If the literal is not accessible via a special bytecode, answer nil."
	| value |
	"176-191 	1011iiii 	Send Arithmetic Message #iiii
	 192-207 	1100iiii 	Send Special Message #iiii"
	self flag: #deprecated. "mt: Use CompiledCode>>#implicitLiteralsDo:."
	(aLiteral isSymbol or: [aLiteral isInteger]) ifTrue:
		[value := aLiteral isSymbol
					ifTrue: [176 + ((Smalltalk specialSelectors indexOf: aLiteral ifAbsent: [^nil]) // 2)]
					ifFalse: [(aLiteral between: -1 and: 2) ifFalse: [^nil].
							aLiteral + 117].
		 ^[:byte| byte = value]].
	"112-119 	01110iii 	Push (receiver, true, false, nil, -1, 0, 1, 2) [iii]
	 120-123 	011110ii 	Return (receiver, true, false, nil) [ii] From Message"
	aLiteral == true ifTrue:
		[^[:byte| byte = 113 or: [byte = 121]]].
	aLiteral == false ifTrue:
		[^[:byte| byte = 114 or: [byte = 122]]].
	aLiteral == nil ifTrue:
		[^[:byte| byte = 115 or: [byte = 123]]].
	^nil! !
!EncoderForV3PlusClosures class methodsFor: 'testing' stamp: 'eem 10/9/2021 17:28' overrides: 50344274!
                         canBeSpecialLiteral: aLiteral
	"This check can be used to prevent unnecessary use of #scanBlockOrNilForLiteral:."

	aLiteral isVariableBinding ifTrue: [^false]. "a common case; don't waste time analysing..."

	aLiteral isSymbol ifTrue: [^ Smalltalk specialSelectors identityIncludes: aLiteral].
	aLiteral isInteger ifTrue: [^ aLiteral between: -1 and: 2].

	aLiteral == true ifTrue: [^ true].
	aLiteral == false ifTrue: [^ true].
	aLiteral == nil ifTrue: [^ true].

	^ false! !
!AssignmentNode methodsFor: 'private' stamp: 'mt 9/4/2019 09:20' overrides: 50344197!
            ifNilTemporary
	"(temp := object) == nil ifTrue: [...] ifFalse: [...]"
	
	^ self variable! !
!BraceNode methodsFor: 'closure analysis' stamp: 'eem 1/18/2020 17:33'!
                           deoptimize
	"Deoptimize the blocks in a caseOf:[otherwise:] that is being used in a cascade."
	elements do:
		[:aMessage|
		self assert: aMessage selector key == #->.
		aMessage receiver deoptimize.
		aMessage arguments first deoptimize]! !
!BlockNode methodsFor: 'accessing' stamp: 'eem 12/24/2024 16:46:15'!
          ensureClosureCreationNode: ignored
	^self closureCreationNode! !
!MethodNode methodsFor: 'converting-private' stamp: 'eem 1/16/2025 17:12:45'!
                 preenIfNotNilNode: messageNode preenableNodes: preenableNodes
	"Transform a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block
	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where
	 the block already declares the variable and the decompile case where it does not."

	| variable relevantNodes |
	self assert: (messageNode isMessageNode
				and: [messageNode macroPrinter == #printIfNilNotNil:indent:
				and: [messageNode receiver receiver isAssignmentNode]]).
	variable := messageNode receiver receiver variable.
	self assert: (variable isTemp and: [variable isRemote not]).
	relevantNodes := preenableNodes keys select:
						[:node| 
						node isMessageNode
						and: [messageNode macroPrinter == #printIfNilNotNil:indent:]].
	(variable isLocalToBlocksInIfNilIfNotNilNodes: relevantNodes in: self) ifFalse:
		[messageNode arguments do:
			[:argBlock|
			(argBlock arguments size = 1
			and: [argBlock firstArgument = variable]) ifTrue:
				[argBlock arguments: #()]].
		 variable beTemp.
		 ^self].
	messageNode arguments last arguments isEmpty
		ifTrue: [messageNode arguments last arguments: { variable }]
		ifFalse:
			[self assert: messageNode arguments last arguments asArray = { variable }.
			 variable := nil].
	messageNode receiver receiver: messageNode receiver receiver value.
	(temporaries includes: variable) ifTrue: "can't use removeAtIndex: cuz temporaries could be an Array"
		[temporaries := temporaries copyWithout: variable].
	variable ifNil: [^self].
	self nodesDo:
		[:node|
		((node == self or: [node isBlockNode])
		 and: [node temporaries anySatisfy: [:temp| temp = variable]]) ifTrue:
			[node temporaries: (node temporaries reject: [:temp| temp = variable])]]! !
!MethodNode methodsFor: 'converting-private' stamp: 'eem 12/29/2024 17:44:13'!
                          preenNilNodeFollowingNilIfNode: aNilIfMessageNode preenableNodes: preenableNodes
	self nodesDo:
		[:node| | statements indices |
		 (node isBlockNode
		  and: [(statements := node statements) includes: aNilIfMessageNode]) ifTrue:
			[indices := (2 to: statements size) reject:
							[:i|
							(statements at: i) == NodeNil
							and: [(statements at: i - 1) isNilIf]].
			 node statements: (({1}, indices) collect: [:i| statements at: i])]]! !
!MethodNode methodsFor: 'converting-private' stamp: 'eem 12/29/2024 17:44:18'!
                 preenTempsConflictingWithBlockNode: temps preenableNodes: preenableNodes
	"Push temps that conflict with other blocks down into their narrowest enclosing block scope."
	temps do:
		[:tempVar|
		(self accept: (NarrowerVariableScopeFinder new ofVariable: tempVar)) ifNotNil:
			[:enclosingScope |
			 self assert: enclosingScope isBlockNode.
			 self nodesDo:
				[:node|
				 ((node == self or: [node isBlockNode])
				  and: [node temporaries includes: tempVar]) ifTrue:
					[node temporaries: (node temporaries copyWithout: tempVar)]].
			 enclosingScope temporaries: enclosingScope temporaries, { tempVar }]]! !
!MethodNode methodsFor: 'converting-private' stamp: 'eem 12/29/2024 17:52:24'!
          preenableNodes
	"Answer a Dictionary from node or sequence of nodes to preen method selector for nodes in
	 the tree that require post-processing after either a format or a decompile.  Such issues are
	 the variable for an ifNotNil: which is local to the ifNotNil: block but, due to the inlining of
	 ifNotNil: appears to be declared at the outer level, and, similarly, a temporary variable that
	 conflicts with one of the same name in a block when, were the variable declared local to
	 some inlined block it would no longer conflict.  The resulting dictionary is used to perform
	 the value with the key (node or array) and the dictionary as arguments to preen the tree."

	| preenableNodes priorBlocks priorVariables |
	preenableNodes := Dictionary new.
	priorBlocks := OrderedCollection new.
	priorVariables := Set new.
	self nodesWithPrecedingStatementsDo:
		[:node :precedingStatementOrNil| | variable temps |
		(node isMessageNode
		and: [node macroPrinter == #printIfNilNotNil:indent:
		and: [node receiver isMessageNode
		and: [node receiver selector key == #==
		and: [node receiver receiver isAssignmentNode
		and: [(variable := node receiver receiver variable) isTemp
		and: [variable isRemote not]]]]]]) ifTrue:
			[preenableNodes at: node put: #preenIfNotNilNode:preenableNodes:.
			 priorVariables add: variable].
		node isBlockNode ifTrue:
			[temps := OrderedCollection new.
			 node temporaries do:
				[:temp|
				 priorBlocks do:
					[:aBlock|
					 aBlock temporaries do:
						[:priorTemp|
						 (priorVariables includes: priorTemp) ifFalse:
							[priorTemp key = temp key ifTrue:
								[temps addLast: priorTemp]]]]].
			 temps isEmpty ifFalse:
				[preenableNodes at: temps put: #preenTempsConflictingWithBlockNode:preenableNodes:].
			 priorBlocks addLast: node].
		(node == NodeNil
		 and: [precedingStatementOrNil notNil
		 and: [precedingStatementOrNil isMessageNode
		 and: [precedingStatementOrNil isNilIf]]]) ifTrue:
			[preenableNodes at: precedingStatementOrNil put: #preenNilNodeFollowingNilIfNode:preenableNodes:]].
	^preenableNodes! !
!TempVariableNode methodsFor: 'testing' stamp: 'eem 12/29/2024 18:05:06'!
                        beTemp
	"This is for preening of ifNil:ifNotNil:"
	argType := nil! !
!TempVariableNode methodsFor: 'testing' stamp: 'eem 1/16/2025 11:58:00'!
                  isLocalToBlocksInIfNilIfNotNilNodes: ifNilIfNotNilMessages "<Collection of: MessageNode>" in: aMethodNode "<MethodNode>"
	"Answer if the receiver only occurs within the ifNotNil: blocks of the message nodes,
	 or is the target of the assignment that is the receiver of each node.
	 Assumes that all ifNilIfNotNilMessages are in fact subnodes of aMethodNode.

	Strategy:
		First visit all nodes outside of the message nodes. If the variable is referenced there answer false.
		Next visit the expressions of all assignments that are the receivers of the ifNilIfNotNil: messages.
		If the variable is referenced there answer false.
		If not found outside, answer true. This does not require the variable to be referenced within the
		block, but that is not necessary to produce a nicely preened tree."
	| ifNotNilBlocks ifNotNilAssignments finder |
	ifNotNilBlocks := Set new.
	ifNotNilAssignments := Set new.
	ifNilIfNotNilMessages do:
		[:messageNode|
		(messageNode receiver isMessageNode
		 and: [messageNode receiver selector key == #==
		 and: [messageNode receiver receiver isAssignmentNode
		 and: [messageNode receiver receiver variable = self]]]) ifTrue:
			[ifNotNilAssignments add: messageNode receiver receiver].
		ifNotNilBlocks add: (messageNode arguments at: (messageNode selector key keywords indexOf: #ifNotNil:))].
	finder := ParseNodeEnumerator
				ofBlock: [:node| node == self ifTrue: [^false]]
				select: [:node| ((node isBlockNode and: [ifNotNilBlocks includes: node])
								or: [node isAssignmentNode and: [ifNotNilAssignments includes: node]]) not].
	aMethodNode accept: finder.
	ifNotNilAssignments do:
		[:assignmentNode|
		assignmentNode value accept: finder].
	^true! !
!MessageNode methodsFor: 'private' stamp: 'mt 9/4/2019 09:27' overrides: 50344197!
         ifNilTemporary

	^ self ifNilReceiver ifNilTemporary! !
!MessageNode methodsFor: 'decompiling' stamp: 'eem 7/11/2024 18:10'!
   toDoFromWhileWithCounts: blockBodyTempCounts init: incrInit limit: limitInitOrNil
	"If the receiver, a whileTrue: loop, represents a to:[by:]do: loop
	 then answer the replacement to:[by:]do:, otherwise answer nil."
	| variable increment limit toDoBlock body test |
	self assert: (selector key == #whileTrue:
				and: [incrInit isAssignmentNode]).
	(limitInitOrNil notNil "limit should not be referenced within the loop"
	  and: [(blockBodyTempCounts at: limitInitOrNil variable ifAbsent: [0]) ~= 1]) ifTrue:
		[^nil].
	body := arguments last statements.
	(variable := incrInit variable) isTemp ifFalse:
		[^nil].
	(increment := body last toDoIncrement: variable) ifNil:
		[^nil].
	receiver statements size ~= 1 ifTrue:
		[^nil].
	test := receiver statements first.
	"Note: test should really be checked that <= or >= comparison
	jibes with the sign of the (constant) increment"
	(test isMessageNode
	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:
		[^nil].
	"The block must not overwrite the limit"
	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable is: limit]]]) ifTrue:
		[^nil]. 
	toDoBlock := BlockNode statements: body allButLast returns: false.
	toDoBlock arguments: {variable}.
	^MessageNode new
		receiver: incrInit value
		selector: (SelectorNode new key: #to:by:do: code: #macro)
		arguments: { limit. increment. toDoBlock }
		precedence: precedence! !
!DecompilerConstructor methodsFor: 'constructor' stamp: 'mt 10/9/2019 09:42'!
           decodeIfNilWithReceiver: receiver selector: selector arguments: arguments tempReadCounts: tempReadCounts
	
	| node temp |
	receiver ifNil: [ ^nil ].		"For instance, when cascading"
	selector == #ifTrue:ifFalse:
		ifFalse: [^ nil].
				
	(receiver isMessage: #==
				receiver: nil
				arguments: [:argNode | argNode == NodeNil])
		ifFalse: [^ nil].
		
	"Like #to:(by:)do:, support only local temps."
	(((temp := receiver ifNilTemporary) isNil or: [tempReadCounts includesKey: temp]) or: [
		"What about 'object ifNotNil: [:o | ]', which as not read the blockArg? Just check that there is no remote vector pointing to it."
		tempReadCounts keys noneSatisfy:
			[:otherTemp |
				otherTemp isIndirectTempVector
					ifTrue: [otherTemp remoteTemps anySatisfy:
						[:remoteTemp |
						remoteTemp name = temp name]]
					ifFalse: [otherTemp name = temp name]]
			])
		ifFalse: [^ nil].
		
	node := (MessageNode new
			receiver: receiver
			selector: (SelectorNode new key: #ifTrue:ifFalse: code: #macro)
			arguments: arguments
			precedence: 3).

	"Reconfigure the message node to #ifNil:ifNotNil:. Note that original* instance variables keep their optimized format. See MessageNode >> #printIfNilNotNil:indent:."	
	node
		noteSpecialSelector: #ifNil:ifNotNil:;
		selector: (SelectorNode new key: #ifNil:ifNotNil:).
	
	temp ifNil: [^ node].
	temp isTemp ifFalse: [^ node].
	
	(arguments second isJust: NodeNil) not ifTrue:
		[temp beBlockArg.
		node arguments: {
			arguments first.
			arguments second copy arguments: { temp }; yourself }].
				
	^ node! !
!ParseNodeWithPrecedingStatementEnumerator methodsFor: 'initialize-release' stamp: 'eem 3/19/2019 11:50' overrides: 16920643!
              ofBlock: aBlock
	"N.B. This enumerator visits a node before any of the node's children.
	 Hence, when enumerating statements in a block, we can ensure that
	 the second argument to the block, the preceding statement, is non-nil
	 only for top-level statements in the block by nilling out precedingStatement
	 once the block is evaluated. Perhaps stronger would be to capture its value
	 in a temporary and nil it before evaluating, but this is good enough."
	theBlock := [:node|
				aBlock value: node value: precedingStatement.
				precedingStatement := nil]! !
!ParseNodeWithPrecedingStatementEnumerator methodsFor: 'initialize-release' stamp: 'eem 12/24/2017 10:32' overrides: 16920647!
              ofBlock: aBlock select: aSelectBlock
	self ofBlock: aBlock.
	theSelectBlock := aSelectBlock! !
!ParseNodeWithPrecedingStatementEnumerator methodsFor: 'visiting' stamp: 'eem 1/3/2019 15:46' overrides: 16920481!
              visitBlockNode: aBlockNode
	| savedPrecedingStatement |
	(theSelectBlock isNil or: [theSelectBlock value: aBlockNode]) ifFalse:
		[^nil].
	theBlock value: aBlockNode.
	savedPrecedingStatement := precedingStatement.
	precedingStatement := nil.
	[aBlockNode statements do:
		[:statement|
		 statement accept: self.
		 precedingStatement := statement]] ensure:
		[precedingStatement := savedPrecedingStatement]! !
!NarrowerVariableScopeFinder methodsFor: 'visiting' stamp: 'eem 12/29/2024 18:34:35' overrides: 16999289!
                           visitTempVariableNode: aVariableNode
	^(theVariable is: aVariableNode) ifTrue: [theVariable]! !
!NarrowerVariableScopeFinder methodsFor: 'visiting' stamp: 'eem 4/3/2017 12:00' overrides: 16999293!
                           visitUndeclaredVariableNode: aVariableNode
	^nil! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 2/6/2022 20:32'!
                           arguments

	^ arguments! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 2/6/2022 20:04'!
                    context

	^ context! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 2/6/2022 20:32'!
                        method

	^ method! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 5/2/2021 16:01'!
                          primitive

	^ primitiveIndex! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 5/9/2021 20:14'!
               suppress

	suppressed := true.! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 5/9/2021 20:14'!
             suppressed

	^ suppressed ifNil: [self isSimulationGuard not]! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 2/6/2022 20:33'!
              theReceiver

	^ receiver! !
!SimulationSideEffectWarning methodsFor: 'accessing' stamp: 'ct 5/9/2021 20:14'!
                   unsuppress

	suppressed := false.! !
!SimulationSideEffectWarning methodsFor: 'initialize-release' stamp: 'ct 2/6/2022 20:24'!
 context: aContext method: aCompiledMethod receiver: rcvr arguments: args

	context := aContext.
	method := aCompiledMethod.
	receiver := rcvr.
	arguments := args.! !
!SimulationSideEffectWarning methodsFor: 'initialize-release' stamp: 'ct 2/6/2022 20:23'!
primitive: anInteger

	primitiveIndex := anInteger.! !
!SimulationSideEffectWarning methodsFor: 'priv handling' stamp: 'ct 3/2/2024 23:47' overrides: 17005795!
defaultAction

	self suppressed ifFalse: [super defaultAction].
	self flag: #forLater. "When we support explicit exception handler invocation (e.g., #resume, #retry) from the debugger, this exception should publish a #resume handler rather than relying on the weakly defined proceed semantics of the debugger."
	^ self defaultResumeValue! !
!SimulationSideEffectWarning methodsFor: 'defaults' stamp: 'ct 2/6/2022 20:34' overrides: 16856623!
       defaultResumeValue

	^ true! !
!SimulationSideEffectWarning methodsFor: 'testing' stamp: 'ct 5/9/2021 20:43'!
                  isControlPrimitive
	"See StackInterpreter class>>#initializePrimitiveTable."

	^ self primitive between: 80 and: 89! !
!SimulationSideEffectWarning methodsFor: 'testing' stamp: 'ct 5/9/2021 20:43'!
                          isSimulationGuard
	"See Parser >> #simulationGuard."

	^ self primitive = 19! !
!SimulationSideEffectWarning methodsFor: 'printing' stamp: 'ct 3/3/2024 19:24' overrides: 16856659!
            messageText

	^ messageText ifNil: [
		'The code being simulated is trying to control a process ({1}). {2}' translated format: {
			self context method reference.
			self isSimulationGuard
				ifTrue: ['If you proceed, your image may be locked. Continue at own risk, and better save your image before.' translated]
				ifFalse: ['Process controlling cannot be simulated. If you proceed, side effects may occur outside the observable area of the simulator.' translated]}]! !
!SimulationSideEffectWarning methodsFor: 'signaling' stamp: 'ct 2/6/2022 20:38'!
                     signalIfSkipped: skipBlock

	^ self signal ifFalse: skipBlock! !
!SimulationSideEffectWarning methodsFor: 'handling' stamp: 'ct 2/6/2022 20:37'!
               skipPrimitive

	^ self resume: false! !
!SimulationSideEffectWarning class methodsFor: 'instance creation' stamp: 'ct 2/6/2022 20:22'!
                         forPrimitive: primitiveIndex

	^ self new primitive: primitiveIndex! !
!ImplicitLiteralInstructionClientHook methodsFor: 'instruction decoding - implicit literals' stamp: 'mt 12/20/2023 13:19'!
                              methodReturnSpecialConstant: value
	"This is a hook to allow clients to intercept implicit literal bytecodes"
	^self methodReturnConstant: value! !
!ImplicitLiteralInstructionClientHook methodsFor: 'instruction decoding - implicit literals' stamp: 'eem 9/12/2021 14:46'!
                 pushSpecialConstant: value
	"This is a hook to allow clients to intercept implicit literal bytecodes"
	^self pushConstant: value! !
!ImplicitLiteralInstructionClientHook methodsFor: 'instruction decoding - implicit literals' stamp: 'eem 9/12/2021 14:19'!
 sendSpecial: selector numArgs: numArgs
	"This is a hook to allow clients to intercept special selector sends (which have an implicit selector)"
	^self send: selector super: false numArgs: numArgs! !
!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 8/1/2014 07:11'!
  blockReturnConstant: value
	"Return Constant From Block bytecode."
	scanner pc < blockEnd ifTrue:
		[self doJoin]! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 8/1/2014 07:21'!
                       blockReturnConstant: value 
	"Print the Return Constant From Block bytecode."

	self print: 'blockReturn: ', value printString! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 4/6/2015 12:00'!
          directedSuperSend: selector "<Symbol>" numArgs: numArgs "<SmallInteger>"
	self print: 'directedSuperSend: ' , (self stringForSelector: selector numArgs: numArgs)! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 8/5/2014 11:38'!
       trapIfNotInstanceOf: behaviorOrArrayOfBehavior
	"If the top of stack is not an instance of either the argument, or, if the argument is an Array,
	  any of the elements of the argument, send the class trap message to the current context."
	self print: 'trapIfNotInstanceOf: ', behaviorOrArrayOfBehavior printString! !
!InstructionPrinter methodsFor: 'printing' stamp: 'eem 1/1/2023 12:04'!
                           stringForReceiverVariableOffset: offset
	| tmpStream |
	tmpStream := WriteStream on: (String new: 16).
	offset printOn: tmpStream.
	method methodClass ifNotNil:
		[:class|
		class isBehavior ifTrue:
			[(class instVarNameForIndex: offset + 1) ifNotNil:
				[:instVarName|
				tmpStream nextPutAll: ' "'; nextPutAll: instVarName; nextPut: $"]]].
	^tmpStream contents! !
!InstructionPrinter methodsFor: 'printing' stamp: 'eem 3/15/2013 15:14'!
      stringForSelector: selector numArgs: numArgs
	^(selector isSymbol and: [selector numArgs = numArgs])
		ifTrue: [selector]
		ifFalse: [selector printString
				, (numArgs = 1
					ifTrue: [' (1 arg)']
					ifFalse: [' (', numArgs printString, ' args)'])]! !
!InstructionPrinter methodsFor: '*BytecodeSets-SistaV1-decoding' stamp: 'cb 1/19/2017 14:10'!
 branchIfInstanceOf: behaviorOrArrayOfBehavior distance: distance
	"If the object on top of stack has the type -or one of the type- present in the literal
	 (the literal is a behavior or an array of behavior), then pop it. Else jumps by the distance."
	self print: 'branchIfInstanceOf: ', behaviorOrArrayOfBehavior printString, ' distance: ', distance printString! !
!InstructionPrinter methodsFor: '*BytecodeSets-SistaV1-decoding' stamp: 'eem 7/11/2016 14:24'!
                   branchIfNotInstanceOf: behaviorOrArrayOfBehavior distance: distance
	"If the object on top of stack has the type -or one of the type- present in the literal
	 (the literal is a behavior or an array of behavior), then pop it. Else jumps by the distance."
	self print: 'branchIfNotInstanceOf: ', behaviorOrArrayOfBehavior printString, ' distance: ', distance printString! !
!InstructionPrinter methodsFor: '*BytecodeSets-instruction decoding' stamp: 'eem 5/14/2020 13:32'!
         callInlinePrimitive: index
	"Print the callInlinePrimitive: bytecode.  This is the m = 1, ss = 0 case in SistaV1:	**	248 below.

	SistaV1:	**	248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
								m=1 means inlined primitive, no hard return after execution. 
								ss defines the unsafe operation set used to encode the operations. 
								(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are as yet used)
	 V3/Spur:		139		10001011	i i i i i i i i	jjjjjjjj		Call Primitive #iiiiiiii + (jjjjjjjj * 256)"

	self print: 'callInlinePrimitive: ' , ((#((1000 ' class')
										(1001 ' pointer numSlots')
										(1002 ' pointer basicSize')
										(1003 ' byte8Type format numBytes')
										(1004 ' short16Type format numSho')
										(1005 ' word32Type format numWord')
										(1006 ' doubleWord64Type format n')

										(1010 ' ensure number of bytes available')
										(1011 ' fixed pointer basicNew')

										(1020 ' identityHash (non-immediate, non-Behavior, has hash)')
										(1021 ' identityHash (SmallInteger)')
										(1022 ' identityHash (Character)')
										(1023 ' identityHash (SmallFloat64)')
										(1024 ' identityHash (Behavior, has hash?)')

										(1030 ' immediateAsInteger (Character)')
										(1031 ' immediateAsInteger (SmallFloat64)')

										(2000 ' SmallInteger #+')
										(2001 ' SmallInteger #-')
										(2002 ' SmallInteger #*')
										(2003 ' SmallInteger #/')
										(2004 ' SmallInteger #//')
										(2005 ' SmallInteger #\\')
										(2006 ' SmallInteger #quo:')

										(2011 ' Variable-sized pointers new (new:). Array, etc')
										(2012 ' Variable-sized byte new (new:). ByteArray, ByteString, etc')
										(2013 ' Variable-sized 16-bit new (new:). DoubleByteArray, etc')
										(2014 ' Variable-sized 32-bit new (new:). Bitmap, FloatArray, etc')
										(2015 ' Variable-sized 64-bit new (new:). DoubleWordArray, etc')

										(2016 ' SmallInteger #bitAnd:')
										(2017 ' SmallInteger #bitOr:')
										(2018 ' SmallInteger #bitXor:')
										(2019 ' SmallInteger #bitShiftLeft:')
										(2019 ' SmallInteger #bitShiftRight:')

										(2032 ' SmallInteger #>')
										(2033 ' SmallInteger #<')
										(2034 ' SmallInteger #>=')
										(2035 ' SmallInteger #<=')
										(2036 ' SmallInteger #=')
										(2037 ' SmallInteger #~=')

										(2064 ' Pointer Object>>at:')
										(2065 ' Byte Object>>at:')
										(2066 ' 16-bit Word Object>>at:')
										(2067 ' Word Object>>at:')
										(2068 ' DoubleWord Object>>at:')
										(2069 ' QuadWord Object>>at:')

										(3000 ' Pointer Object>>at:put:')
										(3001 ' Byte Object>>at:put:')
										(3002 ' Word Object>>at:put:')
										(3003 ' DoubleWord Object>>at:put')
										(3004 ' QuadWord Object>>at:put:'))
											detect: [:tuple| tuple first = index]
											ifNone: [{index printString}]) last)! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'nice 3/10/2022 09:50'!
   interpretNext2ByteSistaV1Instruction: bytecode for: client extA: extA extB: extB startPC: startPC
	"Send to the argument, client, a message that specifies the next instruction.
	 This method handles the two-byte codes.
	 For a table of the bytecode set, see EncoderForV1's class comment."

	| byte method |
	method := self method.
	byte := self method at: pc.
	pc := pc + 1.
	"We do an inline quasi-binary search on bytecode"
	bytecode < 234 ifTrue: "pushes"
		[bytecode < 231 ifTrue:
			[bytecode < 229 ifTrue:
				[| literal |
				 bytecode = 226 ifTrue:
					[^client pushReceiverVariable: (extA bitShift: 8) + byte].
				 literal := method literalAt: (extA bitShift: 8) + byte + 1.
				 bytecode = 227 ifTrue:
					[^client pushLiteralVariable: literal].
				 ^client pushConstant: literal].
			bytecode = 229 ifTrue:
				[^client pushTemporaryVariable: byte].
			^self unusedBytecode: client at: startPC].
		bytecode = 231 ifTrue:
			[^byte < 128
				ifTrue: [client pushNewArrayOfSize: byte]
				ifFalse: [client pushConsArrayWithElements: byte - 128]].
		bytecode = 232 ifTrue:
			[^client pushSpecialConstant: ((extB < 128 ifTrue: [extB] ifFalse: [extB - 256]) bitShift: 8) + byte].
		^client pushSpecialConstant: (Character value: ((extB bitAnd: 16rFF) bitShift: 8) + byte)].
	bytecode < 240 ifTrue: "sends, trap and jump"
		[bytecode < 236 ifTrue: "sends"
			[(bytecode = 235 and: [extB >= 64]) ifTrue:
				[^client
					directedSuperSend: (method literalAt: (extA bitShift: 5) + (byte // 8) + 1)
					numArgs: (extB - 64 bitShift: 3) + (byte \\ 8)].
			 ^client
				send: (method literalAt: (extA bitShift: 5) + (byte // 8) + 1)
				super: bytecode = 235
				numArgs: (extB bitShift: 3) + (byte \\ 8)].
		 bytecode = 236 ifTrue:
			[^client callMappedInlinedPrimitive: byte].
		bytecode = 237 ifTrue:
			[^client jump: (extB bitShift: 8) + byte].
		 ^client jump: (extB bitShift: 8) + byte if: bytecode = 238].
	bytecode < 243 ifTrue:
		[bytecode = 240 ifTrue:
			[^client popIntoReceiverVariable: (extA bitShift: 8) + byte].
		 bytecode = 241 ifTrue:
			[^client popIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1)].
		 ^client popIntoTemporaryVariable: byte].
	bytecode = 243 ifTrue:
		[^client storeIntoReceiverVariable: (extA bitShift: 8) + byte].
	bytecode = 244 ifTrue:
		[^client storeIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1)].
	bytecode = 245 ifTrue:
		[^client storeIntoTemporaryVariable: byte].
	"246-247	1111011 i	xxxxxxxx	UNASSIGNED"
	^self unusedBytecode: client at: startPC! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'eem 3/23/2017 16:32'!
         interpretNext3ByteSistaV1Instruction: bytecode for: client extA: extA extB: extB startPC: startPC
	"Send to the argument, client, a message that specifies the next instruction.
	 This method handles the three-byte codes.
	 For a table of the bytecode set, see EncoderForSistaV1's class comment."

	| method byte2 byte3 literal |
	method := self method.
	byte2 := method at: pc.
	byte3 := method at: pc + 1.
	pc := pc + 2.

	"**	248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
									m=1 means inlined primitive, no hard return after execution. 
									ss defines the unsafe operation set used to encode the operations. 
									(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are not used)
									Lowcode inlined primitives may have extensions."
	bytecode = 248 ifTrue:
		[| primitiveSetSelector primitiveNumber |
		 byte3 < 128 ifTrue:
			[ "Maybe this should be restricted to the 13 bit primitiveNumber too..."
			 ^client callPrimitive: byte2 + (byte3 bitShift: 8)].
		 primitiveSetSelector := (byte3 bitShift: -5) bitAnd: 3.
		 primitiveNumber := byte2 + ((byte3 bitAnd: 31) bitShift: 8).
		 primitiveSetSelector = 0 ifTrue: "Sista inline primitives"
			[^client callInlinePrimitive: byte2 + (byte3 - 128 bitShift: 8)].
		 primitiveSetSelector = 1 ifTrue: "Lowcode inline primitives"
			[^client callLowcodeInlinePrimitive: byte2 + (byte3 - 128 bitShift: 8) extA: extA extB: extB].
		 "fall through to ^self unusedBytecode: client at: startPC below"].

	"*	249		11111001	xxxxxxxx	siyyyyyy	push Closure Compiled block literal index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1 ignoreOuterContext: i = 1"
	bytecode = 249 ifTrue:
		[literal := method literalAt: (extA bitShift: 8) + byte2 + 1.
		 (byte3 noMask: 16rC0) ifTrue:
			[^client pushFullClosure: literal numCopied: byte3].
		 ^client
			pushFullClosure: literal
			numCopied: (byte3 bitAnd: 16r3F)
			receiverOnStack: (byte3 anyMask: 16r80)
			ignoreOuterContext: (byte3 anyMask: 16r40)].
	bytecode = 250 ifTrue:
		["**	250  11111010  eeiiikkk  jjjjjjjj  Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions"
		 ^client
			pushClosureCopyNumCopiedValues: ((byte2 bitShift: -3) bitAnd: 7) + (extA // 16 bitShift: 3)
			numArgs: (byte2 bitAnd: 7) + (extA \\ 16 bitShift: 3)
			blockSize: byte3 + (extB bitShift: 8)].
	bytecode = 251 ifTrue:
		[^client pushRemoteTemp: byte2 inVectorAt: byte3].
	bytecode = 252 ifTrue:
		[^client storeIntoRemoteTemp: byte2 inVectorAt: byte3].
	bytecode = 253 ifTrue:
		[^client popIntoRemoteTemp: byte2 inVectorAt: byte3].
	"**	254		11111110	kkkkkkkk	jjjjjjjj		branch If Not Instance Of Behavior/Array Of Behavior kkkkkkkk (+ Extend A * 256, where Extend A >= 0) distance jjjjjjjj (+ Extend B * 256, where Extend B >= 0)"
	bytecode = 254 ifTrue: "The sign bit of extB inverts the operation.  Would like to have extB < -128, but this is good enough for now."
		[literal := method literalAt: (extA bitShift: 8) + byte2 + 1.
		 extB < 0 ifTrue: [^client branchIfInstanceOf: literal distance: (extB + 128 bitShift: 8) + byte3].
		 ^client branchIfNotInstanceOf: literal distance: (extB bitShift: 8) + byte3].
	^self unusedBytecode: client at: startPC! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'mt 12/20/2023 13:20'!
                   interpretNextSistaV1InstructionFor: client
	"Send to the argument, client, a message that specifies the next instruction."

	| byte div16 offset method extA extB savedPC |
	method := self method.
	"For a table of the bytecode set, see EncoderForSistaV1's class comment."
	"consume and compute any extensions first."
	extA := extB := 0.
	savedPC := pc.
	[byte := self method at: pc.
	 pc := pc + 1.
	 byte >= 16rE0 and: [byte <= 16rE1]] whileTrue:
		[| extByte |
		 extByte := self method at: pc.
		 pc := pc + 1.
		 byte = 16rE0
			ifTrue:
				[extA := (extA bitShift: 8) + extByte]
			ifFalse:
				[extB := (extB = 0 and: [extByte > 127])
							ifTrue: [extByte - 256]
							ifFalse: [(extB bitShift: 8) + extByte]]].
	div16 := byte // 16.
	offset := byte \\ 16.
	"We do an inline quasi-binary search on each of the possible 16 values of div16"
	div16 < 11 ifTrue:
		[div16 < 6 ifTrue:
			[div16 < 4 ifTrue:
				[div16 < 2 ifTrue:
					[div16 = 0 ifTrue:
						 [^client pushReceiverVariable: offset].
					^client pushLiteralVariable: (method literalAt: offset + 1)]. "div16 = 1"
				 ^client pushConstant: (method literalAt: byte \\ 32 + 1)].
			 div16 = 4 ifTrue:
				[offset < 12 ifTrue:
					[^client pushTemporaryVariable: offset].
				 offset = 12 ifTrue:
					[^client pushReceiver].
				 offset = 13 ifTrue:
					[^client pushSpecialConstant: true].
				 offset = 14 ifTrue:
					[^client pushSpecialConstant: false].
				 offset = 15 ifTrue:
					[^client pushSpecialConstant: nil]].
			"div16 = 5"
			 offset < 2 ifTrue:
				[^client pushSpecialConstant: offset].
			 offset = 2 ifTrue:
				[^self interpretSistaV1ExtendedPush: extB for: client].
			 offset = 3 ifTrue:
				[^client doDup].
			 offset = 8 ifTrue:
				[^client methodReturnReceiver].
			 offset = 9 ifTrue:
				[^client methodReturnSpecialConstant: true].
			 offset = 10 ifTrue:
				[^client methodReturnSpecialConstant: false].
			 offset = 11 ifTrue:
				[^client methodReturnSpecialConstant: nil].
			 offset = 12 ifTrue:
				[^client methodReturnTop].
			 offset = 13 ifTrue:
				[^client blockReturnConstant: nil].
			 offset = 14 ifTrue:
				[^client blockReturnTop].
			 offset = 15 ifTrue:
				[^client doNop].
			 ^self unusedBytecode: client at: savedPC].
		"short sends"
		div16 = 6 ifTrue:
			[^client
				sendSpecial: (Smalltalk specialSelectorAt: offset + 1)
				numArgs: (Smalltalk specialNargsAt: offset + 1)].
		 div16 = 7 ifTrue:
			[^client
				sendSpecial: (Smalltalk specialSelectorAt: offset + 17)
				numArgs: (Smalltalk specialNargsAt: offset + 17)].
		^client
			send: (method literalAt: offset + 1)
			super: false
			numArgs: div16 - 8].
	"div16 >= 11; bytecode >= 176"
	div16 < 14 ifTrue:
		[div16 = 11 ifTrue:
			[offset < 8 ifTrue:
				[^client jump: offset + 1].
			 ^client jump: offset - 7 if: true].
		 div16 = 12 ifTrue:
			[offset < 8 ifTrue:
				[^client jump: offset + 1 if: false].
			 ^client popIntoReceiverVariable: offset - 8].
		 "div16 = 13"
		 offset < 8 ifTrue:
		 	[^client popIntoTemporaryVariable: offset].
		 offset = 8 ifTrue:
			[^client doPop].
		 offset = 9 ifTrue:
			[^client trap].
		 ^self unusedBytecode: client at: savedPC].
	"2 byte and 3 byte codes"
	byte < 248 ifTrue:
		[^self interpretNext2ByteSistaV1Instruction: byte for: client extA: extA extB: extB startPC: savedPC].
	^self interpretNext3ByteSistaV1Instruction: byte for: client extA: extA extB: extB startPC: savedPC! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'eem 8/1/2014 07:00'!
     interpretSistaV1ExtendedPush: extB for: client
	"Implement the extended push for non-zero extensions."
	"*	82			01010010			Push thisContext, (then Extend B = 1 => push thisProcess)"
	extB = 0 ifTrue:
		[^client pushActiveContext].
	extB = 1 ifTrue:
		[^client pushActiveProcess].
	self error: 'undefined extended push'! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'eem 1/9/2023 08:40'!
  interpretSistaV1Jump
	"If the instruction at pc is an unconditional jump, interpret it, advancing the pc,
	 and answering the jump distance. Otherwise answer nil."

	"	176-183	10110 iii				Jump iii + 1 (i.e., 1 through 8)
	 *	225/16rE1	11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	 *	237		11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, a=0, s=1)"
	| method byte nextpc extB |
	method := self method.
	"consume and compute any extension first."
	extB := 0.
	nextpc := pc. "must not advance pc unless this is a jump."
	[byte := self method at: nextpc.
	 nextpc := nextpc + 1.
	 byte = 16rE1] whileTrue:
		[| extByte |
		 extByte := self method at: nextpc.
		 nextpc := nextpc + 1.
		 extB := (extB = 0 and: [extByte > 127])
					ifTrue: [extByte - 256]
					ifFalse: [(extB bitShift: 8) + extByte]].
	(byte between: 176 and: 183) ifTrue:
		[pc := nextpc.
		 ^byte - 175].
	byte = 237 ifTrue:
		[byte := method at: nextpc.
		 pc := nextpc + 1.
		 ^(extB bitShift: 8) + byte].
	^nil! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'eem 8/1/2014 06:45'!
        interpretSistaV1JumpIfCond
	"If the instruction at pc is a conditional jump, interpret it, advancing the pc,
	 and answering the jump distance. Otherwise answer nil."

	"	184-191	10111 iii				Pop and Jump 0n True iii +1 (i.e., 1 through 8)
		192-199	11000 iii				Pop and Jump 0n False iii +1 (i.e., 1 through 8)
	 *	225/E1		11100001	sbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B)
	 *	238		11101110	iiiiiiii		Pop and Jump 0n True #iiiiiiii (+ Extend B * 256, where Extend B >= 0)
	 *	239		11101111	iiiiiiii		Pop and Jump 0n False #iiiiiiii (+ Extend B * 256, where Extend B >= 0)"
	| method byte nextpc extB |
	method := self method.
	"consume and compute any extension first."
	extB := 0.
	nextpc := pc. "must not advance pc unless this is a jump."
	[byte := self method at: nextpc.
	 nextpc := nextpc + 1.
	 byte = 16rE1] whileTrue:
		[| extByte |
		 extByte := self method at: nextpc.
		 nextpc := nextpc + 1.
		 extB := (extB = 0 and: [extByte > 127])
					ifTrue: [extByte - 256]
					ifFalse: [(extB bitShift: 8) + extByte]].
	(byte between: 184 and: 199) ifTrue:
		[pc := nextpc.
		 ^(byte bitAnd: 7) + 1].
	(byte between: 238 and: 239) ifTrue:
		[byte := method at: nextpc.
		 pc := nextpc + 1.
		 ^(extB bitShift: 8) + byte].
	^nil! !
!InstructionStream class methodsFor: 'class initialization' stamp: 'eem 8/22/2018 15:00' overrides: 16917943!
                 initialize
	"Initialize an array of special constants returned by single-bytecode returns
	 in the SqueakV3 bytecode set."

	SpecialConstants := {true. false. nil. -1. 0. 1. 2}
	"InstructionStream initialize."
! !

InstructionStream initialize!
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 8/1/2014 07:17'!
                               blockReturnConstant: value

	self pushConstant: value; blockReturnTop! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 1/5/2018 10:29'!
           directedSuperSend: selector numArgs: numArgs
	stack removeLast. "Discard the pushed class."
	^self send: selector super: true numArgs: numArgs! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'mt 12/20/2023 13:24'!
 methodReturnSpecialConstant: value
	^self methodReturnConstant: value! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'CompiledMethodTest 9/12/2021 21:20'!
                           pushSpecialConstant: value
	^self pushConstant: value! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'CompiledMethodTest 9/12/2021 21:19'!
           sendSpecial: selector numArgs: numArgs
	^self send: selector super: false numArgs: numArgs! !
!Decompiler methodsFor: 'private' stamp: 'eem 4/25/2017 18:02'!
  convertToDoLoop: blockBodyTempCounts
	"If statements contains the pattern
		var := startExpr.
		[var <= limit] whileTrue: [...statements... var := var + incConst]
	or
		var := startExpr.
		limit := limitExpr.
		[var <= limit] whileTrue: [...statements... var := var + incConst]
	then replace this by
		startExpr to: limit by: incConst do: [:var | ...statements...]
	 and answer true."
	| whileStmt incrStmt initStmt limitStmt toDoStmt |
	whileStmt := statements last.
	incrStmt := whileStmt arguments first statements last.
	incrStmt isAssignmentNode ifFalse:
		[^false].
	(self startAndLimitFor: incrStmt variable from: stack into:
							[:startExpr :limitExpr| initStmt := startExpr. limitStmt := limitExpr])
		ifTrue:
			[| limitInStatements |
			 limitInStatements := limitStmt isNil
								    and: [statements size > 1
								    and: [self startAndLimitFor: incrStmt variable from: { stack last. (statements last: 2) first } into:
												[:startExpr :limitExpr| limitStmt := limitExpr]]].
			(toDoStmt := statements last toDoFromWhileWithCounts: blockBodyTempCounts init: initStmt limit: limitStmt) ifNil:
				[^false].
			 limitInStatements
				ifTrue:
					[stack
						removeLast;
						addLast: toDoStmt.
					 statements removeLast: 2]
				ifFalse:
					[stack
						removeLast: (limitStmt ifNil: [1] ifNotNil: [2]);
						addLast: toDoStmt.
					 statements removeLast]]
		ifFalse:
			[(self startAndLimitFor: incrStmt variable from: statements allButLast into:
							[:startExpr :limitExpr| initStmt := startExpr. limitStmt := limitExpr]) ifFalse:
				[^false].
			 (toDoStmt := statements last toDoFromWhileWithCounts: blockBodyTempCounts init: initStmt limit: limitStmt) ifNil:
				[^false].
			 statements
				removeLast: (limitStmt ifNil: [2] ifNotNil: [3]);
				addLast: toDoStmt].
	self markTemp: initStmt variable asOutOfScope: -1. "Flag arg as out of scope"
	initStmt variable beBlockArg.
	limitStmt ifNotNil:
		[self markTemp: limitStmt variable asOutOfScope: -2.
		 toDoStmt arguments at: 1 put: limitStmt value]. "Flag limit as hidden"
	^true! !
!Decompiler methodsFor: 'private' stamp: 'eem 4/25/2017 16:07'!
markTemp: tempVarNode asOutOfScope: scopeFlag
	tempVarNode scope: scopeFlag.
	tempReadCounts removeKey: tempVarNode ifAbsent: []! !
!Decompiler methodsFor: 'private' stamp: 'eem 1/10/2023 11:36'!
                            printPCRelative: value on: aStream
	value
		ifNil: [value printOn: aStream]
		ifNotNil:
			[value < method initialPC
				ifTrue: [value printOn: aStream]
				ifFalse: [aStream nextPut: $+; print: value - method initialPC]]! !
!Decompiler methodsFor: 'private' stamp: 'eem 7/12/2024 10:21'!
                              startAndLimitFor: incrVar from: aStack into: binaryBlock
	"If incrVar matches the increment of a whileLoop at the end of statements
	 evaluate binaryBlock with the init statement for incrVar and the init statement
	 for the block's limit, if any, and answer true.  Otherwise answer false.  Used to
	 help convert whileTrue: loops into to:[by:]do: loops."
	| guard initExpr limitInit size |
	((size := aStack size) >= 1
	 and: [(initExpr := aStack at: size) ~~ CaseFlag]
	 and: [initExpr isAssignmentNode]) ifFalse:
		[^false].
	initExpr variable == incrVar ifTrue:
		[binaryBlock value: initExpr value: nil.
		 ^true].
	limitInit := initExpr.
	(size >= 2
	 and: [(initExpr := aStack at: size - 1) isAssignmentNode
	 and: [initExpr variable == incrVar
	 and: [(guard := statements last receiver) isBlockNode
	 and: [guard statements size = 1
	 and: [(guard := guard statements first) isMessageNode
	 and: [guard receiver == incrVar
	 and: [guard arguments size > 0
	 and: [guard arguments first == limitInit variable]]]]]]]]) ifTrue:
		[binaryBlock value: initExpr value: limitInit.
		 ^true].
	^false! !
!Decompiler class methodsFor: 'class initialization' stamp: 'nice 5/10/2020 11:50' overrides: 50347373!
        initialize

	CascadeFlag := 'cascade'.  "A unique object"
	CaseFlag := 'case'. "Ditto"
	OtherwiseFlag := 'otherwise'. "Ditto"
	ArgumentFlag := 'argument'.  "Ditto"
	IfNilFlag := 'ifNil'.  "Ditto"

	"Decompiler initialize"! !

Decompiler initialize!
!ContextPart methodsFor: 'instruction decoding' stamp: 'tpr 12/25/2022 16:36'!
                        directedSuperSend: selector numArgs: numArgs
	"Simulate the action of bytecodes that send a message with selector, selector,
	 starting the message lookup in the superclass of the class on top of stack.
	 The arguments of the message are found in the next numArgs locations on
	 the stack and the receiver just below them."

	| class newReceiver arguments |
	class := self pop.
	arguments := Array new: numArgs.
	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].
	newReceiver := self pop.
	QuickStep == self ifTrue:
		[QuickStep := nil.
		^self quickSend: selector to: newReceiver with: arguments lookupIn: class superclass].
	^self send: selector to: newReceiver with: arguments lookupIn: class superclass! !
!ContextPart methodsFor: 'controlling' stamp: 'eem 12/27/2024 13:55:04'!
   activateMethod: newMethod withArgs: args receiver: rcvr
	"Answer a MethodContext initialized with the arguments."

	^MethodContext 
		sender: self
		receiver: rcvr
		method: newMethod
		arguments: args! !
!ContextPart methodsFor: 'controlling' stamp: 'eem 12/27/2024 14:09:16'!
          executeMethod: meth forSelector: selector withArgs: arguments receiver: rcvr

	| primIndex val ctxt |
	(self objectClass: meth) isCompiledMethodClass ifFalse:
		["Object as Methods (OaM) protocol: 'The contract is that, when the VM encounters an ordinary object (rather than a compiled method) in the method dictionary during lookup, it sends it the special selector #run:with:in: providing the original selector, arguments, and receiver.'. DOI: 10.1145/2991041.2991062."
		^self send: #run:with:in:
			to: meth
			with: {selector. arguments. rcvr}].
	
	meth numArgs = arguments size ifFalse:
		[^ self class primitiveFailTokenFor: #'bad number of arguments'].
	(primIndex := meth primitive) > 0 ifTrue:
		[val := self doPrimitive: primIndex method: meth receiver: rcvr args: arguments.
		(self isPrimFailToken: val) ifFalse:
			[^val]].
	
	ctxt := self activateMethod: meth withArgs: arguments receiver: rcvr.
	(primIndex isInteger and: [primIndex > 0]) ifTrue:
		[ctxt failPrimitiveWith: val].
	
	^ctxt! !
!ContextPart methodsFor: 'controlling' stamp: 'eem 4/13/2017 13:22'!
           send: selector to: rcvr with: arguments
	"Simulate the action of sending a message with selector arguments to rcvr."

	^self send: selector to: rcvr with: arguments lookupIn: (self objectClass: rcvr)! !
!ContextPart methodsFor: 'instruction decoding implicit literals' stamp: 'mt 12/20/2023 13:23'!
                     methodReturnSpecialConstant: value
	"Simulate the action of a 'return constant' bytecode whose value is the
	 argument, value. This corresponds to a source expression like '^0'."

	^self return: value from: self methodReturnContext! !
!ContextPart methodsFor: 'instruction decoding implicit literals' stamp: 'eem 9/12/2021 21:52'!
                     pushSpecialConstant: value 
	"Simulate the action of bytecode that pushes the constant, value, on the 
	top of the stack."

	self push: value! !
!ContextPart methodsFor: 'instruction decoding implicit literals' stamp: 'eem 9/12/2021 21:24'!
               sendSpecial: selector numArgs: numArgs
	"Simulate the action of bytecodes that send a message with selector, 
	 selector. The arguments  of the message are found in the top numArgs
	 locations on the stack and the receiver just below them."

	| thisReceiver arguments lookupClass |
	arguments := Array new: numArgs.
	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].
	thisReceiver := self pop.
	lookupClass := self objectClass: thisReceiver.
	QuickStep == self ifTrue:
		[QuickStep := nil.
		^self quickSend: selector to: thisReceiver with: arguments lookupIn: lookupClass].
	^self send: selector to: thisReceiver with: arguments lookupIn: lookupClass! !
!ContextPart methodsFor: 'read-only objects' stamp: 'eem 12/24/2024 19:58:21'!
                    modificationForbiddenFor: target at: index put: anObject
	"This is a place-holder before proper read-only object support is implemented."
	^self error: 'no modification'! !
!ContextPart methodsFor: 'read-only objects' stamp: 'eem 12/24/2024 19:58:48'!
    modificationForbiddenFor: target instVarAt: index put: anObject
	"This is a place-holder before proper read-only object support is implemented."
	^self error: 'no modification'! !
!ContextPart methodsFor: 'read-only objects' stamp: 'eem 3/11/2020 18:02'!
 simulatedObject: anObject instVarAt: anIndex put: aValue 
	"Primitive. Store a value into a fixed variable in the argument anObject.
	 The numbering of the variables corresponds to the named instance
	 variables.  Fail if the index is not an Integer or is not the index of a
	 fixed variable, or if anObject is read-only. This version correctly simulates
	 assigning to a read-only object. Answer the value stored as the result.
	 Using this message violates the  principle that each object has sovereign
	 control over the storing of values into its instance variables. Essential for
	 the debugger. See Object documentation whatIsAPrimitive."

	<primitive: 174 error: ec>
	ec == #'no modification' ifTrue:
		[^self send: #attemptToAssign:to:withIndex: to: self with: {aValue. anObject. anIndex} lookupIn: self class].
	self primitiveFailed! !
!ContextPart class methodsFor: 'class initialization' stamp: 'eem 12/26/2024 14:02:33' overrides: 50347373!
       initialize

	PrimitiveFailToken := Object new. "A unique token."
	ValueIndex := Association allInstVarNames indexOf: 'value'.
	QuickStep := nil "The context stepping in the debugger"! !

ContextPart initialize!
!Mutex methodsFor: 'system simulation' stamp: 'eem 3/30/2017 15:44'!
        primitiveEnterCriticalSectionOnBehalfOf: effectiveProcess
	"Primitive. Simulate primitiveEnterCriticalSection.  The receiver
	 must be unowned or owned by the effectiveProcess to proceed.
	 Answer if the process is already owned by the current process."
	<primitive: 186>
	^MethodContext primitiveFailTokenFor: nil! !
!Mutex methodsFor: 'system simulation' stamp: 'eem 3/30/2017 15:44'!
                             primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effectiveProcess
	"Primitive. Simulate primitiveEnterCriticalSection.  Attempt to set the ownership
	 of the receiver.  If the receiver is unowned set its owningProcess to the
	 effectiveProcess and answer false.  If the receiver is owned by the effectiveProcess
	 answer true.  If the receiver is owned by some other process answer nil."
	<primitive: 187>
	^MethodContext primitiveFailTokenFor: nil! !
!CompiledMethod methodsFor: 'testing' stamp: 'eem 1/17/2025 15:16:36' prior: 16833192!
                             isSetterOf: anInstVarName at: anInstVarIndex
	"Check if the receiver is a setter of the give inst var located at instVarIndex.
	 Only look at the bytecode to avoid soiurce code parsing issues."
	| scanner instruction |
	
	self isQuick ifTrue: [ ^false ].
	self selector = (anInstVarName, ':') ifFalse: [ ^false ].
	scanner := InstructionStream on: self.
	instruction := scanner nextInstruction.
	(instruction selector == #pushTemporaryVariable:
	 and: [instruction argument = 0]) ifFalse:
		[^false].
	instruction := scanner nextInstruction.
	(instruction selector == #popIntoReceiverVariable:
	 and: [instruction argument = (anInstVarIndex - 1)]) ifFalse:
		[^false].
	^scanner nextInstruction selector == #methodReturnReceiver! !
!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 1/21/2025 12:07' prior: 16835020 overrides: 16917943!
         initialize    "CompiledMethod initialize"
	"Initialize class variables specifying the size of the temporary frame
	needed to run instances of me."

	SmallFrame := 16.	"Context range for temps+stack"
	LargeFrame := 56.
	PrimaryBytecodeSetEncoderClass ifNil:
		[PrimaryBytecodeSetEncoderClass := EncoderForV3PlusClosures].
	SecondaryBytecodeSetEncoderClass ifNil:
		[SecondaryBytecodeSetEncoderClass := EncoderForSistaV1].
	PreferredBytecodeSetEncoderClass ifNil:
		[PreferredBytecodeSetEncoderClass := PrimaryBytecodeSetEncoderClass]! !

CompiledMethod initialize!
!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 8/13/2014 13:29' prior: 16835037!
     installPrimaryBytecodeSet: aBytecodeEncoderSubclass
	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:
		[^self].
	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:
		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].
	(self allSubInstances
			detect: [:m| m header >= 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]
			ifNone: []) ifNotNil:
		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].
	PrimaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass! !
!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 8/13/2014 13:29' prior: 16835056!
installSecondaryBytecodeSet: aBytecodeEncoderSubclass
	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:
		[^self].
	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:
		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].
	(self allSubInstances
			detect: [:m| m header < 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]
			ifNone: []) ifNotNil:
		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].
	SecondaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass! !
!Parser methodsFor: 'private' stamp: 'eem 4/3/2017 16:21' prior: 16922693!
                         encoder
	^encoder ifNil:
		[encoder := CompiledMethod preferredBytecodeSetEncoderClass new]! !
!ParseNode methodsFor: 'testing' stamp: '' prior: 16920139!
     isReturningIf

	^false! !
!ParseNode class methodsFor: 'accessing' stamp: 'eem 12/27/2024 15:32:12' prior: 16920324!
           blockReturnCode

	^ EndRemote! !
!ParseNode class methodsFor: 'accessing' stamp: 'eem 12/27/2024 15:32:16' prior: 16920329!
    popCode

	^ Pop! !
!ParseNode class methodsFor: 'accessing' stamp: 'eem 12/27/2024 15:30:17' prior: 16920334!
                  pushNilCode

	^LdNil! !
!ParseNode class methodsFor: 'class initialization' stamp: 'jmv 8/8/2016 12:59:33' prior: 16920401 overrides: 16917943!
                initialize
	"
	ParseNode initialize. VariableNode initialize
	"
	LdInstType := 1.
	LdTempType := 2.
	LdLitType := 3.
	LdLitIndType := 4.
	SendType := 5.
	"Back in the day the following constants corresponded to bytecodes.
	 Now they're just unique values that need to be eliminated when and if
	 things like code:type: are cleaned up."
	CodeBases := #(0 16 32 64 208 ).
	CodeLimits := #(16 16 32 32 16 ).
	LdSelf := 112.
	LdTrue := 113.
	LdFalse := 114.
	LdNil := 115.
	LdMinus1 := 116.
	LoadLong := 128.
	LdSuper := 133.
	Pop := 135.
	LdThisContext := 137.
	EndRemote := 125.
	SendPlus := 176.
	Send := 208.
	
	"((ParseNode class >> #initialize) literals select: [:l| l isVariableBinding and: [(ParseNode classPool includesAssociation: l) and: [(self systemNavigation allCallsOn: l localTo: ParseNode) size = 1]]]) sort: [:a :b| a key <= b key]"

	"ParseNode classPool associations select: [:a| (self systemNavigation allCallsOn: a localTo: ParseNode) isEmpty]"! !

ParseNode initialize!
!Encoder methodsFor: 'initialization' stamp: 'eem 12/27/2024 15:56:37' prior: 16853557!
           initScopeAndLiteralTables

	StdVariables ifNil: [VariableNode initClassCachedState].
	scopeTable := StdVariables copy.
	litSet := StdLiterals copy.
	"comments can be left hanging on nodes from previous compilations.
	 probably better than this hack fix is to create the nodes afresh on each compilation."
	scopeTable do:
		[:varNode| varNode comment: nil].
	litSet do:
		[:varNode| varNode comment: nil].
	selectorSet := StdSelectors copy.
	litIndSet := IdentityDictionary new.
	literalStream := WriteStream on: (Array new: 32).
	addedSelectorAndMethodClassLiterals := false.
	optimizedSelectors := Set new.
	bindingsInBacktickLiterals := Set new.! !
!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 4/5/2017 17:22' prior: 16801497 overrides: 16852806!
               bindBlockArg: name within: aBlockNode
	| nArgs |
	(nArgs := aBlockNode nArgsSlot) isNil ifTrue:
		[aBlockNode nArgsSlot: (nArgs := 0)].
	nArgs >= 15 ifTrue:
		[^self notify: 'Too many arguments'].
	aBlockNode nArgsSlot: nArgs + 1.
	^(self bindTemp: name)
		beBlockArg;
		nowHasDef;
		nowHasRef;
		yourself! !
!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 4/5/2017 17:20' prior: 16801530 overrides: 16852845!
     bindBlockTemp: name within: aBlockNode
	| nArgs |
	(nArgs := aBlockNode nArgsSlot) ifNil:
		[aBlockNode nArgsSlot: (nArgs := 0)].
	nArgs >= (CompiledMethod fullFrameSize - 1) ifTrue:
		[^self notify: 'Too many temporaries'].
	aBlockNode nArgsSlot: nArgs + 1.
	^self bindTemp: name! !
!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 4/5/2017 17:23' prior: 16801556 overrides: 16852883!
                              bindTemp: name
	"Declare a temporary; error not if a field or class variable or out-of-scope temp."
	scopeTable at: name ifPresent:
		[:node|
		"When non-interactive raise the error only if it is a duplicate"
		node isTemp
			ifTrue:[node scope >= 0 ifTrue:
						[^self notify: 'Name already used in this method']]
			ifFalse:[self warnAboutShadowed: name]].
	^self reallyBind: name! !
!BytecodeEncoder methodsFor: 'special literal encodings' stamp: 'eem 12/26/2024 11:34:56' prior: 16801635!
                  if: code isSpecialLiteralForPush: aBlock
	"If code is that of a special literal for push then evaluate aBlock with the special literal
	 The special literals for push are nil true false -1 0 1 & 2 which have special encodings
	 in the blue book bytecode set.  Answer whether it was a special literal."
	^(code between: LdTrue and: LdNil + 4)
	    and: [aBlock value: (#(true false nil -1 0 1 2) at: code - LdSelf).
			true]! !
!BraceNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:12' prior: 16797030!
                               emitCodeForValue: stack encoder: encoder
	"Hack; when sizing we have no way of knowing how much stack space is available."
	elements size <= self maxElementsForConsArray ifTrue:
		[elements do: [:node| node emitCodeForValue: stack encoder: encoder].
		 encoder genPushConsArray: elements size.
		 stack
			pop: elements size;
			push: 1.
		 ^self].
	^emitNode emitCodeForValue: stack encoder: encoder! !
!BraceNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:16' prior: 16797047!
                      sizeCodeForValue: encoder

	"Hack; we have no way of knowing how much stack space is available."
	elements size <= self maxElementsForConsArray ifTrue:
		[^(elements inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])
		  + (encoder sizePushConsArray: elements size)].
	"Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"
	emitNode := CascadeNode new
					receiver: (MessageNode new
								receiver: (encoder encodeVariable: #Array)
								selector: #braceStream:
								arguments: {encoder encodeLiteral: elements size}
								precedence: 3 from: encoder)
					messages: ((elements collect: [:elt |
											MessageNode new
												receiver: nil
												selector: #nextPut:
												arguments: {elt}
												precedence: 3
												from: encoder])
								copyWith: (MessageNode new
												receiver: nil
												selector: #braceArray
												arguments: #()
												precedence: 1
												from: encoder)).
	^emitNode sizeCodeForValue: encoder! !
!BraceNode methodsFor: 'closure analysis' stamp: 'eem 7/20/2009 09:33' prior: 16797008!
 analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"
	elements do:
		[:node|
		node analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools]! !
!BlockNode methodsFor: 'code generation' stamp: 'eem 01/07/2018 18:41' prior: 16795063!
                   emitCodeForValue: stack encoder: encoder
	encoder supportsFullBlocks ifTrue:
		[^self emitCodeForFullBlockValue: stack encoder: encoder].
	copiedValues do:
		[:copiedValue| copiedValue emitCodeForValue: stack encoder: encoder].
	closureCreationNode pc: encoder nextPC.
	encoder
		genPushClosureCopyNumCopiedValues: copiedValues size
		numArgs: arguments size
		jumpSize: size.
	stack
		pop: copiedValues size;
		push: 1.
	"Emit the body of the block"
	self emitCodeForEvaluatedClosureValue: stack encoder: encoder! !
!BlockNode methodsFor: 'code generation' stamp: 'eem 12/24/2024 16:46:18' prior: 16795096!
sizeCodeForValue: encoder
	"Compute the size for the creation of the block and its code."
	copiedValues := self computeCopiedValues: encoder rootNode.
	self closureCreationNode.
	encoder supportsFullBlocks ifTrue:
		[^(copiedValues inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])
		 + (encoder
				sizePushFullClosure:
					(closureCreationNode
						key: (self createBlockLiteral: encoder);
						reserve: encoder;
						index)
				numCopied: copiedValues size)].
	"Remember size of body for emit time so we know the size of the jump around it."
	size := self sizeCodeForEvaluatedClosureValue: encoder.
	^(copiedValues inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])
	  + (encoder sizePushClosureCopyNumCopiedValues: copiedValues size numArgs: arguments size jumpSize: size)
	  + size! !
!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 12/24/2024 16:30:00' prior: 16794722!
                         constructClosureCreationNode: encoder
	copiedValues := self computeCopiedValues: encoder rootNode.
	^self closureCreationNode! !
!BlockNode class methodsFor: 'instance creation' stamp: 'eem 12/28/2024 13:23' prior: 16795500!
                               withJust: aNode
	^self new statements: { aNode } returns: false! !
!MethodNode methodsFor: 'converting' stamp: 'eem 12/29/2024 17:45:43' prior: 16901166!
      preen
	"Preen for pretty-printing and/or decompilation.
	 i.e. post-process to cover up for inadequacies in both algorithms.

	 Currently two cases:

		preenLocalIfNotNilArg: blockNode
		hiding the assignment to the arg of an inlined block arg to ifNotNil:,
			(var := expr) ifNil: [...] ifNotNil: [...]    =>    expr ifNil: [...] ifNotNil: [:var| ...].

		preenTempsConflictingWithBlockNode: temps
		hiding the declaration of a temp that is redeclared in some block"

	self preenableNodes ifNotNil:
		[:preenableNodes|
		 preenableNodes keysAndValuesDo:
			[:nodeOrArray :selector |
			 self perform: selector with: nodeOrArray with: preenableNodes]]! !
!LiteralNode methodsFor: 'code generation' stamp: 'eem 8/12/2017 15:26' prior: 16893390!
                        emitCodeForValue: stack encoder: encoder
	stack push: 1.
	(encoder isSpecialLiteralForPush: key)
		ifTrue: [encoder genPushSpecialLiteral: key]
		ifFalse: [encoder genPushLiteral: index]! !
!LiteralNode methodsFor: 'code generation' stamp: 'eem 11/29/2022 12:35' prior: 16893406 overrides: 16892950!
                    sizeCodeForValue: encoder
	^(encoder isSpecialLiteralForPush: key)
		ifTrue: [encoder sizePushSpecialLiteral: key]
		ifFalse:
			[self reserve: encoder.
			encoder sizePushLiteral: index]! !
!RemoteTempVectorNode methodsFor: 'closure analysis' stamp: 'eem 4/5/2017 17:23' prior: 16939984!
                               addRemoteTemp: aTempVariableNode encoder: encoder
	remoteTemps ifNil:
		[remoteTemps := OrderedCollection new].
	remoteTemps addLast: aTempVariableNode.
	aTempVariableNode referenceScopesAndIndicesDo:
		[:scopeBlock "<BlockNode>" :location "<Integer>"|
		 self addReadWithin: scopeBlock at: location]! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:30' prior: 16940029!
               emitCodeForStoreInto: aTempVariableNode stack: stack encoder: encoder
	encoder
		genStoreRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:27' prior: 16940042!
                      emitCodeForStorePopInto: aTempVariableNode stack: stack encoder: encoder
	encoder
		genStorePopRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index.
	stack pop: 1! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:31' prior: 16940056!
 emitCodeForValueOf: aTempVariableNode stack: stack encoder: encoder
	encoder
		genPushRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index.
	stack push: 1! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:27' prior: 16940076!
         nodeToInitialize: encoder
	^AssignmentNode new
		variable: self
		value: (NewArrayNode new numElements: remoteTemps size)! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:31' prior: 16940134!
  sizeCodeForStoreInto: aTempVariableNode encoder: encoder
	^encoder
		sizeStoreRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:31' prior: 16940145!
 sizeCodeForStorePopInto: aTempVariableNode encoder: encoder
	^encoder
		sizeStorePopRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index! !
!RemoteTempVectorNode methodsFor: 'code generation' stamp: 'eem 4/5/2017 17:31' prior: 16940157!
                           sizeCodeForValueOf: aTempVariableNode encoder: encoder
	^encoder
		sizePushRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1
		inVectorAt: index! !
!MessageNode methodsFor: 'testing' stamp: 'eem 9/26/2008 12:39' prior: 16897379 overrides: 50347847!
isReturningIf

	^((special between: 3 and: 4) "ifTrue:ifFalse:/ifFalse:ifTrue:"
	    or: [special between: 17 and: 18]) "ifNil:ifNotNil:/ifNotNil:ifNil:"
		and: [arguments first returns and: [arguments last returns]]! !
!MessageNode class methodsFor: 'class initialization' stamp: 'eem 12/27/2024 15:36:08' prior: 16898590 overrides: 50347864!
        initialize
	"
	MessageNode initialize
	"
	MacroSelectors := 
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:
			repeat ).
	MacroTransformers := 
		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:
			transformAnd: transformOr:
			transformWhile: transformWhile: transformWhile: transformWhile:
			transformToDo: transformToDo:
			transformCase: transformCase:
			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:
			transformRepeat: ).
	MacroEmitters := 
		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:
			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:
			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForRepeat:encoder:value:).
	MacroSizers := 
		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:
			sizeCodeForToDo:value: sizeCodeForToDo:value:
			sizeCodeForCase:value: sizeCodeForCase:value:
			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForRepeat:value:).
	MacroPrinters := 
		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:
			printIfOn:indent: printIfOn:indent:
			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:
			printToDoOn:indent: printToDoOn:indent:
			printCaseOn:indent: printCaseOn:indent:
			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:
			printRepeatOn:indent:).
	Preferences
		name: #allowNonBooleanReceiversOfBooleanMessages
		description: 'If set, do not optimize boolean selectors, allowing, for example, new Boolean classes.'
		category: #programming type: Boolean value: false! !

MessageNode initialize!
!DecompilerConstructor methodsFor: 'constructor' stamp: 'ct 3/27/2020 20:01' prior: 16846500!
                 codeAnyLitInd: association

	^LiteralVariableNode new
		name: association key
		key: association
		index: nil
		type: LdLitIndType! !
!DecompilerConstructor methodsFor: 'constructor' stamp: 'ct 3/28/2020 00:36' prior: 16846513!
                            codeAnySelector: selector

	^SelectorNode new
		key: selector
		index: nil
		type: SendType! !
!DecompilerConstructor methodsFor: 'constructor' stamp: 'mt 9/4/2019 16:09' prior: 16846586!
    codeMessage: receiver selector: selector arguments: arguments
	| symbol |
	symbol := selector key.
	(self
		decodeLiteralVariableValueDereferenceWithReceiver: receiver
		selector: symbol
		arguments: arguments) ifNotNil: [:node| ^node].

	^MessageNode new
			receiver: receiver selector: selector
			arguments: arguments
			precedence: symbol precedence! !
!Behavior methodsFor: 'system startup' stamp: 'eem 12/26/2024 14:10:16' prior: 16789305!
  releaseClassCachedState
	"Will be called for each class on shutdown or snapshot. Implemented in relevant subclasses.
	 All class vars or class instVar vars that refer to objects that take up space and can be cheaply
	 recreated lazily on demand, should be nilled. For more expensive stuff to clean and recreate,
	 consider implementing #releaseClassState which is not called on every image save.

	 See implementors for examples"! !
!BlockLocalTempCounter methodsFor: 'initialize-release' stamp: 'eem 4/6/2017 14:16' prior: 16794210!
          tempCountForBlockAt: pc in: method
	"Compute the number of local temporaries in a block.
	 If the block begins with a sequence of push: nil bytecodes then some of
	 These could be initializing local temps.  We can only reliably disambuguate
	 them from other uses of nil by parsing the stack and seeing what the offset
	 of the stack pointer is at the end of the block.

	 There are short-cuts.  The ones we take here are
		- if there is no sequence of push nils there can be no local temps
		- we follow forward jumps to shorten the amount of scanning"
	stackPointer := 0.
	scanner := InstructionStream new method: method pc: pc.
	scanner interpretNextInstructionFor: self.
	blockEnd ifNil:
		[self error: 'pc is not that of a block'].
	scanner nextByte = method encoderClass pushNilCode ifTrue:
		[joinOffsets := Dictionary new.
		 [scanner pc < blockEnd] whileTrue:
			[scanner interpretNextInstructionFor: self]].
	^stackPointer! !
!BlockLocalTempCounter methodsFor: 'initialize-release' stamp: 'eem 4/6/2017 14:56' prior: 16794242!
                   testTempCountForBlockAt: startPc in: method
	"Compute the number of local temporaries in a block.
	 If the block begins with a sequence of push: nil bytecodes then some of
	 These could be initializing local temps.  We can only reliably disambuguate
	 them from other uses of nil by parsing the stack and seeing what the offset
	 of the stack pointer is at the end of the block.There are short-cuts.  The only
	 one we take here is
		- if there is no sequence of push nils there can be no local temps"

	| symbolicLines line prior thePc |
	symbolicLines := Dictionary new.
	method symbolicLinesDo:
		[:pc :lineForPC| symbolicLines at: pc put: lineForPC].
	stackPointer := 0.
	scanner := InstructionStream new method: method pc: startPc.
	scanner interpretNextInstructionFor: self.
	blockEnd ifNil:
		[self error: 'pc is not that of a block'].
	scanner nextByte = method encoderClass pushNilCode ifTrue:
		[joinOffsets := Dictionary new.
		 [scanner pc < blockEnd] whileTrue:
			[line := symbolicLines at: scanner pc.
			 prior := stackPointer.
			 thePc := scanner pc.
			 scanner interpretNextInstructionFor: self.
			 Transcript cr; print: prior; nextPutAll: '->'; print: stackPointer;  tab; print: thePc; tab; nextPutAll: line; flush]].
	^stackPointer! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 1/1/2023 11:57' prior: 16884686 overrides: 16884448!
                              popIntoReceiverVariable: offset 
	"Print the Remove Top Of Stack And Store Into Instance Variable bytecode."

	self print: 'popIntoRcvr: ' , (self stringForReceiverVariableOffset: offset)! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 12/24/2024 17:12:48' prior: 16884743 overrides: 16884488!
    pushConstant: obj
	"Print the Push Constant, obj, on Top Of Stack bytecode."

	self print: (String streamContents:
				[:s |
				s nextPutAll: 'pushConstant: '.
				obj isVariableBinding
					ifFalse: [obj printOn: s]
					ifTrue: [obj key
						ifNotNil: [s nextPutAll: '##'; nextPutAll: obj key]
						ifNil: [s nextPutAll: '###'; nextPutAll: obj value soleInstance name]]]).

	(obj is: #CompiledMethod) ifTrue:
		[obj longPrintOn: stream indent: self indent + 2.
		^self].! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 1/1/2023 11:57' prior: 16884782 overrides: 16884510!
         pushReceiverVariable: offset
	"Print the Push Contents Of the Receiver's Instance Variable Whose Index 
	is the argument, offset, On Top Of Stack bytecode."

	self print: 'pushRcvr: ' , (self stringForReceiverVariableOffset: offset)! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 3/30/2017 15:54' prior: 16884810 overrides: 16884532!
                           send: selector super: supered numArgs: numArgs
	"Print the Send Message With Selector, selector, bytecode. The argument, 
	supered, indicates whether the receiver of the message is specified with 
	'super' in the source method. The arguments of the message are found in 
	the top numArguments locations on the stack and the receiver just 
	below them."

	self print: (supered
				ifTrue: ['superSend: ']
				ifFalse: ['send: '])
			, (self stringForSelector: selector numArgs: numArgs)! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 1/1/2023 11:57' prior: 16884838 overrides: 16884552!
                               storeIntoReceiverVariable: offset 
	"Print the Store Top Of Stack Into Instance Variable Of Method bytecode."

	self print: 'storeIntoRcvr: ' , (self stringForReceiverVariableOffset: offset)! !
!InstructionStream methodsFor: 'decoding - private - v3 plus closures' stamp: 'mt 12/20/2023 13:20' prior: 16885418!
         interpretNextV3ClosuresInstructionFor: client 
	"Send to the argument, client, a message that specifies the type of the 
	 next instruction."

	| byte type offset method |
	method := self method.  
	byte := method at: pc.
	type := byte // 16.  
	offset := byte \\ 16.  
	pc := pc+1.
	"We do an inline binary search on each of the possible 16 values of type."
	type < 8 ifTrue:
		[type < 4 ifTrue:
			[type < 2 ifTrue:
				[type = 0 ifTrue:
					[^ client pushReceiverVariable: offset].
				^ client pushTemporaryVariable: offset].				"type = 1"
			type = 2 ifTrue: 
				[^ client pushConstant: (method literalAt: offset + 1)].
			^ client pushConstant: (method literalAt: offset + 17)].		"type = 3"
		type < 6 ifTrue:
			[type = 4 ifTrue:
				[^ client pushLiteralVariable: (method literalAt: offset + 1)].
			^ client pushLiteralVariable: (method literalAt: offset + 17)]."type = 5"
		type = 6 ifTrue:
			[offset < 8 ifTrue:
				[^ client popIntoReceiverVariable: offset].
			^ client popIntoTemporaryVariable: offset - 8].
		"type = 7"
		offset = 0 ifTrue: [^ client pushReceiver].
		offset < 8 ifTrue: [^ client pushSpecialConstant: (SpecialConstants at: offset)].
		offset = 8 ifTrue: [^ client methodReturnReceiver].
		offset < 12 ifTrue: [^ client methodReturnSpecialConstant: (SpecialConstants at: offset - 8)].
		offset = 12 ifTrue: [^ client methodReturnTop].
		offset = 13 ifTrue: [^ client blockReturnTop].
		^ self unusedBytecode: client at: pc - 1]. "offset = 14 & offset = 15, 126 & 127"
	type < 12 ifTrue:
		[type < 10 ifTrue:
			[type = 8 ifTrue:
				[^ self
					interpretV3ClosuresExtension: offset
					in: method
					for: client].
			"type = 9 (short jumps)"
			offset < 8 ifTrue: [^ client jump: offset + 1].
			^ client jump: offset - 8 + 1 if: false].
		type = 10 ifTrue: "(long jumps)"
			[byte := method at: pc.
			pc := pc + 1.
			offset < 8 ifTrue: [^ client jump: offset - 4 * 256 + byte].
			^ client jump: (offset bitAnd: 3) * 256 + byte if: offset < 12].
		"type = 11; arithmetic special selector sends"
		^ client
			sendSpecial: (Smalltalk specialSelectorAt: offset + 1)
			numArgs: (Smalltalk specialNargsAt: offset + 1)].
		type = 12 ifTrue: "non-arithmetic special selector sends"
			[^ client
				sendSpecial: (Smalltalk specialSelectorAt: offset + 17)
				numArgs: (Smalltalk specialNargsAt: offset + 17)].
	"type = 13, 14 or 15"
	^ client
		send: (method literalAt: offset + 1)
		super: false
		numArgs: type - 13 "0, 1 & 2"! !
!Decompiler methodsFor: 'control' stamp: 'ct 3/26/2020 17:16' prior: 16845449!
             blockTo: end
	"Decompile a range of code as in statementsTo:, but return a block node. NB: end is an exclusive index."
	| exprs block oldBase lastStatementOfBlockIsNil |
	oldBase := blockStackBase.
	blockStackBase := stack size.
	exprs := self statementsTo: end.
	lastStatementOfBlockIsNil := pc < method endPC and: [exprs notEmpty and: [exprs last == (constTable at: 4)]].
	lastStatementOfBlockIsNil ifTrue:
		[exprs := exprs allButLast].
	block := constructor codeBlock: exprs returns: lastReturnPc = lastPc.
	blockStackBase := oldBase.
	lastReturnPc := -1.  "So as not to mislead outer calls"
	^block! !
!Decompiler methodsFor: 'control' stamp: 'eem 12/29/2024 15:16:40' prior: 16845488!
             doClosureCopyCopiedValues: blockCopiedValues numArgs: numArgs blockSize: blockSize
	| startpc savedTemps savedTempVarCount savedNumLocalTemps
	  jump blockArgs blockTemps blockTempsOffset block tmpNumberBase |
	tmpNumberBase := statements size.
	savedTemps := tempVars.
	savedTempVarCount := tempVarCount.
	savedNumLocalTemps := numLocalTemps.
	jump := blockSize + (startpc := pc).
	numLocalTemps := BlockLocalTempCounter tempCountForBlockStartingAt: pc in: method.
	blockTempsOffset := numArgs + blockCopiedValues size.
	(blockStartsToTempVars notNil "implies we were intialized with temp names."
	 and: [blockStartsToTempVars includesKey: pc])
		ifTrue:
			[tempVars := blockStartsToTempVars at: pc]
		ifFalse:
			[blockArgs := (1 to: numArgs) collect:
							[:i| (constructor
									codeTemp: i - 1
									named: 'argm', tmpNumberBase printString, '_', (tempVarCount + i) printString)
								  beBlockArg].
			blockTemps := (1 to: numLocalTemps) collect:
							[:i| constructor
									codeTemp: i + blockTempsOffset - 1
									named: 'temp', tmpNumberBase printString, '_', (tempVarCount + i + numArgs) printString].
			tempVars := blockArgs, blockCopiedValues, blockTemps].
	numLocalTemps timesRepeat:
		[super interpretNextInstructionFor: self.
		 stack removeLast].
	tempVarCount := tempVarCount + numArgs + numLocalTemps.
	block := self blockTo: jump.
	stack addLast: ((constructor
						codeArguments: (tempVars copyFrom: 1 to: numArgs)
						temps: (tempVars copyFrom: blockTempsOffset + 1 to: blockTempsOffset + numLocalTemps)
						block: block)
							pc: startpc;
							yourself).
	tempVars := savedTemps.
	tempVarCount := savedTempVarCount.
	numLocalTemps := savedNumLocalTemps! !
!Decompiler methodsFor: 'control' stamp: 'nice 5/10/2020 12:23' prior: 16845544!
    statementsForCaseTo: end
	"Decompile the method from pc up to end and return an array of
	expressions. If at run time this block will leave a value on the stack,
	set hasValue to true. If the block ends with a jump or return, set exit
	to the destination of the jump, or the end of the method; otherwise, set
	exit = end. Leave pc = end.
	Note that stack initially contains a OtherwiseFlag which will be removed by
	a subsequent Pop instruction, so adjust the StackPos accordingly."

	| blockPos stackPos |
	blockPos := statements size.
	stackPos := stack size - 1. "Adjust for OtherwiseFlag"
	[pc < end]
		whileTrue:
			[lastPc := pc.  limit := end.  "for performs"
			self interpretNextInstructionFor: self].
	"If there is an additional item on the stack, it will be the value
	of this block."
	(hasValue := stack size > stackPos)
		ifTrue:
			[stack last == OtherwiseFlag
				ifFalse: [ statements addLast: stack removeLast] ].
	lastJumpPc = lastPc ifFalse: [exit := pc].
	caseExits add: exit.
	^self popTo: blockPos! !
!Decompiler methodsFor: 'control' stamp: 'eem 12/29/2024 12:19:28' prior: 16845578!
             statementsTo: end
	"Decompile the method from pc up to end and return an array of
	expressions. If at run time this block will leave a value on the stack,
	set hasValue to true. If the block ends with a jump or return, set exit
	to the destination of the jump, or the end of the method; otherwise, set
	exit = end. Leave pc = end."

	| encoderClass blockPos stackPos localLastPC initialPC |
	initialPC := pc.
	encoderClass := method encoderClass.
	blockPos := statements size.
	stackPos := stack size.
	[pc < end]
		whileTrue:
			[lastPc := localLastPC := pc.  limit := end. "for performs"
			 "for logging use the first form"
			 encoderClass interpretNextInstructionFor: self in: self].
	"If there is an additional item on the stack, it will be the value of this block."
	(hasValue := stack size > stackPos)
		ifTrue:
			[statements addLast: stack removeLast].
	lastJumpPc = lastPc ifFalse: [exit := pc].
	^self popTo: blockPos! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'nice 5/10/2020 12:33' prior: 16845609!
                             case: dist
	"statements = keyStmts CascadeFlag keyValueBlock ... keyStmts"

	| nextCase thenJump stmtStream elements b node cases otherBlock myExits |
	nextCase := pc + dist.

	"Now add CaseFlag & keyValueBlock to statements"
	statements addLast: stack removeLast.
	"Trick: put a flag on the stack.
	If it is the last case before otherwise: block, then
	- there won't be a dup of caseOf: receiver before sending =
	- there won't be a pop in the case handling block"
	stack addLast: OtherwiseFlag. "set for next pop"
	statements addLast: (self blockForCaseTo: nextCase).
		
	stack last == OtherwiseFlag
		ifTrue: "Last case"
			["ensure jump is within block (in case thenExpr returns wierdly I guess)"
			stack removeLast. "get rid of CaseFlag"
			stmtStream := ReadStream on: (self popTo: stack removeLast).
			
			elements := OrderedCollection new.
			b := OrderedCollection new.
			[stmtStream atEnd] whileFalse:
				[(node := stmtStream next) == CaseFlag
					ifTrue:
						[elements addLast: (constructor
							codeMessage: (constructor codeBlock: b returns: false)
							selector: (constructor codeSelector: #-> code: #macro)
							arguments: (Array with: stmtStream next)).
						 b := OrderedCollection new]
					ifFalse: [b addLast: node]].
			b size > 0 ifTrue: [self error: 'Bad cases'].
			cases := constructor codeBrace: elements.
			
			"try find the end of the case"
			myExits := caseExits removeLast: elements size.
			myExits := myExits reject: [ :e | e isNil or: [ e < 0 or: [ e > method endPC ] ] ].
			thenJump := myExits isEmpty
							ifTrue: [ nextCase ]
							ifFalse: [ myExits max ].
			
			otherBlock := self blockTo: thenJump.
			stack addLast:
				(constructor
					codeMessage: stack removeLast
					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)
					arguments: (Array with: cases with: otherBlock))].! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'nice 5/10/2020 12:31' prior: 16845664!
                           doDup
	stack last == CaseFlag
		ifTrue:
			["We are in the process of decompiling a caseOf:"
			stack addLast: CaseFlag.
			^self].
	stack last == CascadeFlag
		ifFalse:
			["Save position and mark cascade"
			stack addLast: statements size.
			stack addLast: CascadeFlag].
	stack addLast: CascadeFlag! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'nice 5/10/2020 12:26' prior: 16845673!
                 doPop

	stack isEmpty ifTrue:
		["Ignore pop in first leg of ifNil for value"
		^ self].
	stack last == OtherwiseFlag
		ifTrue: [stack removeLast]
		ifFalse: [statements addLast: stack removeLast].! !
!Decompiler methodsFor: 'instruction decoding' stamp: '' prior: 16845682!
             doStore: stackOrBlock
	"Only called internally, not from InstructionStream. StackOrBlock is stack
	for store, statements for storePop."

	| var expr |
	var := stack removeLast.
	expr := stack removeLast.
	stackOrBlock addLast: (expr == ArgumentFlag
		ifTrue: [var]
		ifFalse: [constructor codeAssignTo: var value: expr])! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 12/28/2024 14:42' prior: 16845718!
                              jump: dist if: condition

	| savePc sign elsePc elseStart end cond ifExpr thenBlock elseBlock
	  thenJump elseJump condHasValue isIfNil saveStack |
	lastJumpIfPcStack addLast: lastPc.
	stack last == CaseFlag ifTrue: [^ [self case: dist] ensure: [lastJumpIfPcStack removeLast]].
	elsePc := lastPc.
	elseStart := pc + dist.
	end := limit.
	"Check for bfp-jmp to invert condition.
	Don't be fooled by a loop with a null body."
	sign := condition.
	savePc := pc.
	self interpretJump ifNotNil:
		[:elseDist|
		 (elseDist >= 0 and: [elseStart = pc]) ifTrue:
			 [sign := sign not.  elseStart := pc + elseDist]].
	pc := savePc.
	ifExpr := stack removeLast.
	(isIfNil := stack size > 0 and: [stack last == IfNilFlag]) ifTrue:
		[stack removeLast].
	saveStack := stack.
	stack := OrderedCollection new.
	thenBlock := self blockTo: elseStart.
	condHasValue := hasValue or: [isIfNil].
	"ensure jump is within block (in case thenExpr returns)"
	thenJump := exit <= end ifTrue: [exit] ifFalse: [elseStart].
	"if jump goes back, then it's a loop"
	thenJump < elseStart
		ifTrue:
			[| blockBody blockArgs savedReadCounts blockBodyReadCounts selector |
			 "Must be a while loop...
			  thenJump will jump to the beginning of the while expr.  In the case of while's
			  with a block in the condition, the while expr should include more than just
			  the last expression: find all the statements needed by searching for the node
			  with the relevant pc."
			stack := saveStack.
			savedReadCounts := tempReadCounts copy.
			pc := thenJump.
			blockBody := self statementsTo: elsePc.
			blockBodyReadCounts := tempReadCounts.
			savedReadCounts keysAndValuesDo:
				[:temp :count|
				 blockBodyReadCounts at: temp put: (blockBodyReadCounts at: temp) - count].
			tempReadCounts := savedReadCounts.
			"discard unwanted statements from block"
			blockBody size - 1 timesRepeat: [statements removeLast].
			blockArgs := thenBlock statements = constructor codeEmptyBlock statements
							ifTrue: [#()]
							ifFalse: [{ thenBlock }].
			selector := blockArgs isEmpty
							ifTrue: [sign ifTrue: [#whileFalse] ifFalse: [#whileTrue]]
							ifFalse: [sign ifTrue: [#whileFalse:] ifFalse: [#whileTrue:]].
			statements addLast:
				(constructor
					codeMessage: (constructor codeBlock: blockBody returns: false)
					selector: (constructor codeSelector: selector code: #macro)
					arguments: blockArgs).
			pc := elseStart.
			selector == #whileTrue: ifTrue:
				[self convertToDoLoop: blockBodyReadCounts]]
		ifFalse:
			["Must be a conditional..."
			elseBlock := self blockTo: thenJump.
			elseJump := exit.
			"if elseJump is backwards, it is not part of the elseExpr"
			elseJump < elsePc ifTrue:
				[pc := lastPc].
			cond := isIfNil
						ifTrue:
							[constructor
								codeMessage: ifExpr ifNilReceiver
								selector: (constructor
											codeSelector: (sign ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])
											code: #macro)
								arguments: (Array with: thenBlock)]
						ifFalse:
							[| args |
							args := sign
										ifTrue: [{elseBlock. thenBlock}]
										ifFalse: [{thenBlock. elseBlock}].
							(constructor
								decodeIfNilWithReceiver: ifExpr
								selector: #ifTrue:ifFalse:
								arguments: args
								tempReadCounts: tempReadCounts) ifNil:
									[constructor
										codeMessage: ifExpr
										selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)
										arguments: args]].
			stack := saveStack.
			condHasValue
				ifTrue: [stack addLast: cond]
				ifFalse: [statements addLast: cond]].
	lastJumpIfPcStack removeLast! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 12/29/2024 12:42:50' prior: 16845859!
                          popIntoTemporaryVariable: offset
	| maybeTVTag tempVector start |
	maybeTVTag := stack last.
	((maybeTVTag isMemberOf: Association)
	 and: [maybeTVTag key == #pushNewArray]) ifTrue:
		[blockStartsToTempVars "implies we were intialized with temp names."
			ifNotNil: "Use the provided temps"
				[self assert: ((tempVector := tempVars at: offset + 1 ifAbsent: [ParseNode basicNew]) isTemp
							 and: [tempVector isIndirectTempVector
							 and: [tempVector remoteTemps size = maybeTVTag value size]])]
			ifNil: "Synthesize some remote temps"
				[tempVector := maybeTVTag value.
				 offset + 1 <= tempVars size
					ifTrue:
						[start := 2.
						 tempVector at: 1 put: (tempVars at: offset + 1)]
					ifFalse:
						[tempVars := (Array new: offset + 1)
										replaceFrom: 1
										to: tempVars size
										with: tempVars.
						start := 1].
				 start to: tempVector size do:
					[:i|
					tempVector
						at: i
						put: (constructor
								codeTemp: numLocalTemps + offset + i - 1
								named: 'temp', (tempVarCount + i) printString)].
				tempVars at: offset + 1 put: (constructor codeRemoteTemp: offset + 1 remoteTemps: tempVector)].
		 tempVarCount := tempVarCount + maybeTVTag value size.
		 stack removeLast.
		 ^self].
	stack addLast: (offset >= tempVars size
						ifTrue: "Handle the case of chained LiteralVariableBinding assigments"
							[stack at: (offset + 1 - tempVars size)]
						ifFalse: "A regular argument or temporary"
							[tempVars at: offset + 1]).
	self doStore: statements! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 4/24/2017 10:17' prior: 16845979!
          pushTemporaryVariable: offset
	| node |
	offset >= tempVars size
				ifTrue: "Handle the case of chained LiteralVariableBinding assigments"
					[self halt.
					 node := stack at: offset + 1 - tempVars size]
				ifFalse: "A regular argument or temporary"
					[node := tempVars at: offset + 1.
					 node isArg ifFalse: "count temp reads for the whileTrue: => to:do: transformation."
						[tempReadCounts at: node put: (tempReadCounts at: node ifAbsent: [0]) + 1]].
	stack addLast: node! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'nice 5/10/2020 12:35' prior: 16845990!
                      send: selector super: superFlag numArgs: numArgs

	| args rcvr selNode msgNode messages |
	args := Array new: numArgs.
	(numArgs to: 1 by: -1) do:
		[:i | args at: i put: stack removeLast].
	rcvr := stack removeLast.
	superFlag ifTrue: [rcvr := constructor codeSuper].
	selNode := constructor codeAnySelector: selector.
	rcvr == CaseFlag
		ifTrue:
			[| cases stmtStream elements node b |
			selector == #= ifTrue:
					[" = signals a case statement..."
					statements addLast: args first.
					stack addLast: rcvr. "restore CaseFlag"
					^ self].
			selector = #caseError ifFalse: [self error: 'unexpected message send while decompiling a caseOf:'].
			stmtStream := ReadStream on: (self popTo: stack removeLast).
			
			elements := OrderedCollection new.
			b := OrderedCollection new.
			[stmtStream atEnd] whileFalse:
				[(node := stmtStream next) == CaseFlag
					ifTrue:
						[elements addLast: (constructor
							codeMessage: (constructor codeBlock: b returns: false)
							selector: (constructor codeSelector: #-> code: #macro)
							arguments: (Array with: stmtStream next)).
						 b := OrderedCollection new]
					ifFalse: [b addLast: node]].
			b size > 0 ifTrue: [self error: 'Bad cases'].
			cases := constructor codeBrace: elements.
			
			stack addLast:
				(constructor
					codeMessage: stack removeLast
					selector: (constructor codeSelector: #caseOf: code: #macro)
					arguments: (Array with: cases)).
			^self].
	rcvr == CascadeFlag
		ifTrue:
			["May actually be a cascade or an ifNil: for value."
			self willJumpIfFalse
				ifTrue: "= generated by a case macro"
					[selector == #= ifTrue:
						[" = signals a case statement..."
						statements addLast: args first.
						stack removeLast; addLast: CaseFlag; addLast: CaseFlag.	"Properly mark the case statement"
						^ self].
					selector == #== ifTrue:
						[" == signals an ifNil: for value..."
						stack removeLast; removeLast.
						rcvr := stack removeLast.
						stack addLast: IfNilFlag;
							addLast: (constructor
								codeMessage: rcvr
								selector: selNode
								arguments: args).
						^ self]]
				ifFalse:
					[(self willJumpIfTrue and: [selector == #==]) ifTrue:
						[" == signals an ifNotNil: for value..."
						stack removeLast; removeLast.
						rcvr := stack removeLast.
						stack addLast: IfNilFlag;
							addLast: (constructor
								codeMessage: rcvr
								selector: selNode
								arguments: args).
						^ self]].
			msgNode := constructor
							codeCascadedMessage: selNode
							arguments: args.
			stack last == CascadeFlag ifFalse:
				["Last message of a cascade"
				statements addLast: msgNode.
				messages := self popTo: stack removeLast.  "Depth saved by first dup"
				msgNode := constructor
								codeCascade: stack removeLast
								messages: messages]]
		ifFalse:
			[msgNode := constructor
						codeMessage: rcvr
						selector: selNode
						arguments: args].
	stack addLast: msgNode! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 4/24/2017 10:18' prior: 16846074!
storeIntoTemporaryVariable: offset
	stack addLast: (offset >= tempVars size
						ifTrue: "Handle the case of chained LiteralVariableBinding assigments"
							[stack at: (offset + 1 - tempVars size)]
						ifFalse: "A regular argument or temporary"
							[tempVars at: offset + 1]).
	self doStore: stack! !
!Decompiler methodsFor: 'public access' stamp: 'eem 1/21/2025 15:32' prior: 16846275!
                     decompile: aSelector in: aClass method: aMethod using: aConstructor

	| block node |
	constructor := aConstructor.
	method := aMethod.
	self initSymbols: aClass.  "create symbol tables"
	method isQuick
		ifTrue: [block := self quickMethod]
		ifFalse: 
			[stack := OrderedCollection new.
			lastJumpIfPcStack := OrderedCollection new.
			caseExits := OrderedCollection new.
			statements := OrderedCollection new.
			numLocalTemps := 0.
			self method: method pc: method initialPC.
			"skip primitive error code store if necessary"
			(method primitive ~= 0 and: [self skipCallPrimitive; willStore]) ifTrue:
				[pc := pc + (method encoderClass bytecodeSize: self firstByte).
				 tempVars := tempVars asOrderedCollection].
			block := self blockTo: method endPC + 1.
			stack isEmpty ifFalse: [self error: 'stack not empty']].
	node := constructor
				codeMethod: aSelector
				block: block
				tempVars: tempVars
				primitive: method primitive
				class: aClass.
	method primitive > 0 ifTrue:
		[node removeAndRenameLastTempIfErrorCode].
	^node preen! !
!Decompiler methodsFor: 'public access' stamp: 'jmv 9/25/2019 17:51:15' prior: 16846311!
      decompileBlock: aBlock 
	"Decompile aBlock, returning the result as a BlockNode.  
	Show temp names from source if available."
	"Decompiler new decompileBlock: [3 + 4]"
	| methodNode home |
	(home := aBlock home) ifNil: [^ nil].
	method := home method.
	(home methodClass) == #unknown ifTrue: [^ nil].
	aBlock isClosure ifTrue:
		[(methodNode := method decompile)
			ifNil: [^nil]
			ifNotNil: [methodNode nodesDo: [:node| node pc = aBlock startpc ifTrue: [^node]]].
		 ^self error: 'cannot find block node matching aBlock'].
	^self error: 'can only decompile BlockClosures'! !
!Decompiler methodsFor: 'initialization' stamp: 'eem 12/28/2024 14:29:22' prior: 16846338!
   initSymbols: aClass
	| argCount |
	constructor method: method class: aClass literals: method literals.
	constTable := constructor codeConstants.
	instVars := Array new: aClass instSize.
	tempVarCount := method numTemps.
	argCount := method numArgs.
	"(tempVars isNil
	 and: [method holdsTempNames]) ifTrue:
		[tempVars := method tempNamesString]."
	tempVars isString
		ifTrue:
			[blockStartsToTempVars := self mapFromBlockStartsIn: method
											toTempVarsFrom: tempVars
											constructor: constructor.
			 tempVars := blockStartsToTempVars at: method initialPC]
		ifFalse:
			[| namedTemps |
			namedTemps := tempVars ifNil: [(1 to: tempVarCount) collect: [ :i | 
					(i <= argCount ifTrue: ['arg'] ifFalse: ['temp']), i printString]].
			tempVars := (1 to: tempVarCount) collect:
							[:i | i <= namedTemps size
								ifTrue: [constructor codeTemp: i - 1 named: (namedTemps at: i)]
								ifFalse: [constructor codeTemp: i - 1]]].
	1 to: method numArgs do:
		[:i|
		(tempVars at: i)
			beMethodArg].
	tempReadCounts := Dictionary new! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'ct 12/30/2023 20:23' prior: 16837100!
   jump: distance if: condition 
	"Simulate the action of a 'conditional jump' bytecode whose offset is the 
	 argument, distance, and whose condition is the argument, condition."

	| bool |
	bool := self pop.
	condition == bool
		ifTrue: [self jump: distance]
		ifFalse:
			[(true == bool or: [false == bool]) ifFalse:
				[^self send: #mustBeBoolean to: bool with: #()]]! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/11/2020 17:29' prior: 16837143!
             popIntoLiteralVariable: value 
	"Simulate the action of bytecode that removes the top of the stack and 
	 stores it into a literal variable of my method. If the receiver is read-only
	 this will provoke a send of #attemptToAssign:withIndex:"

	| top result |
	top := self pop.
	result := self simulatedObject: value instVarAt: ValueIndex put: top.
	^(self object: result eqeq: top)
		ifTrue: [self]
		ifFalse: [result]! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/11/2020 17:30' prior: 16837153!
                            popIntoReceiverVariable: offset 
	"Simulate the action of bytecode that removes the top of the stack and 
	 stores it into an instance variable of my receiver. If the receiver is read-only
	 this will provoke a send of #attemptToAssign:withIndex:"

	| top result |
	top := self pop.
	result := self simulatedObject: self receiver instVarAt: offset + 1 put: top.
	^(self object: result eqeq: top)
		ifTrue: [self]
		ifFalse: [result]! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/29/2017 12:48' prior: 16837176!
              popIntoTemporaryVariable: offset 
	"Simulate the action of bytecode that removes the top of the stack and 
	stores it into one of my temporary variables."

	self at: offset + 1 put: self pop! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 12/26/2024 14:04:11' prior: 16837220!
                            pushLiteralVariable: value 
	"Simulate the action of bytecode that pushes the contents of the literal 
	variable whose index is the argument, index, on the top of the stack."

	self push: (self object: value instVarAt: ValueIndex)! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 12/24/2024 19:40:19' prior: 16837298!
                    send: selector super: superFlag numArgs: numArgs
	"Simulate the action of bytecodes that send a message with selector, 
	 selector. The argument, superFlag, tells whether the receiver of the 
	 message was specified with 'super' in the source method. The arguments 
	 of the message are found in the top numArgs locations on the stack and 
	 the receiver just below them."

	| thisReceiver arguments lookupClass |
	arguments := Array new: numArgs.
	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].
	thisReceiver := self pop.
	lookupClass := superFlag
					ifTrue: [self method methodClassAssociation value superclass]
					ifFalse: [self objectClass: thisReceiver].
	QuickStep == self ifTrue:
		[QuickStep := nil.
		^self quickSend: selector to: thisReceiver with: arguments lookupIn: lookupClass].
	^self send: selector to: thisReceiver with: arguments lookupIn: lookupClass! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/11/2020 17:31' prior: 16837323!
    storeIntoLiteralVariable: value 
	"Simulate the action of bytecode that stores the top of the stack into a 
	literal variable of my method. If the receiver is read-only
	 this will provoke a send of #attemptToAssign:withIndex:"

	| top result |
	top := self top.
	result := self simulatedObject: value instVarAt: ValueIndex put: top.
	^(self object: result eqeq: top)
		ifTrue: [self]
		ifFalse: [result]! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/11/2020 17:32' prior: 16837333!
          storeIntoReceiverVariable: offset 
	"Simulate the action of bytecode that stores the top of the stack into an 
	instance variable of my receiver. If the receiver is read-only
	 this will provoke a send of #attemptToAssign:withIndex:"

	| top result |
	top := self top.
	result := self simulatedObject: self receiver instVarAt: offset + 1 put: top.
	^(self object: result eqeq: top)
		ifTrue: [self]
		ifFalse: [result]! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 3/29/2017 12:48' prior: 16837355!
                            storeIntoTemporaryVariable: offset 
	"Simulate the action of bytecode that stores the top of the stack into one 
	of my temporary variables."

	self at: offset + 1 put: self top! !
!ContextPart methodsFor: 'controlling' stamp: 'jar 2/14/2023 22:06' prior: 16837746!
                      restart
	"Unwind thisContext to self and resume from beginning.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"

	^self resumeEvaluating: [self privRefresh]! !
!ContextPart methodsFor: 'controlling' stamp: 'ct 3/25/2022 18:36' prior: 16837930!
           send: selector to: rcvr with: arguments lookupIn: lookupClass
	"Simulate the action of sending a message with selector and arguments to rcvr. The argument, lookupClass, is the class in which to lookup the message. This is the receiver's class for normal messages, but for super messages it will be some specific class related to the source method."

	| meth |
	(meth := lookupClass lookupSelector: selector) ifNil:
		[selector == #doesNotUnderstand: ifTrue:
			[self error: 'Recursive message not understood!!' translated].
		^self send: #doesNotUnderstand:
				to: rcvr
				with: {(Message selector: selector arguments: arguments) lookupClass: lookupClass}
				lookupIn: lookupClass].
	
	^ self
		executeMethod: meth
		forSelector: selector
		withArgs: arguments
		receiver: rcvr! !
!ContextPart methodsFor: 'private' stamp: 'ct 3/3/2024 19:22' prior: 16838165!
 doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments
	"Simulate a primitive method whose index is primitiveIndex.  The simulated receiver and
	 arguments are given as arguments to this message. If successful, push result and return
	 resuming context, else ^ {errCode, PrimitiveFailToken}. Any primitive which provokes
	 execution needs to be intercepted and simulated to avoid execution running away."

	| value |
	"Test for unsimulatable side effects (that is, code that will be triggered in the image outside of the simulator range). This includes simulation guards, which are traditionally flagged using primitive 19 (a null primitive that doesn't do anything), as well as certain control primitives that might trigger code on other processes. If a side effect is detected, raise a warning to give the user/client a chance to cancel or virtualize the operation."
	"#(19 87) do: [:primitive | self systemNavigation browseAllSelect: [:m | m primitive = primitive]]"
	(primitiveIndex = 19 "simulationGuard" or: [primitiveIndex = 87 "primitiveResume"]) ifTrue:
		[[(SimulationSideEffectWarning forPrimitive: primitiveIndex)
			context: self method: meth receiver: receiver arguments: arguments;
			signalIfSkipped: [^ self]]
				ifCurtailed:
					[self push: receiver "Cheap fix of the context's internal state. Note that unwinding the receiver -- so that the next step would invoke the primitive again -- would be challenging due to to the variety of senders to this method."]].
	
	((primitiveIndex between: 201 and: 222)
	 and: [(self objectClass: receiver) includesBehavior: BlockClosure]) ifTrue:
		[(primitiveIndex = 206
		  or: [primitiveIndex = 208]) ifTrue:						"[Full]BlockClosure>>valueWithArguments:"
			[^receiver simulateValueWithArguments: arguments first caller: self].
		 ((primitiveIndex between: 201 and: 209)			 "[Full]BlockClosure>>value[:value:...]"
		  or: [primitiveIndex between: 221 and: 222]) ifTrue: "[Full]BlockClosure>>valueNoContextSwitch[:]"
			[^receiver simulateValueWithArguments: arguments caller: self]].

	primitiveIndex = 83 ifTrue: "afr 9/11/1998 19:50" "Object>>perform:[with:...]"
		[| selector |
		selector := arguments at: 1 ifAbsent:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: receiver with: arguments allButFirst].
	primitiveIndex = 84 ifTrue: "afr 9/11/1998 19:50 & eem 8/18/2009 17:04" "Object>>perform:withArguments:"
		[| selector args |
		arguments size = 2 ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		selector := arguments first.
		args := arguments second.
		args isArray ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: receiver with: args].
	primitiveIndex = 100 ifTrue: "eem 8/18/2009 16:57" "Object>>perform:withArguments:inSuperclass:"
		[| rcvr selector args superclass |
		arguments size
			caseOf: {
				[3] -> [
					rcvr := receiver.
					selector := arguments first.
					args := arguments second.
					superclass := arguments third].
				[4] -> ["mirror primitive"
					rcvr := arguments first.
					selector := arguments second.
					args := arguments third.
					superclass := arguments fourth] }
			otherwise: [^ self class primitiveFailTokenFor: #'bad number of arguments'].
		args isArray ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		((self objectClass: rcvr) includesBehavior: superclass) ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: rcvr with: args lookupIn: superclass].

	"Mutex>>primitiveEnterCriticalSection
	 Mutex>>primitiveTestAndSetOwnershipOfCriticalSection"
	(primitiveIndex = 186 or: [primitiveIndex = 187]) ifTrue:
		[| effective |
		 effective := Processor activeProcess effectiveProcess.
		 "active == effective"
		 value := primitiveIndex = 186
					ifTrue: [receiver primitiveEnterCriticalSectionOnBehalfOf: effective]
					ifFalse: [receiver primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effective].
		 ^(self isPrimFailToken: value)
			ifTrue: [value]
			ifFalse: [self push: value]].
	
	(primitiveIndex = 188 or: [primitiveIndex = 189]) ifTrue:
		[| n args methodArg thisReceiver |
		 primitiveIndex caseOf:
			{[188 "primitiveExecuteMethodArgsArray"] ->
				["Object>>withArgs:executeMethod:
				  CompiledMethod class>>receiver:withArguments:executeMethod:
				  VMMirror>>ifFail:object:with:executeMethod: et al"
				 ((n := arguments size) between: 2 and: 4) ifFalse:
					[^self class primitiveFailTokenFor: #'unsupported operation'].
				 ((self objectClass: (args := arguments at: n - 1)) == Array
				  and: [(self objectClass: (methodArg := arguments at: n)) includesBehavior: CompiledMethod]) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 thisReceiver := arguments at: n - 2 ifAbsent: [receiver]].
			 [189 "primitiveExecuteMethod"] ->
				["Object>>executeMethod:
				  Object>>with:...executeMethod:"
				 (arguments size > 0) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 ((self objectClass: (methodArg := arguments atLast: 1)) includesBehavior: CompiledMethod) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 args := arguments allButLast.
				 thisReceiver := receiver]}.
		 methodArg numArgs = args size ifFalse:
			[^self class primitiveFailTokenFor: #'bad number of arguments'].
		 methodArg primitive > 0 ifTrue:
			[methodArg isQuick ifTrue:
				[^self push: (methodArg valueWithReceiver: thisReceiver arguments: args)].
			 ^self doPrimitive: methodArg primitive method: methodArg receiver: thisReceiver args: args].
		 ^self
			activateMethod: methodArg
			withArgs: args
			receiver: thisReceiver].

	primitiveIndex = 118 ifTrue: "[receiver:]tryPrimitive:withArgs:; avoid recursing in the VM"
		[(arguments size = 3
		  and: [(self objectClass: arguments second) == SmallInteger
		  and: [(self objectClass: arguments last) == Array]]) ifTrue:
			[^self doPrimitive: arguments second method: meth receiver: arguments first args: arguments last].
		 (arguments size = 2
		 and: [(self objectClass: arguments first) == SmallInteger
		 and: [(self objectClass: arguments last) == Array]]) ifFalse:
			[^self class primitiveFailTokenFor: -3].
		 ^self doPrimitive: arguments first method: meth receiver: receiver args: arguments last].

	value := primitiveIndex = 120 "FFI method"
				ifTrue: [(meth literalAt: 1) tryInvokeWithArguments: arguments]
				ifFalse:
					[primitiveIndex = 117 "named primitives"
						ifTrue: [self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]
						ifFalse: "should use self receiver: receiver tryPrimitive: primitiveIndex withArgs: arguments but this is only in later VMs (and appears to be broken)"
							[receiver tryPrimitive: primitiveIndex withArgs: arguments]].

	^(self isPrimFailToken: value)
		ifTrue: [value]
		ifFalse: [self push: value]! !
!ContextPart methodsFor: 'private' stamp: 'eem 12/26/2024 14:03:04' prior: 16838330!
                isPrimFailToken: anObject
	^(self objectClass: anObject) == Array
	  and: [anObject size = 2
	  and: [anObject first == PrimitiveFailToken]]! !
!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 2/22/2019 16:26' prior: 16838911!
                     object: anObject instVarAt: anIndex
	"Primitive. Answer a fixed variable in an object. The numbering of the 
	 variables corresponds to the named instance variables. Fail if the index 
	 is not an Integer or is not the index of a fixed variable. Essential for the
	 debugger. See  Object documentation whatIsAPrimitive."

	<primitive: 173 error: ec>
	self primitiveFailed! !
!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 3/11/2020 18:06' prior: 16838928!
              object: anObject instVarAt: anIndex put: aValue 
	"Primitive. Store a value into a fixed variable in the argument anObject.
	 The numbering of the variables corresponds to the named instance
	 variables.  Fail if the index is not an Integer or is not the index of a
	 fixed variable, or if anObject is read-only.  Answer the value stored as
	 the result. Using this message violates the  principle that each object
	 has sovereign control over the storing of values into its instance variables.
	 Essential for the debugger. See Object documentation whatIsAPrimitive."

	<primitive: 174 error: ec>
	ec == #'no modification' ifTrue:
		[^self modificationForbiddenFor: anObject instVarAt: anIndex put: aValue].
	self primitiveFailed! !
!ContextPart class methodsFor: 'simulation' stamp: 'eem 12/26/2024 14:03:14' prior: 16839131!
    primitiveFailTokenFor: errorCode

	^{PrimitiveFailToken. errorCode}! !
!ContextPart class methodsFor: 'cached class state' stamp: 'eem 12/26/2024 14:02:45' prior: 16839244 overrides: 16885795!
                               releaseClassCachedState

	QuickStep := nil! !
!Debugger class methodsFor: 'instance creation' stamp: 'eem 12/24/2024 19:42:44' prior: 16844145!
                informExistingDebugger: aContext label: aString
	"Walking the context chain, we try to find out if we're in a debugger stepping situation.
	If we find the relevant contexts, we must rearrange them so they look just like they would
	if the methods were excuted outside of the debugger."
	| ctx quickStepMethod oldSender baseContext |
	ctx := thisContext.
	quickStepMethod := ContextPart compiledMethodAt: #quickSend:to:with:lookupIn:.
	[ctx sender == nil or: [ctx sender method == quickStepMethod]] whileFalse: [ctx := ctx sender].
	ctx sender ifNil: [^self].
	baseContext := ctx.
	"baseContext is now the context created by the #quickSend... method."
	oldSender := ctx := ctx sender home sender.
	"oldSender is the context which originally sent the #quickSend... method"
	[ctx == nil or: [ctx receiver isKindOf: self]] whileFalse: [ctx := ctx sender].
	ctx == nil ifTrue: [^self].
	"ctx is the context of the Debugger method #doStep"
	ctx receiver labelString: aString.
	baseContext swapSender: baseContext sender sender sender.	"remove intervening contexts"
	thisContext swapSender: oldSender.	"make myself return to debugger"
	^aContext! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'eem 12/27/2024 15:53:47' prior: 16955229!
                 explainTemp: string 
	"Is string the name of a temporary variable (method or block argument or temporary)?"

	| selectedClass methodNode tempNode |
	self codeProvider selectedMessageName ifNil: [^nil].	"not in a method"
	selectedClass := self codeProvider selectedClassOrMetaClass.
	methodNode := selectedClass parserClass new parse: self codeProvider selectedMessage class: selectedClass.
	tempNode := methodNode encoder tempNodes detect: [ :n | n name = string ] ifNone: [^nil].
	^(tempNode isArg
		ifTrue: [string, ' is an argument to this ']
		ifFalse: [string, ' is a temporary variable in this ']),
	   (tempNode isDeclaredAtMethodLevel
		ifTrue: ['method ']
		ifFalse: ['block '])! !

UndefinedObject removeSelector: #literalIndexOfBytecodeAt:in:!

ContextPart class removeSelector: #primitiveFailToken!

!methodRemoval: ContextPart class #primitiveFailToken stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
primitiveFailToken
	"A unique object to be returned when a primitive fails during simulation"
	PrimitiveFailToken ifNil: [ PrimitiveFailToken := Object new ].
	^ PrimitiveFailToken!

ContextPart class removeSelector: #valueIndex!

!methodRemoval: ContextPart class #valueIndex stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
valueIndex
	ValueIndex ifNil: [
		ValueIndex := 2.
		self assert: (Association instVarNameForIndex: ValueIndex) = 'value' ].
	^ ValueIndex!

ContextPart removeSelector: #quickSend:to:with:super:!

!methodRemoval: ContextPart #quickSend:to:with:super: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
quickSend: selector to: rcvr with: arguments super: superFlag
	"Send the given selector with arguments in an environment which closely resembles
	 the non-simulating environment, with an interjected unwind-protected block to catch
	 nonlocal returns.  Attention: don't get lost!!  This beautiful method is due to
	 Hans-Martin Mosner.  Eliot Miranda merely added the mirror primitive code."
	| oldSender contextToReturnTo result lookupClass |
	contextToReturnTo := self.
	lookupClass := superFlag
					ifTrue: [self method methodClassAssociation value superclass]
					ifFalse: [self objectClass: rcvr].
	[oldSender := thisContext sender swapSender: self.
	 result := self object: rcvr perform: selector withArguments: arguments inClass: lookupClass.
	 thisContext sender swapSender: oldSender] ifCurtailed:
		[contextToReturnTo := thisContext sender receiver.	"The block context returning nonlocally"
		contextToReturnTo pc: contextToReturnTo previousPc.	"skip to front of return bytecode causing this unwind"
		contextToReturnTo willReturnTopFromMethod ifTrue:
			"If it was a returnTop, push the value to be returned.
			Otherwise the value is implicit in the bytecode"
			[contextToReturnTo push: (thisContext sender tempAt: 1)].
		thisContext swapSender: thisContext home sender.	"Make this block return to the method's sender"
		contextToReturnTo].
	contextToReturnTo push: result.
	^contextToReturnTo!

Decompiler removeSelector: #printInstVarNamed:at:on:asPc:!

Decompiler removeSelector: #convertToDoLoop!

!methodRemoval: Decompiler #convertToDoLoop stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
convertToDoLoop
	"If statements contains the pattern
		var := startExpr.
		[var <= limit] whileTrue: [...statements... var := var + incConst]
	then replace this by
		startExpr to: limit by: incConst do: [:var | ...statements...]"
	| leaveOnStack initStmt toDoStmt limitStmt |
	leaveOnStack := false.
	(stack notEmpty
	 and: [
		(#(CaseFlag CascadeFlag) statePointsTo: stack last) not
			and: [ stack last isAssignmentNode]])
		ifTrue:
			[initStmt := stack last.
			 (toDoStmt := statements last toDoFromWhileWithInit: initStmt) ifNil:
				[^self].
			 stack removeLast.
			 statements removeLast; addLast: toDoStmt.
			 leaveOnStack := true]
		ifFalse:
			[statements size < 2 ifTrue:
				[^self].
			initStmt := statements at: statements size-1.
			(toDoStmt := statements last toDoFromWhileWithInit: initStmt) ifNil:
				[^self].
			statements removeLast; removeLast; addLast: toDoStmt].
	initStmt variable scope: -1.  "Flag arg as block temp"

	"Attempt further conversion of the pattern
		limitVar := limitExpr.
		startExpr to: limitVar by: incConst do: [:var | ...statements...]
	to
		startExpr to: limitExpr by: incConst do: [:var | ...statements...].
	The complication here is that limitVar := limitExpr's value may be used, in which case it'll
	be statements last, or may not be used, in which case it'll be statements nextToLast."
	statements size < 2 ifTrue:
		[leaveOnStack ifTrue:
			[stack addLast: statements removeLast].
			 ^self].
	limitStmt := statements last.
	((limitStmt isMemberOf: AssignmentNode)
		and: [limitStmt variable isTemp
		and: [limitStmt variable == toDoStmt arguments first]]) ifFalse:
			[limitStmt := statements at: statements size-1.
			((limitStmt isMemberOf: AssignmentNode)
				and: [limitStmt variable isTemp
				and: [limitStmt variable == toDoStmt arguments first]]) ifFalse:
					[leaveOnStack ifTrue:
						[stack addLast: statements removeLast].
					^self]].

	(self blockScopeRefersOnlyOnceToTemp: limitStmt variable fieldOffset) ifFalse:
		[^self].
	toDoStmt arguments at: 1 put: limitStmt value.
	limitStmt variable scope: -2.  "Flag limit var so it won't print"
	statements last == limitStmt
		ifTrue: [statements removeLast]
		ifFalse: [statements removeLast; removeLast; addLast: toDoStmt]!

Decompiler removeSelector: #withTempNames:!

!methodRemoval: Decompiler #withTempNames: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
withTempNames: tempNames "<Array|String>"
	"Optionally initialize the temp names to be used when decompiling.
	 For backward-copmpatibility, if tempNames is an Array it is a single
	 vector of temp names, probably for a blue-book-compiled method.
	 If tempNames is a string it is a schematic string that encodes the
	 layout of temp vars in the method and any closures/blocks within it.
	 Decoding encoded tempNames is done in decompile:in:method:using:
	 which has the method from which to derive blockStarts.
	 See e.g. BytecodeEncoder>>schematicTempNamesString for syntax."
	tempVars := tempNames!

Decompiler removeSelector: #methodRefersOnlyOnceToTemp:!

Decompiler removeSelector: #doClosureCopy:copiedValues:!

InstructionStream class removeSelector: #releaseClassCachedState!

!methodRemoval: InstructionStream class #releaseClassCachedState stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
releaseClassCachedState

	SpecialConstants := nil!

InstructionStream class removeSelector: #specialConstants!

!methodRemoval: InstructionStream class #specialConstants stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
specialConstants
	SpecialConstants ifNil: [ self initSpecialConstants ].
	^SpecialConstants!

InstructionStream class removeSelector: #initSpecialConstants!

!methodRemoval: InstructionStream class #initSpecialConstants stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
initSpecialConstants
	"Initialize an array of special constants returned by single-bytecode returns."

	SpecialConstants := 
		(Array with: true with: false with: nil)
			, (Array with: -1 with: 0 with: 1 with: 2)	
	"
	InstructionStream initSpecialConstants
	"
!

InstructionStream removeSelector: #interpretExtension:in:for:!

!methodRemoval: InstructionStream #interpretExtension:in:for: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
interpretExtension: offset in: method for: client
	| type offset2 byte2 byte3 byte4 |
	offset <= 6 ifTrue: 
		["Extended op codes 128-134"
		byte2 := method at: pc. pc := pc + 1.
		offset <= 2 ifTrue:
			["128-130:  extended pushes and pops"
			type := byte2 // 64.
			offset2 := byte2 \\ 64.
			offset = 0 ifTrue: 
				[type = 0 ifTrue: [^client pushReceiverVariable: offset2].
				type = 1 ifTrue: [^client pushTemporaryVariable: offset2].
				type = 2  ifTrue: [^client pushConstant: (method literalAt: offset2 + 1)].
				type = 3 ifTrue: [^client pushLiteralVariable: (method literalAt: offset2 + 1)]].
			offset = 1 ifTrue: 
				[type = 0 ifTrue: [^client storeIntoReceiverVariable: offset2].
				type = 1 ifTrue: [^client storeIntoTemporaryVariable: offset2].
				type = 2 ifTrue: [self error: 'illegalStore'].
				type = 3 ifTrue: [^client storeIntoLiteralVariable: (method literalAt: offset2 + 1)]].
			offset = 2 ifTrue: 
				[type = 0 ifTrue: [^client popIntoReceiverVariable: offset2].
				type = 1 ifTrue: [^client popIntoTemporaryVariable: offset2].
				type = 2 ifTrue: [self error: 'illegalStore'].
				type = 3  ifTrue: [^client popIntoLiteralVariable: (method literalAt: offset2 + 1)]]].
		"131-134: extended sends"
		offset = 3 ifTrue:  "Single extended send"
			[^client send: (method literalAt: byte2 \\ 32 + 1)
					super: false numArgs: byte2 // 32].
		offset = 4 ifTrue:    "Double extended do-anything"
			[byte3 := method at: pc. pc := pc + 1.
			type := byte2 // 32.
			type = 0 ifTrue: [^client send: (method literalAt: byte3 + 1)
									super: false numArgs: byte2 \\ 32].
			type = 1 ifTrue: [^client send: (method literalAt: byte3 + 1)
									super: true numArgs: byte2 \\ 32].
			type = 2 ifTrue: [^client pushReceiverVariable: byte3].
			type = 3 ifTrue: [^client pushConstant: (method literalAt: byte3 + 1)].
			type = 4 ifTrue: [^client pushLiteralVariable: (method literalAt: byte3 + 1)].
			type = 5 ifTrue: [^client storeIntoReceiverVariable: byte3].
			type = 6 ifTrue: [^client popIntoReceiverVariable: byte3].
			type = 7 ifTrue: [^client storeIntoLiteralVariable: (method literalAt: byte3 + 1)]].
		offset = 5 ifTrue:  "Single extended send to super"
			[^client send: (method literalAt: byte2 \\ 32 + 1)
					super: true numArgs: byte2 // 32].
		offset = 6 ifTrue:   "Second extended send"
			[^client send: (method literalAt: byte2 \\ 64 + 1)
					super: false numArgs: byte2 // 64]].
	offset = 7 ifTrue: [^client doPop].
	offset = 8 ifTrue: [^client doDup].
	offset = 9 ifTrue: [^client pushActiveContext].
	byte2 := method at: pc. pc := pc + 1.
	offset = 10 ifTrue:
		[^byte2 < 128
			ifTrue: [client pushNewArrayOfSize: byte2]
			ifFalse: [client pushConsArrayWithElements: byte2 - 128]].
	offset = 11 ifTrue: [^self error: 'unusedBytecode'].
	byte3 := method at: pc.  pc := pc + 1.
	offset = 12 ifTrue: [^client pushRemoteTemp: byte2 inVectorAt: byte3].
	offset = 13 ifTrue: [^client storeIntoRemoteTemp: byte2 inVectorAt: byte3].
	offset = 14 ifTrue: [^client popIntoRemoteTemp: byte2 inVectorAt: byte3].
	"offset = 15"
	byte4 := method at: pc.  pc := pc + 1.
	^client
		pushClosureCopyNumCopiedValues: (byte2 bitShift: -4)
		numArgs: (byte2 bitAnd: 16rF)
		blockSize: (byte3 * 256) + byte4!

InstructionStream removeSelector: #scanForInstructionSequence:!

InstructionStream removeSelector: #blockMethodOrNil!

InstructionPrinter removeSelector: #pushFullClosure:numCopied:receiverOnStack:ignoreOuterContext:!

InstructionPrinter removeSelector: #pushFullClosure:numCopied:!

NarrowerVariableScopeFinder removeSelector: #visitVariableUsageNode:!

MessageNode class removeSelector: #releaseClassCachedState!

!methodRemoval: MessageNode class #releaseClassCachedState stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
releaseClassCachedState

	MacroSelectors := nil.
	MacroTransformers := nil.
	MacroEmitters := nil.
	MacroSizers := nil.
	MacroPrinters := nil!

MessageNode class removeSelector: #new!

!methodRemoval: MessageNode class #new stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
new
	MacroSelectors ifNil: [ self initClassCachedState ].
	^super new!

MessageNode class removeSelector: #initClassCachedState!

!methodRemoval: MessageNode class #initClassCachedState stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
initClassCachedState
	"
	MessageNode initialize
	"
	MacroSelectors := 
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:
			repeat ).
	MacroTransformers := 
		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:
			transformAnd: transformOr:
			transformWhile: transformWhile: transformWhile: transformWhile:
			transformToDo: transformToDo:
			transformCase: transformCase:
			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:
			transformRepeat: ).
	MacroEmitters := 
		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:
			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:
			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForRepeat:encoder:value:).
	MacroSizers := 
		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:
			sizeCodeForToDo:value: sizeCodeForToDo:value:
			sizeCodeForCase:value: sizeCodeForCase:value:
			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForRepeat:value:).
	MacroPrinters := 
		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:
			printIfOn:indent: printIfOn:indent:
			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:
			printToDoOn:indent: printToDoOn:indent:
			printCaseOn:indent: printCaseOn:indent:
			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:
			printRepeatOn:indent:).
	Preferences
		name: #allowNonBooleanReceiversOfBooleanMessages
		description: 'If set, do not optimize boolean selectors, allowing, for example, new Boolean classes.'
		category: #programming type: Boolean value: false!

RemoteTempVectorNode removeSelector: #emitCodeForIndexOf:stack:encoder:!

!methodRemoval: RemoteTempVectorNode #emitCodeForIndexOf:stack:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
emitCodeForIndexOf: aTempVariableNode stack: stack encoder: encoder
	self assert: encoder supportsClosureOpcodes not.
	(encoder encodeLiteral: (remoteTemps indexOf: aTempVariableNode))
		emitCodeForValue: stack encoder: encoder!

RemoteTempVectorNode removeSelector: #sizeCodeForIndexOf:encoder:!

!methodRemoval: RemoteTempVectorNode #sizeCodeForIndexOf:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
sizeCodeForIndexOf: aTempVariableNode encoder: encoder
	self assert: encoder supportsClosureOpcodes not.
	^(encoder encodeLiteral: (remoteTemps indexOf: aTempVariableNode)) sizeCodeForValue: encoder!

RemoteTempVectorNode removeSelector: #sizeCodeForLoadFor:encoder:!

!methodRemoval: RemoteTempVectorNode #sizeCodeForLoadFor:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
sizeCodeForLoadFor: aTempVariableNode encoder: encoder
	encoder supportsClosureOpcodes ifTrue:
		[^0].
	"Need to size the first half of
		tempVector at: index put: expr
	 i.e. the push of tempVector and index."
	^(super sizeCodeForValue: encoder)
	+ (self sizeCodeForIndexOf: aTempVariableNode encoder: encoder)!

RemoteTempVectorNode removeSelector: #emitCodeForLoadFor:stack:encoder:!

!methodRemoval: RemoteTempVectorNode #emitCodeForLoadFor:stack:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
emitCodeForLoadFor: aTempVariableNode stack: stack encoder: encoder
	encoder supportsClosureOpcodes ifTrue:
		[^self].
	"Need to generate the first half of
		tempVector at: index put: expr
	 i.e. the push of tempVector and index."
	super emitCodeForValue: stack encoder: encoder.
	self emitCodeForIndexOf: aTempVariableNode stack: stack encoder: encoder!

TempVariableNode removeSelector: #emitCodeForLoad:forValue:encoder:!

!methodRemoval: TempVariableNode #emitCodeForLoad:forValue:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
emitCodeForLoad: stack forValue: forValue encoder: encoder
	remoteNode ~~ nil ifTrue:
		[remoteNode emitCodeForLoadFor: self stack: stack encoder: encoder]!

TempVariableNode removeSelector: #sizeCodeForLoad:forValue:!

!methodRemoval: TempVariableNode #sizeCodeForLoad:forValue: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
sizeCodeForLoad: encoder forValue: forValue
	^remoteNode
		ifNil: [0]
		ifNotNil: [remoteNode sizeCodeForLoadFor: self encoder: encoder]!

VariableNode removeSelector: #emitCodeForLoad:forValue:encoder:!

!methodRemoval: VariableNode #emitCodeForLoad:forValue:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
emitCodeForLoad: stack forValue: forValue encoder: encoder
	"Do nothing"!

MethodNode removeSelector: #preenIfNotNilNode:!

MethodNode removeSelector: #preenNilNodeFollowingNilIfNode:!

MethodNode removeSelector: #preenTempsConflictingWithBlockNode:!

MethodNode removeSelector: #preenLocalIfNotNilArg!

!methodRemoval: MethodNode #preenLocalIfNotNilArg stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
preenLocalIfNotNilArg
	"Try and spot a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block
	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where
	 the block already declares the variable and the decompile case where it does not."

	| varsToHide |
	varsToHide := Set new.
	self nodesDo:
		[:node| | variable |
		(node isMessageNode
		and: [node macroPrinter == #printIfNilNotNil:indent:
		and: [node receiver isMessageNode
		and: [node receiver selector key == #==
		and: [node receiver receiver isAssignmentNode
		and: [(variable := node receiver receiver variable) isTemp
		and: [variable isRemote not
		and: [variable isOnlySubnodeOf: node in: self]]]]]]]) ifTrue:
			[node arguments last arguments isEmpty
				ifTrue: [node arguments last arguments: { variable }.
						varsToHide add: variable]
				ifFalse: [self assert: node arguments last arguments asArray =  { variable }].
			 node receiver receiver: node receiver receiver value]].
	varsToHide notEmpty ifTrue:
		[self nodesDo:
			[:node|
			((node == self or: [node isBlockNode])
			and: [node temporaries anySatisfy: [:temp| varsToHide includes: temp]]) ifTrue:
				[node temporaries: (node temporaries reject: [:temp| varsToHide includes: temp])]]]!

BlockNode removeSelector: #sizeCodeForClosureValue:!

!methodRemoval: BlockNode #sizeCodeForClosureValue: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
sizeCodeForClosureValue: encoder
	"Compute the size for the creation of the block and its code."
	"If we have the closure bytecodes constructClosureCreationNode: will note
	 the copied values in the copiedValues inst var and answer #pushCopiedValues."
	closureCreationNode := self constructClosureCreationNode: encoder.
	"Remember size of body for emit time so we know the size of the jump around it."
	size := self sizeCodeForEvaluatedClosureValue: encoder.
	^encoder supportsClosureOpcodes
		ifTrue:
			[(copiedValues inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])
			 + (encoder sizePushClosureCopyNumCopiedValues: copiedValues size numArgs: arguments size jumpSize: size)
			 + size]
		ifFalse:
			["closureCreationSupportNode is send closureCopy:copiedValues:"
			(closureCreationNode sizeCodeForValue: encoder)
			 + (encoder sizeJumpLong: size)
			 + size]!

BlockNode removeSelector: #emitCodeForClosureValue:encoder:!

!methodRemoval: BlockNode #emitCodeForClosureValue:encoder: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
emitCodeForClosureValue: stack encoder: encoder
	"if not supportsClosureOpcodes closureCreationSupportNode is the
	 node for thisContext closureCopy: numArgs [ copiedValues: { values } ]"
	encoder supportsClosureOpcodes
		ifTrue:
			[copiedValues do:
				[:copiedValue| copiedValue emitCodeForValue: stack encoder: encoder].
			 closureCreationNode pc: encoder methodStreamPosition + 1.
			 encoder
				genPushClosureCopyNumCopiedValues: copiedValues size
				numArgs: arguments size
				jumpSize: size.
			 stack
				pop: copiedValues size;
				push: 1]
		ifFalse:
			[closureCreationNode emitCodeForValue: stack encoder: encoder.
			 encoder genJumpLong: size]. "Force a two byte jump."
	"Emit the body of the block"
	self emitCodeForEvaluatedClosureValue: stack encoder: encoder!

BlockNode removeSelector: #ensureClosureCreationNode!

EncoderForV3PlusClosures class removeSelectorIfInBaseSystem: #literalIndexOfBytecodeAt:in:!

EncoderForV3PlusClosures removeSelector: #if:isSpecialLiteralForPush:!

EncoderForV3PlusClosures removeSelector: #if:isSpecialLiteralForReturn:!

EncoderForV3PlusClosures removeSelector: #isSpecialLiteralForReturn:!

EncoderForV3PlusClosures removeSelector: #genPushNClosureTemps:!

!methodRemoval: EncoderForV3PlusClosures #genPushNClosureTemps: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
genPushNClosureTemps: numTemps
	numTemps timesRepeat: [self genPushSpecialLiteral: nil]!

EncoderForV3PlusClosures removeSelector: #supportsClosureOpcodes!

!methodRemoval: EncoderForV3PlusClosures #supportsClosureOpcodes stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
supportsClosureOpcodes
	^true!

EncoderForSistaV1 class removeSelector: #supportsClosures!

EncoderForSistaV1 class removeSelector: #method:refersInBytecodeToLiteral:specialSelectorIndex:!

EncoderForSistaV1 class removeSelector: #isBranchAt:in:!

EncoderForSistaV1 class removeSelector: #nopCode!

EncoderForSistaV1 class removeSelector: #blockMethodOrNilFor:in:at:!

EncoderForSistaV1 class removeSelector: #isRealSendAt:in:!

EncoderForSistaV1 class removeSelectorIfInBaseSystem: #literalIndexOfBytecodeAt:in:!

EncoderForSistaV1 removeSelector: #isSpecialLiteralForReturn:!

BytecodeEncoder removeSelector: #supportsClosureOpcodes!

!methodRemoval: BytecodeEncoder #supportsClosureOpcodes stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
supportsClosureOpcodes
	"Answer if the receiver supports the
		genPushNewArray:/genPushConsArray:
		genPushRemoteTemp:inVectorAt:
		genStoreRemoteTemp:inVectorAt:
		genStorePopRemoteTemp:inVectorAt:
		genPushClosureCopyCopiedValues:numArgs:jumpSize:
	 opcodes"
	^false!

BytecodeEncoder removeSelectorIfInBaseSystem: #litIndexOrNilFor:!

Encoder removeSelector: #initForCuisWithClass:literalStream:!

Encoder removeSelectorIfInBaseSystem: #initPreFullBlocksClass:literalStream:!

Encoder removeSelectorIfInBaseSystem: #initClass:literalStream:!

ParseNode class removeSelector: #releaseClassCachedState!

!methodRemoval: ParseNode class #releaseClassCachedState stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
releaseClassCachedState

	LdInstType := LdTempType := LdLitType := LdLitIndType := SendType := nil.
	CodeBases := CodeLimits := nil.
	LdSelf := LdTrue := LdFalse := nil.
	LdNil := LdMinus1 := LoadLong := nil.
	LdSuper := Pop := nil.
	LdThisContext := EndRemote := nil.
	SendPlus := Send := nil!

ParseNode class removeSelector: #new!

!methodRemoval: ParseNode class #new stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
new
	LdInstType ifNil: [
		ParseNode initClassCachedState.
		VariableNode initClassCachedState ].
	^super new!

ParseNode class removeSelector: #initClassCachedState!

!methodRemoval: ParseNode class #initClassCachedState stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
initClassCachedState
	"
	ParseNode initialize. VariableNode initialize
	"
	LdInstType := 1.
	LdTempType := 2.
	LdLitType := 3.
	LdLitIndType := 4.
	SendType := 5.
	"Back in the day the following constants corresponded to bytecodes.
	 Now they're just unique values that need to be eliminated when and if
	 things like code:type: are cleaned up."
	CodeBases := #(0 16 32 64 208 ).
	CodeLimits := #(16 16 32 32 16 ).
	LdSelf := 112.
	LdTrue := 113.
	LdFalse := 114.
	LdNil := 115.
	LdMinus1 := 116.
	LoadLong := 128.
	LdSuper := 133.
	Pop := 135.
	LdThisContext := 137.
	EndRemote := 125.
	SendPlus := 176.
	Send := 208.
	
	"((ParseNode class >> #initialize) literals select: [:l| l isVariableBinding and: [(ParseNode classPool includesAssociation: l) and: [(self systemNavigation allCallsOn: l localTo: ParseNode) size = 1]]]) sort: [:a :b| a key <= b key]"

	"ParseNode classPool associations select: [:a| (self systemNavigation allCallsOn: a localTo: ParseNode) isEmpty]"!

ParseNode removeSelector: #isOnlySubnodeOf:in:!

!methodRemoval: ParseNode #isOnlySubnodeOf:in: stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
isOnlySubnodeOf: aSubtree "<ParseNode>" in: aParseTree "<ParseNode>"
	"Answer if the receiver only occurs within aSubtree of aParseTree, not in the rest of aParseTree.
	 Assumes that aSubtree is in fact a subnode of aParseTree."
	| isSubnode |
	isSubnode := false.
	aSubtree accept: (ParseNodeEnumerator
							ofBlock: [:node| node == self ifTrue: [isSubnode := true]]).
	isSubnode ifFalse:
		[^false].
	aParseTree accept: (ParseNodeEnumerator
							ofBlock: [:node| node == self ifTrue: [^false]]
							select: [:node| node ~= aSubtree]).
	^true!

WriteStream removeSelectorIfInBaseSystem: #crtab!

ByteArray variableByteSubclass: #CompiledMethod
	instanceVariableNames: ''
	classVariableNames: 'LargeFrame PreferredBytecodeSetEncoderClass PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame'
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!classDefinition: #CompiledMethod category: #'Kernel-Methods' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
ByteArray variableByteSubclass: #CompiledMethod
	instanceVariableNames: ''
	classVariableNames: 'LargeFrame PreferredBytecodeSetEncoderClass PrimaryBytecodeSetEncoderClass SecondaryBytecodeSetEncoderClass SmallFrame'
	poolDictionaries: ''
	category: 'Kernel-Methods'!

InstructionStream subclass: #Decompiler
	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps blockStartsToTempVars tempVarCount lastJumpIfPcStack tempReadCounts'
	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag OtherwiseFlag'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

!classDefinition: #Decompiler category: #'Compiler-Kernel' stamp: 'Install-6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st 1/23/2025 11:11:12'!
InstructionStream subclass: #Decompiler
	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps blockStartsToTempVars tempVarCount lastJumpIfPcStack tempReadCounts'
	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag OtherwiseFlag'
	poolDictionaries: ''
	category: 'Compiler-Kernel'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6997-SistaV1BytecodeSet-EliotEmilioMiranda-2025Jan21-15h32m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #6996] on 22 January 2025 at 8:26:14 am'!
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:25:53'!
      browseEqEqSentToNumericConstants
	"
	Smalltalk browseEqEqSentToNumericConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#== #~~ ) identityIncludes: node selector key) and: [
					node receiver isLiteralNumber or: [ node arguments first isLiteralNumber ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:26:02'!
                              browseEqSentToCharacterConstants
	"
	Smalltalk browseEqSentToCharacterConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#= #~= ) identityIncludes: node selector key) and: [
					node receiver isLiteralCharacter or: [ node arguments first isLiteralCharacter ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:26:06'!
                         browseEqSentToNumericConstants
	"
	Smalltalk browseEqSentToNumericConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#= #~= ) identityIncludes: node selector key) and: [
					node receiver isLiteralNumber or: [ node arguments first isLiteralNumber ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:26:10'!
   browseEqSentToSmallIntegerConstants
	"
	Smalltalk browseEqSentToSmallIntegerConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#= #~= ) identityIncludes: node selector key) and: [
					node receiver isLiteralSmallInteger or: [ node arguments first isLiteralSmallInteger ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!ParseNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:16:27'!
                     isLiteralCharacter  "Overridden in LiteralNode"
	^false! !
!ParseNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:17:12'!
   isLiteralNumber  "Overridden in LiteralNode"
	^false! !
!ParseNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:21:06'!
      isLiteralSmallInteger  "Overridden in LiteralNode"
	^false! !
!LiteralNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:16:30' overrides: 50350699!
          isLiteralCharacter
	^ key isCharacter! !
!LiteralNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:17:15' overrides: 50350703!
                               isLiteralNumber
	^ key isNumber! !
!LiteralNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:22:59' overrides: 50350707!
     isLiteralSmallInteger
	^ key isNumber and: [ key class == SmallInteger ]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:25:49' prior: 16969133!
                          browseEqEqSentToCharacterConstants
	"
	Smalltalk browseEqEqSentToCharacterConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#== #~~ ) identityIncludes: node selector key) and: [
					node receiver isLiteralCharacter or: [ node arguments first isLiteralCharacter ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 1/22/2025 08:25:58' prior: 16969153!
    browseEqEqSentToSmallIntegerConstants
	"
	Smalltalk browseEqEqSentToSmallIntegerConstants
	"
	| hasMatch visitor |
	hasMatch := false.
	visitor := ParseNodeEnumerator
		ofBlock: [ :node |
			(node isMessageNode and: [
				(#(#== #~~ ) identityIncludes: node selector key) and: [
					node receiver isLiteralSmallInteger or: [ node arguments first isLiteralSmallInteger ]]]) ifTrue: [
						hasMatch := true ]]
		select: [ :node |
			hasMatch not ].
	self browseAllSelect: [ :method |
		hasMatch := false.
		method decompile accept: visitor.
		hasMatch ].! !
!ParseNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:16:50' prior: 16920062!
isConstantCharacter
	"Compatibility"

	^self isLiteralCharacter! !
!ParseNode methodsFor: 'testing' stamp: 'jmv 1/22/2025 08:17:32' prior: 16920067!
           isConstantNumber
	"Compatibility"

	^self isLiteralNumber! !

LiteralNode removeSelector: #isConstantCharacter!

!methodRemoval: LiteralNode #isConstantCharacter stamp: 'Install-6998-BrowseEqualityWithLiterals-JuanVuletich-2025Jan22-08h10m-jmv.001.cs.st 1/23/2025 11:11:12'!
isConstantCharacter
	^ key isCharacter!

LiteralNode removeSelector: #isConstantNumber!

!methodRemoval: LiteralNode #isConstantNumber stamp: 'Install-6998-BrowseEqualityWithLiterals-JuanVuletich-2025Jan22-08h10m-jmv.001.cs.st 1/23/2025 11:11:12'!
isConstantNumber
	^ key isNumber!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6998-BrowseEqualityWithLiterals-JuanVuletich-2025Jan22-08h10m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6996] on 22 January 2025 at 8:32:52 am'!
!MethodSet methodsFor: 'message functions' stamp: 'jmv 1/22/2025 08:31:36'!
                     fileOutAllMethods
	"Put a description of the selected message on a file"

	DirectoryEntry fileOutsDirQuery: 'methods.st' writeStreamDo: [ :fileStream |
		fileStream timeStamp.
		self messageList do: [ :methodRef |
			methodRef actualClass
				printMethodChunk: methodRef methodSymbol
				withPreamble: true
				on: fileStream
				moveSource: false
				toFile: 0 ]].! !
!MethodSetWindow methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 1/22/2025 08:29:35' prior: 16903426!
          messageListMenuSpec
	"Spec for the menu and shortcut keys for the messages list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Message Set' 				false)
		#(10	'Browse Full (b)' 				$b 	window browseMethodFull 						editFindReplaceIcon)
		#(20	'Browse Hierarchy (h)' 		$h 	window browseHierarchy 							goTopIcon)
		#(30	'Browse Method (O)' 			$O 	window openSingleMessageBrowser 				scriptIcon)
		#(40	'Browse Protocol (p)' 			$p 	window browseFullProtocol 						spreadsheetIcon)
		#(45	'Browse Package' 			nil 	window browsePackage 							packageIcon)
		#(50 	'-----')
		#(60	'File Out' 					nil 	model 	fileOutMessage 							fileOutIcon)
		#(61	'File Out All' 					nil 	model 	fileOutAllMethods 							fileOutIcon)
		#(70	'Run Test (t)' 				$t 	model 	runMethodTest 							weatherFewCloudsIcon)
		#(80	'Debug Test (r)' 				$r 	model 	debugMethodTest 							weatherFewCloudsIcon)
		#(90	'Inspect CompiledMethod' 	nil 	model 	inspectCompiledMethod 					exploreIcon)
		#(100 	'-----')
		#(110	'Senders of... (n)' 			nil 	window browseSendersOfMessages 				mailForwardIcon)
		#(120	'Local Senders of...' 			nil 	window browseLocalSendersOfMessages 			mailForwardIcon)
		#(130	'Implementors of... (m)' 		nil 	window browseImplementorsOfMessages 			developmentIcon)
		#(140	'Local Implementors of...' 		nil 	window browseLocalImplementorsOfMessages 	developmentIcon)
		#(150	'Inheritance (i)' 				$i 	window methodInheritance 						goDownIcon)
		#(160	'Versions (v)' 				$v 	window browseVersions 							clockIcon)
		#(170 	'-----')
		#(180	'Remove Method (x)' 			$x 	model 	removeMessage 							deleteIcon)
		#(190	'more' 						nil 	nil 		2000 										listAddIcon)

		"Shortcut only. No menu entry."
		#(991	nil 							$m 	window browseImplementors)
		#(992	nil 							$n 	window browseSenders)
		#(993	nil 							$c 	model 	copySelector)
		#(994	nil 							$N 	window browseClassRefs)

		" 'more' SubMenu"
		#(2010	'Sample instance' 			nil 	window makeSampleInstance 						instanceIcon)
		#(2020	'Inspect instances' 			nil 	window inspectInstances 							inspectIcon)
		#(2030	'Inspect subinstances' 		nil 	window inspectSubInstances 						inspectIcon)
		#(2040 	'-----')
		#(2050 	'Remove from this Browser' 	nil 	model 	removeMessageFromBrowser 				listRemoveIcon)
		#(2060 	'Filter message list...' 			nil 	window filterMessageList 							findIcon)
		#(2070	'Change category...' 			nil 	model 	changeCategory 							saveAsIcon)
		#(2080	'Change sets with this Method' nil 	window findMethodInChangeSets 					changesIcon)
		#(2090	'Revert to previous Version' 	nil 	model 	revertToPreviousVersion 					undoIcon)
		#(2100 	'-----')
		#(2110 	'Sort by class Hierarchy' 		nil 	model 	sortByClassHierarchy 						classIcon)
		#(2120 	'Sort by class Name' 			nil 	model 	sortByClassName 							classIcon)
		#(2130 	'Sort by Selector' 				nil 	model 	sortBySelector 								scriptIcon)
		#(2140 	'Sort by Date' 				nil 	model 	sortByDate 								dateIcon)
		#(2150 	'Reverse sort' 				nil 	model 	sortReverse 								redoIcon)
	).
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\6999-MethodSet-fileOutAll-JuanVuletich-2025Jan22-08h26m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6996] on 22 January 2025 at 8:37:48 am'!
!CompiledMethod methodsFor: 'debugger support' stamp: 'jmv 11/30/2014 11:37' prior: 16834361!
                             mapFromBlockKeys: keys toSchematicTemps: schematicTempNamesString
	"Decode a schematicTempNamesString that encodes the layout of temp names
	 in a method and any closures/blocks within it, matching keys in keys to
	 vectors of temp names."
	| map tempNames |
	map := Dictionary new.
	tempNames := schematicTempNamesString readStream.
	keys do:
		[:key| | tempSequence tempIndex |
		tempSequence := OrderedCollection new.
		tempIndex := 0.
		[(tempNames skipSeparators; peek) ifNil: [true] ifNotNil: [:ch| '[]' includes: ch]] whileFalse:
			[tempNames peek == $(
				ifTrue: [tempSequence addAll: ((self tempsSubSequenceFrom: (tempNames next; yourself)) withIndexCollect:
														[:temp :index|
														{ temp. { tempIndex + 1. index } }]).
						tempNames peek ~~ $) ifTrue: [self error: 'parse error'].
						tempIndex := tempIndex + 1.
						tempNames next]
				ifFalse: [tempSequence addAll: ((self tempsSubSequenceFrom: tempNames) withIndexCollect:
														[:temp :index|
														{ temp. tempIndex := tempIndex + 1 }])]].
		map at: key put: tempSequence asArray.
		[tempNames peek == $]] whileTrue: [tempNames next].
		tempNames peek == $[ ifTrue:
			[tempNames next]].
	^map! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 7/21/2023 16:59:57' prior: 16958199!
          trimParentesisOn: aSourceCode
			
	| parentesis |
	
	parentesis := 1.
	start+1 to: stop-1 do: [ :index | | char |
		char := aSourceCode at: index.
		char == $( 
			ifTrue: [ parentesis := parentesis + 1]
			ifFalse: [ char == $) 
				ifTrue: [ 
					parentesis = 1 ifTrue: [ ^self ].
					parentesis := parentesis - 1]]].
		
	^(self trimLeft: 1 right: 1) trimToMatchExpressionOn: aSourceCode ! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 7/21/2023 16:53:59' prior: 16958214!
                     trimToMatchExpressionOn: aSourceCode

	| initialChar endingChar |
	
	initialChar := aSourceCode at: start ifAbsent: [ nil ].
	endingChar := aSourceCode at: stop ifAbsent: [ nil ].
	
	^(initialChar == $( and: [ endingChar == $) ])
		ifTrue: [ self trimParentesisOn: aSourceCode ]
		ifFalse: [ self trimNoParentesisStartingWith: initialChar endingWith: endingChar on: aSourceCode]! !
!SourceCodeInterval methodsFor: 'private - source code' stamp: 'RNG 5/9/2020 15:39:55' prior: 16958235!
                          canBeExpandedStartingWith: firstChar endingWith: lastChar

	^ (firstChar == $( and: [ lastChar == $) ]) or: [ firstChar == $` and: [ lastChar == $` ] ]! !
!SourceCodeInterval methodsFor: 'private - source code' stamp: 'RNG 5/8/2020 21:30:59' prior: 16958243!
                             canBeTrimmed: initialChar

	^ initialChar notNil and: [ initialChar isSeparator or: [ initialChar == $. ] ]! !
!SourceCodeInterval methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:31:22' prior: 16958262!
                      endsOnDotOn: aSourceCode

	^(self lastCharacterOfRangeOn: aSourceCode) == $.! !
!SourceCodeInterval methodsFor: 'testing' stamp: 'HAW 6/11/2022 19:31:07' prior: 16958284!
                     isEndOfTemporariesDeclarationOn: aSourceCode

	^((self lastCharacterOfRangeOn: aSourceCode) == $|) and: [^(aSourceCode indexOf: $|) < self last]! !
!CharacterSequence methodsFor: 'comparing' stamp: 'ul 11/14/2010 06:02' prior: 16813068!
                   startingAt: keyStart match: text startingAt: textStart
	"Answer whether text matches the pattern in this string.
	Matching ignores upper/lower case differences.
	Where this string contains #, text may contain any character.
	Where this string contains *, text may contain any sequence of characters."
	| anyMatch matchStart matchEnd i matchStr j ii jj |
	i := keyStart.
	j := textStart.

	"Check for any #'s"
	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].
	(self at: i) == $#] whileTrue:
		["# consumes one char of key and one char of text"
		j > text size ifTrue: [^ false "no more text"].
		i := i+1.  j := j+1].

	"Then check for *"
	(self at: i) == $*
		ifTrue: [i = self size ifTrue:
					[^ true "Terminal * matches all"].
				"* means next match string can occur anywhere"
				anyMatch := true.
				matchStart := i + 1]
		ifFalse: ["Otherwise match string must occur immediately"
				anyMatch := false.
				matchStart := i].

	"Now determine the match string"
	matchEnd := self size.
	(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue:
		[ii = matchStart ifTrue: [self error: '** not valid -- use * instead'].
		matchEnd := ii-1].
	(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue:
		[ii = matchStart ifTrue: [self error: '*# not valid -- use #* instead'].
		matchEnd := matchEnd min: ii-1].
	matchStr := self copyFrom: matchStart to: matchEnd.

	"Now look for the match string"
	[jj := text findString: matchStr startingAt: j caseSensitive: false.
	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]
		whileTrue:
		["Found matchStr at jj.  See if the rest matches..."
		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:
			[^ true "the rest matches -- success"].
		"The rest did not match."
		anyMatch ifFalse: [^ false].
		"Preceded by * -- try for a later match"
		j := j+1].
	^ false "Failed to find the match string"! !
!CharacterSequence methodsFor: 'converting' stamp: 'ls 10/28/2003 12:24' prior: 16813245!
                asSmalltalkComment
	"return this string, munged so that it can be treated as a comment in Smalltalk code.  Quote marks are added to the beginning and end of the string, and whenever a solitary quote mark appears within the string, it is doubled"

	^self species streamContents:  [ :str |
		| quoteCount first |

		str nextPut: $".
	
		quoteCount := 0.
		first := true.
		self do: [ :char |
			char == $"
				ifTrue: [
					first ifFalse: [
						str nextPut: char.
						quoteCount := quoteCount + 1 ] ]
				ifFalse: [
					quoteCount odd ifTrue: [
						"add a quote to even the number of quotes in a row"
						str nextPut: $" ].
					quoteCount := 0.
					str nextPut: char ].
			first := false ]. 

		quoteCount odd ifTrue: [
			"check at the end"
			str nextPut: $". ].

		str nextPut: $".
	].
	! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:50:36' prior: 50336452!
                              asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in |
	in := self readStream.
	^self species streamContents: [ :out |
		[ in atEnd ] whileFalse: [
			in peek == $<
				ifTrue: [in unCommand] 	"Absorb <...><...>"
				ifFalse: [
					| char |
					(char := in next) == $&
					ifTrue: [
						| rest did |
						rest := in upTo: $;.
						did := out position.
						rest = 'lt' ifTrue: [out nextPut: $<].
						rest = 'gt' ifTrue: [out nextPut: $>].
						rest = 'amp' ifTrue: [out nextPut: $&].
						rest = 'deg' ifTrue: [out nextPut: $¡].
						rest = 'quot' ifTrue: [out nextPut: $"].
						rest first == $# ifTrue: [ out nextPut: (Character codePoint: rest findPositiveInteger) ].
						did = out position ifTrue: [
							out nextPut: $&; nextPutAll: rest.
							"self error: 'unknown encoded HTML char'."
							"Please add it to this method"]]
					ifFalse: [out nextPut: char]].
			]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:11' prior: 50336487!
 keywords
	"Answer an array of the keywords that compose the receiver."
	| keywords |
	keywords := Array streamContents: [ :kwds |
		| kwd isAllValidInIdentifiers |
		kwd := self species writeStream.
		isAllValidInIdentifiers := true.
		1
			to: self size
			do: [ :i |
				| char |
				char := self at: i.
				kwd nextPut: char.
				char == $: & isAllValidInIdentifiers
					ifTrue: [
						kwds nextPut: kwd contents.
						kwd reset.
						isAllValidInIdentifiers := true ]
					ifFalse: [
						char isValidInIdentifiers ifFalse: [ isAllValidInIdentifiers := false ]]].
		kwd isEmpty ifFalse: [ kwds nextPut: kwd contents ]].
	
	^ keywords.! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/6/2024 17:27:30' prior: 16813819!
                             withDoubleColonsDoubled
	"Return a copy of the receiver with any double colons duplicated.
	Useful for turning text into Smalltalk comments."

	^self species streamContents: [ :stream |
		self do: [ :c |
			stream nextPut: c.
			c == $"
				ifTrue: [ stream nextPut: c ]]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 12/19/2024 13:51:42' prior: 50336532!
             withDoubleColonsUndoubled
	"Do the inverse of #withDoubleColonsDoubled"

	^self species streamContents: [ :stream |
		| lastWasDoubleColon |
		lastWasDoubleColon := false.
		self do: [ :c |
			c == $"
				ifTrue: [
					lastWasDoubleColon
						ifFalse: [
							stream nextPut: c.
							lastWasDoubleColon := true ]
						ifTrue: [
							lastWasDoubleColon := false]]
				ifFalse: [
					stream nextPut: c.
					lastWasDoubleColon := false ]]].! !
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 6/8/2022 15:01:25' prior: 16813848!
 withNewLines
	"Return a copy of the receiver in which backslash (\) characters have been replaced with newLine (i.e. Lf)."

	^ self collect: [ :c | c == $\ ifTrue: [ Character newLineCharacter ] ifFalse: [ c ]].! !
!CharacterSequence methodsFor: 'printing' stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16813970 overrides: 16828385!
                    storeOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."
	| x |
	aStream nextPut: $'.
	1 to: self size do:
		[:i |
		aStream nextPut: (x := self at: i).
		x == $' ifTrue: [aStream nextPut: x]].
	aStream nextPut: $'! !
!CharacterSequence methodsFor: 'fileman-testing' stamp: 'jmv 2/21/2024 15:09:00' prior: 16814194!
                  isAbsolutePathName
	"Note: On Windows, both 'C:\Users\Someone\file.txt' and '\Users\Someone\file.txt'
	and even '/Users/Someone/file.txt' are considered an absolute pathName.
	This is essentially because FilePlugin can handle them. The gained uniformity with Unix is nice."
	
	self isEmpty ifTrue: [^ false].
	self first isPathSeparator ifTrue: [^ true].
	
	"tilde means user's home folder, if possible.
	https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html"
	self first == $~ ifTrue: [^ true ].

	FileIOAccessor default onWindows
		ifTrue: [
			^ self beginsWithWindowsDriveName and: [ self size = 2 or: [ (self at: 3) isPathSeparator ]]].

	^ false! !
!CharacterSequence methodsFor: 'private' stamp: 'jmv 6/13/2022 09:25:45' prior: 16814559!
     getEnclosedExpressionFrom: aStream
	"private - get the expression enclosed between '{' and 
	'}' and remove all the characters from the stream"

	| result currentChar |
	result := self species writeStream.
	[aStream atEnd 
		or: [(currentChar := aStream next) == $}]]
			whileFalse: [result nextPut: currentChar].
	^ result contents withBlanksTrimmed.! !
!CharacterSequence methodsFor: 'formatting' stamp: 'jmv 12/19/2024 13:52:18' prior: 50336579!
                               format: aCollection
	"format the receiver with aCollection  
	 
	simplest example:
	'foo {1} bar' format: {Date today}.
	 
	complete example:
	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}..
	"
	^self species streamContents: [ :out |
		| stream |
		stream := self readStream.
		[stream atEnd]
			whileFalse: [| currentChar | 
				currentChar := stream next.
				currentChar == ${
					ifTrue: [| expression | 
						expression := self getEnclosedExpressionFrom: stream.
						out nextPutAll: (self evaluateExpression: expression parameters: aCollection)]
					ifFalse: [
						currentChar == $\
							ifTrue: [stream atEnd ifFalse: [out nextPut: stream next]]
							ifFalse: [out nextPut: currentChar]]]].! !
!CharacterSequence methodsFor: 'grammar' stamp: 'LC 7/5/2020 16:47:58' prior: 16814640!
                             article
	| article first letter second |
	self isEmpty ifTrue: [^self].
	article := self first isVowel ifTrue: ['an'] ifFalse: ['a'].
	first := self first asLowercase.
	letter := self size = 1.
	second := letter ifFalse: [self second asLowercase].
	(first == $f and: [letter orNot: ['aeiloru' includes: second]])
		ifTrue: [^'an'].
	first == $u ifTrue: [
		(letter or: ['cks' includes: second]) ifTrue: [^'a'].
		second == $n
			ifTrue: [(self size = 2 or: [self third isVowel]) ifTrue: [^'a']]].
	(first == $e and: [second == $u]) ifTrue: [^'a'].
	^article! !
!CharacterSequence methodsFor: 'grammar' stamp: 'LC 4/25/2020 10:24:38' prior: 16814753!
                      lowercasePlural
	| last |
	self exceptionalPlural ifNotNil: [:pl | ^pl].
	self isUninflictedNoun ifTrue: [^self].
	last := self last.
	last == $y ifTrue: [
		#('ay' 'ey' 'oy' 'uy') do: [:t |
			(self endsWith: t) ifTrue: [^self , 's'].
			^self allButLast , 'ies']].
	#('zz' 'ch' 'sh') do: [:t | (self endsWith: t) ifTrue: [^self , 'es']].
	last == $s ifTrue: [
		self = 'its' ifTrue: [^'their'].
		#('bs' 'cs' 'ds' 'ks' 'ls' 'ms' 'rs' 'ts' 'ws')
			do: [:t | (self endsWith: t) ifTrue: [^self]].
		#('sis' 'xis')
			do: [:t | (self endsWith: t) ifTrue: [^(self allButLast: 2) , 'es']]].
	last == $z ifTrue: [^self , 'zes'].
	(last == $x or: [last == $s]) ifTrue: [^self , 'es'].
	(self endsWith: 'man') ifTrue: [^(self allButLast: 2) , 'en'].
	last == $f ifTrue: [^self allButLast , 'ves'].
	(self endsWith: 'fe') ifTrue: [^(self allButLast: 2) , 'ves'].
	^self , 's'! !
!CharacterSequence class methodsFor: 'instance creation' stamp: 'jmv 12/19/2024 13:52:49' prior: 50336606 overrides: 16917720!
                         readFrom: inStream
	"Answer a new String that is determined by reading the stream, inStream.  Embedded
	double quotes become the quote Character."

	^self streamContents: [ :outStream |
		| done |
		"go to first quote"
		inStream skipTo: $'.
		done := false.
		[done or: [inStream atEnd]]
			whileFalse: 
				[ |char|
				char := inStream next.
				char == $'
					ifTrue: 
						[char := inStream next.
						char == $'
							ifTrue: [outStream nextPut: char]
							ifFalse: [done := true]]
					ifFalse: [outStream nextPut: char]]].! !
!String methodsFor: 'testing' stamp: 'fgz 7/1/2024 16:33:58' prior: 16961227!
                      isIntegerDenotation
	"Answer true if the receiver denotes an integer number."
	
	^(self size > 1 and: [
		self first == $- and: [ (self findFirst: [:each | each isDigit not ] startingAt: 2) = 0 ]
			]) or: [ self size > 0 and: [ self allSatisfy: [:each | each isDigit ] ] ]

! !
!Symbol methodsFor: 'accessing' stamp: 'jmv 6/28/2022 14:45:08' prior: 16962542!
                        precedence
	"Answer the receiver's precedence, assuming it is a valid Smalltalk
	message selector or 0 otherwise. The numbers are 1 for unary,
	2 for binary and 3 for keyword selectors."

	| c |
	self isEmpty ifTrue: [^ 0].
	"Consider selectors starting with an underscore $_ as unary, even if Preferences allowUnderscoreSelectors is not set."
	c := self first.
	c isValidInBinarySelectors ifTrue: [^ 2].
	self last == $: ifTrue: [^ 3].
	^ 1! !
!Symbol class methodsFor: 'instance creation' stamp: 'jmv 8/15/2015 10:21' prior: 16962916 overrides: 50351344!
                   readFrom: strm
	"
	Symbol readFrom: '#abc' readStream
	"

	strm peek == $# ifFalse: [self error: 'Symbols must be introduced by #'].
	^ (Scanner new scan: strm) advance  "Just do what the code scanner does"! !
!Symbol class methodsFor: 'services' stamp: 'jmv 2/5/2024 17:59:33' prior: 16962993!
                         possibleSelectorsFor: misspelled 
	"Answer an ordered collection of possible corrections
	for the misspelled selector in order of likelyhood"

	| numArgs candidates lookupString best binary short long first ss |
	lookupString := misspelled asLowercase. "correct uppercase selectors to lowercase"
	numArgs := lookupString numArgs.
	(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollection new].
	first := lookupString first.
	short := lookupString size - (lookupString size // 4 max: 3) max: 2.
	long := lookupString size + (lookupString size // 4 max: 3).

	"First assemble candidates for detailed scoring"
	candidates := OrderedCollection new.
	self allSymbolTablesDo: [:s | (((ss := s size) >= short	"not too short"
			and: [ss <= long			"not too long"
					or: [(s at: 1) = first]])	"well, any length OK if starts w/same letter"
			and: [s numArgs = numArgs])	"and numArgs is the same"
			ifTrue: [candidates add: s]].

	"Then further prune these by correctAgainst:"
	best := lookupString correctAgainst: candidates.
	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [
		binary := misspelled, ':'.		"try for missing colon"
		Symbol hasInterned: binary ifTrue: [:him | best addFirst: him]].
	^ best! !
!UnicodeSymbol methodsFor: 'accessing' stamp: 'jmv 6/28/2022 14:45:18' prior: 16996576!
                          precedence
	"Answer the receiver's precedence, assuming it is a valid Smalltalk
	message selector or 0 otherwise. The numbers are 1 for unary,
	2 for binary and 3 for keyword selectors."

	| c |
	self isEmpty ifTrue: [^ 0].
	"Consider selectors starting with an underscore $_ as unary, even if Preferences allowUnderscoreSelectors is not set."
	c := self first.
	c isValidInBinarySelectors ifTrue: [^ 2].
	self last == $: ifTrue: [^ 3].
	^ 1! !
!UnicodeSymbol class methodsFor: 'instance creation' stamp: 'jmv 7/6/2023 11:52:07' prior: 16996828 overrides: 50351344!
          readFrom: strm
	"
	UnicodeSymbol readFrom: '#abc' readStream
	"

	strm peek == $# ifFalse: [self error: 'Symbols must be introduced by #'].
	^ (Scanner new scan: strm) advance  "Just do what the code scanner does"! !
!SystemDictionary methodsFor: 'query' stamp: 'jmv 10/1/2022 12:02:12' prior: 16970333!
                classesWithExtensionCategories
	"For a base image, there should be none.
	Smalltalk classesWithExtensionCategories
	"

	Object withAllSubclasses do: [ :cls | cls organization categories do: [ :cat | cat first == $* ifTrue: [cls print ]]]! !
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 8/16/2024 09:21:38' prior: 16970805!
                      processCommandLineArguments: initialOptions
	"
	Smalltalk processCommandLineArguments: true
	Smalltalk processCommandLineArguments: false

	Note: By default, any exceptions thrown during the evaluation of arguments are simply ignored.
	To ease debugging, use the -e argument: Do Not Ignore Exceptions. 
	For example:
		squeak Cuis.image -e -s myScript.st
	If ``myScript.st`` contains an error, a Debugger will pop up.
	
	See comment at
		processInitialCommandLineOption:optionArgument:
		processFinalCommandLineOption:optionArgument:raiseExceptions:
	See displayCommandLineUsageOn:
	"
	| optionString optionArgument optionIndex nextOptionIndex optionLastParameterIndex raiseExceptions dashFinder |

	"Any command line argument that starts with $- is an Option.
	NonOption arguments are parameters for the preceding Option."
	raiseExceptions := false.
	startUpScriptArguments := #().
	"Empty Strings are valid command line arguments, generated by two double quotes. Handle them."
	dashFinder := [ :any | any notEmpty and: [ any first == $- ] ].
	optionIndex := startUpArguments findFirst: dashFinder startingAt: 1.
	[ optionIndex > 0 ] whileTrue: [
		"Find parameters for this option"
		nextOptionIndex := startUpArguments findFirst: dashFinder startingAt: optionIndex+1.
		optionLastParameterIndex := nextOptionIndex = 0
			ifTrue: [startUpArguments size]
			ifFalse: [nextOptionIndex-1].
		optionString := startUpArguments at: optionIndex.
		optionString size > 1 ifTrue: [
			optionString = '--' 						"Including    --    as an option means 'ignore everything after here'"
				ifTrue: [^self].
			optionString = '-e'
				ifTrue: [ raiseExceptions := true ]
				ifFalse: [
					optionArgument := optionLastParameterIndex > optionIndex ifTrue: [startUpArguments at: optionIndex+1].
					startUpScriptArguments := startUpArguments copyFrom: optionIndex+2 to: optionLastParameterIndex.
					initialOptions
						ifTrue: [ self processInitialCommandLineOption: optionString optionArgument: optionArgument ]
						ifFalse: [ self processFinalCommandLineOption: optionString optionArgument: optionArgument raiseExceptions: raiseExceptions ].
					startUpScriptArguments := #() ]
			].
		optionIndex := nextOptionIndex ].! !
!Base64MimeConverter methodsFor: 'conversion' stamp: 'jmv 5/21/2022 22:29:58' prior: 16786556!
                      nextValue
	"The next six bits of data char from the mimeStream, or nil.  Skip all other chars"
	| raw num |
	FromCharTable ifNil: [ self class initializeTables ].
	[
		raw := mimeStream next.
		raw ifNil: [^ nil].	"end of stream"
		raw == $= ifTrue: [^ nil].
		num := FromCharTable at: raw asciiValue + 1.
		num ifNotNil: [^ num].
		"else ignore space, return, tab, ..."
	] repeat! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 5/26/2022 15:14:19' prior: 16960426!
nextNumber
	"Answer a number from the (text) stream."

	|element|
	[(element := self next) isNil or: [element isDigit or: [element == $- or: [element == $. or: [element == $)]]]]] whileFalse.
	element ifNil: [^nil].
	self skipBack.
	element == $) ifTrue: [^nil].
	^Number readFrom: self! !
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 11/16/2015 14:52' prior: 16928511!
   nextKeyword
	^self
		untilAnySatisfying: [:c | (c isValidInIdentifiers or: [c == $:]) not]! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16929068!
                              unCommand
	"If this read stream is at a <, then skip up to just after the next >.  For removing html commands."
	| char |
	[self peek == $<] whileTrue: ["begin a block"
		[self atEnd == false and: [self next ~~ $>]] whileTrue.
		"absorb characters"
		].
 ! !
!Transcripter methodsFor: 'command line' stamp: 'di 8/12/97 22:11' prior: 16990646 overrides: 16917177!
                     confirm: queryString 
	| choice |
	[true]
		whileTrue: 
			[choice := self request: queryString , '
Please type yes or no followed by return'.
			choice first asUppercase == $Y ifTrue: [^ true].
			choice first asUppercase == $N ifTrue: [^ false]]! !
!Scanner methodsFor: 'expression types' stamp: 'HAW 6/22/2020 16:11:44' prior: 16946318!
            scanToken

	"Skip delimiters fast, there almost always is one."
	self skipDelimiters.

	mark := source position - 1.
	(tokenType at: 1) == $x "x as first letter"
		ifTrue: [self perform: tokenType "means perform to compute token & type"]
		ifFalse: [token := self step asSymbol "else just unique the first char"].
	^token! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 11/28/2022 11:51:26' prior: 16946518!
                            xBinary

	tokenType := #binary.
	token := source collectionSpecies streamContents: [ :stream |
	stream nextPut: self step.
	[	| type |
		type := self typeTableAt: hereChar.
		(type == #xBinary or: [ type == #xDiacritical ]) and: [
			hereChar ~~ $- or: [aheadChar isDigit not]]
	] whileTrue: [
		stream nextPut: self step]].
	token := token asSymbol.! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/21/2022 22:30:01' prior: 16946532!
xColon
	"Allow := for assignment"
	
	aheadChar == $= ifTrue:
		[self step.
		tokenType := #leftArrow.
		self step.
		^ token := #':='].
	"Otherwise, just do what normal scan of colon would do"
	tokenType := #colon.
	^ token := self step asSymbol! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 5/23/2022 17:16:31' prior: 16946570!
         xDoubleQuote
    "Collect a comment."
    "wod 1/10/98: Allow 'empty' comments by testing the first character
for $"" rather than blindly adding it to the comment being collected."
    | aStream stopChar |
    stopChar := DoItCharacter.
    aStream := source collectionSpecies writeStream.
    self step.
    [hereChar == $"]
        whileFalse:
            [(hereChar = stopChar and: [source atEnd])
                ifTrue: [^self offEnd: self class unmatechedCommentQuoteErrorDescription].
            aStream nextPut: self step.].
    self step.
    currentComment == nil
        ifTrue: [currentComment := OrderedCollection with: aStream contents]
        ifFalse: [currentComment add: aStream contents].
    self scanToken! !
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 1/9/2024 11:37:11' prior: 16946604!
        xLetter
	"Form a word or keyword."

	| type |
	buffer reset.
	[(type := self typeTableAt: hereChar) == #xLetter
		or: [type == #xDigit
		or: [type == #xUnderscore
		or: [type == #xDiacritical
		or: [ hereChar == $′ ]]]]  						"Also see #isValidInIdentifiers"
	] whileTrue: [
			"open code step for speed"
			buffer nextPut: hereChar.
			hereChar := aheadChar.
			aheadChar := source atEnd
				ifTrue: [DoItCharacter "doit"]
				ifFalse: [source next]].
	tokenType := (type == #colon or: [type == #xColon and: [aheadChar ~~ $=]])
		ifTrue: [
			buffer nextPut: self step.
			"Allow any number of embedded colons in literal symbols"
			[(self typeTableAt: hereChar) == #xColon]
				whileTrue:
					[buffer nextPut: self step].
			#keyword]
		ifFalse: [
			#word].
	token := buffer contents.! !
!Scanner class methodsFor: 'testing' stamp: 'jmv 11/27/2024 14:56:06' prior: 16946786!
              typeTable: aTypeTable at: aCharacterOrCodePoint

	"Prebuilt tables for the ASCII range"
	aCharacterOrCodePoint isAscii ifTrue: [
		^aTypeTable at: aCharacterOrCodePoint asciiValue ].

	"For CodePoints not in the ASCII range"
	aCharacterOrCodePoint isDiacriticalMark ifTrue: [ ^#xDiacritical ].
	aCharacterOrCodePoint isLetter ifTrue: [ ^#xLetter ].
	aCharacterOrCodePoint isSymbolLike ifTrue: [ ^#xBinary ].
	aCharacterOrCodePoint == $­ ifTrue: [ ^#xBinary ].
	aCharacterOrCodePoint isSeparator ifTrue: [ ^#xDelimiter ].
	"Many should actually be #xIllegal"
	^#xLetter! !
!Parser methodsFor: 'pragmas' stamp: 'jmv 5/21/2022 22:31:42' prior: 16921045!
                    pragmaLiteral: selectorSoFar
	"Read a pragma literal.  As a nicety we allow a variable name (rather
	 than a literal string) as the second argument to primitive:error:"

	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])
		ifTrue: [ ^ self advance ].
	(here == $# and: [ tokenType == #word ])
		ifTrue: [ ^ self advance ].
	(here == #- and: [ tokenType == #number ])
		ifTrue: [ ^ (self advance; advance) negated ].
	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])
		ifTrue: [ ^ (Scanner new scanTokens: self advance) first ].
	"This nicety allows one to supply a primitive error
	 temp as a variable name, rather than a string."
	((selectorSoFar beginsWith: 'primitive:')
	 and: [(selectorSoFar endsWith: 'error:')
	 and: [hereType == #word]]) ifTrue:
		[^self advance].
	^self expected: 'Literal constant'! !
!Parser methodsFor: 'pragmas' stamp: 'jmv 7/12/2023 11:53:03' prior: 16921098!
                             pragmaStatement
	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."
	
	| selector arguments words index keyword |
	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])
		ifFalse: [  ^ self expected: 'pragma declaration' ].

	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "
	(here = #apicall: or: [ here = #cdecl: ])
		ifTrue: [ ^ self externalFunctionDeclaration ].

	selector := String new.
	arguments := OrderedCollection new.
	words := OrderedCollection new.
	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [
		index := self startOfNextToken + requestorOffset.
		selector := selector , self advance.
		selector := encoder asciiStringLiteral: selector.
		words add: (index to: self endOfLastToken + requestorOffset).
		(selector last == $: or: [ selector first isLetter not ]) ifTrue: [
			arguments add: (encoder asciiStringLiteral: (self pragmaLiteral: selector)) ] ].
	selector numArgs ~= arguments size
		ifTrue: [ ^ self expected: 'pragma argument' ].
	(Symbol hasInterned: selector 
		ifTrue: [ :value | keyword := value]) 
		ifFalse: [ 
			keyword := self 
				correctSelector: selector wordIntervals: words
				exprInterval: (words first first to: words last last)
				ifAbort: [ ^ self fail ] ].
	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).
	^ true! !
!Parser methodsFor: 'error correction' stamp: 'jmv 4/26/2024 15:20:48' prior: 16922137!
     correctSelector: proposedKeyword wordIntervals: aSpots exprInterval: expInt ifAbort: abortAction
	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."

	| correctSelector userSelection delta adjustedSpots |
	"If we can't ask the user, assume that the keyword will be defined later"
	self interactive ifFalse: [^proposedKeyword asSymbol].
	
	"If the requestor is of an exotic kind (like a telnet server) we might not be allowed to open a PupUpMenu for querying the user"
	"
	((requestor isKindOf: Editor) or: [ requestor is: #Morph ])
		ifFalse: [ ^ proposedKeyword asSymbol ].
	"

	userSelection := requestor selectionInterval.

	delta := self sourceDelta.
	adjustedSpots := aSpots collect: [ :interval | interval first + delta to: interval last + delta ].
	requestor selectFrom: adjustedSpots first first to: adjustedSpots last last.

	correctSelector := UnknownSelector name: proposedKeyword.
	correctSelector ifNil: [^abortAction value].

	requestor selectInvisiblyFrom: userSelection first to: userSelection last.

	self substituteSelector: correctSelector keywords wordIntervals: adjustedSpots.
	^(proposedKeyword last ~~ $:
	   and: [correctSelector last == $:])
		ifTrue: [abortAction value]
		ifFalse: [correctSelector]! !
!Parser methodsFor: 'error correction' stamp: 'EB 1/27/2020 20:19:48' prior: 16922482!
                        isLastPipeOfEmptyTempsDeclaration: pipeIndex

	| indexOfPreviousPipe sourceCode |
	
	sourceCode := requestor text string.
	indexOfPreviousPipe := sourceCode lastIndexOf: $| startingAt: pipeIndex - 1 endingAt: 1 ifAbsent: [ ^false ].
	^(sourceCode at: pipeIndex) == $| and: [
		(sourceCode copyFrom: indexOfPreviousPipe + 1 to: pipeIndex - 1) allSatisfy: [ :char | char isSeparator ]]! !
!Parser methodsFor: 'error correction' stamp: 'HAW 12/12/2019 17:44:22' prior: 16922497!
    newRangeRemovingTempsDeclarationFrom: currentSource 
	startingAt: start
	to: originalEnd
	
	| end |
	
	end := self filterSeparatorsToTheRightOn: currentSource startingAt: originalEnd.
	
	(currentSource at: end+1) == $| ifTrue: [ | possibleNewStart |
		possibleNewStart := (self filterSeparatorsToTheLeftOn: currentSource startingAt: start) - 1.
		(currentSource at: possibleNewStart) == $| ifTrue: [ ^Array with: possibleNewStart with: end + 1 ]]. 
	
	^Array with: start with: end
! !
!Parser methodsFor: 'error correction' stamp: 'EB 12/13/2019 01:26:43' prior: 16922531!
   pasteTempAtMethodLevel: name

	| theTextString |
	
	theTextString := requestor text string.
	tempsMark := 
		(theTextString at: tempsMark) == $| 
			ifTrue: [
  				"Paste it before the second vertical bar"
		 		self pasteTemp: name before: tempsMark ] 
			ifFalse: [ self createTempDeclarationInMethodWith: name ].
	! !
!BlockNode methodsFor: 'printing' stamp: 'hlsf 6/24/2022 09:29:25' prior: 16795182 overrides: 16919938!
                       printOn: aStream indent: level
	| separateLines |
	aStream nextPut: $[.
	self
		printArgumentsOn: aStream
		indent: level.
	separateLines := (self
		printTemporaries: temporaries
		on: aStream
		doPrior: [ aStream space ]) or: [arguments notNil and: [arguments notEmpty] ].
	(Preferences at: #prettyPrintRectangularBlocks)
		ifTrue: [
			"If args+temps > 0 and statements > 1 (or just one complex statement),
			put all statements on separate lines"
			separateLines
				ifTrue: [
					(statements size > 1 or: [
						statements size = 1 and: [ statements first isComplex ]])
							ifTrue: [ aStream newLineTab: (1 max: level) ]
							ifFalse: [ aStream space ] ]
				ifFalse: [
					(statements size = 1 and: [ statements first isComplex not ])
						ifTrue: [ aStream space ]]]
		ifFalse: [
			self isComplex
				ifTrue: [ aStream newLineTab: (1 max: level) ]
				ifFalse: [ aStream space ] ].
	((self printStatementsOn: aStream indent: level) > 0 and: [ aStream peekLast ~~ $] ])
		ifTrue: [ aStream space ].
	aStream nextPut: $]! !
!TTFontReader methodsFor: 'processing' stamp: 'jmv 8/23/2024 14:57:38' prior: 16974344!
                         mapAndStoreGlyphsUsing: characterMap
	"
	https://developer.apple.com/fonts/TrueType-Reference-Manual/RM07/appendixB.html
	"
	| glyphsByUTF8 unknownGlyph nullGlyph spaceGlyph mapSize preferredCodePoint arrowGlyphIndexes leftArrowGlyph upArrowGlyph rightArrowGlyph downArrowGlyph carriageReturnGlyph leftArrowGlyphCodePoint upArrowGlyphCodePoint rightArrowGlyphCodePoint downArrowGlyphCodePoint carriageReturnGlyphCodePoint |
	unknownGlyph := glyphs first.
	nullGlyph := glyphs second.
	mapSize := characterMap size.
	glyphsByUTF8 := Array new: 256.
	leftArrowGlyphCodePoint := self class smalltalkAssignmentArrowGlyphCodePoint.
	upArrowGlyphCodePoint := self class smalltalkReturnArrowGlyphCodePoint.
	rightArrowGlyphCodePoint := 8594.
	downArrowGlyphCodePoint := 8595.
	carriageReturnGlyphCodePoint := 8617.
	
	"Store Unicode arrow glyphs for future use if appropriate,"
	(FallbackArrowGlyphs isNil or: [fontDescription name = 'DejaVuSans']) ifTrue: [
		mapSize > 8617 ifTrue: [								"Usually true. Just in case."
			arrowGlyphIndexes := {leftArrowGlyphCodePoint. upArrowGlyphCodePoint. rightArrowGlyphCodePoint. downArrowGlyphCodePoint. carriageReturnGlyphCodePoint}
					collect: [ :codePoint | (characterMap at: codePoint+1)+1 ].
				(arrowGlyphIndexes allSatisfy: [ :i | i > 1 ]) ifTrue: [
					FallbackArrowGlyphs := arrowGlyphIndexes collect: [ :i | glyphs at: i ]]]].
	"Take arrow glyphs if present, or use fallbacks if not."
	leftArrowGlyph := upArrowGlyph := rightArrowGlyph := downArrowGlyph := carriageReturnGlyph := unknownGlyph.
	mapSize > downArrowGlyphCodePoint ifTrue: [
		leftArrowGlyph := glyphs at: (characterMap at: leftArrowGlyphCodePoint+1)+1.
		upArrowGlyph := glyphs at: (characterMap at: upArrowGlyphCodePoint+1)+1.
		rightArrowGlyph := glyphs at: (characterMap at: rightArrowGlyphCodePoint+1)+1.
		downArrowGlyph := glyphs at: (characterMap at: downArrowGlyphCodePoint+1)+1 ].
	leftArrowGlyph == unknownGlyph ifTrue: [ leftArrowGlyph := FallbackArrowGlyphs at: 1 ].
	upArrowGlyph == unknownGlyph ifTrue: [ upArrowGlyph := FallbackArrowGlyphs at: 2 ].
	rightArrowGlyph == unknownGlyph ifTrue: [ rightArrowGlyph := FallbackArrowGlyphs at: 3 ].
	downArrowGlyph == unknownGlyph ifTrue: [ downArrowGlyph := FallbackArrowGlyphs at: 4 ].
	mapSize > carriageReturnGlyphCodePoint ifTrue: [
		carriageReturnGlyph := glyphs at: (characterMap at: carriageReturnGlyphCodePoint+1)+1 ].
	carriageReturnGlyph == unknownGlyph ifTrue: [ carriageReturnGlyph := FallbackArrowGlyphs at: 5 ].

	0 to: mapSize - 1 do: [ :codePoint | | g array prevByte|

		preferredCodePoint := codePoint.
		(codePoint == $- codePoint and: [mapSize > 16r2212]) ifTrue: [ preferredCodePoint := 16r2212 ]. "WIDE MINUS"
		(codePoint == $* codePoint and: [mapSize > 16r2217]) ifTrue: [ preferredCodePoint := 16r2217 ]. "CENTERED ASTERISK"
		g := glyphs at: (characterMap at: preferredCodePoint+1)+1 ifAbsent: [ unknownGlyph ].
		g == unknownGlyph ifTrue: [
			g := glyphs at: (characterMap at: codePoint+1)+1 ifAbsent: [ unknownGlyph ]].

		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ].
					].
				prevByte := byte.
				]
			withUtf8BytesOf: codePoint.
			array at: prevByte+1 put: g.
		codePoint = 32 ifTrue: [
			spaceGlyph := g ].

		].

	"Synthetic Unicode zero width space glyph. Add others as needed."
	{ Character zeroWidthSpace } do: [ :codePoint | | g array prevByte|
		g := TTGlyph new.					"Suitable as zero width space"
		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ]].
				prevByte := byte ]
			withUtf8BytesOf: codePoint codePoint.
			array at: prevByte+1 put: g ].

	Character separators do: [ :s |
		s codePoint < 256 ifTrue: [
			glyphsByUTF8 at: s codePoint +1 put: spaceGlyph ]].
	1 to: 4 do: [ :i |			glyphsByUTF8 at: 28+i put: i ].
	glyphsByUTF8 at: 13 +1 put: carriageReturnGlyph.
	fontDescription
		glyphsByUtf8Bytes: glyphsByUTF8
		unknownGlyph: unknownGlyph scaleArrowGlyphs: {leftArrowGlyph. rightArrowGlyph. upArrowGlyph. downArrowGlyph. carriageReturnGlyph}! !
!Date class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 16:33:54' prior: 16841926 overrides: 16917720!
                          readFrom: aStream 
	"Read a Date from the stream in any of the forms:
		<day> <month> <year>		(15 April 1982; 15-APR-82; 15.4.82; 15APR82)  
		<month> <day> <year>		(April 15, 1982; 4/15/82)
		<year>-<month>-<day>		(1982-04-15) (ISO8601)"
	| day month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek == $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 31])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isLetter
		ifTrue: ["MonthName-DD-YY or DD-MonthName-YY or YY-MonthName-DD"
			month := String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
			firstAsNumber
				ifNil: ["MonthName DD YY"
					day := Integer readFrom: aStream]
				ifNotNil: [
					year ifNil: ["DD MonthName YY"
						day := firstAsNumber]]]
		ifFalse: ["MM-DD-YY or DD-MM-YY or YY-MM-DD"
			year 
				ifNil: ["MM-DD-YY or DD-MM-YY"
					firstAsNumber > 12
						ifTrue: ["DD-MM-YY"
							day := firstAsNumber.
							month := Month nameOfMonth: (Integer readFrom: aStream)]
						ifFalse: ["MM-DD-YY"
							month := Month nameOfMonth: firstAsNumber.
							day := Integer readFrom: aStream]]
				ifNotNil: ["YY-MM-DD"
					month := Month nameOfMonth: (Integer readFrom: aStream)]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	year
		ifNil: [year := Integer readFrom: aStream]
		ifNotNil: [day := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year :=  year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self year: year month: month day: day! !
!Month class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 16:33:59' prior: 16904411 overrides: 16917720!
        readFrom: aStream 
	"Read a Month from the stream in any of the forms:  
		<month> <year>			(April 1982; APR-82; 4.82; APR82)  
		<month> <year>			(April, 1982; 4/82)
		<year>-<month>			(1982-04) (ISO8601)"
	"
	Month readFrom: 'July 1998' readStream
	"
	| month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek == $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isLetter
		ifTrue: ["MonthName-YY or YY-MonthName"
			month := String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip]]
		ifFalse: ["MM-YY or YY-MM"
			month := year 
				ifNil: ["MM-YY"
					Month nameOfMonth: firstAsNumber ]
				ifNotNil: ["YY-MM"
					Month nameOfMonth: (Integer readFrom: aStream)]].

	year ifNil: [
		[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
		year := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year := year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self month: month year: year! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 15:07:01' prior: 17007707 overrides: 16917720!
                         readFrom: aStream 
	"Read a Week from the stream in any of the forms:  
		<year>-W<week>			(2009-W01) (ISO8601)"
	| weekNumber yearNumber firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek == $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [yearNumber := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip].
	aStream next == $W ifFalse: [
		self error: 'Invalid Format' ].

	weekNumber := Integer readFrom: aStream.
	weekNumber < 1 ifTrue: [ self error: 'Invalid Format' ].
	(yearNumber < 100 and: [yearNumber >= 0])  ifTrue: [
		yearNumber := yearNumber < 69 
			ifTrue: [2000 + yearNumber]
			ifFalse: [1900 + yearNumber]].

	^ self yearNumber: yearNumber weekNumber: weekNumber! !
!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/26/2022 15:07:07' prior: 17010753 overrides: 16917720!
                    readFrom: aStream 

	| year sign |
	sign := aStream peek == $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isDigit] whileFalse: [aStream skip].
	year := (Integer readFrom: aStream) * sign.
	^ self yearNumber: year! !
!Browser methodsFor: 'class functions' stamp: 'jmv 5/21/2022 22:29:19' prior: 16797765!
                 explainSpecial: string 
	"Answer a string explaining the code pane selection if it is displaying 
	one of the special edit functions."

	| classes whole lits reply |
	self isEditingClass
		ifTrue: 
			["Selector parts in class definition"
			string last == $: ifFalse: [^nil].
			lits := Array with:
				#subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:.
			(whole := lits detect: [:each | (each keywords
					detect: [:frag | frag = string] ifNone: nil) notNil]
						ifNone: nil) notNil
				ifTrue: [reply := '"' , string , ' is one part of the message selector ' , whole , '.']
				ifFalse: [^nil].
			classes := Smalltalk allClassesImplementing: whole.
			classes := 'these classes ' , classes printString.
			^reply , '  It is defined in ' , classes , '."
Smalltalk browseAllImplementorsOf: #' , whole].

	editSelection == #editSystemCategories ifTrue: [^nil].
	editSelection == #editMessageCategories ifTrue: [^nil].
	^nil! !
!Browser methodsFor: 'message category functions' stamp: 'jmv 3/14/2024 10:32:52' prior: 16798119!
                             addExtensionCategory
	"Present a choice package names and let the user enter a new category suffx.
	Take the suffix form the selected category."

	| packageNames packageNameIndex |
	
	selectedClassName ifNil: [ ^self ].

	packageNames := (CodePackage installedPackages collect: [ :package |
		package packageName ]) sorted.
	packageNames ifEmpty: [ ^ self ].
	
	packageNameIndex := PopUpMenu 
		withCaption: 'Which package to extend?'
		chooseFrom: packageNames.
	packageNameIndex = 0 ifTrue: [ ^ self ].

	self 
		request: 'Enter the category name'
		initialAnswer: 
			(String streamContents: [ :stream |
				stream
					nextPut: $*;
					nextPutAll: (packageNames at: packageNameIndex).
				selectedMessageCategory ifNotNil: [
					stream
						nextPut: $-;
						nextPutAll: selectedMessageCategory ] ])
		 verifying: [ :newCategoryName | 
			((newCategoryName at: 1) == $* or: [
				self confirm:
					"I know about with #withNewlines ..."
					`'The selected category does not start with an asterix (*).',
					String newLineString,
					'Do you want to use it anyway?'` ]) and: [
						(packageNames includes:				(newCategoryName copyUpTo: $-) allButFirst) or: [
							self confirm:
								`'The selected prefix does not match any package name.', 
								String newLineString,
								'Do you want to use it anyway?'` ] ] ]
		do: [ :newCategoryName | | oldMessageCategoryListIndex |
			oldMessageCategoryListIndex := self messageCategoryListIndex.
			self classOrMetaClassOrganizer
				addCategory: newCategoryName
				before: selectedMessageCategory.
			self changed: #messageCategoryList.
			self messageCategoryListIndex:
				(oldMessageCategoryListIndex = 0
					ifTrue: [ self classOrMetaClassOrganizer categories size + 1 ]
					ifFalse: [ oldMessageCategoryListIndex ]).
			self changed: #messageCategoryList ]! !
!MessageNames methodsFor: 'search' stamp: 'jmv 4/28/2022 11:40:38' prior: 16896313!
     computeSelectorListFromSearchString
	"Compute selector list from search string"
	| sorted |
	sorted := SortedCollection sortBlock: [ :x :y |
		x asLowercase <= y asLowercase ].
	(searchString findBetweenSubStrs: ';') do: [ :selPat | | raw n m |
		selPat notEmpty ifTrue: [
			(selPat first == $" and: [
				selPat last == $" and: [ selPat size > 2 ]])
				ifTrue: [
					Symbol
						hasInterned:
							(selPat
								copyFrom: 2
								to: selPat size - 1)
						ifTrue: [ :sym |
							sorted add: sym ]]
				ifFalse: [
					raw := ((n := selPat occurrencesOf: $*) > 0 | ((m := selPat occurrencesOf: $#) > 0) and: [ selPat size > (n + m) ])
						ifTrue: [ Symbol selectorsMatching: selPat ]
						ifFalse: [ Symbol selectorsContaining: selPat ].
					sorted addAll: raw ]]].
	selectorList := sorted asArray  select: [ :sym |
		(Smalltalk isThereAnImplementorOf: sym) or: [ Smalltalk isThereAReferenceTo: sym ]].
	^ selectorList.! !
!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 3/27/2024 10:50:49' prior: 16809851!
                               contents: input notifying: aRequestor 
	"Compile the code in aString. Notify aRequestor of any syntax errors. 
	Create an error if the category of the selected message is unknown. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."

	| codeString category selector class oldSelector |
	codeString := input string.
	(class := self selectedClassOrMetaClass) ifNil:
		[(myChangeSet preambleString == nil or: [codeString isEmpty]) ifTrue: [ ^ false].
		(codeString count: [:char | char == $"]) odd 
			ifTrue: [self inform: 'unmatched double quotes in preamble']
			ifFalse: [(Scanner new scanTokens: codeString) notEmpty ifTrue: [
				self inform: 'Part of the preamble is not within double-quotes.
To put a double-quote inside a comment, type two double-quotes in a row.
(Ignore this warning if you are including a doIt in the preamble.)']].
		myChangeSet preambleString: codeString.
		self currentSelector: nil.  "forces update with no 'unsaved chages' feedback"
		^ true].
	oldSelector := self selectedMessageName.
	category := class organization categoryOfElement: oldSelector.
	selector := class compile: codeString
				classified: category
				notifying: aRequestor.
	selector ifNil: [^ false].
	(self messageList includes: selector)
		ifTrue: [self currentSelector: selector]
		ifFalse: [self currentSelector: oldSelector].
	self update.
	^ true! !
!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 3/28/2023 15:37:43' prior: 16862897!
                        doesPattern: aPattern allow: entry 

	(aPattern = '*' or: [ aPattern match: entry name ]) ifFalse: [ ^false ].

	(showHidden not and: [ entry name first == $. ]) ifTrue: [ ^false ].

	"Hide Mac resurce forks and folder service stores"
	(entry name = '.DS_Store') ifTrue: [ ^false ].
	('._*' match: entry name) ifTrue: [ ^false ].
	^true! !
!FileList methodsFor: 'private' stamp: 'jmv 8/5/2024 16:44:13' prior: 16863299!
                            updateFileList
	"Update my files list with file names in the current directory  
	that match the pattern.
	The pattern string may have embedded newlines or semicolons; these separate different patterns."
	| patterns patternsThatReject patternsThatSelect newList |
	patterns := OrderedCollection new.
	(pattern findTokens: (String with: Character cr with: Character lf with: $;))
		do: [ :each |
			(each includes: $*) | (each includes: $?)
				ifTrue: [ patterns add: (each copyReplaceAll: '?' with: '#')]
				ifFalse: [
					each isEmpty
						ifTrue: [ patterns add: '*']
						ifFalse: [ patterns add: '*' , each , '*']]].
	"A pattern that starts with $/ is used to reject entries
	Rejecting patterns are applied after selecting patterns."
	patternsThatSelect := patterns reject: [ :any | any first == $/ ].
	patternsThatSelect isEmpty ifTrue: [ patternsThatSelect add: '*' ]. 
	patternsThatReject := patterns select: [ :any | any first == $/ ] thenCollect: [ :each | each copyFrom: 2 to: each size ].
	newList := self listForSelectingPatterns: patternsThatSelect rejectingPatterns: patternsThatReject.

	newList = list ifFalse: [
		"If we had a selection, ensure it is valid, or discard it."
		listIndex = 0 ifFalse: [
			(listIndex > newList size or: [(list at: listIndex) ~= (newList at: listIndex)]) ifTrue: [
				listIndex := newList indexOf: (list at: listIndex) ]].
		list := newList.
		listIndex > 0 ifFalse: [ "Had no selection or it was discarded"
			fileName := nil.
			acceptedContentsCache := ''.
			self acceptedContentsChanged.
			self changed: #fileListIndex ].
		self changed: #fileList.
		self triggerEvent: #updateButtonRow ].! !
!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 4/21/2022 12:17:39' prior: 16842824 overrides: 16917720!
                      readFrom: aStream

	| offset date time ch |

	date := Date readFrom: aStream.
	[aStream peek isDigit]
		whileFalse: [aStream next].
	time := Time readFrom: aStream.
	aStream atEnd
		ifTrue: [ offset := self localOffset ]
		ifFalse: [
			ch := aStream next.
			ch == $+ ifTrue: [ch := Character space].
			offset := Duration fromString: (String with: ch), '0:', aStream upToEnd, ':0'].
		
	^ self
		year: date yearNumber
		month: date monthIndex
		day: date dayOfMonth
		hour: time hour
		minute: time minute
		second: time second
		nanoSecond: time nanoSecond
		offset: offset


	"
		DateAndTime readFrom: '-1199-01-05T20:33:14.321-05:00' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.1+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.02+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.003+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0004+01:01' readStream
  		DateAndTime readFrom: ' 2002-05-16T17:20:45.00005' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000006+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000007+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.00000008-01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000000009+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000000001+01:01' readStream

 		DateAndTime readFrom: ' 2002-05-16T17:20' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45+01:57' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45-02:34' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45+00:00' readStream
		DateAndTime readFrom: ' 1997-04-26T01:02:03+01:02:3' readStream
 	"! !
!Time class methodsFor: 'smalltalk-80' stamp: 'jmv 11/15/2022 10:33:12' prior: 16989079 overrides: 16917720!
          readFrom: aStream
	"Read a Time from the stream in the form:
		<hour>:<minute>:<second> <am/pm>

	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"

	| hour minute second nanos ampm |
	hour := Integer readFrom: aStream.
	minute := 0.
	second := 0.
	nanos := 0.
	(aStream peekFor: $:) 
		ifTrue: [
			minute := Integer readFrom: aStream.
			(aStream peekFor: $:) ifTrue: [
				second := Integer readFrom: aStream.
				(aStream peekFor: $.)
					ifTrue: [ | nanosStart scale |
						nanosStart := aStream position.
						nanos := Integer readFrom: aStream.
						"As if there were trailing zeros to fill 9 positions"
						scale := 10 raisedToInteger: nanosStart + 9 - aStream position.
						nanos := nanos * scale ]]].
	aStream skipSeparators.
	(aStream atEnd not and: [aStream peek isLetter]) ifTrue: [
		ampm := aStream next asLowercase.
	
	(ampm == $p and: [hour < 12]) ifTrue: [hour := hour + 12].
		(ampm == $a and: [hour = 12]) ifTrue: [hour := 0].
	
	(aStream peekFor: $m) ifFalse: [aStream peekFor: $M ]].
	^ self 
		hour: hour 
		minute: minute 
		second: second 
		nanoSecond: nanos.

	"
	Time readFrom: '2:23:09 pm' readStream
	Time readFrom: '2:23:09.0 pm' readStream
	Time readFrom: '2:23:09.123402 pm' readStream
	Time readFrom: '2:23:09.00123402 pm' readStream
	Time readFrom: '2:23:09.001234020 pm' readStream
	Time readFrom: '2:23:09.000123402 pm' readStream
	"! !
!Number class methodsFor: 'instance creation' stamp: 'jmv 6/6/2022 10:59:12' prior: 16914943 overrides: 16917720!
              readFrom: stringOrStream 
	"Answer a number as described on aStream.  The number may
	include a leading radix specification, as in 16rFADE"
	| value base aStream sign |
	aStream := stringOrStream isString
		ifTrue: [stringOrStream readStream]
		ifFalse: [stringOrStream].
	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].
	sign := (aStream peekFor: $-) ifTrue: [-1] ifFalse: [aStream peekFor: $+. 1].
	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].
	base := 10.
	aStream peek == $.
		ifTrue: [ value := 0 ]
		ifFalse: [
			value := Integer readFrom: aStream base: base.
			(aStream peekFor: $r)
				ifTrue: [
					"<base>r<integer>"
					(base := value) < 2 ifTrue: [
						base = 1 ifTrue: [ ^Integer readBaseOneFrom: aStream ].
						^self error: 'Invalid radix'].
					(aStream peekFor: $-) ifTrue: [sign := sign negated].
					value := Integer readFrom: aStream base: base].
			(aStream peekFor: $x)
				ifTrue: [
					"0x<integer>" "Hexadecimal"
					base := 16.
					(aStream peekFor: $-) ifTrue: [sign := sign negated].
					value := Integer readFrom: aStream base: base]].
	^ self readRemainderOf: value from: aStream base: base withSign: sign.! !
!Number class methodsFor: 'instance creation' stamp: 'jmv 5/26/2022 15:15:32' prior: 16914983!
  readRemainderOf: integerPart from: aStream base: base withSign: sign
	"Read optional fractional part and exponent, and return the final result"
	| value fraction fracpos peekChar exp scale convertToFloat |

	convertToFloat := false.
	value := integerPart.
	(aStream peekFor: $.)
		ifTrue: [		 "<integer>.<fraction>"
			(aStream atEnd not and: [ aStream peek digitValue between: 0 and: base - 1 ])
				ifTrue:  [
					fracpos := aStream position.
					fraction := Integer readFrom: aStream base: base.
					fraction := fraction / (base raisedToInteger: aStream position - fracpos).
					value := value + fraction.
					convertToFloat := true ]
				ifFalse: [
					"oops - just <integer>."
					aStream skipBack.
					"un-gobble the period"
					^ value * sign"Number readFrom: '3r-22.2'"]].
	peekChar := aStream peek.
	('deqp' includes: peekChar)
		ifTrue: [			"<number>(e|d|q)<exponent>>" "<number>(p)<binaryExponent>>"
			aStream next.
			(aStream atEnd not and: [ (aStream peek digitValue between: 0 and: 9) or: [ '+-' includes: aStream peek ]])
				ifTrue:  [
					exp := Integer readFrom: aStream.
					scale := (peekChar == $p ifTrue: [2] ifFalse: [base]) raisedToInteger: exp.
					value := value * scale ]
				ifFalse: [
					"oops - just <number>."
					aStream skipBack.]].
	^convertToFloat
		ifTrue: [
			(value = 0.0 and: [ sign = -1 ])
				ifTrue: [ Float negativeZero ]
				ifFalse: [ (value * sign) asFloat ]]
		ifFalse: [ value * sign ]! !
!MessageSend methodsFor: 'evaluating' stamp: 'jmv 5/15/2024 15:51:16' prior: 16898912 overrides: 16915784!
      valueWithPossibleArgument: anObject

	^selector last == $:
		ifFalse: [ receiver perform: selector ]
		ifTrue: [ receiver perform: selector with: anObject ]! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 8/3/2020 17:30:42' prior: 16830411!
   fromHexString: aString
	"For HTML color spec: #FFCCAA.
	See http://www.w3schools.com/cssref/css_colors_legal.asp
	Also handles 3 digit shorthand."
	"
	Color fromHexString: '#FFCCAA'.
	"
	(aString size = 7 and: [ aString first == $# ]) ifTrue: [
		| aColorHexU red green blue |
		aColorHexU := aString asUppercase.
		red := ('16r', (aColorHexU copyFrom: 2 to: 3)) asNumber/255.
		green := ('16r', (aColorHexU copyFrom: 4 to: 5)) asNumber/255.
		blue := ('16r', (aColorHexU copyFrom: 6 to: 7)) asNumber/255.
		^ self r: red g: green b: blue].
	(aString size = 4 and: [ aString first == $# ]) ifTrue: [
		| aColorHexU red green blue |
		aColorHexU := aString asUppercase.
		red := aColorHexU at: 2.
		green := aColorHexU at: 3.
		blue := aColorHexU at: 4.
		red := ('16r', (String with: red with: red)) asNumber/255.
		green := ('16r', (String with: green with: green)) asNumber/255.
		blue := ('16r', (String with: blue with: blue)) asNumber/255.
		^ self r: red g: green b: blue].
	^ nil! !
!InputSensor methodsFor: 'keyboard' stamp: 'jmv 1/8/2024 12:38:20' prior: 16882862!
              kbdTest
	"
	Sensor kbdTest
	"
	"This test routine will print the unmodified character, its keycode,
	and the OR of all its modifier bits, until the character x is typed

Also useful:
	Sensor test
	"
	| char |
	char := nil.
	[ char == $x ] whileFalse: [
		[ self keyboardPressed ] whileFalse.
		char := self keyboard.
		Display fill: `5@5 extent: 400@50` fillColor: `Color white`.
		(String streamContents: [ :s |
			s
				nextPut: $-;
				nextPut: char;
				nextPut: $-;
				space;
				print: char codePoint;
				space.
			self isMouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].
			self isMouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].
			self isMouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].
			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].
			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].
			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].
			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ].
			Time now printOn: s
			])
		displayAt: 10 @ 10 ].! !
!EventSensor methodsFor: 'test' stamp: 'jmv 3/8/2023 10:26:28' prior: 16856441!
                               test
	"
	Sensor test

Also useful:
	Sensor kbdTest
	"
	| c lastStamp stamp |
	c := nil.
	lastStamp := 0.
	[ c == $x asciiValue ] whileFalse: [
		Sensor nextEvent ifNotNil: [ :evt |
			stamp := evt at: 2.
			stamp - lastStamp > 300 ifTrue: [ ' ' print.' ' print ].
			Transcript show: evt; newLine.
			self printEventBuffer: evt.
			(evt first = 2 and: [ evt fourth = 0 ]) ifTrue: [
				c := evt third ].
			lastStamp := stamp]]! !
!Character methodsFor: 'testing' stamp: 'jmv 1/9/2024 11:39:35' prior: 16810590!
isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	self isNullCharacter ifTrue: [ ^false ].
	self == $′ ifTrue: [ ^true ]. 		"Also see #xLetter"
	^#(xLetter xDigit xUnderscore xDiacritical) statePointsTo: (Scanner typeTableAt: self).! !
!Character methodsFor: 'testing' stamp: 'jmv 11/16/2015 14:51' prior: 16810621!
            tokenish
	"Answer whether the receiver is a valid token-character--letter, digit, or 
	colon."

	^self isValidInIdentifiers or: [self == $:]! !
!Character methodsFor: 'converting' stamp: 'jmv 7/5/2024 17:17:06' prior: 16810712!
                            withDiacriticalMark: codePointOrCharacter
	"Answer the character resulting from adding a diacritical mark (accent) to a letter.
	If the result is unsupported in ISO 8859-1, answer the receiver.
	Supported diacritical marks are:
		U+0300 	COMBINING GRAVE ACCENT
		U+0301 	COMBINING ACUTE ACCENT
		U+0302 	COMBINING CIRCUMFLEX ACCENT
		U+0303 	COMBINING TILDE
		U+0308 	COMBINING DIAERESIS
		U+030A 	COMBINING RING ABOVE
		U+030C 	COMBINING CARON
		$a withDiacriticalMark: 16r301
		$N withDiacriticalMark: $~
		$Z withDiacriticalMark: $v
		
		invalid:
		$9 withDiacriticalMark:$v
		$A withDiacriticalMark: $v
		$Á withDiacriticalMark: $v
		$A withDiacriticalMark: 1244
		"
	| answer i |
	i := ((codePointOrCharacter isNumber
			ifTrue: [#(16r300 16r301 16r302 16r303 16r308 16r30A 16r30C)]
			ifFalse: [#($` $' $^ $~ $" $° $v)]) indexOf: codePointOrCharacter
				) + 1.
	answer := (Character accentedLetters detect: [ :group | group first = self ] ifNone: [ ^self ]) at: i.
	^answer == $- ifFalse: [answer] ifTrue: [self]! !
!Character methodsFor: 'fileman-testing' stamp: 'jmv 5/21/2022 22:29:28' prior: 16810753!
     isDriveSeparator
	^self == $:
	! !
!Character class methodsFor: 'class initialization' stamp: 'jmv 10/4/2024 11:13:02' prior: 16810798 overrides: 16917943!
    initialize
	"https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt
	http://www.unicode.org/L2/L1999/UnicodeData.html
	Character initialize
	"

	| fields codePoint codePointName generalCategory canonicalCombiningClass characterDecompositionMapping decomposition composition |
	UppercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	LowercaseLettersTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	SymbolsLikeTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	DiacriticalMarksTable := ByteArray newBits: 16r1FFFF. "Basic Multilingual Plane 	+ Supplementary Multilingual Plane"
	CanonicalCombiningClasses := Dictionary new.
	DecompositionMapping := Dictionary new.
	CompositionMapping := Dictionary new.
	(DirectoryEntry smalltalkImageDirectory // 'UnicodeData.txt') readStreamDo: [ :strm |
		[strm atEnd] whileFalse: [
			fields := strm nextLine substringsSeparatedBy: $;.
			(#(4 5 6) includes: fields first size) ifFalse: [ fields first print. self error: 'Bad UnicodeData.txt file' ].
			codePoint := ('16r', fields first) asNumber.
			codePointName := fields at: 2.
			generalCategory := fields at: 3.
			codePoint <= 16r1FFFF ifTrue: [
				({ 'Lu'. 'Lt' } includes: generalCategory) ifTrue: [ UppercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Ll'. 'Lo' } includes: generalCategory) ifTrue: [ LowercaseLettersTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Pc'. 'Pd'. 'Po'. 'Sm'. 'Sc'. 'Sk'. 'So' } includes: generalCategory) ifTrue: [ SymbolsLikeTable bitBooleanAt: codePoint+1 put: true ].
				({ 'Mn'. 'Mc'. 'Me' } includes: generalCategory) ifTrue: [ DiacriticalMarksTable bitBooleanAt: codePoint+1 put: true ]].
			canonicalCombiningClass := (fields at: 4) asNumber.
			canonicalCombiningClass = 0 ifFalse: [
				CanonicalCombiningClasses at: codePoint put: canonicalCombiningClass ].
			characterDecompositionMapping := fields at: 6.
			(characterDecompositionMapping size > 0 and: [ characterDecompositionMapping first ~~ $< ]) ifTrue: [
				decomposition := characterDecompositionMapping substrings collect: [ :s | ('16r', s) asNumber].
				DecompositionMapping at: codePoint put: decomposition.
				decomposition size > 1 ifTrue: [
					composition := CompositionMapping at: decomposition first ifAbsentPut: [Dictionary new].
					composition at: decomposition second put: codePoint.
					decomposition size > 2 ifTrue: [self error: decomposition printString print].
					]].
			"
			uppercaseMapping := fields at: 13. lowercaseMapping := fields at: 14. titlecaseMapping := fields at: 15.
			Random next > 10.999 | (generalCategory = 'So') ifTrue: [
				{codePoint hex. codePointName. generalCategory} print ].
			decimalDigitValue := fields at: 7. digitValue := fields at: 8. numericValue := fields at: 9.
			decimalDigitValue isEmpty & digitValue isEmpty & numericValue isEmpty ifFalse: [
				{'numeric'. codePoint. codePointName. generalCategory. decimalDigitValue. digitValue. numericValue} print].
			"
			]].
	self initializeNamedCharactersMap.! !
!Character class methodsFor: 'instance creation' stamp: 'jmv 1/8/2024 12:13:35' prior: 16811064!
   codePoint: anInteger
	"Answer the Character whose value is anInteger.
	
	self assert: (Character codePoint: 16r41) == $A.
	self assert: (Character codePoint: 16r20AC) == $€.
	"

	<primitive: 170>
	^self primitiveFailed! !
!Character class methodsFor: 'static state' stamp: 'jmv 7/25/2024 14:36:48' prior: 16811552!
   basicLookupTables
	| lowercaseMappingTable uppercaseMappingTable unaccentedTable |
	lowercaseMappingTable := Array new: 256.
	uppercaseMappingTable := Array new: 256.
	unaccentedTable := ByteArray new: 256.
	0
		to: 255
		do: [ :idx | | char |
			"Default to an identity mapping with a false truth mapping"
			char := self codePoint: idx.
			lowercaseMappingTable
				at: idx + 1 put: char.
			uppercaseMappingTable
				at: idx + 1 put: char.
			unaccentedTable at: idx + 1 put: idx].
	"Now override as needed"
	Character uppercaseLowercaseAndUnaccentedLetters do: [ :group | | uppercase lowercase |
		(group first == $ÿ or: [group first == $ß])
			ifFalse: [ | lowercaseChar uppercaseChar |
				uppercase := group first codePoint.
				lowercase := group second codePoint.
				lowercaseChar := self codePoint: lowercase.
				uppercaseChar := self codePoint: uppercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar;
					at: uppercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: uppercaseChar;
					at: uppercase + 1 put: uppercaseChar.
				group size > 2
					ifTrue: [|unaccentedUppercase unaccentedLowercase|
						unaccentedUppercase := group third codePoint.
						unaccentedLowercase := group fourth codePoint.
						unaccentedTable
							at: uppercase+1 put: unaccentedUppercase;
							at: lowercase+1 put: unaccentedLowercase]]
			ifTrue: [ | lowercaseChar |
				lowercase := group first codePoint.
				lowercaseChar := self codePoint: lowercase.
				lowercaseMappingTable
					at: lowercase + 1 put: lowercaseChar.
				uppercaseMappingTable
					at: lowercase + 1 put: lowercaseChar.
				group size > 1
					ifTrue: [|unaccentedLowercase|
						unaccentedLowercase := group second codePoint.
						unaccentedTable
							at: lowercase+1 put: unaccentedLowercase]]].
	^{ lowercaseMappingTable. uppercaseMappingTable. unaccentedTable}.! !
!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 7/3/2023 12:18:01' prior: 16889227!
                         isCloseWindowShortcut

	self flag: #definesKeyboardShortcuts.
	^ (self commandAltKeyPressed or: [ self controlKeyPressed ])
		and: [self keyCharacter == $w].! !
!KeyboardEvent methodsFor: 'testing' stamp: 'HAW 9/23/2018 21:04:09' prior: 16889235!
         isColon

	^ self keyCharacter == $:.! !
!KeyboardEvent methodsFor: 'testing' stamp: 'db 7/1/2020 17:09:47' prior: 16889292!
    isQuestionMark
	
	^ self keyCharacter == $? ! !
!KeyboardEvent methodsFor: 'platform peculiarities' stamp: 'jmv 12/29/2011 10:52' prior: 16889322!
             isCmdAltGreaterThan
	"Answer true if the user pressed cmd/Alt + $>
	We need this special method because of platform differences, especially the weird way the Mac VM reports keystrokes if cmd or control are held down (the character answered is usually the unshifted one, even if shift is pressed, depending on keyboard layout!!)
	Note: On the Mac, this code handles US, German and Spanish layouts. Add more as needed...
	Tweak both #isCmdAltLessThan and #isCmdAltGreaterThan !!"
	| char shifted |

	self commandAltKeyPressed ifFalse: [ ^false ].

	char := self keyCharacter.
	"Do the easy test for non macOS"
	Smalltalk platformName = 'Mac OS' ifFalse: [
		^char == $> ].

	shifted := self shiftPressed.
	
	"For Mac keyboard layouts where $> is unshifted (Is there such a layout?)"
	(shifted not and: [ char == $> ])
		ifTrue: [ ^true ].

	"For Mac keyboard layouts where $> is shift + $. (for example US).
	As cmd is pressed, the Mac VM gives us the unshifted character, i.e. $."
	(shifted and: [ char == $. ])
		ifTrue: [ ^true ].

	"For Mac keyboard layouts where $> is shift + $<.
	In this case, in the German layout, the Mac VM gives us $> (surprising!!)"
	(shifted and: [ char == $> ])
		ifTrue: [ ^true ].

	"For Mac keyboard layouts where $> is shift + $<
	In the Spanish layout, as cmd is pressed, the Mac VM gives us the unshifted character, i.e. $<"
	(shifted and: [ char == $< ])
		ifTrue: [ ^true ].

	"We guess it is not cmd + $> then..."
	^false! !
!KeyboardEvent methodsFor: 'platform peculiarities' stamp: 'jmv 12/29/2011 10:52' prior: 16889371!
      isCmdAltLessThan
	"Answer true if the user pressed cmd/Alt + $<
	We need this special method because of platform differences, especially the weird way the Mac VM reports keystrokes if cmd or control are held down (the character answered is usually the unshifted one, even if shift is pressed, depending on keyboard layout!!)
	Note: On the Mac, this code handles US, German and Spanish layouts. Add more as needed...
	Tweak both #isCmdAltLessThan and #isCmdAltGreaterThan !!"
	| char shifted |

	self commandAltKeyPressed ifFalse: [ ^false ].

	char := self keyCharacter.
	"Do the easy test for non macOS"
	Smalltalk platformName = 'Mac OS' ifFalse: [
		^char == $< ].

	shifted := self shiftPressed.
	
	"For Mac keyboard layouts where $< is unshifted (for example, German and Spanish)"
	(shifted not and: [ char == $< ])
		ifTrue: [ ^true ].

	"For Mac keyboard layouts where $< is shift + $, (for example US).
	As cmd is pressed, the Mac VM gives us the unshifted character, i.e. $,"
	(shifted and: [ char == $, ])
		ifTrue: [ ^true ].

	"We guess it is not cmd + $< then..."
	^false! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 12/21/2018 09:21:39' prior: 16905723!
       focusKeyboardFor: aKeyboardEvent

	"If aKeyboardEvent ctrl-tab or shift-ctrl-tab use it to navigate keyboard focus.
	Warning: This doesn't work on Windows... the event is not sent"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent controlKeyPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand keyboardFocusPrevious ]
				ifFalse: [ aKeyboardEvent hand keyboardFocusNext ].
			^ true ].
	"On Windows use at least some keystroke to navigate morphs... even shift-Tab that should navigate backwards"
"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent shiftPressed and: [ aKeyboardEvent rawMacOptionKeyPressed not ]])
		ifTrue: [
			aKeyboardEvent hand keyboardFocusNext.
			^ true ].
"

	"Cycle through windows with cmdAlt + < and cmdAlt + >.
	VM and platform peculiarities are hidden in #isCmdAltLessThan and #isCmdAltGreaterThan"
	"This was done as an attempt to mimic the Mac OSX keystrokes for 'Move focus to next window in active application'. Unfortunately, it only works if OS X is set to use any other keys for this. If (as for example, with German defaults), OS-X uses these keystrokes, then they are not sent to the VM. This is a long standing issues in Chromium and PhotoShop, for example..."
	self disableCode: [
		aKeyboardEvent isCmdAltLessThan ifTrue: [
			aKeyboardEvent hand activatePreviousWindow.
			^true ].
		aKeyboardEvent isCmdAltGreaterThan ifTrue: [
			aKeyboardEvent hand activateNextWindow.
			^true ]].
	"Alternative for Mac OS-X: option-Tab and option-shift-Tab"
	(aKeyboardEvent keyValue = 9 and: [ aKeyboardEvent rawMacOptionKeyPressed ])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand activatePreviousWindow ]
				ifFalse: [ aKeyboardEvent hand activateNextWindow ].
			^ true ].
	"Alternative for non-Mac OS-X: alt-< and alt->"
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter == $< ]) ifTrue: [
		aKeyboardEvent hand activatePreviousWindow.
		^true ].
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter == $> ]) ifTrue: [
		aKeyboardEvent hand activateNextWindow.
		^true ].
	^false! !
!Morph methodsFor: 'submorphs-menus' stamp: 'jmv 11/22/2024 11:35:30' prior: 16908370!
  getMenu
	"Answer the right-click (contextual) menu."
	"Spec for the menu and shortcut keys.
	Each entry is
		#(itemId 			'menu item label'    shortcut    receiverGetter    selector     iconOrNil(optional)    'helpText(optional)'    selectorArgument(optional))
		- itemId is a number (integer or float). It specifies the position of the item in the menu, and is also an id, allowing for overrides and deletions.
		- label is a string or symbol. Symbol means self updating menu entry. nil means just keyboard shortcut, no menu entry.
		- shortcut is a Character or nil
		- receiverGetter sent to the widget to get the actual receiver for selector.
			Typically #window, #model or #editor. If nil, receiver is the widget itself.
		- selector is #aSymbol. Usually no arguments, or one single argument in 8th entry. 
			If a Number (multiple of 1000), indicates a subMenu. ItemsIds must be in range. See BrowserWindow>>#classListMenuSpec.
			If nil, the menu entry is created but disabled. The keyboard shortcut is disabled too.
		- icon may be nil. It is also optional (but must be there if there is help text)
		- help text is optional
		- selectorArgument is optional. If selector takes an argument, and selectorArgument is not provided, the argument is self.
	Entries of size 1 mean 'remove menu item'.
	Entries of size 2 are separators.
	An entry of size 3 (usually with key 0 and at the first position), if present, tells a menu title, whether to #addStayUpIcons.
	"

	| menuNshortcutsSpecs itemSpec menu submenus |
	menuNshortcutsSpecs := self allMenuNshortcutsSpecs.
	menuNshortcutsSpecs ifEmpty: [ ^nil ].
	menu := MenuMorph new.
	submenus := nil.
	menuNshortcutsSpecs keys sorted do: [ :key |
		itemSpec := menuNshortcutsSpecs at: key.
		itemSpec size =1 ifTrue: [
				"Do nothing. This is a marker for removing a previously provided entry" ]
			ifFalse: [ itemSpec size = 2 ifTrue: [
				itemSpec second first == $X ifFalse: [ "Compatibility. Also a marker for removing previous entries."
					self addLineTo: menu fromSpec: itemSpec submenus: submenus ]]
			ifFalse: [ itemSpec size = 3 ifTrue: [
				self addTitleTo: menu fromSpec: itemSpec ]
			ifFalse: [ itemSpec fifth isNumber ifTrue: [
				submenus ifNil: [submenus := Dictionary new ].
				self addSubmenuTo: menu fromSpec: itemSpec submenus: submenus ]
			ifFalse: [
				self addItemTo: menu fromSpec: itemSpec submenus: submenus ]]]]].
	^ menu! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 5/1/2024 15:54:13' prior: 16894183!
                            contentsWithMarkers: aString inverse: invertMarkers
	"Set the menu item entry. Parse aString for embedded markers."

	| markerIndex marker |
	contentString := nil.	"get rid of old"
	self removeAllMorphs.	"get rid of old markers if updating"
	(aString notEmpty and: [aString first == $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	contentString := aString.	"remember actual string"
	marker := ((marker = '<on>' or: [marker = '<yes>']) xor: invertMarkers)
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents: (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph newWith: marker.
	self addMorphFront: marker position: 1@(self morphHeight +1- marker morphHeight // 2).
	marker lock.! !
!BrowserWindow class methodsFor: 'services' stamp: 'HAW 6/27/2020 19:48:57' prior: 16800429!
   classNamesFrom: potentialClassNames with: pattern matching: toMatch 

	^ (pattern last == $. or: [pattern last == $ ])
		ifTrue: [potentialClassNames select: [:className | className asLowercase = toMatch]]
		ifFalse: [potentialClassNames select: [:className | className includesSubstring: toMatch caseSensitive: false]]! !
!HierarchyBrowserWindow class methodsFor: 'examples' stamp: 'jmv 5/21/2022 22:33:45' prior: 16875783!
                       example2
	"Put up a ClassListBrowser that shows all classes whose names start with the letter S"

	self forClassesNamed: (Smalltalk allClasses collect: [:c | c name] thenSelect: [:aName | aName first == $S]) title: 'All classes starting with S'

"HierarchyBrowserWindow example2"! !
!WorldMorph methodsFor: 'events' stamp: 'jmv 9/19/2024 12:36:07' prior: 17009192 overrides: 16905314!
                               keyStroke: aKeyboardEvent

	self flag: #definesKeyboardShortcuts.
	super keyStroke: aKeyboardEvent.
	aKeyboardEvent wasHandled ifTrue: [ ^self ].

	"Handle a keystroke event."
	(aKeyboardEvent commandAltKeyPressed or: [ aKeyboardEvent controlKeyPressed ])
		ifTrue: [
			aKeyboardEvent keyCharacter == $b ifTrue: [
				Smalltalk browseFull: nil.
				aKeyboardEvent wasHandled: true. ].
			aKeyboardEvent keyCharacter == $f ifTrue: [
				Smalltalk findAndBrowseClass.
				aKeyboardEvent wasHandled: true. ].
			aKeyboardEvent keyCharacter == $F ifTrue: [
				Smalltalk findInSourceCode.
				aKeyboardEvent wasHandled: true. ].
		].
	"aKeyboardEvent keyCharacter print."! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 2/21/2024 15:37:28' prior: 16861855!
       expandTildeFor: aString

	aString size = 0 ifTrue: [ ^aString ].
	aString first == $~ifFalse: [ ^aString ].
	"Basic tilde expansion. Consider $~ to mean user's home folder, if possible.
	See, for example, https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html"
	Smalltalk at: #OSProcess
		ifPresent: [ :osProcess |
			(osProcess thisOSProcess environmentAt: 'HOME')
				ifNotNil: [ :homeVariable |
					^homeVariable, (aString copyFrom: 2 to: aString size) ]
				ifNil: [ self error: 'The $HOME variable could not be resolved' ]]
		ifAbsent: [
			self error: 'Use of tilde (~) to mean $HOME folder requires OSProcess' ]! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'bp 5/10/2024 11:25:01' prior: 16861878!
        extensionFor: pathName 
	"In original FileMan, accepts only a localName (withouth path separators). Modify it for Cuis for also allowing them, as it is traditional in Squeak / Cuis.
	
	FileIOAccessor default extensionFor: 'writings.txt'
	FileIOAccessor default extensionFor: 'folder.ext/file'
	FileIOAccessor default extensionFor: 'optionalstuff.pck.st'
	FileIOAccessor default extensionFor: 'code.cs.st'
	FileIOAccessor default extensionFor: 'code.cs'
	"
	| index |
	{ '.cs.st' . '.pck.st'. '.ws.st' } do: [ :specialExtension |
		(pathName endsWith: specialExtension)
			ifTrue: [ ^specialExtension copyFrom: 2 to: specialExtension size ]].
	index := pathName
				findLast: [ :c | c == $.].
	^ (index = 0 or: [ pathName indexOfLastPathSeparator > index ])
		ifTrue: ['']
		ifFalse: [pathName copyFrom: index + 1 to: pathName size]! !
!FileIOAccessor methodsFor: 'utilities' stamp: 'jmv 12/20/2024 16:32:24' prior: 50337717!
   splitNameVersionExtensionFor: fileName
	" answer an array with the root name, version # and extension.
	See comment in senders for more details"

	self baseNameAndExtensionFor: fileName do: [ :b :extension |
		| baseName version i j |
		baseName := b.
		i := j := baseName findLast: [:c | c isDigit not].
		i = 0
			ifTrue: [version := 0]
			ifFalse: [
				(baseName at: i) == $.
					ifTrue: [
						version := (baseName copyFrom: i+1 to: baseName size) asNumber.
						j := j - 1]
					ifFalse: [version := 0].
				baseName := baseName copyFrom: 1 to: j ].
		^ Array with: baseName with: version with: extension ]! !
!FileIOAccessor methodsFor: 'testing' stamp: 'pb 5/25/2016 00:32' prior: 16862144!
  onUnix
	^self pathNameDelimiter == $/! !
!FileIOAccessor methodsFor: 'testing' stamp: 'pb 5/25/2016 00:32' prior: 16862148!
    onWindows
	^self pathNameDelimiter == $\! !
!DirectoryEntry methodsFor: 'testing' stamp: 'jmv 10/9/2019 11:28:39' prior: 16848946!
                             isRegularDirectory
	"hidden convention in Unix"
	name first == $. ifTrue: [ ^false ].
	"in MacOS, applications are actually directories, but are usually not treated as such"
	self extension = 'app' ifTrue: [ ^false ].
	"in MacOS, .bundle directories, are resource packages"
	self extension = 'bundle' ifTrue: [ ^false ].
	^true! !
!CodePackage methodsFor: 'testing' stamp: 'jmv 3/16/2012 10:48' prior: 16823930!
    category: categoryName matches: prefix
	| prefixSize catSize |
	categoryName ifNil: [ ^false ].
	catSize := categoryName size.
	prefixSize := prefix size.
	catSize < prefixSize ifTrue: [ ^false ].
	(categoryName findString: prefix startingAt: 1 caseSensitive: false) = 1
		ifFalse: [ ^false ].
	^(categoryName at: prefix size + 1 ifAbsent: [ ^true ]) == $-! !
!CodePackage methodsFor: 'testing' stamp: 'jfr 8/3/2024 10:43:36' prior: 16824032!
     isForeignClassExtension: categoryName
	"Answer true if <categoryName> is a foreign class extension reference"
	
	categoryName ifNil: [ ^false ].
	(categoryName size = 0) ifTrue:[^false].
	^ categoryName first == $* and: [(self isYourClassExtension: categoryName) not]! !
!PreferenceSet class methodsFor: 'services' stamp: 'jmv 12/19/2024 12:47:39' prior: 50337870!
                   readAndApplyUserPrefs
	"
	PreferenceSet readAndApplyUserPrefs
	"
	| file |
	file := DirectoryEntry userBaseDirectory // 'UserPrefs.txt'.
	file exists ifTrue: [
		file readStreamDo: [ :stream |
			[ stream atEnd ] whileFalse: [ | line parts |
				line := stream nextLine.
				parts := line substringsSeparatedBy: $=.
				[ | pref value |
					pref := Preferences instanceAt: parts first asSymbol.
					value := parts second.
					value first == $# ifTrue: [ value := (value withoutPrefix: '#') asSymbol ].
					pref value: value.
					pref justReadFromDisk.
				]
					on: Error
					do: [ :error |
						'--- UserPrefts.txt Error' print.
						error print.
						line print ].
				]]].! !
!Utilities class methodsFor: 'summer97 additions' stamp: 'jmv 9/27/2016 21:41:18' prior: 16997761!
            classFromPattern: pattern withCaption: aCaption
	"If there is a class whose name exactly given by pattern, return it.
	If there is only one class in the system whose name matches pattern, return it.
	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.
	This method ignores tab, space, & newline characters in the pattern"

	| toMatch potentialClassNames classNames exactMatch index |
	(toMatch :=  pattern copyWithoutAll:
			{Character space.  Character newLineCharacter.  Character tab})
		isEmpty ifTrue: [^ nil].
	Symbol hasInterned: toMatch ifTrue:
		[:patternSymbol | Smalltalk at: patternSymbol ifPresent:
			[:maybeClass | (maybeClass class isMeta) ifTrue: [^ maybeClass]]].

	toMatch := (toMatch copyWithout: $.) asLowercase.
	potentialClassNames := Smalltalk classNames asOrderedCollection.
	classNames := pattern last == $. 
		ifTrue: [potentialClassNames select:
					[:nm |  nm asLowercase = toMatch]]
		ifFalse: [potentialClassNames select: 
					[:n | n includesSubstring: toMatch caseSensitive: false]].
	classNames isEmpty ifTrue: [^ nil].
	exactMatch := classNames detect: [:each | each asLowercase = toMatch] ifNone: nil.

	index := classNames size = 1
		ifTrue:	[1]
		ifFalse:	[exactMatch
			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUpWithCaption: aCaption]
			ifNotNil: [classNames addFirst: exactMatch.
				(PopUpMenu labelArray: classNames lines: #(1)) startUpWithCaption: aCaption]].
	index = 0 ifTrue: [^ nil].
	^ Smalltalk at: (classNames at: index) asSymbol

"
	Utilities classFromPattern: 'CharRecog' withCaption: 'xx'
	Utilities classFromPattern: 'rRecog' withCaption: 'xx'
	Utilities classFromPattern: 'znak' withCaption: 'xx'
	Utilities classFromPattern: 'orph' withCaption: 'xx'
"
! !
!Editor methodsFor: 'new selection' stamp: 'HAW 10/28/2024 12:13:31' prior: 16851952!
                wordRangeIncluding: aPositionInText
	"Select delimited text or word--the result of double-clicking."

	| direction level string here hereChar start sSize |
	string := self privateCurrentString.
	sSize := string size.
	sSize < 2 ifTrue: [^1 to: 1].
	here := aPositionInText min: sSize max: 2.
	"no delimiters -- select a token"
	direction := -1.
	level := 1.
	[level > 0 and: [direction > 0
			ifTrue: [here < sSize]
			ifFalse: [here > 1]]]
		whileTrue: [
			hereChar := string at: (here := here + direction).
			"token scan goes left, then right"
			hereChar isValidInIdentifiers 	"Consider $: as a word separator"
				ifTrue: [
					here = 1
						ifTrue: [
							start := 1.
							"go right if hit string start"
							direction := 1]]
				ifFalse: [
					direction < 0
						ifTrue: [
							start := here + 1.
							"go right if hit non-token"
							direction := 1]
						ifFalse: [level := 0]]].
	level > 0 ifTrue: [
		here := here + direction ].
	"If a word ends with $: (a keyword), consider it part of the word"
	hereChar == $: ifTrue: [here := here + 1].
	^start to: here - 1! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/26/2024 11:54:17' prior: 16852165!
                             normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| character i replacement |

	"Ignore keystrokes that could be keyboard shortcuts, even if not defined as such."
	((aKeyboardEvent keyValue between: 32 and: 126) and: [ aKeyboardEvent commandAltKeyPressed ])
		ifTrue: [ ^true ].

	"Convert strings like '\+161 ' (š) to unicode"
	aKeyboardEvent isSpace ifTrue: [ | string |
		string := self privateCurrentString.
		self pointIndex - 1 to: (self pointIndex - 7 max: 1) by: -1 do: [ :index |
		(string at: index) == $\ ifTrue: [ | key |
			key := string copyFrom: index + 1 to: self pointIndex - 1.
			(key size > 2 and: [ (key at: 1) == $+ ])
				ifTrue: [ | stream number value |
					stream := ReadStream on: key asUppercase from: 2 to: key size.
					[ number := Integer readFrom: stream  base: 16 ] on: Error do: [ ^ false ].
					value := Character codePoint: number.
					self
						selectFrom: index to: self pointIndex - 1;
						replaceSelectionWith: (UnicodeString with: value).
						^ false ] ] ] ].
	character := aKeyboardEvent keyCharacter.
	"Linux VMs don't automatically replace combining marks + space with ASCII,
	as Windows and Mac VMs do. It seems it is an app responsibility to do that in Linux."
	character isDiacriticalMark ifTrue: [
		i := self pointIndex-1.
		(i > 0 and: [ (self privateCurrentString at: i) == $  ]) ifTrue: [
			replacement := character caseOf: {
				[ `Character codePoint: 16r300` ] -> [ '`' ].
				[ `Character codePoint: 16r301` ] -> [ '''' ].
				[ `Character codePoint: 16r302` ] -> [ '^' ].
				[ `Character codePoint: 16r303` ] -> [ '~' ].
				[ `Character codePoint: 16r308` ] -> [ '"' ].
			} otherwise: [].
			replacement notNil ifTrue: [
				self selectFrom: i to: i; replaceSelectionWith: replacement.
				^ false ]
			]
		].
	self addString: (UnicodeString with: character).
	^false! !
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'jmv 6/10/2024 17:24:53' prior: 16954712 overrides: 16982344!
      encloseWith: aCharacter
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| startIndex stopIndex oldSelection new enlargedBy |
	"This implementation is only for commenting and uncommenting code.
	Other cases are handled by the super implementation.
	This implementation only handles String and discards Text attributes."
	aCharacter == $" ifFalse: [
		^super encloseWith: aCharacter ].

	startIndex := self startIndex.
	stopIndex := self stopIndex.
	oldSelection := self selection string.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) == $"
				and: [(model actualContents at: stopIndex) == $"]])
		ifTrue: [
			"already enclosed in double colons; make selection no longer a comment"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection withDoubleColonsUndoubled ]
		ifFalse: [
			"not enclosed in double colons; make selection a comment"
			new := oldSelection withDoubleColonsDoubled.
			enlargedBy := new size - oldSelection size.
			self replaceSelectionWith: $" asString, new, $" asString.
			self selectFrom: startIndex+1 to: stopIndex + enlargedBy ].
	^ true.! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 9/17/2016 18:06:28' prior: 16954795!
                       explainChar: string
	"Does string start with a special character?"

	| char |
	char := string at: 1.
	char == $. ifTrue: [^'Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float).'].
	char == $' ifTrue: [^'The characters between two single quotes are made into an instance of class String'].
	char == $" ifTrue: [^'Double quotes enclose a comment.  Smalltalk ignores everything between double quotes.'].
	char == $# ifTrue: [^'The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants.'].
	(char == $( or: [char == $)]) ifTrue: [^'Expressions enclosed in parenthesis are evaluated first'].
	(char == $[ or: [char == $]]) ifTrue: [^'The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockClosure and is usually passed as an argument.'].
	(char == ${ or: [char == $}]) ifTrue: [^ 'A sequence of expressions separated by periods, when enclosed in curly braces, are evaluated to yield the elements of a new Array'].
	(char == $< or: [char == $>]) ifTrue: [^'<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails.'].
	char == $^ ifTrue: [^'Up arrow means return from this method.  The value returned is the expression following the ^'].
	char == $| ifTrue: [^'Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code.'].
	char == $_ ifTrue: [^'Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it.'].
	char == $; ifTrue: [^'Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon.'].
	char == $: ifTrue: [^'A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withNewLines, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon).'].
	char == $$ ifTrue: [^'The single character following a dollar sign is made into an instance of class Character'].
	char == $- ifTrue: [^'A minus sign in front of a number means a negative number.'].
	char == $e ifTrue: [^'An e in the middle of a number means that the exponent follows.'].
	char == $r ifTrue: [^'An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base.'].
	char = Character space ifTrue: [^'the space Character'].
	char = Character tab ifTrue: [^'the tab Character'].
	char = Character cr ifTrue: [^'the carriage return Character'].
	char = Character lf ifTrue: [^'newline. The line feed Character'].
	^nil! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 9/22/2024 22:18:22' prior: 16955013!
    explainDelimiter: string
	"Is string enclosed in delimiters?"

	| str |
	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"
	(string first = string last) ifTrue:
			[^ self explainChar: (String with: string first)]
		ifFalse:
			[(string first == $( and: [string last == $)]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first == $[ and: [string last == $]]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first == ${ and: [string last == $}]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first == $< and: [string last == $>]) ifTrue:
				[^ self explainChar: (String with: string first)].
			(string first == $# and: [string last == $)]) ifTrue:
				[^'An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array.'].
			string first == $# ifTrue:
				[^'An instance of class Symbol.'].
			(string first == $$ and: [string size = 2]) ifTrue:
				[^'An instance of class Character.  This one is the character ', (String with: string last), '.'].
			(string first == $:) ifTrue:
				[str := string allButFirst.
				(self explainTemp: str) ifNotNil: [
					^'An argument to this block will be bound to the temporary variable ',
						str, '.']]].
	^ nil! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 5/22/2022 20:43:16' prior: 16955167!
           explainNumber: string 
	"Is string a Number?"

	| strm c |
	(c := string at: 1) isDigit ifFalse: [(c == $- and: [string size > 1 and: [(string at: 2) isDigit]])
			ifFalse: [^nil]].
	strm := string readStream.
	c := Number readFrom: strm.
	strm atEnd ifFalse: [ ^nil ].
	c printString = string
		ifTrue: [ ^ string , ' is a ' , c class name ]
		ifFalse: [ ^ string , ' (= ' , c printString , ') is a ' , c class name ]! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 11/26/2024 10:25:33' prior: 16955183!
 explainPartSel: string 
	"Is this a fragment of a multiple-argument selector sent in this method?"
	| lits whole reply classes s msg |
	(msg := self codeProvider selectedMessageName) ifNil: [^ nil].  "not in a message"
	string last == $: ifFalse: [^ nil].
	"Name of this method"
	lits := Array with: msg.
	(whole := lits detect: [:each | (each keywords detect: [:frag | frag = string]
					ifNone: nil) notNil]
				ifNone: nil)
		ifNotNil: [
			reply := ', which is the selector of this very method!!'.
			s := self class plateA]
		ifNil: [ 
			"Selectors called from this method"
			lits := (self codeProvider selectedClassOrMetaClass compiledMethodAt: msg) messages.
			(whole := lits detect: [:each | (each keywords detect: [ :frag | frag = string ]
							ifNone: nil) notNil]
						ifNone: nil) notNil
				ifFalse: [string = 'primitive:'
					ifTrue: [^self explainChar: '<']
					ifFalse: [^nil]].
			reply := '.'.
			s := self class plateB].
		classes := Smalltalk allClassesImplementing: whole.
		classes size > 12
			ifTrue: [classes := 'many classes']
			ifFalse: [classes := 'these classes ' , classes printString].
		^ String streamContents: [:str |
			str
				nextPutAll: string;
				nextPutAll: ' is one part of the message selector ';
				nextPutAll: whole;
				nextPutAll: reply;
				nextPutAll: '  It is defined in ';
				nextPutAll: classes;
				nextPutAll: s]! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 6/10/2024 16:45:42' prior: 16955789!
                    argPrev
	"Invoked by cmd-Q.
	 Search backwards from the start of the selection for a colon followed by
		a space.  Place the text cursor after the space.  If none are found, place the
		text cursor at the start of the text.."

	| t i |
	t := model actualContents.
	i := self stopIndex.
	i > 1 ifTrue: [
		i := i -2.
		[i > 0 and: [ (t at: i) ~~ $  or: [(t at: i-1) ~~ $: ]]] whileTrue: [
			i := i -1 ].
		self deselectAndPlaceCursorAt: i + 1.
	].
	^true! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 12/7/2022 09:05:55' prior: 16955821 overrides: 16852159!
                            newLine: aKeyboardEvent
	"Replace the current text selection with a newLine (i.e. LF) followed by as many tabs
	as there are leading tabs on the current line (+/- bracket count)."

	| char s i tabCount stopIndex newLineString |
	s := self privateCurrentString.
	stopIndex := self stopIndex.
	i := stopIndex.
	tabCount := 0.
	[ (i := i-1) > 0 and: [ (char := s at: i) isLineSeparator not ] ] whileTrue: [
		"Count brackets"
		char == $[ ifTrue: [tabCount := tabCount + 1].
		char == $] ifTrue: [tabCount := tabCount - 1]].
	[ (i := i + 1) < stopIndex and: [ (char := s at: i) isSeparator ] ] whileTrue: [
		"Count leading tabs"
		char = Character tab ifTrue: [ tabCount := tabCount + 1 ]].
	"Now inject newline with tabCount tabs, generating a new undoable command"
	newLineString := UnicodeString streamContents: [ :strm | strm newLineTab: tabCount ].
	model startNewUndoRedoCommand.
	self replaceSelectionWith: newLineString.
	^ false! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 10/22/2024 10:56:14' prior: 16955854 overrides: 50353590!
                          normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| string key |

	"To enable:
	Preferences name: #autoReplaceNamedCharacters category: #gui value: true.
	Preferences saveToDisk: #autoReplaceNamedCharacters.
	PreferenceSet saveUserPrefs.
	"
	"To disable:
	Preferences name: #autoReplaceNamedCharacters category: #gui value: false.
	Preferences saveToDisk: #autoReplaceNamedCharacters.
	PreferenceSet saveUserPrefs.
	"
	"Allow to enter named (otherwise untypable) characters like the alpha greek letter as \alpha."
	(Preferences at: #autoReplaceNamedCharacters) ifTrue: [
		aKeyboardEvent keyCharacter isLetter ifFalse: [
			string := self privateCurrentString.
			"Look backwards and find a character that is not a letter (we want to find '\' just a few characters behind):"
			self pointIndex - 1 to: (self pointIndex - 20 max: 1) by: -1 do: [:i|
				(string at: i) == $\ ifTrue: [
					key := string copyFrom: i + 1 to: self pointIndex - 1.
					Character namedCharactersMap at: key ifPresent: [ :value |
						self selectFrom: i to: self pointIndex - 1; replaceSelectionWith: (UnicodeString with: value) ].
					^ super normalCharacter: aKeyboardEvent]]]].

	^ super normalCharacter: aKeyboardEvent! !
!TextAction methodsFor: 'as yet unclassified' stamp: 'tk 12/16/97 16:44' prior: 16980389!
                          analyze: aString
	"Analyze the selected text to find both the parameter to store and the text to emphesize (may be different from original selection).  Does not return self!!.  May be of the form:
3+4
<3+4>
Click Here<3+4>
<3+4>Click Here
"
	"Obtain the showing text and the instructions"
	| b1 b2 trim param show |
	b1 := aString indexOf: $<.
	b2 := aString indexOf: $>.
	(b1 < b2) & (b1 > 0) ifFalse: ["only one part"
		param := self validate: aString.
		^ Array with: param with: (param size = 0 ifTrue: [nil] ifFalse: [param])].
	"Two parts"
	trim := aString withBlanksTrimmed.
	trim first == $< 
		ifTrue: [ trim last == $>
			ifTrue: ["only instructions" 
				param := self validate: (aString copyFrom: b1+1 to: b2-1).
				show := param size = 0 ifTrue: [nil] ifFalse: [param]]
			ifFalse: ["at the front"
				param := self validate: (aString copyFrom: b1+1 to: b2-1).
				show := param size = 0 ifTrue: [nil] 
						ifFalse: [aString copyFrom: b2+1 to: aString size]]]
		ifFalse: [ trim last == $>
			ifTrue: ["at the end"
				param := self validate: (aString copyFrom: b1+1 to: b2-1).
				show := param size = 0 ifTrue: [nil] 
						ifFalse: [aString copyFrom: 1 to: b1-1]]
			ifFalse: ["Illegal -- <> has text on both sides"
				show := nil]].
	^ Array with: param with: show
! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'jmv 10/22/2024 16:38:26' prior: 16784554!
                     lastCharacterWantsAutoComplete

	| lastCharIndex lastCharacter |
	textMorph editor hasSelection ifTrue: [ ^ false ].

	lastCharIndex := textMorph editor startIndex-1.
	lastCharIndex <= 0 ifTrue: [ ^ false ].
	lastCharacter := model actualContents at: lastCharIndex.

	^ lastCharacter isAlphaNumeric or: [
		lastCharacter isValidInBinarySelectors or: [ lastCharacter == $: ]]! !
!AutoCompleter methodsFor: 'entries' stamp: 'HAW 2/8/2019 17:27:05' prior: 16784635!
                 insertSelected
	
	| entry editor selEnd str |
	
	textMorph ifNil: [ ^false ].
	
	entry := self selectedEntryFormatted.
	(self canSelect: entry) ifFalse: [ ^true ].
	
	editor := textMorph editor.
	str := model actualContents string.
	selEnd := position.
	[selEnd < str size and: [ (str at: selEnd+1) tokenish ]] whileTrue: [ selEnd := selEnd + 1 ].
	(selEnd < str size and: [ (str at: selEnd+1) == $ ]) ifTrue: [ selEnd := selEnd + 1].
	editor selectFrom: position-prefix size+1 to: selEnd.
	editor
		replaceSelectionWith: entry;
		deselectAndPlaceCursorAt: position - prefix size + 1 + (self newCursorPosition: entry).
	textMorph redrawNeeded.
	menuMorph delete.
	menuMorph := nil.
	
	^ true! !
!MethodReference methodsFor: 'testing' stamp: 'HAW 6/11/2022 20:04:20' prior: 16902354!
                 isMessageListTitle

	^(self actualClass isKindOf: Object) and: [methodSymbol first == $_]
! !
!ChangeSet methodsFor: 'class changes' stamp: 'jmv 6/1/2022 11:07:41' prior: 16807790!
           fatDefForClass: class

	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |
	newDef := class definition.
	oldDef := (self changeRecorderFor: class) priorDefinition.
	oldDef ifNil: [^ newDef].
	oldDef = newDef ifTrue: [^ newDef].

	oldStrm := oldDef readStream.
	newStrm := newDef readStream.
	outStrm := String writeStream.

	"Merge inst vars from old and new defs..."
	oldStrm upToAll: 'instanceVariableNames'; upTo: $'.
	outStrm 
		nextPutAll: (newStrm upToAll: 'instanceVariableNames'); 
		nextPutAll: 'instanceVariableNames:'.
	newStrm peek == $: ifTrue: [newStrm next].	"may or may not be there, but already written"
	outStrm
		nextPutAll: (newStrm upTo: $'); nextPut: $'.
	oldVars := (oldStrm upTo: $') findTokens: Character separators.
	newVars := (newStrm upTo: $') findTokens: Character separators.
	addedVars := oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.
	oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].
	outStrm nextPut: $'.

	class isMeta ifFalse: [
		"Merge class vars from old and new defs..."
		oldStrm upToAll: 'classVariableNames:'; upTo: $'.
		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';
			nextPutAll: (newStrm upTo: $'); nextPut: $'.
		oldVars := (oldStrm upTo: $') findTokens: Character separators.
		newVars := (newStrm upTo: $') findTokens: Character separators.
		addedVars := oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.
		oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].
		outStrm nextPut: $'].

	outStrm nextPutAll: newStrm upToEnd.
	^ outStrm contents
! !
!ExtractAsParameter class methodsFor: 'pre-conditions' stamp: 'HAW 9/22/2021 15:42:21' prior: 16857606!
              removeDotsAt: anInterval in: sourceCode
	
	| lastToReplace |
	
	lastToReplace := anInterval last.
	[(sourceCode at: lastToReplace) == $. ] whileTrue: [ lastToReplace := lastToReplace - 1].
	
	^anInterval first to: lastToReplace! !
!InlineMethod methodsFor: 'applying primitives - private' stamp: 'FB 7/4/2022 21:18:15' prior: 16878163!
                replaceRange: aSourceCodeInterval withNewSourceCode: newSourceCode inMethod: aCompiledMethod

	| currentUpdates sourceCodeReplacement|
	
	sourceCodeReplacement := newSourceCode.
	((aSourceCodeInterval last < aCompiledMethod sourceCode size) and: [((aCompiledMethod sourceCode at: aSourceCodeInterval last + 1) == $.)]
		and: [newSourceCode endsWith: '.']) ifTrue: [sourceCodeReplacement := newSourceCode copyUpToLast: $.].
	"It's important to use < and not <= because temporaries declarations are added to the changes collection
	after the changes concerning the inlining of the implementor code, but they need to be replaced first - Fernando"
	currentUpdates := updatedSendersCode at: aCompiledMethod methodReference ifAbsent: (SortedCollection 
		sortBlock: [ :left :right | left key first < right key first ]).
	currentUpdates add: (aSourceCodeInterval -> sourceCodeReplacement).
	updatedSendersCode at: aCompiledMethod methodReference put: currentUpdates.
	! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 8/27/2022 21:06:09' prior: 16878269!
                addParenthesesIfNeededTo: anExpression

	"TODO: duplicated code in InlineTemporaryVariable"

	| firstCharacterIsOpeningParentheses lastCharacterIsClosingParentheses |
	
 	firstCharacterIsOpeningParentheses := (anExpression at: (anExpression firstNonSeparator)) == $(.
	lastCharacterIsClosingParentheses := (anExpression at: (anExpression lastNonSeparator)) == $).

	^(firstCharacterIsOpeningParentheses and: [lastCharacterIsClosingParentheses])
		ifTrue: [^anExpression]
		ifFalse: [ (anExpression endsWith: '.')
			ifTrue: [^('(', anExpression copyUpToLast: $.), ').']
	 		ifFalse: [^'(', anExpression, ')']
		].! !
!InlineMethod methodsFor: 'source code building - private' stamp: 'FB 6/12/2022 18:33:45' prior: 16878460!
            indentationUpTo: anIndex in: aSourceCode

	| indentation currentIndex character|

	currentIndex := anIndex - 1.
	((aSourceCode at: currentIndex) == $^) ifTrue: [currentIndex := currentIndex  -1]. "Skip the return character if present"
	indentation := ''.

	[currentIndex > 0 and: [
		character := (aSourceCode at: currentIndex).
		(character = Character tab) or: [character = Character space]
	]] whileTrue: [
		indentation := indentation, character asString.
		currentIndex := currentIndex - 1.
	].

	^(character = Character newLineCharacter) ifFalse: [^''] ifTrue: [^indentation reversed].! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'HAW 6/11/2022 19:21:17' prior: 16880295!
                       addParenthesesIfNeededTo: anExpression

	| firstCharacterIsOpeningParentheses lastCharacterIsClosingParentheses |

 	firstCharacterIsOpeningParentheses := (anExpression at: (anExpression firstNonSeparator)) == $(.
	lastCharacterIsClosingParentheses := (anExpression at: (anExpression lastNonSeparator)) == $).

	^(firstCharacterIsOpeningParentheses and: [lastCharacterIsClosingParentheses])
		ifTrue: [anExpression]
		ifFalse: ['(', anExpression, ')'].! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/24/2022 11:20:42' prior: 16943027!
      scanBinary
	| c d |
	c := self currentChar.
	currentTokenSourcePosition := sourcePosition.
	currentToken := source class with: c.
	d := self nextChar.
	((self isBinarySelectorCharacter: c) or: [c == $:]) ifFalse: [^currentToken].
	(c == $: and: [d == $=]) 
		ifTrue: [" := assignment"
			currentToken := currentToken , (source class with: d).
			self nextChar.
			^currentToken].
	"|| empty temp declaration"
	"This makes || colorize as an invalid method definition.
	It is better to allow #|| as valid selector, and mark an empty temp declaration as invalid instead!!"
	"(c == $| and: [d == $|])
		ifTrue: [^currentToken]."
	c := d.
	[
		d := self peekChar.
		c == $-
			ifTrue: [ d isDigit not ]
			ifFalse: [ self isBinarySelectorCharacter: c ]
	]
		whileTrue: [
			currentToken := currentToken copyWith: c.
			c := self nextChar ].
	^currentToken! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/21/2022 22:45:35' prior: 16943056!
                        scanComment
	| c s e |
	s := sourcePosition.
	
	[sourcePosition := sourcePosition + 1.
	(c := self currentChar) 
		ifNil: [
			self rangeType: #unfinishedComment start: s end: source size.
			^self error	": 'unfinished comment'"].
	c == $"] 
		whileFalse: [].
	e := sourcePosition.
	s < e ifTrue: [self rangeType: #comment start: s end: e].
	self nextChar.
	self scanWhitespace! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/21/2022 22:45:41' prior: 16943070!
                 scanIdentifier
	| c start |
	start := sourcePosition.
	[ (c := self nextChar) isValidInIdentifiers ] whileTrue: [].
	(c == $: and: [(self isBinarySelectorCharacter: self peekChar) not]) 
		ifTrue: [self nextChar].
	currentToken := source copyFrom: start to: sourcePosition - 1.
	currentTokenSourcePosition := start! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/23/2022 12:46:55' prior: 16943096!
                scanNumber
	| start c nc base |
	start := sourcePosition.
	self skipDigits.
	c := self currentChar.
	('rx' includes: c)
		ifTrue: [
			base := Integer readFrom: ((source copyFrom: start to: sourcePosition - 1) readStream).
			self peekChar == $- ifTrue: [self nextChar].
			self skipBigDigits: base.
			c := self currentChar.
			c == $. 
				ifTrue: [
					(self isBigDigit: self nextChar base: base) 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipBigDigits: base]].
			c := self currentChar.
			('deqp'includes: c)
				ifTrue: [
					((nc := self nextChar) isDigit or: [nc == $- and:[self peekChar isDigit]]) 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipDigits]].
			c == $s 
				ifTrue: [
					self nextChar isDigit 
						ifFalse: [sourcePosition := sourcePosition - 1]
						ifTrue: [self skipDigits]].
			currentToken := source copyFrom: start to: sourcePosition - 1.
			^currentTokenSourcePosition := start].
	c == $s 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits.].
			currentToken := source copyFrom: start to: sourcePosition - 1.
			^currentTokenSourcePosition := start].
	c == $. 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [
					sourcePosition := sourcePosition - 1.
					currentToken := source copyFrom: start to: sourcePosition - 1.
					^currentTokenSourcePosition := start]
				ifTrue: [self skipDigits]].
	c := self currentChar.
	('deqp' includes: c)
		ifTrue: [
			((nc := self nextChar) isDigit or: [nc == $-  and:[self peekChar isDigit]]) 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits]].
	c == $s 
		ifTrue: [
			self nextChar isDigit 
				ifFalse: [sourcePosition := sourcePosition - 1]
				ifTrue: [self skipDigits]].
	currentToken := source copyFrom: start to: sourcePosition - 1.
	^currentTokenSourcePosition := start! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/21/2022 22:45:45' prior: 16943200!
     scanWhitespace
	| c |
	
	[c := self currentChar.
	c notNil and: [c isSeparator]] 
		whileTrue: [sourcePosition := sourcePosition + 1].
	c == $" ifTrue: [self scanComment]! !
!SHParserST80 methodsFor: 'token testing' stamp: 'jmv 5/21/2022 22:35:28' prior: 16943278!
                       isBinary
	| c |
	(currentToken isNil or: [self isName or: [self isKeyword]]) 
		ifTrue: [^false].
	"Special case: '::' is not a binary selector but the Chain operator"
	(sourcePosition - currentTokenSourcePosition = 1 and: [
		(source at: currentTokenSourcePosition ifAbsent: nil) == $: and: [		
			(source at: sourcePosition ifAbsent: nil) == $: ]])
				ifTrue: [^ false ].
	1 to: currentToken size do: [ :i |
		c := currentToken at: i.
		((self isBinarySelectorCharacter: c) or: [c == $:])
			ifFalse: [^false]].
	^true! !
!SHParserST80 methodsFor: 'token testing' stamp: 'jmv 5/21/2022 22:35:32' prior: 16943297!
                        isKeyword
	^ currentTokenFirst isValidStartOfIdentifiers and: [ currentToken last == $: ]! !
!SHParserST80 methodsFor: 'character testing' stamp: 'jmv 12/14/2018 15:39:18' prior: 16943331!
   isBinarySelectorCharacter: aCharacter
	aCharacter == $: ifTrue: [^ false].
	^aCharacter isValidInBinarySelectors! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:36' prior: 16943672!
                         parseArray
	[currentTokenFirst == $)] whileFalse: [self parseLiteralArrayElement].
	self scanPast: #arrayEnd! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:41' prior: 16943678!
                             parseBacktick
	self enterBlock.
	self scanPast: #backtick.
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $`.
	self scanPast: #backtick.
	self leaveBlock! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:49' prior: 16943711!
                               parseBlock

	"Just read $["
	blockDepths add: blockDepth+1.
	blockDepthsStartIndexes add: sourcePosition-1.

	self enterBlock.
	self scanPast: #blockStart level: bracketDepth.
	currentTokenFirst == $: ifTrue: [self parseBlockArguments].
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $].

	"Just read $]"
	blockDepths add: blockDepth-1.
	blockDepthsStartIndexes add: sourcePosition.

	self scanPast: #blockEnd level: bracketDepth.
	self leaveBlock! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:35:55' prior: 16943730!
                         parseBlockArguments
	[ currentTokenFirst == $: ]
		whileTrue: [
			self scanPast: #blockArgColon.
			self failUnless: self isName.
			self scanPast: #blockPatternArg ].
	currentTokenFirst == $| 
		ifTrue: [ self scanPast: #blockArgsBar ]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/13/2024 11:32:52' prior: 16943740!
                            parseBlockTemporaries

	currentToken = '||' "Empty temp declaration without whitespace"
		ifTrue: [ ^self scanPast: #blockTempBar ].

	currentTokenFirst == $| 
		ifTrue: [
			self scanPast: #blockTempBar.
			[self isName] 
				whileTrue: [self scanPast: #blockPatternTempVar].
			self failUnless: currentToken = '|'.
			self scanPast: #blockTempBar]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:05' prior: 16943754!
            parseBraceArray
	self parseStatementListForBraceArray.
	self failUnless: currentTokenFirst == $}.
	self scanPast: #rightBrace level: braceDepth.
	braceDepth := braceDepth - 1! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:12' prior: 16943762!
                           parseByteArray
	"Literal ByteArray or literal FloatArray"
	[currentTokenFirst == $]] whileFalse: [
		currentTokenFirst isDigit | (currentTokenFirst == $-)
			ifTrue: [
				"do not parse the number, can be time consuming"
				self scanPast: #number]
			ifFalse: [
				self failWhen: currentTokenFirst == $. .
				self error]].
	self scanPast: #arrayEnd! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/16/2024 10:17:00' prior: 16943776!
          parseCascadeAndChain

	| beforeKeywordPos |
	beforeKeywordPos := currentTokenSourcePosition.
	self parseKeyword.

	"At least one message send before cascade and chain"
	beforeKeywordPos =​ currentTokenSourcePosition ifTrue: [ ^self ].

	currentTokenFirst == $; ifTrue:
		[
			self scanPast: #cascadeSeparator.
			^self parseCascadeAndChain
		].
	currentTokenFirst == $: ifTrue:
		[
			self scanPast: #chainSeparator.

			"These lines implement double colon chains"
			currentTokenFirst == $: ifFalse: [^self].
			self scanPast: #chainSeparator.
			
			^self parseCascadeAndChain
		].! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:25' prior: 16943819!
parseExternalCall
	self scanNext.
	self failWhen: currentToken isNil.
	self scanPast: #externalCallType.
	currentToken = '*' 
		ifTrue: [self scanPast: #externalCallTypePointerIndicator].
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: 	[
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentTokenFirst == $(.
	self scanPast: #leftParenthesis.
	[currentTokenFirst ~~ $)] 
		whileTrue: [
			self failWhen: currentToken isNil.
			self scanPast: #externalCallType.
			currentToken = '*' 
				ifTrue: [self scanPast: #externalCallTypePointerIndicator]].
	self scanPast: #rightParenthesis.
	currentToken = 'module:' 
		ifTrue: [
			self scanPast: #module.
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:44:55' prior: 16943887!
        parseLiteral: inArray 
	currentTokenFirst == $$ 
		ifTrue: [
			| pos |
			self failWhen: self currentChar isNil.
			self rangeType: #'$'.
			pos := currentTokenSourcePosition + 1.
			self nextChar.
			self scanPast: #character start: pos end: pos.
			^self ].
	currentTokenFirst isDigit 
		ifTrue: [
			"do not parse the number, can be time consuming"
			self scanPast: #number.
			^self ].
	currentToken = '-' 
		ifTrue: [
			| c |
			c := self currentChar.
			(inArray and: [c isNil or: [c isDigit not]]) 
				ifTrue: [
					"single - can be a symbol in an Array"
					self scanPast: #symbol.
					^self ].
			self scanPast: #-.
			self failWhen: currentToken isNil.
			"token isNil ifTrue: [self error: 'Unexpected End Of Input']."
			"do not parse the number, can be time consuming"
			self scanPast: #number.
			^self ].
	currentTokenFirst == $' ifTrue: [
		self parseString.
		^self ].
	currentTokenFirst == $# ifTrue: [
		self parseSymbol.
		^self ].
	(inArray and: [currentToken notNil]) ifTrue: [
		self scanPast: #symbol.
		^self ].
	self failWhen: currentTokenFirst == $. .
	self error	": 'argument missing'"! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:36:39' prior: 16943925!
         parseLiteralArrayElement
	 currentTokenFirst isValidStartOfIdentifiers ifTrue: [
		#true = currentToken ifTrue: [
			self scanPast: #true.
			^ self ].
		#false = currentToken ifTrue: [
			self scanPast: #false.
			^ self ].
		#nil = currentToken ifTrue: [
			self scanPast: #nil.
			^ self ].
		self scanPast: #symbol.
		^ self ].
	currentTokenFirst == $( ifTrue: [
		self scanPast: #arrayStart.
		self parseArray.
		^ self ].
	self parseLiteral: true! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/13/2024 11:33:12' prior: 16943952!
     parseMethodTemporaries

	currentToken = '||' "Empty temp declaration without whitespace"
		ifTrue: [ ^self scanPast: #methodTempBar ].

	currentTokenFirst == $| 
		ifTrue: [
			self scanPast: #methodTempBar.
			[self isName] 
				whileTrue: [self scanPast: #patternTempVar].
			self failUnless: currentToken = '|'.
			self scanPast: #methodTempBar]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 8/23/2024 15:13:54' prior: 16944040!
             parseStatement
	(currentToken isNil or: [	currentToken size = 1]) ifTrue: [
		currentTokenFirst == $^ ifTrue: [self scanPast: #return].
		currentTokenFirst = Character smalltalkUpArrow ifTrue: [self scanPast: #return]].
	self parseExpression.! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:00' prior: 16944050!
                       parseStatementList
	
	[[currentTokenFirst == $.] whileTrue: [self scanPast: #statementSeparator].
	(currentToken notNil and: [currentTokenFirst ~~ $]]) 
		ifTrue: [self parseStatement].
	currentTokenFirst == $.] 
			whileTrue: [self scanPast: #statementSeparator]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 9/13/2024 11:38:10' prior: 16944061!
  parseStatementListForBraceArray
	"same as parseStatementList, but does not allow empty statements e.g {...$a...}.
	A single terminating . IS allowed e.g. {$a.} "

	
	[currentTokenFirst ~~ $} ifTrue: [self parseExpression].
	currentTokenFirst == $.] 
		whileTrue: [self scanPast: #statementSeparator]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:09' prior: 16944073!
                              parseString
	| first c last |
	first := sourcePosition.
	[
		(c := self currentChar) ifNil: [
			self
				rangeType: #unfinishedString
				start: first - 1
				end: source size.
			self error": 'unfinished string'" ].
		c ~~ $' or: [
			self peekChar == $' and: [
				sourcePosition := sourcePosition + 1.
				true ]]] whileTrue: [ sourcePosition := sourcePosition + 1 ].
	last := sourcePosition.
	self nextChar.
	self
		scanPast: #string
		start: first - 1
		end: last! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:15' prior: 16944090!
                    parseStringOrSymbol

	currentTokenFirst == $' ifTrue: [ ^self parseString ].
	currentTokenFirst == $# ifTrue: [ ^self parseSymbol ].
	self error! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:45:04' prior: 16944097!
                         parseSymbol
	| c |
	currentToken = '#' 
		ifTrue: [
			"if token is just the #, then scan whitespace and comments
			and then process the next character.
			Allows space between the # and the start of the symbol 
			e.g. # (),  #  a, #  'sym' "
			self rangeType: #symbol.
			self scanWhitespace].
	c := self currentChar.
	self failWhen: (c isNil or: [c isSeparator]).
	c == $( 
		ifTrue: [
			self nextChar.
			self scanPast: #arrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.
			^self parseArray].
	c == $' ifTrue: [
		self parseSymbolString.
		^self ].
	c == $[ ifTrue: [
			self nextChar.
			self scanPast: #arrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.
			^self parseByteArray].
	(self isBinarySelectorCharacter: c) ifTrue: [
		self parseSymbolSelector.
		^self ].
	( c isValidStartOfIdentifiers or: [c == $:]) ifTrue: [
		self parseSymbolIdentifier.
		^self].
	self parseCharSymbol! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:29' prior: 16944129!
              parseSymbolIdentifier
	| c start end |
	c := self currentChar.
	self failUnless: ( c isValidStartOfIdentifiers or: [ c == $: ]).
	start := sourcePosition.
	[
		c := self nextChar.
		c isValidInIdentifiers or: [ c == $: ]
	] whileTrue: [].
	end := sourcePosition - 1.
	self scanPast: #symbol start: start - 1 end: end! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:37:34' prior: 16944152!
             parseSymbolString
	| first c last |
	first := sourcePosition.
	self nextChar.
	[
		(c := self currentChar) 
			ifNil: [
				self rangeType: #unfinishedString start: first end: source size.
				self error	": 'unfinished string'"].
		c ~~ $' or: [
			self peekChar == $' 
				ifTrue: [sourcePosition := sourcePosition + 1. true] 
				ifFalse: [false]]
	] whileTrue: [sourcePosition := sourcePosition + 1].
	last := sourcePosition.
	self nextChar.
	self scanPast: #stringSymbol start: first - 1 end: last! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 5/21/2022 22:45:14' prior: 16944170!
                    parseTerm
	self failWhen: currentToken isNil.
	currentTokenFirst == $( 
		ifTrue: [
			bracketDepth := bracketDepth + 1.
			self scanPast: #leftParenthesis level: bracketDepth.
			self parseExpression.
			self failUnless: currentTokenFirst == $).
			self scanPast: #rightParenthesis level: bracketDepth.
			bracketDepth := bracketDepth - 1.
			^self ].
	currentTokenFirst == $[ ifTrue: [^self parseBlock].
	currentTokenFirst == $` ifTrue: [^self parseBacktick].
	currentTokenFirst == ${ 
		ifTrue: [
			braceDepth := braceDepth + 1.
			self scanPast: #leftBrace level: braceDepth.
			self parseBraceArray.
			^self ].
	self isName ifTrue: [^self scanPast: (self resolve: currentToken)].
	self parseLiteral: false! !

Character initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7000-UseEqualEqualForLiteralCharacters-JuanVuletich-2025Jan22-08h32m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7000] on 22 January 2025 at 3:01:40 pm'!
!CharacterSequence methodsFor: 'converting' stamp: 'jmv 1/22/2025 15:00:17'!
                       translated
	"In Squeak, #translated does localization of Strings. This method helps with compatibility.
	Additionally, applications written in Cuis could do the same.
	This method should be redefined in a Localization package."! !
!Text methodsFor: 'converting' stamp: 'jmv 1/22/2025 15:00:27'!
                         translated
	"In Squeak, #translated does localization of Strings. This method helps with compatibility.
	Additionally, applications written in Cuis could do the same.
	This method should be redefined in a Localization package."! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7001-translated-JuanVuletich-2025Jan22-14h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7000] on 22 January 2025 at 3:02:14 pm'!
!ContextPart methodsFor: 'controlling' stamp: 'jmv 1/22/2025 15:01:43' prior: 50347579!
                               executeMethod: meth forSelector: selector withArgs: arguments receiver: rcvr

	| primIndex val ctxt isPrimitive |
	(self objectClass: meth) isCompiledMethodClass ifFalse:
		["Object as Methods (OaM) protocol: 'The contract is that, when the VM encounters an ordinary object (rather than a compiled method) in the method dictionary during lookup, it sends it the special selector #run:with:in: providing the original selector, arguments, and receiver.'. DOI: 10.1145/2991041.2991062."
		^self send: #run:with:in:
			to: meth
			with: {selector. arguments. rcvr}].
	
	meth numArgs = arguments size ifFalse:
		[^ self class primitiveFailTokenFor: #'bad number of arguments'].
	primIndex := meth primitive.
	isPrimitive := primIndex > 0 and: [ meth isQuick not ].
	isPrimitive ifTrue:
		[val := self doPrimitive: primIndex method: meth receiver: rcvr args: arguments.
		(self isPrimFailToken: val) ifFalse:
			[^val]].
	
	ctxt := self activateMethod: meth withArgs: arguments receiver: rcvr.
	isPrimitive ifTrue:
		[ctxt failPrimitiveWith: val].
	
	^ctxt! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7002-RestoreStepIntoQuickMethods-JuanVuletich-2025Jan22-15h01m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7002] on 23 January 2025 at 8:38:17 am'!
!Debugger methodsFor: 'method creation' stamp: 'jmv 1/23/2025 08:37:41' prior: 16843897!
                      wasInterruptedOnOverridableMethod
	| methodClass receiverClass |

	self interruptedContext sender ifNotNil:
		[ :senderContext |
			senderContext selector == #shouldBeImplemented ifTrue: 
				[ ^false ]].

	methodClass := self interruptedContext method methodClass.
	receiverClass := self interruptedContext receiver class.

	^ methodClass ~= receiverClass! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7003-Debugger-Dont-Create-if-shouldBeImplemented-JuanVuletich-2025Jan23-08h37m-jmv.001.cs.st----!

----QUIT----(23 January 2025 11:11:19) Cuis7.3-7003.image priorSource: 352489!

----STARTUP---- (29 January 2025 14:59:57) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.3-7003.image!


'From Cuis7.3 [latest update: #7003] on 23 January 2025 at 5:15:27 pm'!
!ChangeList methodsFor: 'menu actions' stamp: 'eem 1/23/2025 17:08:14'!
                      selectContentsMatching
	| pattern |
	pattern := self request: 'pattern to match' initialAnswer: ''.
	pattern isEmpty ifTrue: [^self].
	^self selectSuchThat: ((pattern includesAnyOf: '?*')
							ifTrue: [[ :change | pattern match: change string]]
							ifFalse: [[ :change | change string includesSubString: pattern]])! !
!ChangeListWindow methodsFor: 'menu & kbd shortcuts' stamp: 'eem 1/23/2025 17:14:42' prior: 16805306!
                       listMenuSpec
	"Spec for the menu and shortcut keys for the changes list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Change List' 									true)
		#(10	'File In selections' 									nil 	model 	fileInSelections 						nil
					'import the selected items into the image')
		#(20	'File Out selections...	' 							nil 	model 	fileOutSelections 						nil
		 			'create a new file containing the selected items')
		#(30	'File Out current version of selections...' 			nil 	model 	fileOutCurrentVersionsOfSelections 	nil
 					'create a new file containing the current (in-image) counterparts of the selected methods')
		#(40 	'-----')
		#(50	'Compare to Current' 								nil 	model 	compareToCurrentVersion 				nil
 					'open a separate window which shows the text differences between the on-file version and the in-image version.')
		#(60 	'-----')
		#(70	'Select new methods' 								nil 	model 	selectNewMethods 					nil
 					'select methods in the file that do not currently exist in the image')
		#(80	'Select changes for Absent Classes' 				nil 	model 	selectAllForAbsentClasses 				nil
					'select methods in the file for classes that are not defined in the image')
		#(90	'Select all changes for this Class' 					nil 	model 	selectAllForThisClass 					nil
					'select all methods in the file that belong to the currently-selected class')
		#(100	'Select Unchanged methods' 						nil 	model 	selectUnchangedMethods 				nil
					'select methods in the file whose in-image versions are the same as their in-file counterparts')
		#(105	'Select changes with contents matching'			nil	model	selectContentsMatching				nil
					'select all changes in the file whose text matches a pattern or includes a string')

		#(110	'Select methods Equivalent to current' 				nil 	model 	selectEquivalentMethods 				nil
					'select methods in the file whose in-image versions have the same behavior as their in-file counterparts')
		#(120	'Select methods Older than current' 				nil 	model 	selectMethodsOlderThanCurrent 		nil
					'select methods in the file that are older than the one currently in the image')
		#(130	'Select removals of Sent methods' 					nil 	model 	selectRemovalsOfSent 					nil
					'select all method removals of methods that have some sender in the image')
		#(140 	'-----')
		#(150	'Select All (a)' 									$a 	model 	selectAll 								nil
					'select all the items in the list')
		#(160	'Deselect All (A)' 									$A 	model 	deselectAll 								nil
					'deselect all the items in the list')
		#(170	'Invert Selections' 								nil 	model 	invertSelections 						nil
					'select every item that is not currently selected, and deselect every item that *is* currently selected')
		#(180 	'-----')
		#(190	'Browse class and method' 						nil 	window browseMethodFull 					nil
					'open a full browser showing the selected method')
		#(200	'Browse all versions of single selection' 			nil 	window browseVersions 						nil
					'open a version browser showing the versions of the currently selected method')
		#(210	'Browse current versions of selections' 				nil 	window browseCurrentVersionsOfSelections 	nil
					'open a message-list browser showing the current (in-image) counterparts of the selected methods')
		#(220	'Destroy current methods of selections' 			nil 	model 	destroyCurrentCodeOfSelections 		nil
					'remove (*destroy*) the in-image counterparts of all selected methods')
		#(230 	'-----')
		#(240	'Remove doIts' 									nil 	model 	removeDoIts 							nil
					'remove all items that are doIts rather than definitions')
		#(250	'Remove older versions' 							nil 	model 	removeOlderMethodVersions 			nil
					'remove all but the most recent versions of methods in the list')
		#(260	'Remove up-to-date versions' 					nil 	model 	removeUpToDate 						nil
					'remove all items whose code is the same as the counterpart in-image code')
		#(270	'Remove empty class comments' 					nil 	model 	removeEmptyClassComments 			nil
					'remove all empty class comments')
		#(280	'Remove selected items' 							nil 	model 	removeSelections 						nil
					'remove the selected items from the change-list')
		#(290	'Remove unselected items' 						nil 	model 	removeNonSelections 					nil
					'remove all the items not currently selected from the change-list')
	)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7004-ChangeListSelectContentsMatching-EliotEmilioMiranda-2025Jan23-14h18m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #7004] on 25 January 2025 at 10:14:01 am'!
!Object methodsFor: 'testing' stamp: 'ul 11/23/2010 13:28'!
                              shouldBePrintedAsLiteral

	^self isLiteral! !
!Object methodsFor: 'testing' stamp: 'eem 1/25/2025 09:51:32'!
                   shouldBePrintedAsLiteralVisiting: aSet
	"aSet is for detecting circular references.
	See implementors and senders."
	^self isLiteral! !
!Array methodsFor: 'printing' stamp: 'eem 4/3/2017 15:42'!
                             printAsBraceFormOn: aStream
	aStream nextPut: ${.
	self do: [:el | el printOn: aStream] separatedBy: [ aStream nextPutAll: ' . '].
	aStream nextPut: $}! !
!Array methodsFor: 'printing' stamp: 'eem 4/3/2017 15:35'!
          printAsLiteralOn: aStream
	aStream nextPut: $#; nextPut: $(.
	self do: [:each| each printAsLiteralOn: aStream] separatedBy: [aStream space].
	aStream nextPut: $)
! !
!Array methodsFor: 'testing' stamp: 'eem 1/25/2025 09:52:21' overrides: 50355045!
        shouldBePrintedAsLiteral
	"Detect circular references."
	^self class == Array
	  and: [self shouldBePrintedAsLiteralVisiting: (IdentitySet newWithRoomForMoreThan: 8)]! !
!Array methodsFor: 'testing' stamp: 'eem 11/2/2011 11:01' overrides: 50355049!
       shouldBePrintedAsLiteralVisiting: aSet
	self class == Array ifFalse:
		[^false].
	(aSet includes: self) ifTrue:
		[^false].
	aSet add: self.
	^self allSatisfy: [:each | each shouldBePrintedAsLiteralVisiting: aSet]! !
!ByteArray methodsFor: 'printing' stamp: 'eem 4/3/2017 15:18'!
        printAsLiteralOn: aStream
	aStream nextPut: $#; nextPut: $[.
	self do: [:each| each storeOn: aStream]
		separatedBy: [aStream nextPut: $ ].
	aStream nextPut: $]! !
!String methodsFor: 'printing' stamp: 'eem 4/3/2017 15:30'!
printAsLiteralOn: aStream
	"Print inside string quotes, doubling embedded quotes."
	self storeOn: aStream! !
!Boolean methodsFor: 'printing' stamp: 'eem 4/3/2017 15:44'!
                      printAsLiteralOn: aStream
	^self printOn: aStream! !
!Float methodsFor: 'printing' stamp: 'eem 4/3/2017 15:27'!
                printAsLiteralOn: aStream
	^self storeOn: aStream base: 10! !
!Integer methodsFor: 'printing' stamp: 'eem 4/3/2017 15:26'!
     printAsLiteralOn: aStream
	^self printOn: aStream base: 10! !
!UndefinedObject methodsFor: 'printing' stamp: 'eem 4/3/2017 15:32'!
                             printAsLiteralOn: aStream
	^self printOn: aStream! !
!Character methodsFor: 'testing' stamp: 'eem 1/24/2025 10:54:35' overrides: 50355045!
                     shouldBePrintedAsLiteral

	| integerValue |
	(integerValue := self codePoint) < 33 ifTrue: [ ^false ].
	^integerValue ~= 127! !
!Character methodsFor: 'testing' stamp: 'eem 11/2/2011 11:03' overrides: 50355049!
             shouldBePrintedAsLiteralVisiting: aSet

	^self shouldBePrintedAsLiteral! !
!Character methodsFor: 'printing' stamp: 'eem 4/3/2017 15:21'!
                      printAsLiteralOn: aStream
	aStream nextPut: $$; nextPut: self! !
!Character class methodsFor: 'private' stamp: 'eem 1/23/2025 18:03:34'!
                       constantNameFor: aCharacter
	self constantNames do:
		[ :constantName |
		(self perform: constantName) == aCharacter ifTrue:
			[^constantName]].
	^nil! !
!Character class methodsFor: 'private' stamp: 'eem 1/23/2025 18:02:02'!
                             constantNames
	^ #(backQuote backspace cr delete doubleQuote end enter escape home insert lf newPage noBreakSpace null pageUp singleQuote smalltalkDownArrow smalltalkLeftArrow smalltalkRightArrow smalltalkUpArrow space tab zeroWidthSpace)! !
!Object methodsFor: 'printing' stamp: 'eem 1/24/2025 10:35:19' prior: 16916512!
                              isLiteral
	"Answer whether the receiver has a literal text form recognized by the compiler, and
	 preferrably typeable by a human user. The literal form must be provided by #storeOn:"

	^false! !
!Array methodsFor: 'printing' stamp: 'eem 1/25/2025 09:58:52' prior: 16782857 overrides: 16828377!
                         printOn: aStream
	self class == Array ifFalse:
		[^super printOn: aStream].
	self == Smalltalk specialObjectsArray ifTrue:
		[^aStream nextPutAll: 'Smalltalk specialObjectsArray' ].
	self shouldBePrintedAsLiteral
		ifTrue: [self printAsLiteralOn: aStream]
		ifFalse: [self printAsBraceFormOn: aStream]! !
!Array methodsFor: 'printing' stamp: 'eem 4/3/2017 15:42' prior: 16782866 overrides: 16783414!
                storeOn: aStream
	"Use the literal form if possible."
	self shouldBePrintedAsLiteral
		ifTrue:  [self printAsLiteralOn: aStream]
		ifFalse: [super storeOn: aStream]! !
!ByteArray methodsFor: 'printing' stamp: 'eem 4/3/2017 15:20' prior: 16801253 overrides: 16828377!
                     printOn: aStream
	self shouldBePrintedAsLiteral ifFalse:
		[super printOn: aStream.
		 aStream space].
	self printAsLiteralOn: aStream! !
!ByteArray methodsFor: 'printing' stamp: 'eem 4/3/2017 15:19' prior: 16801257 overrides: 16783414!
                   storeOn: aStream
	self shouldBePrintedAsLiteral
		ifTrue: [self printAsLiteralOn: aStream]
		ifFalse: [super storeOn: aStream]! !
!Character methodsFor: 'printing' stamp: 'eem 1/24/2025 10:24:58' prior: 16810646 overrides: 16916644!
                       printOn: aStream
	| integerValue |
	((integerValue := self codePoint) > 32 and: [integerValue ~= 127]) ifTrue:
		[^self printAsLiteralOn: aStream].
	(self class constantNameFor: self)
		ifNotNil: [ :name | aStream nextPutAll: 'Character '; nextPutAll: name ]
		ifNil: [ aStream nextPutAll: 'Character value: '; print: integerValue ]! !
!Character methodsFor: 'printing' stamp: 'eem 1/24/2025 10:27:09' prior: 16810654 overrides: 16916718!
         storeOn: aStream
	"Common character literals are preceded by '$', however special need to be encoded differently: for some this might be done by using one of the shortcut constructor methods for the rest we have to create them by ascii-value."

	self shouldBePrintedAsLiteral ifTrue:
		[^self printAsLiteralOn: aStream].
	(self class constantNameFor: self)
		ifNotNil:
			[ :name | aStream nextPutAll: self class name; space; nextPutAll: name]
		ifNil:
			[aStream nextPutAll: '(Character value: '; print: self codePoint; nextPut: $)]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7005-ImprovedLiteralPrinting-EliotEmilioMiranda-2025Jan25-09h49m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #7005] on 25 January 2025 at 10:32:22 am'!

InstructionClient subclass: #ImplicitLiteralFinder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!

!classDefinition: #ImplicitLiteralFinder category: #'Kernel-Methods' stamp: 'Install-7006-ImplicitLiteralSupport-EliotEmilioMiranda-2025Jan25-10h28m-eem.001.cs.st 1/29/2025 14:59:57'!
InstructionClient subclass: #ImplicitLiteralFinder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Methods'!
!ImplicitLiteralFinder commentStamp: 'eem 9/12/2021 14:44' prior: 0!
                               ImplicitLiteralFinder is a means to extract special literals from an instruction stream.  Instances of InstructionClient answer self in response to all bytecode decode messages.  Instances of this class answer the literal itself for implicit literal bytecode messages.

Instance Variables
!
!Object methodsFor: 'literals' stamp: 'mt 12/15/2023 12:17'!
allLiteralsDo: aBlock
	"Enumerate all literals in the receiver. Note that subclasses may override this to expose the literals they hold such as Array or Pragma. Also note that CompiledCode, being the typical entry point for such an operation, will rather call #allLiteralsDo:#scanForSpecial: on all code literals (and regular literals) to avoid expensive byte-code scanning if possible."

	self flag: #discuss. "mt: Better implement this only on Symbol, Array, Number, Binding, etc. instead of Object?"
	aBlock value: self.! !
!Object methodsFor: 'literals' stamp: 'mt 12/15/2023 10:22'!
                    allLiteralsDo: aBlock scanForSpecial: aBoolean
	"Backstop. Avoid bytecode scanning in CompiledCode and below. See #hasLiteral:scanForSpecial:."
	
	self allLiteralsDo: aBlock.! !
!Object methodsFor: 'literals' stamp: 'eem 7/8/2024 15:25'!
                  hasLiteral: literal

	^ self
		hasLiteralSuchThat: [:lit | lit literalEqual: literal]
		scanForSpecial: false! !
!Object methodsFor: 'literals' stamp: 'mt 12/15/2023 12:13'!
                  hasLiteralSuchThat: testBlock
	"Also see #hasLiteral:. Do not scan for implicit (i.e. special) literals by default to get a faster response."

	^ self hasLiteralSuchThat: testBlock scanForSpecial: false! !
!Object methodsFor: 'literals' stamp: 'mt 12/15/2023 10:23'!
                     hasLiteralSuchThat: testBlock scanForSpecial: aBoolean
	"Backstop. Avoid bytecode scanning in CompiledCode and below. See #hasLiteral:scanForSpecial:."

	self
		allLiteralsDo: [:literal | (testBlock value: literal) ifTrue: [^ true]]
		scanForSpecial: aBoolean.
	
	^ false! !
!Array methodsFor: '*Kernel-literals' stamp: 'mt 6/24/2019 09:25' overrides: 50355271!
                      allLiteralsDo: aBlock

	"I am a literal."
	aBlock value: self.
	
	"All my elements are literals."
	self do: [:each | each allLiteralsDo: aBlock].! !
!CompiledMethod methodsFor: 'literals' stamp: 'mt 12/15/2023 10:52'!
      allImplicitLiteralsDo: aBlock

	self codeLiteralsDo: [:compiledCode |
		compiledCode implicitLiteralsDo: aBlock].! !
!CompiledMethod methodsFor: 'literals' stamp: 'mt 12/15/2023 10:29' overrides: 50355271!
                  allLiteralsDo: aBlock
	"Overwritten to really enumerate all literals. Also the implicit ones."
	
	self
		allLiteralsDo: aBlock
		scanForSpecial: true.! !
!CompiledMethod methodsFor: 'literals' stamp: 'mt 12/15/2023 10:58' overrides: 50355290!
             allLiteralsDo: aBlock scanForSpecial: aBoolean
	"Overwritten to skip certain (raw) literals."
		
	"Exclude method selector (or properties) and the method's class. Include code literals."
	1 to: self numLiterals - 2 do: [:index |
		(self literalAt: index) allLiteralsDo: aBlock scanForSpecial: aBoolean].

	"Enumerate the implicit literals in bytecodes of the receiver."
	aBoolean ifTrue: [self implicitLiteralsDo: aBlock].

	"Enumerate method selector only through additional method state."
	self penultimateLiteral isMethodProperties
		ifTrue: [self penultimateLiteral allLiteralsDo: aBlock scanForSpecial: aBoolean]! !
!CompiledMethod methodsFor: 'literals' stamp: 'mt 7/4/2019 08:46'!
                codeLiterals

	^ Array streamContents: [:stream |
		self codeLiteralsDo: [:compiledCode | stream nextPut: compiledCode]]! !
!CompiledMethod methodsFor: 'literals' stamp: 'mt 7/4/2019 08:37'!
 codeLiteralsDo: aBlock
	"Enumerate all literals that represent instances of CompiledCode. This is especially required for SistaV1."
	
	aBlock value: self.
	
	self literalsDo: [:literal | literal isCompiledCode ifTrue: [
		literal codeLiteralsDo: aBlock]].! !
!CompiledMethod methodsFor: 'literals' stamp: 'eem 9/12/2021 15:03'!
                        implicitLiteralsDo: aBlock
	"Enumerate the implicit literals in bytecodes of the receiver."
	
	| stream client encoderClass endPC |
	"Enumerate special selectors & special literals such as true and false."
	stream := InstructionStream on: self.
	encoderClass := self encoderClass.
	"cache endPC for methods with embedded source; finding out the endPC is very slow in this case..."
	endPC := self endPC.
	client := ImplicitLiteralFinder new.
	[stream pc <= endPC] whileTrue:
		[| literalOrClient |
		literalOrClient := encoderClass interpretNextInstructionFor: client in: stream.
		literalOrClient ~~ client ifTrue:
			[aBlock value: literalOrClient]]! !
!AdditionalMethodState methodsFor: 'literals' stamp: 'mt 6/5/2019 11:12' overrides: 50355271!
                    allLiteralsDo: aBlock

	1 to: self basicSize do: [:index |
		(self basicAt: index) allLiteralsDo: aBlock].! !
!ImplicitLiteralFinder methodsFor: 'instruction decoding - implicit literals' stamp: 'mt 12/20/2023 13:19' overrides: 50346768!
                  methodReturnSpecialConstant: value
	^value! !
!ImplicitLiteralFinder methodsFor: 'instruction decoding - implicit literals' stamp: 'eem 9/12/2021 14:45' overrides: 50346777!
                  pushSpecialConstant: value
	^value! !
!ImplicitLiteralFinder methodsFor: 'instruction decoding - implicit literals' stamp: 'eem 9/12/2021 14:45' overrides: 50346785!
                          sendSpecial: selector numArgs: numArgs
	^selector! !
!Pragma methodsFor: 'literals' stamp: 'mt 6/5/2019 10:59' overrides: 50355271!
                            allLiteralsDo: aBlock

	keyword allLiteralsDo: aBlock.
	arguments allLiteralsDo: aBlock.! !
!LookupKey methodsFor: '*Kernel-literals' stamp: 'mt 7/22/2019 09:40' overrides: 50355271!
         allLiteralsDo: aBlock
	"Treat myself or my key as literal. Do not treat any value (i.e., in Association or Binding) as literal to avoid decending too thoroughly. As a consequence, for example, classes have to be resolved to their class bindings or class names before using them as input in this interface."
	
	aBlock value: self.	
	self key allLiteralsDo: aBlock.! !
!CompiledMethod methodsFor: 'literals' stamp: 'mt 7/4/2019 09:27' prior: 16833467!
                              allLiterals
	"Skip compiled-code objects. Keep literal arrays, bindings, etc."
	
	^ Array streamContents: [:result |
		self allLiteralsDo: [:literal | result nextPut: literal]]! !
!CompiledMethod methodsFor: 'literals' stamp: 'eem 7/8/2024 15:15' prior: 16833471 overrides: 50355298!
    hasLiteral: aLiteral
	"Overwrite this method to invoke the bytecode encoder scanner explicitly.
	 This might be removed if there would be a way to enumerate special literals in a compiled-code object. See #allLiteralsDo:."

	^ self
		hasLiteralSuchThat: [:lit | lit literalEqual: aLiteral]
		scanForSpecial: (self encoderClass canBeSpecialLiteral: aLiteral)! !
!CompiledMethod methodsFor: 'literals' stamp: 'mt 5/28/2019 14:08' prior: 16833585!
   literals
	
	^ Array streamContents: [:result |
		self literalsDo: [:lit | result nextPut: lit]]! !
!Pragma methodsFor: 'literals' stamp: 'mt 5/28/2019 12:34' prior: 16929348 overrides: 50355298!
                             hasLiteral: aLiteral
	"Extra support for #hasLiteralTest:."
	
	^ (super hasLiteral: aLiteral)
		or: [keyword == #hasLiteralTest: and: [
			self methodClass theNonMetaClass perform: arguments first with: aLiteral]]! !

Array removeSelector: #hasLiteral:!

!methodRemoval: Array #hasLiteral: stamp: 'Install-7006-ImplicitLiteralSupport-EliotEmilioMiranda-2025Jan25-10h28m-eem.001.cs.st 1/29/2025 14:59:57'!
hasLiteral: literal
	"Answer true if literal is identical to any literal in this array, even 
	if imbedded in further array structure. This method is only intended 
	for private use by CompiledMethod hasLiteralSymbol:"

	| lit |
	1 to: self size do: 
		[:index | 
		((lit := self at: index) literalEqual: literal) ifTrue: [^true].
		(Array == lit class and: [lit hasLiteral: literal]) ifTrue: [^true]].
	^false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7006-ImplicitLiteralSupport-EliotEmilioMiranda-2025Jan25-10h28m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #7006] on 25 January 2025 at 10:45:45 am'!
!CharacterSequence methodsFor: 'printing' stamp: 'eem 4/3/2017 15:30'!
                   printAsLiteralOn: aStream
	"Print inside string quotes, doubling embedded quotes."
	self storeOn: aStream! !

String removeSelector: #printAsLiteralOn:!

!methodRemoval: String #printAsLiteralOn: stamp: 'Install-7007-Move-printAsLiteralOn-fromStringToCharacterSequence-EliotEmilioMiranda-2025Jan25-10h44m-eem.001.cs.st 1/29/2025 14:59:57'!
printAsLiteralOn: aStream
	"Print inside string quotes, doubling embedded quotes."
	self storeOn: aStream!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7007-Move-printAsLiteralOn-fromStringToCharacterSequence-EliotEmilioMiranda-2025Jan25-10h44m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #7006] on 25 January 2025 at 11:03:27 am'!
!Fraction methodsFor: 'printing' stamp: 'jmv 1/25/2025 10:58:09'!
             printAsLiteralIfAtAllPossibleOn: aStream
	| n d base powers pow2 maximumBase |
	n := numerator.
	d := denominator.
	powers := Dictionary new.
	(pow2 := d lowBit - 1) = 0
		ifTrue: [
			base := 1]
		ifFalse: [
			base := 2.
			powers at: 2 put: pow2.
			d := d >> pow2].
	maximumBase := 36.
	Integer largePrimesUpTo: (d sqrtFloor max: 2) do: [ :p |
		| pow |
		(d rem: p) = 0
			ifTrue: [
				pow := 1.
				[((d := d quo: p) rem: p) = 0] whileTrue: [pow := pow + 1].
				base := base * p.
				base > maximumBase ifTrue: [
					"self halt: 'cannot print in base > ' , maximumBase printString."
					^self printOn: aStream.
					].
				powers at: p put: pow].
		p squared > d
			ifTrue: [ "Decomposition done, we can now print"
				| maximumPower b |
				d = 1 ifFalse: [base := base * d. powers at: d put: 1].
				base > maximumBase ifTrue: [
					"self halt: 'cannot print in base > ' , maximumBase printString."
					^self printOn: aStream.
					].
				base = 2 ifTrue: [base := 10. powers at: 5 put: 0].
				maximumPower := powers detectMax: [:each | each].
				powers keysAndValuesDo: [:k :v | n := n * (k raisedTo: maximumPower - v)].
				b := base.
				[maximumPower > 1 and: [b * base <= maximumBase]]
					whileTrue:
						[b := b * base.
						maximumPower := maximumPower - 1].
				n storeOn: aStream base: b.
				aStream nextPutAll: 'e-'.
				maximumPower storeOn: aStream.
				^self ]].! !
!Fraction methodsFor: 'printing' stamp: 'jmv 1/25/2025 11:03:25' prior: 16871287!
                      printAsLiteralOn: aStream
	"
	{123e-12000} storeString
	{123e-12000} printString
	"
	self storeOn: aStream! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7008-Fraction-printing-fix-JuanVuletich-2025Jan25-10h45m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7008] on 25 January 2025 at 2:37:36 pm'!
!Float64Array methodsFor: 'printing' stamp: 'eem 1/25/2025 14:36:19'!
                               printAsLiteralOn: aStream

	aStream nextPut: $#; nextPut: $[.
	self
		do: [ :each | each storeOn: aStream ]
		separatedBy: [ aStream nextPut: $ ].
	aStream nextPut: $]! !
!Float64Array methodsFor: 'testing' stamp: 'eem 1/25/2025 14:33:47' prior: 16866974 overrides: 50355155!
            isLiteral
	"so that 
	#(1 #[1.0 2 3] 5)
	prints itself"
	^self class == Float64Array and: [self allSatisfy: [:ea| ea isFinite]]! !
!Float64Array methodsFor: 'printing' stamp: 'eem 1/25/2025 14:37:02' prior: 16866983 overrides: 16783414!
                   storeOn: aStream

	self isLiteral
		ifTrue: [self printAsLiteralOn: aStream]
		ifFalse: [super storeOn: aStream]! !
!LiteralNode methodsFor: 'printing' stamp: 'eem 1/25/2025 14:31:06' prior: 16893449 overrides: 16919938!
   printOn: aStream indent: level
	key isVariableBinding
		ifTrue: [
			key key isNil
				ifTrue: [
					aStream
						nextPutAll: '###';
						nextPutAll: key value soleInstance name ]
				ifFalse: [
					aStream
						nextPutAll: '##';
						nextPutAll: key key ]]
		ifFalse: [
			key isLiteral
				ifTrue: [ | isComplex |
					isComplex := false.
					key isArray ifTrue: [
						isComplex := key anySatisfy: [ :ea |
							ea isArray ]].
					"Is it complex? (i.e. array of arrays)"
					isComplex
						ifTrue: [
							aStream
								nextPut: $#;
								nextPut: $(.
							key do: [ :ea |
								aStream newLineTab: (1 max: level + 1).
								ea printAsLiteralOn: aStream ].
							aStream newLineTab: (1 max: level).
							aStream nextPut: $) ]
						ifFalse: [ key printAsLiteralOn: aStream ]]
				ifFalse: [
					"Need to generate code for stuff that is in a CompiledMethod literal
					but is not understood as a literal by the Compiler.
					Well, then it is because it was generated using backticks!!"
					aStream nextPut: $`.
					key storeOn: aStream.
					aStream nextPut: $` ]]! !
!InstructionStream methodsFor: 'decoding - private - sista v1' stamp: 'eem 1/25/2025 14:19:21' prior: 50346981!
   interpretNext2ByteSistaV1Instruction: bytecode for: client extA: extA extB: extB startPC: startPC
	"Send to the argument, client, a message that specifies the next instruction.
	 This method handles the two-byte codes.
	 For a table of the bytecode set, see EncoderForV1's class comment."

	| byte method |
	method := self method.
	byte := self method at: pc.
	pc := pc + 1.
	"We do an inline quasi-binary search on bytecode"
	bytecode < 234 ifTrue: "pushes"
		[bytecode < 231 ifTrue:
			[bytecode < 229 ifTrue:
				[| literal |
				 bytecode = 226 ifTrue:
					[^client pushReceiverVariable: (extA bitShift: 8) + byte].
				 literal := method literalAt: (extA bitShift: 8) + byte + 1.
				 bytecode = 227 ifTrue:
					[^client pushLiteralVariable: literal].
				 ^client pushConstant: literal].
			bytecode = 229 ifTrue:
				[^client pushTemporaryVariable: byte].
			^self unusedBytecode: client at: startPC].
		bytecode = 231 ifTrue:
			[^byte < 128
				ifTrue: [client pushNewArrayOfSize: byte]
				ifFalse: [client pushConsArrayWithElements: byte - 128]].
		bytecode = 232 ifTrue:
			[^client pushSpecialConstant: ((extB < 128 ifTrue: [extB] ifFalse: [extB - 256]) bitShift: 8) + byte].
		^client pushSpecialConstant: (Character value: ((extA bitAnd: 16rFF) bitShift: 8) + byte)].
	bytecode < 240 ifTrue: "sends, trap and jump"
		[bytecode < 236 ifTrue: "sends"
			[(bytecode = 235 and: [extB >= 64]) ifTrue:
				[^client
					directedSuperSend: (method literalAt: (extA bitShift: 5) + (byte // 8) + 1)
					numArgs: (extB - 64 bitShift: 3) + (byte \\ 8)].
			 ^client
				send: (method literalAt: (extA bitShift: 5) + (byte // 8) + 1)
				super: bytecode = 235
				numArgs: (extB bitShift: 3) + (byte \\ 8)].
		 bytecode = 236 ifTrue:
			[^client callMappedInlinedPrimitive: byte].
		bytecode = 237 ifTrue:
			[^client jump: (extB bitShift: 8) + byte].
		 ^client jump: (extB bitShift: 8) + byte if: bytecode = 238].
	bytecode < 243 ifTrue:
		[bytecode = 240 ifTrue:
			[^client popIntoReceiverVariable: (extA bitShift: 8) + byte].
		 bytecode = 241 ifTrue:
			[^client popIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1)].
		 ^client popIntoTemporaryVariable: byte].
	bytecode = 243 ifTrue:
		[^client storeIntoReceiverVariable: (extA bitShift: 8) + byte].
	bytecode = 244 ifTrue:
		[^client storeIntoLiteralVariable: (method literalAt: (extA bitShift: 8) + byte + 1)].
	bytecode = 245 ifTrue:
		[^client storeIntoTemporaryVariable: byte].
	"246-247	1111011 i	xxxxxxxx	UNASSIGNED"
	^self unusedBytecode: client at: startPC! !
!EncoderForSistaV1 class methodsFor: 'testing' stamp: 'eem 1/25/2025 18:20:09' prior: 50346111 overrides: 50344274!
                  canBeSpecialLiteral: aLiteral
	"This check can be used to prevent unnecessary use of #scanBlockOrNilForLiteral:."

	aLiteral isVariableBinding ifTrue: [^false]. "a common case; don't waste time analysing..."

	aLiteral isSymbol ifTrue: [^ Smalltalk specialSelectors identityIncludes: aLiteral].
	aLiteral isCharacter ifTrue: [^ aLiteral codePoint <= 65535].
	aLiteral isInteger ifTrue: [^ aLiteral between: -32768 and: 32767].

	aLiteral == true ifTrue: [^ true].
	aLiteral == false ifTrue: [^ true].
	aLiteral == nil ifTrue: [^ true].

	^ false! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7009-DecompilerFixes-EliotEmilioMiranda-2025Jan25-18h21m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #7009] on 27 January 2025 at 9:49:40 am'!
!ContextPart methodsFor: 'private' stamp: 'jmv 1/27/2025 09:35:59' prior: 50349395!
                          doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments
	"Simulate a primitive method whose index is primitiveIndex.  The simulated receiver and
	 arguments are given as arguments to this message. If successful, push result and return
	 resuming context, else ^ {errCode, PrimitiveFailToken}. Any primitive which provokes
	 execution needs to be intercepted and simulated to avoid execution running away."

	| value |
	"Test for unsimulatable side effects (that is, code that will be triggered in the image outside of the simulator range). This includes simulation guards, which are traditionally flagged using primitive 19 (a null primitive that doesn't do anything), as well as certain control primitives that might trigger code on other processes. If a side effect is detected, raise a warning to give the user/client a chance to cancel or virtualize the operation."
	"#(19 87) do: [:primitive | self systemNavigation browseAllSelect: [:m | m primitive = primitive]]"
	(primitiveIndex = 19 "simulationGuard" or: [primitiveIndex = 87 "primitiveResume"]) ifTrue:
		[[(SimulationSideEffectWarning forPrimitive: primitiveIndex)
			context: self method: meth receiver: receiver arguments: arguments;
			signalIfSkipped: [^ self]]
				ifCurtailed:
					[self push: receiver "Cheap fix of the context's internal state. Note that unwinding the receiver -- so that the next step would invoke the primitive again -- would be challenging due to to the variety of senders to this method."]].
	
	((primitiveIndex between: 201 and: 222)
	 and: [(self objectClass: receiver) includesBehavior: BlockClosure]) ifTrue:
		[(primitiveIndex = 206
		  or: [primitiveIndex = 208]) ifTrue:						"[Full]BlockClosure>>valueWithArguments:"
			[^receiver simulateValueWithArguments: arguments first caller: self].
		 ((primitiveIndex between: 201 and: 209)			 "[Full]BlockClosure>>value[:value:...]"
		  or: [primitiveIndex between: 221 and: 222]) ifTrue: "[Full]BlockClosure>>valueNoContextSwitch[:]"
			[^receiver simulateValueWithArguments: arguments caller: self]].

	primitiveIndex = 83 ifTrue: "afr 9/11/1998 19:50" "Object>>perform:[with:...]"
		[| selector |
		selector := arguments at: 1 ifAbsent:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: receiver with: arguments allButFirst].
	primitiveIndex = 84 ifTrue: "afr 9/11/1998 19:50 & eem 8/18/2009 17:04" "Object>>perform:withArguments:"
		[| selector args |
		arguments size = 2 ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		selector := arguments first.
		args := arguments second.
		args isArray ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: receiver with: args].
	primitiveIndex = 100 ifTrue: "eem 8/18/2009 16:57" "Object>>perform:withArguments:inSuperclass:"
		[| rcvr selector args superclass |
		arguments size
			caseOf: {
				[3] -> [
					rcvr := receiver.
					selector := arguments first.
					args := arguments second.
					superclass := arguments third].
				[4] -> ["mirror primitive"
					rcvr := arguments first.
					selector := arguments second.
					args := arguments third.
					superclass := arguments fourth] }
			otherwise: [^ self class primitiveFailTokenFor: #'bad number of arguments'].
		args isArray ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		((self objectClass: rcvr) includesBehavior: superclass) ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: rcvr with: args lookupIn: superclass].

	"Mutex>>primitiveEnterCriticalSection
	 Mutex>>primitiveTestAndSetOwnershipOfCriticalSection"
	(primitiveIndex = 186 or: [primitiveIndex = 187]) ifTrue:
		[| effective |
		 effective := Processor activeProcess.
		 value := primitiveIndex = 186
					ifTrue: [receiver primitiveEnterCriticalSectionOnBehalfOf: effective]
					ifFalse: [receiver primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effective].
		 ^(self isPrimFailToken: value)
			ifTrue: [value]
			ifFalse: [self push: value]].
	
	(primitiveIndex = 188 or: [primitiveIndex = 189]) ifTrue:
		[| n args methodArg thisReceiver |
		 primitiveIndex caseOf:
			{[188 "primitiveExecuteMethodArgsArray"] ->
				["Object>>withArgs:executeMethod:
				  CompiledMethod class>>receiver:withArguments:executeMethod:
				  VMMirror>>ifFail:object:with:executeMethod: et al"
				 ((n := arguments size) between: 2 and: 4) ifFalse:
					[^self class primitiveFailTokenFor: #'unsupported operation'].
				 ((self objectClass: (args := arguments at: n - 1)) == Array
				  and: [(self objectClass: (methodArg := arguments at: n)) includesBehavior: CompiledMethod]) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 thisReceiver := arguments at: n - 2 ifAbsent: [receiver]].
			 [189 "primitiveExecuteMethod"] ->
				["Object>>executeMethod:
				  Object>>with:...executeMethod:"
				 (arguments size > 0) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 ((self objectClass: (methodArg := arguments atLast: 1)) includesBehavior: CompiledMethod) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 args := arguments allButLast.
				 thisReceiver := receiver]}.
		 methodArg numArgs = args size ifFalse:
			[^self class primitiveFailTokenFor: #'bad number of arguments'].
		 methodArg primitive > 0 ifTrue:
			[methodArg isQuick ifTrue:
				[^self push: (methodArg valueWithReceiver: thisReceiver arguments: args)].
			 ^self doPrimitive: methodArg primitive method: methodArg receiver: thisReceiver args: args].
		 ^self
			activateMethod: methodArg
			withArgs: args
			receiver: thisReceiver].

	primitiveIndex = 118 ifTrue: "[receiver:]tryPrimitive:withArgs:; avoid recursing in the VM"
		[(arguments size = 3
		  and: [(self objectClass: arguments second) == SmallInteger
		  and: [(self objectClass: arguments last) == Array]]) ifTrue:
			[^self doPrimitive: arguments second method: meth receiver: arguments first args: arguments last].
		 (arguments size = 2
		 and: [(self objectClass: arguments first) == SmallInteger
		 and: [(self objectClass: arguments last) == Array]]) ifFalse:
			[^self class primitiveFailTokenFor: -3].
		 ^self doPrimitive: arguments first method: meth receiver: receiver args: arguments last].

	value := primitiveIndex = 120 "FFI method"
				ifTrue: [(meth literalAt: 1) tryInvokeWithArguments: arguments]
				ifFalse:
					[primitiveIndex = 117 "named primitives"
						ifTrue: [self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]
						ifFalse: "should use self receiver: receiver tryPrimitive: primitiveIndex withArgs: arguments but this is only in later VMs (and appears to be broken)"
							[receiver tryPrimitive: primitiveIndex withArgs: arguments]].

	^(self isPrimFailToken: value)
		ifTrue: [value]
		ifFalse: [self push: value]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7010-DontCall-effectiveProcess-JuanVuletich-2025Jan27-09h35m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7006] on 25 January 2025 at 11:06:20 am'!
!Array methodsFor: 'printing' stamp: 'jmv 1/25/2025 11:06:02'!
                              storeAsBraceFormOn: aStream
	"
	{(1/3)} storeString
	"
	aStream nextPut: ${.
	self do: [:el | el storeOn: aStream] separatedBy: [ aStream nextPutAll: ' . '].
	aStream nextPut: $}! !
!Array methodsFor: 'printing' stamp: 'jmv 1/25/2025 11:05:19' prior: 50355178 overrides: 16783414!
       storeOn: aStream
	"Use the literal form if possible."
	self shouldBePrintedAsLiteral
		ifTrue:  [self printAsLiteralOn: aStream]
		ifFalse: [self storeAsBraceFormOn: aStream]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7011-Array-storeAsBraceFormOn-JuanVuletich-2025Jan25-11h03m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7009] on 27 January 2025 at 9:50:44 am'!
!ContextPart methodsFor: 'controlling' stamp: 'eem 4/13/2017 13:02'!
                         quickSend: selector to: rcvr with: arguments lookupIn: lookupClass
	"Send the given selector with arguments in an environment which closely resembles
	 the non-simulating environment, with an interjected unwind-protected block to catch
	 nonlocal returns.  Attention: don't get lost!!  This beautiful method is originally due to
	 Hans-Martin Mosner."
	| oldSender contextToReturnTo result |
	contextToReturnTo := self.
	[oldSender := thisContext sender swapSender: self.
	 result := self object: rcvr perform: selector withArguments: arguments inClass: lookupClass.
	 thisContext sender swapSender: oldSender] ifCurtailed:
		[contextToReturnTo := thisContext sender receiver.	"The block context returning nonlocally"
		contextToReturnTo pc: contextToReturnTo previousPc.	"skip to front of return bytecode causing this unwind"
		contextToReturnTo willReturnTopFromMethod ifTrue:
			"If it was a returnTop, push the value to be returned.
			Otherwise the value is implicit in the bytecode"
			[contextToReturnTo push: (thisContext sender tempAt: 1)].
		thisContext swapSender: thisContext home sender.	"Make this block return to the method's sender"
		contextToReturnTo].
	contextToReturnTo push: result.
	^contextToReturnTo! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7012-AddMissing-quickSend-to-with-lookupIn-EzequielBirman-2025Jan27-09h49m-Ez3.001.cs.st----!

'From Cuis7.3 [latest update: #7003] on 23 January 2025 at 2:54:14 pm'!
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 1/22/2025 16:37:26'!
           defaultGap
	"Answer the default gap between submorphs for the receiver.
	Redefine this method for a different initial gap in your morphs."

	^ 0! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 1/22/2025 16:37:37' prior: 16891180 overrides: 16795911!
                             initialize
	super initialize.
	gap := self defaultGap.
	axisEdgeWeight := 0.0.
	doAdoptWidgetsColor := false.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7013-LayoutMorph-defaultGap-JuanVuletich-2025Jan23-14h54m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7005] on 24 January 2025 at 11:42:57 am'!
!SmalltalkEditor methodsFor: 'accessing' stamp: 'jmv 1/23/2025 15:46:11'!
                      selectedClass
	^ self codeProvider selectedClass! !
!EntryFieldMorph methodsFor: 'events-processing' stamp: 'jmv 1/23/2025 16:32:44' prior: 16855567 overrides: 50353110!
                      focusKeyboardFor: aKeyboardEvent
	"If aKeyboardEvent tab or shift-tab use it to navigate keyboard focus.
	ctrl key ignored."
	aKeyboardEvent isTab
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifFalse: [ aKeyboardEvent hand keyboardFocusNext ]
				ifTrue: [ aKeyboardEvent hand keyboardFocusPrevious ].
			^ true ].
	^super focusKeyboardFor: aKeyboardEvent! !
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 1/23/2025 16:39:48' prior: 16881870!
                              escAction
	"Return the action to perform when user presses <Esc> key"

	^self valueOfProperty: #escAction! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 1/23/2025 16:38:47' prior: 16882270!
                     processKeystrokeEvent: evt

	(acceptOn = #enter and: [evt isReturnKey]) ifTrue: [^ self acceptContents].

	self pauseBlinking.

	"Return - check for special action"
	evt isReturnKey ifTrue: [
		self crAction ifNotNil: [ :action |
			^action value ]].

	"Esc - check for special action"
	evt isEsc ifTrue: [			
		self escAction ifNotNil: [ :action |
			^action value ]].

	self handleInteraction: [ editor processKeystrokeEvent: evt ].	
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].

	"Only accept (on any) if we have unaccepted edits, otherwise the morph will flash."
	(hasUnacceptedEdits and: [ acceptOn == #any ]) ifTrue: [ self acceptContents ].! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 1/23/2025 16:53:15' prior: 50339774!
                       findMethodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"
	| searchString selection scopeClass scopeClassName includeSubclasses includeSuperclasses labelList package |

	searchString := StringRequestMorph
		request: 'Enter search text:'
		initialAnswer: self selectedString
		orCancel: [^self].

	scopeClass := self selectedClass.
	scopeClassName := scopeClass name asString.
	includeSubclasses := false.
	includeSuperclasses := false.

	labelList := {
		'This method'. 
		'All methods in image'. } asOrderedCollection.
	(scopeClass notNil)
		ifTrue: [
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := self codeProvider isEditingExistingMethod
				ifTrue: [CodePackage packageOfMethod: self codeProvider currentCompiledMethod asMethodReference ifNone: []]
				ifFalse: [CodePackage packageOfClass: scopeClass ifNone: []].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].

	selection := (SelectionMenu labelList: labelList selections: nil) startUpWithCaption: 'Search Scope'.

	(selection = 0) ifTrue:[^self].
	(selection = 1) "This method"
		ifTrue:[^self find: searchString].
	(selection = 2) "All methods in image"
		ifTrue:[scopeClass := nil].
	"(selection = 3) ifTrue:[]. ""Class only - nothing to do"
	(selection = 4) "Class and subclasses"
		ifTrue:[includeSubclasses := true].
	(selection = 5) "Class, subclasses, and superclasses"
		ifTrue:[
			includeSubclasses := true.
			includeSuperclasses := true].
	(selection = 6) "In my package if any "
		ifTrue: [^ Smalltalk browseMethodsWithSourceString: searchString in: package].
	Smalltalk browseMethodsWithSourceString: searchString scopeClass: scopeClass includeSubclasses: includeSubclasses includeSuperclasses: includeSuperclasses! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7014-VariousMorphicCleanups-JuanVuletich-2025Jan24-11h42m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7004] on 23 January 2025 at 4:55:27 pm'!
!PlacedMorph methodsFor: 'initialization' stamp: 'jmv 1/23/2025 15:13:48' prior: 16923980 overrides: 16907245!
                    openInWorld: aWorld
	"Add this morph to the requested World."

	(location isIdentity or: [ location isPureMirroring ])
		ifTrue: [ "No real position set yet"
			aWorld addMorph: self centeredNear: aWorld activeHand morphPosition.
			^self ].

	aWorld addMorph: self.! !
!WorldMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/23/2025 15:12:39' prior: 17009587!
                  addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	self addMorph: aMorph.
	aMorph morphExtent
		ifNil: [ aMorph positionInWorld: aPoint ]
		ifNotNil:
			[ :e |
				| trialRect delta |
				trialRect := Rectangle center: aPoint extent: e.
				delta := trialRect amountToTranslateWithin: self displayBounds.
				aMorph positionInWorld: (trialRect origin + delta) rounded ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7015-MorphInitialPosition-tweaks-JuanVuletich-2025Jan23-16h54m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7015] on 27 January 2025 at 4:46:40 pm'!
!WorldMorph methodsFor: 'taskbar' stamp: 'jmv 1/27/2025 16:46:34' prior: 17009609!
  showTaskbar

	taskbar ifNil: [
		taskbar := TaskbarMorph newRow.
		self addMorph: taskbar ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7016-LetTaskbarPositionItself-JuanVuletich-2025Jan27-16h46m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7004] on 23 January 2025 at 4:56:21 pm'!
!EntryFieldMorph methodsFor: 'accessing' stamp: 'jmv 1/23/2025 16:30:49'!
       crAction
	"Return the action to perform when user presses <Return> key"
	^self valueOfProperty: #crAction! !
!EntryFieldMorph methodsFor: 'accessing' stamp: 'jmv 1/23/2025 16:30:45'!
         crAction: aBlock
	"Sets the action to perform when user presses <Return> key"
	self setProperty: #crAction toValue: aBlock! !
!EntryFieldMorph methodsFor: 'accessing' stamp: 'jmv 1/23/2025 16:39:30'!
                        escAction
	"Return the action to perform when user presses <Esc> key"

	^self valueOfProperty: #escAction! !
!EntryFieldMorph methodsFor: 'accessing' stamp: 'jmv 1/23/2025 16:39:35'!
         escAction: aBlock
	"Sets the action to perform when user presses <Esc> key"

	self setProperty: #escAction toValue: aBlock.! !
!EntryFieldMorph methodsFor: 'events' stamp: 'jmv 1/23/2025 16:39:41' prior: 16855502 overrides: 16905314!
                      keyStroke: aKeyboardEvent
	"Handle a keystroke event."
	super keyStroke: aKeyboardEvent.
	aKeyboardEvent wasHandled ifTrue: [ 
		self updateFromContents.
		self morphExtent: (self morphExtent max: self minimumExtent). "big enough to fit"
		self redrawNeeded.
		^self ].

	self pauseBlinking.

	"Return - check for special action"
	aKeyboardEvent isReturnKey ifTrue: [
		self crAction ifNotNil: [ :action |
			^action value ]].

	"Esc - check for special action"
	aKeyboardEvent isEsc ifTrue: [			
		self escAction ifNotNil: [ :action |
			^action value ]].

	self handleInteraction: [ self editor processKeystrokeEvent: aKeyboardEvent ].
	self updateFromContents.
	self morphExtent: (self morphExtent max: self minimumExtent). "big enough to fit"
	self redrawNeeded.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7017-EntryField-crAction-escAction-JuanVuletich-2025Jan23-16h55m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7004] on 23 January 2025 at 4:59:44 pm'!
!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 1/23/2025 16:16:03' overrides: 16851989!
cursorDown: aKeyboardEvent
	"Private - Move cursor from position in current line to same position in
	next line. If next line too short, put at end. If shift key down,
	select."

	self
		moveCursor: [ :position | | newPos |
			newPos := self sameColumn: position newLine: [ :line | line + 1 ] forward: true.
			"Mac standard keystroke"
			aKeyboardEvent rawMacOptionKeyPressed ifTrue: [
				newPos := self endOfParagraph: position+1 ].
			"Windows / Linux standard keystroke"
			aKeyboardEvent controlKeyPressed ifTrue: [
				newPos := self beginningOfNextParagraph: position ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self endOfText ].
			newPos ]
		forward: true
		event: aKeyboardEvent.
	^ true! !
!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 1/23/2025 16:16:20' overrides: 16852042!
       cursorPageDown: aKeyboardEvent 

	self 
		moveCursor: [ :position |
			self
				sameColumn: position
				newLine: [ :lineNo | lineNo + self pageHeight]
				forward: true]
		forward: true
		event: aKeyboardEvent.
	^true! !
!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 1/23/2025 16:16:25' overrides: 16852052!
                         cursorPageUp: aKeyboardEvent 

	self 
		moveCursor: [ :position |
			self
				sameColumn: position
				newLine: [ :lineNo | lineNo - self pageHeight]
				forward: false]
		forward: false
		event: aKeyboardEvent.
	^true! !
!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 1/23/2025 16:15:52' overrides: 16852088!
                         cursorUp: aKeyboardEvent 
	"Private - Move cursor from position in current line to same position in
	prior line. If prior line too short, put at end"

	self
		moveCursor: [ :position | | newPos |
			newPos := self sameColumn: position newLine: [ :line | line - 1] forward: false.
			"Mac standard keystroke"
			(aKeyboardEvent rawMacOptionKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [
						newPos := self beginningOfParagraph: newPos-1 ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self beginningOfText ].
			newPos ]
		forward: false
		event: aKeyboardEvent.
	^true! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 1/23/2025 16:59:21' prior: 16852489 overrides: 16917943!
                            initialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c | c initializeKeyboardActions ].! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 1/23/2025 16:19:24' prior: 16852495!
                      initializeKeyboardActions
	"Initialize the table for regular (i.e. non-command) keystroke dispatch"
	"
	self initializeKeyboardActions
	"
	| actions |
	actions := Array new: 256 withAll: #normalCharacter:.
	0 to: 31 do: [ :i | actions at: i+1 put: #noop: ].
	actions at: 1 + 1 put: #cursorHome:.				"home key"
	actions at: 3 + 1 put: #enter:.					"enter / return key"
	actions at: 4 + 1 put: #cursorEnd:.				"end key"
	actions at: 5 + 1 put: #noop:.					"insert key"
	actions at: 8 + 1 put: #backspace:.				"macDelete winBackspace key"
	actions at: 9 + 1 put: #normalCharacter:.		"tab"
	actions
		at:  InputSensor returnKey + 1
		put: #returnKey:.							"return (sometimes labelled enter) key"
	actions at: 27 + 1 put: #offerMenuFromEsc:.		"escape key"
	actions at: 28 + 1 put: #cursorLeft:.				"left arrow key"
	actions at: 29 + 1 put: #cursorRight:.			"right arrow key"
	actions at: 127 + 1 put: #forwardDelete:.		"winDelete key"
	keyboardActions := actions! !
!TextEditor class methodsFor: 'class initialization' stamp: 'jmv 1/23/2025 16:19:30' prior: 16983747 overrides: 50356427!
   initializeKeyboardActions
	
	super initializeKeyboardActions.
	keyboardActions at: 9 + 1 put: #tabKey:.
	keyboardActions at: 11 + 1 put: #cursorPageUp:.			"page up key"
	keyboardActions at: 12 + 1 put: #cursorPageDown:.		"page down key"
	keyboardActions at: 30 + 1 put: #cursorUp:.				"up arrow key"
	keyboardActions at: 31 + 1 put: #cursorDown:.			"down arrow key"! !

Editor removeSelector: #cursorDown:!

!methodRemoval: Editor #cursorDown: stamp: 'Install-7018-Editor-TextEditor-Refactor-JuanVuletich-2025Jan23-16h56m-jmv.001.cs.st 1/29/2025 14:59:57'!
cursorDown: aKeyboardEvent
	"Private - Move cursor from position in current line to same position in
	next line. If next line too short, put at end. If shift key down,
	select."

	self
		moveCursor: [ :position | | newPos |
			newPos := self sameColumn: position newLine: [ :line | line + 1 ] forward: true.
			"Mac standard keystroke"
			aKeyboardEvent rawMacOptionKeyPressed ifTrue: [
				newPos := self endOfParagraph: position+1 ].
			"Windows / Linux standard keystroke"
			aKeyboardEvent controlKeyPressed ifTrue: [
				newPos := self beginningOfNextParagraph: position ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self endOfText ].
			newPos ]
		forward: true
		event: aKeyboardEvent.
	^ true!

Editor removeSelector: #cursorPageDown:!

!methodRemoval: Editor #cursorPageDown: stamp: 'Install-7018-Editor-TextEditor-Refactor-JuanVuletich-2025Jan23-16h56m-jmv.001.cs.st 1/29/2025 14:59:57'!
cursorPageDown: aKeyboardEvent 

	self 
		moveCursor: [ :position |
			self
				sameColumn: position
				newLine: [ :lineNo | lineNo + self pageHeight]
				forward: true]
		forward: true
		event: aKeyboardEvent.
	^true!

Editor removeSelector: #cursorUp:!

!methodRemoval: Editor #cursorUp: stamp: 'Install-7018-Editor-TextEditor-Refactor-JuanVuletich-2025Jan23-16h56m-jmv.001.cs.st 1/29/2025 14:59:57'!
cursorUp: aKeyboardEvent 
	"Private - Move cursor from position in current line to same position in
	prior line. If prior line too short, put at end"

	self
		moveCursor: [ :position | | newPos |
			newPos := self sameColumn: position newLine: [ :line | line - 1] forward: false.
			"Mac standard keystroke"
			(aKeyboardEvent rawMacOptionKeyPressed or: [
				"Windows / Linux standard keystroke"
				aKeyboardEvent controlKeyPressed ])
					ifTrue: [
						newPos := self beginningOfParagraph: newPos-1 ].
			"Mac standard keystroke"
			aKeyboardEvent commandAltKeyPressed ifTrue: [
				newPos := self beginningOfText ].
			newPos ]
		forward: false
		event: aKeyboardEvent.
	^true!

Editor removeSelector: #cursorPageUp:!

!methodRemoval: Editor #cursorPageUp: stamp: 'Install-7018-Editor-TextEditor-Refactor-JuanVuletich-2025Jan23-16h56m-jmv.001.cs.st 1/29/2025 14:59:57'!
cursorPageUp: aKeyboardEvent 

	self 
		moveCursor: [ :position |
			self
				sameColumn: position
				newLine: [ :lineNo | lineNo - self pageHeight]
				forward: false]
		forward: false
		event: aKeyboardEvent.
	^true!

Editor initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7018-Editor-TextEditor-Refactor-JuanVuletich-2025Jan23-16h56m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7004] on 23 January 2025 at 5:03:00 pm'!
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 1/23/2025 16:01:36' prior: 16925178 overrides: 16926276!
                 keyStroke: aKeyboardEvent 
	"Process keys"

	| aCharacter |
	super keyStroke: aKeyboardEvent.
	aKeyboardEvent wasHandled ifTrue: [ ^self ].
	
	(self arrowKey: aKeyboardEvent) ifNotNil: [
		^ aKeyboardEvent wasHandled: true ].

	"All the cases below consume the event."
	aKeyboardEvent wasHandled: true.
	aKeyboardEvent isReturnKey ifTrue: [
		^doubleClickSelector notNil ifTrue: [(self window ifNil: [model]) perform: doubleClickSelector]].
	aKeyboardEvent isEsc ifTrue: [ ^ self mouseButton2Activity ].
	aKeyboardEvent isDelete ifTrue: [ ^ self deleteAction ].
	aKeyboardEvent isBackspace ifTrue: [ ^ self deleteAction ].
	
	aCharacter := aKeyboardEvent keyCharacter.
	^ self keyboardSearch: aCharacter! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7019-PluggableListMorph-Enter-sameAs-doubleClick-JuanVuletich-2025Jan23-17h00m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7010] on 24 January 2025 at 1:23:46 pm'!
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 1/24/2025 12:08:58' overrides: 16907215!
                          intoWorld: aWorld
	"The receiver has just appeared in a new world. Note:
		* aWorld can be nil (due to optimizations in other places)
		* owner is already set
		* owner's submorphs may not include receiver yet.
	Important: Keep this method fast - it is run whenever morphs are added."
	super intoWorld: aWorld.
	self activate.! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 1/24/2025 12:09:59' prior: 50335260 overrides: 50356231!
          openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| frameRect |
	frameRect := self initialFrameIn: aWorld.
	self morphExtent: frameRect extent.
	aWorld addMorph: self position: frameRect topLeft.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7020-SystemWindow-activate-when-intoWorld-JuanVuletich-2025Jan24-13h23m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7012] on 27 January 2025 at 3:53:44 pm'!

Character class removeSelector: #shortUnderscore!

!methodRemoval: Character class #shortUnderscore stamp: 'Install-7021-remove-shortUnderscore-JuanVuletich-2025Jan27-15h53m-jmv.001.cs.st 1/29/2025 14:59:57'!
shortUnderscore
	"Answer the Character representing very short (or invisible) underscore.
	Used to optionally mark subscript in code."

	^ `Character codePoint: 127`!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7021-remove-shortUnderscore-JuanVuletich-2025Jan27-15h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7021] on 27 January 2025 at 4:57:31 pm'!
!Character class methodsFor: 'private' stamp: 'eem 1/23/2025 18:02:02' prior: 50355144!
                    constantNames
	^ #(backQuote backspace cr delete doubleQuote escape home insert lf newPage noBreakSpace null pageUp singleQuote smalltalkDownArrow smalltalkLeftArrow smalltalkRightArrow smalltalkUpArrow space tab zeroWidthSpace)! !

Character class removeSelector: #enter!

!methodRemoval: Character class #enter stamp: 'Install-7022-Character-cleanup-JuanVuletich-2025Jan27-16h55m-jmv.001.cs.st 1/29/2025 14:59:57'!
enter
	"Answer the Character representing enter."

	^ `Character codePoint: 3`!

Character class removeSelector: #end!

!methodRemoval: Character class #end stamp: 'Install-7022-Character-cleanup-JuanVuletich-2025Jan27-16h55m-jmv.001.cs.st 1/29/2025 14:59:57'!
end

	^ `Character codePoint: 4`!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7022-Character-cleanup-JuanVuletich-2025Jan27-16h55m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6982] on 16 January 2025 at 2:58:40 pm'!

Smalltalk removeClassNamed: #WeakRegistry!

!classRemoval: #WeakRegistry stamp: 'Install-7023-WeakRegistry-removal-JuanVuletich-2025Jan16-14h56m-jmv.002.cs.st 1/29/2025 14:59:57'!
Collection subclass: #WeakRegistry
	instanceVariableNames: 'valueDictionary accessLock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7023-WeakRegistry-removal-JuanVuletich-2025Jan16-14h56m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7022] on 27 January 2025 at 5:20:17 pm'!
!WeakKeyDictionary commentStamp: '<historical>' prior: 17006814!
        I am a dictionary holding only weakly on my keys. This is a bit dangerous since at any time my keys can go away. Clients are responsible to register my instances by WeakArray such that the appropriate actions can be taken upon loss of any keys.
!
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: 'eem 12/18/2024 09:52:15' prior: 50335342!
                           finalizationProcess
	"The finalization process arranges to send mourn to each element of the VM's finalization queue,
	 which is accessed via primitiveFetchMourner.  The mourn queue contains Ephemerons whose
	 keys should be finalized. The VM signals FinalizationSemaphore whenever the queue is non-empty.
	 This process loops, waiting on the semaphore, fetches the first element of the queue and then
	 spawns a process at a higher priority to actually send the mourn messages. If an error occurs in
	 the higher priority mourn loop process then this process will simply spawn another process, hence
	 ensuring that errors in finalization methods don't break finalization."
	| throttle firstMourner |
	throttle := Semaphore new.
	[true] whileTrue:
		[FinalizationSemaphore wait; initSignals.
		
		 [firstMourner := self primitiveFetchMourner.
		  firstMourner notNil] whileTrue:
			[[throttle signal.
			  self mournLoopWith: firstMourner] forkAt: Processor activePriority + 1  named: '[system] Ephemeron Mourning'.
			  throttle wait]]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
EphemeronFinalizationProcess restartFinalizationProcess!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7024-WeakFinalization-remove-p1-JuanVuletich-2025Jan27-17h18m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #7024] on 27 January 2025 at 5:25:38 pm'!

Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock '
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakArray category: #'Collections-Weak' stamp: 'Install-7025-WeakFinalization-remove-p2-JuanVuletich-2025Jan27-17h23m-jmv.001.cs.st 1/29/2025 14:59:57'!
Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: 'FinalizationDependents FinalizationLock'
	poolDictionaries: ''
	category: 'Collections-Weak'!

EphemeronFinalizationProcess class removeSelector: #doWeakFinalizationWork!

!methodRemoval: EphemeronFinalizationProcess class #doWeakFinalizationWork stamp: 'Install-7025-WeakFinalization-remove-p2-JuanVuletich-2025Jan27-17h23m-jmv.001.cs.st 1/29/2025 14:59:57'!
doWeakFinalizationWork
	" Fork off the old weak array processing logic" 
	
	[WeakArray doWeakFinalizationWork] forkAt: Processor activePriority + 2 named: '[system] Ephemeron WeakArray processing'!

WeakArray class removeSelector: #initialize!

!methodRemoval: WeakArray class #initialize stamp: 'Install-7025-WeakFinalization-remove-p2-JuanVuletich-2025Jan27-17h23m-jmv.001.cs.st 1/29/2025 14:59:57'!
initialize
	"
	WeakArray initialize.
	"

	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].
	FinalizationLock := Semaphore forMutualExclusion.!

WeakArray class removeSelector: #removeWeakDependent:!

!methodRemoval: WeakArray class #removeWeakDependent: stamp: 'Install-7025-WeakFinalization-remove-p2-JuanVuletich-2025Jan27-17h23m-jmv.001.cs.st 1/29/2025 14:59:57'!
removeWeakDependent: anObject

	FinalizationLock critical:[
		1 to: FinalizationDependents size do:[:i|
			((FinalizationDependents at: i) == anObject) ifTrue:[
				FinalizationDependents at: i put: nil.
			].
		].
	] ifError:[:msg :rcvr| rcvr error: msg].!

WeakArray class removeSelector: #addWeakDependent:!

!methodRemoval: WeakArray class #addWeakDependent: stamp: 'Install-7025-WeakFinalization-remove-p2-JuanVuletich-2025Jan27-17h23m-jmv.001.cs.st 1/29/2025 14:59:57'!
addWeakDependent: anObject
	FinalizationLock critical: [
		| finished index weakDependent |
		finished := false.
		index := 0.
		[index := index + 1.
		finished not and:[index <= FinalizationDependents size]] whileTrue:[
			weakDependent := FinalizationDependents at: index.
			weakDependent ifNil:[
				FinalizationDependents at: index put: anObject.
				finished := true.
			].
		].
		finished ifFalse:[
			"Grow linearly"
			FinalizationDependents := FinalizationDependents, (WeakArray new: 10).
			FinalizationDependents at: index put: anObject.
		].
	] ifError:[:msg :rcvr| rcvr error: msg].!

WeakArray class removeSelector: #doWeakFinalizationWork!

!methodRemoval: WeakArray class #doWeakFinalizationWork stamp: 'Install-7025-WeakFinalization-remove-p2-JuanVuletich-2025Jan27-17h23m-jmv.001.cs.st 1/29/2025 14:59:57'!
doWeakFinalizationWork
	"Process the weak registries, in the old finalization style.  Hopefully this will
	 eventually go away when all clients have adopted the new finalization scheme."
	FinalizationLock
		critical:
			[FinalizationDependents do:
				[ :weakDependent |
				weakDependent ifNotNil:
					[weakDependent finalizeValues]]]
		ifError:
			[:msg :rcvr | rcvr error: msg]!

Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

!classDefinition: #WeakArray category: #'Collections-Weak' stamp: 'Install-7025-WeakFinalization-remove-p2-JuanVuletich-2025Jan27-17h23m-jmv.001.cs.st 1/29/2025 14:59:57'!
Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Collections-Weak'!

WeakArray initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7025-WeakFinalization-remove-p2-JuanVuletich-2025Jan27-17h23m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7024] on 27 January 2025 at 5:39:27 pm'!
!EphemeronFinalizationProcess class methodsFor: 'finalization' stamp: 'JMM 11/29/2024 14:30:48'!
ensureFinalizationComplete

	Smalltalk garbageCollect.
	Processor activePriority >= self runningFinalizationProcess priority ifTrue: [
		"Not needed if the default priorities are used. Just in case."
		Processor activeProcess priority: self runningFinalizationProcess priority-1.
		Processor yield ].! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/16/2025 16:45:25' prior: 16967274!
             quit
	"Just quit. No questions asked. No validations done.
	Smalltalk quit.
	"

	(SourceFiles at: 2) ifNotNil: [ :changes |
		ChangesInitialFileSize ifNotNil: [ changes truncate: ChangesInitialFileSize ]].
	ActiveModel flushEventSystem.
	"These could be moved to some #shutDown"
	self stopLowSpaceWatcher.
	ProcessorScheduler stopBackgroundProcess.

	"Be sure all unreferenced objects are finalized as approriate."
	EphemeronFinalizationProcess ensureFinalizationComplete.
	EphemeronFinalizationProcess stopFinalizationProcess.

	self processShutDownList: true.
	self closeSourceFiles.

	"Do image save & quit as apropriate"
	self quitPrimitive.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/16/2025 16:45:31' prior: 16967650!
                    snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
	"This is the main method for image save and / or quit.
	See senders."
	"WARNING: Current process will be killed. UI Process will be restarted"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic
	checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
	| activeProc |
	"If it is just about quitting, do it the simpler way."
	save not & quit ifTrue: [
		self quit.
		"Execution doesn't reach this point"
		^self.
	].
	self logSnapshot: save andQuit: quit.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each |
			each isInWorld ifTrue: [ each delete.]].
		UISupervisor ui tearDownDesktop.
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	"These could be moved to some #shutDown"
	self stopLowSpaceWatcher.
	ProcessorScheduler stopBackgroundProcess.
	"Be sure all unreferenced objects are finalized as approriate."
	EphemeronFinalizationProcess ensureFinalizationComplete.
	EphemeronFinalizationProcess stopFinalizationProcess.
	activeProc := Processor activeProcess.
[
	| isARealStartup guiRootObject guiRootObjectClass userBaseDirectory |
	"Stuff needed to relaunch UI on startup"
	guiRootObjectClass := UISupervisor ui class.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	guiRootObject := clearAllStateFlag ifFalse: [ UISupervisor ui ].

	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [ activeProc terminate ].
	guiRootObject ifNotNil: [ guiRootObject releaseCachedState ].
	clearAllStateFlag ifTrue: [
		Processor processesDo: [ :p |
			(p name = 'Formerly: Morphic UI') ifTrue: [ p terminate ]]].
	MorphicCanvas allSubInstancesDo: [ :c |
		c nilState ].
	self processShutDownList: quit.

	"Clean Globals"
	userBaseDirectory := DirectoryEntry userBaseDirectory.
	self at: #Sensor put: nil.
	self closeSourceFiles.
	self at: #SourceFiles put: nil.
	self allClassesDo: [ :cls |
		cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [
		self allClassesDo: [ :cls |
			cls releaseClassState ]].
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [
		Transcript clear.
		"Enable this call to actually see the image clean report."
		false ifTrue: [self printStuffToCleanOnImageSave]].
	"Do image save & quit as apropriate"
	(Cursor cursorAt: #writeCursor) activateCursor.
	isARealStartup := false.
	save ifTrue: [
		"The snapshot primitive answers false if it was just called to do the snapshot.
		But image startup is resumed by returning (again) from the primitive, but this time answering true.
		nil means saving image failed"
		isARealStartup := embeddedFlag
			ifTrue: [ self snapshotEmbeddedPrimitive ]
			ifFalse: [ self snapshotPrimitive ]].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ]. "Don't quit on nil (image save failed)"

	isARealStartup == true ifFalse: [ 									"Keep current #userBaseDirectory unless a real startup"
		DirectoryEntry setUserBaseDirectory: userBaseDirectory ].

	"If starting from absolute scratch, this would be a good time to recreate Global names"
	self at: #Sensor put: nil.
	self at: #SourceFiles put: (Array new: 2).
	self logStartupDebugAid: 'To #openSourceFiles'.
	self openSourceFiles.
	"Here, startup begins!! (isARealStartup might be nil)"
	self logStartupDebugAid: 'To #initClassCachedState'.
	self allClassesDo: [ :cls | cls initClassCachedState ].
	self logStartupDebugAid: 'To #doStartUp:'.
	self doStartUp: isARealStartup == true.
	self logStartupDebugAid: 'To #spawnNewMorphicProcessFor: ', guiRootObject printString.
	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject := guiRootObjectClass newWorld ]).
	isARealStartup == true
		ifTrue: [
			self logStartupDebugAid: 'To #checkIfAlreadyRunningOrStoppedNoExit'.
			self checkIfAlreadyRunningOrStoppedNoExit.
			"Some command line arguments need to be processed before starting the UI"
			self processCommandLineArguments: true.
			self assureStartupStampLogged ].
	clearAllStateFlag ifTrue: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #recreateDefaultDesktop'.
			guiRootObject recreateDefaultDesktop; restoreDisplay ]]
	ifFalse: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #restoreDisplay'.
			guiRootObject restoreDisplay ]].
	"It is needed to do this at least once on MacVMs, where it may not be needed later.
	For instance #forceToScreen: is usually not called in #displayWorldOn: if running on Mac."
	Display forceToScreen.
	isARealStartup == true
		ifTrue: [
			"If system is coming up (VM and image just started)"
			UISupervisor whenUIinSafeState: [
				self logStartupDebugAid: 'To #readAndApplyUserPrefs'.
				self readAndApplyUserPrefs.
				self logStartupDebugAid: 'To #processCommandLineArguments'.
				"Some command line arguments need to be processed after the UI is up, and in the UI process"
				self processCommandLineArguments: false.
				self logStartupDebugAid: 'To #launchApp'.
				AppLauncher launchApp ]]
		ifFalse: [
			"If we are just saving the image"
			UISupervisor whenUIinSafeState: [
				self logStartupDebugAid: 'To #readAndApplyUserPrefs'.
				self readAndApplyUserPrefs ]].
	"Now it's time to raise an error"
	isARealStartup ifNil: [ self logStartupError: 'Failed to write image file (disk full?)' ]
]
	forkAt: Processor timingPriority - 1
	named: 'Startup process'.! !

WeakArray class removeSelector: #stopFinalizationProcess!

!methodRemoval: WeakArray class #stopFinalizationProcess stamp: 'Install-7026-Finalization-Cleanup-JuanVuletich-2025Jan27-17h25m-jmv.001.cs.st 1/29/2025 14:59:58'!
stopFinalizationProcess
	"kill old process"
	EphemeronFinalizationProcess stopFinalizationProcess!

WeakArray class removeSelector: #runningFinalizationProcess!

!methodRemoval: WeakArray class #runningFinalizationProcess stamp: 'Install-7026-Finalization-Cleanup-JuanVuletich-2025Jan27-17h25m-jmv.001.cs.st 1/29/2025 14:59:58'!
runningFinalizationProcess
	"Answer the FinalizationProcess I am running, if any"
	^EphemeronFinalizationProcess runningFinalizationProcess!

WeakArray class removeSelector: #finalizationProcess!

!methodRemoval: WeakArray class #finalizationProcess stamp: 'Install-7026-Finalization-Cleanup-JuanVuletich-2025Jan27-17h25m-jmv.001.cs.st 1/29/2025 14:59:58'!
finalizationProcess
	"nothing here, moved to EphemeronFinalizationProcess class"
	^EphemeronFinalizationProcess runningFinalizationProcess!

WeakArray class removeSelector: #ensureFinalizationComplete!

!methodRemoval: WeakArray class #ensureFinalizationComplete stamp: 'Install-7026-Finalization-Cleanup-JuanVuletich-2025Jan27-17h25m-jmv.001.cs.st 1/29/2025 14:59:58'!
ensureFinalizationComplete

	Smalltalk garbageCollect.
	Processor activePriority >= self finalizationProcess priority ifTrue: [
		"Not needed if the default priorities are used. Just in case."
		Processor activeProcess priority: self finalizationProcess priority-1.
		Processor yield ].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7026-Finalization-Cleanup-JuanVuletich-2025Jan27-17h25m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7026] on 28 January 2025 at 11:10:42 am'!
!ClassOrganizer methodsFor: 'accessing' stamp: 'jmv 1/28/2025 11:07:43' prior: 16820850 overrides: 16803470!
                            setDefaultList: anArray
	| oldDict oldCategories |
	oldDict := self elementCategoryDict.
	oldCategories := self categories copy.
	SystemChangeNotifier uniqueInstance doSilently: [
		categoryArray := anArray isEmpty ifTrue: [#()] ifFalse: [{self class defaultCategory}].
		categoryStops := Array with: anArray size.
		elementArray := anArray ].
	self notifyOfChangedSelectorsOldDict: oldDict newDict: self elementCategoryDict.
	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7027-NoUnclassifiedMethodsInNewClasses-JuanVuletich-2025Jan28-11h09m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7027] on 28 January 2025 at 1:55:34 pm'!
!Categorizer methodsFor: 'accessing' stamp: 'jmv 1/28/2025 13:52:24'!
            initEmpty
	categoryArray :=#().
	categoryStops := #().
	elementArray := #().! !
!Categorizer class methodsFor: 'instance creation' stamp: 'jmv 1/28/2025 13:52:36'!
                            empty
	"Answer an instance of me with initial elements from the argument"

	^self new initEmpty! !
!ClassOrganizer methodsFor: 'accessing' stamp: 'jmv 1/28/2025 13:52:28' overrides: 50357203!
initEmpty
	SystemChangeNotifier uniqueInstance doSilently: [
		super initEmpty ].! !
!ClassOrganizer methodsFor: 'accessing' stamp: 'jmv 1/28/2025 12:29:42'!
  unclassifiedSelectors: anArray

	SystemChangeNotifier uniqueInstance doSilently: [
		categoryArray := {self class defaultCategory}.
		categoryStops := {anArray size}.
		elementArray := anArray ].! !
!ClassOrganizer class methodsFor: 'instance creation' stamp: 'jmv 1/28/2025 12:42:38'!
  withUnclassifiedSelectors: anArray 

	^self new unclassifiedSelectors: anArray! !
!PseudoClassOrganizer methodsFor: 'accessing' stamp: 'jmv 1/28/2025 13:52:32' overrides: 50357203!
           initEmpty
	super initEmpty.
	self classComment: nil! !
!ClassDescription methodsFor: 'organization' stamp: 'jmv 1/28/2025 12:23:46' prior: 16820226!
           organization
	"Answer the instance of ClassOrganizer that represents the organization 
	of the messages of the receiver."

	organization ifNil:
		[self organization: (ClassOrganizer withUnclassifiedSelectors: self methodDict keys sort)].
	(organization isMemberOf: Array) ifTrue:
		[self recoverFromMDFaultWithTrace].
	
	"Making sure that subject is set correctly. It should not be necessary."
	organization ifNotNil: [organization setSubject: self].
	^ organization! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 1/28/2025 13:52:44' prior: 16803091!
                    changeFromString: aString 
	"Parse the argument, aString, and make this be the receiver's structure."

	| categorySpecs |
	categorySpecs := Scanner new scanTokens: aString.
	"If nothing was scanned and I had no elements before, then default me"
	(categorySpecs isEmpty and: [elementArray isEmpty])
		ifTrue: [^ self initEmpty].

	^ self changeFromCategorySpecs: categorySpecs! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 1/28/2025 12:07:37' prior: 16803287!
               removeCategory: cat 
	"Remove the category named, cat. Create an error notificiation if the 
	category has any elements in it."

	| index lastStop |
	index := categoryArray indexOf: cat ifAbsent: [^self].
	lastStop := 
		index = 1
			ifTrue: [0]
			ifFalse: [categoryStops at: index - 1].
	(categoryStops at: index) - lastStop > 0 
		ifTrue: [^self error: 'cannot remove non-empty category'].
	categoryArray := categoryArray copyReplaceFrom: index to: index with: #().
	categoryStops := categoryStops copyReplaceFrom: index to: index with: #().
! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 1/28/2025 12:06:32' prior: 16803342!
     removeEmptyCategories
	"Remove empty categories."

	| categoryIndex currentStop keptCategories keptStops |
	keptCategories := WriteStream on: (Array new: 16).
	keptStops := WriteStream on: (Array new: 16).
	currentStop := categoryIndex := 0.
	[(categoryIndex := categoryIndex + 1) <= categoryArray size]
		whileTrue: 
			[(categoryStops at: categoryIndex) > currentStop
				ifTrue: 
					[keptCategories nextPut: (categoryArray at: categoryIndex).
					keptStops nextPut: (currentStop := categoryStops at: categoryIndex)]].
	categoryArray := keptCategories contents.
	categoryStops := keptStops contents.

	"ClassOrganizer allInstancesDo: [:co | co removeEmptyCategories]."! !
!CodeFileBrowser methodsFor: 'accessing' stamp: 'jmv 1/28/2025 13:47:03' prior: 16822706 overrides: 16797463!
             contents: input notifying: aRequestor 
	"The retrieved information has changed and its source must now be 
	updated. The information can be a variety of things, depending on the 
	list selections (such as templates for class or message definition, methods) 
	or the user menu commands (such as definition, comment, hierarchy). 
	Answer the result of updating the source."

	| codeString theClass |
	codeString := input string.

	editSelection == #editComment 
		ifTrue: [
			theClass := self selectedClass.
			theClass ifNil: [
				self inform: 'You must select a class
before giving it a comment.'.
				^ false ].
			theClass comment: codeString. 
			^ true ].

	self inform:'You cannot change the current selection'.
	^false! !
!CodeFile methodsFor: 'accessing' stamp: 'jmv 1/28/2025 13:52:07' prior: 16822296!
                   organization
	^ SystemOrganizer empty.! !
!PseudoClass methodsFor: 'accessing' stamp: 'jmv 1/28/2025 13:52:10' prior: 16934477!
organization
	organization ifNil: [
		organization := PseudoClassOrganizer empty].

	"Making sure that subject is set correctly. It should not be necessary."
	organization setSubject: self.
	^ organization! !
!PseudoClass methodsFor: 'methods' stamp: 'jmv 1/28/2025 13:44:25' prior: 16934825!
                           removeSelector: aSelector
	| catName |
	catName := self class removedCategoryName asPlainString.
	self organization addCategory: catName before:
		(self organization categories ifNotEmpty: [ :coll | coll first ]).
	self organization classify: aSelector under: catName.
	self sourceCodeAt: aSelector put:'methodWasRemoved' asText.! !

CodeFileBrowser removeSelector: #changeMessageCategories:!

!methodRemoval: CodeFileBrowser #changeMessageCategories: stamp: 'Install-7028-MethodCategorizationFixes-JuanVuletich-2025Jan28-13h53m-jmv.001.cs.st 1/29/2025 14:59:58'!
changeMessageCategories: aString 
	"The characters in aString represent an edited version of the the message 
	categories for the selected class. Update this information in the system 
	and inform any dependents that the categories have been changed. This 
	message is invoked because the user had issued the categories command 
	and edited the message categories. Then the user issued the accept 
	command."

	self classOrMetaClassOrganizer changeFromString: aString.
	self unlock.
	self editClass.
	self classListIndex: self classListIndex.
	^ true!

PseudoClassOrganizer removeSelector: #setDefaultList:!

!methodRemoval: PseudoClassOrganizer #setDefaultList: stamp: 'Install-7028-MethodCategorizationFixes-JuanVuletich-2025Jan28-13h53m-jmv.001.cs.st 1/29/2025 14:59:58'!
setDefaultList: anArray
	super setDefaultList: anArray.
	self classComment: nil!

ClassOrganizer removeSelector: #setDefaultList:!

!methodRemoval: ClassOrganizer #setDefaultList: stamp: 'Install-7028-MethodCategorizationFixes-JuanVuletich-2025Jan28-13h53m-jmv.001.cs.st 1/29/2025 14:59:58'!
setDefaultList: anArray
	| oldDict oldCategories |
	oldDict := self elementCategoryDict.
	oldCategories := self categories copy.
	SystemChangeNotifier uniqueInstance doSilently: [
		categoryArray := anArray isEmpty ifTrue: [#()] ifFalse: [{self class defaultCategory}].
		categoryStops := Array with: anArray size.
		elementArray := anArray ].
	self notifyOfChangedSelectorsOldDict: oldDict newDict: self elementCategoryDict.
	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.!

Categorizer class removeSelector: #defaultList:!

!methodRemoval: Categorizer class #defaultList: stamp: 'Install-7028-MethodCategorizationFixes-JuanVuletich-2025Jan28-13h53m-jmv.001.cs.st 1/29/2025 14:59:58'!
defaultList: anArray 
	"Answer an instance of me with initial elements from the argument, 
	aSortedCollection."

	^self new setDefaultList: anArray!

Categorizer removeSelector: #setDefaultList:!

!methodRemoval: Categorizer #setDefaultList: stamp: 'Install-7028-MethodCategorizationFixes-JuanVuletich-2025Jan28-13h53m-jmv.001.cs.st 1/29/2025 14:59:58'!
setDefaultList: anArray

	categoryArray := Array with: self class defaultCategory.
	categoryStops := Array with: anArray size.
	elementArray := anArray!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7028-MethodCategorizationFixes-JuanVuletich-2025Jan28-13h53m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7028] on 28 January 2025 at 2:24:23 pm'!
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 1/27/2025 15:21:40' overrides: 16795944!
                     interiorExtent
	| p |
	p := super interiorExtent.
	^p x @ (p y - self labelHeight)! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 1/27/2025 15:21:19' overrides: 16795951!
                interiorOrigin
	| p |
	p := super interiorOrigin.
	^p x @ (p y + self labelHeight)! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 1/27/2025 15:22:42' prior: 50340514 overrides: 50340611!
extentChanged: oldExtent
	"Our extent changed.
	- Reposition adjusters
	- Resize our layoutMorph"

	| h thickness w cornerExtent wh ww halfThickness |
	thickness := self borderWidth.
	halfThickness := thickness * 0.5.
	cornerExtent := thickness * 5.
	ww := extent x.
	wh := extent y.
	w := ww - cornerExtent - cornerExtent.
	h := wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) position: cornerExtent@halfThickness extent: w@0.
	(adjusters at: #bottomAdjuster) position: cornerExtent@(wh-halfThickness) extent: w@0.
	(adjusters at: #leftAdjuster) position: halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #rightAdjuster) position: ww-halfThickness@cornerExtent extent: 0@h.
	(adjusters at: #topLeftAdjuster) position: `0@0` extent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster) position: ww-cornerExtent@0 extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster) position: 0@(wh-cornerExtent) extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster) position: ww@wh-cornerExtent extent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		layoutMorph
			position: self interiorOrigin
			extent: self interiorExtent ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7029-SystemWindow-tweaks-JuanVuletich-2025Jan28-14h24m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7029] on 28 January 2025 at 3:28:19 pm'!

Smalltalk removeClassNamed: #ModalDialog!

!classRemoval: #ModalDialog stamp: 'Install-7030-RemoveFirstExperimental-ModalDialog-JuanVuletich-2025Jan28-15h26m-jmv.001.cs.st 1/29/2025 14:59:58'!
ModalMorph subclass: #ModalDialog
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-ModalWidgets'!

Smalltalk removeClassNamed: #ModalMorph!

!classRemoval: #ModalMorph stamp: 'Install-7030-RemoveFirstExperimental-ModalDialog-JuanVuletich-2025Jan28-15h26m-jmv.001.cs.st 1/29/2025 14:59:58'!
LayoutMorph subclass: #ModalMorph
	instanceVariableNames: 'callingProcess callingProcessIsUIProcess done response'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-ModalWidgets'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7030-RemoveFirstExperimental-ModalDialog-JuanVuletich-2025Jan28-15h26m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7029] on 28 January 2025 at 3:30:07 pm'!
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 1/28/2025 15:08:05' prior: 16892484!
      offAxisEdgeWeight: aSymbolOrNumber
	"A LayoutSpec may indicate a weighting perpendicular to the Layout Axis.   
	
	 This is the LayoutSpec's offAxisEdgeWeight which is between 0.0 and 1.0.

	As with LayoutSpec's a symbol may be used.

	If in a Row (preferred): { #rowTop (0.0), #center (0.5), #rowBottom (1.0)}

	If in a Column (preferred): { #columnLeft (0.0), #center (0.5), #columnRight (1.0) }

	Also accepted: { #leftOrTop (0.0), #center (0.5), #rightOrBottom (1.0) }
	"
	| edgeWeight |
	edgeWeight := (aSymbolOrNumber is: #Number)
		ifTrue: [ (aSymbolOrNumber between: 0.0 and: 1.0)
			ifTrue: [ aSymbolOrNumber ] 
			ifFalse: [self error: 'axisEdgeWeight ', aSymbolOrNumber printString, ' is out of range 0.0 to 1.0']
		]
		ifFalse: [ aSymbolOrNumber
			caseOf: {
				[ #leftOrTop ] 			-> [ 0.0 ].
				[ #rowTop ] 			-> [ 0.0 ].
				[ #columnLeft ]			-> [ 0.0 ].
				[ #center ] 				-> [ 0.5 ].
				[ #rightOrBottom ]		-> [ 1.0 ].
				[ #rowBottom ] 		-> [ 1.0 ].
				[ #columnRight ] 		-> [ 1.0 ]
			}
			otherwise: [ self error: 'bad offAxisEdgeWeight specifier: ', aSymbolOrNumber  printString ]
		].
	offAxisEdgeWeight := edgeWeight.
	self updateContainingLayout.! !
!LayoutSpec methodsFor: 'private' stamp: 'jmv 1/28/2025 15:10:24' prior: 50340653!
                   updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LayoutMorph) ifTrue:
			[ owningLayout layoutSubmorphs ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7031-LayoutSpec-fix-JuanVuletich-2025Jan28-15h28m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7029] on 28 January 2025 at 3:31:03 pm'!
!LabelMorph class methodsFor: 'instance creation' stamp: 'jmv 1/28/2025 15:17:11'!
                         contents: aString fontSize: pointSize emphasis: emphasisCode
	"
	(LabelMorph contents: 'I am a LabelMorph' fontSize: 25 emphasis: 3) openInWorld.
	"
	^ self basicNew
		initWithContents: aString
		font: (FontFamily defaultFamilyPointSize: pointSize)
		emphasis: emphasisCode.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7032-LabelMorph-creationMethod-JuanVuletich-2025Jan28-15h30m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7029] on 28 January 2025 at 3:32:33 pm'!

BorderedBoxMorph subclass: #Dialog
	instanceVariableNames: 'layoutMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!

!classDefinition: #Dialog category: #'Morphic-Composite Widgets' stamp: 'Install-7033-Dialog-ModalDialog-SampleModalDialog-JuanVuletich-2025Jan28-15h31m-jmv.001.cs.st 1/29/2025 14:59:58'!
BorderedBoxMorph subclass: #Dialog
	instanceVariableNames: 'layoutMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!
!Dialog commentStamp: '<historical>' prior: 0!
              Hierachy of UI Dialogs, both Modal and Non-Modal.!

Dialog subclass: #ModalDialog
	instanceVariableNames: 'callingProcess callingProcessIsUIProcess done response'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!

!classDefinition: #ModalDialog category: #'Morphic-Composite Widgets' stamp: 'Install-7033-Dialog-ModalDialog-SampleModalDialog-JuanVuletich-2025Jan28-15h31m-jmv.001.cs.st 1/29/2025 14:59:58'!
Dialog subclass: #ModalDialog
	instanceVariableNames: 'callingProcess callingProcessIsUIProcess done response'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!
!ModalDialog commentStamp: '<historical>' prior: 0!
            This class includes the fundamentals for any Modal Dialog.
For a more complete, working example, check SampleModalDialog.

Subclasses may offer both modal and non-modal functionality:
	SampleModalDialog openModal. "Print-it"
	SampleModalDialog open. "Nothing answered"
!

ModalDialog subclass: #SampleModalDialog
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!

!classDefinition: #SampleModalDialog category: #'Morphic-Composite Widgets' stamp: 'Install-7033-Dialog-ModalDialog-SampleModalDialog-JuanVuletich-2025Jan28-15h31m-jmv.001.cs.st 1/29/2025 14:59:58'!
ModalDialog subclass: #SampleModalDialog
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!
!SampleModalDialog commentStamp: '<historical>' prior: 0!
                          SampleModalDialog openModal. "Print-it"
SampleModalDialog open. "Nothing answered"
!
!Dialog methodsFor: 'defaults' stamp: 'jmv 1/27/2025 14:58:41' overrides: 16795899!
                       defaultColor
	^ Theme current defaultWindowColor! !
!Dialog methodsFor: 'defaults' stamp: 'jmv 1/27/2025 14:58:45' overrides: 16796206!
                        defaultExtent
	^`400@300`! !
!Dialog methodsFor: 'defaults' stamp: 'jmv 1/27/2025 14:58:48' overrides: 16795903!
               defaultPadding
	^ `30@10`! !
!Dialog methodsFor: 'layout' stamp: 'jmv 1/27/2025 15:01:32'!
     beColumn
	layoutMorph
		ifNotNil: [ layoutMorph beColumn ]
		ifNil: [
			layoutMorph := LayoutMorph newColumn.
			self addMorphFront: layoutMorph ]! !
!Dialog methodsFor: 'geometry' stamp: 'jmv 1/27/2025 15:24:58' overrides: 50340611!
                     extentChanged: oldExtent
	"Our extent changed.
	- Resize our layoutMorph"

	layoutMorph ifNotNil: [
		layoutMorph
			position: self interiorOrigin
			extent: self interiorExtent ].! !
!Dialog methodsFor: 'geometry' stamp: 'jmv 1/27/2025 15:31:11' overrides: 16795958!
                    minimumExtent
	^layoutMorph minimumExtent + (borderWidth + padding * 2)! !
!Dialog class methodsFor: 'instance creation' stamp: 'jmv 1/27/2025 15:44:05'!
      open
	"Open a Non-Modal Dialog. Answer user's response (if OK) or nil (if Cancel)
	This is an abstract class. Better play with SampleModalDialog. Inspect the result of:
		SampleModalDialog open
	"
	| world dialog |
	world := self runningWorld ifNil: [UISupervisor ui].
	dialog := self new beColumn buildWidgets.
	world addMorph: dialog centeredNear: world activeHand morphPosition.
	^ dialog.! !
!ModalDialog methodsFor: 'modal UI' stamp: 'jmv 1/27/2025 14:57:55' overrides: 16908168!
                           delete
	"Resume the calling process, so #waitForUserResponse can finish and answer 'response'."

	super delete.
	done ifFalse: [
		done := true.
		callingProcess ifNotNil: [ "Only if (as usual) our calling process is suspended"
			callingProcessIsUIProcess
				ifTrue: [
					UISupervisor uiProcess: callingProcess.
					callingProcess := nil.
					Processor terminateActive ]
				ifFalse: [
					callingProcess resume.
					callingProcess := nil ]]].! !
!ModalDialog methodsFor: 'modal UI' stamp: 'jmv 1/27/2025 14:57:59'!
                    waitForUserResponse
	"Wait for the user to accept or cancel, and answer the response. Answers nil if the user cancels."
	"Details:
	This method suspends the current process until we have an appropriate 'response' and close.
	To keep the UI alive, it schedules a new Morphic Process that is terminated as ours is resumed.
	(If called from a non-UI process, a new Morphic process is not needed, but the calling process is suspended nevertheless)."

	| w |
	w := self world.
	w isNil ifTrue: [^ response ].
	callingProcess := nil.
	done := false.

	"If called from the UI process, suspend it (to later resume it with the answer)
	and run a new UI process for UI interaction with the receiver.."
	callingProcessIsUIProcess := UISupervisor isUIProcessRunning.
	callingProcessIsUIProcess ifTrue: [
		UISupervisor spawnNewMorphicProcessFor: w createNewCanvas: false ].

	"Suspend the calling process, regardless of it being the UI process or not.
	Usually variable 'done' will be false at this point.
	In the extremely rare case where user has already done [ok] or [cancel] in the just spawned new UI process,
	don't suspend us, as no one would resume us again."
	done ifFalse: [
		callingProcess := Processor activeProcess.
		callingProcess suspend ].

	"At this point we are resumed by #deleteAndResumeCallingProcess, after user doing [ok] or [cancel]"
	^ response.! !
!ModalDialog methodsFor: 'events' stamp: 'jmv 1/27/2025 14:59:20'!
         cancel
	"May be redefined in subclasses. This default implementation may be enough, though."

	response := nil.
	self delete.! !
!ModalDialog methodsFor: 'events' stamp: 'jmv 1/27/2025 14:59:15'!
                            ok
	"This is a sample implementation. Subclasses should prepare a meaningful response"

	response := 'Build an appropriate response for OK'.
	self delete.! !
!ModalDialog methodsFor: 'initialization' stamp: 'jmv 1/27/2025 15:47:50' overrides: 16795911!
   initialize
	super initialize.
	done := false.! !
!ModalDialog class methodsFor: 'instance creation' stamp: 'jmv 1/27/2025 15:50:02'!
                           openModal
	"Open a Modal Dialog. Answer user's response (if OK) or nil (if Cancel)
	This is an abstract class. Better play with SampleModalDialog. Inspect the result of:
		SampleModalDialog openModal
	Note: a ModalDialog can also be opened in non-modal mode calling #open.
		No answer will be returned, so #ok and #cancel need to do any approriate actions.
	"
	| world dialog |
	world := self runningWorld ifNil: [UISupervisor ui].
	dialog := self new beColumn buildWidgets.
	world addMorph: dialog centeredNear: world activeHand morphPosition.
	^ dialog waitForUserResponse.! !
!SampleModalDialog methodsFor: 'initialization' stamp: 'jmv 1/27/2025 15:33:03'!
            buildWidgets
	"
	This is a sample implementation. Actual subclasses should reimplement #buildWidgets (without calling super!!).
	self openModal
	"

	| typeRow buttonRow |
	typeRow := LayoutMorph newRow.
	typeRow
		addMorph: (LabelMorph contents: 'Type');
		addMorph: (LabelMorph contents: 'So what');
		addMorph: (LabelMorph contents: 'And then').
	buttonRow := LayoutMorph newRow.
	buttonRow
		padding: 10;
		gap: 20;
		addMorph: (PluggableButtonMorph model: self action: #ok label: 'Ok');
		addMorph: (PluggableButtonMorph model: self action: #cancel label: 'Cancel').
	layoutMorph
		addMorph: 
			((LabelMorph contents: 'This is a title for this Dialog' fontSize: 25)
				borderWidth: 2; borderColor: color lighter;
				padding: 20);
		addMorph: Sample01Star new;
		addMorph: typeRow;
		addMorph: buttonRow.
	layoutMorph
		position: self interiorOrigin
		extent: self interiorExtent! !
!SampleModalDialog methodsFor: 'layout' stamp: 'jmv 1/27/2025 15:32:15' overrides: 50357698!
          defaultExtent
	^`600@400`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7033-Dialog-ModalDialog-SampleModalDialog-JuanVuletich-2025Jan28-15h31m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7029] on 28 January 2025 at 3:34:25 pm'!

Dialog subclass: #FindInSourceDialog
	instanceVariableNames: 'smalltalkEditor searchField initialSearchString scopeList package selectedScopeIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!

!classDefinition: #FindInSourceDialog category: #'Morphic-Composite Widgets' stamp: 'Install-7034-FindInSourceDialog-JuanVuletich-2025Jan28-15h33m-jmv.001.cs.st 1/29/2025 14:59:58'!
Dialog subclass: #FindInSourceDialog
	instanceVariableNames: 'smalltalkEditor searchField initialSearchString scopeList package selectedScopeIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Composite Widgets'!
!FindInSourceDialog methodsFor: 'initialization' stamp: 'jmv 1/28/2025 15:18:20'!
         buildWidgets

	| buttonRow titleMorph |
	titleMorph := (LabelMorph contents: 'Find in source code' fontSize: 16 emphasis: 1).
	titleMorph layoutSpec offAxisEdgeWeight: 0.
	searchField := EntryFieldMorph new.
	searchField
		crAction: [ self ok ];
		escAction: [ self cancel ].
	searchField layoutSpec offAxisEdgeWeight: 0.
	initialSearchString ifNotNil: [ searchField contents: initialSearchString ].
	scopeList := PluggableListMorph
		withModel: self
		listGetter: #scopesList
		indexGetter: #scopeIndex
		indexSetter: #scopeIndex:.
	scopeList 
		doubleClickSelector: #ok.
	buttonRow := LayoutMorph newRow.
	buttonRow
		addMorph: (PluggableButtonMorph model: self action: #ok label: 'Ok');
		addMorph: (PluggableButtonMorph model: self action: #cancel label: 'Cancel').
	layoutMorph
		gap: 14;
		addMorphKeepMorphHeight: titleMorph;
		addMorphKeepMorphHeight: searchField;
		addMorphUseAll: scopeList;
		addMorphKeepMorphHeight: buttonRow.
	layoutMorph
		position: self interiorOrigin
		extent: self interiorExtent! !
!FindInSourceDialog methodsFor: 'initialization' stamp: 'jmv 1/28/2025 14:54:38' overrides: 16795911!
initialize
	super initialize.
	selectedScopeIndex := 1.! !
!FindInSourceDialog methodsFor: 'initialization' stamp: 'jmv 1/28/2025 14:59:13' overrides: 16907215!
                               intoWorld: aWorld
	"The receiver has just appeared in a new world. Note:
		* aWorld can be nil (due to optimizations in other places)
		* owner is already set
		* owner's submorphs may not include receiver yet.
	Important: Keep this method fast - it is run whenever morphs are added."
	super intoWorld: aWorld.
	"Steal focus even after some subwidget got it."
	self whenUIinSafeState: [aWorld activeHand newKeyboardFocus: self]! !
!FindInSourceDialog methodsFor: 'initialization' stamp: 'jmv 1/28/2025 14:54:56'!
                               smalltalkEditor: aSmalltalkEditor
	smalltalkEditor := aSmalltalkEditor.
	initialSearchString := smalltalkEditor selectedString asPlainString.! !
!FindInSourceDialog methodsFor: 'defaults' stamp: 'jmv 1/28/2025 15:05:25' overrides: 16795894!
               defaultBorderWidth
	"answer the default border width for the receiver"
	^ 0! !
!FindInSourceDialog methodsFor: 'defaults' stamp: 'jmv 1/28/2025 15:02:02' overrides: 50357698!
                 defaultExtent
	^`640@320`! !
!FindInSourceDialog methodsFor: 'defaults' stamp: 'jmv 1/28/2025 15:13:51' overrides: 50357702!
   defaultPadding
	^ `30@20`! !
!FindInSourceDialog methodsFor: 'events' stamp: 'jmv 1/28/2025 15:00:19'!
                         cancel
	self delete.! !
!FindInSourceDialog methodsFor: 'events' stamp: 'jmv 1/28/2025 15:00:23' overrides: 16905314!
          keyStroke: aKeyboardEvent
	"Avoid the need to give focus to subwidgets"

	(aKeyboardEvent isArrowUp or: [  aKeyboardEvent isArrowDown ]) ifTrue: [
		^scopeList keyStroke: aKeyboardEvent ].
	aKeyboardEvent isReturnKey ifTrue: [
		^self ok ].
	aKeyboardEvent isEsc ifTrue: [
		^self cancel ].
	^searchField keyStroke: aKeyboardEvent! !
!FindInSourceDialog methodsFor: 'events' stamp: 'jmv 1/28/2025 15:00:27'!
        ok
	| includeSubclasses includeSuperclasses searchString scopeClass |
	self delete.
	
	scopeClass := smalltalkEditor selectedClass.
	includeSubclasses := false.
	includeSuperclasses := false.

	searchString := searchField contents.

	(selectedScopeIndex = 0) ifTrue:[^self].
	(selectedScopeIndex = 1) "This method"
		ifTrue:[^smalltalkEditor find: searchString].
	(selectedScopeIndex = 2) "All methods in image"
		ifTrue:[scopeClass := nil].
	"(selection = 3) ifTrue:[]. ""Class only - nothing to do"
	(selectedScopeIndex = 4) "Class and subclasses"
		ifTrue:[includeSubclasses := true].
	(selectedScopeIndex = 5) "Class, subclasses, and superclasses"
		ifTrue:[
			includeSubclasses := true.
			includeSuperclasses := true].
	(selectedScopeIndex = 6) "In my package if any "
		ifTrue: [^ Smalltalk browseMethodsWithSourceString: searchString in: package].
	Smalltalk browseMethodsWithSourceString: searchString scopeClass: scopeClass includeSubclasses: includeSubclasses includeSuperclasses: includeSuperclasses! !
!FindInSourceDialog methodsFor: 'event handling testing' stamp: 'jmv 1/28/2025 15:01:00' overrides: 16905574!
                          handlesKeyboard

	^self visible! !
!FindInSourceDialog methodsFor: 'scopes list' stamp: 'jmv 1/28/2025 14:59:59'!
              scopeIndex
	^selectedScopeIndex! !
!FindInSourceDialog methodsFor: 'scopes list' stamp: 'jmv 1/28/2025 15:00:02'!
              scopeIndex: i
	selectedScopeIndex := i.! !
!FindInSourceDialog methodsFor: 'scopes list' stamp: 'jmv 1/28/2025 15:00:05'!
      scopesList
	| scopeClassName labelList |
	labelList := {
		'This method or text'.
		'All methods in image'. } asOrderedCollection.
	smalltalkEditor selectedClass ifNotNil:
		[ :scopeClass |
			scopeClassName := scopeClass name asString.
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := smalltalkEditor selectedMethod
				ifNotNil: [ :scopeMethod |CodePackage packageOfMethod: scopeMethod ifNone: []]
				ifNil: [CodePackage packageOfClass: scopeClass ifNone: []].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
	^labelList! !
!FindInSourceDialog class methodsFor: 'instance creation' stamp: 'jmv 1/28/2025 14:58:30'!
             openOn: aSmalltalkEditor
	| world dialog |
	world := self runningWorld ifNil: [UISupervisor ui].
	dialog := self new beColumn
		smalltalkEditor: aSmalltalkEditor;
		buildWidgets.
	world addMorph: dialog centeredNear: world activeHand morphPosition.
	^ dialog.! !
!SmalltalkEditor methodsFor: 'accessing' stamp: 'jmv 1/28/2025 15:19:43'!
               selectedMethod
	self codeProvider isEditingExistingMethod ifTrue: [
		self codeProvider currentCompiledMethod asMethodReference ].! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 1/28/2025 15:20:00' prior: 50356157!
                     findMethodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"
	| searchString selection scopeClass scopeClassName includeSubclasses includeSuperclasses labelList package |

	true ifTrue: [
		^FindInSourceDialog openOn: self ].

	searchString := StringRequestMorph
		request: 'Enter search text:'
		initialAnswer: self selectedString
		orCancel: [^self].
	
	scopeClass := self selectedClass.
	scopeClassName := scopeClass name asString.
	includeSubclasses := false.
	includeSuperclasses := false.

	labelList := {
		'This method'. 
		'All methods in image'. } asOrderedCollection.
	(scopeClass notNil)
		ifTrue: [
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := self codeProvider isEditingExistingMethod
				ifTrue: [CodePackage packageOfMethod: self codeProvider currentCompiledMethod asMethodReference ifNone: []]
				ifFalse: [CodePackage packageOfClass: scopeClass ifNone: []].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
				
	selection := (SelectionMenu labelList: labelList selections: nil) startUpWithCaption: 'Search Scope'.

	(selection = 0) ifTrue:[^self].
	(selection = 1) "This method"
		ifTrue:[^self find: searchString].
	(selection = 2) "All methods in image"
		ifTrue:[scopeClass := nil].
	"(selection = 3) ifTrue:[]. ""Class only - nothing to do"
	(selection = 4) "Class and subclasses"
		ifTrue:[includeSubclasses := true].
	(selection = 5) "Class, subclasses, and superclasses"
		ifTrue:[
			includeSubclasses := true.
			includeSuperclasses := true].
	(selection = 6) "In my package if any "
		ifTrue: [^ Smalltalk browseMethodsWithSourceString: searchString in: package].
	Smalltalk browseMethodsWithSourceString: searchString scopeClass: scopeClass includeSubclasses: includeSubclasses includeSuperclasses: includeSuperclasses! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7034-FindInSourceDialog-JuanVuletich-2025Jan28-15h33m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7034] on 28 January 2025 at 5:24:05 pm'!
!EntryFieldMorph methodsFor: 'geometry' stamp: 'jmv 1/28/2025 17:23:29' prior: 16855605 overrides: 16795958!
                              minimumExtent
	| h |
	h := self textBox y.
	^3@1 * h! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7035-EntryField-minimumExtent-JuanVuletich-2025Jan28-17h17m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7035] on 28 January 2025 at 8:09:26 pm'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'eem 1/28/2025 20:04:34' prior: 16967628!
                     setPlatformPreferences
	"Set some platform specific preferences on system startup"
	| platform specs |	

	(Preferences at: #automaticPlatformSettings) ifFalse:[^self].
	platform := self platformName.
	specs := 	#(	
					(soundStopWhenDone false)
					(soundQuickStart false)
			).
	platform = 'Win32' ifTrue:[
		specs := #(	
					(soundStopWhenDone true)
					(soundQuickStart false)
				)].
	platform = 'Mac OS' ifTrue:[
		specs := #(	
					(soundStopWhenDone false)
					(soundQuickStart true)
				)].
	specs do: [:tuple |
		Preferences name: tuple first category: #system value: tuple last ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7036-setPlatPrefsFix-EliotEmilioMiranda-2025Jan28-20h04m-eem.001.cs.st----!

----QUIT----(29 January 2025 15:00:01) Cuis7.3-7036.image priorSource: 743233!

----STARTUP---- (13 May 2025 17:35:45) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.3-7036.image!


'From Cuis7.3 [latest update: #6992] on 22 January 2025 at 8:57:01 pm'!
!HaloSpec class methodsFor: 'instance creation' stamp: 'hlsf 1/22/2025 20:50:06'!
                        from: array
" See iconicHaloSpecifications "
	| color |
	color := Color.
	array fourth do: [ :sel | color := color perform: sel].
	^ HaloSpec new 
		horizontalPlacement: array second
		verticalPlacement: array third 
		color: color
		iconSymbol: array fifth
		addHandleSelector: array first
		hoverHelp: array sixth! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'hlsf 1/22/2025 20:54:58' prior: 50337829!
                             installHaloPreferencesWith: anArray
	^ self sysPreferences 
		name: #haloSpecifications 
		description: 'Halo specifications describing which halos are to be used, what they should look like, and where they should be situated'
		category: #gui
		type: Array
		value: (anArray collect: [ :each | HaloSpec from: each ])! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7037-HaloSpec-refactor-HilaireFernandes-2025Jan22-20h46m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #6992] on 22 January 2025 at 9:47:12 pm'!
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 1/22/2025 21:44:34'!
   haloSpecifications

	^ Preferences at: #haloSpecifications! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 1/22/2025 21:44:42' prior: 16906927!
    addHandlesTo: aHaloMorph box: box
	"Add halo handles to the halo.  Apply the halo filter if appropriate"

	self haloSpecifications do: [ :aSpec |
		(self
			wantsHaloHandleWithSelector: aSpec addHandleSelector
			inHalo: aHaloMorph) ifTrue: [
		aHaloMorph
			perform: aSpec addHandleSelector
			with: aSpec ]].
	aHaloMorph target
		addOptionalHandlesTo: aHaloMorph
		box: box! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7038-HaloSpec-refactor-HilaireFernandes-2025Jan22-20h46m-hlsf.002.cs.st----!

'From Cuis7.3 [latest update: #7036] on 30 January 2025 at 12:04:32 pm'!
!HaloMorph methodsFor: 'private' stamp: 'hlsf 1/30/2025 12:03:55' prior: 16872328!
   addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient. Return the handle."

	| handle aPoint colorToUse form icon e |
	aPoint := self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse := Color colorFrom: handleSpec color.
	handle := HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	e := (Preferences at: #haloHandleSize) asPoint.
	handle position: aPoint-(e//2) extent: e.
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form := self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				form extent = e ifFalse: [ 
					": Non default size, scale that bugger!!"
					form := form  ": Be as smooth as possible, these images are small."
						magnify: form boundingBox
						to: e
						smoothing: 2 ].
				icon := (ImageMorph newWith: form)
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: `1@1`.
				handle morphExtent: icon morphExtent+2 ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^ handle! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7039-HaloIcon-position-fix-HilaireFernandes-2025Jan22-21h47m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #7039] on 30 January 2025 at 11:26:36 am'!
!PreferenceSet class methodsFor: 'sys preference' stamp: 'jmv 1/30/2025 11:26:01' prior: 16930292!
                           installMiscPreferences
" Preferences with value defined as a closure. We could insert in a dynamic array...
  Preferences with an event handler.
  Preferences with default value of anything but simple literals."
	self sysPreferences

		name: #haloHandleSize 
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize * 5 // 6 * 2 max: 16];

		name: #halosMorphBoundsFrameColor
		description: 'When set, use this color for a rectangle on halos morph bounds. Useful for debugging morph sizes.' 
		category: #gui 
		type: Object "Using Object as type as the property value can be either nil or a Color."
		value: nil;

		name: #halosMorphBoundsFillColor
		description: 'When set, use this color for filling a rectangle on halos morph bounds. Useful for debugging morph sizes.'
		category: #gui
		type: Object "Using Object as type as the property value can be either nil or a Color."
		value: nil;

		name: #roundedButtonRadius 	
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize * 8 // 14];

		name: #roundedWindowRadius 	
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize] ;

		name: #scrollbarThickness 
		category: #gui 		
		value: [(Preferences at: #windowTitleFont) pointSize + 2];

		name: #backgroundEffect
		description: 'determines how backgroundImage is applied'
		category: #gui
		type: Symbol
		value: #stretch;

		name: #classFinder 
		category: #programming 
		value: [ Smalltalk findAndBrowseClass ];

		name: #defaultAuthorName 
		category: #programming 
		value: [Utilities authorName];

		name: #worldMenu
		category: #system
		value: TheWorldMenu;

		name: #browserWindowClass
		category: #programming
		value: BrowserWindow.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	PreferenceSet sysPreferences
		name: #haloHandleSize 
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize * 5 // 6 * 2 max: 16]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7040-MakeHaloExtentEven-JuanVuletich-2025Jan30-11h25m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7040] on 30 January 2025 at 4:20:30 pm'!
!SmalltalkEditor methodsFor: 'accessing' stamp: 'jmv 1/30/2025 16:19:30' prior: 50358091!
                               selectedMethod
	^self codeProvider isEditingExistingMethod ifTrue: [
		self codeProvider currentCompiledMethod asMethodReference ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7041-FindInSourceDialog-fix-JuanVuletich-2025Jan30-16h18m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7041] on 31 January 2025 at 4:15:02 pm'!
!Morph methodsFor: 'event handling testing' stamp: 'jmv 1/31/2025 15:52:09'!
                              tabToFocus
	"Answer true if tab and shift+tab are used to transfer keyboard focus between windgets.
	See senders."
	^true! !
!InnerTextMorph methodsFor: 'event handling testing' stamp: 'jmv 1/31/2025 15:54:40' overrides: 50358429!
                         tabToFocus
	"Answer true if tab and shift+tab are used to transfer keyboard focus between windgets.
	See senders."
	^(self valueOfProperty: #tabIsValidInput) == false! !
!InnerTextMorph methodsFor: 'event handling testing' stamp: 'jmv 1/31/2025 15:54:12'!
tabToFocus: aBoolean
	"Enable or disable #tabToFocus.
	Disabled means that tab is valid character input."
	^self setProperty: #tabIsValidInput toValue: aBoolean! !
!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 1/31/2025 16:11:51' prior: 16889307!
      isTab
	"On the Mac, ctrl-shift-tab has keyValue = 25"
	^keyValue = 9 or: [ keyValue = 25 ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 1/31/2025 16:14:15' prior: 50353110!
          focusKeyboardFor: aKeyboardEvent

	"For most widgets, tab / shift-tab control focus. For those that not, ctrl-tab / ctrl-shift-tab is an alternative."
	aKeyboardEvent isTab ifTrue:
		[
			(self tabToFocus or: [aKeyboardEvent controlKeyPressed]) ifTrue:
				[
					aKeyboardEvent shiftPressed
						ifFalse: [ aKeyboardEvent hand keyboardFocusNext ]
						ifTrue: [ aKeyboardEvent hand keyboardFocusPrevious ].
					^ true ]].

	"Cycle through windows with cmdAlt + < and cmdAlt + >.
	VM and platform peculiarities are hidden in #isCmdAltLessThan and #isCmdAltGreaterThan"
	"This was done as an attempt to mimic the Mac OSX keystrokes for 'Move focus to next window in active application'. Unfortunately, it only works if OS X is set to use any other keys for this. If (as for example, with German defaults), OS-X uses these keystrokes, then they are not sent to the VM. This is a long standing issues in Chromium and PhotoShop, for example..."
	self disableCode: [
		aKeyboardEvent isCmdAltLessThan ifTrue: [
			aKeyboardEvent hand activatePreviousWindow.
			^true ].
		aKeyboardEvent isCmdAltGreaterThan ifTrue: [
			aKeyboardEvent hand activateNextWindow.
			^true ]].
	"Alternative for Mac OS-X: option-Tab and option-shift-Tab"
	(aKeyboardEvent isTab and: [ aKeyboardEvent rawMacOptionKeyPressed ])
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifTrue: [ aKeyboardEvent hand activatePreviousWindow ]
				ifFalse: [ aKeyboardEvent hand activateNextWindow ].
			^ true ].
	"Alternative for non-Mac OS-X: alt-< and alt->"
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter == $< ]) ifTrue: [
		aKeyboardEvent hand activatePreviousWindow.
		^true ].
	(aKeyboardEvent commandAltKeyPressed and: [ aKeyboardEvent keyCharacter == $> ]) ifTrue: [
		aKeyboardEvent hand activateNextWindow.
		^true ].
	^false! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 1/31/2025 15:57:23' prior: 16873480!
  keyboardFocusNext

	| m |
	"Right now, only do it within a Window.
	We could add a preference, though.
	See #keyboardFocusPrevious"
	true ifTrue: [
		^self keyboardFocusNextWithinWindow ].

	m := self nextFocusMorph.
	m ifNotNil: [
		m activateWindowAndSendTopToBack: false.
		self newKeyboardFocus: m ]! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 1/31/2025 15:57:19' prior: 16873500!
                    keyboardFocusPrevious

	| m |
	"Right now, only do it within a Window.
	We could add a preference, though.
	See #keyboardFocusNext"
	true ifTrue: [
		^self keyboardFocusPreviousWithinWindow ].

	m := self previousFocusMorph.
	m ifNotNil: [
		m activateWindowAndSendTopToBack: true.
		self newKeyboardFocus: m ]! !

EntryFieldMorph removeSelector: #focusKeyboardFor:!

!methodRemoval: EntryFieldMorph #focusKeyboardFor: stamp: 'Install-7042-Use-tab-toControlFocus-JuanVuletich-2025Jan31-15h41m-jmv.001.cs.st 5/13/2025 17:35:45'!
focusKeyboardFor: aKeyboardEvent
	"If aKeyboardEvent tab or shift-tab use it to navigate keyboard focus.
	ctrl key ignored."
	aKeyboardEvent isTab
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifFalse: [ aKeyboardEvent hand keyboardFocusNext ]
				ifTrue: [ aKeyboardEvent hand keyboardFocusPrevious ].
			^ true ].
	^super focusKeyboardFor: aKeyboardEvent!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7042-Use-tab-toControlFocus-JuanVuletich-2025Jan31-15h41m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7042] on 31 January 2025 at 4:31:39 pm'!
!InnerTextMorph methodsFor: 'event handling testing' stamp: 'jmv 1/31/2025 16:30:41' prior: 16882231 overrides: 16905574!
 handlesKeyboard

	self isLocked ifTrue: [^false ].
	self disablesEditing ifTrue: [^false ].
	((owner is: #ScrollPane) and: [owner isLocked])
		ifTrue: [^false ].
	^self visible! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7043-InnerTextMorph-fix-JuanVuletich-2025Jan31-16h30m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7043] on 1 February 2025 at 8:27:09 am'!
!TextModelMorph methodsFor: 'focus handling' stamp: 'jmv 2/1/2025 08:26:52'!
                     tabToFocus: aBoolean
	"Enable or disable #tabToFocus.
	Disabled means that tab is valid character input."
	scroller tabToFocus: aBoolean! !
!InnerTextMorph methodsFor: 'event handling testing' stamp: 'jmv 2/1/2025 08:25:01' prior: 50358445!
               tabToFocus: aBoolean
	"Enable or disable #tabToFocus.
	Disabled means that tab is valid character input."
	^self setProperty: #tabIsValidInput toValue: aBoolean not! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7044-Fix-7042-JuanVuletich-2025Feb01-08h25m-jmv.001.cs.st----!

'From Squeak6.1alpha of 20 February 2025 [latest update: #23209] on 21 February 2025 at 12:11:14 pm'!
!Ephemeron methodsFor: 'mourning' stamp: 'eem 2/21/2025 12:11' prior: 50335317 overrides: 50334245!
                      mourn
	"Triggered ephemerons get sent mourn by the #finalizationProcess (via #mournLoopWith:)
	 when the only reference(s) to an ephemeron's key is through one or more ephemerons.
	 i.e. the key is not reachable from the roots of the system except through ephemerons.
	 So ephemerons get sent mourn when their key would otherwise have been garbage
	 collected.  Respond to the information that the key would have been garbage collected
	 other than through ephemeron references by sending finalize to the key.

	 N.B. read #finalizeEphemeron: to understand why #finalize is typically not sent here."
	container
		ifNil: [key finalize]
		ifNotNil: [container finalizeEphemeron: self]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7045-Ephemeron-mourn-comment-EliotEmilioMiranda-2025Feb21-12h15m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #7036] on 22 February 2025 at 7:03:35 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'HAW 2/22/2025 19:02:56' prior: 50341068!
                              knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jpb' 						'Josef Philip Bernhart')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NPM'						'Nicolás Papagna Maldonado')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wbsl'						'Wéslleymberg Lisboa')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7046-AddNicoPapagnaAsKnowDeveloper-HernanWilkinson-2025Feb22-19h00m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7044] on 17 February 2025 at 9:49:07 am'!
!Color methodsFor: 'transformations' stamp: 'RMV 2/17/2025 09:47:28' prior: 16829937!
                        blacker

	^ self alphaMixed: 0.8333 with: `Color black`
! !
!Color methodsFor: 'transformations' stamp: 'RMV 2/17/2025 09:47:46' prior: 16830034!
              slightlyWhiter

	^ self alphaMixed: 0.85 with: `Color white`
! !
!Color methodsFor: 'transformations' stamp: 'RMV 2/17/2025 09:47:53' prior: 16830061!
         whiter

	^ self alphaMixed: 0.8333 with: `Color white`
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7047-ColorTweaks-MarkVolkmann-2025Feb17-09h47m-RMV.001.cs.st----!

'From Cuis7.3 [latest update: #7047] on 24 February 2025 at 1:20:07 pm'!
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 2/24/2025 13:16:29'!
            classDefRefactoringsSubmenuSpec
	" 'Refactorings' SubMenu"

	^#(
		#(2010 	'-----')
		#(2020	'Rename... (R)' 						$R 	editor 	contextualRenameInClassDefinition 	saveAsIcon 	'Renames what is under cursor')
		#(2030 	'-----')
		#(2040	'Push Up Instance Variable' 			nil 	editor 	contextualPushUpInClassDefinition 	goTopIcon)
		#(2050	'Push Down Instance Variable' 		nil 	editor 	contextualPushDownInClassDefinition 	goBottomIcon)
	).! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 2/24/2025 13:09:49'!
                       methodRefactoringsSubmenuSpec
	" 'Refactorings' SubMenu"

	^#(
		#(2010 	'-----')
		#(2020	'Rename... (R)' 						$R 	editor 	contextualRenameInMethod 			saveAsIcon 	'Renames what is under cursor')
		#(2030	'Extract as Parameter... (V)' 			$V 	editor 	contextualExtractAsParameter 		listAddIcon 	'Extracts the selected code as parameter')
		#(2040	'Add Parameter... (A)' 				$A 	editor 	contextualAddParameter 				listAddIcon 	'Adds parameter to message that is under cursor')
		#(2050	'Remove Parameter... (S)' 			$S 	editor 	contextualRemoveParameter 			listRemoveIcon 'Removes parameter to message that is under cursor')
		#(2060 	'-----')
		#(2070	'Extract Temporary... (J)' 				$J 	editor 	extractToTemporary 					saveAsIcon 	'Extracts the selected code into a temporary variable')
		#(2080	'Extract Method... (K)' 				$K 	editor 	extractMethod 							saveAsIcon 	'Extracts the selected code into a separate method')
		#(2090 	'-----')
		#(2100	'Inline Temporary... (O)' 				$O 	editor 	inlineTemporaryVariable 				saveAsIcon 	'Inlines the selected temporary variable into each usage')
		#(2110	'Inline Method... (L)' 					$L 	editor 	contextualInlineMethod 				saveAsIcon  	'Inlines the selected message send into desired colaborations')
		#(2120 	'-----')
		#(2130	'Temporary to Instance Variable (G)' 	$G 	editor 	temporaryToInstanceVariable 			saveAsIcon 	'Extracts temporary variable to instance variable')
	).! !
!SmalltalkEditor methodsFor: 'contextual add/remove parameter' stamp: 'jmv 2/24/2025 13:05:41' prior: 16954131!
 contextualChangeSelectorUsing: aChangeSelectorApplier
	
	self ifSourceCodeRefactoringCanBeAppliedDo: [ self contextualChangeSelectorInMethodUsing: aChangeSelectorApplier ]! !
!SmalltalkEditor methodsFor: 'contextual add/remove parameter' stamp: 'jmv 2/24/2025 13:05:59' prior: 16954142!
 contextualExtractAsParameter

	self ifSourceCodeRefactoringCanBeAppliedDo: [ self extractAsParameter ]! !
!SmalltalkEditor methodsFor: 'contextual push up/down inst. var' stamp: 'jmv 2/24/2025 13:13:07' prior: 16954185!
    contextualPushDownInClassDefinition 

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withClassDefinitionNodeAndClassDo: [ :classDefinitionNode :selectedClass | 
				self apply: [ :aSelectedClass | 
					(PushDownInstanceVariableApplier 
						on: self codeProvider 
						for: self wordUnderCursor 
						at: aSelectedClass ) value ] inClassDefinitionOf: classDefinitionNode in: selectedClass ]
			ifErrorsParsing: [ :anError | morph flash ]]! !
!SmalltalkEditor methodsFor: 'contextual push up/down inst. var' stamp: 'jmv 2/24/2025 13:13:57' prior: 16954196!
      contextualPushUpInClassDefinition 

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withClassDefinitionNodeAndClassDo: [ :classDefinitionNode :selectedClass | 
				self apply: [ :aSelectedClass | 
					(PushUpInstanceVariableApplier 
						on: self codeProvider 
						for: self wordUnderCursor 
						at: aSelectedClass) value ] inClassDefinitionOf: classDefinitionNode in: selectedClass ]
			ifErrorsParsing: [ :anError | morph flash ]]! !
!SmalltalkEditor methodsFor: 'inline method' stamp: 'jmv 2/24/2025 13:06:16' prior: 16956006!
                               contextualInlineMethod

	self ifSourceCodeRefactoringCanBeAppliedDo: [
		self
			withMethodNodeAndClassDo: [ :methodNode :selectedClass | self contextualInlineMethodOf: methodNode in: selectedClass ]
			ifErrorsParsing: [ :anError | morph flash ]	]	! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 2/24/2025 13:17:48' prior: 16956074 overrides: 16983613!
          defaultMenuSpec
	"Spec for the menu and shortcut keys for the regular text editors.
	See coment at Morph >> #getMenu
	"
	| codeProvider acceptEntry additionalEntries isEditingAMethod isEditingAClassDef |
	isEditingAMethod := false.
	isEditingAClassDef := false.
	additionalEntries := nil.
	codeProvider := self codeProvider.
	(codeProvider is: #CodeProvider)
		ifTrue: [
			acceptEntry := self hasUnacceptedEdits
				ifTrue: [ #(270	'Save (s)' 				$s 	editor 	acceptContents 		acceptIcon 				'Save') ]
				ifFalse: [ #(270 	'Save' 					nil 	editor 	nil 						acceptIcon 				'Save') ].
			codeProvider isEditingMethod ifTrue: [
				isEditingAMethod := true.
				additionalEntries := #(
					#(20 	'-----')
					#(30	'What to Show' 					nil 	nil 		3000 					preferencesIcon 		'Select alternative views of the method')
					#(40	'Toggle Break' 					nil 	editor 	toggleBreakOnEntry 	debugIcon 				'Add or remove a Breakpoint')
					#(200 	'-----')
					#(210	'Refactorings' 					nil 	nil 		2000 					listAddIcon)
					#(280	'Save & Run Test in Class (t)' 		$t 	editor 	acceptAndTest 			weatherFewCloudsIcon 'Saves method, runs it as test and then all tests in class. Opens debugger if error.')
					#(290	'Save & Run Test in Category (y)' 	$y 	editor 	acceptAndTestAll 		weatherFewCloudsIcon 'Saves method, runs it as test and then all tests in class category. Opens debugger if error.')
					#(300	'Save & Debug Test (r)' 			$r 	editor 	acceptAndDebugTest 	weatherFewCloudsIcon 'Saves method and debugs it')
				) ].
			self isEditingClassDefinition ifTrue: [
				isEditingAClassDef := true.
				additionalEntries := #(
					#(200 	'-----')
					#(210	'Refactorings' 					nil 	nil 		2000 					listAddIcon)
				) ]
			]
		ifFalse: [
			acceptEntry := self hasUnacceptedEdits
				ifTrue: [ #(270	'Save to file (s)' 			$s 	editor 	acceptContents 		acceptIcon 				'Save contents to a file') ]
				ifFalse: [ #(270 	'Save to file' 				nil 	editor 	nil 						acceptIcon 				'Save contents to a file') ]].
	^Array streamContents: [ :strm |
		strm nextPutAll:
			#(
				#(0 		'Smalltalk Editor' 				true)
				#(10	'Help... (h)' 					$h 	editor 	openHelp 				helpIcon 				'Open Help')
				#(50 	'-----')
				#(60	'Do it (d)' 					$d 	editor 	doIt 					doItIcon 				'Do it (selection is a valid expression)')
				#(70	'Print it (p)' 					$p 	editor 	printIt 					printIcon 				'Print it (selection is a valid expression)')
				#(80	'Inspect it (i)' 				$i 	editor 	inspectIt 				inspectIcon 			'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
				#(90	'Explore it (I)' 				$I 	editor 	exploreIt 				exploreIcon			'Inspect via Object Explorer')
				#(100	'Debug it (D)' 				$D 	editor 	debugIt 				debugIcon				'Debug it')
				#(110	'Profile it' 					nil 	editor 	profileIt 				clockIcon)
				#(120 	'-----')
				#(130	'Edit' 						nil 	nil 		1000 					textEditorIcon)
				#(140 	'-----')
				#(150	'Explain' 					nil 	editor 	explain 				helpIcon)
				#(160	'Browse it (b)' 				$b 	editor 	browseIt 				editFindReplaceIcon 	'Browse it (selection is a class name or cursor is over a class-list or message-list)')
				#(170	'Senders (n)' 				$n 	editor 	sendersOfIt 			mailForwardIcon 		'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
				#(180	'Implementors (m)' 			$m 	editor 	implementorsOfIt 		developmentIcon 		'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')
				#(190	'References (N)' 				$N 	editor 	referencesToIt 			addressBookIcon 		'References to it (selection is a class name, or cursor is over a class-list or message-list)')
				#(220 	'-----')
				#(230	'Find with Scope (e)' 			$e 	editor 	findMethodSourceContainingIt scriptIcon 		'Find with scope')
				#(240	'Method Strings with it (E)' 	$E	editor 	methodStringsContainingIt 	genericTextIcon 'Method strings containing it')
				#(250	'Find in class comments' 		nil 	editor 	classCommentsContainingIt 	chatIcon)
				#(260 	'-----')
			);
			nextPut: acceptEntry.
		additionalEntries notNil ifTrue: [
			strm nextPutAll: additionalEntries ].
		strm
			nextPutAll: self editSubmenuSpec;
			nextPutAll: self keyboardShortuctsSubmenuSpec.
		isEditingAMethod ifTrue: [
			strm nextPutAll: self methodRefactoringsSubmenuSpec ].
		isEditingAMethod ifTrue: [
			strm nextPutAll: self codeProvider whatToShowSubmenuSpec ].
		isEditingAClassDef ifTrue: [
			strm nextPutAll: self classDefRefactoringsSubmenuSpec ].
	].! !

SmalltalkEditor removeSelector: #refactoringsSubmenuSpec!

!methodRemoval: SmalltalkEditor #refactoringsSubmenuSpec stamp: 'Install-7048-RefactoringMenuInClassDefinition-JuanVuletich-2025Feb24-13h19m-jmv.001.cs.st 5/13/2025 17:35:45'!
refactoringsSubmenuSpec
	" 'Refactorings' SubMenu"

	^#(
		#(2010 	'-----')
		#(2020	'Rename... (R)' 						$R 	editor 	contextualRename 						saveAsIcon 	'Renames what is under cursor')
		#(2030	'Extract as Parameter... (V)' 			$V 	editor 	contextualExtractAsParameter 		listAddIcon 	'Extracts the selected code as parameter')
		#(2040	'Add Parameter... (A)' 				$A 	editor 	contextualAddParameter 				listAddIcon 	'Adds parameter to message that is under cursor')
		#(2050	'Remove Parameter... (S)' 			$S 	editor 	contextualRemoveParameter 			listRemoveIcon 'Removes parameter to message that is under cursor')
		#(2060 	'-----')
		#(2070	'Extract Temporary... (J)' 				$J 	editor 	extractToTemporary 					saveAsIcon 	'Extracts the selected code into a temporary variable')
		#(2080	'Extract Method... (K)' 				$K 	editor 	extractMethod 							saveAsIcon 	'Extracts the selected code into a separate method')
		#(2090 	'-----')
		#(2100	'Inline Temporary... (O)' 				$O 	editor 	inlineTemporaryVariable 				saveAsIcon 	'Inlines the selected temporary variable into each usage')
		#(2110	'Inline Method... (L)' 					$L 	editor 	contextualInlineMethod 				saveAsIcon  	'Inlines the selected message send into desired colaborations')
		#(2120 	'-----')
		#(2130	'Temporary to Instance Variable (G)' 	$G 	editor 	temporaryToInstanceVariable 			saveAsIcon 	'Extracts temporary variable to instance variable')
		#(2140	'Push Up Instance Variable' 			nil 	editor 	contextualPushUpInClassDefinition 	goTopIcon)
		#(2150	'Push Down Instance Variable' 		nil 	editor 	contextualPushDownInClassDefinition 	goBottomIcon)
	).!

SmalltalkEditor removeSelector: #contextualRename!

!methodRemoval: SmalltalkEditor #contextualRename stamp: 'Install-7048-RefactoringMenuInClassDefinition-JuanVuletich-2025Feb24-13h19m-jmv.001.cs.st 5/13/2025 17:35:45'!
contextualRename

	self isEditingClassDefinition 
		ifTrue: [ self contextualRenameInClassDefinition ]
		ifFalse: [ self contextualRenameInMethod ]!

SmalltalkEditor removeSelector: #ifEditingClassDefinitionDoOrWarn:!

!methodRemoval: SmalltalkEditor #ifEditingClassDefinitionDoOrWarn: stamp: 'Install-7048-RefactoringMenuInClassDefinition-JuanVuletich-2025Feb24-13h19m-jmv.001.cs.st 5/13/2025 17:35:45'!
ifEditingClassDefinitionDoOrWarn: aBlock

	self isEditingClassDefinition 
		ifTrue: aBlock
		ifFalse: [ self informRefactoringCanOnlyBeAppliedInClassDefinition ]!

SmalltalkEditor removeSelector: #inClassDefinitionContextuallyApply:!

!methodRemoval: SmalltalkEditor #inClassDefinitionContextuallyApply: stamp: 'Install-7048-RefactoringMenuInClassDefinition-JuanVuletich-2025Feb24-13h19m-jmv.001.cs.st 5/13/2025 17:35:45'!
inClassDefinitionContextuallyApply: aBlock

	self ifEditingClassDefinitionDoOrWarn: [
		self ifSourceCodeRefactoringCanBeAppliedDo: [
			self
				withClassDefinitionNodeAndClassDo: [ :classDefinitionNode :selectedClass | 
					self apply: aBlock inClassDefinitionOf: classDefinitionNode in: selectedClass ]
				ifErrorsParsing: [ :anError | morph flash ]]]!

SmalltalkEditor removeSelector: #informRefactoringCanOnlyBeAppliedInClassDefinition!

!methodRemoval: SmalltalkEditor #informRefactoringCanOnlyBeAppliedInClassDefinition stamp: 'Install-7048-RefactoringMenuInClassDefinition-JuanVuletich-2025Feb24-13h19m-jmv.001.cs.st 5/13/2025 17:35:45'!
informRefactoringCanOnlyBeAppliedInClassDefinition

	self inform: 'This refactoring can only be applied from the class definition'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7048-RefactoringMenuInClassDefinition-JuanVuletich-2025Feb24-13h19m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7048] on 24 February 2025 at 3:06:52 pm'!
!PluggableButtonMorph class methodsFor: 'instance creation' stamp: 'RMV 2/1/2025 16:21:32'!
                model: anObject stateGetter: getStateSel action: actionSel label: aString balloonText: aBallonText
	^ (self 
		model: anObject
		stateGetter: getStateSel
		action: actionSel
		label: aString)
		setBalloonText: aBallonText;
		yourself! !
!ChangeSelectorWizardStepWindow methodsFor: 'button creation' stamp: 'RMV 2/1/2025 16:21:32' prior: 16807253!
     createAddButton
	
	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #add
		label: 'Add'
		balloonText: 'Add a new method to refactor'! !
!ChangeSelectorImplementorsStepWindow methodsFor: 'button creation' stamp: 'RMV 2/1/2025 16:21:32' prior: 16806563!
                  createSeeSendersButton
	
	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #seeSenders
		label: 'See Senders'
		balloonText: 'Shows the senders that will be affected by the refactoring'

! !
!ExtractMethodReplacementsWindow methodsFor: 'button creation' stamp: 'RMV 2/1/2025 16:21:32' prior: 16859493!
 createExtractAllInClassButton

	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #extractAllInClass
		label: 'In Class'
		balloonText: 'Applies the refactoring to all methods defined in the class'
! !
!ExtractMethodReplacementsWindow methodsFor: 'button creation' stamp: 'RMV 2/1/2025 16:21:32' prior: 16859503!
                       createExtractInMethodOnlyButton

	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #extractInMethodOnly
		label: 'In Method'
		balloonText: 'Applies the refactoring to all repetitions in the source method'
! !
!ExtractMethodReplacementsWindow methodsFor: 'button creation' stamp: 'RMV 2/1/2025 16:21:32' prior: 16859514!
              createExtractSelectionOnlyButton

	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #extractSelectionOnly
		label: 'Selection Only'
		balloonText: 'Applies the refactoring to the selected code only'
! !
!ExtractMethodReplacementsWindow methodsFor: 'button creation' stamp: 'RMV 2/1/2025 16:21:32' prior: 16859524!
                     createRefactorButton

	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #refactor
		label: 'Refactor'
		balloonText: 'Applies the refactoring to all places without showing the changes'! !
!InlineMethodImplementorsStepWindow methodsFor: 'button creation' stamp: 'RMV 2/1/2025 16:21:32' prior: 16879780!
 createSelectImplementorButton

	^PluggableButtonMorph
		model: self
		stateGetter: #isMessageSelected
		action: #selectImplementor
		label: 'Select'
		balloonText: 'Applies the refactoring in the selected place'
! !
!InlineMethodImplementorsWithShowUsagesStepWindow methodsFor: 'button creation' stamp: 'RMV 2/1/2025 16:21:32' prior: 16879834!
        createSelectAndSeeUsagesButton

	^PluggableButtonMorph
		model: self
		stateGetter: nil
		action: #selectAndSeeUsages
		label: 'Select and see usages'
		balloonText: 'Selects the replacement to refactor and shows the usages'


! !
!RefactoringApplier class methodsFor: 'common buttons' stamp: 'RMV 2/1/2025 16:21:32' prior: 16938393!
                  createCancelButtonOn: aModel
	
	^PluggableButtonMorph 
		model: aModel
		stateGetter: nil
		action: #delete
		label: 'Cancel'
		balloonText: 'Do not apply the refactoring'
! !
!RefactoringApplier class methodsFor: 'common buttons' stamp: 'RMV 2/1/2025 16:21:32' prior: 16938402!
         createJustRefactorButtonOn: aModel

	^PluggableButtonMorph 
		model: aModel
		stateGetter: nil
		action: #justRefactor
		label: 'Refactor'
		balloonText: 'Applies the refactoring without showing the changes'! !
!RefactoringApplier class methodsFor: 'common buttons' stamp: 'RMV 2/1/2025 16:21:32' prior: 16938412!
      createRefactorButtonOn: aModel

	^PluggableButtonMorph 
		model: aModel
		stateGetter: nil
		action: #refactor
		label: 'Refactor...'
		balloonText: 'Applies the refactoring and shows the changes'! !
!RefactoringApplier class methodsFor: 'common buttons' stamp: 'RMV 2/1/2025 16:21:32' prior: 16938421!
                 createRemoveButtonOn: aModel

	^PluggableButtonMorph
		model: aModel
		stateGetter: nil
		action: #remove
		label: 'Remove'
		balloonText: 'Removes the selected element from the refactoring'
! !
!RefactoringApplier class methodsFor: 'common buttons' stamp: 'RMV 2/1/2025 16:21:32' prior: 16938430!
                      createSeeImplementorsButtonOn: aModel

	^PluggableButtonMorph
		model: aModel
		stateGetter: nil
		action: #seeImplementors
		label: 'See Implementors'
		balloonText: 'Shows the implementors that will be affected by the refactoring'
! !

PluggableButtonMorph class removeSelector: #model:stateGetter:action:label:ballonText:!

!methodRemoval: PluggableButtonMorph class #model:stateGetter:action:label:ballonText: stamp: 'Install-7049-typoFix-R.MarkVolkmann-2025Feb24-15h06m-RMV.001.cs.st 5/13/2025 17:35:45'!
model: anObject stateGetter: getStateSel action: actionSel label: aString ballonText: aBallonText
	^ (self 
		model: anObject
		stateGetter: getStateSel
		action: actionSel
		label: aString)
		setBalloonText: aBallonText;
		yourself!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7049-typoFix-R.MarkVolkmann-2025Feb24-15h06m-RMV.001.cs.st----!

'From Cuis7.3 [latest update: #7049] on 24 February 2025 at 6:18:45 pm'!
!AbstractVectorCanvas methodsFor: 'paths' stamp: 'jmv 2/24/2025 18:14:46' prior: 16777682!
                           cubicBezierTo: aPoint control1: controlPoint1 control2: controlPoint2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorCanvas onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :canvas |
		canvas
			moveTo: 100@100;
			cubicBezierTo: 300@200 control1: 110@110 control2: 200@200 ].
Display forceToScreen
	"
	"
(VectorCanvas onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :canvas |
		canvas moveTo: 100@50.
		canvas
			cubicBezierTo: 600@100
			control1: 150@300
			control2: 600@400 ].
Display forceToScreen
	"
	engine cubicBezierTo: aPoint control1: controlPoint1 control2: controlPoint2.
	currentPoint := aPoint.
	lastControlPoint := controlPoint2.! !
!AbstractVectorCanvas methodsFor: 'paths' stamp: 'jmv 2/24/2025 18:14:37' prior: 16777918!
                             quadraticBezierTo: aPoint control: controlPoint
	"
(VectorCanvas onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :canvas |
		canvas
			moveTo: 100@100;
			quadraticBezierTo: 300@200 control: 100@210 ].
Display forceToScreen
	"
	"
(VectorCanvas onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :canvas |
		canvas moveTo: 10@5.
		canvas quadraticBezierTo: 60@10 control: 15@30 ].
Display forceToScreen
	"
	engine quadraticBezierTo: aPoint control: controlPoint.
	currentPoint := aPoint.
	lastControlPoint := controlPoint.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7050-BeziersWithImplicitControlPointFix-JuanVuletich-2025Feb24-18h17m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7036] on 25 February 2025 at 10:09:58 am'!
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 2/25/2025 09:41:44' prior: 50351485!
                              processCommandLineArguments: initialOptions
	"
	Smalltalk processCommandLineArguments: true
	Smalltalk processCommandLineArguments: false

	Note: By default, any exceptions thrown during the evaluation of arguments are simply ignored.
	To ease debugging, use the -e argument: Do Not Ignore Exceptions. 
	For example:
		squeak Cuis.image -e -s myScript.st
	If ``myScript.st`` contains an error, a Debugger will pop up.
	
	See comment at
		processInitialCommandLineOption:optionArgument:
		processFinalCommandLineOption:optionArgument:raiseExceptions:
	See displayCommandLineUsageOn:
	"
	| optionString optionArgument optionIndex nextOptionIndex optionLastParameterIndex raiseExceptions dashFinder |

	"Any command line argument that starts with $- is an Option.
	non-Option arguments are parameters for the preceding Option."
	raiseExceptions := false.
	startUpScriptArguments := #().
	"Empty Strings are valid command line arguments, generated by two double quotes. Handle them."
	dashFinder := [ :any | any size > 1 and: [ any first == $- ] ].
	optionIndex := startUpArguments findFirst: dashFinder startingAt: 1.
	[ optionIndex > 0 ] whileTrue:
	[
		"Find parameters for this option. Find the next option after this one."
		nextOptionIndex := startUpArguments findFirst: dashFinder startingAt: optionIndex+1.
		optionLastParameterIndex := nextOptionIndex = 0
			ifTrue: [startUpArguments size]
			ifFalse: [nextOptionIndex-1].
			
		optionString := startUpArguments at: optionIndex.
		optionString = '--' 						"Including    --    as an option means 'ignore everything after here'"
			ifTrue: [^self].
		optionString = '-e'
			ifTrue: [ raiseExceptions := true ]
			ifFalse:
			[
				optionArgument := optionLastParameterIndex > optionIndex ifTrue: [startUpArguments at: optionIndex+1].
				"optionArgument (at: optionIndex+1) would be the startUpScript fileName. It's arguments follow."
				startUpScriptArguments := startUpArguments copyFrom: optionIndex+2 to: optionLastParameterIndex.
				initialOptions
					ifTrue: [ self processInitialCommandLineOption: optionString optionArgument: optionArgument ]
					ifFalse: [ self processFinalCommandLineOption: optionString optionArgument: optionArgument raiseExceptions: raiseExceptions ].
				startUpScriptArguments := #().
			].
		optionIndex := nextOptionIndex.
	].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7051-processCommandLineArguments-cleanup-JuanVuletich-2025Feb25-09h27m-jmv.003.cs.st----!

'From Cuis7.3 [latest update: #7037] on 25 February 2025 at 10:45:02 am'!
!EventSensor methodsFor: 'accessing' stamp: 'jmv 2/25/2025 10:37:05'!
          flushAllEvents
	eventQueue := SharedQueue new.
! !
!EventSensor methodsFor: 'initialization' stamp: 'jmv 2/25/2025 10:44:20' prior: 16856457 overrides: 16933811!
                              initialize
	"Run the I/O process"
	mouseButtons := 0.
	mousePosition := `0@0`.
	self setInterruptKey: (interruptKey ifNil: [$. codePoint bitOr: 16r0800 ]). 	"cmd-."
	self flushAllEvents.
	inputSemaphore := Semaphore new.
	hasInputSemaphore := false.

	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).
	self installInterruptWatcher.
	self installEventTickler.

	"A new Sensor discards anything in the event queue of the previous one. Discard also
		anything not yet queued.
	Additionally, on image startup, discard the possible D&D added by the VM (that tries to
		help old Squeak functionality where the image doesn't parse cmdline arguments,
		and the VM generates a D&D event assuming that cmdline argument is a filename.
		Cuis does any such thing at image level, effectively disable the VM doing this.
		See #processCommandLineArguments:."
	self fetchMoreEvents; flushAllEvents.

	"Attempt to discover whether the input semaphore is actually being signaled."
	hasInputSemaphore := false.
	inputSemaphore initSignals.! !

EventSensor removeSelector: #flushAllButDandDEvents!

!methodRemoval: EventSensor #flushAllButDandDEvents stamp: 'Install-7052-EventSensor-flushAllEventsOnStartup-JuanVuletich-2025Feb25-10h36m-jmv.001.cs.st 5/13/2025 17:35:45'!
flushAllButDandDEvents
	| newQueue oldQueue  |
	
	newQueue := SharedQueue new.
	eventQueue ifNil: [
		eventQueue := newQueue.
		^self].
	oldQueue := eventQueue.
	[ oldQueue size > 0 ] whileTrue: [ | item type | 
		item := oldQueue next.
		type := item at: 1.
		type = EventSensor eventTypeDragDropFiles ifTrue: [ newQueue nextPut: item]].
	eventQueue := newQueue.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7052-EventSensor-flushAllEventsOnStartup-JuanVuletich-2025Feb25-10h36m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7052] on 26 February 2025 at 3:52:49 pm'!
!ClassDefinitionNodeAnalyzer methodsFor: 'accessing' stamp: 'HAW 2/26/2025 15:49:17'!
                            systemCategory

	self isClassDefinition 	ifFalse: [ self error: 'Cannot get system category from metaclass definition' ].
	
	^(classCreationMessageNode arguments at: self class categoryPosition) literalValue ! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 2/26/2025 15:39:05'!
                          renameSystemCategoryNamed: oldName

	^ self
		request: 'New category name?'
		initialAnswer: oldName
		verifying: [:aString| aString notEmpty and: [aString ~= oldName]]
		do: [:aString| | newName |
			newName := aString asSymbol.
			systemOrganizer renameSystemCategory: oldName to: newName.
			self setSelectedSystemCategory: newName.
			self changed: #systemCategoryRoots]! !
!Browser methodsFor: 'system category functions' stamp: 'HAW 2/26/2025 15:50:33' prior: 16798971!
    renameSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection
	
	21-Mar-2012 jmv Note: This is not recorded appropriately in change sets.
	The easiest solution is to trigger #classRecategorized for all classes in the category.
	But this is not a real solution, as the resulting changeset would not do a rename,
	but create a new category (that would go to the bottom) with all the classes.
	
	In the meantime, disable the menu entry. This is not so important after all.
	"
	
	selectedSystemCategory ifNil: [^ self].  "no selection"
	self renameSystemCategoryNamed: selectedSystemCategory! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7053-RenameSystemCategoryFromClassDefinition-HernanWilkinson-2025Feb26-15h35m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7053] on 27 February 2025 at 9:57:24 am'!
!SystemDictionary methodsFor: 'browsing' stamp: 'eem 2/27/2025 09:56:09' prior: 16968800!
            browseAllCallsOn: aLiteral
	"Create and schedule a message browser on each method that refers to
	aLiteral. For example, Smalltalk browseAllCallsOn: #open:label:."
	(aLiteral isKindOf: LookupKey)
		ifTrue: [
			self
				browseMessageList: (self allCallsOn: aLiteral)
				name: 'Users of ' , aLiteral key
				autoHighlight: aLiteral key
				allOccurrences: true ]
		ifFalse:
			[self
				browseMessageList: (self allCallsOn: aLiteral)
				name: 'Senders of ' , aLiteral asString
				autoHighlight: aLiteral asString
				allOccurrences: true ].! !
!SystemDictionary methodsFor: 'browsing' stamp: 'eem 2/27/2025 09:56:23' prior: 16968834!
    browseAllCallsOn: aLiteral localTo: aClass
	"Create and schedule a message browser on each method in or below the given class that refers to
	aLiteral. For example, Smalltalk browseAllCallsOn: #open:label:."
	aClass ifNil: [ ^ self inform: 'no selected class' ].
	(aLiteral isKindOf: LookupKey)
		ifTrue: [
			self
				browseMessageList: (aClass allLocalCallsOn: aLiteral)
				name: 'Users of ' , aLiteral key , ' in the full hierarchy of ' , aClass name
				autoHighlight: aLiteral key
				allOccurrences: true ]
		ifFalse: [
			self
				browseMessageList: (aClass allLocalCallsOn: aLiteral)
				name: 'Senders of ' , aLiteral asString , ' in the full hierarchy of ' , aClass name
				autoHighlight: aLiteral asString
				allOccurrences: true ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7054-MoreGeneralAllCallsOn-EliotEmilioMiranda-2025Feb27-09h50m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #7054] on 27 February 2025 at 10:46:12 am'!
!BytecodeEncoder class methodsFor: 'behavior support' stamp: 'eem 2/27/2025 07:39'!
         maxAccessibleInstSize
	"Answer the maximum number of accessible named instance variables supported by the bytecode set.
	C.f. genPushInstVarLong:, genStoreInstVarLong:, and genStorePopInstVarLong:"
	^self subclassResponsibility! !
!EncoderForSistaV1 class methodsFor: 'behavior support' stamp: 'eem 2/27/2025 07:40' overrides: 50359818!
               maxAccessibleInstSize
	"Answer the maximum number of accessible named instance variables supported by the bytecode set.
	C.f. genPushInstVarLong:, genStoreInstVarLong:, and genStorePopInstVarLong:"
	^65536! !
!EncoderForV3PlusClosures class methodsFor: 'behavior support' stamp: 'eem 2/27/2025 07:41' overrides: 50359818!
                              maxAccessibleInstSize
	"Answer the maximum number of accessible named instance variables supported by the bytecode set.
	C.f. genPushInstVarLong:, genStoreInstVarLong:, and genStorePopInstVarLong:"
	^256! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'eem 2/27/2025 10:21:25'!
                      maxAccessibleInstSize
	"Answer the maximum number of accessible named instance variables.
	 This depends on the bytecode set."
	^CompiledMethod preferredBytecodeSetEncoderClass maxAccessibleInstSize! !
!Behavior methodsFor: 'accessing instances and variables' stamp: 'eem 2/27/2025 10:21:52'!
                           maxInstSize
	"Answer the maximum number of named instance variables
	 (as opposed to indexed variables) of the receiver.
	 The class format is
		<5 bits inst spec><16 bits inst size>"
	^16rFFFF! !
!ClassBuilder methodsFor: 'validation' stamp: 'eem 2/27/2025 10:18:23'!
                   checkInstSize: instSize errorMessage: errorMessage
	instSize > self class maxInstSize ifTrue:
		[self error: errorMessage.
		 ^false].
	instSize > self class maxAccessibleInstSize ifTrue:
		[Smalltalk isDevelopmentEnvironmentPresent ifTrue:
			[^self confirm: 'To access ', instSize printString, ' instance variables\requires the SistaV1 bytecode set.\See #preferredBytecodeSetEncoderClass:.' withNewLines].
		 ^false].
	^true! !
!Behavior methodsFor: 'accessing' stamp: 'eem 2/18/2020 19:37' prior: 16787040!
  instSpec
	"Answer the instance specification part of the format that defines what kind of object
	 an instance of the receiver is.  The formats are
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (Context BlockClosure AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable	(DoubleWordArray et al)
		10-11	= 32-bit indexable	(WordArray et al)			(includes one odd bit, unused in 32-bit instances)
		12-15	= 16-bit indexable	(DoubleByteArray et al)		(includes two odd bits, one unused in 32-bit instances)
		16-23	= 8-bit indexable	(ByteArray et al)			(includes three odd bits, one unused in 32-bit instances)
		24-31	= compiled code	(CompiledCode et al)		(includes three odd bits, one unused in 32-bit instances)

	 Note that in the VM instances also have a 5 bit format field that relates to their class's format.
	 Formats 11, 13-15, 17-23 & 25-31 are unused in classes but used in instances to define the
	 number of elements missing up to the slot size.  For example, a 2-byte ByteString instance
	 has format 18 in 32 bits, since its size is one 32-bit slot - 2 bytes ((18 bitAnd: 3) = 2), and
	 22 in 64 bits, since its size is one 64-bit slot - 6 bytes ((22 bitAnd: 7) = 6).
	 Formats 24-31 are for compiled code which is a combination of pointers and bytes.  The number of pointers is
	 determined by literal count field of the method header, which is the first field of the object and must be a SmallInteger. 
	 The literal count field occupies the least significant 15 bits of the method header, allowing up to 32,767 pointer fields,
	 not including the header."
	^(format bitShift: -16) bitAnd: 16r1F! !
!ClassBuilder methodsFor: 'class format' stamp: 'eem 2/27/2025 10:23:27' prior: 16816375!
     computeFormat: type fullInstancesSize: newInstSize
	"Compute the new format for making oldClass a subclass of newSuper.
	 Answer the format or nil if there is any problem."

	| isVar isPointers isWeak bitsUnitSize |
	type == #compiledMethod ifTrue: [
		newInstSize > 0 ifTrue: [
			self error: 'A compiled method class cannot have named instance variables'.
			^nil].
		^CompiledMethod format].
	(self checkInstSize: newInstSize
		 errorMessage:  'Class has too many instance variables (', newInstSize printString,')') ifFalse: [
		^nil].
	type == #normal ifTrue:[isVar := isWeak := false. isPointers := true].
	type == #bytes ifTrue:[isVar := true. bitsUnitSize := 1. isPointers := isWeak := false].
	type == #shorts ifTrue:[isVar := true. bitsUnitSize := 2. isPointers := isWeak := false].
	type == #words ifTrue:[isVar := true. bitsUnitSize := 4. isPointers := isWeak := false].
	type == #longs ifTrue:[isVar := true. bitsUnitSize := 8. isPointers := isWeak := false].
	type == #variable ifTrue:[isVar := isPointers := true. isWeak := false].
	type == #weak ifTrue:[isVar := isWeak := isPointers := true].
	type == #ephemeron ifTrue:[isVar := false. isWeak := isPointers := true].
	type == #immediate ifTrue:[isVar := isWeak := isPointers := false].
	isVar ifNil: [ self error: 'Unsupported class format type: ', type. ^ nil ].
	(isPointers not and: [newInstSize > 0]) ifTrue: [
		self error: 'A non-pointer class cannot have named instance variables'.
		^nil].
	^self format: newInstSize variable: isVar bitsUnitSize: bitsUnitSize pointers: isPointers weak: isWeak! !
!ClassBuilder methodsFor: 'validation' stamp: 'eem 2/27/2025 10:33:01' prior: 16816617!
    validateSubclassFormat: newType from: oldClass forSuper: newSuper extra: newInstSize
	"Validate the # of instVars and the format of the subclasses"
	| deltaSize errorMessage |
	oldClass ifNil: [^ true]. "No subclasses"
	"Compute the # of instvars needed for all subclasses"
	deltaSize := newInstSize.
	oldClass
		ifNotNil: [deltaSize := deltaSize - oldClass instVarNames size].
	newSuper
		ifNotNil: [deltaSize := deltaSize + newSuper instSize].
	(oldClass notNil and: [oldClass superclass notNil]) 
		ifTrue: [deltaSize := deltaSize - oldClass superclass instSize].
	errorMessage := 'more than ', self class maxInstSize printString, ' instance variables'.
	oldClass
		ifNil: [^self checkInstSize: deltaSize errorMessage: errorMessage capitalized].

	oldClass withAllSubclassesDo:
		[ :sub |
		(self
			checkInstSize: sub instSize + deltaSize
			errorMessage: sub name,' has ', errorMessage) ifFalse:
			[^false].

		"If we get this far, check whether the immediate subclasses of oldClass can keep its layout."
		(newType ~~ #normal) 
			ifTrue: [ self validateSubclass: sub canKeepLayoutFrom: oldClass forSubclassFormat: newType ]].

	^ true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7055-64kInstVars-EliotEmilioMiranda-2025Feb27-10h13m-eem.001.cs.st----!

'From Cuis7.3 [latest update: #7055] on 28 February 2025 at 9:50:24 am'!
!Morph methodsFor: 'drawing' stamp: 'jmv 2/28/2025 09:32:42'!
                              imageForm
	^self imageForm: 32! !
!Morph methodsFor: 'geometry' stamp: 'jmv 2/28/2025 09:28:15'!
                               ensureMinimumExtent
	"We can't change extent. NOP here.
	See inheritance."! !
!BoxMorph methodsFor: 'geometry' stamp: 'jmv 2/28/2025 09:47:42' overrides: 50360052!
                            ensureMinimumExtent
	"Make our extent no smaller than #minimumExtent"

	self morphExtent:
		(extent
			ifNotNil: [extent max: self minimumExtent]
			ifNil: [self minimumExtent]).! !
!Morph methodsFor: 'drawing' stamp: 'jmv 2/28/2025 09:31:12' prior: 16905058!
                            imageForm: extentOrNil depth: depth

	| answerExtent answer auxCanvas bounds |
	self ensureMinimumExtent.

	self requiresVectorCanvas ifTrue: [	
		^ self imageFormVG: extentOrNil depth: depth ].

	bounds := self fullBoundsInOwner.
	answerExtent := bounds extent.
	extentOrNil ifNotNil: [ answerExtent := answerExtent min: extentOrNil * 4 ].
	auxCanvas := MorphicCanvas depth: depth over: (bounds origin extent: answerExtent ceiling).
	auxCanvas fullDraw: self.
	answer := auxCanvas form divideByAlpha.
	extentOrNil ifNotNil: [ answer := answer magnifyTo: extentOrNil ].
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7056-ensureMinimumExtent-imageForm-JuanVuletich-2025Feb28-09h49m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7055] on 28 February 2025 at 9:55:26 am'!
!Dialog methodsFor: 'initialization' stamp: 'jmv 2/28/2025 09:53:07'!
                              buildWidgets
	"Redefine as appropriate.
	At the end, do
		self ensureMinimumExtent.
	or
		self morphExtent: self minimumExtent + xtraSpace.
	or similar, as #defaultExtent is nil."

	self subclassResponsibility.! !
!Dialog methodsFor: 'defaults' stamp: 'jmv 2/28/2025 09:10:52' prior: 50357698 overrides: 16796206!
      defaultExtent
	^nil! !
!FindInSourceDialog methodsFor: 'initialization' stamp: 'jmv 2/28/2025 09:13:08' prior: 50357909 overrides: 50360096!
                   buildWidgets

	| buttonRow titleMorph |
	titleMorph := (LabelMorph contents: 'Find in source code' fontSize: 16 emphasis: 1).
	titleMorph layoutSpec offAxisEdgeWeight: 0.
	searchField := EntryFieldMorph new.
	searchField
		crAction: [ self ok ];
		escAction: [ self cancel ].
	searchField layoutSpec offAxisEdgeWeight: 0.
	initialSearchString ifNotNil: [ searchField contents: initialSearchString ].
	scopeList := PluggableListMorph
		withModel: self
		listGetter: #scopesList
		indexGetter: #scopeIndex
		indexSetter: #scopeIndex:.
	scopeList 
		doubleClickSelector: #ok.
	buttonRow := LayoutMorph newRow.
	buttonRow
		addMorph: (PluggableButtonMorph model: self action: #ok label: 'Ok');
		addMorph: (PluggableButtonMorph model: self action: #cancel label: 'Cancel').
	layoutMorph
		gap: 14;
		addMorphKeepMorphHeight: titleMorph;
		addMorphKeepMorphHeight: searchField;
		addMorphUseAll: scopeList;
		addMorphKeepMorphHeight: buttonRow.

	self morphExtent: self minimumExtent * (2@1.5).! !
!SampleModalDialog methodsFor: 'initialization' stamp: 'jmv 2/28/2025 09:54:03' prior: 50357846 overrides: 50360096!
          buildWidgets
	"
	This is a sample implementation. Actual subclasses should reimplement #buildWidgets (without calling super!!).
	self openModal
	"

	| typeRow buttonRow |
	typeRow := LayoutMorph newRow.
	typeRow
		addMorph: (LabelMorph contents: 'Type');
		addMorph: (LabelMorph contents: 'So what');
		addMorph: (LabelMorph contents: 'And then').
	buttonRow := LayoutMorph newRow.
	buttonRow
		padding: 10;
		gap: 20;
		addMorph: (PluggableButtonMorph model: self action: #ok label: 'Ok');
		addMorph: (PluggableButtonMorph model: self action: #cancel label: 'Cancel').
	layoutMorph
		addMorph: 
			((LabelMorph contents: 'This is a title for this Dialog' fontSize: 25)
				borderWidth: 2; borderColor: color lighter;
				padding: 20);
		addMorph: Sample01Star new;
		addMorph: typeRow;
		addMorph: buttonRow.

	"self ensureMinimumExtent."
	"To make the star somehow larger"
	self morphExtent: self minimumExtent + (0@200).! !

SampleModalDialog removeSelector: #defaultExtent!

!methodRemoval: SampleModalDialog #defaultExtent stamp: 'Install-7057-Dialog-defaultExtent-JuanVuletich-2025Feb28-09h50m-jmv.001.cs.st 5/13/2025 17:35:45'!
defaultExtent
	^`600@400`!

FindInSourceDialog removeSelector: #defaultExtent!

!methodRemoval: FindInSourceDialog #defaultExtent stamp: 'Install-7057-Dialog-defaultExtent-JuanVuletich-2025Feb28-09h50m-jmv.001.cs.st 5/13/2025 17:35:45'!
defaultExtent
	^`640@320`!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7057-Dialog-defaultExtent-JuanVuletich-2025Feb28-09h50m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7055] on 28 February 2025 at 10:57:26 am'!
!MessageNode methodsFor: 'testing' stamp: 'jmv 2/28/2025 10:55:24' prior: 16897354 overrides: 16920099!
                  isMessageNamed: aSelector
	"aSelector may be a Symbol or a String."

	^aSelector = self selectorSymbol ! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7058-SenderAutoHighlight-fix-JuanVuletich-2025Feb28-10h56m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7055] on 28 February 2025 at 10:36:35 am'!
!Text methodsFor: 'copying' stamp: 'jmv 2/28/2025 10:36:31' prior: 16979427 overrides: 16948944!
   copyReplaceFrom: start to: stop with: aText
	| newRuns newString |
	newString := string copyReplaceFrom: start to: stop with: aText string.
	newRuns := runs copyReplaceFrom: start to: stop with: aText runs.
	^self class string: newString runs: newRuns.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7059-Text-copyReplaceOptimization-JuanVuletich-2025Feb28-09h56m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7059] on 28 February 2025 at 12:24:29 pm'!
!PluggableTextModel methodsFor: 'accessing' stamp: 'jmv 2/28/2025 12:14:09' overrides: 16984392!
         basicReplaceFrom: start to: stop with: replacement
	"As requested. Basic service used by Undo / Redo. Does not genertate undo."

	"If we style text (as usual for Smalltalk code), but text is huge, assume plain String is OK.
	This was needed to accomodate class definition with thousands of instance variables,
	meaning a class definition with a single word-wrapped line of several hundred thousand character.
	It makes no sense to shout that, and plain String is composed much faster."
	(self stylesText and: [actualContents size + replacement size > self textStylerClass maxSizeForStyling ]) ifTrue: [
		actualContents := actualContents asString copyReplaceFrom: start to: stop with: replacement asString.
		actualContents := actualContents asText.
		^self ].

	^super basicReplaceFrom: start to: stop with: replacement! !
!SHTextStyler class methodsFor: 'constants' stamp: 'jmv 2/28/2025 12:23:14'!
                           maxSizeForStyling
	"Rather arbitrary, but reasonable."
	^20000! !
!SHTextStyler class methodsFor: 'constants' stamp: 'jmv 2/28/2025 12:13:44'!
                 minSizeForBackgroundStyling
	"Rather arbitrary, but reasonable."
	^4096! !
!SHTextStyler methodsFor: 'styling' stamp: 'jmv 2/28/2025 12:14:21' prior: 16944693!
convertAndStyle: text allowBackgroundStyleProcess: aBoolean
	"Do the styling on the model text.
	After finishing, tell model, by triggering #shoutStyled."
	self getReady.
	formattedText := text.
	formattedText removeAttributesThat: [ :attribute | attribute isForShout ].
	(aBoolean and: [formattedText size >= self class minSizeForBackgroundStyling])
		ifTrue: [
			formattedText size <= self class maxSizeForStyling ifTrue: [
				self convertAndStyleInBackgroundProcess ]]
		ifFalse: [
			self parseText.
			self privateAutoHighlight.
			self privateConvertAssignmentsOffset: 0.
			self privateStyle.
			textModel changed: #shoutStyled ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7060-DisableShoutForMonsterClassDefinitions-JuanVuletich-2025Feb28-12h15m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7060] on 28 February 2025 at 3:11:17 pm'!
!CodeFileBrowser methodsFor: 'as yet unclassified' stamp: 'HAW 2/28/2025 15:09:16'!
           removeUpToDate
	
	caseCodeSource classes do: [ :aPseudoClass |
		aPseudoClass removeUpToDateMethods.
		aPseudoClass theMetaClass removeUpToDateMethods ].
	self classListIndex: 0! !
!CodeFileBrowserWindow methodsFor: 'as yet unclassified' stamp: 'HAW 2/28/2025 09:28:35'!
                 removeUpToDate
	
	model removeUpToDate! !
!PseudoClass methodsFor: 'removing' stamp: 'HAW 2/28/2025 15:09:41'!
                 removeUpToDateMethods

	self selectors do: [ :aSelector | self removeIfUpToDate: aSelector ].
	self organization removeEmptyCategories.! !
!PseudoClass methodsFor: 'private' stamp: 'HAW 2/28/2025 15:06:18'!
                 removeIfUpToDate: aSelector

	| realClass pseudoSourceCode realSourceCode |

	realClass := self realClass ifNil: [^self ].
	realSourceCode := realClass sourceCodeAt: aSelector ifAbsent: [ nil ].
	pseudoSourceCode := self sourceCodeAt: aSelector.
	realSourceCode = pseudoSourceCode ifTrue: [ self removeMethod: aSelector ]! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'HAW 2/28/2025 13:17:27' prior: 16823329 overrides: 16799771!
    buildMorphicWindow
	"Create a pluggable version of all the views for a Browser, using Morphic widgets."

	| sysCatList msgCatList upperPanes clsLayout clsList msgList |
	model systemCategoryList ifNotEmpty: [ 
		model setSelectedSystemCategory: model systemCategoryList first ].
	sysCatList := (PluggableListMorph
			withModel: model 
			listGetter: #systemCategorySingleton
			indexGetter: #indexIsOne 
			indexSetter: #indexIsOne:)
				menuNshortcutsKey: #codeFileListMenuSpec.
	sysCatList hideScrollBarsIndefinitely.
	
	msgCatList := (PluggableListMorph
			withModel: model 
			listGetter: #messageCategoryList
			indexGetter: #messageCategoryListIndex 
			indexSetter: #messageCategoryListIndex:)
				menuNshortcutsKey: #messageCatListMenuSpec.

	clsList := self buildMorphicClassList.
	clsLayout := self buildMorphicClassColumnWith: clsList.
	msgList := self buildMorphicMessageList.

	upperPanes := LayoutMorph newRow.
	upperPanes
		addMorph: clsLayout proportionalWidth: 0.3;
		addAdjusterAndMorph: msgCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: msgList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: sysCatList fixedHeight: (Preferences at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.
	model changed: #editSelection! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'HAW 2/28/2025 09:27:08' prior: 16823373 overrides: 16826660!
                  optionalButtonTuples
	"Answer a tuple buttons, in the format:
			button label
			selector to send
			help message"
	^ (model baseCodeSource isLiveSmalltalkImage and: [ model caseCodeSource isLiveSmalltalkImage not ])
		ifTrue: [ super optionalButtonTuples, 
			#((17	'remove up to date'		removeUpToDate 	'remove up to date methods...')) ]
		ifFalse: [
			"For non-standard browser configurations assume most of the default buttons are invalid"
			#(
			) ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7061-CodeFileBrowser-RemoveUpToDate-HernanWilkinson-2025Feb28-15h11m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7061] on 1 March 2025 at 5:31:30 pm'!
!TestResult methodsFor: 'running' stamp: 'jmv 3/1/2025 17:16:02' prior: 16977945!
           runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				"self reportAboutToRun: aTestCase."
				aTestCase runCase.
				"self reportPassed: aTestCase."
				true]
					on: self class failure
					do: [ :signal |
						self reportFailed: aTestCase because: signal.
						(self failures isEmpty or: [ failures last ~~ aTestCase ])
							ifTrue: [ failures add: aTestCase ].
						signal sunitExitWith: false ]]
							on: UnhandledError
							do: [ :signal |
								self reportError: aTestCase because: signal.
								aTestCase errored: signal.
								self errors add: aTestCase.
								signal sunitExitWith: false ].

	testCasePassed
		ifTrue: [ self passed add: aTestCase ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7062-DontLogEveryTestRunToTranscript-JuanVuletich-2025Mar01-17h16m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7062] on 5 March 2025 at 10:55:00 am'!
!Morph methodsFor: 'submorphs-add/remove' stamp: 'hlsf 3/1/2025 10:17:12' prior: 16908168!
                      delete
	"Remove the receiver as a submorph of its owner and make its 
	new owner be nil."

	| aWorld |
	aWorld := self world ifNil: [ self runningWorld ].
	aWorld ifNotNil: [
		aWorld activeHand ifNotNil: [ :h | h
			releaseKeyboardFocus: self;
			releaseMouseFocus: self ]].
	self privateDelete.
	self clearDependencyAndEvents.
	self allSubmorphsDo: [ :each |
		each clearDependencyAndEvents ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7063-SmallSimplification-HilaireFernandes-2025Mar05-10h54m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #7062] on 5 March 2025 at 10:56:02 am'!
!MenuMorph methodsFor: 'accessing' stamp: 'hlsf 3/2/2025 10:34:10' prior: 16894782!
               stayUp: aBoolean
	stayUp := aBoolean.
	aBoolean 
		ifTrue: [ self removeStayUpBox.
			self setProperty: #layerNumber toValue: 20]
		ifFalse: [self removeProperty: #layerNumber].
	self taskbar ifNotNil: [ :tb | tb refreshTaskbarFor: self ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7064-stayUpMenusOnTop-HilaireFernandes-2025Mar05-10h55m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #7062] on 5 March 2025 at 10:56:53 am'!
!LayoutMorph methodsFor: 'accessing' stamp: 'hlsf 2/9/2025 10:11:59' prior: 16890780 overrides: 16904549!
                        adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	doAdoptWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: color) ]
		ifFalse: [ self color: `Color transparent` ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7065-LayoutMorph-color-tweak-HilaireFernandes-2025Mar05-10h56m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #7062] on 5 March 2025 at 11:04:00 am'!
!AbstractFont methodsFor: 'measuring' stamp: 'hlsf 3/5/2025 11:00:45'!
                             averageCharWidth

	^ ((self widthOf: $A) + (self widthOf: $i) / 2) asIntegerOrFloat
	! !
!LabelMorph methodsFor: 'accessing' stamp: 'hlsf 3/5/2025 11:02:45'!
  contents: newContents constrainedTo: aWidth
"
	Label may need to be displayed given a constrained width
"
	| f adjustedContents |
	f := self font.
	adjustedContents := (f widthOfString: newContents ) > aWidth 
		ifTrue: [" label to be truncated, adjsust the avalaible space for label considering the additional ellipsis "
			newContents truncateWithElipsisTo: (aWidth - (f widthOfString: '...') / f averageCharWidth) rounded]
		ifFalse: [newContents].
	self contents: adjustedContents 
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7066-LabelMorph-contents-constrainedTo-HilaireFernandes-2025Mar05-10h56m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #7066] on 12 March 2025 at 4:37:11 pm'!
!AbstractVectorCanvas methodsFor: 'paths' stamp: 'mv 3/5/2025 18:09:04'!
                 stadium: aRectangle
	"
| r |
r := 500@150 extent: 100@250.
(VectorCanvas onForm: Display)
	strokeWidth: 2.0 color: Color red do: [ :canvas |
			canvas stadium: r ].
(VectorCanvas onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color red do: [ :canvas |
		canvas
			stadium: r ].
Display forceToScreen
"
	| height p1 p2 p3 p4 radius width x1 x2 y1 y2 |
	width := aRectangle width.
	height := aRectangle height.
	radius := (width min: height) / 2.
	height < width
		ifTrue: [
			x1 := aRectangle left + radius.
			x2 := aRectangle right - radius.
			y1 := aRectangle top.
			y2 := aRectangle bottom.
			p1 := x1 @ y1.
			p2 := x2 @ y1.
			p3 := x2 @ y2.
			p4 := x1 @ y2 ]
		ifFalse: [
			x1 := aRectangle left.
			x2 := aRectangle right.
			y1 := aRectangle top + radius.
			y2 := aRectangle bottom - radius.
			p1 := x1 @ y2.
			p2 := x1 @ y1.
			p3 := x2 @ y1.
			p4 := x2 @ y2].
	self
		moveTo: p1;
		lineTo: p2;
		arcTo: p3 radius: radius angleOfXAxis: 0 largeFlag: false sweepFlag: true;
		lineTo: p4;
		arcTo: p1 radius: radius angleOfXAxis: 0 largeFlag: false sweepFlag: true.! !
!Morph methodsFor: 'geometry services' stamp: 'mv 3/12/2025 16:35:24' prior: 16906445!
                    bitMask
	"Answer an 1bpp Form with our bitMask.
	Include all pixels drawn by any morph in our submorphs tree.
	Query with #pixelValueAt:
	Pixels drawn by us (or any submorph) are 0. Pixels not drawn by us (or any submorph) are 1.
	Remember to do `self removeProperty: #bitMask when appropriate!!
	(i.e. when we change in such a way to make the bitMask invalid)
	
	Also see senders of #contour"

	| prevNotVisibleFlag bounds answer auxCanvas |

	(self valueOfProperty: #bitMask) ifNotNil: [ :bitMask |
		^bitMask ].

	"Position and scale us in order to fill required extent, but disregard any rotation.
	Do it without triggering any invalidation at all."
	prevNotVisibleFlag := self privateFlagAt: 3.
	bounds := self findFullBoundsInOwner.
	[
		answer := Form extent: bounds extent depth: 32.
		"Ask for a Canvas with subpixels so it can also handle translucent target"
		auxCanvas := VectorCanvas onFormWithSubPixelAntiAliasing: answer translation: bounds origin negated.
		"But disable subpixel anti aliasing, as we are answering a Form, and therefore can't assume a Display geometry."
		auxCanvas engine disableSubPixelSampling.
		self privateFlagAt: 3 put: false.
		auxCanvas fullDraw: self.
	] ensure: [
		self privateFlagAt: 3 put: prevNotVisibleFlag ].
	^self setProperty: #bitMask toValue:
		"Reverse it so we get bit=1 for affected pixels."
		((answer asGrayForm: 1) asFormOfDepth: 1) reverse.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7067-stadium-oval-like-shape-MarkVolkman-2025Mar12-16h35m-RMV.001.cs.st----!

'From Cuis7.3 [latest update: #7066] on 10 March 2025 at 9:45:21 pm'!
!Morph methodsFor: 'menus' stamp: 'hlsf 3/10/2025 21:43:22' prior: 16907431!
          addExportMenuItems: aMenu hand: aHandMorph
	"Add export items to the menu"

	aMenu ifNotNil: [
		| aSubMenu |
		aSubMenu := MenuMorph new defaultTarget: self.
		(self respondsTo: #exportAsPNG) ifTrue: [
			aSubMenu add: 'PNG file' action: #exportAsPNG.].
		aSubMenu add: 'BMP file' action: #exportAsBMP.
		aSubMenu add: 'JPEG file' action: #exportAsJPEG.
		aMenu add: 'export...' subMenu: aSubMenu]
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7068-Morph-exportAsPNG-menuItem-HilaireFernandes-2025Mar10-21h40m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #7068] on 13 March 2025 at 2:35:29 pm'!
!Browser methodsFor: 'message category functions' stamp: 'KLG 3/8/2025 19:04:27' prior: 50352268!
                      addExtensionCategory
	"Present a choice package names and let the user enter a new category suffx.
	Take the suffix form the selected category."

	| packageNames packageNameIndex newCategoryName oldMessageCategoryListIndex |
	
	selectedClassName ifNil: [ ^self ].

	packageNames := (CodePackage installedPackages collect: [ :package |
		package packageName ]) sorted.
	packageNames ifEmpty: [ ^ self ].
	
	packageNameIndex := PopUpMenu 
		withCaption: 'Which package to extend?'
		chooseFrom: packageNames.
	packageNameIndex = 0 ifTrue: [ ^ self ].

	(newCategoryName := self 
		request: 'Enter the category name'
		initialAnswer: 
			(String streamContents: [ :stream |
				stream
					nextPut: $*;
					nextPutAll: (packageNames at: packageNameIndex).
				selectedMessageCategory ifNotNil: [
					stream
						nextPut: $-;
						nextPutAll: selectedMessageCategory ] ])) ifEmpty: [ ^ self ].
	(newCategoryName at: 1) = $*
		ifFalse: [
			self confirm:
				"I know about with #withNewlines ..."
				`'The category choosen does not start with an asterix (*).',
				String newLineString,
				'Do you want to use it anyway?'` :: ifFalse: [ ^ self ] ]
		ifTrue: [
			packageNames includes: newCategoryName allButFirst ::
				ifTrue: [
					self confirm:
						`'The name choosen denotes a package without a documenting suffix',
						String newLineString,
						'Do you want to use it anyway?'`:: ifFalse: [ ^ self ] ]
				ifFalse: [
					packageNames includes: (newCategoryName copyUpToLast: $-) allButFirst :: ifFalse: [
						self confirm:
							`'The category or prefix choosen does not match any package name.', 
							String newLineString,
							'Do you want to use it anyway?'` :: ifFalse: [ ^ self ] ] ] ].
	oldMessageCategoryListIndex := self messageCategoryListIndex.
		self classOrMetaClassOrganizer
			addCategory: newCategoryName
			before: selectedMessageCategory.
		self changed: #messageCategoryList.
		self messageCategoryListIndex:
			(oldMessageCategoryListIndex = 0
				ifTrue: [ self classOrMetaClassOrganizer categories size + 1 ]
				ifFalse: [ oldMessageCategoryListIndex ]).
		self changed: #messageCategoryList! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7069-addExtensionCategory-fix-GeraldKlix-2025Mar13-14h34m-KLG.001.cs.st----!

'From Cuis7.3 [latest update: #7069] on 13 March 2025 at 4:48:28 pm'!
!CodeFileBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 3/13/2025 16:41:58'!
    removeUnmodifiedClasses
	model removeUnmodifiedClasses! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 3/13/2025 16:38:35' prior: 50360385 overrides: 16826660!
               optionalButtonTuples
	"Answer a tuple buttons, in the format:
			button label
			selector to send
			help message"
	^ (model baseCodeSource isLiveSmalltalkImage and: [ model caseCodeSource isLiveSmalltalkImage not ])
		ifTrue: [ super optionalButtonTuples, 
			#((17	'remove up to date'		removeUnmodifiedClasses 	'remove up to date methods and classes...')) ]
		ifFalse: [
			"For non-standard browser configurations assume most of the default buttons are invalid"
			#(
			) ].! !
!CodeFileBrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 3/13/2025 16:46:30' prior: 16823471 overrides: 50339848!
                               classListMenuSpec
	"Spec for the menu and shortcut keys for the class list.
	See coment at Morph >> #getMenu
	"
	^ model baseCodeSource isLiveSmalltalkImage
		ifTrue: [
			#(
				#(0 		'Class List' 			false)
				#(10	'Definition' 				nil 	model 		editClass 							editFindReplaceIcon)
				#(20	'Comment' 				nil 	model 		editComment 						editFindReplaceIcon)
				#(30      'Show Hierarchically' 		nil   model          enableListClassesHierarchically 	goTopIcon)		
				#(40 	'Show Alphabetically' 	nil 	model 		enableListClassesAlphabetically 	sendReceiveIcon)
				#(50 	'-----')
				#(60	'Browse Full (b)' 			$b 	window 	browseMethodFull 					editFindReplaceIcon)
				#(70	'Class References (N)' 	$N 	window 	browseClassRefs 					classIcon)
				#(80 	'-----')
				#(90	'File In' 					nil 	model 		fileInClass 							updateIcon)
				#(100	'File Out' 				nil 	model 		fileOutClass 						fileOutIcon)
				#(110    'Browse Changes'		nil   model          browseCodeFileChanges  			changesIcon)
				#(120 	'-----')
				#(130	'Rename...' 				nil 	model 		renameClass 						saveAsIcon)
				#(140	'Remove' 				nil 	model 		removeClass 						listRemoveIcon)
				#(150 	'-----')
				#(160	'Remove Up to Date' 		nil 	model 		removeUnmodifiedClasses 			deleteIcon)
			)]
		ifFalse: [
			#(
				#(0 		'Class List' 			false)
				#(10	'Definition' 				nil 	model 		editClass 							editFindReplaceIcon)
				#(20	'Comment' 				nil 	model 		editComment 						editFindReplaceIcon)
				#(30      'Show Hierarchically' 		nil   model          enableListClassesHierarchically 	goTopIcon)		
				#(40 	'Show Alphabetically' 	nil 	model 		enableListClassesAlphabetically 	sendReceiveIcon)
				#(50 	'-----')
				#(80	'File Out' 				nil 	model 		fileOutClass 						fileOutIcon)
				#(90 	'-----')
				#(100	'Rename...' 				nil 	model 		renameClass 						saveAsIcon)
				#(110	'Remove' 				nil 	model 		removeClass 						listRemoveIcon)
				#(120 	'-----')
				#(130	'Remove Up to Date' 		nil 	model 		removeUnmodifiedClasses 			deleteIcon)
			) ].! !
!CodeFileBrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 3/13/2025 16:38:03' prior: 16823537!
            codeFileListMenuSpec
	"Spec for the menu and shortcut keys for the single entry filename list.
	See coment at Morph >> #getMenu
	"
	| answer |
	answer := 
			#(
				#(0 		'Code File' 			false)
				#(10	'Find Class... (f)' 			$f 	window 	findClass)
				#(20 	'-----') ).
	model baseCodeSource isLiveSmalltalkImage ifTrue: [
			answer := answer, #(
				#(30	'File In' 					nil 	model 		fileIn) )].
	answer := answer, 
			#(
				#(40	'File Out' 				nil 	model 		fileOut) ).
	model caseCodeSource isLiveSmalltalkImage ifFalse: [
		answer := answer, #(
				#(50	'Remove Up to Date' 		nil 	model 		removeUnmodifiedClasses) )].
	^answer! !
!PseudoClass methodsFor: 'testing' stamp: 'HAW 3/6/2025 18:56:12' prior: 16934600!
                    hasChanges

	self sourceCode isEmpty ifFalse:[^true].
	self organization hasNoComment ifFalse:[^true].
	definition ifNotNil: [ self realClass ifNotNil: [ :realClass | realClass definition = definition ifFalse: [ ^true]]].
	metaClass ifNotNil: [ ^metaClass hasChanges].
	^false! !

PseudoClass removeSelector: #removeUpToDateMethods!

!methodRemoval: PseudoClass #removeUpToDateMethods stamp: 'Install-7070-ImprovedRemoveUpToDate-HernanWilkinson-JuanVuletich-2025Mar13-16h29m-jmv.003.cs.st 5/13/2025 17:35:45'!
removeUpToDateMethods

	self selectors do: [ :aSelector | self removeIfUpToDate: aSelector ].
	self organization removeEmptyCategories.!

PseudoClass removeSelector: #removeIfUpToDate:!

!methodRemoval: PseudoClass #removeIfUpToDate: stamp: 'Install-7070-ImprovedRemoveUpToDate-HernanWilkinson-JuanVuletich-2025Mar13-16h29m-jmv.003.cs.st 5/13/2025 17:35:45'!
removeIfUpToDate: aSelector

	| realClass pseudoSourceCode realSourceCode |

	realClass := self realClass ifNil: [^self ].
	realSourceCode := realClass sourceCodeAt: aSelector ifAbsent: [ nil ].
	pseudoSourceCode := self sourceCodeAt: aSelector.
	realSourceCode = pseudoSourceCode ifTrue: [ self removeMethod: aSelector ]!

CodeFileBrowserWindow removeSelector: #removeUpToDate!

!methodRemoval: CodeFileBrowserWindow #removeUpToDate stamp: 'Install-7070-ImprovedRemoveUpToDate-HernanWilkinson-JuanVuletich-2025Mar13-16h29m-jmv.003.cs.st 5/13/2025 17:35:45'!
removeUpToDate
	
	model removeUpToDate!

CodeFileBrowser removeSelector: #removeUpToDate!

!methodRemoval: CodeFileBrowser #removeUpToDate stamp: 'Install-7070-ImprovedRemoveUpToDate-HernanWilkinson-JuanVuletich-2025Mar13-16h29m-jmv.003.cs.st 5/13/2025 17:35:45'!
removeUpToDate
	
	caseCodeSource classes do: [ :aPseudoClass |
		aPseudoClass removeUpToDateMethods.
		aPseudoClass theMetaClass removeUpToDateMethods ].
	self classListIndex: 0!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7070-ImprovedRemoveUpToDate-HernanWilkinson-JuanVuletich-2025Mar13-16h29m-jmv.003.cs.st----!

'From Cuis7.3 [latest update: #7070] on 16 March 2025 at 8:03:33 pm'!
!FileIOAccessor methodsFor: 'utilities' stamp: 'wbsl 3/16/2025 20:03:07' prior: 16861727!
                           absolutePathComponentsFor: aString relativeTo: baseDirectory
	"aString is a relative path, and will be applied to baseDirectory
	See comment at #isAbsolutePathName"

	| baseDirectoryPathComponents tokens |

	baseDirectoryPathComponents := baseDirectory pathComponents.
	aString = '.' ifTrue: [ ^ baseDirectoryPathComponents copy ].
	aString = '..' ifTrue:  [^ baseDirectoryPathComponents allButLast ].

	tokens := aString asPathTokens.
	[ tokens notEmpty and: [ tokens first = '..' ]] whileTrue: [
		baseDirectoryPathComponents := baseDirectoryPathComponents allButLast.
		tokens removeFirst ].

	^ Array streamContents: [ :strm |
		baseDirectory drive ifNotNil: [ :drive |
			strm nextPut: drive ].
		strm nextPutAll: baseDirectoryPathComponents.
		tokens do: [ :each |
			each = '.' ifFalse: [ strm nextPut: each ]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7071-RelativePathResolution-InWindows-Fix-WeslleymbergLisboa-2025Mar16-20h02m-wbsl.001.cs.st----!

'From Cuis7.3 [latest update: #7071] on 18 March 2025 at 12:11:55 pm'!

PlacedMorph subclass: #Sample02Bezier
	instanceVariableNames: 'aStart aEnd aControlPoint bStart bEnd bControlPoint1 bControlPoint2 dashOffset '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Examples'!

!classDefinition: #Sample02Bezier category: #'Morphic-Examples' stamp: 'Install-7072-WalkingDashedBeziersExample-JuanVuletich-2025Mar18-12h08m-jmv.001.cs.st 5/13/2025 17:35:45'!
PlacedMorph subclass: #Sample02Bezier
	instanceVariableNames: 'aStart aEnd aControlPoint bStart bEnd bControlPoint1 bControlPoint2 dashOffset'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Examples'!
!Sample02Bezier methodsFor: 'stepping' stamp: 'jmv 3/18/2025 10:49:48' overrides: 16907759!
                              step

	dashOffset := dashOffset + 2.
	self redrawNeeded.! !
!Sample02Bezier methodsFor: 'stepping' stamp: 'jmv 3/18/2025 10:49:37' overrides: 16907787!
        stepTime
	^200! !
!Sample02Bezier methodsFor: 'stepping' stamp: 'jmv 3/18/2025 10:47:48' overrides: 16907808!
                  wantsSteps

	^ true! !
!Sample02Bezier methodsFor: 'initialization' stamp: 'jmv 3/18/2025 10:46:27' prior: 16945531 overrides: 16923973!
                       initialize
	super initialize.
	aStart := 500 atRandom @ 500 atRandom.
	aEnd := 500 atRandom @ 500 atRandom.
	aControlPoint := 500 atRandom @ 500 atRandom.
	bStart := 500 atRandom @ 500 atRandom.
	bEnd := 500 atRandom @ 500 atRandom.
	bControlPoint1 := 500 atRandom @ 500 atRandom.
	bControlPoint2 := 500 atRandom @ 500 atRandom.
	dashOffset := 0.! !
!Sample02Bezier methodsFor: 'drawing' stamp: 'jmv 3/18/2025 12:10:40' prior: 16945544 overrides: 16905026!
                       drawOn: aCanvas
	"Two Bezier curves. A Quadratic one (with start, end and a single control point), and a Cubic one (with start, end, and two control points)
	Sample02Bezier new openInHand
	"

	aCanvas strokeWidth: 2 color: Color green strokeDashArray: #(10 10) strokeDashArrayOffset: dashOffset do: [
		aCanvas
				moveTo: aStart;
				quadraticBezierTo: aEnd control: aControlPoint ].
	aCanvas strokeWidth: 1 color: Color darkGray strokeDashArray: #(1 3) strokeDashArrayOffset: Random next * 4 do: [
		aCanvas
				moveTo: aStart;
				lineTo: aControlPoint;
				lineTo: aEnd ].

	aCanvas strokeWidth: 3 color: Color red strokeDashArray: #(10 35) strokeDashArrayOffset: dashOffset do: [
		aCanvas
				moveTo: bStart;
				cubicBezierTo: bEnd control1: bControlPoint1 control2: bControlPoint2 ].
	aCanvas strokeWidth: 1 color: Color darkGray strokeDashArray: #(15 8) strokeDashArrayOffset: dashOffset do: [
		aCanvas
				moveTo: bStart;
				lineTo: bControlPoint1;
				lineTo: bControlPoint2;
				lineTo: bEnd ].! !

PlacedMorph subclass: #Sample02Bezier
	instanceVariableNames: 'aStart aEnd aControlPoint bStart bEnd bControlPoint1 bControlPoint2 dashOffset'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Examples'!

!classDefinition: #Sample02Bezier category: #'Morphic-Examples' stamp: 'Install-7072-WalkingDashedBeziersExample-JuanVuletich-2025Mar18-12h08m-jmv.001.cs.st 5/13/2025 17:35:45'!
PlacedMorph subclass: #Sample02Bezier
	instanceVariableNames: 'aStart aEnd aControlPoint bStart bEnd bControlPoint1 bControlPoint2 dashOffset'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Examples'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7072-WalkingDashedBeziersExample-JuanVuletich-2025Mar18-12h08m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7071] on 18 March 2025 at 12:17:43 pm'!
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 3/18/2025 12:03:11'!
                            displayByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try BOTH!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.'.
e displayByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsTop boundsBottom numContours numBeziers x y cx cy contourStart |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	 "Should use a specific table with 256 entries"
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8. "Should use a specific table with 256 entries"
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		startIndex to: stopIndex do: [ :charIndex | | latin1Code i |
			latin1Code := (aString at: charIndex) asciiValue.
			i := contourDataIndexes at: latin1Code + 1.
			advanceWidth := contourData at: i. i := i + 1.
			boundsLeft := contourData at: i. i := i + 1.
			boundsRight := contourData at: i. i := i + 1.
			boundsTop := contourData at: i. i := i + 1.
			boundsBottom := contourData at: i. i := i + 1.
			numContours := (contourData at: i) asInteger. i := i + 1.
			numContours timesRepeat: [
				numBeziers := (contourData at: i) asInteger. i := i + 1.
				ttMoveToX := contourData at: i. i := i + 1.
				ttMoveToY := contourData at: i. i := i + 1.
				x := ttMoveToX * sx + nextGlyphX.
				y := ttMoveToY * sy + nextGlyphY.
				contourStart := x@y.
				self moveTo: contourStart.
				numBeziers timesRepeat: [
					ttEndX := contourData at: i. i := i + 1.
					ttEndY := contourData at: i. i := i + 1.
					ttControlX := contourData at: i. i := i + 1.
					ttControlY := contourData at: i. i := i + 1.
					cx := ttControlX * sx + x.
					cy := ttControlY * sy + y.
					x := ttEndX * sx + x.
					y := ttEndY * sy + y.
					self quadraticBezierTo: x@y control: cx@cy
					].
				self lineTo: contourStart.
				].
			nextGlyphX := nextGlyphX + (advanceWidth * sx).
		]
	].
	^ nextGlyphX@nextGlyphY! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 3/18/2025 12:06:09'!
              displayUtf32: aWordArray from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f utf32 |
'Try BOTH!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf32 _ #(4314 4317 4320 4308 4315 32 4312 4324 4321 4323 4315 32 4307 4317 4314 4317 4320 32 4321 4312 4311 32 4304 4315 4308 4311 44 32 4327 4323 4317 32 4323 4311 32 4307 4312 4330 4304 4311 32 4304 4314 4312 4327 4323 4312 4307 44 32 4304 4307 32 4314 4312 4305 4320 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4320 4308 4324 4320 4308 4336 4308 4316 4307 4323 4316 4311 32 4308 4321 4311 46 32 4314 4308 4306 4308 4320 4308 32 4330 4317 4320 4324 4317 4320 4304 32 4308 4324 4324 4312 4330 4312 4304 4316 4311 4323 4320 32 4304 4311 32 4308 4304 4315 44 32 4316 4317 32 4327 4323 4304 4321 32 4315 4308 4316 4304 4316 4307 4320 4312 32 4320 4308 4324 4308 4320 4320 4308 4316 4311 4323 4320 32 4327 4323 4312 46 32 4311 4308 32 4324 4323 4311 4308 4316 4311 32 4315 4317 4314 4314 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4309 4312 4321 46 32 4309 4312 4315 32 4307 4308 4316 4312 4327 4323 4308 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4311 4336 4308 4317 4324 4336 4320 4304 4321 4311 4323 4321 32 4308 4334 44 32 4308 4304 32 4336 4304 4321 32 4309 4317 4314 4323 4315 4323 4321 32 4324 4304 4321 4311 4312 4307 4312 4312 32 4307 4308 4321 4308 4320 4323 4316 4311 46 32 4308 4334 32 4317 4324 4324 4312 4330 4312 4312 4321 32 4311 4317 4320 4327 4323 4304 4311 4317 4321 32 4315 4308 4312 44 32 4307 4317 4330 4311 4323 4321 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4312 4316 32 4327 4323 4317 46 32 4321 4323 4315 4315 4317 32 4311 4320 4304 4330 4311 4304 4311 4317 4321 32 4308 4312 32 4312 4323 4321 44 32 4323 4311 32 4317 4315 4316 4308 4321 32 4309 4312 4320 4311 4323 4311 4308 32 4307 4308 4311 4320 4304 4334 4312 4311 46) asWordArray.
e displayUtf32: utf32 from: 1 to: utf32 size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsTop boundsBottom numContours numBeziers x y cx cy contourStart |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		startIndex to: stopIndex do: [ :utf32Index | | utf32 utf8Byte1 uft8Byte2 utf8Byte3 utf8Byte4 i |
			utf32 := aWordArray at: utf32Index.
			utf32 <= 16r7F
				ifTrue: [
					utf8Byte1 := utf32.
					i := contourDataIndexes at: utf8Byte1 + 1.
					]
				ifFalse: [ utf32 <= 16r7FF
				ifTrue: [
					utf8Byte1 := (utf32 bitShift: -6) bitOr: 2r11000000.
					uft8Byte2 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1.
					]
				ifFalse: [ utf32 <= 16rFFFF
				ifTrue: [
					utf8Byte1 := (utf32 bitShift: -12) bitOr: 2r11100000.
					uft8Byte2 := ((utf32 bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte3 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1.
					i := contourDataIndexes at: utf8Byte3 - i + 1.
					]
				ifFalse: [
					utf8Byte1 := (utf32 bitShift: -18) bitOr: 2r11110000.
					uft8Byte2 := ((utf32 bitShift: -12) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte3 := ((utf32 bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte4 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1.
					i := contourDataIndexes at: utf8Byte3 - i + 1.
					i := contourDataIndexes at: utf8Byte4 - i + 1.
					]]].
			advanceWidth := contourData at: i. i := i + 1.
			boundsLeft := contourData at: i. i := i + 1.
			boundsRight := contourData at: i. i := i + 1.
			boundsTop := contourData at: i. i := i + 1.
			boundsBottom := contourData at: i. i := i + 1.
			numContours := (contourData at: i) asInteger. i := i + 1.
			numContours timesRepeat: [
				numBeziers := (contourData at: i) asInteger. i := i + 1.
				ttMoveToX := contourData at: i. i := i + 1.
				ttMoveToY := contourData at: i. i := i + 1.
				x := ttMoveToX * sx + nextGlyphX.
				y := ttMoveToY * sy + nextGlyphY.
				contourStart := x@y.
				self moveTo: contourStart.
				numBeziers timesRepeat: [
					ttEndX := contourData at: i. i := i + 1.
					ttEndY := contourData at: i. i := i + 1.
					ttControlX := contourData at: i. i := i + 1.
					ttControlY := contourData at: i. i := i + 1.
					cx := ttControlX * sx + x.
					cy := ttControlY * sy + y.
					x := ttEndX * sx + x.
					y := ttEndY * sy + y.
					self quadraticBezierTo: x@y control: cx@cy
					].
				self lineTo: contourStart.
				].
			nextGlyphX := nextGlyphX + (advanceWidth * sx).
			]
	].
	^ nextGlyphX@nextGlyphY! !
!VectorEngine class methodsFor: 'instance creation' stamp: 'jmv 3/18/2025 12:02:26'!
                onForm: aForm
	"To be called on specific subclasses."

	^self onForm: aForm subPixelAntiAliasing: nil! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 3/18/2025 12:04:13' overrides: 50361062!
       displayByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try BOTH!!'.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.'.
e displayByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale asFloat.
	sy := scale * trueTypeScale asFloat.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	 "Should use a specific table with 256 entries"
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8. "Should use a specific table with 256 entries"
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayByteString: aString from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
			useST80Glyphs: false
			edgeCounts: edgeCounts
			alphaMask: alphaMask
		].
	^ nextGlyphX @ nextGlyphY! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 3/18/2025 12:05:22' overrides: 50361160!
                             displayUtf32: aWordArray from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f utf32 |
'Try BOTH!!'.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf32 _ #(4314 4317 4320 4308 4315 32 4312 4324 4321 4323 4315 32 4307 4317 4314 4317 4320 32 4321 4312 4311 32 4304 4315 4308 4311 44 32 4327 4323 4317 32 4323 4311 32 4307 4312 4330 4304 4311 32 4304 4314 4312 4327 4323 4312 4307 44 32 4304 4307 32 4314 4312 4305 4320 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4320 4308 4324 4320 4308 4336 4308 4316 4307 4323 4316 4311 32 4308 4321 4311 46 32 4314 4308 4306 4308 4320 4308 32 4330 4317 4320 4324 4317 4320 4304 32 4308 4324 4324 4312 4330 4312 4304 4316 4311 4323 4320 32 4304 4311 32 4308 4304 4315 44 32 4316 4317 32 4327 4323 4304 4321 32 4315 4308 4316 4304 4316 4307 4320 4312 32 4320 4308 4324 4308 4320 4320 4308 4316 4311 4323 4320 32 4327 4323 4312 46 32 4311 4308 32 4324 4323 4311 4308 4316 4311 32 4315 4317 4314 4314 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4309 4312 4321 46 32 4309 4312 4315 32 4307 4308 4316 4312 4327 4323 4308 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4311 4336 4308 4317 4324 4336 4320 4304 4321 4311 4323 4321 32 4308 4334 44 32 4308 4304 32 4336 4304 4321 32 4309 4317 4314 4323 4315 4323 4321 32 4324 4304 4321 4311 4312 4307 4312 4312 32 4307 4308 4321 4308 4320 4323 4316 4311 46 32 4308 4334 32 4317 4324 4324 4312 4330 4312 4312 4321 32 4311 4317 4320 4327 4323 4304 4311 4317 4321 32 4315 4308 4312 44 32 4307 4317 4330 4311 4323 4321 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4312 4316 32 4327 4323 4317 46 32 4321 4323 4315 4315 4317 32 4311 4320 4304 4330 4311 4304 4311 4317 4321 32 4308 4312 32 4312 4323 4321 44 32 4323 4311 32 4317 4315 4316 4308 4321 32 4309 4312 4320 4311 4323 4311 4308 32 4307 4308 4311 4320 4304 4334 4312 4311 46) asWordArray.
e displayUtf32: utf32 from: 1 to: utf32 size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen."

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayUtf32: aWordArray from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
			useST80Glyphs: false
			edgeCounts: edgeCounts
			alphaMask: alphaMask
		].
	^ nextGlyphX @ nextGlyphY! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 3/18/2025 11:45:09'!
         primDisplayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes useST80Glyphs: aBoolean edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primDisplayString' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 3/18/2025 11:44:47'!
                         primDisplayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes useST80Glyphs: aBoolean edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primDisplayUtf32' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 3/18/2025 11:45:29'!
                          primDisplayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes useST80Glyphs: aBoolean edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primDisplayStringWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 3/18/2025 11:45:40'!
                     primDisplayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes useST80Glyphs: aBoolean edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primDisplayUtf32WP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 7/12/2024 15:51:39' prior: 17000603!
                    displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours numBeziers baseIndex x y cx cy contourStart deltaXToCenter deltaXForBaseGlyph deltaXForDiacriticalMark baseBoundsTop deltaYForDiacriticalMark byte1 byte2OrNil |
	deltaXForBaseGlyph := 0.0.
	baseBoundsTop := 0.
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	byte1 := nil.
	byte2OrNil := nil.
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		baseIndex := 0.
		byteStartIndex to: byteStopIndex do: [ :byteIndex | | byte i |
			byte := aByteArray at: byteIndex.
			byte1 isNil ifTrue: [byte1 := byte ] ifFalse: [ byte2OrNil isNil ifTrue: [ byte2OrNil := byte ]].
			i := contourDataIndexes at: baseIndex + byte + 1.

			"$i followed by a Combining Diacritical Mark is replaced by CodePoint 305 Dotless i, UTF-8 #[196 177]
			(UnicodeString fromUtf8Bytes: #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32 105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137	]) edit
			This should also be done for VectorEngineWithPlugin
			"
			(byte1 = 105 and: [ byteIndex < (byteStopIndex-1) ] and: [
				(aByteArray at: byteIndex+1) = 204 or: [ (aByteArray at: byteIndex+1) = 205 and: [ (aByteArray at: byteIndex+2) < 176 ]]])
					ifTrue: [
						i := contourDataIndexes at: 196 + 1.
						i := contourDataIndexes at: i negated + 177 + 1 						].

			i < 0
				ifTrue: [ baseIndex := i negated ]
				ifFalse: [
					advanceWidth := contourData at: i. i := i + 1.
					boundsLeft := contourData at: i. i := i + 1.
					boundsRight := contourData at: i. i := i + 1.
					boundsBottom := contourData at: i. i := i + 1.
					boundsTop := contourData at: i. i := i + 1.
					numContours := (contourData at: i) asInteger. i := i + 1.
					"TrueType doesn't speciy how to position diacritics wrt base character glyph.
					Horizontally center diacriticals wrt base glyph.
					See
						basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
						formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
					This should also be done for VectorEngineWithPlugin
					Apparently OpenType can do better than TrueType, as it includes the GPOS table."
					deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
					byte1 = 204 ifTrue: [
						byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
							deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
						byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
							deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ]].

					"DoubleWidth code points that combine above previous and following characters.
					Codepoints between 16r035C and 16r0363.
					Example: o͢o
					Don't center them"
					(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
						deltaXToCenter := 0.0 ].

					deltaXForDiacriticalMark := 0.0.
					deltaYForDiacriticalMark := 0.
					advanceWidth = 0.0
						ifFalse: [ "Regular glyph"
							deltaXForBaseGlyph := deltaXToCenter.
							baseBoundsTop := boundsTop ]
						ifTrue: [ "Diacritical mark"
							deltaXForBaseGlyph = 0.0  						"For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
								ifFalse: [
									deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
									baseBoundsTop > boundsBottom ifTrue: [
										deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
					nextGlyphX := nextGlyphX + deltaXForDiacriticalMark.
					numContours timesRepeat: [
						numBeziers := (contourData at: i) asInteger. i := i + 1.
						ttMoveToX := contourData at: i. i := i + 1.
						ttMoveToY := contourData at: i. i := i + 1.
						x := ttMoveToX * sx + nextGlyphX.
						y := ttMoveToY * sy + nextGlyphY + deltaYForDiacriticalMark.
						contourStart := x@y.
						self moveTo: contourStart.
						numBeziers timesRepeat: [
							ttEndX := contourData at: i. i := i + 1.
							ttEndY := contourData at: i. i := i + 1.
							ttControlX := contourData at: i. i := i + 1.
							ttControlY := contourData at: i. i := i + 1.
							cx := ttControlX * sx + x.
							cy := ttControlY * sy + y.
							x := ttEndX * sx + x.
							y := ttEndY * sy + y.
							self quadraticBezierTo: x@y control: cx@cy
							].
						self lineTo: contourStart.
						].
					nextGlyphX := nextGlyphX + (advanceWidth * sx) - deltaXForDiacriticalMark.
					baseIndex := 0.
					byte1 := nil.
					byte2OrNil := nil.
				]
			]
	].
	^ nextGlyphX@nextGlyphY! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 3/18/2025 11:24:40' prior: 17000777!
  pathSequence: aFloat32Array
	"
	(VectorEngine onForm: Display subPixelAntiAliasing: true)
		geometryTransformation: (AffineTransformation withScale: 14 position: 100@100);
		strokeWidth: 3 color: Color black do: [ :engine |
			engine
				pathSequence: `#[
					0.0 15.0 15.0
					3.0 30.0 30.0 15.0 23.3 21.7 30.0
					3.0 45.0 15.0 38.3 30.0 45.0 23.3
					3.0 30.0 0.0 45.0 6.7 38.3 0.0
					3.0 15.0 15.0 21.7 0.0 15.0 6.7
					0.0 22.0 19.0
					2.0 30.0 24.0 24.5 24.0
					2.0 38.0 19.0 35.5 24.0
					0.0 25.0 10.0
					1.0 25.0 12.0
					0.0 35.0 10.0
					1.0 35.0 12.0
					] asFloat32Array`
				].
	Display forceToScreen
	"
	| size i |
	size := aFloat32Array size.
	i := 1.
	[ i < size ] whileTrue: [
		| commandType p1x p1y p2x p2y p3x p3y |
		commandType := aFloat32Array at: i. i := i + 1.
		commandType caseOf: {
			[0.0] -> [
				i < size ifFalse: [ ^self "failure" ].
				p1x := aFloat32Array at: i. i := i + 1.
				p1y := aFloat32Array at: i. i := i + 1.
				self moveTo: p1x@p1y].
			[1.0] -> [
				i < size ifFalse: [ ^self "failure" ].
				p1x := aFloat32Array at: i. i := i + 1.
				p1y := aFloat32Array at: i. i := i + 1.
				self lineTo: p1x@p1y].
			[2.0] -> [
				i+2 < size ifFalse: [ ^self "failure" ].
				p1x := aFloat32Array at: i. i := i + 1.
				p1y := aFloat32Array at: i. i := i + 1.
				p2x := aFloat32Array at: i. i := i + 1.
				p2y := aFloat32Array at: i. i := i + 1.
				self quadraticBezierTo: p1x@p1y control: p2x@p2y ].
			[3.0] -> [
				i+4 < size ifFalse: [ ^self "failure" ].
				p1x := aFloat32Array at: i. i := i + 1.
				p1y := aFloat32Array at: i. i := i + 1.
				p2x := aFloat32Array at: i. i := i + 1.
				p2y := aFloat32Array at: i. i := i + 1.
				p3x := aFloat32Array at: i. i := i + 1.
				p3y := aFloat32Array at: i. i := i + 1.
				self cubicBezierTo: p1x@p1y control1: p2x@p2y control2: p3x@p3y ]}
		otherwise: [ ^self "failure"]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7073-UTF32-ByteString-VectorEngine-SupportAndExamples-JuanVuletich-2025Mar18-12h11m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7067] on 11 March 2025 at 12:07:11 pm'!
!IntegerArray methodsFor: 'private' stamp: 'jmv 3/6/2025 19:07:06' overrides: 16948649!
                           replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!IntegerArray methodsFor: 'private' stamp: 'jmv 3/11/2025 12:03:53' prior: 16888434!
              primFill: aPositiveInteger
	"Fill the receiver, an indexable bytes or words object, with the given positive integer. The range of possible fill values is [0..255] for byte arrays and [0..(2^32 - 1)] for word arrays.
	Note: We store signed integers (see class comment). Senders may hack negative integers into positive integers for this primitive to work. See senders. Use with care."

	<primitive: 145>
	self errorImproperStore.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7074-IntegerArray-Enh-JuanVuletich-2025Mar11-12h06m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7066] on 7 March 2025 at 10:03:44 am'!
!VectorEngineDrawer methodsFor: 'accessing' stamp: 'jmv 3/6/2025 17:42:24'!
                              morphContourAfterDrawInterectInto: aGlobalContour
	"In targetForm coordinates.
	Doesn't account for any clipping at all.
	Doesn't include any protruding submorphs.
	Only valid _after_ drawing currentMorph.
	Use argument if appropriate, or answer a new array if not.
	Dilates contour by the last used strokeWIdth. A future improvement must be,
	when building the contour in the engine, for each point recorded, also record
	the amout it must be dilated by, i.e. the current strokeWidth at that moment.
	See #morphContourAfterDrawInto:into:
	See #morphContourAfterDrawUpdate:oldTop:oldBottom:into:
	"

	| y0 y1 dilationHalfHeight strokeHalfSquared |
	y0 := morphBoundsTop max: 0.
	y1 := morphBoundsBottom min: targetHeight -1.
	dilationHalfHeight := (strokeWidth / 2.0) rounded.
	strokeHalfSquared := (strokeWidth / 2.0) squared.
	y0 to: y1 do: [ :y | | x0 x1 i |
		x0 := targetWidth.
		x1 := 0.
		dilationHalfHeight negated to: dilationHalfHeight do: [ :dy | | dx |
			(y + dy between: y0 and: y1) ifTrue: [
				dx := (strokeHalfSquared - dy squared max: 0) sqrt.
				x0 := x0 min: ((contour at: y+dy * 2 + 1) - dx) rounded.
				x1 := x1 max: ((contour at: y+dy * 2 + 2) + dx) rounded ]].
		i := y*2+1.
		aGlobalContour at: i put: ((aGlobalContour at: i) max: x0).
		aGlobalContour at: i+1 put: ((aGlobalContour at: i+1) min: x1) ].! !
!VectorEngineDrawer methodsFor: 'accessing' stamp: 'jmv 3/6/2025 17:39:14' prior: 17001616!
             morphContourAfterDrawInto: contourArrayOrNil into: aBlock
	"In targetForm coordinates.
	Doesn't account for any clipping at all.
	Doesn't include any protruding submorphs.
	Only valid _after_ drawing currentMorph.
	Use argument if appropriate, or answer a new array if not.
	Dilates contour by the last used strokeWIdth. A future improvement must be,
	when building the contour in the engine, for each point recorded, also record
	the amout it must be dilated by, i.e. the current strokeWidth at that moment.
	See #morphContourAfterDrawUpdate:oldTop:oldBottom:into:
	See #morphContourAfterDrawInterectInto:
	"

	| morphContour i requiredSize y0 y1 dilationHalfHeight strokeHalfSquared |
	y0 := morphBoundsTop max: 0.
	y1 := morphBoundsBottom min: targetHeight -1.
	requiredSize := (y1 - y0 + 1) *  2 max: 0.
	morphContour := contourArrayOrNil.
	(morphContour isNil or: [ requiredSize > morphContour size ]) ifTrue: [
		morphContour := IntegerArray new: requiredSize ].
	dilationHalfHeight := (strokeWidth / 2.0) rounded.
	strokeHalfSquared := (strokeWidth / 2.0) squared.
	i := 1.
	y0 to: y1 do: [ :y | | x0 x1 |
		x0 := targetWidth.
		x1 := 0.
		dilationHalfHeight negated to: dilationHalfHeight do: [ :dy | | dx |
			(y + dy between: y0 and: y1) ifTrue: [
				dx := (strokeHalfSquared - dy squared max: 0) sqrt.
				x0 := x0 min: ((contour at: y+dy * 2 + 1) - dx) rounded.
				x1 := x1 max: ((contour at: y+dy * 2 + 2) + dx) rounded ]].
		morphContour at: i put: x0.
		morphContour at: i+1 put: x1.
		i := i + 2 ].
	i to: morphContour size by: 2 do: [ :ii |
		morphContour at: ii put: targetWidth.
		morphContour at: ii+1 put: 0 ].
	aBlock value: morphContour value: y0 value: y1.! !
!VectorEngineDrawer methodsFor: 'accessing' stamp: 'jmv 3/6/2025 17:34:50' prior: 17001666!
              morphContourAfterDrawUpdate: oldContour oldTop: oldTop oldBottom: oldBottom into: aBlock
	"In targetForm coordinates.
	Doesn't account for any clipping at all.
	Doesn't include any protruding submorphs.
	Only valid _after_ drawing currentMorph.
	Dilates contour by the last used strokeWIdth. A future improvement must be,
	when building the contour in the engine, for each point recorded, also record
	the amout it must be dilated by, i.e. the current strokeWidth at that moment.
	See #morphContourAfterDrawInto:into:
	See #morphContourAfterDrawInterectInto:
	"

	| morphContour i ii requiredSize oldContourDelta y0 y1 dilationHalfHeight strokeHalfSquared mbb mbt |
	y0 := (morphBoundsTop min: oldTop) max: 0.
	y1 := (morphBoundsBottom max: oldBottom) min: targetHeight -1.
	requiredSize := (y1 - y0 + 1) *  2.
	morphContour := oldContour.
	oldContourDelta := 0.
	(morphContour size < requiredSize or: [y0 < oldTop] ) ifTrue: [
		oldContourDelta := (oldTop - y0) * 2.
		morphContour := IntegerArray new: requiredSize ].
	dilationHalfHeight := (strokeWidth / 2.0) rounded.
	strokeHalfSquared := (strokeWidth / 2.0) squared.
	i := 1.
	ii := 1-oldContourDelta.
	mbt := morphBoundsTop max: 0.
	mbb := morphBoundsBottom min: targetHeight -1.
	y0 to: y1 do: [ :y | | x0 x1 |
		(ii between: 1 and: oldContour size-1) ifTrue: [
			x0 := oldContour at: ii.
			x1 := oldContour at: ii+1 ]
		ifFalse: [
			x0 := targetWidth.
			x1 := 0 ].
		dilationHalfHeight negated to: dilationHalfHeight do: [ :dy | | dx |
			(y+dy between: mbt and: mbb) ifTrue: [
				dx := (strokeHalfSquared - dy squared max: 0) sqrt.
				x0 := x0 min: ((contour at: y+dy * 2 + 1) - dx) rounded.
				x1 := x1 max: ((contour at: y+dy * 2 + 2) + dx) rounded ]].
		morphContour at: i put: x0.
		morphContour at: i+1 put: x1.
		i := i + 2.
		ii := ii + 2 ].
	i to: morphContour size by: 2 do: [ :iii |
		morphContour at: iii put: targetWidth.
		morphContour at: iii+1 put: 0 ].
	aBlock value: morphContour value: y0 value: y1.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7075-ContourUpdate-JuanVuletich-2025Mar07-10h02m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #7067] on 11 March 2025 at 12:18:33 pm'!
!BoundsFinderCanvas methodsFor: 'morphic' stamp: 'jmv 3/7/2025 10:58:53' prior: 16796008 overrides: 16909601!
          drawCurrentAndSubmorphs
	| current |
	currentMorph visible ifFalse: [ ^self ].

	currentMorph drawOn: self.
	self displayBoundsSetOnCurrentMorph.

	"Display submorphs back to front"
	"coordinate system stack already set up for aMorph
	('ivars transformations' and 'currentTransformation')
	Hold currentMorph in a temp in case of breakage in recursive calls on submorphs."
	current := currentMorph.
	currentMorph hasSubmorphs ifTrue: [
		self clippingByCurrentMorphDo: [
			currentMorph submorphsReverseDo: [ :m | self fullDraw: m ]]].

	(current postDrawOn: self) ifTrue: [
		self displayBoundsUpdateOnCurrentMorph ].

	current isHighlighted ifTrue: [
		self drawHighlight: current ].! !
!VectorCanvas methodsFor: 'morphic' stamp: 'jmv 3/7/2025 11:00:26' prior: 16999734 overrides: 16909601!
        drawCurrentAndSubmorphs

	| currentNeedsDrawing submorphsNeedDrawing current |
	currentMorph visible ifFalse: [ ^self ].
	currentNeedsDrawing := true.
	submorphsNeedDrawing := currentMorph hasSubmorphs.
	clipRect notNil ifTrue: [
		self boundingRectOfCurrentIfTrivial ifNotNil: [ :mb |
			(mb intersects: clipRect) ifFalse: [
				currentNeedsDrawing := false.
				currentMorph submorphsMightProtrude ifFalse: [
					submorphsNeedDrawing := false ]]]].

	currentNeedsDrawing ifTrue: [
		currentMorph drawOn: self.
		self displayBoundsSetOnCurrentMorph.
		self contourSetOnCurrentMorph.
		self contourUpdateOnAllOwners ].

	"Hold currentMorph in a temp in case of breakage in recursive calls on submorphs."
	current := currentMorph.
	submorphsNeedDrawing ifTrue: [
		"Display submorphs back to front"
		"coordinate system stack already set up for aMorph
		('ivars transformations' and 'currentTransformation')"
		self clippingByCurrentMorphDo: [
			currentMorph submorphsReverseDo: [ :m | self fullDraw: m ]]].

	currentNeedsDrawing ifTrue: [
		(current postDrawOn: self) ifTrue: [
			self displayBoundsUpdateOnCurrentMorph.
			self contourUpdateOnCurrentMorph.
			self contourUpdateOnAllOwners ].
		current isHighlighted ifTrue: [
			self drawHighlight: current ]].! !
!BitBltCanvas methodsFor: 'morphic' stamp: 'jmv 3/7/2025 11:00:33' prior: 16791847 overrides: 16909601!
    drawCurrentAndSubmorphs

	| currentNeedsDrawing submorphsNeedDrawing current |
	currentMorph visible ifFalse: [ ^self ].
	currentNeedsDrawing := true.
	submorphsNeedDrawing := currentMorph hasSubmorphs.
	clipRect notNil ifTrue: [
		self boundingRectOfCurrentIfTrivial ifNotNil: [ :mb |
			(mb intersects: clipRect) ifFalse: [
				currentNeedsDrawing := false.
				currentMorph submorphsMightProtrude ifFalse: [
					submorphsNeedDrawing := false ]]]].

	currentNeedsDrawing ifTrue: [
		currentMorph drawOn: self.
		self displayBoundsSetOnCurrentMorph.
		self contourClearOnCurrentMorph ].

	"Hold currentMorph in a temp in case of breakage in recursive calls on submorphs."
	current := currentMorph.
	submorphsNeedDrawing ifTrue: [
		"Display submorphs back to front"
		"coordinate system stack already set up for aMorph
		('ivars transformations' and 'currentTransformation')"
		self clippingByCurrentMorphDo: [
			currentMorph submorphsReverseDo: [ :m | self fullDraw: m ]]].

	currentNeedsDrawing ifTrue: [
		(current postDrawOn: self) ifTrue: [
			self displayBoundsUpdateOnCurrentMorph ].
		current isHighlighted ifTrue: [
			self drawHighlight: current ]].! !
!HybridCanvas methodsFor: 'morphic' stamp: 'jmv 3/7/2025 11:01:31' prior: 16876347 overrides: 50362109!
          drawCurrentAndSubmorphs
	"If we get here, we are drawing with BitBlt, not VectorCanvas.
	Clear morphIds of pixels drawn for currentMorph"

	| currentNeedsDrawing submorphsNeedDrawing current |
	currentMorph visible ifFalse: [ ^self ].
	currentNeedsDrawing := true.
	submorphsNeedDrawing := currentMorph hasSubmorphs.
	clipRect notNil ifTrue: [
		self boundingRectOfCurrentIfTrivial ifNotNil: [ :mb |
			(mb intersects: clipRect) ifFalse: [
				currentNeedsDrawing := false.
				currentMorph submorphsMightProtrude ifFalse: [
					submorphsNeedDrawing := false ]]]].

	currentNeedsDrawing ifTrue: [
		currentMorph drawOn: self.
		self onMorphIdsDo: [
			currentMorph drawOn: self ].
		self displayBoundsSetOnCurrentMorph.
		self contourClearOnCurrentMorph ].

	"Hold currentMorph in a temp in case of breakage in recursive calls on submorphs."
	current := currentMorph.
	submorphsNeedDrawing ifTrue: [
		"Display submorphs back to front"
		"coordinate system stack already set up for aMorph
		('ivars transformations' and 'currentTransformation')"
		self clippingByCurrentMorphDo: [
			currentMorph submorphsReverseDo: [ :m | self fullDraw: m ]]].

	currentNeedsDrawing ifTrue: [
		(current postDrawOn: self) ifTrue: [
			self onMorphIdsDo: [
				current postDrawOn: self ].
			self displayBoundsUpdateOnCurrentMorph ].
		current isHighlighted ifTrue: [
			self drawHighlight: current ]].! !
!VectorEngine class methodsFor: 'instance creation' stamp: 'jmv 3/6/2025 15:43:47' prior: 17001244!
             onForm: aForm subPixelAntiAliasing: aBoolean
	"nil means use default kind of anti aliasing
	Use the VectorEnginePlugin if available."

	| engineClass doSubPixelAntiAliasing |
	self hasSubclasses
		ifFalse: [
			engineClass := self ]
		ifTrue: [
			doSubPixelAntiAliasing := aBoolean ifNil: [
				"Assume high resolution implies high DPI"
				Display width <= 1920 ].
			engineClass := VectorEngineWithPlugin isPluginAvailable
				ifTrue: [ doSubPixelAntiAliasing
					ifTrue: [VectorEngineWithPluginSubPixel]
					ifFalse: [VectorEngineWithPluginWholePixel]]
				ifFalse: [ doSubPixelAntiAliasing
					ifTrue: [VectorEngineSubPixel]
					ifFalse: [VectorEngineWholePixel]]].
		^engineClass new initializeOnForm: aForm.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7076-SubmorphDrawingTweaks-JuanVuletich-2025Mar11-12h07m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7070] on 11 March 2025 at 3:41:27 pm'!
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 3/11/2025 15:20:20' prior: 16999374 overrides: 16909119!
 image: srcForm at: aPoint
	"Workaround using WarpBlt until properly implemented in VectorEngine.
	 (WarpBlt might not give desired result, i.e. a properly filtered and resamples image)

	In the general case, use WarpBlt to apply currentTransformation.
	Prior to that, set morphIds for affected pixels, and update bounds in engine.
	This is expensive!!

	If No scaling and no rotation, use BitBlt instead (way faster). This is useful, for instance, for halo handles.
	We expect to replace them with vector graphics icons, anyway.

	But if drawing the world background, finding bounds is not needed. Use two BitBlts then:
	One to paint pixels, and a second one to set morphIds.
	In this way, performance is same as in HybridCanvas, and not too different from BitBltCanvas.
	This is especially important, the default World background is a Form!!"

	| p bits |

	"Special case for our world:
	- No bounds needed
	- currentTransformation is identity: No translation, no rotation, no scaling.
	BitBlt is enough, but we need two of them!!"
	(world notNil and: [currentMorph == world]) ifTrue: [
		p := (currentTransformation transform: aPoint) roundedHAFZ.
		auxBitBltEngine
			sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
			colorMap: (srcForm colormapIfNeededFor: form);
			clipRect: clipRect;
			sourceX: 0; sourceY: 0;
			destX: p x destY: p y width: srcForm width height: srcForm height;
			copyBits.
		bits := form bits.
		[
			form bits: engine morphIds.
			auxBitBltEngine
				sourceForm: nil;
				fillBitmap: (Bitmap with: (currentMorph morphId <<8 + 255));
				combinationRule: `Form over`;
				colorMap: nil;
				copyBits.
		] ensure: [ form bits: bits ].
		^self ].

	"Otherwise, we need to compute bounds. While we are at it, set morphID for affected pixels."
	self fillRectangle: (srcForm boundingBox translatedBy: aPoint) color: `Color gray alpha: 0.01`.
	currentTransformation isPureTranslation
		ifTrue: [
			p := (currentTransformation transform: aPoint) roundedHAFZ.
			auxBitBltEngine
				sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				sourceX: 0; sourceY: 0;
				destX: p x destY: p y width: srcForm width height: srcForm height;
				copyBits ]
		ifFalse: [
			| bb cellSize dstBox srcBox srcQuad |
			cellSize := 4.
			srcBox := srcForm boundingBox.
			dstBox := (currentTransformation externalBoundingRectOf: srcBox)
				encompassingIntegerRectangle.
			srcQuad := dstBox corners collect: [ :pt | (currentTransformation inverseTransform: pt) roundedHAFZ ].
			dstBox := (srcBox translatedBy: aPoint).
			dstBox := dstBox origin extent: dstBox extent + 1.1.
			dstBox := ((currentTransformation externalBoundingRectOf: dstBox))
				encompassingIntegerRectangle.
			bb := WarpBlt toForm: form.
			bb
				sourceForm: srcForm; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				cellSize: cellSize;
				copyQuad: srcQuad toRect: dstBox ].! !
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 3/11/2025 15:20:27' prior: 16999472!
                             image: srcForm at: aPoint sourceRect: sourceRect
	"Workaround using WarpBlt until properly implemented in VectorEngine.
	 (WarpBlt might not give desired result, i.e. a properly filtered and resamples image)

	In the general case, use WarpBlt to apply currentTransformation.
	Prior to that, set morphIds for affected pixels, and update bounds in engine.
	This is expensive!!

	If No scaling and no rotation, use BitBlt instead (way faster). This is useful, for instance, for halo handles.
	We expect to replace them with vector graphics icons, anyway.

	But if drawing the world background, finding bounds is not needed. Use two BitBlts then:
	One to paint pixels, and a second one to set morphIds.
	In this way, performance is same as in HybridCanvas, and not too different from BitBltCanvas.
	This is especially important, the default World background is a Form!!"

	| p bits |

	"Special case for our world:
	- No bounds needed
	- currentTransformation is identity: No translation, no rotation, no scaling.
	BitBlt is enough, but we need two of them!!"
	currentMorph == world ifTrue: [
		p := (currentTransformation transform: aPoint) roundedHAFZ.
		auxBitBltEngine
			sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
			colorMap: (srcForm colormapIfNeededFor: form);
			clipRect: clipRect;
			sourceX: sourceRect left; sourceY: sourceRect top;
			destX: p x destY: p y width: sourceRect width height: sourceRect height;
			copyBits.
		bits := form bits.
		[
			form bits: engine morphIds.
			auxBitBltEngine
				sourceForm: nil;
				fillBitmap: (Bitmap with: (currentMorph morphId <<8 + 255));
				combinationRule: `Form over`;
				colorMap: nil;
				copyBits.
		] ensure: [ form bits: bits ].
		^self ].

	"Otherwise, we need to compute bounds. While we are at it, set morphID for affected pixels."
	self fillRectangle: (sourceRect translatedBy: aPoint) color: `Color gray alpha: 0.01`.
	currentTransformation isPureTranslation
		ifTrue: [
			p := (currentTransformation transform: aPoint) roundedHAFZ.
			auxBitBltEngine
				sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				sourceX: sourceRect left; sourceY: sourceRect top;
				destX: p x destY: p y width: sourceRect width height: sourceRect height;
				copyBits ]
		ifFalse: [
			| bb cellSize dstBox srcBox srcQuad |
			cellSize := 4.
			srcBox := sourceRect.
			dstBox := (currentTransformation externalBoundingRectOf: srcBox)
				encompassingIntegerRectangle.
			srcQuad := dstBox corners collect: [ :pt | (currentTransformation inverseTransform: pt) roundedHAFZ ].
			dstBox := (currentTransformation externalBoundingRectOf: (srcBox translatedBy: aPoint-0.5))
				encompassingIntegerRectangle.
			bb := WarpBlt toForm: form.
			bb
				sourceForm: srcForm; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				cellSize: cellSize;
				copyQuad: srcQuad toRect: dstBox ].! !
!VectorEngineDrawer methodsFor: 'private' stamp: 'jmv 3/11/2025 15:19:47' prior: 17001758!
          morphIdAt: aPoint
	| index |
	index := aPoint y * targetWidth + aPoint x + 1.
	(index between: 1 and: morphIds size) ifFalse: [ ^0 ].
	^(morphIds at: index) >>8! !
!VectorEngineSmalltalk methodsFor: 'accessing' stamp: 'jmv 3/11/2025 15:20:38' prior: 17002086 overrides: 17001578!
        clipCurrentMorph: aBoolean
	(clipCurrentMorph and: [ aBoolean not ]) ifTrue: [
		| pixelIndex |
		clipTop to: clipBottom do: [ :displayY |
			pixelIndex := displayY * targetWidth + clipLeft.
			clipLeft to: clipRight do: [ :displayX |
				pixelIndex := pixelIndex + 1.
				morphIds at: pixelIndex put: ((morphIds at: pixelIndex) >>8 <<8) ]]].
	clipCurrentMorph := aBoolean.! !
!VectorEngineSmalltalk methodsFor: 'primitive algorithms - aux' stamp: 'jmv 3/7/2025 15:00:32' prior: 17002352!
                       updateContourForX: x y: y
	"The Contour of the current morph is the pixel area affected, but without holes.
	For each y line where a pixel is affected, record the leftmost and rightmost affected pixels.
	Note: Only includes pen trajectory, but not stroke width. Ignores any clipping."

	| thisYRounded |
	thisYRounded := y rounded.
	(thisYRounded between: 0 and: targetHeight-1) ifTrue: [
		thisYRounded = prevYRounded ifFalse: [
			prevYRounded = 16r3FFFFFFF ifFalse: [
				contour at: prevYRounded * 2 + 1 put: leftAtThisY.
				contour at: prevYRounded * 2 + 2 put: rightAtThisY ].
			leftAtThisY := contour at: thisYRounded * 2 + 1.
			rightAtThisY := contour at: thisYRounded * 2 + 2.
			prevYRounded := thisYRounded ].
		leftAtThisY := leftAtThisY min: x.
		rightAtThisY := rightAtThisY max: x ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7077-MorphicTweaks-JuanVuletich-2025Mar11-15h41m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7069] on 11 March 2025 at 2:54:27 pm'!
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/11/2025 11:41:34' prior: 17003622 overrides: 17002504!
                   blendFillOnly
	"Blends fill color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixel edgesThisPixel pixelIndex antiAliasAlphaBits |
	spanTop to: spanBottom do: [ :displayY |
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			edgesThisPixel := edgeCounts at: pixelIndex.
			edgesThisPixel = 0 ifFalse: [
				edgeCounts at: pixelIndex put: 0.
				"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
				edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
				edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
			antiAliasAlphaBits := alphaMask at: pixelIndex.
			antiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ].
			edgesUpToThisPixel = 0
				ifFalse: [		"Inside the shape. Turn stroke anti aliasing into fill anti aliasing."
					antiAliasAlphaBits := 127 - antiAliasAlphaBits.
					self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: antiAliasAlphaBits ]
				ifTrue: [		"Still in the anti aliasing area, but outside the shape, strictly speaking."
					antiAliasAlphaBits = 0 ifFalse: [
						self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: antiAliasAlphaBits ]]]].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/11/2025 10:26:18' prior: 17003731 overrides: 17002509!
                               blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixel edgesThisPixel pixelIndex antiAliasAlphaBits |
	spanTop to: spanBottom do: [ :displayY |
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			edgesThisPixel := edgeCounts at: pixelIndex.
			edgesThisPixel = 0 ifFalse: [
				edgeCounts at: pixelIndex put: 0.
				"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
				edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
				edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
			antiAliasAlphaBits := alphaMask at: pixelIndex.
			antiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ].
			edgesUpToThisPixel = 0
				ifFalse: [			"Inside the shape"
					self blendStrokeAndFillAt: pixelIndex isInside: true antiAliasAlphaByte: antiAliasAlphaBits ]
				ifTrue: [			"Still in the stroke, but outside the shape, strictly speaking."
					antiAliasAlphaBits = 0 ifFalse: [
						self blendStrokeAndFillAt: pixelIndex isInside: false antiAliasAlphaByte: antiAliasAlphaBits ]]]].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/11/2025 14:51:14' prior: 17003870 overrides: 17002514!
                              blendStrokeOnly
	"Blends stroke color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex antiAliasAlphaBits |
	spanTop to: spanBottom do: [ :displayY |
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			antiAliasAlphaBits := alphaMask at: pixelIndex.
			antiAliasAlphaBits = 0 ifFalse: [						"In the stroke"
				alphaMask at: pixelIndex put: 0.
				self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: antiAliasAlphaBits ]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7078-MorphicTweaks-JuanVuletich-2025Mar11-14h44m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7071] on 11 March 2025 at 3:56:39 pm'!
!VectorEngineDrawer methodsFor: 'private' stamp: 'jmv 3/10/2025 10:45:16' prior: 17001766!
                      pvtSetForm: aForm

	| s |
	targetForm := aForm.
	targetWidth := targetForm width.
	targetHeight := targetForm height.
	s := targetWidth * targetHeight.
	morphIds := WordArray new: s.
	edgeCounts := self auxPixelDataClass new: s.
	alphaMask := self auxPixelDataClass new: s.
	contour := Float32Array new: targetHeight * 2.
	0 to: targetHeight-1 do: [ :y |
		contour at: y * 2 + 1 put: targetWidth.
		contour at: y * 2 + 2 put: 0 ].
	self resetMorphBounds.
	self clipRect: targetForm boundingBox.
	self antiAliasingWidth: self class defaultAntiAliasingWidth.
	geometryTransformation := MorphicTranslation identity.! !
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 3/11/2025 15:56:19' prior: 17004402!
                    primResetContourTop: t bottom: b contour: aFloat32Array
	<primitive: 'primReset2Contour' module: 'VectorEnginePlugin'>
	self primitiveFailed.! !
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 3/11/2025 15:56:23' prior: 17004483!
           primUpdateContourLastLine: aFloat32Array
	<primitive: 'primUpdate2ContourLastLine' module: 'VectorEnginePlugin'>
	self primitiveFailed.! !
!VectorEngineWithPlugin class methodsFor: 'instance creation' stamp: 'jmv 3/11/2025 15:55:49' prior: 17004706!
      isPluginAvailable
	"
	VectorEngineWithPlugin isPluginAvailable
	Check if services provided by VM plugin match this class requirements.
	"
	| pluginApiVersion |
	pluginApiVersion := self pluginApiVersion.
	^ pluginApiVersion = 6! !

VectorEngineWithPlugin removeSelector: #primUpdateContourLastLine!

!methodRemoval: VectorEngineWithPlugin #primUpdateContourLastLine stamp: 'Install-7079-Morphic-Cleanup-JuanVuletich-2025Mar11-15h54m-jmv.001.cs.st 5/13/2025 17:35:46'!
primUpdateContourLastLine
	"Only for compatibility with VMs including plugin API v5"
	<primitive: 'primUpdateContourLastLine' module: 'VectorEnginePlugin'>

	self primitiveFailed.
	self flag: #VEPapi5.		"Eventually delete this method"!

VectorEngineWithPlugin removeSelector: #primResetContourTop:bottom:!

!methodRemoval: VectorEngineWithPlugin #primResetContourTop:bottom: stamp: 'Install-7079-Morphic-Cleanup-JuanVuletich-2025Mar11-15h54m-jmv.001.cs.st 5/13/2025 17:35:46'!
primResetContourTop: t bottom: b
	"Only for compatibility with VMs including plugin API v5"
	<primitive: 'primResetContour' module: 'VectorEnginePlugin'>

	self primitiveFailed.
	self flag: #VEPapi5.		"Eventually delete this method"!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7079-Morphic-Cleanup-JuanVuletich-2025Mar11-15h54m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7079] on 19 March 2025 at 10:55:27 am'!
!Debugger methodsFor: 'initialization' stamp: 'FJG 2/22/2025 18:35:24'!
                       isOnBreakpointMethod
	"Tells whether the selected method is a halt method, like #halt or #haltOnce"

	^ self selectedContext method selector beginsWith: 'halt'! !
!Debugger methodsFor: 'initialization' stamp: 'FJG 2/22/2025 18:37:03'!
                     stepOutBreakpointMethods

	^ [self isOnBreakpointMethod ]
		whileTrue: [ self send. self down ]! !
!Debugger methodsFor: 'initialization' stamp: 'FJG 2/22/2025 18:37:03' prior: 16843641!
     openFullMorphicLabel: aLabelString
	"Open a full morphic debugger with the given label"

	| oldContextStackIndex |
	oldContextStackIndex := contextStackIndex.
	self expandStack. "Sets contextStackIndex to zero."

	DebuggerWindow open: self label: aLabelString.
	self toggleContextStackIndex: oldContextStackIndex.

	self stepOutBreakpointMethods.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7080-stepOutBreakpointMethods-FacundoJavierGelatti-2025Mar19-10h52m-FJG.001.cs.st----!

'From Cuis7.3 [latest update: #7080] on 19 March 2025 at 11:13:48 am'!
!Collection methodsFor: 'enumerating' stamp: 'Ez3 3/7/2025 15:16:02'!
     reject: rejectBlock thenCollect: collectBlock

	^self select: [ :each | (rejectBlock value: each) not ] thenCollect: collectBlock! !
!Collection methodsFor: 'enumerating' stamp: 'Ez3 3/7/2025 15:31:41'!
                     reject: rejectBlock thenDo: doBlock

	self do: [ :each | (rejectBlock value: each) ifFalse: [ doBlock value: each ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7081-twoNewEnumerationMethods-EzequielBirman-2025Mar19-11h09m-Ez3.001.cs.st----!

'From Cuis7.3 [latest update: #7081] on 19 March 2025 at 12:22:05 pm'!
!SystemWindow methodsFor: 'submorphs-menus' stamp: 'jmv 3/19/2025 12:10:55'!
          allRegisteredMenuAndShortcutsSpecProviders: widgetKey do: aBlock widget: aWidget
	"Hierarchy order allows more specific classes to override choices made by superclasses."
	(self class withAllSuperclassesDownFrom: (self menuAndShortcutRegistryRoot: widgetKey)) do:
		[ :windowClass |
			(windowClass registeredMenuAndShortcutsSpecProviders: widgetKey) ifNotNil: [ :providers |
				providers do:
					[ :eachMessageSend |
						(eachMessageSend valueWithPossibleArgument: aWidget) do: aBlock ]]].! !
!SystemWindow methodsFor: 'submorphs-menus' stamp: 'jmv 3/19/2025 12:06:18'!
 menuAndShortcutRegistryRoot: widgetKey
	"Answer the topmost class whose menu and shortcut registry we honor.
	It is SystemWindow by default.
	But classes redefining menus may want to ignore providers registered assuming menus that they redefine.
	See inheritance."
	^SystemWindow! !
!CodeFileBrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 3/19/2025 12:15:40' overrides: 50362775!
                      menuAndShortcutRegistryRoot: widgetKey
	"Answer the topmost class whose menu and shortcut registry we honor.
	It is SystemWindow by default.
	But classes redefining menus may want to ignore providers registered assuming menus that they redefine.
	See inheritance."
	(#(classListMenuSpec messageCatListMenuSpec messageListMenuSpec) pointsTo: widgetKey)
		ifTrue: [ ^CodeFileBrowserWindow ].
	^super menuAndShortcutRegistryRoot: widgetKey! !
!EntryFieldMorph methodsFor: 'menu - shortcuts' stamp: 'jmv 3/19/2025 11:58:09' prior: 16855683 overrides: 16908457!
                   menuNshortcutsSpecsDo: aBlock
	"Iterate over our own menu and shortcut specs.
	Subclasses may implement specific ways of providing menu items and
	keyboard shortcuts for themselves.
	See implementors."

	"First take default editor menu and shortcut specs"
	self editor defaultMenuSpec do: aBlock.

	self window ifNotNil: [ :myWindow |

		"Then include additions, overrides and deletions registered for #Editor, #TextEditor, #SmalltalkEditor, etc.
		Hierarchy order allows more specific classes to override choices made by superclasses."
		(self editor class withAllSuperclassesDownFrom: Editor) do: [ :editorClass |
			myWindow allRegisteredMenuAndShortcutsSpecProviders: editorClass name do: aBlock widget: self ]].! !
!SystemWindow methodsFor: 'submorphs-menus' stamp: 'jmv 3/19/2025 12:15:04' prior: 16973227 overrides: 16908466!
                               menuNshortcutsSpecsFor: aWidget do: aBlock
	"aWidget is a submorph, or submorph of a submorph, etc.
	Subclasses may implement specific ways of providing menu items and
	keyboard shortcuts for their submorphs."

	aWidget menuNshortcutsKey ifNotNil: [ :widgetKey |
		(widgetKey numArgs = 0
			ifTrue: [self perform: widgetKey]
			ifFalse: [self perform: widgetKey with: aWidget]) do: aBlock.
		self allRegisteredMenuAndShortcutsSpecProviders: widgetKey do: aBlock widget: aWidget ].! !
!InnerTextMorph methodsFor: 'menu' stamp: 'jmv 3/19/2025 12:20:19' prior: 16882383 overrides: 16908457!
                    menuNshortcutsSpecsDo: aBlock
	"Iterate over our own menu and shortcut specs.
	Subclasses may implement specific ways of providing menu items and
	keyboard shortcuts for themselves.
	See implementors."

	"First take default editor menu and shortcut specs"
	self editor defaultMenuSpec do: aBlock.

	self window ifNotNil: [ :myWindow |

		"Then include additions, overrides and deletions registered for #Editor, #TextEditor, #SmalltalkEditor, etc.
		Hierarchy order allows more specific classes to override choices made by superclasses."
		(self editor class withAllSuperclassesDownFrom: Editor) do: [ :editorClass |
			myWindow allRegisteredMenuAndShortcutsSpecProviders: editorClass name do: aBlock widget: self ].

		"Also allow registering menu+shortcut entries for specific TextModels or TextProviders"
		myWindow
			allRegisteredMenuAndShortcutsSpecProviders: self
			textProviderOrModel class name
			do: aBlock
			widget: self ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7082-CodeFileBrowser-skipBroserMenuExtensions-JuanVuletich-2025Mar19-12h16m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7081] on 19 March 2025 at 12:22:50 pm'!
!SystemDictionary methodsFor: 'ui' stamp: 'jmv 3/19/2025 11:53:47' prior: 16968635!
 confirmRemovalOf: aSelector on: aClass andSubclasses: aBoolean
	"Determine if it is okay to remove the given selector. Answer 1 if it  
	should be removed, 2 if it should be removed followed by a senders  
	browse, and 3 if it should not be removed."
	| count aMenu labels answer caption allCalls |
	allCalls := self allCallsOn: aSelector.
	(count := allCalls size) = 0
		ifTrue: [^ 1].
	"no senders -- let the removal happen without warning"
	count = 1
		ifTrue: [(allCalls first actualClass == aClass
					and: [allCalls first methodSymbol == aSelector])
				ifTrue: [^ 1]].
	"only sender is itself"
	labels := aBoolean
		ifTrue: [
'Remove from ', aClass name, ' and subclasses
Remove them, then browse senders
Don''t remove, but show me those senders
Forget it -- do nothing -- sorry I asked']
		ifFalse: [
'Remove it
Remove, then browse senders
Don''t remove, but show me those senders
Forget it -- do nothing -- sorry I asked'].
	aMenu := PopUpMenu labels: labels
		icons: #(acceptIcon acceptIcon cancelIcon cancelIcon).

	caption := 'This message has ' , count printString , ' sender'.
	count > 1
		ifTrue: [caption := caption copyWith: $s].
	answer := aMenu startUpWithCaption: caption.
	answer = 3
		ifTrue: [
			self
				browseMessageList: allCalls
				name: 'Senders of ' , aSelector
				autoHighlight: aSelector asString
				allOccurrences: false ].
	answer = 0
		ifTrue: [answer := 3].
	"If user didn't answer, treat it as cancel"
	^ answer min: 3! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7083-confirmRemovalOfSelector-fix-JuanVuletich-2025Mar19-12h22m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #6959] on 19 March 2025 at 7:11:14 pm'!

Refactoring subclass: #ScopedRefactoring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ScopedRefactoring category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
Refactoring subclass: #ScopedRefactoring
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ScopedRefactoring subclass: #ChangeSelector
	instanceVariableNames: 'oldSelector newSelector implementors senders changes '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelector category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
ScopedRefactoring subclass: #ChangeSelector
	instanceVariableNames: 'oldSelector newSelector implementors senders changes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ScopedRefactoring subclass: #ExtractAsParameter
	instanceVariableNames: 'sourceMethod addParameter intervals '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractAsParameter category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
ScopedRefactoring subclass: #ExtractAsParameter
	instanceVariableNames: 'sourceMethod addParameter intervals'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ScopedRefactoring subclass: #InlineMethod
	instanceVariableNames: 'methodToInline messageSendsToInline updatedSendersCode methodNodeToInline replacementsByMessageSend temporariesDeclarationsByNode temporariesToDeclareByInsertionPoint implementorCompleteSourceRanges removeMethod '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethod category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
ScopedRefactoring subclass: #InlineMethod
	instanceVariableNames: 'methodToInline messageSendsToInline updatedSendersCode methodNodeToInline replacementsByMessageSend temporariesDeclarationsByNode temporariesToDeclareByInsertionPoint implementorCompleteSourceRanges removeMethod'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

RefactoringApplier subclass: #ScopedRefactoringApplier
	instanceVariableNames: 'scopeChoice selectedClass'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ScopedRefactoringApplier category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
RefactoringApplier subclass: #ScopedRefactoringApplier
	instanceVariableNames: 'scopeChoice selectedClass'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ScopedRefactoringApplier subclass: #ChangeSelectorApplier
	instanceVariableNames: 'oldSelector implementors senders wizardStepWindow shouldShowChanges browser '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelectorApplier category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
ScopedRefactoringApplier subclass: #ChangeSelectorApplier
	instanceVariableNames: 'oldSelector implementors senders wizardStepWindow shouldShowChanges browser'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ScopedRefactoringApplier subclass: #InlineMethodApplier
	instanceVariableNames: 'selectorToInline implementors messageSends wizardStepWindow shouldShowChanges browser shouldRemoveImplementor triggeringMessageSend shouldInlineTriggeringMessageSendOnly '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodApplier category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
ScopedRefactoringApplier subclass: #InlineMethodApplier
	instanceVariableNames: 'selectorToInline implementors messageSends wizardStepWindow shouldShowChanges browser shouldRemoveImplementor triggeringMessageSend shouldInlineTriggeringMessageSendOnly'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:05:52'!
                               addImplementorsOf: anOldSelector to: implementors andSendersTo: senders forClassAndMetaOf: aPotentialClassToRefactor

	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor theNonMetaClass.
	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor theMetaClass.

! !
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:15:52'!
             addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategoriesAndHierarchyOf: aClass organizedBy: anOrganization

	| categories |

	categories := Set new.

	self
		addImplementorsOf: anOldSelector
		to: implementors
		andSendersTo: senders
		inHierarchyOf: aClass
		doingPerClass: [:aClassInHierarchy | categories add: aClassInHierarchy category ].

	categories do: [:aCategory |
		self
			addImplementorsOf: anOldSelector
			to: implementors
			andSendersTo: senders
			inCategory: aCategory
			organizedBy: anOrganization ].
! !
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:16:13'!
                      addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategory: aCategory organizedBy: anOrganization

	| classesInCategory |

	classesInCategory := anOrganization classesAt: aCategory.
	classesInCategory do: [ :aPotentialClassToRefactor |
		self
			addImplementorsOf: anOldSelector
			to: implementors
			andSendersTo: senders
			forClassAndMetaOf: aPotentialClassToRefactor ].
! !
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:16:24'!
            addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inHierarchyOf: aClass

	self
		addImplementorsOf: anOldSelector
		to: implementors
		andSendersTo: senders
		inHierarchyOf: aClass
		doingPerClass: [ :aClassInHierarchy | ]

	! !
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:15:41'!
    addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inHierarchyOf: aClass doingPerClass: aBlock

	| highestClassImplementingOldSelector |

	highestClassImplementingOldSelector := aClass highestClassImplementing: anOldSelector ifNone: [ aClass ].
	highestClassImplementingOldSelector theNonMetaClass withAllSubclassesDo: [ :aPotentialClassToRefactor |
		aPotentialClassToRefactor isMeta ifFalse: [
			self
				addImplementorsOf: anOldSelector
				to: implementors
				andSendersTo: senders
				forClassAndMetaOf: aPotentialClassToRefactor.
			aBlock value: aPotentialClassToRefactor ]]
	! !
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:16:33'!
                             addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inSystem: aSystem

	aSystem allBehaviorsDo: [ :aPotentialClassToRefactor |
		self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor ].
! !
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:11:50'!
                        addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor

	| potentialImplementor |

	"Phil B. requested to avoid refactoring OMeta2 classes, so right now
	it avoids implementors and senders whose compilerClass is not register
	as allowed compiler - Hernan"
	(self canRefactor: aPotentialClassToRefactor) ifFalse: [ ^self ].

	potentialImplementor := aPotentialClassToRefactor compiledMethodAt: anOldSelector ifAbsent: [ nil ].
	potentialImplementor ifNotNil: [ implementors add: potentialImplementor ].

	(aPotentialClassToRefactor whichSelectorsReferTo: anOldSelector) do: [ :aSelector |
		self addTo: senders referencesTo: anOldSelector from: aSelector in: aPotentialClassToRefactor ]! !
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:12:20'!
                               addTo: senders referencesTo: anOldSelector from: aSelector in: aPotentialClassToRefactor

	senders add: (MethodReference class: aPotentialClassToRefactor selector: aSelector)! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:17:42' overrides: 50363216!
                              addTo: senders referencesTo: aSelectorToInline from: aSelector in: aPotentialClassToRefactor

	| methodReference references |

	methodReference := MethodReference class: aPotentialClassToRefactor selector: aSelector.
	references := self findReferencesToSelector: aSelectorToInline in: methodReference.

	senders addAll: references! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 12:26:24'!
        askScope

	| scopeMenu |

	scopeMenu := PopUpMenu labelArray: self scopeOptionLabels.
	scopeChoice := scopeMenu startUpWithCaption: 'Select Refactoring Scope'.
	scopeChoice = 0 ifTrue: [ self endRequest ].
	! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 19:05:37'!
   basicCalculateImplementorsAndSenders

  "Do not inline/rename/remove. Used by LiveTyping - Hernan"

	scopeChoice = 1 ifTrue: [ ^self implementorsAndSendersForClass ].
	scopeChoice = 2 ifTrue: [ ^self implementorsAndSendersForHierarchy ].
	scopeChoice = 3 ifTrue: [ ^self implementorsAndSendersInCategory ].
	scopeChoice = 4 ifTrue: [ ^self implementorsAndSendersInCategoryAndHierarchy ].
	scopeChoice = 5 ifTrue: [ ^self implementorsAndSendersInSystem ].

	self error: 'Unknown scope option'

		! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 19:07:49'!
   basicScopeOptionLabels

	"Do not inline/rename/remove. Used by LiveTyping - Hernan"

	^`{'In Class'. 'In Hierarchy'. 'In Root Class Category Tree'. 'In Hierarchy and its Categories'. 'In System'}`! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 19:06:10'!
              calculateImplementorsAndSenders

	"Do not inline this message send, #basicCalculateImplementorsAndSenders
	is used in live typing - Hernan"
	self basicCalculateImplementorsAndSenders
		! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 15:32:27'!
                         collectionToAddSendersTo

	self subclassResponsibility! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 15:32:45'!
                            collectionToAddimplementorsTo

	self subclassResponsibility! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 13:14:49'!
                       implementorsAndSendersForClass

	^self refactoringClass
		addImplementorsOf: self selectorToLookImplementorsFor
		to: self collectionToAddimplementorsTo
		andSendersTo: self collectionToAddSendersTo
		forClassAndMetaOf: selectedClass! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 13:15:05'!
         implementorsAndSendersForHierarchy

	^self refactoringClass
		addImplementorsOf: self selectorToLookImplementorsFor
		to: self collectionToAddimplementorsTo
		andSendersTo: self collectionToAddSendersTo
		inHierarchyOf: selectedClass! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 13:15:14'!
         implementorsAndSendersInCategory

	^self refactoringClass
		addImplementorsOf: self selectorToLookImplementorsFor
		to: self collectionToAddimplementorsTo
		andSendersTo: self collectionToAddSendersTo
		inCategory: selectedClass category
		organizedBy: SystemOrganization! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 13:15:23'!
   implementorsAndSendersInCategoryAndHierarchy

	^self refactoringClass
		addImplementorsOf: self selectorToLookImplementorsFor
		to: self collectionToAddimplementorsTo
		andSendersTo: self collectionToAddSendersTo
		inCategoriesAndHierarchyOf: selectedClass
		organizedBy: SystemOrganization ! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 13:15:33'!
               implementorsAndSendersInSystem

	^self refactoringClass
		addImplementorsOf: self selectorToLookImplementorsFor
		to: self collectionToAddimplementorsTo
		andSendersTo: self collectionToAddSendersTo
		inSystem: Smalltalk ! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 19:08:09'!
                     scopeOptionLabels

	"Do not inline #basicScopeOptionLabels it is used by
	live typing - Hernan"
	^self basicScopeOptionLabels ! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 13:09:01'!
                    selectorToLookImplementorsFor

	self subclassResponsibility ! !
!ScopedRefactoringApplier methodsFor: 'refactoring - creation' stamp: 'HAW 3/19/2025 14:01:23'!
refactoringClass

	self subclassResponsibility! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 15:32:27' overrides: 50363289!
                   collectionToAddSendersTo

	^senders! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 15:32:45' overrides: 50363295!
                              collectionToAddimplementorsTo

	^implementors ! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 15:36:43' prior: 16806215!
                       createImplementors

	^IdentitySet new.! !
!ChangeSelectorApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 18:16:56' overrides: 50363367!
                           selectorToLookImplementorsFor

	^oldSelector ! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 15:34:26' overrides: 50363289!
                      collectionToAddSendersTo

	"This is implemented like this so we don't have to duplicate every implementorsAndUsagesInXXX method to
	only calculate implementors or only usages. We always calculate both but if they are not needed they end
	up in this collection that will not be used in the refactoring process - Fernando"

	^self shouldAskForMessageSendsToInline ifTrue: [messageSends] ifFalse: [^Set new].! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 13:12:05' overrides: 50363295!
              collectionToAddimplementorsTo

	"This is implemented like this so we don't have to duplicate every implementorsAndMessageSendsInXXX method to
	only calculate implementors or only usages. We always calculate both but if they are not needed they end
	up in this collection that will not be used in the refactoring process - Fernando"

	^self shouldAskForImplementors ifTrue: [implementors] ifFalse: [^Set new]! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 15:36:43' prior: 16879294!
                createImplementors

	^IdentitySet new.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 13:09:51' overrides: 50363367!
                             selectorToLookImplementorsFor

	^selectorToInline ! !
!InlineMethodApplier methodsFor: 'evaluation' stamp: 'HAW 3/19/2025 18:08:43'!
                           isOnMessageSend

	^triggeringMessageSend isNil not.! !
!ExtractAsParameter class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:18:20' prior: 16857766 overrides: 50363091!
   addImplementorsOf: anOldSelector to: implementors andSendersTo: senders forClassAndMetaOf: aPotentialClassToRefactor

	^self addParameterClass
		addImplementorsOf: anOldSelector
		to: implementors
		andSendersTo: senders
		forClassAndMetaOf: aPotentialClassToRefactor! !
!ExtractAsParameter class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:18:35' prior: 16857778 overrides: 50363106!
           addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategoriesAndHierarchyOf: aClass organizedBy: anOrganization

	^self addParameterClass
		addImplementorsOf: anOldSelector
		to: implementors
		andSendersTo: senders
		inCategoriesAndHierarchyOf: aClass
		organizedBy: anOrganization! !
!ExtractAsParameter class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:18:49' prior: 16857791 overrides: 50363127!
     addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategory: aCategory organizedBy: anOrganization

	^self addParameterClass
		addImplementorsOf: anOldSelector
		to: implementors
		andSendersTo: senders
		inCategory: aCategory
		organizedBy: anOrganization! !
!ExtractAsParameter class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:19:01' prior: 16857803 overrides: 50363143!
                               addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inHierarchyOf: aClass

	^self addParameterClass
		addImplementorsOf: anOldSelector
		to: implementors
		andSendersTo: senders
		inHierarchyOf: aClass
! !
!ExtractAsParameter class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:19:13' prior: 16857813 overrides: 50363177!
                        addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inSystem: aSystem

	^self addParameterClass
		addImplementorsOf: anOldSelector
		to: implementors
		andSendersTo: senders
		inSystem: aSystem
! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 08:59:35' prior: 16879146!
                          convertToSender: aSenderSelector of: aPotentialClassToRefactor referencing: aSelector

	^self
		findReferencesToSelector: aSelector
		in: (MethodReference class: aPotentialClassToRefactor selector: aSenderSelector)! !
!InlineMethod class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:02:04' prior: 16879156!
                          findReferencesToSelector: aSelectorToInline in: aMethodReference

	| references |

	references := Set new.
	aMethodReference notOptimizedMethodNode completeSourceRangesDo: [:aNode :ranges |
		(aNode isMessageNode and: [aNode selector key = aSelectorToInline]) ifTrue: [
			ranges do: [:range  | | referenceToAdd |
				referenceToAdd := MessageNodeReference
					messageNode: aNode
					selector: aMethodReference methodSymbol
					class: aMethodReference methodClass
					completeSourceRange: range.
					references add: referenceToAdd]]].

	^references.

	! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 12:32:21' prior: 16879201!
                          askForImplementorsAndMessageSends

	self
		initializeImplementorsAndMessageSends;
		calculateImplementorsAndSenders;
		openImplementorSelectionWindow.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 12:32:21' prior: 16879210!
                 askForImplementorsOnly

	self
		initializeImplementors;
		calculateImplementorsAndSenders;
		openImplementorSelectionWindow.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 12:32:21' prior: 16879218!
           askForMessagesToInlineOnly

	self
		initializeMessageSends;
		calculateImplementorsAndSenders;
		openMessageSendsSelectionWindow.! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 15:34:26' prior: 16879392!
      initializeMessageSends

	messageSends := self createMessageSends
	! !
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/19/2025 18:08:43' prior: 16879442 overrides: 16938084!
                 requestRefactoringParameters

	self isOnMessageSend ifTrue: [self askIfOnlyTriggeringMessageSendShouldBeInlined].
	self askIfImplementorShouldBeRemoved.! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'HAW 3/19/2025 15:34:26' prior: 16879468!
      messageSendAt: anIndex ifAbsent: ifAbsentBlock

	^messageSends at: anIndex ifAbsent: ifAbsentBlock! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'HAW 3/19/2025 15:34:26' prior: 16879474!
                            messageSends: aCollectionOfMessageSends

	messageSends := aCollectionOfMessageSends reject: [:aMessageNodeReference | aMessageNodeReference isMessageListTitle ]! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'HAW 3/19/2025 15:34:26' prior: 16879482!
                              messageSendsToInline

	^messageSends ! !
!InlineMethodApplier methodsFor: 'accessing' stamp: 'HAW 3/19/2025 15:34:26' prior: 16879486!
                         methodsOfUsagesToInline

	^messageSends collect: [:aMessageNodeReference | aMessageNodeReference methodReference]! !
!InlineMethodApplier methodsFor: 'refactoring - creation' stamp: 'HAW 3/19/2025 15:34:26' prior: 16879551!
createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor

	implementors := Array with: anImplementor.
	messageSends := #().
	shouldShowChanges := false.

	self createAndApplyRefactoring ! !
!InlineMethodApplier methodsFor: 'refactoring - creation' stamp: 'HAW 3/19/2025 15:34:26' prior: 16879561 overrides: 16938066!
                     createRefactoring

	self assert: implementors size = 1.
	^self refactoringClass
		from: (implementors anyOne)
		intoSendersAndUsages: messageSends
		removeMethod: shouldRemoveImplementor

			! !
!InlineMethodApplier methodsFor: 'refactoring - creation' stamp: 'HAW 3/19/2025 15:34:26' prior: 16879574!
                  removeMessageSendsBelongingToImplementor

	messageSends := messageSends reject: [:messageNodeReference |
		messageNodeReference compiledMethod equivalentTo: implementors anyOne
	]
! !
!InlineMethodApplier methodsFor: 'evaluation' stamp: 'HAW 3/19/2025 15:34:26' prior: 16879637 overrides: 16938209!
                     value

	requestExitBlock := [ ^self ].

	self requestRefactoringParametersHandlingRefactoringExceptions.

	self
		ifHasNoUsagesAndOneImplementor: [ :anImplementor |
			shouldRemoveImplementor ifFalse: [self askIfImplementorShouldBeRemovedWhenNoSenders ]. "Give the user another chance to delete the message"
			shouldRemoveImplementor ifFalse: [^self].
			self createAndApplyRefactoringWhenNoSendersAndOneImplementor: anImplementor
		]
		ifNot: [
			self askScope.
			shouldInlineTriggeringMessageSendOnly ifTrue: [
				messageSends := OrderedCollection new.
				messageSends add: triggeringMessageSend.
				^self askForImplementorsOnly
			].
			self shouldAskForImplementors ifFalse: [implementors := IdentitySet with: (selectedClass >> selectorToInline). ^self askForMessagesToInlineOnly].
			self askForImplementorsAndMessageSends.
	]! !

InlineMethodApplier removeSelector: #actualImplementorsAndSendersWhenNotOnMessageSend!

InlineMethodApplier removeSelector: #implementorsAndSendersInCategory!

InlineMethodApplier removeSelector: #implementorsAndMessageSendsInCategoryAndHierarchy!

!methodRemoval: InlineMethodApplier #implementorsAndMessageSendsInCategoryAndHierarchy stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
implementorsAndMessageSendsInCategoryAndHierarchy

	^self refactoringClass
		addImplementorsOf: selectorToInline
		to: self implementorsOrDiscardCollection
		andUsagesTo: self messageSendsOrDiscardCollection
		inCategoriesAndHierarchyOf: selectedClass
		organizedBy: SystemOrganization !

InlineMethodApplier removeSelector: #implementorsAndMessageSendsForHierarchy!

!methodRemoval: InlineMethodApplier #implementorsAndMessageSendsForHierarchy stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
implementorsAndMessageSendsForHierarchy

	^self refactoringClass
		addImplementorsOf: selectorToInline
		to: self implementorsOrDiscardCollection
		andUsagesTo: self messageSendsOrDiscardCollection
		inHierarchyOf: selectedClass!

InlineMethodApplier removeSelector: #implementorsAndSendersInCategoryAndHierarchy!

InlineMethodApplier removeSelector: #canNotRefactorWithoutTypeInfo!

InlineMethodApplier removeSelector: #implementorsAndSendersForClass!

InlineMethodApplier removeSelector: #isActualScopeChoice!

InlineMethodApplier removeSelector: #actualImplementorsAndSendersWhenOnMessageSend!

InlineMethodApplier removeSelector: #refactoringRequestedFromUsage!

!methodRemoval: InlineMethodApplier #refactoringRequestedFromUsage stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
refactoringRequestedFromUsage

	^triggeringMessageSend isNil not.!

InlineMethodApplier removeSelector: #isActualAndPossibleScope!

InlineMethodApplier removeSelector: #messageSendsOrDiscardCollection!

!methodRemoval: InlineMethodApplier #messageSendsOrDiscardCollection stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
messageSendsOrDiscardCollection

	"This is implemented like this so we don't have to duplicate every implementorsAndUsagesInXXX method to
	only calculate implementors or only usages. We always calculate both but if they are not needed they end
	up in this collection that will not be used in the refactoring process - Fernando"

	^self shouldAskForMessageSendsToInline ifTrue: [messageSends] ifFalse: [^Set new].!

InlineMethodApplier removeSelector: #implementorsAndSendersInSystem!

InlineMethodApplier removeSelector: #scopeOptionLabels!

!methodRemoval: InlineMethodApplier #scopeOptionLabels stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
scopeOptionLabels

	^{'In Class'. 'In Hierarchy'. 'In Category'. 'In Hierarchy and its Categories'. 'In System'}.!

InlineMethodApplier removeSelector: #calculateImplementorsAndSenders!

InlineMethodApplier removeSelector: #implementorsOrDiscardCollection!

!methodRemoval: InlineMethodApplier #implementorsOrDiscardCollection stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
implementorsOrDiscardCollection

	"This is implemented like this so we don't have to duplicate every implementorsAndMessageSendsInXXX method to
	only calculate implementors or only usages. We always calculate both but if they are not needed they end
	up in this collection that will not be used in the refactoring process - Fernando"

	^self shouldAskForImplementors ifTrue: [implementors] ifFalse: [^Set new]!

InlineMethodApplier removeSelector: #implementorsAndMessageSendsForClass!

!methodRemoval: InlineMethodApplier #implementorsAndMessageSendsForClass stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
implementorsAndMessageSendsForClass

	^self refactoringClass
		addImplementorsOf: selectorToInline
		to: self implementorsOrDiscardCollection
		andUsagesTo: self messageSendsOrDiscardCollection
		forClassAndMetaOf: selectedClass!

InlineMethodApplier removeSelector: #implementorsAndMessageSendsInSystem!

!methodRemoval: InlineMethodApplier #implementorsAndMessageSendsInSystem stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
implementorsAndMessageSendsInSystem

	^self refactoringClass
		addImplementorsOf: selectorToInline
		to: self implementorsOrDiscardCollection
		andUsagesTo: self messageSendsOrDiscardCollection
		inSystem: Smalltalk !

InlineMethodApplier removeSelector: #implementorsAndMessageSendsInCategory!

!methodRemoval: InlineMethodApplier #implementorsAndMessageSendsInCategory stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
implementorsAndMessageSendsInCategory

	^self refactoringClass
		addImplementorsOf: selectorToInline
		to: self implementorsOrDiscardCollection
		andUsagesTo: self messageSendsOrDiscardCollection
		inCategory: selectedClass category
		organizedBy: SystemOrganization!

InlineMethodApplier removeSelector: #actualScopeOptionLabels!

InlineMethodApplier removeSelector: #actualImplementorsAndSenders!

InlineMethodApplier removeSelector: #canNotRefactorWithIncompleteTypeInfo!

InlineMethodApplier removeSelector: #implementorsAndSendersForHierarchy!

InlineMethodApplier removeSelector: #calculateImplementorsAndMessageSends!

!methodRemoval: InlineMethodApplier #calculateImplementorsAndMessageSends stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
calculateImplementorsAndMessageSends

	scopeChoice = 1 ifTrue: [ ^self implementorsAndMessageSendsForClass ].
	scopeChoice = 2 ifTrue: [ ^self implementorsAndMessageSendsForHierarchy ].
	scopeChoice = 3 ifTrue: [ ^self implementorsAndMessageSendsInCategory ].
	scopeChoice = 4 ifTrue: [ ^self implementorsAndMessageSendsInCategoryAndHierarchy ].
	scopeChoice = 5 ifTrue: [ ^self implementorsAndMessageSendsInSystem ].

	self error: 'Unknown scope option'

		!

InlineMethodApplier removeSelector: #askScope!

!methodRemoval: InlineMethodApplier #askScope stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
askScope

	| scopeMenu |

	scopeMenu := PopUpMenu labelArray: self scopeOptionLabels.
	scopeChoice := scopeMenu startUpWithCaption: 'Select Refactoring Scope'.
	scopeChoice = 0 ifTrue: [ self endRequest ].
	!

AddParameterApplier removeSelector: #withLiveTypingScopeOptionLabels!

ChangeSelectorApplier removeSelector: #withLiveTypingScopeOptionLabels!

ChangeSelectorApplier removeSelector: #implementorsAndSendersInSystem!

!methodRemoval: ChangeSelectorApplier #implementorsAndSendersInSystem stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
implementorsAndSendersInSystem
		
	^self refactoringClass addImplementorsOf: oldSelector to: implementors andSendersTo: senders inSystem: Smalltalk !

ChangeSelectorApplier removeSelector: #scopeOptionLabels!

!methodRemoval: ChangeSelectorApplier #scopeOptionLabels stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
scopeOptionLabels
	
	^{'In Class'. 'In Hierarchy'. 'In Category'. 'In Hierarchy and its Categories'. 'In System'}.!

ChangeSelectorApplier removeSelector: #calculateImplementorsAndSenders!

!methodRemoval: ChangeSelectorApplier #calculateImplementorsAndSenders stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
calculateImplementorsAndSenders
		
	scopeChoice = 1 ifTrue: [ ^self implementorsAndSendersForClass ].
	scopeChoice = 2 ifTrue: [ ^self implementorsAndSendersForHierarchy ].
	scopeChoice = 3 ifTrue: [ ^self implementorsAndSendersInCategory ].
	scopeChoice = 4 ifTrue: [ ^self implementorsAndSendersInCategoryAndHierarchy ].
	scopeChoice = 5 ifTrue: [ ^self implementorsAndSendersInSystem ].
	
	self error: 'Unknown scope option' 
		
		!

ChangeSelectorApplier removeSelector: #implementorsAndSendersInCategory!

!methodRemoval: ChangeSelectorApplier #implementorsAndSendersInCategory stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
implementorsAndSendersInCategory

	^self refactoringClass
		addImplementorsOf: oldSelector
		to: implementors
		andSendersTo: senders
		inCategory: selectedClass category
		organizedBy: SystemOrganization!

ChangeSelectorApplier removeSelector: #implementorsAndSendersForHierarchy!

!methodRemoval: ChangeSelectorApplier #implementorsAndSendersForHierarchy stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
implementorsAndSendersForHierarchy

	^self refactoringClass
		addImplementorsOf: oldSelector
		to: implementors
		andSendersTo: senders
		inHierarchyOf: selectedClass!

ChangeSelectorApplier removeSelector: #implementorsAndSendersInCategoryAndHierarchy!

!methodRemoval: ChangeSelectorApplier #implementorsAndSendersInCategoryAndHierarchy stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
implementorsAndSendersInCategoryAndHierarchy

	^self refactoringClass
		addImplementorsOf: oldSelector
		to: implementors
		andSendersTo: senders
		inCategoriesAndHierarchyOf: selectedClass
		organizedBy: SystemOrganization !

ChangeSelectorApplier removeSelector: #implementorsAndSendersForClass!

!methodRemoval: ChangeSelectorApplier #implementorsAndSendersForClass stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
implementorsAndSendersForClass

	^self refactoringClass
		addImplementorsOf: oldSelector
		to: implementors
		andSendersTo: senders
		forClassAndMetaOf: selectedClass!

ChangeSelectorApplier removeSelector: #askScope!

!methodRemoval: ChangeSelectorApplier #askScope stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
askScope

	| scopeMenu |
	
	scopeMenu := PopUpMenu labelArray: self scopeOptionLabels.
	scopeChoice := scopeMenu startUpWithCaption: 'Select Refactoring Scope'.
	scopeChoice = 0 ifTrue: [ self endRequest ].
	!

ScopedRefactoringApplier class removeSelector: #scopeOptionLabels!

ScopedRefactoringApplier removeSelector: #createImplementors!

ScopedRefactoringApplier removeSelectorIfInBaseSystem: #withLiveTypingScopeOptionLabels!

ScopedRefactoringApplier removeSelectorIfInBaseSystem: #actualImplementorsAndSenders!

ScopedRefactoringApplier removeSelectorIfInBaseSystem: #calculateImplementorsAndSendersWithLiveTyping!

InlineMethod class removeSelector: #addImplementorsOf:to:andSendersTo:of:!

InlineMethod class removeSelector: #addImplementorsOf:to:andUsagesTo:inHierarchyOf:!

!methodRemoval: InlineMethod class #addImplementorsOf:to:andUsagesTo:inHierarchyOf: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages inHierarchyOf: aClass

	self
		addImplementorsOf: aSelectorToInline
		to: implementors
		andUsagesTo: usages
		inHierarchyOf: aClass
		doingPerClass: [ :aClassInHierarchy | ]

	!

InlineMethod class removeSelector: #addImplementorsOf:to:andUsagesTo:inHierarchyOf:doingPerClass:!

!methodRemoval: InlineMethod class #addImplementorsOf:to:andUsagesTo:inHierarchyOf:doingPerClass: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages inHierarchyOf: aClass doingPerClass: aBlock

	| highestClassImplementingOldSelector |

	highestClassImplementingOldSelector := aClass highestClassImplementing: aSelectorToInline ifNone: [ aClass ].
	highestClassImplementingOldSelector theNonMetaClass withAllSubclassesDo: [ :aPotentialClassToRefactor |
		aPotentialClassToRefactor isMeta ifFalse: [
			self
				addImplementorsOf: aSelectorToInline
				to: implementors
				andUsagesTo: usages
				forClassAndMetaOf: aPotentialClassToRefactor.
			aBlock value: aPotentialClassToRefactor ]]
	!

InlineMethod class removeSelector: #addImplementorsOf:to:andSendersTo:inCategory:organizedBy:!

InlineMethod class removeSelector: #addImplementorsOf:to:andUsagesTo:inSystem:!

!methodRemoval: InlineMethod class #addImplementorsOf:to:andUsagesTo:inSystem: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages inSystem: aSystem

	aSystem allBehaviorsDo: [ :aPotentialClassToRefactor |
		self addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages of: aPotentialClassToRefactor ].
!

InlineMethod class removeSelector: #addImplementorsOf:to:andUsagesTo:forClassAndMetaOf:!

!methodRemoval: InlineMethod class #addImplementorsOf:to:andUsagesTo:forClassAndMetaOf: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages forClassAndMetaOf: aPotentialClassToRefactor

	self addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages of: aPotentialClassToRefactor theNonMetaClass.
	self addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages of: aPotentialClassToRefactor theMetaClass.

!

InlineMethod class removeSelector: #addImplementorsOf:to:andSendersTo:inHierarchyOf:doingPerClass:!

InlineMethod class removeSelector: #addImplementorsOf:to:andUsagesTo:of:!

!methodRemoval: InlineMethod class #addImplementorsOf:to:andUsagesTo:of: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages of: aPotentialClassToRefactor

	| potentialImplementor |

	"Phil B. requested to avoid refactoring OMeta2 classes, so right now
	it avoids implementors and senders whose compilerClass is not register
	as allowed compiler - Hernan"
	(self canRefactor: aPotentialClassToRefactor) ifFalse: [ ^self ].

	potentialImplementor := aPotentialClassToRefactor compiledMethodAt: aSelectorToInline ifAbsent: [ nil ].
	potentialImplementor ifNotNil: [ implementors add: potentialImplementor ].

	(aPotentialClassToRefactor whichSelectorsReferTo: aSelectorToInline) do: [ :aSelector |
		usages addAll: (self findReferencesToSelector: aSelectorToInline in: (MethodReference class: aPotentialClassToRefactor selector: aSelector))]!

InlineMethod class removeSelector: #addImplementorsOf:to:andUsagesTo:inCategoriesAndHierarchyOf:organizedBy:!

!methodRemoval: InlineMethod class #addImplementorsOf:to:andUsagesTo:inCategoriesAndHierarchyOf:organizedBy: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages inCategoriesAndHierarchyOf: aClass organizedBy: anOrganization

	| categories |

	categories := Set new.

	self
		addImplementorsOf: aSelectorToInline
		to: implementors
		andUsagesTo: usages
		inHierarchyOf: aClass
		doingPerClass: [:aClassInHierarchy | categories add: aClassInHierarchy category ].

	categories do: [:aCategory |
		self
			addImplementorsOf: aSelectorToInline
			to: implementors
			andUsagesTo: usages
			inCategory: aCategory
			organizedBy: anOrganization ].
!

InlineMethod class removeSelector: #addImplementorsOf:to:andSendersTo:inCategoriesAndHierarchyOf:organizedBy:!

InlineMethod class removeSelector: #addImplementorsOf:to:andSendersTo:inHierarchyOf:!

InlineMethod class removeSelector: #addImplementorsOf:to:andSendersTo:forClassAndMetaOf:!

InlineMethod class removeSelector: #addImplementorsOf:to:andUsagesTo:inCategory:organizedBy:!

!methodRemoval: InlineMethod class #addImplementorsOf:to:andUsagesTo:inCategory:organizedBy: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: aSelectorToInline to: implementors andUsagesTo: usages inCategory: aCategory organizedBy: anOrganization

	| classesInCategory |

	classesInCategory := anOrganization classesAt: aCategory.
	classesInCategory do: [ :aPotentialClassToRefactor |
		self
			addImplementorsOf: aSelectorToInline
			to: implementors
			andUsagesTo: usages
			forClassAndMetaOf: aPotentialClassToRefactor ].!

InlineMethod class removeSelector: #addImplementorsOf:to:andSendersTo:inSystem:!

ChangeSelector class removeSelector: #addImplementorsOf:to:andSendersTo:inHierarchyOf:doingPerClass:!

!methodRemoval: ChangeSelector class #addImplementorsOf:to:andSendersTo:inHierarchyOf:doingPerClass: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inHierarchyOf: aClass doingPerClass: aBlock

	| highestClassImplementingOldSelector |
	
	highestClassImplementingOldSelector := aClass highestClassImplementing: anOldSelector ifNone: [ aClass ].
	highestClassImplementingOldSelector theNonMetaClass withAllSubclassesDo: [ :aPotentialClassToRefactor |
		aPotentialClassToRefactor isMeta ifFalse: [ 
			self 
				addImplementorsOf: anOldSelector 
				to: implementors 
				andSendersTo: senders 
				forClassAndMetaOf: aPotentialClassToRefactor.
			aBlock value: aPotentialClassToRefactor ]]
	!

ChangeSelector class removeSelector: #addImplementorsOf:to:andSendersTo:inSystem:!

!methodRemoval: ChangeSelector class #addImplementorsOf:to:andSendersTo:inSystem: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inSystem: aSystem

	aSystem allBehaviorsDo: [ :aPotentialClassToRefactor | 
		self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor ].
!

ChangeSelector class removeSelector: #addImplementorsOf:to:andSendersTo:inCategoriesAndHierarchyOf:organizedBy:!

!methodRemoval: ChangeSelector class #addImplementorsOf:to:andSendersTo:inCategoriesAndHierarchyOf:organizedBy: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategoriesAndHierarchyOf: aClass organizedBy: anOrganization

	| categories |
	
	categories := Set new.

	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders 
		inHierarchyOf: aClass 
		doingPerClass: [:aClassInHierarchy | categories add: aClassInHierarchy category ].
		
	categories do: [:aCategory | 
		self 
			addImplementorsOf: anOldSelector 
			to: implementors 
			andSendersTo: senders 
			inCategory: aCategory 
			organizedBy: anOrganization ].
!

ChangeSelector class removeSelector: #addImplementorsOf:to:andSendersTo:inHierarchyOf:!

!methodRemoval: ChangeSelector class #addImplementorsOf:to:andSendersTo:inHierarchyOf: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inHierarchyOf: aClass

	self 
		addImplementorsOf: anOldSelector 
		to: implementors 
		andSendersTo: senders 
		inHierarchyOf: aClass 
		doingPerClass: [ :aClassInHierarchy | ]
		
	!

ChangeSelector class removeSelector: #addImplementorsOf:to:andSendersTo:forClassAndMetaOf:!

!methodRemoval: ChangeSelector class #addImplementorsOf:to:andSendersTo:forClassAndMetaOf: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: anOldSelector to: implementors andSendersTo: senders forClassAndMetaOf: aPotentialClassToRefactor
	
	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor theNonMetaClass.
	self addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor theMetaClass.

!

ChangeSelector class removeSelector: #addImplementorsOf:to:andSendersTo:of:!

!methodRemoval: ChangeSelector class #addImplementorsOf:to:andSendersTo:of: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor

	| potentialImplementor |

	"Phil B. requested to avoid refactoring OMeta2 classes, so right now
	it avoids implementors and senders whose compilerClass is not register
	as allowed compiler - Hernan"
	(self canRefactor: aPotentialClassToRefactor) ifFalse: [ ^self ].

	potentialImplementor := aPotentialClassToRefactor compiledMethodAt: anOldSelector ifAbsent: [ nil ].
	potentialImplementor ifNotNil: [ implementors add: potentialImplementor ].

	(aPotentialClassToRefactor whichSelectorsReferTo: anOldSelector) do: [ :aSelector |
		senders add: (MethodReference class: aPotentialClassToRefactor selector: aSelector) ]!

ChangeSelector class removeSelector: #addImplementorsOf:to:andSendersTo:inCategory:organizedBy:!

!methodRemoval: ChangeSelector class #addImplementorsOf:to:andSendersTo:inCategory:organizedBy: stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategory: aCategory organizedBy: anOrganization

	| classesInCategory |
	
	classesInCategory := anOrganization classesAt: aCategory.
	classesInCategory do: [ :aPotentialClassToRefactor | 
		self 
			addImplementorsOf: anOldSelector 
			to: implementors 
			andSendersTo: senders 
			forClassAndMetaOf: aPotentialClassToRefactor ].
!

ScopedRefactoring subclass: #ChangeSelector
	instanceVariableNames: 'oldSelector newSelector implementors senders changes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelector category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
ScopedRefactoring subclass: #ChangeSelector
	instanceVariableNames: 'oldSelector newSelector implementors senders changes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ScopedRefactoring subclass: #ExtractAsParameter
	instanceVariableNames: 'sourceMethod addParameter intervals'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ExtractAsParameter category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
ScopedRefactoring subclass: #ExtractAsParameter
	instanceVariableNames: 'sourceMethod addParameter intervals'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ScopedRefactoring subclass: #InlineMethod
	instanceVariableNames: 'methodToInline messageSendsToInline updatedSendersCode methodNodeToInline replacementsByMessageSend temporariesDeclarationsByNode temporariesToDeclareByInsertionPoint implementorCompleteSourceRanges removeMethod'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethod category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
ScopedRefactoring subclass: #InlineMethod
	instanceVariableNames: 'methodToInline messageSendsToInline updatedSendersCode methodNodeToInline replacementsByMessageSend temporariesDeclarationsByNode temporariesToDeclareByInsertionPoint implementorCompleteSourceRanges removeMethod'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ScopedRefactoringApplier subclass: #ChangeSelectorApplier
	instanceVariableNames: 'oldSelector wizardStepWindow shouldShowChanges browser implementors senders'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ChangeSelectorApplier category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
ScopedRefactoringApplier subclass: #ChangeSelectorApplier
	instanceVariableNames: 'oldSelector wizardStepWindow shouldShowChanges browser implementors senders'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ScopedRefactoringApplier subclass: #InlineMethodApplier
	instanceVariableNames: 'selectorToInline wizardStepWindow shouldShowChanges browser shouldRemoveImplementor triggeringMessageSend shouldInlineTriggeringMessageSendOnly implementors messageSends'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #InlineMethodApplier category: #'Tools-Refactoring' stamp: 'Install-7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st 5/13/2025 17:35:46'!
ScopedRefactoringApplier subclass: #InlineMethodApplier
	instanceVariableNames: 'selectorToInline wizardStepWindow shouldShowChanges browser shouldRemoveImplementor triggeringMessageSend shouldInlineTriggeringMessageSendOnly implementors messageSends'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7084-ScopeRefactoring-HernanWilkinson-2025Mar19-08h56m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7082] on 20 March 2025 at 2:10:21 pm'!
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/20/2025 14:00:46' prior: 50363127!
       addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategory: aCategory organizedBy: anOrganization

	| classesInCategory rootCategory |

	rootCategory := (aCategory findTokens: '-') first.
	classesInCategory := anOrganization allClassesAt: rootCategory.
	classesInCategory do: [ :aPotentialClassToRefactor |
		self
			addImplementorsOf: anOldSelector
			to: implementors
			andSendersTo: senders
			forClassAndMetaOf: aPotentialClassToRefactor ].
! !
!ScopedRefactoringApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/20/2025 14:08:17' prior: 50363269!
            basicScopeOptionLabels

	"Do not inline/rename/remove. Used by LiveTyping - Hernan"

	^`{'In Class'. 'In Hierarchy'. 'In Class Category Tree'. 'In Hierarchy and its Categories Tree'. 'In System'}`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7085-RefactoringScopeInCategoryTree-HernanWilkinson-2025Mar20-13h58m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7084] on 20 March 2025 at 9:29:44 pm'!
!TestSuite class methodsFor: 'instance creation' stamp: 'HAW 3/20/2025 21:08:51'!
               forSystemCategoryTreeOf: aCategoryName  using: aSystemOrganizer

	| rootCategory |

	rootCategory := (aCategoryName findTokens: '-') first.
	
	^self forSystemCategoryNamed: rootCategory using: aSystemOrganizer ! !
!SmalltalkEditor methodsFor: 'running tests' stamp: 'HAW 3/20/2025 21:14:55' prior: 16955725!
            testSuiteForCategoryOf: aClass

	| selectedSystemCategory |
	
	"If we are in a senders or implementors window, a MessageSet, the selectedSystemCategory is nil.
	In that case most of those cases the user wants to run the tests of the category of the selected method class - Hernan"
	selectedSystemCategory := self codeProvider selectedSystemCategory ifNil: [ aClass category ].
	^TestSuite forSystemCategoryTreeOf: selectedSystemCategory using: SystemOrganization 
! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 3/20/2025 21:12:44' prior: 50359060 overrides: 16983613!
                   defaultMenuSpec
	"Spec for the menu and shortcut keys for the regular text editors.
	See coment at Morph >> #getMenu
	"
	| codeProvider acceptEntry additionalEntries isEditingAMethod isEditingAClassDef |
	isEditingAMethod := false.
	isEditingAClassDef := false.
	additionalEntries := nil.
	codeProvider := self codeProvider.
	(codeProvider is: #CodeProvider)
		ifTrue: [
			acceptEntry := self hasUnacceptedEdits
				ifTrue: [ #(270	'Save (s)' 				$s 	editor 	acceptContents 		acceptIcon 				'Save') ]
				ifFalse: [ #(270 	'Save' 					nil 	editor 	nil 						acceptIcon 				'Save') ].
			codeProvider isEditingMethod ifTrue: [
				isEditingAMethod := true.
				additionalEntries := #(
					#(20 	'-----')
					#(30	'What to Show' 					nil 	nil 		3000 					preferencesIcon 		'Select alternative views of the method')
					#(40	'Toggle Break' 					nil 	editor 	toggleBreakOnEntry 	debugIcon 				'Add or remove a Breakpoint')
					#(200 	'-----')
					#(210	'Refactorings' 					nil 	nil 		2000 					listAddIcon)
					#(280	'Save & Run Test in Class (t)' 		$t 	editor 	acceptAndTest 			weatherFewCloudsIcon 'Saves method, runs it as test and then all tests in class. Opens debugger if error.')
					#(290	'Save & Run Test in Category tree (y)' 	$y 	editor 	acceptAndTestAll 		weatherFewCloudsIcon 'Saves method, runs it as test and then all tests in class category tree. Opens debugger if error.')
					#(300	'Save & Debug Test (r)' 			$r 	editor 	acceptAndDebugTest 	weatherFewCloudsIcon 'Saves method and debugs it')
				) ].
			self isEditingClassDefinition ifTrue: [
				isEditingAClassDef := true.
				additionalEntries := #(
					#(200 	'-----')
					#(210	'Refactorings' 					nil 	nil 		2000 					listAddIcon)
				) ]
			]
		ifFalse: [
			acceptEntry := self hasUnacceptedEdits
				ifTrue: [ #(270	'Save to file (s)' 			$s 	editor 	acceptContents 		acceptIcon 				'Save contents to a file') ]
				ifFalse: [ #(270 	'Save to file' 				nil 	editor 	nil 						acceptIcon 				'Save contents to a file') ]].
	^Array streamContents: [ :strm |
		strm nextPutAll:
			#(
				#(0 		'Smalltalk Editor' 				true)
				#(10	'Help... (h)' 					$h 	editor 	openHelp 				helpIcon 				'Open Help')
				#(50 	'-----')
				#(60	'Do it (d)' 					$d 	editor 	doIt 					doItIcon 				'Do it (selection is a valid expression)')
				#(70	'Print it (p)' 					$p 	editor 	printIt 					printIcon 				'Print it (selection is a valid expression)')
				#(80	'Inspect it (i)' 				$i 	editor 	inspectIt 				inspectIcon 			'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
				#(90	'Explore it (I)' 				$I 	editor 	exploreIt 				exploreIcon			'Inspect via Object Explorer')
				#(100	'Debug it (D)' 				$D 	editor 	debugIt 				debugIcon				'Debug it')
				#(110	'Profile it' 					nil 	editor 	profileIt 				clockIcon)
				#(120 	'-----')
				#(130	'Edit' 						nil 	nil 		1000 					textEditorIcon)
				#(140 	'-----')
				#(150	'Explain' 					nil 	editor 	explain 				helpIcon)
				#(160	'Browse it (b)' 				$b 	editor 	browseIt 				editFindReplaceIcon 	'Browse it (selection is a class name or cursor is over a class-list or message-list)')
				#(170	'Senders (n)' 				$n 	editor 	sendersOfIt 			mailForwardIcon 		'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
				#(180	'Implementors (m)' 			$m 	editor 	implementorsOfIt 		developmentIcon 		'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')
				#(190	'References (N)' 				$N 	editor 	referencesToIt 			addressBookIcon 		'References to it (selection is a class name, or cursor is over a class-list or message-list)')
				#(220 	'-----')
				#(230	'Find with Scope (e)' 			$e 	editor 	findMethodSourceContainingIt scriptIcon 		'Find with scope')
				#(240	'Method Strings with it (E)' 	$E	editor 	methodStringsContainingIt 	genericTextIcon 'Method strings containing it')
				#(250	'Find in class comments' 		nil 	editor 	classCommentsContainingIt 	chatIcon)
				#(260 	'-----')
			);
			nextPut: acceptEntry.
		additionalEntries notNil ifTrue: [
			strm nextPutAll: additionalEntries ].
		strm
			nextPutAll: self editSubmenuSpec;
			nextPutAll: self keyboardShortuctsSubmenuSpec.
		isEditingAMethod ifTrue: [
			strm nextPutAll: self methodRefactoringsSubmenuSpec ].
		isEditingAMethod ifTrue: [
			strm nextPutAll: self codeProvider whatToShowSubmenuSpec ].
		isEditingAClassDef ifTrue: [
			strm nextPutAll: self classDefRefactoringsSubmenuSpec ].
	].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7086-RunTestsInClassCategoryTree-HernanWilkinson-2025Mar20-20h52m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7084] on 20 March 2025 at 9:42:35 pm'!
!SystemOrganizer methodsFor: 'categories' stamp: 'HAW 3/20/2025 21:34:22'!
                            rootCategoryOf: aCategory

	^ (aCategory findTokens: '-') first! !
!Browser methodsFor: 'system category list' stamp: 'HAW 3/20/2025 21:37:23' prior: 16799084!
systemCategoryRoots
	"Answer the roots of the forest of system categories."
	| categories subcategories roots name |
	categories := self systemCategoryList.
	subcategories := Dictionary new.
	categories do: [:each|
		name := SystemOrganization rootCategoryOf: each.
		(subcategories at: name ifAbsentPut: [OrderedCollection new]) add: each].
	roots := OrderedCollection new.
	categories do: [:each|
		name := SystemOrganization rootCategoryOf: each.
		(roots includes: name) ifFalse:
			[(subcategories at: name) size > 1 ifTrue: [roots add: name] ifFalse: [roots add: (subcategories at: name) first]]].
	^ roots collect: [:each| SystemCategoryWrapper with: each name: each model: self]! !
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/20/2025 21:36:26' prior: 50364484!
                             addImplementorsOf: anOldSelector to: implementors andSendersTo: senders inCategory: aCategory organizedBy: anOrganization

	| classesInCategory rootCategory |

	rootCategory := anOrganization rootCategoryOf: aCategory.
	classesInCategory := anOrganization allClassesAt: rootCategory.
	classesInCategory do: [ :aPotentialClassToRefactor |
		self
			addImplementorsOf: anOldSelector
			to: implementors
			andSendersTo: senders
			forClassAndMetaOf: aPotentialClassToRefactor ].
! !
!TestSuite class methodsFor: 'instance creation' stamp: 'HAW 3/20/2025 21:38:29' prior: 50364520!
                             forSystemCategoryTreeOf: aCategoryName  using: aSystemOrganizer

	| rootCategory |

	rootCategory := aSystemOrganizer rootCategoryOf: aCategoryName.
	
	^self forSystemCategoryNamed: rootCategory using: aSystemOrganizer ! !

ScopedRefactoring class removeSelector: #rootCategoryOf:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7087-RootCategoryInOnePlace-HernanWilkinson-2025Mar20-21h29m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7087] on 22 March 2025 at 5:40:31 pm'!
!CodePackageList methodsFor: 'user interface support' stamp: 'jmv 3/22/2025 17:38:30' prior: 16825008 overrides: 16917518!
                            editorClassFor: textGetter
	^TextEditor! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7088-CodePackageList-fix-JuanVuletich-2025Mar22-17h37m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7084] on 22 March 2025 at 9:30:55 pm'!
!MethodSet methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:06:56'!
     addAsSubclassResponsibilitySelector

	AddAsSubclassResponsibilityApplier applyFrom: self.! !
!MethodSet methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:11:44'!
                            addParameter

	RefactoringApplier addParameterApplier applyFrom: self
	! !
!MethodSet methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:16:46'!
              changeKeywordOrder
	
	ChangeKeywordsSelectorOrderApplier applyFrom: self.! !
!MethodSet methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:17:48'!
            inlineMethod

	RefactoringApplier inlineMethodApplier applyFrom: self! !
!MethodSet methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:19:52'!
                moveToInstanceOrClassMethod

	MoveToInstanceOrClassMethodApplier applyFrom: self! !
!MethodSet methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:20:58'!
     pushDownSelectorToOneSubclass
	
	PushDownMethodToOneSubclassApplier applyFrom: self.! !
!MethodSet methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:22:02'!
 pushDownSelectorToSubclasses
	
	PushDownMethodToSubclassesApplier applyFrom: self.! !
!MethodSet methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:23:18'!
   pushUpSelector

	PushUpMethodApplier applyFrom: self.! !
!MethodSet methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:24:17'!
removeParameter

	RefactoringApplier removeParameterApplier applyFrom: self
	! !
!MethodSet methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:26:13'!
        renameSelector

	RefactoringApplier renameSelectorApplier applyFrom: self
	! !
!MethodSetWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 3/22/2025 19:00:22' prior: 50350815!
            messageListMenuSpec
	"Spec for the menu and shortcut keys for the messages list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Message Set' 				false)
		#(10	'Browse Full (b)' 				$b 	window browseMethodFull 						editFindReplaceIcon)
		#(20	'Browse Hierarchy (h)' 		$h 	window browseHierarchy 							goTopIcon)
		#(30	'Browse Method (O)' 			$O 	window openSingleMessageBrowser 				scriptIcon)
		#(40	'Browse Protocol (p)' 			$p 	window browseFullProtocol 						spreadsheetIcon)
		#(45	'Browse Package' 			nil 	window browsePackage 							packageIcon)
		#(50 	'-----')
		#(60	'File Out' 					nil 	model 	fileOutMessage 							fileOutIcon)
		#(61	'File Out All' 					nil 	model 	fileOutAllMethods 							fileOutIcon)
		#(70	'Run Test (t)' 				$t 	model 	runMethodTest 							weatherFewCloudsIcon)
		#(80	'Debug Test (r)' 				$r 	model 	debugMethodTest 							weatherFewCloudsIcon)
		#(90	'Inspect CompiledMethod' 	nil 	model 	inspectCompiledMethod 					exploreIcon)
		#(100 	'-----')
		#(103	'Refactorings' 				nil 	nil 		1000 										listAddIcon)
		#(110	'Senders of... (n)' 			nil 	window browseSendersOfMessages 				mailForwardIcon)
		#(120	'Local Senders of...' 			nil 	window browseLocalSendersOfMessages 			mailForwardIcon)
		#(130	'Implementors of... (m)' 		nil 	window browseImplementorsOfMessages 			developmentIcon)
		#(140	'Local Implementors of...' 		nil 	window browseLocalImplementorsOfMessages 	developmentIcon)
		#(150	'Inheritance (i)' 				$i 	window methodInheritance 						goDownIcon)
		#(160	'Versions (v)' 				$v 	window browseVersions 							clockIcon)
		#(170 	'-----')
		#(180	'Remove Method (x)' 			$x 	model 	removeMessage 							deleteIcon)
		#(190	'more' 						nil 	nil 		2000 										listAddIcon)

		"Shortcut only. No menu entry."
		#(991	nil 							$m 	window browseImplementors)
		#(992	nil 							$n 	window browseSenders)
		#(993	nil 							$c 	model 	copySelector)
		#(994	nil 							$N 	window browseClassRefs)

		" 'Refactoring' SubMenu"
		#(1010	'Rename... (R)' 							$R 	model 		renameSelector 							saveAsIcon)
		#(1020	'Change keyword Order...' 				nil 	model 		changeKeywordOrder 						sendReceiveIcon)
		#(1030	'Add Parameter... (A)' 					$A 	model 		addParameter 								listAddIcon)
		#(1040	'Remove Parameter... (S)' 				$S 	model 		removeParameter 							listRemoveIcon)
		#(1050 	'-----')
		#(1060	'Inline Method... (F)' 						$F 	model 		inlineMethod 								saveAsIcon)
		#(1070	'Move to Instance/Class Method' 			nil 	model 		moveToInstanceOrClassMethod 			changesIcon)
		#(1080	'Push Up' 								nil 	model 		pushUpSelector 							goTopIcon)
		#(1090	'Add in Superclass as subclassResponsibility' nil model 		addAsSubclassResponsibilitySelector 		goTopIcon)
		#(1100	'Push Down to Subclasses' 				nil 	model 		pushDownSelectorToSubclasses 			goBottomIcon)
		#(1110	'Push Down to One Subclass' 				nil 	model 		pushDownSelectorToOneSubclass 			goBottomIcon)

		" 'more' SubMenu"
		#(2010	'Sample instance' 			nil 	window makeSampleInstance 						instanceIcon)
		#(2020	'Inspect instances' 			nil 	window inspectInstances 							inspectIcon)
		#(2030	'Inspect subinstances' 		nil 	window inspectSubInstances 						inspectIcon)
		#(2040 	'-----')
		#(2050 	'Remove from this Browser' 	nil 	model 	removeMessageFromBrowser 				listRemoveIcon)
		#(2060 	'Filter message list...' 			nil 	window filterMessageList 							findIcon)
		#(2070	'Change category...' 			nil 	model 	changeCategory 							saveAsIcon)
		#(2080	'Change sets with this Method' nil 	window findMethodInChangeSets 					changesIcon)
		#(2090	'Revert to previous Version' 	nil 	model 	revertToPreviousVersion 					undoIcon)
		#(2100 	'-----')
		#(2110 	'Sort by class Hierarchy' 		nil 	model 	sortByClassHierarchy 						classIcon)
		#(2120 	'Sort by class Name' 			nil 	model 	sortByClassName 							classIcon)
		#(2130 	'Sort by Selector' 				nil 	model 	sortBySelector 								scriptIcon)
		#(2140 	'Sort by Date' 				nil 	model 	sortByDate 								dateIcon)
		#(2150 	'Reverse sort' 				nil 	model 	sortReverse 								redoIcon)
	).
! !
!TransferMethod methodsFor: 'accessing' stamp: 'HAW 3/22/2025 21:12:26'!
                        selector
	
	^method selector ! !
!PushUpMethod methodsFor: 'accessing' stamp: 'HAW 3/22/2025 21:17:10' overrides: 50364964!
    selector
	
	^methods anyOne selector! !
!ScopedRefactoringApplier class methodsFor: 'instance creation' stamp: 'HAW 3/22/2025 20:35:49'!
                       applyFrom: aCodeProvider

	self subclassResponsibility! !
!ChangeSelectorApplier class methodsFor: 'instance creation' stamp: 'HAW 3/22/2025 20:35:08' overrides: 50364973!
                    applyFrom: aCodeProvider
	
	aCodeProvider selectedMessageName ifNotNil: [ :oldSelector |
		self
			createAndValueHandlingExceptionsOn: aCodeProvider
			for: oldSelector
			in: aCodeProvider selectedClassOrMetaClass ].! !
!InlineMethodApplier class methodsFor: 'instance creation' stamp: 'HAW 3/22/2025 20:30:43' overrides: 50364973!
                   applyFrom: aCodeProvider
	
	aCodeProvider selectedMessageName ifNotNil: [ :selectorToInline |
		self
			createAndValueHandlingExceptionsOn: aCodeProvider 
			forMethod: (MethodReference
				class: aCodeProvider selectedClassOrMetaClass 
				selector: selectorToInline )]! !
!InlineMethodApplier class methodsFor: 'instance creation' stamp: 'HAW 3/22/2025 20:41:15'!
                  on: aModel forMessageSend: aMessageNodeReference

	^self new initializeOn: aModel forMessageSend: aMessageNodeReference
	! !
!InlineMethodApplier class methodsFor: 'instance creation' stamp: 'HAW 3/22/2025 20:41:41'!
       on: aModel forMethod: aMethodReference

	"To be called when calling from method selector or when inlining self method from the code editor"

	^self new initializeOn: aModel for: aMethodReference selector in: aMethodReference actualClass.! !
!TransferMethodApplier class methodsFor: 'instance creation' stamp: 'HAW 3/22/2025 20:37:51'!
                 applyFrom: aCodeProvider

	aCodeProvider selectedMessageName ifNotNil: [ :selectedSelector |
		(self 
			on: aCodeProvider 
			for: aCodeProvider selectedClassOrMetaClass>>selectedSelector) value ].
	! !
!AddAsSubclassResponsibilityApplier methodsFor: 'refactoring - changes' stamp: 'HAW 3/22/2025 21:19:37' overrides: 16991015!
                       informChangesToBrowser

! !
!PushDownMethodToSubclassesApplier methodsFor: 'as yet unclassified' stamp: 'HAW 3/22/2025 21:24:46' overrides: 16991015!
          informChangesToBrowser

	browser messageListIndex: browser messageListIndex ! !
!MessageNode methodsFor: 'source ranges' stamp: 'HAW 3/22/2025 20:02:20' prior: 16897216 overrides: 16920006!
  expandRanges: aSourceRange basedOn: sourceRanges using: sourceCode

	| receiverExpandedRanges expandedRangeWithReceiver |
	receiverExpandedRanges := self isCascade
		ifTrue: [ aSourceRange ] "not expanded because expansion is handled in CascadeNode"
		ifFalse: [ originalReceiver expandRanges: (self receiverSourceRangesFrom: sourceRanges) basedOn: sourceRanges using: sourceCode ].
	expandedRangeWithReceiver := self
		expandRange: (aSourceRange isInterval ifTrue: [ aSourceRange ] ifFalse: [ aSourceRange first ])
		basedOn: receiverExpandedRanges.
	^ super
		expandRanges: expandedRangeWithReceiver
		basedOn: expandedRangeWithReceiver
		using: sourceCode! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:07:21' prior: 16799278!
                     addAsSubclassResponsibilitySelector

	AddAsSubclassResponsibilityApplier applyFrom: self.! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:15:39' prior: 16799294!
              addParameter

	RefactoringApplier addParameterApplier applyFrom: self
	! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:17:18' prior: 16799303!
changeKeywordOrder

	ChangeKeywordsSelectorOrderApplier applyFrom: self.! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:19:04' prior: 16799314!
                               inlineMethod

	RefactoringApplier inlineMethodApplier applyFrom: self! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:20:15' prior: 16799332!
  moveToInstanceOrClassMethod

	MoveToInstanceOrClassMethodApplier applyFrom: self! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:21:22' prior: 16799348!
                       pushDownSelectorToOneSubclass
	
	PushDownMethodToOneSubclassApplier applyFrom: self.! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:22:43' prior: 16799357!
                   pushDownSelectorToSubclasses
	
	PushDownMethodToSubclassesApplier applyFrom: self.! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:23:52' prior: 16799373!
                     pushUpSelector

	PushUpMethodApplier applyFrom: self.! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:25:39' prior: 16799400!
                  removeParameter

	RefactoringApplier removeParameterApplier applyFrom: self
	! !
!Browser methodsFor: 'refactorings' stamp: 'HAW 3/22/2025 20:27:03' prior: 16799429!
                          renameSelector

	RefactoringApplier renameSelectorApplier applyFrom: self
	! !
!InlineMethodApplier class methodsFor: 'instance creation' stamp: 'HAW 3/22/2025 20:41:15' prior: 16879689!
     createAndValueHandlingExceptionsOn: aModel forMessageSend: aMessageNodeReference

	self createAndValueHandlingExceptions: [ self on: aModel forMessageSend: aMessageNodeReference ].
! !
!InlineMethodApplier class methodsFor: 'instance creation' stamp: 'HAW 3/22/2025 20:41:41' prior: 16879698!
                           createAndValueHandlingExceptionsOn: aModel forMethod: aMethodReference

	self createAndValueHandlingExceptions: [ self on: aModel forMethod: aMethodReference ].
! !
!TransferMethodApplier methodsFor: 'refactoring - changes' stamp: 'HAW 3/22/2025 21:11:58' prior: 16991015!
               informChangesToBrowser

	browser selector: refactoring selector refactoredTo: nil! !

PushUpMethodApplier class removeSelector: #applyFrom:!

PushUpMethodApplier class removeSelector: #pushUpSelector:!

PushDownMethodToSubclassesApplier class removeSelector: #applyFrom:!

PushDownMethodToSubclassesApplier class removeSelector: #pushDownSelectorToSubclasses:!

PushDownMethodToOneSubclassApplier class removeSelector: #applyFrom:!

PushDownMethodToOneSubclassApplier class removeSelector: #pushDownSelectorToOneSubclass:!

MoveToInstanceOrClassMethodApplier class removeSelector: #applyFrom:!

MoveToInstanceOrClassMethodApplier class removeSelector: #moveToInstanceOrClassMethod:!

AddAsSubclassResponsibilityApplier class removeSelector: #applyFrom:!

AddAsSubclassResponsibilityApplier class removeSelector: #addAsSubclassResponsibilitySelector:!

InlineMethodApplier class removeSelector: #iapplyFrom:!

InlineMethodApplier class removeSelector: #initializeOn:forMethod:!

!methodRemoval: InlineMethodApplier class #initializeOn:forMethod: stamp: 'Install-7089-RefactoringsInMessageSetBrowser-HernanWilkinson-2025Mar22-18h41m-HAW.001.cs.st 5/13/2025 17:35:47'!
initializeOn: aModel forMethod: aMethodReference

	"To be called when calling from method selector or when inlining self method from the code editor"

	^self new initializeOn: aModel for: aMethodReference selector in: aMethodReference actualClass.!

InlineMethodApplier class removeSelector: #initializeOn:forMessageSend:!

!methodRemoval: InlineMethodApplier class #initializeOn:forMessageSend: stamp: 'Install-7089-RefactoringsInMessageSetBrowser-HernanWilkinson-2025Mar22-18h41m-HAW.001.cs.st 5/13/2025 17:35:47'!
initializeOn: aModel forMessageSend: aMessageNodeReference

	^self new initializeOn: aModel forMessageSend: aMessageNodeReference
	!

RemoveParameterApplier class removeSelector: #applyFrom:!

RenameSelectorApplier class removeSelector: #applyFrom:!

ChangeKeywordsSelectorOrderApplier class removeSelector: #applyFrom:!

ChangeKeywordsSelectorOrderApplier class removeSelector: #changeKeywordOrder:!

ChangeSelectorKeepingParametersApplier class removeSelector: #applyFrom:!

AddParameterApplier class removeSelector: #applyFrom:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7089-RefactoringsInMessageSetBrowser-HernanWilkinson-2025Mar22-18h41m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7084] on 23 March 2025 at 10:41:50 am'!
!PushUpMethod methodsFor: 'initialization' stamp: 'HAW 3/23/2025 10:36:01'!
                    initializeForAll: aMethods of: aMethodToPushUp additionallyRemovingFrom: aSubclassesToRemoveMethodFrom

	self initializeFor: aMethodToPushUp.
	methods := aMethods.
	subclassesToRemoveMethodFrom := aSubclassesToRemoveMethodFrom.! !
!PushDownMethodToOneSubclass methodsFor: 'initialization' stamp: 'HAW 3/23/2025 10:38:12' prior: 16935227!
              initializeFor: aMethodToPushDown to: aSubclassToPushDown implementingSubclassResponsibility: shouldImplementSubclassResponsibility 

	self initializeFor: aMethodToPushDown.
	subclassToPushDownTo := aSubclassToPushDown.
	implementSubclassResponsibility := shouldImplementSubclassResponsibility ! !
!PushUpMethod methodsFor: 'applying - private' stamp: 'HAW 3/23/2025 10:36:30' prior: 16935620!
                       pushUpAccessedVariables

	|instanceVariablesToPushUp methodClass|
	
	instanceVariablesToPushUp := self class selectInstanceVariablesToPushUpFrom: methods.
	methodClass := method methodClass.

	instanceVariablesToPushUp do: [:var | (PushUpInstanceVariable named: var from: methodClass) apply ]! !
!PushUpMethod class methodsFor: 'instance creation' stamp: 'HAW 3/23/2025 10:35:44' prior: 16935673!
                   for: aMethodToPushUp additionallyRemovingFrom: subclassesToRemoveMethodFrom pushingUp: dependantMethods
	
	dependantMethods add: aMethodToPushUp.

	self assertIsValidToPushUp: dependantMethods.
	self assertIsValidToRemove: subclassesToRemoveMethodFrom.
	
	^self new 
		initializeForAll: dependantMethods 
		of: aMethodToPushUp 
		additionallyRemovingFrom: subclassesToRemoveMethodFrom.! !
!PushUpMethod class methodsFor: 'warnings' stamp: 'HAW 3/23/2025 10:26:28' prior: 16935780!
                               warnIfDifferentImplementationInSuperclass: methods

	| methodsImplementedInSuperclass |
	
	methodsImplementedInSuperclass := methods 	
		select: [ :method | self checkIfMethodIsImplementedInSuperclass: method ]
		thenCollect: [ :method | method selector].
		
	methodsImplementedInSuperclass ifNotEmpty: [ 
		self refactoringWarning: (self methodWithDifferentImplementationInSuperclass: methodsImplementedInSuperclass)].
	
	
! !

PushUpMethod removeSelector: #initializeForAll:additionallyRemovingFrom:!

PushUpMethod removeSelector: #initializeFor:additionallyRemovingFrom:!

!methodRemoval: PushUpMethod #initializeFor:additionallyRemovingFrom: stamp: 'Install-7090-ProperInstVarMethodInitialization-HernanWilkinson-2025Mar22-21h30m-HAW.001.cs.st 5/13/2025 17:35:47'!
initializeFor: aMethods additionallyRemovingFrom: aSubclassesToRemoveMethodFrom

	methods := aMethods.
	subclassesToRemoveMethodFrom := aSubclassesToRemoveMethodFrom.!

PushUpMethod removeSelector: #selector!

!methodRemoval: PushUpMethod #selector stamp: 'Install-7090-ProperInstVarMethodInitialization-HernanWilkinson-2025Mar22-21h30m-HAW.001.cs.st 5/13/2025 17:35:47'!
selector
	
	^methods anyOne selector!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7090-ProperInstVarMethodInitialization-HernanWilkinson-2025Mar22-21h30m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7084] on 23 March 2025 at 10:51:17 am'!
!InlineMethodApplier methodsFor: 'refactoring - parameters request' stamp: 'HAW 3/23/2025 10:49:26' prior: 16879234!
                     askIfImplementorShouldBeRemoved: aMessage

	shouldRemoveImplementor := PopUpMenu confirm: aMessage orCancel: [ self endRequest ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7091-AllowsToCancelInlineMethod-HernanWilkinson-2025Mar23-10h41m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7091] on 23 March 2025 at 4:05:25 pm'!
!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/23/2025 16:01:57' prior: 16959907 overrides: 16908997!
                              valueAtTime: millisecondClock

	|  nArgs millisecondsSinceLast answer |
	numArgs ifNil: [numArgs := selector numArgs].
	nArgs := arguments ifNil: [0] ifNotNil: [arguments size].
	lastEvaluationTime ifNil: [ lastEvaluationTime := millisecondClock ].
	millisecondsSinceLast := millisecondClock - lastEvaluationTime.
	lastEvaluationTime := millisecondClock.
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self value ].
	[
		arguments
			ifNil: [ answer := receiver perform: selector with: millisecondsSinceLast]
			ifNotNil: [ answer := receiver perform: selector withArguments: (arguments copyWith: millisecondsSinceLast) ]
	] ifError: [ :err :rcvr |
		receiver
			stopStepping;
			setProperty: #errorOnStep toValue: true.
		{ 'Error while stepping: '. self. rcvr. err } print.
		"Install the old error handler, so we can re-raise the error"
		rcvr error: err.
	].
	^answer! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 3/23/2025 15:57:49' prior: 16986102!
           debugMenuOptions

	^`{
			{
				#submenuOf  		-> 		TheWorldMenu debugLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 				-> 		'Inspect World'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#inspect.
				#icon 				-> 		#inspectIcon.
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu debugLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 				-> 		'Explore World'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#explore.
				#icon 				-> 		#exploreIcon.
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu debugLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 				-> 		'MessageTally all Processes'.
				#selector 			-> 		#startMessageTally.
				#icon 				-> 		#systemMonitorIcon.
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu debugLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 				-> 		'Start drawing all again'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#removeAllKnownFailing.
				#icon 				-> 		#graphicsIcon.
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu debugLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 				-> 		'Start stepping again'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#resumeAfterStepError.
				#icon 				-> 		#mediaPlaybackStartIcon.
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu debugLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 				-> 		'Close all Debuggers'.
				#object 			-> 		DebuggerWindow.
				#selector 			-> 		#closeAllDebuggers.
				#icon 				-> 		#closeIcon.
			} asDictionary.
		}`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7092-startSteppingAgain-JuanVuletich-2025Mar23-15h55m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7071] on 18 March 2025 at 9:25:43 am'!
!ExtractToTemporary methodsFor: 'private - applying steps' stamp: 'JEC 3/18/2025 09:20:04'!
                  temporariesDeclarationInterval

	^ (completeSourceRanges 
		at: parseNodeWithNewVariableScope temporariesDeclaration
		ifAbsent: [self shouldNotHappen]) first! !
!ExtractToTemporary methodsFor: 'private - applying steps' stamp: 'JEC 3/18/2025 09:23:31'!
  updatedSourceCodeHasSpaceAt: lastSeparatorIndex

	^ (updatedSourceCode at: lastSeparatorIndex ifAbsent: [ self shouldNotHappen ]) = Character space! !
!ExtractToTemporary methodsFor: 'private - applying steps' stamp: 'JEC 3/18/2025 09:23:37' prior: 16859771!
                             positionToInsertNewVariableDeclaration

	| lastSeparatorIndex |
	lastSeparatorIndex := self temporariesDeclarationInterval last.
	
	^ (self updatedSourceCodeHasSpaceAt: lastSeparatorIndex - 1)
		ifTrue: [ lastSeparatorIndex - 1 ]
		ifFalse: [ lastSeparatorIndex ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7093-ExtractToTemporaryBugFix-JEC.001.cs.st----!

'From Cuis7.3 [latest update: #7093] on 31 March 2025 at 3:40:40 pm'!
!Morph methodsFor: 'layout' stamp: 'jmv 3/31/2025 15:00:56' prior: 16907334!
                        minimumLayoutExtent: cachedValues
	"I combine information from a Morph and its optional LayoutSpec.
	Answer is expressed in owner's coordinates."

	^cachedValues at: self ifAbsentPut: [
		self externalizeDistance: self minimumExtent ].! !
!PlacedMorph methodsFor: 'layout' stamp: 'jmv 3/31/2025 15:01:28' prior: 16924013 overrides: 50365468!
          minimumLayoutExtent: cachedValues
	"I combine information from a Morph and its optional LayoutSpec.
	Answer is expressed in owner's coordinates."
	| minExtent |

	^cachedValues at: self ifAbsentPut: [
		minExtent :=  self externalizeDistance: self minimumExtent.
		layoutSpec
			ifNil: [ minExtent ] 
			ifNotNil: [ :ls | minExtent max: ls minimumSpecExtent ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7094-LayoutFix-JuanVuletich-2025Mar31-15h39m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7093] on 31 March 2025 at 3:41:00 pm'!
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 3/31/2025 15:37:48' prior: 16923782 overrides: 16906247!
            externalizeDistance: aPoint
	"aPoint is in own coordinates. Answer is in owner's coordinates."
	^ (location externalizeDelta: aPoint) abs! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7095-externalizeDistance-fix-JuanVuletich-2025Mar31-15h40m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7086] on 18 March 2025 at 3:57:36 pm'!
!VectorEngineWithPluginWholePixel commentStamp: 'jmv 3/18/2025 15:52:48' prior: 17004973!
            Does only whole pixel antialiasing. Appropriate for very high resolution displays, or slower systems where the extra computational load of VectorEngineWithPluginSubPixel is not affordable.
Variables edgeCounts and alphaMask are single byte per pixel.

Uses VectorEnginePlugin for performance.

Note: As a performance optimization, target is opaque. This means that any translucency (alpha channel) in targetForm is ignored on input, and set to opaque (255) on the primBlend* operations. The 'WPOT' suffix in these primitives means 'Whole Pixel AA, Opaque Target'.

If you need target translucency computed correctly, please use VectorEngineWithPlginSubPixel (maybe setting subPixelDelta to 0.0, to effectively disable subpixel rasterization).!
!Morph methodsFor: 'drawing' stamp: 'jmv 3/18/2025 15:56:50' prior: 16905078!
          imageFormVG: extentOrNil depth: depth
	"Draw using a VectorCanvas
	Scale as needed. Draw unrotated."

	| prevNotVisibleFlag bounds extent fauxLocation answer auxCanvas |
	"Position and scale us in order to fill required extent, but disregard any rotation.
	Do it without triggering any invalidation at all."
	prevNotVisibleFlag := self privateFlagAt: 3.
	[
		bounds := self findFullBoundsInOwner.
		extentOrNil
			ifNotNil: [ | scale |
				extent := extentOrNil.
				scale := extent x asFloat / bounds width min: extent y asFloat / bounds height.
				fauxLocation := AffineTransformation withScale: scale position: bounds origin negated +1 * scale ]
			ifNil: [
				extent := bounds extent.
				fauxLocation := MorphicTranslation withTranslation: bounds origin negated ].
		answer := Form extent: extent depth: 32.
		"Ask for a Canvas with subpixels so it can also handle translucent target.
		This is relevant if #isPluginAvailable is true, and we're using the plugin, as the Smalltalk engine does proper
		target translucency both in subPixel and wholePixel AA variants."
		auxCanvas := VectorCanvas onFormWithSubPixelAntiAliasing: answer.
		auxCanvas geometryTransformation: fauxLocation.
		"But disable subpixel anti aliasing, as we are answering a Form, and therefore can't assume a Display geometry."
		auxCanvas engine disableSubPixelSampling.
		depth = 32 ifFalse: [
			"Only 32 bpp can hold translucent anti aliasing over transparent background"
			answer fillColor: Color veryLightGray ].
		self privateFlagAt: 3 put: false.
		auxCanvas fullDraw: self.
	] ensure: [
		self privateFlagAt: 3 put: prevNotVisibleFlag ].
	^answer asFormOfDepth: depth.! !
!Morph methodsFor: 'geometry services' stamp: 'jmv 3/18/2025 15:57:06' prior: 50360573!
           bitMask
	"Answer an 1bpp Form with our bitMask.
	Include all pixels drawn by any morph in our submorphs tree.
	Query with #pixelValueAt:
	Pixels drawn by us (or any submorph) are 0. Pixels not drawn by us (or any submorph) are 1.
	Remember to do `self removeProperty: #bitMask when appropriate!!
	(i.e. when we change in such a way to make the bitMask invalid)
	
	Also see senders of #contour"

	| prevNotVisibleFlag bounds answer auxCanvas |

	(self valueOfProperty: #bitMask) ifNotNil: [ :bitMask |
		^bitMask ].

	"Position and scale us in order to fill required extent, but disregard any rotation.
	Do it without triggering any invalidation at all."
	prevNotVisibleFlag := self privateFlagAt: 3.
	bounds := self findFullBoundsInOwner.
	[
		answer := Form extent: bounds extent depth: 32.
		"Ask for a Canvas with subpixels so it can also handle translucent target.
		This is relevant if #isPluginAvailable is true, and we're using the plugin, as the Smalltalk engine does proper
		target translucency both in subPixel and wholePixel AA variants."
		auxCanvas := VectorCanvas onFormWithSubPixelAntiAliasing: answer translation: bounds origin negated.
		"But disable subpixel anti aliasing, as we are answering a Form, and therefore can't assume a Display geometry."
		auxCanvas engine disableSubPixelSampling.
		self privateFlagAt: 3 put: false.
		auxCanvas fullDraw: self.
	] ensure: [
		self privateFlagAt: 3 put: prevNotVisibleFlag ].
	^self setProperty: #bitMask toValue:
		"Reverse it so we get bit=1 for affected pixels."
		((answer asGrayForm: 1) asFormOfDepth: 1) reverse.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7096-commentTweaks-JuanVuletich-2025Mar18-15h52m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7081] on 18 March 2025 at 4:48:23 pm'!
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 8/10/2021 12:06:05' prior: 17002876 overrides: 17002504!
       blendFillOnly
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex antiAliasAlphasWord |
	spanTop to: spanBottom do: [ :displayY |
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.

			edgesThisPixel := edgeCounts bytesAt: pixelIndex.
			edgeCounts at: pixelIndex put: 0.
			edgesThisPixelR := edgesThisPixel at: 3.
			edgesThisPixelG := edgesThisPixel at: 2.
			edgesThisPixelB := edgesThisPixel at: 1.

			"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
			edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
			edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
			edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].

			edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
			edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
			edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
			isRedInside := edgesUpToThisPixelR ~= 0.
			isGreenInside := edgesUpToThisPixelG ~= 0.
			isBlueInside := edgesUpToThisPixelB ~= 0.

			antiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			antiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
				alphaMask at: pixelIndex put: 0 ].
			(antiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] or: [
				isRedInside or: [ isGreenInside or: [ isBlueInside ]]]) ifTrue: [
					"At least one subpixel inside the shape, or in the anti aliasing area"
					self blendFillOnlyAt: pixelIndex
						redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
						antiAliasAlphasWord: antiAliasAlphasWord ]]].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/18/2025 16:39:19' prior: 17002948!
      blendFillOnlyAt: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside antiAliasAlphasWord: antiAliasAlphasWord
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB alphaRBits alphaGBits alphaBBits alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB resultAlpha targetAlpha clippingAntiAlias |

	"In this method, antiAliasAlphas are not used to blend stroke, but fill.
	This means that in the inside of the shape, and away from the stroke, they must be 1.0 (not 0.0).
	Next lines try to be in a simd friendly style."
	alphaRBits := antiAliasAlphasWord at: 3.
	alphaGBits := antiAliasAlphasWord at: 2.
	alphaBBits := antiAliasAlphasWord at: 1.
	isRedInside ifTrue: [ alphaRBits := 127 - alphaRBits ].
	isGreenInside ifTrue: [ alphaGBits := 127 - alphaGBits ].
	isBlueInside ifTrue: [ alphaBBits := 127 - alphaBBits ].
	alphaR := alphaRBits / 127.0.
	alphaG := alphaGBits / 127.0.
	alphaB := alphaBBits / 127.0.
	alphaR := alphaR * fillColor alpha.
	alphaG := alphaG * fillColor alpha.
	alphaB := alphaB * fillColor alpha.

	currentClipsSubmorphs
		ifTrue: [
			"Don't clip us, but do clip submorphs"
			clippingAntiAlias := (morphIds at: pixelIndex) bitAnd: 127.
			clippingAntiAlias := clippingAntiAlias max: alphaGBits]
		ifFalse: [
			clipCurrentMorph
				ifTrue: [
					"Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use."
					clippingAntiAlias := (morphIds at: pixelIndex) bitAnd: 127.
					alphaR := alphaR * clippingAntiAlias / 127.0.
					alphaG := alphaG * clippingAntiAlias / 127.0.
					alphaB := alphaB * clippingAntiAlias / 127.0 ]
				ifFalse: [
					"Don't do any additional clipping or preparation for further clipping"
					clippingAntiAlias := 0]].

	alphaR + alphaG + alphaB = 0.0 ifFalse: [
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.

		"These if are not really needed. just ignore them if we use simd instructions."
		alphaR = 0.0 ifFalse: [
			unAlphaR := 1.0 - alphaR.
			resultAlpha := alphaR + (unAlphaR * targetAlpha).
			resultR := alphaR * fillColor red * 255 + (unAlphaR * (targetWord at: 3) * targetAlpha).
			resultR := resultR/resultAlpha.
			targetWord at: 3 put: resultR rounded ].

		alphaG = 0.0 ifFalse: [
			unAlphaG := 1.0 - alphaG.
			resultAlpha := alphaG + (unAlphaG * targetAlpha).
			resultG := alphaG * fillColor green * 255 + (unAlphaG * (targetWord at: 2) * targetAlpha).
			resultG := resultG/resultAlpha.
			targetWord at: 2 put: resultG rounded.
			targetWord at: 4 put: (resultAlpha*255) rounded ].

		alphaB = 0.0 ifFalse: [
			unAlphaB := 1.0 - alphaB.
			resultAlpha := alphaB + (unAlphaB * targetAlpha).
			resultB := alphaB * fillColor blue * 255 + (unAlphaB * (targetWord at: 1) * targetAlpha).
			resultB := resultB/resultAlpha.
			targetWord at: 1 put: resultB rounded ].

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId<<8 + clippingAntiAlias ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 09:00:37' prior: 17003062 overrides: 17002509!
             blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord |
	spanTop to: spanBottom do: [ :displayY |
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.

			edgesThisPixel := edgeCounts bytesAt: pixelIndex.
			edgeCounts at: pixelIndex put: 0.
			edgesThisPixelR := edgesThisPixel at: 3.
			edgesThisPixelG := edgesThisPixel at: 2.
			edgesThisPixelB := edgesThisPixel at: 1.

			"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
			edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
			edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
			edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].

			edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
			edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
			edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
			isRedInside := edgesUpToThisPixelR ~= 0.
			isGreenInside := edgesUpToThisPixelG ~= 0.
			isBlueInside := edgesUpToThisPixelB ~= 0.

			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
				alphaMask at: pixelIndex put: 0 ].
			(strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] or: [
				isRedInside or: [ isGreenInside or: [ isBlueInside ]]]) ifTrue: [
					"At least one subpixel in the stroke or inside the shape"
					self blendStrokeAndFillAt: pixelIndex
						redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
						antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/18/2025 16:42:49' prior: 17003137!
     blendStrokeAndFillAt: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside antiAliasAlphasWord: strokeAntiAliasAlphasWord
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB strokeAARedAlphaBits strokeAARedAlpha strokeAAGreenAlphaBits strokeAAGreenAlpha strokeAABlueAlphaBits strokeAABlueAlpha alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB foreR foreG foreB targetAlpha resultAlpha clippingAntiAlias |

	"Next lines try to be in a simd friendly style."
	strokeAARedAlphaBits := strokeAntiAliasAlphasWord at: 3.
	strokeAAGreenAlphaBits := strokeAntiAliasAlphasWord at: 2.
	strokeAABlueAlphaBits := strokeAntiAliasAlphasWord at: 1.
	strokeAARedAlpha := strokeAARedAlphaBits / 127.0.
	strokeAAGreenAlpha := strokeAAGreenAlphaBits / 127.0.
	strokeAABlueAlpha := strokeAABlueAlphaBits / 127.0.

	isRedInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaR := strokeAARedAlpha * strokeColor alpha + ((1.0-strokeAARedAlpha) * fillColor alpha).
			foreR := strokeAARedAlpha * strokeColor red * 255 + ((1.0-strokeAARedAlpha) * fillColor red * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaR := strokeAARedAlpha * strokeColor alpha.
			foreR := strokeColor red * 255 ].

	isGreenInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaG := strokeAAGreenAlpha * strokeColor alpha + ((1.0-strokeAAGreenAlpha) * fillColor alpha).
			foreG := strokeAAGreenAlpha * strokeColor green * 255 + ((1.0-strokeAAGreenAlpha) * fillColor green * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaG := strokeAAGreenAlpha * strokeColor alpha.
			foreG := strokeColor green * 255 ].

	isBlueInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaB := strokeAABlueAlpha * strokeColor alpha + ((1.0-strokeAABlueAlpha) * fillColor alpha).
			foreB := strokeAABlueAlpha * strokeColor blue * 255 + ((1.0-strokeAABlueAlpha) * fillColor blue * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaB := strokeAABlueAlpha * strokeColor alpha.
			foreB := strokeColor blue * 255 ].

	currentClipsSubmorphs
		ifTrue: [
			"Don't clip us, but do clip submorphs"
			isGreenInside
				ifTrue: [clippingAntiAlias := 127]
				ifFalse: [
					clippingAntiAlias := (morphIds at: pixelIndex) bitAnd: 127.
					clippingAntiAlias := clippingAntiAlias max: strokeAAGreenAlphaBits]]
		ifFalse: [
			clipCurrentMorph
				ifTrue: [
					"Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use."
					clippingAntiAlias := (morphIds at: pixelIndex) bitAnd: 127.
					alphaR := alphaR * clippingAntiAlias / 127.0.
					alphaG := alphaG * clippingAntiAlias / 127.0.
					alphaB := alphaB * clippingAntiAlias / 127.0 ]
				ifFalse: [
					"Don't do any additional clipping or preparation for further clipping"
					clippingAntiAlias := 0]].

	alphaR + alphaG + alphaB = 0.0 ifFalse: [
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.

		"These if are not really needed. just ignore them if we use simd instructions."
		alphaR = 0.0 ifFalse: [
			unAlphaR := 1.0 - alphaR.
			resultAlpha := alphaR + (unAlphaR * targetAlpha).
			resultR := alphaR * foreR + (unAlphaR * (targetWord at: 3) * targetAlpha).
			resultR := resultR/resultAlpha.
			targetWord at: 3 put: resultR rounded ].
		alphaG = 0.0 ifFalse: [
			unAlphaG := 1.0 - alphaG.
			resultAlpha := alphaG + (unAlphaG * targetAlpha).
			resultG := alphaG * foreG + (unAlphaG * (targetWord at: 2) * targetAlpha).
			resultG := resultG/resultAlpha.
			targetWord at: 2 put: resultG rounded.
			targetWord at: 4 put: (resultAlpha*255) rounded ].
		alphaB = 0.0 ifFalse: [
			unAlphaB := 1.0 - alphaB.
			resultAlpha := alphaB + (unAlphaB * targetAlpha).
			resultB := alphaB * foreB + (unAlphaB * (targetWord at: 1) * targetAlpha).
			resultB := resultB/resultAlpha.
			targetWord at: 1 put: resultB rounded ].

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId<<8 + clippingAntiAlias ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 09:00:49' prior: 17003280 overrides: 17002514!
                  blendStrokeOnly
	"Blends stroke color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphasWord |
	spanTop to: spanBottom do: [ :displayY |
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			"At least one subpixel in the stroke."
			strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] ifFalse: [
				alphaMask at: pixelIndex put: 0.
				self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/18/2025 16:44:47' prior: 17003308!
       blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord
	"Blends stroke color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB alphaRBits alphaGBits alphaBBits alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB resultAlpha targetAlpha clippingAntiAlias |

	"Next lines try to be in a simd friendly style."
	alphaRBits := strokeAntiAliasAlphasWord at: 3.
	alphaGBits := strokeAntiAliasAlphasWord at: 2.
	alphaBBits := strokeAntiAliasAlphasWord at: 1.
	alphaR := alphaRBits / 127.0.
	alphaG := alphaGBits / 127.0.
	alphaB := alphaBBits / 127.0.
	alphaR := alphaR * strokeColor alpha.
	alphaG := alphaG * strokeColor alpha.
	alphaB := alphaB * strokeColor alpha.

	currentClipsSubmorphs
		ifTrue: [
			"Don't clip us, but do clip submorphs"
			clippingAntiAlias := (morphIds at: pixelIndex) bitAnd: 127.
			clippingAntiAlias := clippingAntiAlias max: alphaGBits]
		ifFalse: [
			clipCurrentMorph
				ifTrue: [
					"Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use."
					clippingAntiAlias := (morphIds at: pixelIndex) bitAnd: 127.
					alphaR := alphaR * clippingAntiAlias / 127.0.
					alphaG := alphaG * clippingAntiAlias / 127.0.
					alphaB := alphaB * clippingAntiAlias / 127.0 ]
				ifFalse: [
					"Don't do any additional clipping or preparation for further clipping"
					clippingAntiAlias := 0]].

	alphaR + alphaG + alphaB = 0.0 ifFalse: [
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.

		"These if are not really needed. just ignore them if we use simd instructions."
		alphaR = 0.0 ifFalse: [
			unAlphaR := 1.0 - alphaR.
			resultAlpha := alphaR + (unAlphaR * targetAlpha).
			resultR := alphaR * strokeColor red * 255 + (unAlphaR * (targetWord at: 3) * targetAlpha).
			resultR := resultR/resultAlpha.
			targetWord at: 3 put: resultR rounded ].

		alphaG = 0.0 ifFalse: [
			unAlphaG := 1.0 - alphaG.
			resultAlpha := alphaG + (unAlphaG * targetAlpha).
			resultG := alphaG * strokeColor green * 255 + (unAlphaG * (targetWord at: 2) * targetAlpha).
			resultG := resultG/resultAlpha.
			targetWord at: 2 put: resultG rounded.
			targetWord at: 4 put: (resultAlpha*255) rounded ].

		alphaB = 0.0 ifFalse: [
			unAlphaB := 1.0 - alphaB.
			resultAlpha := alphaB + (unAlphaB * targetAlpha).
			resultB := alphaB * strokeColor blue * 255 + (unAlphaB * (targetWord at: 1) * targetAlpha).
			resultB := resultB/resultAlpha.
			targetWord at: 1 put: resultB rounded ].

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId<<8 + clippingAntiAlias ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 09:01:25' prior: 50362536 overrides: 17002509!
              blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixel edgesThisPixel pixelIndex strokeAntiAliasAlphaBits |
	spanTop to: spanBottom do: [ :displayY |
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			edgesThisPixel := edgeCounts at: pixelIndex.
			edgesThisPixel = 0 ifFalse: [
				edgeCounts at: pixelIndex put: 0.
				"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
				edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
				edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
			strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
			strokeAntiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ].
			edgesUpToThisPixel = 0
				ifFalse: [			"Inside the shape"
					self blendStrokeAndFillAt: pixelIndex isInside: true antiAliasAlphaByte: strokeAntiAliasAlphaBits ]
				ifTrue: [			"Still in the stroke, but outside the shape, strictly speaking."
					strokeAntiAliasAlphaBits = 0 ifFalse: [
						self blendStrokeAndFillAt: pixelIndex isInside: false antiAliasAlphaByte: strokeAntiAliasAlphaBits ]]]].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/18/2025 16:47:11' prior: 17003781!
              blendStrokeAndFillAt: pixelIndex isInside: isInside antiAliasAlphaByte: strokeAntiAliasAlphaBits
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB strokeAAAlpha alpha unAlpha foreR foreG foreB targetAlpha resultAlpha clippingAntiAlias |

	strokeAAAlpha := strokeAntiAliasAlphaBits / 127.0.

	isInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha := strokeAAAlpha * strokeColor alpha + ((1-strokeAAAlpha) * fillColor alpha).
			foreR := strokeAAAlpha * strokeColor red * 255 + ((1-strokeAAAlpha) * fillColor red * 255).
			foreG := strokeAAAlpha * strokeColor green * 255 + ((1-strokeAAAlpha) * fillColor green * 255).
			foreB := strokeAAAlpha * strokeColor blue * 255 + ((1-strokeAAAlpha) * fillColor blue * 255) ]
		ifFalse: [							"Blend stroke over background"
			alpha := strokeAAAlpha * strokeColor alpha.
			foreR := strokeColor red * 255.
			foreG := strokeColor green * 255.
			foreB := strokeColor blue * 255 ].

	currentClipsSubmorphs
		ifTrue: [
			"Don't clip us, but do clip submorphs"
			isInside
				ifTrue: [clippingAntiAlias := 127]
				ifFalse: [
					clippingAntiAlias := (morphIds at: pixelIndex) bitAnd: 127.
					clippingAntiAlias := clippingAntiAlias max: strokeAntiAliasAlphaBits]]
		ifFalse: [
			clipCurrentMorph
				ifTrue: [
					"Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use."
					clippingAntiAlias := (morphIds at: pixelIndex) bitAnd: 127.
					alpha := alpha * clippingAntiAlias / 127.0 ]
				ifFalse: [
					"Don't do any additional clipping or preparation for further clipping"
					clippingAntiAlias := 0]].

	alpha = 0.0 ifFalse: [
		unAlpha := 1.0 - alpha.
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.
		resultAlpha := alpha + (unAlpha * targetAlpha).
		targetWord at: 4 put: (resultAlpha*255) rounded.

		resultR := alpha * foreR + (unAlpha * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded.

		resultG := alpha * foreG + (unAlpha * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.

		resultB := alpha * foreB + (unAlpha * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded.

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId<<8 + clippingAntiAlias ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 09:02:00' prior: 50362585 overrides: 17002514!
  blendStrokeOnly
	"Blends stroke color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphaBits |
	spanTop to: spanBottom do: [ :displayY |
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
			strokeAntiAliasAlphaBits = 0 ifFalse: [			"In the stroke"
				alphaMask at: pixelIndex put: 0.
				self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]]].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/18/2025 16:47:42' prior: 17003893!
              blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits
	"Blends stroke color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB alpha unAlpha resultAlpha targetAlpha clippingAntiAlias |
	alpha := strokeAntiAliasAlphaBits / 127.0.
	alpha := alpha * strokeColor alpha.

	currentClipsSubmorphs
		ifTrue: [
			"Don't clip us, but do clip submorphs"
			clippingAntiAlias := (morphIds at: pixelIndex) bitAnd: 127.
			clippingAntiAlias := clippingAntiAlias max: strokeAntiAliasAlphaBits ]
		ifFalse: [
			clipCurrentMorph
				ifTrue: [
					"Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use."
					clippingAntiAlias := (morphIds at: pixelIndex) bitAnd: 127.
					alpha := alpha * clippingAntiAlias / 127.0 ]
				ifFalse: [
					"Don't do any additional clipping or preparation for further clipping"
					clippingAntiAlias := 0]].

	alpha = 0.0 ifFalse: [
		unAlpha := 1.0 - alpha.
		targetWord := targetForm bits bytesAt: pixelIndex.

		targetAlpha := (targetWord at: 4) / 255.0.
		resultAlpha := alpha + (unAlpha * targetAlpha).
		targetWord at: 4 put: (resultAlpha*255) rounded.

		resultR := alpha * strokeColor red * 255 + (unAlpha * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded.

		resultG := alpha * strokeColor green * 255 + (unAlpha * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.

		resultB := alpha * strokeColor blue * 255 + (unAlpha * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded.

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId<<8 + clippingAntiAlias ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7097-BetterNaming-JuanVuletich-2025Mar18-16h25m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7097] on 14 April 2025 at 3:40:26 pm'!
!Rectangle commentStamp: 'jmv 4/14/2025 15:38:38' prior: 16937122!
  My instances represent a rectangular area of the screen. Arithmetic functions take points as arguments and carry out scaling and translating operations to create new instances of me. Rectangle functions create new instances by determining intersections of rectangles with rectangles.

Instance variables:
	origin	<Point> the coordinates of corner having smallest coordinates (top left in Screen coordinates)
	corner	<Point> the coordinates of corner having largest coordinates (bottom right in Screen coordinates)

Important notes:

 1: only rectangles parallel to reference frame (Screen) can be represented by this class.

 2: the Rectangle is represented by two extremities of one diagonal. By convention, it must be the diagonal:
	from rectangle origin (the point having smallest coordinates in reference frame),
	to rectangle corner (the point having largest coordinates in reference frame).

 3: Screen coordinates conventions are:
	x is horizontal axis, zero at left border, oriented toward right;
	y is vertical axis, zero at top border, oriented toward bottom.

 4: the Rectangle extent is obtained by subtracting rectangle origin to rectangle corner coordinates.
If this leads to a negative width (extent x coordinate) and/or a negative height (extent y coordinate), then the Rectangle is degenerated and considered empty.

 5: Instances of Rectangle contain the top left 'origin', but do not include the bottom right 'corner'. See for instance #containsPoint: . This has been like this since Smalltalk-80, and most likely since earlier. This convention is useful for working with pixel areas on the Display. The Rectangle `0@0 corner: 100@100` will have width = 100 and cover exactly 100 pixels wide. It will include point 0@0, but will not include point 100@100. Rectangles `0@0 corner: 100@100` and `100@0 corner: 200@100` do not overlap!!
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7098-Rectangle-classComment-JuanVuletich-2025Apr14-15h26m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7097] on 14 April 2025 at 3:43:38 pm'!
!TextModelMorph commentStamp: 'RMV 4/14/2025 15:43:26' prior: 16984706!
             This is a morph that enables users to view and edit text.

The main features of this class include:
- using either a TextModel or TextProvider to hold the text being edited
- styling and text wrapping (provided by InnerTextMorph)
- scrolling with scrollbars (provided by superclass PluggableScrollPane)

There are two approaches for creating instances. One approach is to hold the text value in a TextModel object. The class methods withModel: and withText: support this. The other approach is to hold the text value in a TextProvider. The class methods that begin with textProvider: support this. For examples, see the method comments in those class methods.

The default background color is white. A border is only displayed when it has focus. One way to make its bounds apparent when it doesn't have focus is to set the background color of the parent component. Another way is to set the background color of this morph.

By default, words that would extend past the right side wrap to the next line. To prevent wrapping, send an instance #wrapFlag: with an argument of false.

The default size is 200 by 100, set in the initialize method of the superclass PluggableMorph. Depending on the font, the default size displays around four lines of wrapping text with around 17 characters per line. To change the size, send an instance #morphExtent: with a Point argument that specifies a width and height. The size should include space for scroll bars if they may be needed. Setting the height to zero causes it to actually be set to the height required for a single line in the current font.

Related classes include TextModel, TextProvider, PluggableScrollPane, and InnerTextMorph.!
!TextModelMorph class methodsFor: 'instance creation' stamp: 'RMV 4/14/2025 15:43:01' prior: 16985090!
       textProvider: aTextProvider textGetter: getTextSel textSetter: setTextSel
	"aTextProvider must have corresponding getter and setter methods
	that manage the text to be edited.
	For example, we can use an instance of the Exception class
	which has the methods messageText and messageText:.

	Select and evaluate the code below.
	In the Inspector that appears, select the messageText instance variable.
	In the TextModelMorph that appears, change the text
	and note how it updates in the Inspector.

	| exception morph |
	exception := Exception new.
	exception messageText: 'initial'.
	exception inspect.
	morph := TextModelMorph textProvider: exception textGetter: #messageText textSetter: #messageText:.
	morph acceptOnAny: true.
	morph openInWorld.
	"
	^ self
		textProvider: aTextProvider
		textGetter: getTextSel
		textSetter: setTextSel
		selectionGetter: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7099-TextModelMorph-comments-R.MarkVolkmann-2025Apr14-15h40m-RMV.001.cs.st----!

'From Cuis7.3 [latest update: #7099] on 21 April 2025 at 4:53:49 pm'!
!ProgressMorph methodsFor: 'as yet unclassified' stamp: 'hlsf 4/21/2025 16:53:17' overrides: 16904561!
       layerNumber 
	^ 10! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7100-Make-ProgressMorph-topMost-HilaireFernandes-2025Apr21-16h53m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #7100] on 22 April 2025 at 4:38:06 pm'!
!TextProvider methodsFor: 'testing' stamp: 'HAW 4/22/2025 16:36:44'!
                isEditingExistingMethod

	^self isEditingMethod! !
!TextProvider methodsFor: 'testing' stamp: 'HAW 4/22/2025 16:36:44'!
        isEditingMethod

	^false! !
!ObjectExplorer methodsFor: 'testing' stamp: 'HAW 4/22/2025 16:37:36'!
                             isEditingExistingMethod

	^self isEditingMethod! !
!ObjectExplorer methodsFor: 'testing' stamp: 'HAW 4/22/2025 16:37:31'!
      isEditingMethod

	^false! !

CodeProvider removeSelector: #isEditingMethod!

!methodRemoval: CodeProvider #isEditingMethod stamp: 'Install-7101-AvoidsErrorWhenSearchingStringOnVariableInspectorInDegugger-HernanWilkinson-2025Apr22-16h31m-HAW.001.cs.st 5/13/2025 17:35:47'!
isEditingMethod

	^false!

CodeProvider removeSelector: #isEditingExistingMethod!

!methodRemoval: CodeProvider #isEditingExistingMethod stamp: 'Install-7101-AvoidsErrorWhenSearchingStringOnVariableInspectorInDegugger-HernanWilkinson-2025Apr22-16h31m-HAW.001.cs.st 5/13/2025 17:35:47'!
isEditingExistingMethod

	^self isEditingMethod!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7101-AvoidsErrorWhenSearchingStringOnVariableInspectorInDegugger-HernanWilkinson-2025Apr22-16h31m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7101] on 23 April 2025 at 1:54:34 pm'!
!CodeFileBrowser methodsFor: 'testing' stamp: 'jmv 4/23/2025 13:39:03' overrides: 16799455!
                 isEditingExistingClass

	^false! !
!CodeFileBrowser methodsFor: 'testing' stamp: 'jmv 4/23/2025 13:41:19' overrides: 50339768!
 isEditingExistingMethod

	^false! !
!CodeFileBrowser methodsFor: 'testing' stamp: 'jmv 4/23/2025 13:39:37' overrides: 16799459!
isEditingMethod

	^false! !
!CodeFileBrowser methodsFor: 'testing' stamp: 'jmv 4/23/2025 13:42:58' overrides: 16799464!
        isEditingNewClass

	^false! !
!SmalltalkCompleter methodsFor: 'entries - private' stamp: 'jmv 4/23/2025 13:42:29' prior: 16953569!
                             parse: source in: contextClass and: specificModel
	
	| isMethod |
	parser := SHParserST80 new.
	parser
		workspace: ((specificModel is: #providesBindings) ifTrue: [specificModel]);
		classOrMetaClass: contextClass;
		source: source.

	isMethod := (specificModel is: #Browser)
		ifTrue: [ specificModel isEditingMethod ]
		ifFalse: [ specificModel is: #CodeProvider ].
	parser parse: isMethod.

	^ parser rangesWithoutExcessCode.! !

CodeFileBrowser removeSelector: #isEditingNone!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7102-CodeFileBrowser-fix-JuanVuletich-2025Apr23-13h36m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7102] on 28 April 2025 at 8:21:53 pm'!
!Categorizer class methodsFor: 'well known categories' stamp: 'HAW 3/24/2025 18:18:48'!
                              accessing

	^'accessing'! !
!Browser methodsFor: 'class functions' stamp: 'HAW 3/24/2025 18:19:32' prior: 16797662!
            createInstVarAccessors
	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"
	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		aClass instVarNames do: [ :aName | | newMessage setter |
			(aClass canUnderstand: aName asSymbol) ifFalse: [
				newMessage := aName , '
	"Answer the value of ' , aName , '"

	^ ' , aName.
				aClass
					compile: newMessage
					classified: Categorizer accessing ].
			(aClass canUnderstand: (setter := aName , ':') asSymbol) ifFalse: [
				newMessage := setter , ' anObject
	"Set the value of ' , aName , '"

	' , aName , ' := anObject'.
				aClass
					compile: newMessage
					classified: Categorizer accessing ]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7103-AccessingCategory-HernanWilkinson-2025Apr28-20h21m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7102] on 28 April 2025 at 8:29:55 pm'!

Smalltalk renameClassNamed: #ParametersCountChange as: #ParametersSizeChange!

ChangeSelector subclass: #ParametersSizeChange
	instanceVariableNames: 'newImplementors changedSenders'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #ParametersSizeChange category: #'Tools-Refactoring' stamp: 'Install-7104-RefactoringParametersSizeChange-HernanWilkinson-2025Apr28-20h21m-HAW.001.cs.st 5/13/2025 17:35:47'!
ChangeSelector subclass: #ParametersSizeChange
	instanceVariableNames: 'newImplementors changedSenders'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ParametersSizeChange subclass: #AddParameter
	instanceVariableNames: 'newParameter newParameterValue implementorTrailingString senderTrailingString index isAddingLast '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #AddParameter category: #'Tools-Refactoring' stamp: 'Install-7104-RefactoringParametersSizeChange-HernanWilkinson-2025Apr28-20h21m-HAW.001.cs.st 5/13/2025 17:35:47'!
ParametersSizeChange subclass: #AddParameter
	instanceVariableNames: 'newParameter newParameterValue implementorTrailingString senderTrailingString index isAddingLast'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ParametersSizeChange subclass: #RemoveParameter
	instanceVariableNames: 'parameterToRemove parameterIndex senderReplacementString isLastParameter '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RemoveParameter category: #'Tools-Refactoring' stamp: 'Install-7104-RefactoringParametersSizeChange-HernanWilkinson-2025Apr28-20h21m-HAW.001.cs.st 5/13/2025 17:35:47'!
ParametersSizeChange subclass: #RemoveParameter
	instanceVariableNames: 'parameterToRemove parameterIndex senderReplacementString isLastParameter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!CharacterSequence methodsFor: 'copying' stamp: 'HAW 3/23/2025 20:47:53'!
copyReplacing: ranges withAll: newStrings

	"Ranges must be in order, with first ranges first. If not, result is unexpected
	newStrings must follow ranges order
	ranges and newString must have same size - Hernan"

	^ self species streamContents: [ :replacementStream |
		self copyReplacing: ranges withAll: newStrings into: replacementStream ]
		! !
!CharacterSequence methodsFor: 'copying' stamp: 'HAW 3/23/2025 20:44:47'!
                        copyReplacing: ranges withAll: newStrings into: replacementStream

	| from |

	from := 1.
	ranges 
		with: newStrings 
		do: [ :aRange :newString |
			from := self 
				newFromAfterAppending: newString 
				into: replacementStream 
				keepingFrom: from 
				skipping: aRange ].

	replacementStream nextPutAll: (self copyFrom: from to: self size).! !
!ParametersSizeChange methodsFor: 'rename senders - private' stamp: 'HAW 3/23/2025 14:15:59' overrides: 16805919!
               renameSendersIn: aMethod

	| changedSender |
	
	changedSender := super renameSendersIn: aMethod.
	
	changedSenders add: changedSender! !
!ParametersSizeChange methodsFor: 'changes' stamp: 'HAW 3/23/2025 19:43:09'!
          changedSenders
	
	^changedSenders! !
!ParametersSizeChange methodsFor: 'changes' stamp: 'HAW 3/23/2025 19:42:55'!
              newImplementors
	
	^newImplementors! !
!ParametersSizeChange methodsFor: 'initialization' stamp: 'HAW 3/23/2025 14:17:26' overrides: 16805939!
                 initializeFrom: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders

	super initializeFrom: anOldSelector to: aNewSelector implementors: aCollectionOfImplementors senders: aCollectionOfSenders.
	
	newImplementors := Set new.
	changedSenders := Set new! !
!ParametersSizeChange methodsFor: 'create new implementors - private' stamp: 'HAW 3/23/2025 14:14:17' overrides: 16805829!
                     createNewImplementorOf: anImplementor

	| newImplementor |
	
	newImplementor := super createNewImplementorOf: anImplementor.
	
	newImplementors add: newImplementor 
	
	! !
!ChangeSelector methodsFor: '*ExtractParameterObject-create new implementors - private' stamp: 'HAW 3/23/2025 14:14:06' prior: 16805829!
           createNewImplementorOf: anImplementor

	| newImplementor |

	self compileNewImplementorOf: anImplementor.
	newImplementor := anImplementor methodClass compiledMethodAt: newSelector.
	self addToSendersIfOldSelectorIsSentIn: newImplementor.
	
	^ changes add: newImplementor methodReference.
	
	! !
!ChangeSelector methodsFor: '*ExtractParameterObject-rename senders - private' stamp: 'HAW 3/23/2025 14:15:14' prior: 16805919!
                        renameSendersIn: aMethod

	| newSource rangesToNewStrings |

	rangesToNewStrings := self rangesToKeywordsOf: aMethod.
	newSource := aMethod sourceCode copyReplacing: rangesToNewStrings.
	aMethod methodClass compile: newSource.

	^changes add: (MethodReference method: aMethod)! !
!AddParameter methodsFor: 'initialization' stamp: 'HAW 9/4/2018 19:00:42' prior: 16779594!
             initializedNamed: aNewParameter 
	at: anIndex
	addingLast: anIsAddingLast
	initializedWith: aNewParameterValue 
	to: anOldSelector 
	implementing: aNewSelector  
	addingToImplementors: anImplementorTrailingString 
	addingToSenders: aSenderTrailingString
	implementors: implementorsCollection 
	senders: sendersCollection

	super initializeFrom: anOldSelector to: aNewSelector implementors: implementorsCollection senders: sendersCollection.
	
	newParameter := aNewParameter.
	newParameterValue := aNewParameterValue.
	implementorTrailingString := anImplementorTrailingString.
	senderTrailingString := aSenderTrailingString.
	
	index := anIndex.
	isAddingLast := anIsAddingLast ! !

ParametersSizeChange subclass: #AddParameter
	instanceVariableNames: 'newParameter newParameterValue implementorTrailingString senderTrailingString index isAddingLast'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #AddParameter category: #'Tools-Refactoring' stamp: 'Install-7104-RefactoringParametersSizeChange-HernanWilkinson-2025Apr28-20h21m-HAW.001.cs.st 5/13/2025 17:35:47'!
ParametersSizeChange subclass: #AddParameter
	instanceVariableNames: 'newParameter newParameterValue implementorTrailingString senderTrailingString index isAddingLast'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

ParametersSizeChange subclass: #RemoveParameter
	instanceVariableNames: 'parameterToRemove parameterIndex senderReplacementString isLastParameter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RemoveParameter category: #'Tools-Refactoring' stamp: 'Install-7104-RefactoringParametersSizeChange-HernanWilkinson-2025Apr28-20h21m-HAW.001.cs.st 5/13/2025 17:35:47'!
ParametersSizeChange subclass: #RemoveParameter
	instanceVariableNames: 'parameterToRemove parameterIndex senderReplacementString isLastParameter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7104-RefactoringParametersSizeChange-HernanWilkinson-2025Apr28-20h21m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7102] on 28 April 2025 at 8:42:49 pm'!
!BrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 4/28/2025 20:41:47' prior: 50339848!
                       classListMenuSpec
	"Spec for the menu and shortcut keys for the class list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Class List' 					false)
		#(10	'New Subclass' 				nil 	model 		makeNewSubclass 					classIcon 		'put a template into the code pane for defining of a subclass of this class')
		#(20	'Copy Class...' 				nil 	model 		copyClass 							copyIcon)
		#(30	'Delete (x)' 					$x 	model 		removeClass 						deleteIcon)
		#(40 	'-----')
		#(50	'Browse Hierarchy (h)' 		$h 	window 	browseHierarchy 					goTopIcon)
		#(60	'Full Browse (b)' 				$b 	window 	browseMethodFull 					editFindReplaceIcon)
		#(70	'Browse Protocol (p)' 			$p 	window 	browseFullProtocol 				spreadsheetIcon)
		#(80	'Browse Package' 			nil 	window 	browsePackage 					packageIcon)
		#(90 	'-----')
		#(100	'File Out' 					nil 	model 		fileOutClass 						fileOutIcon)
		#(110	'File Out Alphabetically (o)' 	$o 	model 		fileOutClassAlphabetically 			fileOutIcon)
		#(120	'Run Tests (t)' 				$t 	model 		runClassTests 						weatherFewCloudsIcon)
		#(130 	'-----')
		#(140	'Refactorings' 				nil 	nil 			1000 								listAddIcon)
		#(150 	'-----')
		#(160	'Show classes Hierarchically' 	nil model 		enableListClassesHierarchically 	goTopIcon)
		#(170	'Show classes Alphabetically' 	nil model 		enableListClassesAlphabetically 	sendReceiveIcon)
		#(180	'Show Definition' 				nil 	model 		editClass 							editFindReplaceIcon)
		#(190	'Show Comment' 			nil 	model 		editComment 						editFindReplaceIcon)
		#(200 	'-----')
		#(210	'Class References (N)' 		$N 	window 	browseClassRefs 					classIcon)
		#(220 	'-----')
		#(230	'More...' 						nil 	nil 			2000 								listAddIcon)

		"Shortcut only. No menu entry."
		#(991	nil 							$r 	model 		recent)

		" 'refactorings' SubMenu"
		#(1010	'Rename Class... (R)' 			$R 	model 		renameClass 						saveAsIcon)
		#(1020	'Insert Superclass...' 			nil 	model 		insertSuperclass 					saveAsIcon)
		#(1030 	'-----')
		#(1040	'Add Inst Var...' 				nil 	model 		addInstVar 							listAddIcon)
		#(1050	'Rename Inst Var...' 			nil 	model 		renameInstVar 						saveAsIcon)
		#(1060	'Remove Inst Var...' 			nil 	model 		removeInstVar 						deleteIcon)
		#(1070	'Remove all Unreferenced Inst Var...' nil model 	removeAllUnreferencedInstVar 	deleteIcon)
		#(1080	'Push Up Inst Var...' 			nil 	model 		pushUpInstanceVariable 			goTopIcon)
		#(1090	'Push Down Inst Var...' 		nil 	model 		pushDownInstanceVariable 		goBottomIcon)
		#(1100 	'-----')
		#(1110	'Rename Global...' 			nil 	model 		renameGlobal 						saveAsIcon)

		" 'more' SubMenu"
		#(2010	'Unsent Methods' 			nil 	window 	browseUnusedMethods 			junkIcon 			'browse all methods defined by this class that have no senders')
		#(2020	'Unreferenced inst Vars' 		nil 	window 	showUnreferencedInstVars 		junkIcon 			'show a list of all instance variables that are not referenced in methods')
		#(2030	'Unreferenced class Vars' 		nil 	window 	showUnreferencedClassVars 		junkIcon 			'show a list of all class variables that are not referenced in methods')
		#(2040 	'-----')
		#(2050	'Sample instance' 			nil 	window 	makeSampleInstance 				instanceIcon 		'give me a sample instance of this class, if possible')
		#(2060	'Inspect instances' 			nil 	window 	inspectInstances 					inspectIcon 		'open an inspector on all the extant instances of this class')
		#(2070	'Inspect subinstances' 		nil 	window 	inspectSubInstances 				inspectIcon 		'open an inspector on all the extant instances of this class and of all of its subclasses')
		#(2080 	'-----')
		#(2090	'Create inst var accessors' 	nil 	model 		createInstVarAccessors 			sendReceiveIcon 	'compile instance-variable access methods for any instance variables that do not yet have them')
	)! !
!BrowserWindow methodsFor: 'menu & kbd shortcuts' stamp: 'HAW 4/28/2025 20:42:07' prior: 50340025!
                    messageListMenuSpec
	"Spec for the menu and shortcut keys for the messages list.
	See coment at Morph >> #getMenu
	"
	^#(
		#(0 		'Message List' 						false)
		#(10	'Browse Full (b)' 							$b 	window 	browseMethodFull 							editFindReplaceIcon)
		#(20	'Browse Hierarchy (h)' 					$h 	window 	browseHierarchy 							goTopIcon)
		#(30	'Browse Method (O)' 						$O 	window 	openSingleMessageBrowser 				scriptIcon)
		#(35	'Browse Package (p)' 						$p 	window 	browsePackage 							packageIcon)
		#(40 	'-----')
		#(50	'File Out (o)' 								$o 	model 		fileOutMessage 							fileOutIcon)
		#(60	'Run Test (t)' 							$t 	model 		runMethodTest 							weatherFewCloudsIcon)
		#(70	'Debug Test (r)' 							$r 	model 		debugMethodTest 							weatherFewCloudsIcon)
		#(80	'Inspect CompiledMethod' 				nil 	model 		inspectCompiledMethod 					exploreIcon)
		#(90 	'-----')
		#(100	'Refactorings' 							nil 	nil 			1000 										listAddIcon)
		#(110	'Senders of... (n)' 						nil 	window 	browseSendersOfMessages 				mailForwardIcon)
		#(120	'Implementors of... (m)' 					nil 	window 	browseImplementorsOfMessages 			developmentIcon)
		#(130	'Inheritance (i)' 							$i 	window 	methodInheritance 						goDownIcon)
		#(140	'Versions (v)' 							$v 	window 	browseVersions 							clockIcon)
		#(150 	'-----')
		#(160	'Remove Method (x)' 						$x 	model 		removeMessage 							deleteIcon)
		#(170	'Remove Method in Hierarchy' 			nil 	model 		removeMessageInHierarchy 				deleteIcon)
		#(180	'More...' 									nil 	nil 			2000 										listAddIcon)

		"Shortcut only. No menu entry."
		#(991	nil 										$m 	window 	browseImplementors)
		#(992	nil 										$n 	window 	browseSenders)
		#(993	nil 										$c 	model 		copySelector)

		" 'refactorings' SubMenu"
		#(1010	'Rename... (R)' 							$R 	model 		renameSelector 							saveAsIcon)
		#(1020	'Change keyword Order...' 				nil 	model 		changeKeywordOrder 						sendReceiveIcon)
		#(1030	'Add Parameter... (A)' 					$A 	model 		addParameter 								listAddIcon)
		#(1040	'Remove Parameter... (S)' 				$S 	model 		removeParameter 							listRemoveIcon)
		#(1050 	'-----')
		#(1060	'Inline Method... (F)' 						$F 	model 		inlineMethod 								saveAsIcon)
		#(1070	'Move to Instance/Class Method' 			nil 	model 		moveToInstanceOrClassMethod 			changesIcon)
		#(1080	'Push Up' 								nil 	model 		pushUpSelector 							goTopIcon)
		#(1090	'Add in Superclass as subclassResponsibility' nil model 		addAsSubclassResponsibilitySelector 		goTopIcon)
		#(1100	'Push Down to Subclasses' 				nil 	model 		pushDownSelectorToSubclasses 			goBottomIcon)
		#(1110	'Push Down to One Subclass' 				nil 	model 		pushDownSelectorToOneSubclass 			goBottomIcon)

		" 'more' SubMenu"
		#(2010	'Local Senders of...' 						nil 	window 	browseLocalSendersOfMessages 			mailForwardIcon)
		#(2020	'Local Implementors of...' 					nil 	window 	browseLocalImplementorsOfMessages 	classIcon)
		#(2030 	'-----')
		#(2040	'Sample Instance' 						nil 	window 	makeSampleInstance 						instanceIcon)
		#(2050	'Inspect Instances' 						nil 	window 	inspectInstances 							inspectIcon)
		#(2060	'Inspect Subinstances' 					nil 	window 	inspectSubInstances 						inspectIcon)
		#(2070 	'-----')
		#(2080	'Change Category...' 						nil 	model 		changeCategory 							saveAsIcon)
		#(2090	'Select method Category (C)' 				$C 	model 		showHomeCategory 						editFindReplaceIcon)
		#(2100	'Change sets with this Method' 			nil 	window 	findMethodInChangeSets 					changesIcon)
		#(2110	'Revert to previous Version' 				nil 	model 		revertToPreviousVersion 					undoIcon)
	)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7105-FileOutShortCuts-HernanWilkinson-2025Apr28-20h29m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7102] on 28 April 2025 at 8:45:28 pm'!
!SystemDictionary methodsFor: 'retrieving' stamp: 'HAW 4/28/2025 20:44:22' prior: 16966423!
                       allSentMessagesWithout: classesAndMessagesPair
	"Answer the set of selectors which are sent somewhere in the system, 
	computed in the absence of the supplied classes and messages."

	| sent absentClasses absentSelectors |
	sent := IdentitySet new.
	absentClasses := classesAndMessagesPair first.
	absentSelectors := classesAndMessagesPair second.
	self classNames do: [ :cName | 
		((absentClasses includes: cName)
				ifTrue: [#()]
				ifFalse: [{(self at: cName). (self at: cName) class}]) do: [ :cl |
			 (absentSelectors isEmpty
					ifTrue: [cl selectors]
					ifFalse: [cl selectors copyWithoutAll: absentSelectors]) do: [ :sel |
				 "Include all sels, but not if sent by self"
				self allSymbolsIn: (cl compiledMethodAt: sel) literals do: [ :m |
					m == sel ifFalse: [sent add: m] ]]]].
	"The following may be sent without being in any literal frame"
	1 to: self specialSelectorSize do: [ :index | 
		sent add: (self specialSelectorAt: index)].
	self presumedSentMessages do: [ :sel | sent add: sel].
	^ sent! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7106-allSentMessagesIndentationFix-HernanWilkinson-2025Apr28-20h42m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7102] on 28 April 2025 at 8:59:40 pm'!
!SystemWindow class methodsFor: 'menu and shortcuts' stamp: 'HAW 4/28/2025 20:56:13'!
                    at: aWidgetKey unregisterMenuAndShortcutsSpecProvider: aMessageSend

	menuNshortcutsProviders ifNotNil: [ 
		(menuNshortcutsProviders at: aWidgetKey ifAbsent: [ ^self ]) removeKey: aMessageSend ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7107-unregisterMenuSpec-HernanWilkinson-2025Apr28-20h45m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7102] on 29 April 2025 at 8:24:45 am'!
!SystemWindow class methodsFor: 'menu and shortcuts' stamp: 'HAW 4/28/2025 21:11:10'!
                        registerAll: specs

	specs do: [ :aSpec | self at: aSpec first registerMenuAndShortcutsSpecProvider: aSpec second ].
! !
!SystemWindow class methodsFor: 'menu and shortcuts' stamp: 'HAW 4/28/2025 21:11:32'!
                 unregisterAll: specs

	specs do: [ :aSpec | self at: aSpec first unregisterMenuAndShortcutsSpecProvider: aSpec second ].
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7108-RegisterUnregisterAllMenuSpecs-HernanWilkinson-2025Apr28-20h59m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7148] on 25 April 2025 at 1:47:24 pm'!
!SystemWindow methodsFor: 'geometry services' stamp: 'jmv 4/25/2025 13:43:45' prior: 16972496 overrides: 16906660!
                         fullyCoveredRectangle
	"Answer a Rectangle whe are certain is completely covered by us.
	Answer nil if we can't be certain about a better answer.
	This implementation is correct, although simplistic and uninteresting.
	This implementation is a good optimization for many common cases."

	| b e |
	"If we can't know better."
	self isOrAnyOwnerIsRotated ifTrue: [
		^ nil ].
	color mightBeTranslucent ifTrue: [
		^ nil ].
	b := self displayBounds.
	b isNil ifTrue: [
		^nil ].
	b := b insetBy: `2@2 corner: 1@1`.
	Theme current roundWindowCorners ifFalse: [
		^ b ].
	e := (self externalizeDistanceToWorld: 0@Theme current roundedWindowRadius) ceiling.
	^ b origin + e corner: b corner! !
!MorphicCanvas methodsFor: 'morphic world' stamp: 'jmv 4/25/2025 13:34:33' prior: 16910006!
                     gatherMorphDamage: rootMorphs rootsReportedDamage: rootsReportedDamage addDamageTo: allDamage
	"For each morph, remove any reported damage that is completely covered by another morph on top.
	Add any  areas that need to be redrawn to uncoveredDamage.
	uncoveredDamage will contain all the areas that need to be repaired. rootMorphsReportedDamage no longer relevant.
	Iterate from front to back"

	1 to: rootMorphs size do: [ :i | | thisMorphReportedDamage |
		thisMorphReportedDamage := rootsReportedDamage at: i.
		thisMorphReportedDamage ifNotNil: [
			"Iterate all morphs up to the one directly above us"
			1 to: i-1 do: [ :j |
				(self fullyCoveredRectangleOf: (rootMorphs at: j)) ifNotNil: [ :coveringR | | nonCoveredParts |
					nonCoveredParts := nil.
					1 to: thisMorphReportedDamage size do: [ :k |
						(thisMorphReportedDamage at: k) ifNotNil: [ :r |
							"If damage is completely covered, remove it. If it is partially covered, just keep uncovered parts."
							(coveringR intersects: r) ifTrue: [
								thisMorphReportedDamage at: k put: nil.
								(coveringR containsRect: r) ifFalse: [
									nonCoveredParts :=nonCoveredParts
										ifNil: [ r areasOutside: coveringR ]
										ifNotNil: [ nonCoveredParts, (r areasOutside: coveringR) ]]]]].
					nonCoveredParts ifNotNil: [
						thisMorphReportedDamage addAll: nonCoveredParts ]]].
			"Store"
			thisMorphReportedDamage do: [ :r |
				r ifNotNil: [
					"DebuggingAid"
					"Display fill: r fillColor: Color random. (Delay forSeconds: 0.01) wait."
					allDamage add: r ]]]].

	"Remove redundant rectangles"
	1 to: allDamage size do: [ :i1 |
		(allDamage at: i1) ifNotNil: [ :r1 |
			1 to: allDamage size do: [ :i2 |
				i1 = i2 ifFalse: [
					(allDamage at: i2) ifNotNil: [ :r2 |
						(r1 containsRect: r2)
							ifTrue: [ 
								allDamage at: i2 put: nil ]]]]]].! !
!AbstractVectorCanvas methodsFor: 'morphic world' stamp: 'jmv 4/25/2025 13:44:53' prior: 16778948 overrides: 16909868!
     boundingRectOfCurrentIfTrivial
	"In targetForm coordinates.
	Answer only if it can be known wothout drawing.
	Don't include any clipping."

	currentMorph knowsOwnLocalBounds ifTrue: [
		"Include an extra pixel to cover possible anti aliasing."
		^(currentTransformation externalBoundingRectOf: currentMorph localBounds)
			encompassingIntegerRectangle outsetBy: `0@0 corner: 1@1` ].
	^nil.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7109-FixDisplayArtifactsInVectorGraphics-JuanVuletich-2025Apr25-13h34m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7149] on 25 April 2025 at 3:51:42 pm'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 4/25/2025 15:50:31' prior: 16886133!
           tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results
	0 tinyBenchmarks

For Pre-Squeak systems, measurements or estimations from
	https://smalltalkzoo.computerhistory.org/papers/EvolutionOfSmalltalk.pdf
										('The evolution of Smalltalk: from Smalltalk-72 through Squeak' by Dan Ingalls, p.98)
	http://wiki.c2.com/?GreenBook
	http://www.wirfs-brock.com/allen/things/smalltalk-things/tektronix-smalltalk-document-archive/1982-qtr4-magnolia-perf-graph.pdf
	http://www.wirfs-brock.com/allen/things/smalltalk-things/tektronix-smalltalk-document-archive/1983-Magnolia-st-perf.pdf

Xerox PARC systems
	Alto Smalltalk-72 5MHz µcode					694 bytecodes/sec						54 sends/sec					7200 µclocks/bytecode
	Alto Smalltalk-74 5MHz µcode					607 bytecodes/sec						46 sends/sec					8200 µclocks/bytecode
	Alto Smalltalk-76 5MHz µcode					16k bytecodes/sec						118 sends/sec				310 µclocks/bytecode
	NoteTaker Smalltalk-78 5MHz 8086				30k bytecodes/sec						250 sends/sec				166.67 clocks/bytecode
	Dorado Smalltalk-76 16.67MHz µcode				1M bytecodes/sec						50k sends/sec				16.67 µClocks/bytecode

Green Book systems
	DEC PDP-11/23									5k bytecodes/sec (Green Book, p.128)
	Apple 5MHz 68000								11k bytecodes/sec (Green Book, p.187, awb)							5000 clocks/bytecode
	VAX-11/780 5MHz C HP Smalltalk					10k bytecodes/sec (Green Book, p.235)								450 clocks/bytecode
	VAX-11/780 5MHz C Berkeley St					17k bytecodes/sec (Green Book, p.203, awb)							300 clocks/bytecode
	DEC VAX-11/780 5MHz assembly					20k bytecodes/sec (Green Book, p.149, awb)							250 clocks/bytecode
	TEK Magnolia 10MHz 68000						50k bytecodes/sec (awb)												200 clocks/bytecode

Squeak & Cuis
	110 MHz PowerPC Mac 8100						4.1M bytecodes/sec;						175k sends/sec				26.8 clocks/bytecode 
	292 MHz G3 Mac:								23M bytecodes/sec;						984k sends/sec				12.7 clocks/bytecode
	400 MHz PII/Win98:								18M bytecodes/sec;						1.08M sends/sec				22.2 clocks/bytecode

	1GHz RISCV Sipeed Lichee RV StackSpur64 		35.56M bytecodes/sec;  					1.56M sends/sec  			28.1 clocks/bytecode

	900MHz RasPi2 - StackVM:						38M bytecodes/sec;						2.41M sends/sec				23.7 clocks/bytecode
	900MHz RasPi2- CogSSpur:						157M bytecodes/sec;						10.95M sends/sec			5.7 clocks/bytecode
	
	1GHz C.H.I.P. (*1) - StackVM:					55M bytecodes/sec;						3.35M sends/sec				18.2 clocks/bytecode
	1GHz C.H.I.P. (*1) - CogSpur:						254M bytecodes/sec;						16.85M sends/sec			3.9 clocks/bytecode
	
	1.2GHz RasPi3B - StackSpur:						44M bytecodes/sec;						2.77M sends/sec				27.2 clocks/bytecode
	1.2GHz RasPi3B - CogSpur:						282M bytecodes/sec;						16.40M sends/sec			4.3 clocks/bytecode

	1.66GHz Atom N450 - Cog:						244M bytecodes/sec;						28.80M sends/sec			6.8 clocks/bytecode
	1.66GHz Atom N450 - CogSpur:					470M bytecodes/sec;						30.75M sends/sec			3.5 clocks/bytecode

	1.33GHz Atom 3735G - Cog:						326M bytecodes/sec;						34.99M sends/sec			4.1 clocks/bytecode
	1.33GHz Atom 3735G - CogSpur:					632M bytecodes/sec;						33.69M sends/sec			2.1 clocks/bytecode

	1.5GHz AMD A4-5000 - Cog:						390M bytecodes/sec;						47.51M sends/sec			3.8 clocks/bytecode
	1.5GHz AMD A4-5000 - CogSpur:					676M bytecodes/sec;						40.67M sends/sec			2.2 clocks/bytecode
	1.5GHz AMD A4-5000 - CogSpur64:				659M bytecodes/sec;						50.34M sends/sec			2.3 clocks/bytecode

	1.5GHz ARM64 RasberryPi4 - CogSpur64: 			732.5M bytecodes/sec;  					53.95M sends/sec			2.0 clocks/bytecode

	2.3GHz Tegra ARM64 (*2) - StackVM:				259M bytecodes/sec;						13.01M sends/sec			8.9 clocks/bytecode
	2.3GHz Tegra ARM64(*2) - CogSpur:				1.08G bytecodes/sec;						64.29M sends/sec			2.1 clocks/bytecode
	2.4GHz RasPi5 (ARM64) 							1.60G bytecodes/sec;  					140.00M sends/sec  			1.5 clocks/bytecode

	3.1GHz Core i3-2100 - Cog:						1.20G bytecodes/sec;						165.72M sends/sec			2.6 clocks/bytecode
	3.1GHz Core i3-2100 - CogSpur:					2.04G bytecodes/sec;						127.84M sends/sec			1.5 clocks/bytecode

	2.70GHz Core i5-6400 -CogSpur64				3.16G bytecodes/sec;						243.32M sends/sec			0.85 clocks/bytecode
	
	2.4GHz Core i9-9980HK 2019-15-MBP 			2.9G bytecodes/sec; 						260M sends/sec 				0.83 clocks/bytecode
	
	4.05GHz Apple M3 MacBook Air					6.17G bytecode/sec; 						405M sends/sec 				0.66 clocks / bytecode

	(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
	(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz

100 Dorados make Morphic comfortable and nice to use.
1000 Dorados make Vector Graphics Morphic 3 comfortable and nice to use.
	"
	| t1 t2 r n1 n2 |
	n1 := 1.
	[
		t1 := Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue: [n1 := n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 := 28.
	[
		t2 := Time millisecondsToRun: [r := n2 benchFib].
		t2 < 1000] 
			whileTrue: [n2 := n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^String streamContents: [ :strm |
		(n1 * 500000 * 1000) // t1 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Bytecodes/second; ' ].
		(r * 1000) // t2 withDecimalUnitPrefixAndValue: [ :value  :unitPrefixSymbol :unitPrefixName |
			value printOn: strm fractionDigits: 2.
			strm
				space;
				nextPutAll: unitPrefixName;
				nextPutAll: 'Sends/second' ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7110-tinyBenchmarks-results-update-JuanVuletich-2025Apr25-15h49m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7110] on 29 April 2025 at 10:06:13 am'!

Character removeSelector: #hash!

!methodRemoval: Character #hash stamp: 'Install-7111-Character-hash-remove-JuanVuletich-2025Apr29-10h03m-jmv.001.cs.st 5/13/2025 17:35:47'!
hash
	"Hash is reimplemented because = is implemented."

	^self codePoint hash!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7111-Character-hash-remove-JuanVuletich-2025Apr29-10h03m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7150] on 28 April 2025 at 1:41:44 pm'!
!Symbol class methodsFor: 'access' stamp: 'jmv 4/28/2025 13:09:41' prior: 16962788!
          allSymbols
	"Answer all interned symbols"

	Symbols ifNil: [ ^#() ].
	^Array streamContents:
		[:s | Symbols do: [:each | s nextPut: each]]! !
!Symbol class methodsFor: 'class initialization' stamp: 'jmv 4/28/2025 13:14:17' prior: 50342338 overrides: 16917943!
                           initialize
	"Rebuild the hash table"
	"
	Symbol initialize.
	"
	self accessProtect critical:
		[ 	| allSymbols |
			allSymbols := Symbols ifNil: [#()].
			Symbols := WeakSet new.
			allSymbols do: [ :each |
				Symbols add: each ]].! !

Symbol initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7112-Symbol-fixForImageBootstrap-JuanVuletich-2025Apr28-12h48m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7150] on 28 April 2025 at 12:43:58 pm'!

Smalltalk removeClassNamed: #SymbolSet!

!classRemoval: #SymbolSet stamp: 'Install-7113-SymbolSet-removal-JuanVuletich-2025Apr28-12h43m-jmv.001.cs.st 5/13/2025 17:35:47'!
Object subclass: #SymbolSet
	instanceVariableNames: 'buckets bucketCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7113-SymbolSet-removal-JuanVuletich-2025Apr28-12h43m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7113] on 29 April 2025 at 10:42:29 am'!
!Character methodsFor: 'comparing' stamp: 'jmv 4/29/2025 10:41:03' overrides: 16915361!
                hash
	"Hash is reimplemented because #hash for long Strings relies on it, and especially on being the same as the codePoint's for the ASCII range. Also see the comment at Integer>>#hash.
	| longString |
	longString := (1 to: 100)
		inject: ''
		into: [ :prev :each |
			prev , 'A lot of stuff, needs over 2000 chars!! ' ].
	self assert: longString asByteString hash = longString asUnicodeString hash.
	self assert: longString asByteString = longString asUnicodeString.
	"
	^self codePoint hash! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7114-AddBack-Character-hash-withAComment-JuanVuletich-2025Apr29-10h25m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7114] on 30 April 2025 at 5:16:22 pm'!
!Process methodsFor: 'changing suspended state' stamp: 'jmv 4/30/2025 17:14:06' prior: 16930964!
                     stepToHome: aContext 
	"Resume self until the home of top context is aContext.  Top context may be a block context.
	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext
	 if so. Note that this will cause weird effects if using through to step through UnhandledError
	 code, but as the doctor ordered, don't do that; use over or into instead."

	| home |
	home := aContext home.
	[
		suspendedContext := suspendedContext step.
		home == suspendedContext home or: [ suspendedContext sender isNil or: [suspendedContext sender isDead]]
	] whileFalse:
		[
			self ifSuspendedContextIsUnhandledErrorDo: [ :anError |
			anError signalerContext ifNotNil: [:unhandledErrorSignalerContext|
				self completeStepUpTo: unhandledErrorSignalerContext.

				"Give a debugger a chance to update its title to reflect the new exception"
				 Notification signalToUpdateDebuggerOn: unhandledErrorSignalerContext dueTo: anError.
				^unhandledErrorSignalerContext]]].
		
	^suspendedContext! !
!Debugger methodsFor: 'context stack menu' stamp: 'jmv 4/30/2025 17:13:24' prior: 16843592!
        stepIntoBlock
	"Send messages until you return to the present method context.
	 Used to step into a block in the method."

	interruptedProcess isTerminated ifTrue: [^self inform: 'Debugging terminated'].

	self selectedContext willReturn ifTrue: [ ^self doStep ].
	self 
		handleLabelUpdatesIn: [interruptedProcess stepToHome: self selectedContext]
		whenExecuting: self selectedContext.
	self resetContext: interruptedProcess stepToSendOrReturn! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7115-Debugger-fix-JuanVuletich-2025Apr30-17h16m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7115] on 5 May 2025 at 11:44:58 am'!
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 5/5/2025 11:40:23' prior: 16930115!
   prefGui
	^ #( 
		#(balloonHelpEnabled true )
		#(biggerCursors false )		
		#(cacheDisplayContentWhenMovingMorphs true )
		#(cheapWindowReframe false )		
		#(clickGrabsMorphs false )	
		#(ctrlArrowsScrollHorizontally false ) 
		#(drawKeyboardFocusIndicator true )
		#(focusFollowsMouse false )
		#(focusIndicatorWidth 1)
		#(fullScreenLeavesDeskMargins true )
		#(haloEnclosesFullBounds true )
		#(halosShowCoordinateSystem true )
		#(menuKeyboardControl true )
		#(optionalButtons true )		
		#(selectiveHalos true )
		#(tapAndHoldEmulatesButton2 true )
		#(tileResizerInWindowMenu true )
		#(wantsMenuIcons true )
		#(autoReplaceNamedCharacters true)
		#(spaceTabOpensAutoCompletion true)
	)! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'jmv 5/5/2025 11:44:07' prior: 16784569!
         openCompletionMenuFor: kbEvent

	"Ctrl-Space (not on Mac), option-Space (on Mac) for open"
	kbEvent isCtrlSpace ifTrue: [
		self openCompletionMenu.
		^ true].

	"Tab, but not after a space."
	(kbEvent isTab and: [ self opensWithTab ]) ifTrue: [
		((Preferences at: #spaceTabOpensAutoCompletion) or: [
				self lastCharacterWantsAutoComplete]) ifTrue: [
			self openCompletionMenu.
			^ true ]].

	"Auto-open - currently deactivated"
"	(ctrl not & cmd not & alphanum) ifTrue: [ self openCompletionMenu ]."
	
	^ false! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Preferences name: #spaceTabOpensAutoCompletion category: #gui value: false.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7116-spaceTabOpensAutoCompletion-Preferences-JuanVuletich-2025May05-11h40m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7115] on 2 May 2025 at 11:12:29 am'!
!HaloMorph methodsFor: 'accessing' stamp: 'hlsf 5/2/2025 11:12:19' overrides: 16904561!
 layerNumber
	^ 10! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7117-HaloMorph-showAboveTarget-HilaireFernandes-2025May02-11h09m-hlsf.001.cs.st----!

'From Cuis7.3 [latest update: #7117] on 5 May 2025 at 1:06:54 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/5/2025 13:06:39' prior: 50358645!
                             knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jpb' 						'Josef Philip Bernhart')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('ml' 						'Matías Lang')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NPM'						'Nicolás Papagna Maldonado')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wbsl'						'Wéslleymberg Lisboa')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7118-addMatiasAsKnownAuthor-JuanVuletich-2025May05-13h06m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7102] on 28 April 2025 at 5:48:05 pm'!
!StringRequestMorph methodsFor: 'initialization' stamp: 'ml 4/28/2025 17:46:54' prior: 16962104!
                            setQuery: queryString initialAnswer: initialAnswer
	| titleMorphExtent titleHeight titleWidth requiredLines lineWidth contentsWidth maxLineWidth extraWidth |
	response := initialAnswer.
	titleMorphExtent := self addTitle: queryString.
	titleWidth := 20 * FontFamily defaultPointSize max: titleMorphExtent x.
	titleHeight := titleMorphExtent y + FontFamily defaultLineSpacing. "Some extra room for borders, etc."
	self addTextPane.

	requiredLines := 0.
	"Single line preferred. For instance, for file names and paths."
	(response noneSatisfy: [ :each | each isSeparator ]) ifTrue: [
		maxLineWidth := Display width * 0.8.
		contentsWidth := FontFamily defaultFamilyAndPointSize widthOfString: response.
		contentsWidth < maxLineWidth ifTrue: [
			"Will fit in the screen. Ok."
			requiredLines := 1.
			extraWidth := (10 * FontFamily defaultPointSize). "Some extra room for edition plus accept/cancel buttons." ]].

	"May need to be multiple lines"
	requiredLines = 0 ifTrue: [
		maxLineWidth := Display width // 3.
		contentsWidth := 0.
		response linesDo: [ :eachLine |
			lineWidth := FontFamily defaultFamilyAndPointSize widthOfString: eachLine.
			contentsWidth := contentsWidth max: (lineWidth min: maxLineWidth).
			requiredLines := requiredLines + (lineWidth / maxLineWidth) ceiling ].
		extraWidth := (10 * FontFamily defaultPointSize). "Some extra room for edition plus accept/cancel buttons."
		requiredLines := requiredLines min: 20. "Use scrollbars if needed." 		].

	self morphExtent: ((titleWidth max: contentsWidth) + extraWidth)@(titleHeight + (FontFamily defaultLineSpacing * requiredLines)).! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7119-Wider-StringRequestMorph-MatiasLang-2025Apr28-17h46m-ml.001.cs.st----!

'From Cuis7.3 [latest update: #7119] on 6 May 2025 at 7:40:46 pm'!
!ProgressMorph methodsFor: 'initialization' stamp: 'HAW 5/6/2025 19:37:31' prior: 16933584 overrides: 50356090!
                          initialize
	super initialize.
	self separation: 0.
	labelMorph := LabelMorph contents: '' font: FontFamily defaultFamilyAndPointSize.
	subLabelMorph := LabelMorph contents: '' font: FontFamily defaultFamilyAndPointSize.
	progress := ProgressBarMorph new.
	progress morphExtent: 200 @ FontFamily defaultLineSpacing.
	self addMorphFront: labelMorph.
	self addMorphFront: subLabelMorph.
	self addMorph: progress fixedHeight: FontFamily defaultLineSpacing.
	self setProperty: #layerNumber toValue: 10! !
!ProgressiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 5/6/2025 19:33:34' prior: 16933684!
createProgressBar
		
	progressBar := ProgressMorph label: testSuite name.
	progressBar setProperty: #layerNumber toValue: 100.
	self calculateTestRunIncrement.
	self updateProgressBarSubLabel.
	! !

ProgressMorph removeSelector: #layerNumber!

!methodRemoval: ProgressMorph #layerNumber stamp: 'Install-7120-ProgressBar-fixTopMost-HernanWilkinson-2025May06-19h15m-HAW.001.cs.st 5/13/2025 17:35:47'!
layerNumber 
	^ 10!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7120-ProgressBar-fixTopMost-HernanWilkinson-2025May06-19h15m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7120] on 8 May 2025 at 9:45:50 am'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 5/8/2025 09:34:46' prior: 16906052!
                          rejectsEventFully: aMorphicEvent
	"Return true to reject the given event, for thereceiver and all submorphs."

	^ self isLocked or: [ self visible not or: [self isInWorld not]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7121-DeletedMorphsMustNotGetEvents-JuanVuletich-2025May08-09h34m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7121] on 8 May 2025 at 10:51:38 am'!
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 5/8/2025 10:30:23' prior: 16924431 overrides: 16795918!
           drawOn: aCanvas
	self isRoundButton
		ifTrue: [ self drawRoundLookOn: aCanvas ]
		ifFalse: [ self draw3DLookOn: aCanvas ].
	aCanvas drawButtonIconFromCurrentMorph .! !
!ScrollBar methodsFor: 'access' stamp: 'jmv 5/8/2025 10:51:22' prior: 16946991 overrides: 16832603!
                    color: aColor
	"Change the color of the scrollbar to go with aColor."
	| buttonColor sliderColor |
	super color: aColor.

	buttonColor := Color transparent.
	upButton color: buttonColor.
	downButton color: buttonColor.

	sliderColor := color alphaMixed: 0.7 with: Theme current scrollbarButtonColor.
	slider color: sliderColor slightlyLighter.

	sliderShadow color: (color alphaMixed: 0.45 with: Theme current scrollbarSliderShadowColor)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7122-PluggableButtonMorph-tweaks-JuanVuletich-2025May08-10h46m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7120] on 10 May 2025 at 6:00:11 pm'!
!CharacterSequence methodsFor: 'copying' stamp: 'HAW 5/10/2025 17:59:25' prior: 16812869!
                              padded: leftRightOrCenter to: aLength with: aChar

	"
	'hi' padded: #left to: 5 with: $. -->  '...hi' 
	'hi' padded: #right to: 5 with: $. --> 'hi...' 
	'hi' padded: #center to: 5 with: $. --> '.hi..' 
	"
	| toPad |
	
	toPad := aLength - self size max: 0.
	
	leftRightOrCenter = #left ifTrue: [ ^ (self species new: toPad withAll: aChar) , self].
	leftRightOrCenter = #right ifTrue: [ ^ self , (self species new: toPad withAll: aChar)].
	leftRightOrCenter = #center ifTrue: [ | paddedLeft | 
		paddedLeft := self padded: #left to: toPad//2 + self size with: aChar.
		^ paddedLeft padded: #right to: aLength with: aChar].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7123-PaddedCenter-HernanWilkinson-2025May10-17h27m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7122] on 11 May 2025 at 6:54:16 pm'!
!SmalltalkCompleter methodsFor: 'keyboard - private' stamp: 'HAW 5/10/2025 18:38:05' overrides: 50354047!
   lastCharacterWantsAutoComplete

	| lastCharIndex lastCharacter |
	textMorph editor hasSelection ifTrue: [ ^ false ].

	lastCharIndex := textMorph editor startIndex-1.
	lastCharIndex <= 0 ifTrue: [ ^ false ].
	lastCharacter := model actualContents at: lastCharIndex.

	^ lastCharacter isAlphaNumeric 
		or: [ lastCharacter isValidInBinarySelectors 
		or: [ lastCharacter == $: 
		or: [ lastCharacter = Character space and: [ Preferences at: #spaceTabOpensAutoCompletion ]]]]! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'jmv 5/11/2025 18:53:24' prior: 50354047!
  lastCharacterWantsAutoComplete

	| lastCharIndex lastCharacter |
	textMorph editor hasSelection ifTrue: [ ^ false ].

	lastCharIndex := textMorph editor startIndex-1.
	lastCharIndex <= 0 ifTrue: [ ^ false ].
	lastCharacter := model actualContents at: lastCharIndex.

	^ lastCharacter isAlphaNumeric! !
!AutoCompleter methodsFor: 'keyboard - private' stamp: 'jmv 10/22/2024 16:58:33' prior: 50367733!
                openCompletionMenuFor: kbEvent

	"Ctrl-Space (not on Mac), option-Space (on Mac) for open"
	kbEvent isCtrlSpace ifTrue: [
		self openCompletionMenu.
		^ true].

	"Tab, but not after a space."
	(kbEvent isTab and: [ self opensWithTab ]) ifTrue: [
		self lastCharacterWantsAutoComplete ifTrue: [
			self openCompletionMenu.
			^ true ]].

	"Auto-open - currently deactivated"
"	(ctrl not & cmd not & alphanum) ifTrue: [ self openCompletionMenu ]."
	
	^ false! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7124-7116Fix-HernanWilkinson-2025May10-18h00m-HAW.002.cs.st----!

'From Cuis7.3 [latest update: #7122] on 11 May 2025 at 7:15:34 pm'!
!Debugger methodsFor: 'context stack menu' stamp: 'jmv 6/13/2024 14:18:52' prior: 50367684!
                          stepIntoBlock
	"Send messages until you return to the present method context.
	 Used to step into a block in the method."

	interruptedProcess isTerminated ifTrue: [^self inform: 'Debugging terminated'].
	self selectedContext method isQuick ifTrue: [ ^self doStep ].
	self 
		handleLabelUpdatesIn: [interruptedProcess stepToHome: self selectedContext]
		whenExecuting: self selectedContext.
	self resetContext: interruptedProcess stepToSendOrReturn! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7125-FixFor7115-JuanVuletich-2025May11-18h54m-jmv.001.cs.st----!

#(
	#(#ProtoObject #'MinimalKernel-Objects')
	#(#Object #'MinimalKernel-Objects')
	#(#Behavior #'MinimalKernel-Classes')
	#(#ClassDescription #'MinimalKernel-Classes')
	#(#Class #'MinimalKernel-Classes')
	#(#Metaclass #'MinimalKernel-Classes')
	#(#Collection #'MinimalKernel-Collections')
	#(#SequenceableCollection #'MinimalKernel-Collections')
	#(#ArrayedCollection #'MinimalKernel-Collections')
	#(#Array #'MinimalKernel-Collections')
	#(#ByteArray #'MinimalKernel-Collections')
	#(#CompiledMethod #'MinimalKernel-Methods')
	#(#LinkedList #'MinimalKernel-Collections')
	#(#Semaphore #'MinimalKernel-Processes')
	#(#CharacterSequence #'MinimalKernel-Strings')
	#(#String #'MinimalKernel-Strings')
	#(#Symbol #'MinimalKernel-Strings')
	#(#Set #'MinimalKernel-Collections')
	#(#Dictionary #'MinimalKernel-Collections')
	#(#IdentityDictionary #'MinimalKernel-Collections')
	#(#SystemDictionary #'MinimalKernel-Support')
	#(#MethodDictionary #'MinimalKernel-Methods')
	#(#SharedQueue #'MinimalKernel-Collections')
	#(#Stream #'MinimalKernel-Collections')
	#(#StdIOWriteStream #'Compiler-Support')
	#(#PositionableStream #'MinimalKernel-Collections')
	#(#WriteStream #'MinimalKernel-Collections')
	#(#AdditionalMethodState #'MinimalKernel-Methods')
	#(#BlockClosure #'MinimalKernel-Methods')
	#(#InstructionStream #'MinimalKernel-Methods')
	#(#ContextPart #'MinimalKernel-Methods')
	#(#MethodContext #'MinimalKernel-Methods')
	#(#Message #'MinimalKernel-Methods')
	#(#Pragma #'MinimalKernel-Methods')
	#(#Boolean #'MinimalKernel-Objects')
	#(#False #'MinimalKernel-Objects')
	#(#True #'MinimalKernel-Objects')
	#(#Magnitude #'MinimalKernel-Objects')
	#(#Number #'MinimalKernel-Numbers')
	#(#Float #'MinimalKernel-Numbers')
	#(#BoxedFloat64 #'MinimalKernel-Numbers')
	#(#SmallFloat64 #'MinimalKernel-Numbers')
	#(#Integer #'MinimalKernel-Numbers')
	#(#LargePositiveInteger #'MinimalKernel-Numbers')
	#(#LargeNegativeInteger #'MinimalKernel-Numbers')
	#(#SmallInteger #'MinimalKernel-Numbers')
	#(#LookupKey #'MinimalKernel-Support')
	#(#Association #'MinimalKernel-Support')
	#(#UndefinedObject #'MinimalKernel-Objects')
	#(#ProcessorScheduler #'MinimalKernel-Processes')
	#(#Character #'MinimalKernel-Strings')
	#(#Link #'MinimalKernel-Support')
	#(#Process #'MinimalKernel-Processes')
	#(#Point #'MinimalKernel-Support')
) do: [ :spec |
	(SystemOrganization hasCategory: spec second) ifFalse: [
		SystemOrganization addCategory: spec second before: 'Kernel-Objects' ].
	SystemOrganization classify: spec first under: spec second ].
SystemOrganization removeEmptyCategories.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7126-MinimalKernel-ClassCategories-JuanVuletich-2025Apr29-11h10m-jmv.003.cs.st----!

'From Cuis7.3 [latest update: #7115] on 29 April 2025 at 3:23:07 pm'!

Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'MinimalKernel-Support'!

!classDefinition: #StdIOWriteStream category: #'MinimalKernel-Support' stamp: 'Install-7127-MinimalKernel-MethodCategories-JuanVuletich-2025Apr29-12h54m-jmv.002.cs.st 5/13/2025 17:35:47'!
Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'MinimalKernel-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7127-MinimalKernel-MethodCategories-JuanVuletich-2025Apr29-12h54m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7115] on 29 April 2025 at 3:28:18 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7128-MinimalKernel-MethodCategories-JuanVuletich-2025Apr29-15h23m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7115] on 29 April 2025 at 4:19:23 pm'!
!Object methodsFor: 'system primitives' stamp: 'jmv 4/29/2025 16:16:23' overrides: 50336070!
               become: otherObject 
	"Primitive. Swap the object pointers of the receiver and the argument.
	All variables in the entire system that used to point to the 
	receiver now point to the argument, and vice-versa.
	Fails if either object is a SmallInteger"

	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				| contextReceiver |
				contextReceiver := context receiver.
				(self == contextReceiver or: [ otherObject == contextReceiver ]) ifTrue: [
					| selector selfMethod otherObjectMethod |
					selector := context method selector.
					selfMethod := self class lookupSelector: selector.
					otherObjectMethod := otherObject class lookupSelector: selector.
					selfMethod = otherObjectMethod ifFalse: [
						| errorMessage |
						errorMessage := contextReceiver class name, ' has some instance running #', selector, 
							'. This CompiledMethod would become invalid.'.
						errorMessage print.
						MethodInCallStackToBecomeInvalid signal ifFalse: [
							'#become: aborted.' print.
							Error signal: errorMessage, ' #become: aborted. Please see Transcript.'.
							^nil ]]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsExchangeIdentityWith: { otherObject }! !
!ProtoObject methodsFor: 'minimalKernel - Bootstrap' stamp: 'jmv 4/29/2025 16:17:57' prior: 50336070!
                         become: otherObject 
	"Primitive. Swap the object pointers of the receiver and the argument.
	All variables in the entire system that used to point to the 
	receiver now point to the argument, and vice-versa.
	Fails if either object is a SmallInteger.
	This implementation is appropriate for minimal bootstrapped images.
	Regular images will automatically use the implementation in Object (if present)."

	{ self } elementsExchangeIdentityWith: { otherObject }! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7129-become-basicInProtoObject-JuanVuletich-2025Apr29-15h28m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7115] on 29 April 2025 at 4:35:20 pm'!
!Object methodsFor: 'minimalKernel - Bootstrap' stamp: 'jmv 4/29/2025 16:29:56' prior: 16916644!
printOn: aStream
	"Append to the argument, aStream, a sequence of characters that  
	identifies the receiver.
	String streamContents: [ :strm | Object new printOn: strm ]
	"

	aStream nextPutAll: 'an instance of '.
	self class printNameOn: aStream.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7130-Object-printOn-JuanVuletich-2025Apr29-16h19m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7115] on 29 April 2025 at 4:51:16 pm'!
!ProtoObject methodsFor: 'minimalKernel - Bootstrap' stamp: 'jmv 4/29/2025 16:46:57'!
          error: aString 
	"
	Note: Subclasses of ProtoObject will redefine this message.
	This implementation will only be used when the Exception based one at Object is missing.
	This may happen in minimal bootstrapped images.
	"

	| context count |
	StdIOWriteStream stdout newLine;
		nextPutAll: 'Error: ';
		nextPutAll: aString; newLine;
		nextPutAll: '------ Call Stack: '; newLine;
		flush.

	context := thisContext sender.
	count := 0.
	[context notNil and: [ count < 10 ]] whileTrue: [
		context printOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout newLine.
		context := context sender.
		count := count + 1 ].

	StdIOWriteStream stdout newLine;
		nextPutAll: 'Will exit Cuis now.';
		newLine;
		flush.
	Smalltalk quitPrimitive: 128.! !
!ProtoObject methodsFor: 'minimalKernel - Bootstrap' stamp: 'jmv 4/29/2025 16:50:28'!
   warning: aString
	"May be redefined."
	"
	7  warning: 'El totón!!'
	"
	StdIOWriteStream stdout
		nextPutAll: 'Warning: ';
		nextPutAll: aString; newLine;
		flush.! !
!MessageCatcher methodsFor: 'error handling' stamp: 'jmv 4/29/2025 16:42:59' overrides: 50368519!
                       error: aString 
	"Throw a generic Error exception."

	^Error new signal: aString! !
!BreakingMethodWrapper methodsFor: 'error handling' stamp: 'jmv 4/29/2025 16:44:05' overrides: 50368519!
   error: aString 
	"Throw a generic Error exception."

	^Error new signal: aString! !
!ProtoObject methodsFor: 'minimalKernel - Bootstrap' stamp: 'jmv 4/29/2025 16:40:58' prior: 16933971!
      doesNotUnderstand: aMessage
	"
	Note: Subclasses of ProtoObject will redefine this message.
	This implementation will only be used when the Exception based one at Object is missing.
	This may happen in minimal bootstrapped images.
	"
	| context count |
	StdIOWriteStream stdout flush.
	StdIOWriteStream stdout newLine;
		nextPutAll: 'Message not understood.'; newLine;
		nextPutAll: 'Receiver: '.

	self class isMeta
		ifFalse: [ StdIOWriteStream stdout nextPutAll: 'a ' ]
		ifTrue: [ StdIOWriteStream stdout nextPutAll: 'class ' ].
	self class theNonMetaClass printNameOn: StdIOWriteStream stdout.

	StdIOWriteStream stdout
		nextPutAll: ' selector: #';
		nextPutAll: aMessage selector; newLine;
		nextPutAll: '------ Call Stack: '; newLine;
		flush.

	context := thisContext sender.
	count := 0.
	[context notNil and: [ count < 10 ]] whileTrue: [
		context printOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout newLine.
		context := context sender.
		count := count + 1 ].

	StdIOWriteStream stdout newLine;
		nextPutAll: 'Will exit now.';
		newLine;
		flush.

	Smalltalk quitPrimitive: 127.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7131-error-warning-basicInProtoObject-JuanVuletich-2025Apr29-16h35m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7120] on 30 April 2025 at 1:00:56 pm'!
!Symbol commentStamp: '<historical>' prior: 16962530!
     I represent Strings that are created uniquely.
So, if aString = anotherString, then we know aString asSymbol == anotherString asSymbol!
!Symbol class methodsFor: 'minimalKernel - Bootstrap' stamp: 'jmv 4/30/2025 12:51:07'!
 isLiteralSymbol: aSymbol 
	"Test whether a symbol can be stored as # followed by its characters.  
	Symbols created internally with asSymbol may not have this property, 
	e.g. '3' asSymbol."
	| char |
	aSymbol size = 0 ifTrue: [^ false].
	aSymbol = ':' ifTrue: [ ^true ].
	aSymbol = '|' ifTrue: [ ^true ].
	(aSymbol allSatisfy: [ :c | Character binarySelectorCharacters includes: c ])
		ifTrue: [ ^true ].
	char := aSymbol at: 1.
	(char isLetter or: [ char = $_ ]) ifTrue: [
		(aSymbol allSatisfy: [ :c |
			c isLetter or: [ c = $_ or: [ c isDigit or: [ c = $: ]]]])
				ifTrue: [ ^true ]].		
	^false! !
!Character class methodsFor: 'constants' stamp: 'jmv 4/30/2025 12:42:37'!
                          binarySelectorCharacters
	^ '!!%&+-*/\,<=>?@~'! !
!Scanner class methodsFor: 'testing' stamp: 'jmv 4/30/2025 12:51:30' prior: 16946769!
                        isValidInstanceVariableName: aString
	"Answer whether aString is a legal instance variable name."

	^ ((Symbol isLiteralSymbol: aString) and: [(aString includes: $:) not]) and:
		[(self pseudoVariableNames includes:  aString) not]! !
!Scanner class methodsFor: 'cached class state' stamp: 'jmv 4/30/2025 12:42:50' prior: 16946834!
                     initTypeTable
	| newTable |
	newTable := Array new: 127 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"
	newTable atAll: Character binarySelectorCharacters asByteArray put: #xBinary.
	1 to: 127 do: [:index |
		(Character codePoint: index) isLetter ifTrue: [
			newTable at: index put: #xLetter ]].
	newTable atAll: ($0 codePoint to: $9 codePoint) put: #xDigit.
	newTable at: self doItCharacterValue put: #doIt.
	newTable at: $" codePoint put: #xDoubleQuote.
	newTable at: $# codePoint put: #xLitQuote.
	newTable at: $$ codePoint put: #xDollar.
	newTable at: $' codePoint put: #xSingleQuote.
	newTable at: $` codePoint put: #xBacktick.
	newTable at: $: codePoint put: #xColon.
	newTable at: $( codePoint put: #leftParenthesis.
	newTable at: $) codePoint put: #rightParenthesis.
	newTable at: $. codePoint put: #period.
	newTable at: $; codePoint put: #semicolon.
	newTable at: $[ codePoint put: #leftBracket.
	newTable at: $] codePoint put: #rightBracket.
	newTable at: ${ codePoint put: #leftBrace.
	newTable at: $} codePoint put: #rightBrace.
	newTable at: $^ codePoint put: #upArrow.
	newTable at: $_ codePoint put: #xUnderscore.
	newTable at: $| codePoint put: #verticalBar.
	newTable at: Character smalltalkLeftArrow codePoint put: #leftArrow.
	newTable at: Character smalltalkUpArrow codePoint put: #upArrow.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !
!UnicodeSymbol methodsFor: 'printing' stamp: 'jmv 4/30/2025 12:51:20' prior: 16996743 overrides: 50351215!
                    storeOn: aStream 

	aStream nextPut: $#.
	(Symbol isLiteralSymbol: self)
		ifTrue: [aStream nextPutAll: self]
		ifFalse: [super storeOn: aStream]! !
!Symbol methodsFor: 'minimalKernel - Bootstrap' stamp: 'jmv 4/30/2025 12:51:16' prior: 16962625 overrides: 50351215!
                      storeOn: aStream 

	aStream nextPut: $#.
	(Symbol isLiteralSymbol: self)
		ifTrue: [aStream nextPutAll: self]
		ifFalse: [super storeOn: aStream]! !

Scanner class removeSelector: #isLiteralSymbol:!

!methodRemoval: Scanner class #isLiteralSymbol: stamp: 'Install-7132-Symbol-storeOn-bootstrapFriendly-JuanVuletich-2025Apr30-12h55m-jmv.001.cs.st 5/13/2025 17:35:48'!
isLiteralSymbol: aSymbol 
	"Test whether a symbol can be stored as # followed by its characters.  
	Symbols created internally with asSymbol may not have this property, 
	e.g. '3' asSymbol."
	| i char type |
	i := aSymbol size.
	i = 0 ifTrue: [^ false].
	char := aSymbol at: 1.
	"TypeTable should have been origined at 0 rather than 1 ..."
	char isNullCharacter ifTrue: [^ false].
	type := self typeTableAt: char.
	type == #xBinary ifTrue:
		[^i <= 2
		  and: [i = 1 or: [(self typeTableAt: (aSymbol at: 2)) == #xBinary]]].
	(type == #xColon or: [type == #verticalBar]) ifTrue:
		[^i = 1].
	(type == #xLetter or: [type == #xUnderscore]) ifTrue: [
		[i > 1] whileTrue: [
			char := aSymbol at: i.
			char isNullCharacter ifTrue: [^ false].
			type := self typeTableAt: char.
			((type == #xLetter or: [type == #xUnderscore])or: [type == #xDigit or: [type == #xColon]]) ifFalse: [
				^false].
			i := i - 1].
		^true].
	^false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7132-Symbol-storeOn-bootstrapFriendly-JuanVuletich-2025Apr30-12h55m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7115] on 29 April 2025 at 5:02:36 pm'!
!StdIOWriteStream methodsFor: 'minimalKernel - Bootstrap' stamp: 'jmv 4/29/2025 17:01:32' prior: 16959795!
                 primWrite: id from: stringOrByteArray startingAt: startIndex count: count
	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."

	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>
	self error: 'StdIOWriteStream [', name, '] write failed'.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7133-StdIO-write-bootstrapFriendly-JuanVuletich-2025Apr29-17h00m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7122] on 30 April 2025 at 9:53:24 am'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7134-MinimalKernel-FloatSupport-methodCats-JuanVuletich-2025Apr30-09h31m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7123] on 30 April 2025 at 3:02:05 pm'!

Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Collections'!

!classDefinition: #WeakArray category: #'MinimalKernel-Collections' stamp: 'Install-7135-MinimalKernel-AdditionalClassesAndMethods-JuanVuletich-2025Apr30-14h46m-jmv.001.cs.st 5/13/2025 17:35:48'!
Array weakSubclass: #WeakArray
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Collections'!

Collection subclass: #WeakSet
	instanceVariableNames: 'buckets estimatedSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Collections'!

!classDefinition: #WeakSet category: #'MinimalKernel-Collections' stamp: 'Install-7135-MinimalKernel-AdditionalClassesAndMethods-JuanVuletich-2025Apr30-14h46m-jmv.001.cs.st 5/13/2025 17:35:48'!
Collection subclass: #WeakSet
	instanceVariableNames: 'buckets estimatedSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Collections'!

Object subclass: #Exception
	instanceVariableNames: 'messageText tag signalContext handlerContexts outerContext handlerBlockNotCurtailed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

!classDefinition: #Exception category: #'MinimalKernel-Exceptions' stamp: 'Install-7135-MinimalKernel-AdditionalClassesAndMethods-JuanVuletich-2025Apr30-14h46m-jmv.001.cs.st 5/13/2025 17:35:48'!
Object subclass: #Exception
	instanceVariableNames: 'messageText tag signalContext handlerContexts outerContext handlerBlockNotCurtailed'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

Exception subclass: #Error
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

!classDefinition: #Error category: #'MinimalKernel-Exceptions' stamp: 'Install-7135-MinimalKernel-AdditionalClassesAndMethods-JuanVuletich-2025Apr30-14h46m-jmv.001.cs.st 5/13/2025 17:35:48'!
Exception subclass: #Error
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

Error subclass: #ArithmeticError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

!classDefinition: #ArithmeticError category: #'MinimalKernel-Exceptions' stamp: 'Install-7135-MinimalKernel-AdditionalClassesAndMethods-JuanVuletich-2025Apr30-14h46m-jmv.001.cs.st 5/13/2025 17:35:48'!
Error subclass: #ArithmeticError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

ArithmeticError subclass: #DomainError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

!classDefinition: #DomainError category: #'MinimalKernel-Exceptions' stamp: 'Install-7135-MinimalKernel-AdditionalClassesAndMethods-JuanVuletich-2025Apr30-14h46m-jmv.001.cs.st 5/13/2025 17:35:48'!
ArithmeticError subclass: #DomainError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

Error subclass: #ArithmeticMessageError
	instanceVariableNames: 'receiver selector arguments'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

!classDefinition: #ArithmeticMessageError category: #'MinimalKernel-Exceptions' stamp: 'Install-7135-MinimalKernel-AdditionalClassesAndMethods-JuanVuletich-2025Apr30-14h46m-jmv.001.cs.st 5/13/2025 17:35:48'!
Error subclass: #ArithmeticMessageError
	instanceVariableNames: 'receiver selector arguments'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

ArithmeticMessageError subclass: #ZeroDivide
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

!classDefinition: #ZeroDivide category: #'MinimalKernel-Exceptions' stamp: 'Install-7135-MinimalKernel-AdditionalClassesAndMethods-JuanVuletich-2025Apr30-14h46m-jmv.001.cs.st 5/13/2025 17:35:48'!
ArithmeticMessageError subclass: #ZeroDivide
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Exceptions'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7135-MinimalKernel-AdditionalClassesAndMethods-JuanVuletich-2025Apr30-14h46m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7124] on 30 April 2025 at 4:08:31 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7136-MinimalKernel-AdditionalClassesAndMethods-JuanVuletich-2025Apr30-15h11m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7126] on 6 May 2025 at 3:47:03 pm'!
!CharacterSequence class methodsFor: 'minimalKernel - Symbol support' stamp: 'jmv 5/6/2025 15:02:25'!
 representsSymbols
	^false! !
!Symbol class methodsFor: 'minimalKernel - Symbol support' stamp: 'jmv 5/6/2025 14:51:13'!
        estimatedCount
	^Symbols estimatedSize! !
!Symbol class methodsFor: 'minimalKernel - Symbol support' stamp: 'jmv 5/6/2025 15:02:37' overrides: 50368941!
       representsSymbols
	^true! !
!Symbol class methodsFor: 'minimalKernel - Symbol support' stamp: 'jmv 5/6/2025 15:06:49' prior: 50367586 overrides: 16917943!
     initialize
	"Rebuild the hash table"
	"
	Symbol initialize.
	"
	self accessProtect critical:
		[
			Symbols := WeakSet new.
			CharacterSequence allSubclassesDo: [ :cls | | sym |
				cls representsSymbols ifTrue: [
					sym := cls someInstance.
					[sym == nil] whileFalse: [
						Symbols add: sym.
						sym := sym nextInstance ]]]]! !
!StdIOWriteStream methodsFor: 'minimalKernel - Bootstrap' stamp: 'jmv 4/29/2025 17:01:32' prior: 50368765!
  primWrite: id from: stringOrByteArray startingAt: startIndex count: count
	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."

	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>
	self error: 'StdIOWriteStream [', name, '] write failed'.! !
!Character methodsFor: 'minimalKernel - Bootstrap' stamp: 'jmv 5/6/2025 14:39:55' prior: 16810495!
                   isLowercase
	"Answer whether the receiver is a letter."
	"
	(Character codePoint: 16r22C7) isLowercase
	(Character codePoint: 16r042F) isLowercase
	(Character codePoint: 16r0431) isLowercase
	"
	| i |
	"If no UnicodeData.txt tables, consider only ASCII"
	LowercaseLettersTable isNil ifTrue: [
		^ self codePoint between: 97 and: 122 ].
		
	i := self codePoint + 1.
	LowercaseLettersTable bitSize < i ifTrue: [ ^false ].
	^LowercaseLettersTable bitBooleanAt: i.! !
!Character methodsFor: 'minimalKernel - Bootstrap' stamp: 'jmv 5/6/2025 14:40:28' prior: 16810543!
             isUppercase
	"Answer whether the receiver is an uppercase letter."
	"
	(Character codePoint: 16r22C7) isUppercase
	(Character codePoint: 16r042F) isUppercase
	(Character codePoint: 16r0431) isUppercase
	"
	| i |
	"If no UnicodeData.txt tables, consider only ASCII"
	UppercaseLettersTable isNil ifTrue: [
		^ self codePoint between: 65 and: 90 ].

	i := self codePoint + 1.
	UppercaseLettersTable bitSize < i ifTrue: [ ^false ].
	^UppercaseLettersTable bitBooleanAt: i.! !

Symbol initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7137-SymbolInitialization-BootstrapFriendly-JuanVuletich-2025May06-15h44m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7127] on 6 May 2025 at 3:55:08 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7138-Categories-cleanup-JuanVuletich-2025May06-15h50m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7128] on 6 May 2025 at 4:14:14 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7139-MinimalKernel-AdditionalClassesAndMethods-JuanVuletich-2025May06-16h07m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7129] on 7 May 2025 at 12:33:42 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7140-BetterCategorizationFor-MinimalKernel-JuanVuletich-2025May07-10h10m-jmv.003.cs.st----!

'From Cuis7.3 [latest update: #7130] on 8 May 2025 at 4:42:00 pm'!

PositionableStream subclass: #ReadStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Collections'!

!classDefinition: #ReadStream category: #'MinimalKernel-Collections' stamp: 'Install-7141-MinimalKernel-CollectionsAndStreams-JuanVuletich-2025May08-14h36m-jmv.002.cs.st 5/13/2025 17:35:48'!
PositionableStream subclass: #ReadStream
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Collections'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7141-MinimalKernel-CollectionsAndStreams-JuanVuletich-2025May08-14h36m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7130] on 8 May 2025 at 5:09:52 pm'!

Set subclass: #IdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Collections'!

!classDefinition: #IdentitySet category: #'MinimalKernel-Collections' stamp: 'Install-7142-MinimalKernel-CollectionsAndStreams-JuanVuletich-2025May08-16h42m-jmv.001.cs.st 5/13/2025 17:35:48'!
Set subclass: #IdentitySet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'MinimalKernel-Collections'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7142-MinimalKernel-CollectionsAndStreams-JuanVuletich-2025May08-16h42m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7132] on 9 May 2025 at 2:03:35 pm'!

Stream subclass: #DataStream
	instanceVariableNames: 'byteStream topCall basePos '
	classVariableNames: 'ReferenceTypes TypeMap '
	poolDictionaries: ''
	category: 'System-Object Storage'!

!classDefinition: #DataStream category: #'System-Object Storage' stamp: 'Install-7143-ReferenceStreamEtAl-Cleanup-JuanVuletich-2025May09-13h59m-jmv.001.cs.st 5/13/2025 17:35:48'!
Stream subclass: #DataStream
	instanceVariableNames: 'byteStream topCall basePos'
	classVariableNames: 'ReferenceTypes TypeMap'
	poolDictionaries: ''
	category: 'System-Object Storage'!
!Stream methodsFor: 'normalized access' stamp: 'jmv 5/9/2025 11:59:30' prior: 16960183!
   nextFloat64BigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'

	(ByteArray streamContents: [ :strm |
		strm nextFloat64Put: Float pi bigEndian: false ])
			readStream nextFloat64BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextFloat64Put: Float pi bigEndian: true ])
			readStream nextFloat64BigEndian: true
	"
	| bytes |
	bytes := self next: 8.
	^ (bytes float64At: 1 bigEndian: bigEndian)
		+ 0.0 "Convert to SmallFloat64 if appropriate"! !
!DataStream methodsFor: '[mkObjectStorage] reading' stamp: 'jmv 5/9/2025 14:00:40' prior: 16840636 overrides: 16959983!
          next
	"Answer the next object in the stream."
	| type selector anObject isARefType pos internalObject |

	type := byteStream next.
	type ifNil: [
		pos := byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		byteStream position = 0 
			ifTrue: [self error: 'The file did not exist in this directory'] 
			ifFalse: [self error: 'Unexpected end of object file'].
		pos.	"so can see it in debugger"
		^ nil].
	type = 0 ifTrue: [
		pos := byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		self error: 'Expected start of object, but found 0'.
		^ nil].
	isARefType := self noteCurrentReference: type.
	selector := #(
			readNil readTrue readFalse readInteger
			errorRead readSymbol readByteArray readArray
			readInstance readReference readBitmap readClass
			errorRead readFloat errorRead readShortInst
			readString readWordArray errorRead readWordLike
			readMethod 
			readCharacter readUnicodeString readUnicodeSymbol) at: type.
	selector = 0 ifTrue: [
		pos := byteStream position.	"absolute!!!!"
		byteStream close. 
		self error: 'file is more recent than this system'.
		^ nil].
	anObject := self perform: selector. "A method that recursively
		calls next (readArray, readInstance, objectAt:) must save &
		restore the current reference position."
	isARefType ifTrue: [self beginReference: anObject].

		"After reading the externalObject, internalize it.
		 #readReference is a special case. Either:
		   (1) We actually have to read the object, recursively calling
			   next, which internalizes the object.
		   (2) We just read a reference to an object already read and
			   thus already interalized.
		 Either way, we must not re-internalize the object here."
	selector == #readReference ifTrue: [^ anObject].
	internalObject := anObject comeFullyUpOnReload: self.
	^ self maybeBeginReference: internalObject.! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 5/9/2025 14:00:54' prior: 16840698 overrides: 16960021!
                 nextPut: anObject
	"Write anObject to the receiver stream. Answer anObject."
	| typeID selector objectToStore |

	typeID := self typeIDFor: anObject.
	(self tryToPutReference: anObject typeID: typeID)
		ifTrue: [^ anObject].

	objectToStore := (self objectIfBlocked: anObject) objectForDataStream: self.
	objectToStore == anObject ifFalse: [typeID := self typeIDFor: objectToStore].

	byteStream nextPut: typeID.
	selector := #(
		writeNil: writeTrue: writeFalse: writeInteger: 
		errorWriteReference: writeSymbol: writeByteArray: writeArray:
		writeInstance: errorWriteReference: writeBitmap: writeClass:
		errorWriteReference: writeFloat: errorWriteReference: errorWriteReference:
		writeString: writeBitmap: errorWriteReference: writeWordLike: 
		writeInstance: "CompiledMethod"
		writeCharacter: writeUnicodeString: writeUnicodeSymbol:) at: typeID.
	self perform: selector with: objectToStore.

	^ anObject


"NOTE: If anObject is a reference type (one that we write cross-references to) but its externalized form (result of objectForDataStream:) isn't (e.g. CompiledMethod), then we should remember its externalized form
 but not add to 'references'. Putting that object again should just put its
 external form again. That's more compact and avoids seeks when reading.
 But we just do the simple thing here, allowing backward-references for
 non-reference types like nil. So objectAt: has to compensate. Objects that
 externalize nicely won't contain the likes of these, so this shouldn't
 hurt much.
	 writeReference: -> errorWriteReference:."! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 5/9/2025 12:00:55' prior: 16840858!
                     readFloat
	"PRIVATE -- Read the contents of a Float.
	 This is the fast way to read a Float.
	Read bigEndian / PowerPC order.
	Answer is BoxedFloat64 or SmallFloat64 as appropriate."

	^ byteStream nextFloat64BigEndian: true! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 5/9/2025 12:00:33' prior: 16841215!
   writeFloat: aFloat
	"PRIVATE -- Write the contents of a Float.
	Supports both BoxedFloat64 and SmallFloat64.
	Write in bigEndian / PowerPC order."

	byteStream nextFloat64Put: aFloat bigEndian: true! !
!DataStream class methodsFor: '[mkObjectStorage] cached state access' stamp: 'jmv 5/9/2025 14:01:37' prior: 16841470!
initCachedState
	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  #nextPut: writes these IDs to the data stream.
	NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  
	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)
	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"
	"
	DataStream initCachedState
	"
	| t |
	t := TypeMap := Dictionary newWithRoomForMoreThan: 80. "sparse for fast hashing"

	t at: UndefinedObject put: 1.
	t at: True put: 2.
	t at: False put: 3.
	t at: SmallInteger put: 4.
	"(type ID 5 was for Squeak's old String format)"
	t at: Symbol put: 6.
	t at: ByteArray put: 7.
	t at: Array put: 8.
	"(type ID 9 is for arbitrary instances of any class. See #typeIDFor: See #writeInstance: See #readInstance)"
	"(type ID 10 is for references, See ReferenceStream>>tryToPutReference:typeID:)"
	t at: Bitmap put: 11.
	t at: Metaclass put: 12.
	"Type ID 13 was for Squeak's  HyperSqueak User classes."
	t at: Float put: 14.
	t at: BoxedFloat64 put: 14.
	t at: SmallFloat64 put: 14.
	"(type ID 15 was for Squeak's old Deprecated compact Rects."
	"type ID 16 is an instance with short header.  See #beginInstance:size:"
	t at: String put: 17.	"'new' String format, 1 or 4 bytes of length"
	t at: WordArray put: 18.
	"type ID 19 was for Squeak's Word Array for Segment."
	"For all classes that are like WordArrays, store them as bits, and able to change endianness."
	Smalltalk do: [:cls |
		cls isBehavior ifTrue: [
			cls isPointers not & cls isVariable & cls isWords ifTrue: [
				(t includesKey: cls) ifFalse: [t at: cls put: 20]]]].
	t at: CompiledMethod put: 21.	"special creation method"
	t at: Character put: 22.
	t at: UnicodeString put: 23.
	t at: UnicodeSymbol put: 24.! !
!DataStream class methodsFor: '[mkObjectStorage] cached state access' stamp: 'jmv 5/9/2025 13:02:38' prior: 16841607 overrides: 50348340!
                            releaseClassCachedState

	TypeMap := nil! !
!ReferenceStream methodsFor: '[mkObjectStorage] writing' stamp: 'jmv 5/9/2025 11:54:59' prior: 16938760!
           isAReferenceType: typeID
	"Answer is:
		- true means a regular object reference (and the referenced object is in elsewhere in the stream)
		- false means either
				- an immediate (SmallInteger, Character, but not SmallFloat64) 
				- or a special object (nil, true, false) 
				- or a Class (actually an error condition. See #next and #nextPut:)
	"
	^ (#(0 0 0 0 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1) at: typeID) = 1! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 5/9/2025 11:33:21' prior: 16956797!
                               moreObjects
	"Return true if there appears to be another object following this one on the file."

	| byte |
	byteStream atEnd ifTrue: [^ false].	"off end of file"
	(byte := byteStream peek) ifNil: [^ false].	"off end of file"
	byte = 33 "$!! asciiValue" ifTrue: [^ false].
	byte = 0 ifTrue: [^ false].
	^ true! !

DataStream class removeSelector: #referenceTypes!

!methodRemoval: DataStream class #referenceTypes stamp: 'Install-7143-ReferenceStreamEtAl-Cleanup-JuanVuletich-2025May09-13h59m-jmv.001.cs.st 5/13/2025 17:35:48'!
referenceTypes

	ReferenceTypes ifNil: [ self initCachedState ].
	^ReferenceTypes!

DataStream removeSelector: #readUser!

!methodRemoval: DataStream #readUser stamp: 'Install-7143-ReferenceStreamEtAl-Cleanup-JuanVuletich-2025May09-13h59m-jmv.001.cs.st 5/13/2025 17:35:48'!
readUser
	"Reconstruct both the private class and the instance.  Still used??"

	^ self readInstance.		"Will create new unique class"
!

DataStream removeSelector: #readWordArrayForSegment!

!methodRemoval: DataStream #readWordArrayForSegment stamp: 'Install-7143-ReferenceStreamEtAl-Cleanup-JuanVuletich-2025May09-13h59m-jmv.001.cs.st 5/13/2025 17:35:48'!
readWordArrayForSegment
	"Read the contents of a WordArray ignoring endianness."
	"Removed WordArrayForSegment when removed ImageSegment"
"	^ WordArrayForSegment newFromStream: byteStream"
	"Size is number of long words."!

DataStream removeSelector: #writeUser:!

!methodRemoval: DataStream #writeUser: stamp: 'Install-7143-ReferenceStreamEtAl-Cleanup-JuanVuletich-2025May09-13h59m-jmv.001.cs.st 5/13/2025 17:35:48'!
writeUser: anObject
    "Write the contents of an arbitrary User instance (and its devoted class)."
    " 7/29/96 tk"

	"If anObject is an instance of a unique user class, will lie and say it has a generic class"
    ^ anObject storeDataOn: self!

DataStream removeSelector: #writeStringOld:!

!methodRemoval: DataStream #writeStringOld: stamp: 'Install-7143-ReferenceStreamEtAl-Cleanup-JuanVuletich-2025May09-13h59m-jmv.001.cs.st 5/13/2025 17:35:48'!
writeStringOld: aString
	"PRIVATE -- Write the contents of a String."

	| length |
	aString size < 16384 
		ifTrue: [
			(length := aString size) < 192
				ifTrue: [byteStream nextPut: length]
				ifFalse: 
					[byteStream nextPut: (length // 256 + 192).
					byteStream nextPut: (length \\ 256)].
			aString do: [:char | byteStream nextPut: (char codePoint min: 255)]]
		ifFalse: [self writeByteArray: aString].	"takes more space"!

Stream subclass: #DataStream
	instanceVariableNames: 'byteStream topCall basePos'
	classVariableNames: 'TypeMap'
	poolDictionaries: ''
	category: 'System-Object Storage'!

!classDefinition: #DataStream category: #'System-Object Storage' stamp: 'Install-7143-ReferenceStreamEtAl-Cleanup-JuanVuletich-2025May09-13h59m-jmv.001.cs.st 5/13/2025 17:35:48'!
Stream subclass: #DataStream
	instanceVariableNames: 'byteStream topCall basePos'
	classVariableNames: 'TypeMap'
	poolDictionaries: ''
	category: 'System-Object Storage'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7143-ReferenceStreamEtAl-Cleanup-JuanVuletich-2025May09-13h59m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7132] on 9 May 2025 at 2:08:40 pm'!
!DataStream methodsFor: '[mkObjectStorage] reading' stamp: 'jmv 5/9/2025 14:07:49' prior: 50369135 overrides: 16959983!
                next
	"Answer the next object in the stream."
	| type selector anObject isARefType pos internalObject |

	type := byteStream next.
	type ifNil: [
		pos := byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		byteStream position = 0 
			ifTrue: [self error: 'The file did not exist in this directory'] 
			ifFalse: [self error: 'Unexpected end of object file'].
		pos.	"so can see it in debugger"
		^ nil].
	type = 0 ifTrue: [
		pos := byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		self error: 'Expected start of object, but found 0'.
		^ nil].
	isARefType := self noteCurrentReference: type.
	selector := #(
			readNil readTrue readFalse readInteger
			errorRead readSymbol readByteArray readArray
			readInstance readReference readBitmap readClass
			errorRead readFloat errorRead readShortInst
			readString readWordArray errorRead readWordLike
			readMethod 
			readCharacter readUnicodeString readUnicodeSymbol) at: type.
	anObject := self perform: selector. "A method that recursively
		calls next (readArray, readInstance, objectAt:) must save &
		restore the current reference position."
	isARefType ifTrue: [self beginReference: anObject].

		"After reading the externalObject, internalize it.
		 #readReference is a special case. Either:
		   (1) We actually have to read the object, recursively calling
			   next, which internalizes the object.
		   (2) We just read a reference to an object already read and
			   thus already interalized.
		 Either way, we must not re-internalize the object here."
	selector == #readReference ifTrue: [^ anObject].
	internalObject := anObject comeFullyUpOnReload: self.
	^ self maybeBeginReference: internalObject.! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 5/9/2025 14:07:33' prior: 16841131!
                               typeIDFor: anObject
	"Return the typeID for anObject's class.  This is where the tangle of objects is clipped to stop everything from going out.  
	Classes can control their instance variables by defining objectToStoreOnDataStream.
	Any object in blockers is not written out.  See ReferenceStream.objectIfBlocked: and DataStream nextPut:.
	Morphs do not write their owners.  See Morph.storeDataOn:   Each morph tells itself to 'prepareToBeSaved' before writing out."
	
	^ DataStream typeMap at: anObject class name ifAbsent: [9 "instance of any normal class"]! !
!DataStream class methodsFor: '[mkObjectStorage] cached state access' stamp: 'jmv 5/9/2025 14:07:05' prior: 50369269!
                       initCachedState
	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  #nextPut: writes these IDs to the data stream.
	NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  
	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)
	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"
	"
	DataStream initCachedState
	"
	| t |
	t := TypeMap := Dictionary newWithRoomForMoreThan: 80. "sparse for fast hashing"

	t at: #UndefinedObject put: 1.
	t at: #True put: 2.
	t at: #False put: 3.
	t at: #SmallInteger put: 4.
	"(type ID 5 was for Squeak's old String format)"
	t at: #Symbol put: 6.
	t at: #ByteArray put: 7.
	t at: #Array put: 8.
	"(type ID 9 is for arbitrary instances of any class. See #typeIDFor: See #writeInstance: See #readInstance)"
	"(type ID 10 is for references, See ReferenceStream>>tryToPutReference:typeID:)"
	t at: #Bitmap put: 11.
	t at: #Metaclass put: 12.
	"Type ID 13 was for Squeak's  HyperSqueak User classes."
	t at: #Float put: 14.
	t at: #BoxedFloat64 put: 14.
	t at: #SmallFloat64 put: 14.
	"(type ID 15 was for Squeak's old Deprecated compact Rects."
	"type ID 16 is an instance with short header.  See #beginInstance:size:"
	t at: #String put: 17.	"'new' String format, 1 or 4 bytes of length"
	t at: #WordArray put: 18.
	"type ID 19 was for Squeak's Word Array for Segment."
	"For all classes that are like WordArrays, store them as bits, and able to change endianness."
	Smalltalk do: [:cls |
		cls isBehavior ifTrue: [
			cls isPointers not & cls isVariable & cls isWords ifTrue: [
				(t includesKey: cls) ifFalse: [
					t at: cls name put: 20 ]]]].
	t at: #CompiledMethod put: 21.	"special creation method"
	t at: #Character put: 22.
	t at: #UnicodeString put: 23.
	t at: #UnicodeSymbol put: 24.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7144-DataStream-Cleanup-JuanVuletich-2025May09-14h03m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7132] on 9 May 2025 at 3:48:27 pm'!
!Behavior methodsFor: 'accessing instances and variables' stamp: 'jmv 5/9/2025 15:42:40' prior: 16788678!
                         sharedPools
	"Answer a Set of the names of the pools (Dictionaries) that the receiver 
	shares.
	9/12/96 tk  sharedPools have an order now"

	^ #()! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7145-MinimalKernel-ClassAndMetaclass-Misc-JuanVuletich-2025May09-14h18m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7135] on 9 May 2025 at 5:46:25 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7146-MinimalKernel-AdditionalMethodCategorization-JuanVuletich-2025May09-16h45m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7146] on 12 May 2025 at 4:19:34 pm'!
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 5/12/2025 16:16:27' prior: 16911983!
                  processMouseOver: aMouseEvent 
	"Re-establish the z-order for all morphs wrt the given event"

	| hand focus evt |
	hand := aMouseEvent hand.
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	"Now go looking for eventual mouse overs"
	hand startEventDispatch: aMouseEvent asMouseOver.
	"Get out early if there's no change"
	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."
		(leftMorphs isEmpty and: [enteredMorphs position = 0])])
		ifTrue: [^leftMorphs := enteredMorphs := overMorphs := nil].
	focus := hand mouseFocus.
	"Send #mouseLeave as appropriate"
	evt := aMouseEvent asMouseLeave.
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					evt sendEventTo: m ]
				ifFalse: [overMorphs nextPut: m]]].
	"Send #mouseEnter as appropriate"
	evt := aMouseEvent asMouseEnter.
	enteredMorphs ifNil: [
		"inform: was called in handleEvent:"
		^ leftMorphs := enteredMorphs := overMorphs := nil].
	enteredMorphs := enteredMorphs contents.
	enteredMorphs reverseDo: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					evt sendEventTo: m ]]].
	"And remember the over list"
	overMorphs ifNil: [
			"inform: was called in handleEvent:"
			^leftMorphs := enteredMorphs := overMorphs := nil].
	mouseOverMorphs := overMorphs contents.
	leftMorphs := enteredMorphs := overMorphs := nil! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 7/13/2020 16:07:54' prior: 50368153!
                      rejectsEventFully: aMorphicEvent
	"Return true to reject the given event, for thereceiver and all submorphs."

	^ self isLocked or: [ self visible not ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7147-WorkingFixInsteadOfBogus7121-JuanVuletich-2025May12-15h46m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7146] on 12 May 2025 at 4:20:07 pm'!
!Morph methodsFor: 'drawing' stamp: 'jmv 5/12/2025 15:38:41' prior: 16905035!
      drawingFails
	self world ifNotNil: [ :w | w addKnownFailing: self ].
	self redrawNeeded.! !
!Morph methodsFor: 'drawing' stamp: 'jmv 5/12/2025 15:44:56' prior: 50360067!
                      imageForm: extentOrNil depth: depth

	| answerExtent answer auxCanvas bounds |
	self ensureMinimumExtent.

	self requiresVectorCanvas ifTrue: [	
		^ self imageFormVG: extentOrNil depth: depth ].

	bounds := self fullBoundsInOwner.
	answerExtent := bounds extent.
	extentOrNil ifNotNil: [ answerExtent := answerExtent min: extentOrNil * 4 ].
	auxCanvas := MorphicCanvas depth: depth over: (bounds origin extent: answerExtent ceiling).
	[auxCanvas fullDraw: self] on: Error do: [ auxCanvas canvasToUse drawCurrentAsOutline ].
	answer := auxCanvas form divideByAlpha.
	extentOrNil ifNotNil: [ answer := answer magnifyTo: extentOrNil ].
	^answer! !
!Morph methodsFor: 'drawing' stamp: 'jmv 5/12/2025 15:45:08' prior: 50365542!
             imageFormVG: extentOrNil depth: depth
	"Draw using a VectorCanvas
	Scale as needed. Draw unrotated."

	| prevNotVisibleFlag bounds extent fauxLocation answer auxCanvas |
	"Position and scale us in order to fill required extent, but disregard any rotation.
	Do it without triggering any invalidation at all."
	prevNotVisibleFlag := self privateFlagAt: 3.
	[
		bounds := self findFullBoundsInOwner.
		extentOrNil
			ifNotNil: [ | scale |
				extent := extentOrNil.
				scale := extent x asFloat / bounds width min: extent y asFloat / bounds height.
				fauxLocation := AffineTransformation withScale: scale position: bounds origin negated +1 * scale ]
			ifNil: [
				extent := bounds extent.
				fauxLocation := MorphicTranslation withTranslation: bounds origin negated ].
		answer := Form extent: extent depth: 32.
		"Ask for a Canvas with subpixels so it can also handle translucent target.
		This is relevant if #isPluginAvailable is true, and we're using the plugin, as the Smalltalk engine does proper
		target translucency both in subPixel and wholePixel AA variants."
		auxCanvas := VectorCanvas onFormWithSubPixelAntiAliasing: answer.
		auxCanvas geometryTransformation: fauxLocation.
		"But disable subpixel anti aliasing, as we are answering a Form, and therefore can't assume a Display geometry."
		auxCanvas engine disableSubPixelSampling.
		depth = 32 ifFalse: [
			"Only 32 bpp can hold translucent anti aliasing over transparent background"
			answer fillColor: Color veryLightGray ].
		self privateFlagAt: 3 put: false.
		[auxCanvas fullDraw: self] on: Error do: [ auxCanvas canvasToUse drawCurrentAsOutline ].
	] ensure: [
		self privateFlagAt: 3 put: prevNotVisibleFlag ].
	^answer asFormOfDepth: depth.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7148-RobustnessAgainstMorphDrawFailures-JuanVuletich-2025May12-16h19m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7148] on 12 May 2025 at 5:06:45 pm'!
!ProtoObject methodsFor: '[mk] system primitives' stamp: 'jmv 5/12/2025 16:57:21' prior: 50368566!
           doesNotUnderstand: aMessage
	"
	Note: Subclasses of ProtoObject will redefine this message.
	This implementation will only be used when the Exception based one at Object is missing.
	This may happen in minimal bootstrapped images.
	"
	| title context count |
	StdIOWriteStream stdout flush.
	StdIOWriteStream stdout newLine;
		nextPutAll: 'Message not understood.'; newLine;
		nextPutAll: 'Receiver: '.

	"
	self class isMeta
		ifFalse: [ StdIOWriteStream stdout nextPutAll: 'a ' ]
		ifTrue: [ StdIOWriteStream stdout nextPutAll: 'class ' ].
	self class theNonMetaClass printNameOn: StdIOWriteStream stdout.
	"
	title := self class name.
	StdIOWriteStream stdout
		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);
		nextPutAll: title.

	StdIOWriteStream stdout
		nextPutAll: ' selector: #';
		nextPutAll: aMessage selector; newLine;
		nextPutAll: '------ Call Stack: '; newLine;
		flush.

	context := thisContext sender.
	count := 0.
	[context notNil and: [ count < 10 ]] whileTrue: [
		context printOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout newLine.
		context := context sender.
		count := count + 1 ].

	StdIOWriteStream stdout newLine;
		nextPutAll: 'Will exit now.';
		newLine;
		flush.

	Smalltalk quitPrimitive: 127.! !
!Object methodsFor: '[mk] printing' stamp: 'jmv 5/12/2025 16:58:04' prior: 50368501!
  printOn: aStream
	"Append to the argument, aStream, a sequence of characters that  
	identifies the receiver.
	String streamContents: [ :strm | Object new printOn: strm ]
	"
	| title |
	title := self class name.
	aStream
		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);
		nextPutAll: title.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7149-traditional-Object-printOn-JuanVuletich-2025May12-17h02m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7149] on 12 May 2025 at 5:14:00 pm'!
!ArrayedCollection class methodsFor: '[mk] instance creation' stamp: 'jmv 5/12/2025 12:09:36'!
                         withAll: aSequenceableCollection with: finalElement
	"Create a new collection containing all the elements from aSequenceableCollection."

	| answer |
	answer := (self new: aSequenceableCollection size + 1)
		replaceFrom: 1
		to: aSequenceableCollection size
		with: aSequenceableCollection.
	answer at: answer size put: finalElement.
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7150-Array-class-withAll-with-JuanVuletich-2025May12-17h13m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7149] on 12 May 2025 at 5:17:59 pm'!
!ClassDescription methodsFor: '[mkClassCreation] initialization' stamp: 'jmv 5/12/2025 12:01:54' prior: 16820421!
        setInstVarNames: instVarArray
	"Private - for class initialization only"
	| required |
	required := self instSize.
	superclass ifNotNil: [
		required := required - superclass instSize].
	instVarArray size = required
		ifFalse:[
			^self error: required printString, ' instvar names are required'].
	instanceVariables := instVarArray size = 0
		ifFalse: [
			instVarArray == Array
				ifTrue: [ instVarArray ]
				ifFalse: [ Array withAll: instVarArray ]].! !
!Class methodsFor: '[mkClassCreation] initialization' stamp: 'jmv 5/12/2025 17:16:17' prior: 16815672!
              addSubclass: aSubclass
	"Make the argument, aSubclass, be one of the subclasses of the receiver. 
	Create an error notification if the argument's superclass is not the receiver."

	aSubclass superclass ~~ self
		ifTrue: [^self error: aSubclass name , ' is not my subclass'].
	subclasses ifNil: [
		subclasses := Array with: aSubclass.
		^self].
	subclasses do: [ :cl | cl == aSubclass ifTrue: [ ^self ]]. "Already my subclass"
	subclasses := Array withAll: subclasses with: aSubclass.! !
!ArrayedCollection class methodsFor: 'instance creation' stamp: 'jmv 5/12/2025 12:07:26' prior: 16783946!
              with: firstElement withAll: aSequenceableCollection
	"Create a new collection containing firstElement, then all the elements from aSequenceableCollection.
	Array with: 1 withAll: (10 to: 20)
	"

	| s |
	s := aSequenceableCollection size+1.
	^ (self new: s)
		at: 1 put: firstElement;
		replaceFrom: 2 to: s with: aSequenceableCollection! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7151-MinimalKernel-friendly-tweaks-JuanVuletich-2025May12-17h14m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7149] on 12 May 2025 at 5:38:53 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7152-MinimalKernel-classAndMethodCreation-JuanVuletich-2025May12-17h23m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7152] on 12 May 2025 at 5:50:58 pm'!
!ProtoObject methodsFor: '[mk] system primitives' stamp: 'jmv 5/12/2025 17:50:41' prior: 50369809!
doesNotUnderstand: aMessage
	"
	Note: Subclasses of ProtoObject will redefine this message.
	This implementation will only be used when the Exception based one at Object is missing.
	This may happen in minimal bootstrapped images.
	"
	| context count |
	StdIOWriteStream stdout flush.
	StdIOWriteStream stdout newLine;
		nextPutAll: 'Message not understood.'; newLine;
		nextPutAll: 'Receiver: '.

	self class isMeta
		ifFalse: [ StdIOWriteStream stdout nextPutAll: 'an instance of ' ]
		ifTrue: [ StdIOWriteStream stdout nextPutAll: 'class ' ].
	self class theNonMetaClass printNameOn: StdIOWriteStream stdout.

	StdIOWriteStream stdout
		nextPutAll: ' selector: #';
		nextPutAll: aMessage selector; newLine;
		nextPutAll: '------ Call Stack: '; newLine;
		flush.

	context := thisContext sender.
	count := 0.
	[context notNil and: [ count < 10 ]] whileTrue: [
		context printOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout newLine.
		context := context sender.
		count := count + 1 ].

	StdIOWriteStream stdout newLine;
		nextPutAll: 'Will exit now.';
		newLine;
		flush.

	Smalltalk quitPrimitive: 127.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7153-ProtoObject-doesNotUnderstand-tweak-JuanVuletich-2025May12-17h48m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7152] on 12 May 2025 at 5:55:50 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7154-MinimalKernel-classAndMethodCreation-JuanVuletich-2025May12-17h51m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7154] on 13 May 2025 at 9:27:36 am'!
!Behavior methodsFor: 'accessing instances and variables' stamp: 'jmv 5/13/2025 09:26:11' prior: 50359850!
          maxAccessibleInstSize
	"Answer the maximum number of accessible named instance variables.
	 This depends on the bytecode set.
	Note: On images without Compiler / Parser / Encoder we'd need a class variable somewhere.
		Assume EncoderForV3PlusClosures if unknown"

	CompiledMethod preferredBytecodeSetEncoderClass isNil
		ifTrue: [ ^256 ].
	^CompiledMethod preferredBytecodeSetEncoderClass maxAccessibleInstSize! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7155-ClassCreationWithoutParserAndEncoder-JuanVuletich-2025May13-09h23m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7154] on 13 May 2025 at 9:42:32 am'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7156-MinimalKernel-classAndMethodCreation-JuanVuletich-2025May13-09h38m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7156] on 13 May 2025 at 10:21:16 am'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7157-MinimalKernel-classAndMethodCreation-JuanVuletich-2025May13-09h45m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7157] on 13 May 2025 at 4:05:00 pm'!
!LayoutSpec commentStamp: 'jmv 5/13/2025 15:52:09' prior: 16892386!
                     LayoutSpecs are the basis for the layout mechanism. Any Morph can be given a LayoutSpec, but in order to honor it, its owner must be a LayoutMorph.

A LayoutSpec specifies how a morph wants to be layed out. It can specify either a fixed width or a fraction of some available owner width. Same goes for height. If a fraction is specified, a minimum extent is also possible.


Alternatives:
	- proportionalWidth notNil, fixedWidth notNil	->		Use fraction of available space, take fixedWidth as minimum desired width
	- proportionalWidth isNil, fixedWidth isNil		->		Use current morph width
	- proportionalWidth isNil, fixedWidth notNil	->		Use fixedWidth
	- proportionalWidth notNil, fixedWidth isNil	->		NOT VALID

Same goes for proportionalHeight and fixedHeight
!
!Form methodsFor: 'scaling, rotation' stamp: 'jmv 5/13/2025 15:41:55' prior: 16869605!
            flippedBy: direction
	"Return a copy of the receiver flipped either #vertical, #horizontal or #both. (#both is a 180 degrees rotation)
	ImageMorph defaultForm display.
	(ImageMorph defaultForm flippedBy: #vertical) display.
	(ImageMorph defaultForm flippedBy: #horizontal) display.
	(ImageMorph defaultForm flippedBy: #both) display.
	"
	| newForm quad |
	newForm := self class extent: self extent depth: depth.
	quad := self boundingBox innerCorners.
	quad := (
		direction caseOf: {
			[ #vertical ] 		-> [#(2 1 4 3)].
			[ #horizontal ] 		-> [#(4 3 2 1)].
			[ #both ] 			-> [#(3 4 1 2)]})
		collect: [:i | quad at: i].
	(WarpBlt toForm: newForm)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: newForm);
		combinationRule: 3;
		copyQuad: quad toRect: newForm boundingBox.
"	newForm offset: (self offset flippedBy: direction centerAt: aPoint)."
	^ newForm
"
[Sensor isAnyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))
			flippedBy: #vertical centerAt: 0@0) display]
"
"Consistency test...
 | f f2 p |
[ Sensor isAnyButtonPressed ] whileFalse: [
	f := Form fromDisplay: ((p := Sensor mousePoint) extent: 31@41).
	Display fillBlack: (p extent: 31@41).
	f2 := f flippedBy: #vertical centerAt: 0@0.
	(f2 flippedBy: #vertical centerAt: 0@0) displayAt: p ]
"! !
!Theme methodsFor: 'shout' stamp: 'jmv 5/13/2025 15:42:30' prior: 16988121!
                        shout
	"Color symbols as an association list.
	SHTextStylerST80 initialize
	"
	^ {
		#selector  						-> nil.
		#arguments  					-> #(cyan muchDarker).
		#comment 						-> #(green muchDarker).
		#tempBar 						-> #gray.
		#tempVars 					-> #(gray muchDarker).
		#instVar 						-> #(magenta muchDarker).
		#pseudoVariables 				-> #(red muchDarker).
		#literals 						-> #(green muchDarker).
		#messages 					-> #(blue darker).
		#incompleteMessages 			-> #(gray veryMuchDarker).
		#blockLevelZero 				-> #black.
		#blockLevelOne 				-> #brown.
		#blockLevelTwo 				-> #magenta.
		#blockLevelThree 				-> #red.
		#blockLevelFour 				-> #(orange darker).
		#blockLevelFive 				-> #(orange muchDarker).
		#blockLevelSix 				-> #(green muchDarker).
		#blockLevelSeven 				-> #blue.
		#defaults 						-> #black.
		#undefined 					-> #red.
		#methodTags 					-> #(green muchDarker).
	}! !
!DarkTheme methodsFor: 'colors' stamp: 'jmv 5/13/2025 15:43:05' prior: 16840487 overrides: 50370124!
         shout
	"Color symbols as an association list."

	^ {
		#selector  						-> '#B59F60'.
		#arguments 					-> '#289078'.
		#comment 						-> #(green duller).
		#tempBar 						-> '#707070'.
		#tempVars 					-> '#767836'.
		#instVar 						-> '#B3695A'.
		#pseudoVariables 				-> '#2070E0'.
		#literals 						-> #green.
		#messages 					-> '#6FB3BD'.
		#incompleteMessages  		-> '#F08060'.
		#blockLevelZero 				-> '#6FB3BD'.
		#blockLevelOne 				-> '#FFB0B0'.
		#blockLevelTwo 				-> '#B0FFB0'.
		#blockLevelThree 				-> '#B0B0FF'.
		#blockLevelFour 				-> '#00B0B0'.
		#blockLevelFive 				-> '#E03030'.
		#blockLevelSix 				-> '#30E030'.
		#blockLevelSeven 				-> '#3030E0'.
		#defaults 						-> '#A1AFBF'.
		#undefined 					-> '#E04020'.
		#methodTags 					-> #green.
	}! !
!Workspace class methodsFor: 'menu-world' stamp: 'jmv 5/13/2025 15:49:45' prior: 17008790!
  worldMenuOptions
	^ `{{
			#submenuOf 	-> 		TheWorldMenu openLabel.
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		20.
			#label 			-> 		'Workspace'.
			#object 		-> 		Workspace.
			#selector 		-> 		#open.
			#icon 			-> 		#terminalIcon.
			#balloonText 	-> 		'A window for evaluating Smalltalk expressions'.
		} asDictionary}`! !
!FileList methodsFor: 'initialization' stamp: 'jmv 5/13/2025 15:45:27' prior: 16862649!
topDirectoryWrappers

	topDirectories := (Preferences at: #initialFileListDirectories) 
		caseOf: {
			[ #cuis ]  	-> 	[ | topDirectoryToUse |
				topDirectoryToUse := directory. "must be inside the tree of some of the included"
				(topDirectoryToUse commonPathWith: DirectoryEntry projectBaseDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				(topDirectoryToUse commonPathWith: DirectoryEntry userBaseDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				(topDirectoryToUse commonPathWith: DirectoryEntry cuisBaseDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				(topDirectoryToUse commonPathWith: DirectoryEntry currentDirectory) ifNotNil: [ :ancestor |
					topDirectoryToUse := ancestor ].
				{ topDirectoryToUse} ].
			[ #roots ] 	-> [ DirectoryEntry roots ].
			}.
	^topDirectories collect: [ :dir |
		FileDirectoryWrapper with: dir name: (dir name ifNil: [ '/' ]) model: self ]! !
!Collection methodsFor: 'converting' stamp: 'jmv 5/13/2025 15:45:38' prior: 16827705!
    asDictionary
	"Answer a Dictionary. Assume our elements are Associations.
	{
			#itemGroup 		-> 	10.
			#itemOrder 		-> 	30.
			#label 			-> 	'Browser'.
			#object 			-> 	Browser.
			#selector 		-> 	#open.
			#icon 			-> 	#editFindReplaceIcon.
			#balloonText 	-> 	'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary
	"

	^ self as: Dictionary! !
!Transcripter class methodsFor: 'menu-world' stamp: 'jmv 5/13/2025 15:50:02' prior: 16990739!
       worldMenuOptions
	^ `{{
			#submenuOf 	-> 		TheWorldMenu openLabel.
			#itemGroup 	-> 		30.
			#itemOrder 	-> 		20.
			#label 			-> 		'Emergency Evaluator'.
			#object 		-> 		Transcripter.
			#selector 		-> 		#emergencyEvaluator.
			#icon 			-> 		#emblemImportantIcon.
			#balloonText 	-> 		'When all else fails...'.
		} asDictionary}`! !
!Float methodsFor: 'mathematical functions' stamp: 'jmv 5/13/2025 15:46:14' prior: 16864890!
                smoothStep
	"A Function that is
		x <= -1 	-> 		1
		-1 < x < 1 	->		smooth differentiable transition from 1 to 0
		1 <= x 		-> 		0
	
	It is a 'smooth' version of an #negative
	Has countless applications. For example in image and signal processing, but also in other fields."
	"
Compiler evaluate: '
	| g |
	Feature require: ''Morphic-Widgets-Extras''.
	g := FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x abs < 1 ifTrue: [1] ifFalse:[0] ] color: Color brown.
	g addFunction: [ :x | x smoothStep ] color: Color red.
	(g embeddedInMorphicWindowLabeled: ''graph'') openInWorld'
	"
	self isNaN ifTrue: [ ^self ].
	self > -1 ifFalse: [ ^ 1 ].
	1 > self ifFalse: [ ^ 0 ].
	^ (self +2 * Float halfPi) sin * 0.5 + 0.5! !
!Morph methodsFor: 'fileIn/out' stamp: 'jmv 5/13/2025 15:46:23' prior: 16906073 overrides: 16916450!
                         storeDataOn: aDataStream
	"Let all Morphs be written out.  All owners are weak references.  They only go out if the owner is in the tree being written."
	| cntInstVars cntIndexedVars ti instVarNames |

	"block my owner unless he is written out by someone else"
	cntInstVars := self class instSize.
	cntIndexedVars := self basicSize.
	instVarNames := self class allInstVarNames.
	ti := 1.  
	((instVarNames at: ti) = 'owner') & (Morph superclass == Object) ifFalse: [
		self error: 'this method is out of date'].
	aDataStream
		beginInstance: self class
		size: cntInstVars + cntIndexedVars.
	1 to: cntInstVars do: [ :i |
		(instVarNames at: i) caseOf: {
				['owner']  				-> [aDataStream nextPutWeak: owner]. 	"owner only written if in our tree"
				['id']  					-> [ aDataStream nextPut: (id bitAnd: 255) ].  "Clear id, but keep flags."
				['privateDisplayBounds']	-> [ aDataStream nextPut: nil ].  "Lazy initialized."
			}
			otherwise: [ aDataStream nextPut: (self instVarAt: i)]].
	1 to: cntIndexedVars do: [ :i |
		aDataStream nextPut: (self basicAt: i)]! !
!Sample10PythagorasTree methodsFor: 'as yet unclassified' stamp: 'jmv 5/13/2025 15:46:31' prior: 16946042 overrides: 16905506!
                        mouseScroll: aMouseEvent localPosition: localEventPosition
	aMouseEvent direction
		caseOf: {
			[ #up ] 		-> 	[ angle := angle + 0.02. self redrawNeeded ].
			[ #down ] 	-> 	[ angle := (angle - 0.02) max: 0. self redrawNeeded ].
			[ #left ] 	-> 	[ depthLimit := depthLimit - 1 max: 1. self redrawNeeded].
			[ #right ] 	-> 	[ depthLimit := depthLimit + 1 min: 15. self redrawNeeded]
		}! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 5/13/2025 15:46:39' prior: 16926331 overrides: 16905506!
         mouseScroll: aMouseEvent localPosition: localEventPosition
	aMouseEvent direction
		caseOf: {
			[ #up ] 		-> 		[ scrollBar scrollUp: 1 ].
			[ #down ] 	-> 		[ scrollBar scrollDown: 1 ].
			[ #left ] 	-> 		[ hScrollBar scrollUp: 1 ].
			[ #right ] 	-> 		[ hScrollBar scrollDown: 1 ] }! !
!CodePackageListWindow class methodsFor: 'menu-world' stamp: 'jmv 5/13/2025 15:48:05' prior: 16825322!
                         worldMenuOptions
	^ `{{
			#submenuOf 	-> 		TheWorldMenu openLabel.
			#itemGroup 	-> 		20.
			#itemOrder 	-> 		10.
			#label 			-> 		'Installed Packages'.
			#object 		-> 		CodePackageList.
			#selector 		-> 		#open.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for managing Packages (optional units of code) installed in the system'.
		} asDictionary}`! !
!BrowserWindow class methodsFor: 'menu-world' stamp: 'jmv 5/13/2025 15:47:09' prior: 16800411!
           worldMenuOptions
	^ `{{
			#submenuOf 	-> 		TheWorldMenu openLabel.
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		30.
			#label 			-> 		'Browser'.
			#object 		-> 		Smalltalk.
			#selector 		-> 		#browse.
			#icon 			-> 		#editFindReplaceIcon.
			#balloonText 	-> 		'A Smalltalk code browser, for studying and modifying the system'.
		} asDictionary}`! !
!ChangeSorterWindow class methodsFor: 'menu-world' stamp: 'jmv 5/13/2025 15:47:19' prior: 16810261!
                           worldMenuOptions
	^ `{{
			#submenuOf 	-> 		TheWorldMenu openLabel.
			#itemGroup 	-> 		20.
			#itemOrder 	-> 		20.
			#label 			-> 		'Change Sorter'.
			#object 		-> 		ChangeSorter.
			#selector 		-> 		#open.
			#icon 			-> 		#halfRefreshIcon.
			#balloonText 	-> 		'A tool allowing you to view the methods in a Change Set, especially changes to the Base System'.
		} asDictionary}`! !
!MessageNamesWindow class methodsFor: 'menu-world' stamp: 'jmv 5/13/2025 15:47:35' prior: 16896577!
                         worldMenuOptions
	^ `{{
			#submenuOf 	-> 		TheWorldMenu openLabel.
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		40.
			#label 			-> 		'Message Names'.
			#object 		-> 		MessageNames.
			#selector 		-> 		#open.
			#icon 			-> 		#inspectIcon.
			#balloonText 	-> 		'A tool for finding and editing methods that contain any given keyword in their names.'.
		} asDictionary}`! !
!FileListWindow class methodsFor: 'menu-world' stamp: 'jmv 5/13/2025 15:50:18' prior: 16863692!
          worldMenuOptions
	^ `{{
			#submenuOf 	-> 		TheWorldMenu openLabel.
			#itemGroup 	-> 		40.
			#itemOrder 	-> 		10.
			#label 			-> 		'File List'.
			#object 		-> 		FileList.
			#selector 		-> 		#open.
			#icon 			-> 		#systemFileManagerIcon.
			#balloonText 	-> 		'An explorer of the File System'.
		} asDictionary}`! !
!ProcessBrowserWindow class methodsFor: 'menu-world' stamp: 'jmv 5/13/2025 15:50:33' prior: 16932774!
                         worldMenuOptions
	^ `{{
			#submenuOf 	-> 		TheWorldMenu openLabel.
			#itemGroup 	-> 		30.
			#itemOrder 	-> 		10.
			#label 			-> 		'Process Browser'.
			#object 		-> 		ProcessBrowser.
			#selector 		-> 		#open.
			#icon 			-> 		#systemMonitorIcon.
			#balloonText 	-> 		'A tool to monitor and manage Smalltalk processes'.
		} asDictionary}`! !
!TestRunnerWindow class methodsFor: 'menu-world' stamp: 'jmv 5/13/2025 15:50:43' prior: 16978882!
   worldMenuOptions
	^ `{{
			#submenuOf 	-> 		TheWorldMenu openLabel.
			#itemGroup 	-> 		40.
			#itemOrder 	-> 		20.
			#label 			-> 		'SUnit Test Runner'.
			#object 		-> 		TestRunner.
			#selector 		-> 		#open.
			#icon 			-> 		#weatherFewCloudsIcon.
			#balloonText 	-> 		'Smalltalk''s testing framework'.
		} asDictionary}`! !
!TranscriptWindow class methodsFor: 'menu-world' stamp: 'jmv 5/13/2025 15:51:34' prior: 16990553!
                    worldMenuOptions
	^ `{{
			#submenuOf 	-> 		TheWorldMenu openLabel.
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		50.
			#label 			-> 		'Transcript'.
			#object 		-> 		Transcript.
			#selector 		-> 		#open.
			#icon 			-> 		#printerIcon.
			#balloonText 	-> 		'A window showing contents of the System Transcript'.
		} asDictionary}`! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 5/13/2025 15:52:16' prior: 16892544!
                             proportionalWidth: aNumberOrNil minimum: otherNumberOrNil
	"Alternatives:
		- proportionalWidth notNil, fixedWidth notNil 	->		Use fraction of available space, take fixedWidth as minimum desired width
		- proportionalWidth isNil, fixedWidth isNil  		->		Use current morph width
		- proportionalWidth isNil, fixedWidth notNil 	->		Use fixedWidth
		- proportionalWidth notNil, fixedWidth isNil 	->		NOT VALID"
	proportionalWidth := aNumberOrNil.
	fixedWidth := otherNumberOrNil.
	self updateContainingLayout.! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 5/13/2025 15:52:21' prior: 16892571!
             setProportionalWidth: aNumberOrNil
	"Alternatives:
		- proportionalWidth notNil, fixedWidth notNil	->		Use fraction of available space, take fixedWidth as minimum desired width
		- proportionalWidth isNil, fixedWidth isNil		->		Use current morph width
		- proportionalWidth isNil, fixedWidth notNil	->		Use fixedWidth
		- proportionalWidth notNil, fixedWidth isNil	->		NOT VALID"
	proportionalWidth := aNumberOrNil.
	self updateContainingLayout.! !
!DynamicMenuBuilder class methodsFor: 'examples' stamp: 'jmv 5/13/2025 15:52:34' prior: 16851579!
                             exampleItemWithoutSubMenu

	^ {
		#itemGroup 	-> 		10.
		#itemOrder 	-> 		10.
		#label 			-> 		'item without submenu'.
		#selector 		-> 		#printString.
		#icon 			-> 		#editFindReplaceIcon
	} asDictionary! !
!DynamicMenuBuilder class methodsFor: 'examples' stamp: 'jmv 5/13/2025 15:52:47' prior: 16851597!
              exampleWithSubMenusDefinition

	| topItemWithSubMenus subItemWithSubMenu |
	
	topItemWithSubMenus := 'top item with submenu...'.
	subItemWithSubMenu := 'subitem with submenu...'.
	
	^ {
			self exampleItemWithoutSubMenu.
			{
				#itemGroup 	-> 		20.
				#itemOrder 	-> 		10.
				#label 			-> 		topItemWithSubMenus.
				#selector 		-> 		nil.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#submenuOf -> topItemWithSubMenus .
				#itemGroup 	-> 		10.
				#itemOrder 	-> 		10.
				#label 			-> 		'subitem without submenu'.
				#selector 		-> 		#printString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> topItemWithSubMenus .
				#itemGroup 	-> 		10.
				#itemOrder 	-> 		20.
				#label 			-> 		subItemWithSubMenu.
				#selector 		-> 		#printString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
			{
				#submenuOf -> topItemWithSubMenus.
				#itemGroup 	-> 		20.
				#itemOrder 	-> 		10.
				#label 			-> 		'another subitem without submenu'.
				#selector 		-> 		#printString.
				#icon 			-> 		#listAddIcon
			} asDictionary.
			{
				#submenuOf -> subItemWithSubMenu.
				#itemGroup 	-> 		10.
				#itemOrder 	-> 	10.
				#label 			-> 		'sub sub item without submenu'.
				#selector 		-> 		#printString.
				#icon 			-> 		#saveAsIcon
			} asDictionary.
		}
	! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 5/13/2025 15:53:05' prior: 16986002!
       additionalMenuOptions

	^`{
		{
			#submenuOf  		-> 		TheWorldMenu openLabel.
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		30.
			#label 				-> 		'Package Installer'.
			#selector 			-> 		#openPackageInstaller.
			#icon 				-> 		#packageIcon.
			#balloonText 		-> 		'A tool for installing Cuis packages from the local file system.'.
		} asDictionary.
		{
			#submenuOf  		-> 		TheWorldMenu openLabel.
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		40.
			#label 				-> 		'Package Downloader'.
			#selector 			-> 		#openPackageDownloader.
			#icon 				-> 		#packageIcon.
			#balloonText 		-> 		'A tool for downloading Cuis packages from the internet.'.
		} asDictionary.
	}`	
	! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 5/13/2025 15:53:46' prior: 16986031!
                       changesMenuOptions

	^`{
			{
				#submenuOf  	-> 		TheWorldMenu changesLabel.
				#itemGroup 	-> 		10.
				#itemOrder 	-> 		10.
				#label 			-> 		'Change Sorter'.
				#object 		-> 		ChangeSorter.
				#selector 		-> 		#open.
				#icon 			-> 		#halfRefreshIcon.
				#balloonText 	-> 		'Open a 3-paned changed-set viewing tool'.
			} asDictionary.
			{
				#submenuOf  	-> 		TheWorldMenu changesLabel.
				#itemGroup 	-> 		20.
				#itemOrder 	-> 		10.
				#label 			-> 		'Install New Updates'.
				#object 		-> 		ChangeSet.
				#selector 		-> 		#installNewUpdates.
				#icon 			-> 		#updateIcon.
				#balloonText 	-> 		'Install in the current image the new updates available
in directory named ./CoreUpdates
or in directory named ../Cuis-Smalltalk-Dev/CoreUpdates'.
			} asDictionary.
			{
				#submenuOf  	-> 		TheWorldMenu changesLabel.
				#itemGroup 	-> 		30.
				#itemOrder 	-> 		10.
				#label 			-> 		'Browse my Changes'.
				#object 		-> 		Smalltalk.
				#selector 		-> 		#browseMyChanges.
				#icon 			-> 		#editFindReplaceIcon.
				#balloonText 	-> 		'Browse all of my changes since the last time #condenseSources was run.'.
			} asDictionary.
			{
				#submenuOf  	-> 		TheWorldMenu changesLabel.
				#itemGroup 	-> 		30.
				#itemOrder 	-> 		20.
				#label 			-> 		'Recently logged Changes...'.
				#object 		-> 		ChangeList.
				#selector 		-> 		#browseRecentLog.
				#icon 			-> 		#clockIcon.
				#balloonText 	-> 		'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'.
			} asDictionary.
			{
				#submenuOf  	-> 		TheWorldMenu changesLabel.
				#itemGroup 	-> 		40.
				#itemOrder 	-> 		10.
				#label 			-> 		'Save World as morph file'.
				#selector 		-> 		#saveWorldInFile.
				#icon 			-> 		#morphsIcon.
				#balloonText 	-> 		'Save a file that, when reloaded, reconstitutes the current World.'.
			} asDictionary.
		}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 5/13/2025 15:55:20' prior: 16986161!
                       helpMenuOptions

	^ `{
			{
				#submenuOf 		-> 		TheWorldMenu helpLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 				-> 		'About this System...'.
				#object 			-> 		Smalltalk.
				#selector 			-> 		#aboutThisSystem.
				#icon 				-> 		#helpIcon.
				#balloonText 		-> 		'current version information.'
			} asDictionary.
			{
				#submenuOf 		-> 		TheWorldMenu helpLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 				-> 		'Terse Guide to Cuis'.
				#selector 			-> 		#openTerseGuide.
				#icon 				-> 		#helpIcon.
				#balloonText 		-> 		'explore Cuis Smalltalk'
			} asDictionary.
			{
				#submenuOf 		-> 		TheWorldMenu helpLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 				-> 		'Class Comment Browser'.
				#selector 			-> 		#openCommentGuide.
				#icon 				-> 		#helpIcon.
				#balloonText 		-> 		'Search & explore Cuis Class Comments. Requires cloning "Cuis-Smalltalk-Tools" git repo.'
			} asDictionary.
			{
				#submenuOf 		-> 		TheWorldMenu helpLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		40.
				#label 				-> 		'Code management in Cuis'.
				#object 			-> 		Utilities.
				#selector 			-> 		#openCodeManagementInCuis.
				#icon 				-> 		#helpIcon.
				#balloonText 		-> 		'Features are kept in Packages.'
			} asDictionary.
			{
				#submenuOf 		-> 		TheWorldMenu helpLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		50.
				#label 				-> 		'Using GitHub to host Cuis packages'.
				#object 			-> 		Utilities.
				#selector 			-> 		#openCuisAndGitHub.
				#icon 				-> 		#helpIcon.
				#balloonText 		-> 		'GitHub usage pattern.'
			} asDictionary.
			{
				#submenuOf 		-> 		TheWorldMenu helpLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 				-> 		'Editor keyboard shortcuts'.
				#object 			-> 		SmalltalkEditor.
				#selector 			-> 		#openHelp.
				#icon 				-> 		#keyboardShortcutsIcon.
				#balloonText 		-> 		'summary of keyboard shortcuts in editors for Smalltalk code.'
			} asDictionary.
			{
				#submenuOf 		-> 		TheWorldMenu helpLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 				-> 		'Useful Expressions'.
				#object 			-> 		Utilities.
				#selector 			-> 		#openUsefulExpressions.
				#icon 				-> 		#chatIcon.
				#balloonText 		-> 		'a window full of useful expressions.'
			} asDictionary.
			{
				#submenuOf 		-> 		TheWorldMenu helpLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 				-> 		'VM Statistics'.
				#selector 			-> 		#vmStatistics.
				#icon 				-> 		#systemMonitorIcon.
				#balloonText 		-> 		'obtain some intriguing data about the vm.'
			} asDictionary.
			{
				#submenuOf 		-> 		TheWorldMenu helpLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 				-> 		'Space Left'.
				#selector 			-> 		#garbageCollect.
				#icon 				-> 		#removableMediaIcon.
				#balloonText 		-> 		'perform a full garbage-collection and report how many bytes of space remain in the image.'
			} asDictionary.
		}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 5/13/2025 15:57:42' prior: 16986267!
                         preferencesMenuOptions

	^`{
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 				-> 		'Focus follows Mouse'.
				#selector 			-> 		#enableFocusFollowsMouse.
				#icon 				-> 		#windowIcon.
				#balloonText 		-> 		'At all times, make the active window and widget the one on which the mouse is located.'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 				-> 		'Focus when Click'.
				#selector 			-> 		#disableFocusFollowsMouse.
				#icon 				-> 		#windowIcon.
				#balloonText 		-> 		'At all times, make the active window and widget the one where the mouse was clicked.'
			} asDictionary.

			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 				-> 		'Show ST-80 assignments'.
				#selector 			-> 		#enableShowAssignmentAsLeftArrow.
				#icon 				-> 		#editFindReplaceIcon.
				#balloonText 		-> 		'Show variable assignment in Smalltalk-80 style (left arrow).'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 				-> 		'Show ANSI assignments'.
				#selector 			-> 		#disableShowAssignmentAsLeftArrow.
				#icon 				-> 		#editFindReplaceIcon.
				#balloonText 		-> 		'Show variable assignment in ANSI style ( := ).'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 				-> 		'Size of GUI elements...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeFontSizes.
				#icon 				-> 		#preferencesDesktopFontIcon.
				#balloonText 		-> 		'use larger or smaller text and widgets'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label				-> 		'Set System Font...'.
				#object 			-> 		FontFamily.
				#selector 			-> 		#promptUserAndSetDefault.
				#icon 				-> 		#preferencesDesktopFontIcon.
				#balloonText 		-> 		'change the current system font family.'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		60.
				#label				-> 		'Load all TrueType Fonts'.
				#object 			-> 		TrueTypeFontFamily.
				#selector 			-> 		#readAdditionalFonts.
				#icon 				-> 		#preferencesDesktopFontIcon.
				#balloonText 		-> 		'Load additional TrueType fonts included with Cuis.'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		70.
				#label 				-> 		'Icons...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeIcons.
				#icon 				-> 		#worldIcon.
				#balloonText 		-> 		'show more or less icons.'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		80.
				#label 				-> 		'Themes...'.
				#object 			-> 		Theme.
				#selector 			-> 		#changeTheme.
				#icon 				-> 		#appearanceIcon.
				#balloonText 		-> 		'switch to another theme.'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 				-> 		'Show taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#showTaskbar.
				#icon 				-> 		#expandIcon.
				#balloonText 		-> 		'show the taskbar'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 				-> 		'Hide taskbar'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#hideTaskbar.
				#icon 				-> 		#collapseIcon.
				#balloonText 		-> 		'hide the taskbar'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		10.
				#label 				-> 		'Full screen on'.
				#selector 			-> 		#fullScreenOn.
				#icon 				-> 		#viewFullscreenIcon.
				#balloonText 		-> 		'puts you in full-screen mode, if not already there.'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		50.
				#itemOrder 		-> 		20.
				#label 				-> 		'Full screen off'.
				#selector 			-> 		#fullScreenOff.
				#icon 				-> 		#exitFullscreenIcon.
				#balloonText 		-> 		'if in full-screen mode, takes you out of it.'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		10.
				#label 				-> 		'Save Prefs in UserPrefs.txt'.
				#selector 			-> 		#enableUsePrefsFile.
				#icon 				-> 		#windowIcon.
				#balloonText 		-> 		'Preferences are saved without need to save the Smalltalk Image.'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		20.
				#label 				-> 		'Save Prefs in the Image'.
				#selector 			-> 		#disableUsePrefsFile.
				#icon 				-> 		#windowIcon.
				#balloonText 		-> 		'Preferences are lost unless the Smalltalk Image is saved.'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		30.
				#label 				-> 		'Set Code Author...'.
				#object 			-> 		Utilities.
				#selector 			-> 		#setAuthor.
				#icon 				-> 		#usersIcon.
				#balloonText 		-> 		'supply initials to be used to identify the author of code and other content.'
			} asDictionary.
			{
				#submenuOf  		-> 		TheWorldMenu preferencesLabel.
				#itemGroup 		-> 		60.
				#itemOrder 		-> 		40.
				#label 				-> 		'All preferences...'.
				#object 			-> 		PreferenceSet.
				#selector 			-> 		#openPreferencesInspector.
				#icon 				-> 		#preferencesIcon.
				#balloonText 		-> 		'view and change various options.'
			} asDictionary.
		}`.! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 5/13/2025 16:02:20' prior: 16986457!
                         windowsMenuOptions

	^`{
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		10.
				#label 				-> 		'Find Window'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findWindow:.
				#icon 				-> 		#windowIcon.
				#balloonText 		-> 		'Presents a list of all windows; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		20.
				#label 				-> 		'Find changed Browsers...'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findDirtyBrowsers:.
				#icon 				-> 		#editFindReplaceIcon.
				#balloonText 		-> 		'Presents a list of browsers that have unsaved changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		10.
				#itemOrder 		-> 		30.
				#label 				-> 		'Find changed Windows...'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findDirtyWindows:.
				#icon 				-> 		#newWindowIcon.
				#balloonText 		-> 		'Presents a list of all windows that have unsaved changes; if you choose one from the list, it becomes the active window.'
			} asDictionary.
			{
				#submenuOf  		->  					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		10.
				#label 				-> 		'Find a Transcript'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findATranscript:.
				#icon 				-> 		#printerIcon.
				#balloonText 		-> 		'Brings an open Transcript to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		20.
				#label 				-> 		'Find a FileList'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAFileList:.
				#icon 				-> 		#systemFileManagerIcon.
				#balloonText 		-> 		'Brings an open fileList  to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		30.
				#label 				-> 		'Find a Change Sorter'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAChangeSorter:.
				#icon 				-> 		#changesIcon.
				#balloonText 		-> 		'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		20.
				#itemOrder 		-> 		40.
				#label 				-> 		'Find Message Names'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#findAMessageNamesWindow:.
				#icon 				-> 		#inspectIcon.
				#balloonText 		-> 		'Brings an open MessageNames window to the front, creating one if necessary, and makes it the active window'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		10.
				#label 				-> 		'Tile open windows'.
				#object          		-> 		TileResizeMorph.
				#selector 			-> 		#tileOpenWindows.
				#icon 				-> 		#windowIcon.
				#balloonText 		-> 		'Tile open windows'.
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		20.
				#label 				-> 		'Collapse all Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#collapseAll.
				#icon 				-> 		#collapseIcon.
				#balloonText 		-> 		'Reduce all open windows to collapsed forms that only show titles.'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		30.
				#label 				-> 		'Restore all Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#restoreAll.
				#icon 				-> 		#expandIcon.
				#balloonText 		-> 		'Restore all collapsed windows back to their previous forms.'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		40.
				#label 				-> 		'Close top Window'.
				#object 			-> 		SystemWindow.
				#selector 			-> 		#closeTopWindow.
				#icon 				-> 		#closeIcon.
				#balloonText 		-> 		'Close the topmost window if possible.'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		50.
				#label 				-> 		'Send top Window to back'.
				#object 			-> 		SystemWindow.
				#selector 			-> 		#sendTopWindowToBack.
				#icon 				-> 		#goBottomIcon.
				#balloonText 		-> 		'Make the topmost window become the backmost one, and activate the window just beneath it.'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		30.
				#itemOrder 		-> 		60.
				#label 				-> 		'Move Windows onscreen'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#bringWindowsFullOnscreen.
				#icon 				-> 		#displayIcon.
				#balloonText 		-> 		'Make all windows fully visible on the screen'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		10.
				#label 				-> 		'Delete unchanged Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#closeUnchangedWindows.
				#icon 				-> 		#warningIcon.
				#balloonText 		-> 		'Deletes all windows that do not have unsaved text edits.'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		20.
				#label 				-> 		'Delete non Windows'.
				#object 			-> 		#myWorld.
				#selector 			-> 		#deleteNonWindows.
				#icon 				-> 		#warningIcon.
				#balloonText 		-> 		'Deletes all non-window morphs lying on the world.'
			} asDictionary.
			{
				#submenuOf  		-> 					TheWorldMenu windowsLabel.
				#itemGroup 		-> 		40.
				#itemOrder 		-> 		30.
				#label 				-> 		'Delete Both of the Above'.
				#selector 			-> 		#cleanUpWorld.
				#icon 				-> 		#warningIcon.
				#balloonText 		-> 		'Deletes all unchanged windows and all non-window morphs on the world.'
			} asDictionary.
		}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 5/13/2025 16:03:49' prior: 16986650!
                         worldMainMenuOptions

	^`{
		{
			#itemGroup 			-> 		10.
			#itemOrder 			-> 		10.
			#label 					-> 		TheWorldMenu openLabel.
			#selector 				-> 		#yourself.
			#icon 					-> 		#openIcon.
			#balloonText			-> 		'Submenu to open various system tools'.
		} asDictionary.
		{
			#itemGroup 			-> 		10.
			#itemOrder 			-> 		20.
			#label 					-> 		'New morph...'.
			#selector				-> 		#newMorph.
			#icon 					-> 		#morphsIcon.
			#balloonText 			-> 		'Offers a variety of ways to create new objects'.
		} asDictionary.
		{
			#itemGroup 			-> 		10.
			#itemOrder 			-> 		30.
			#label 					-> 		TheWorldMenu preferencesLabel.
			#selector 				-> 		#yourself.
			#icon 					-> 		#preferencesIcon.
			#balloonText 			-> 		'Opens a menu offering many controls over appearance and system preferences.'.
		} asDictionary.
		{
			#itemGroup 			-> 		10.
			#itemOrder 			-> 		40.
			#label 					-> 		TheWorldMenu windowsLabel.
			#selector 				-> 		#yourself.
			#icon 					-> 		#windowIcon.
			#balloonText 			-> 		'Manage open windows'.
		} asDictionary.
		{
			#itemGroup 			-> 		10.
			#itemOrder 			-> 		50.
			#label 					-> 		TheWorldMenu helpLabel.
			#selector 				-> 		#yourself.
			#icon 					-> 		#helpIcon.
			#balloonText 			-> 		'Opens a menu of useful items for updating the system, determining what version you are running, and much else'.
		} asDictionary.
		{
			#itemGroup 			-> 		20.
			#itemOrder 			-> 		10.
			#label 					-> 		TheWorldMenu changesLabel.
			#selector 				-> 		#yourself.
			#icon 					-> 		#changesIcon.
			#balloonText 			-> 		'Opens a menu of useful tools for dealing with changes'.
		} asDictionary.
		{
			#itemGroup 			-> 		20.
			#itemOrder 			-> 		20.
			#label 					-> 		TheWorldMenu debugLabel.
			#selector 				-> 		#yourself.
			#icon 					-> 		#debugIcon.
			#balloonText 			-> 		'a menu of debugging items'.
		} asDictionary.
		{
			#itemGroup 			-> 		20.
			#itemOrder 			-> 		30.
			#label 					-> 		'Restore Display'.
			#object 				-> 		#myWorld.
			#selector 				-> 		#restoreDisplay.
			#icon 					-> 		#displayIcon.
			#balloonText 			-> 		'Repaint the screen -- useful for cleaning unwanted display artifacts.'.
		} asDictionary.
		{
			#itemGroup 			-> 		30.
			#itemOrder 			-> 		10.
			#label 					-> 		'Save Image'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveImage.
			#icon 					-> 		#saveIcon.
			#balloonText 			-> 		'Save the current state of the image on disk. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 			-> 		30.
			#itemOrder 			-> 		20.
			#label 					-> 		'Save Image as...'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAs.
			#icon 					-> 		#saveAsIcon.
			#balloonText 			-> 		'Save the current state of the image on disk under a new name.'.
		} asDictionary.
		{
			#itemGroup 			-> 		30.
			#itemOrder 			-> 		30.
			#label 					-> 		'Save Image and Quit'.
			#object 				-> 		Smalltalk.
			#selector 				-> 		#saveAndQuit.
			#icon 					-> 		#saveAndQuitIcon.
			#balloonText 			-> 		'Save the image and quit out of Cuis. Overwrite existing file.'.
		} asDictionary.
		{
			#itemGroup 			-> 		50.
			#itemOrder 			-> 		40.
			#label 					-> 		'Quit without saving'.
			#selector 				-> 		#quitSession.
			#icon 					-> 		#quitIcon.
			#balloonText 			-> 		('Quit out of Cuis without saving the image.\',
									'Ask for confirmation if there are unsaved changes.') withNewLines.
		} asDictionary.
	}`! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'jmv 5/13/2025 16:04:20' prior: 16986778!
                         worldSaveReleaseImagesMenuOptions
	"
	Preferences
		name: #saveReleaseOptionsInWorldMenu
		description: 'Include options for saving Stable and Rolling Release images'
		category: #system type: Boolean value: false
	"

	^`{
				{
					#itemGroup 		-> 		40.
					#itemOrder 		-> 		10.
					#label 				-> 		'Save Stable Release'.
					#object 			-> 		Smalltalk.
					#selector 			-> 		#saveStableRelease.
					#icon 				-> 		#saveAsNewVersionIcon.
					#balloonText 		-> 		('Save as a new official Stable Release of Cuis.\',
												'See naming in #saveStableRelease.\',
												'Clear all user preferences and class vars.\',
												'Write new compacted Sources file, an empty\',
												'Changes file, and save the Image on disk.\') withNewLines.
				} asDictionary.
				{
					#itemGroup 		-> 		40.
					#itemOrder 		-> 		20.
					#label 				-> 		'Save Rolling Release, Quit'.
					#object 			-> 		Smalltalk.
					#selector 			-> 		#saveRollingReleaseAndQuit.
					#icon 				-> 		#saveAsNewVersionIcon.
					#balloonText 		-> 		('Save as update of the Rolling Release of Cuis.\',
												'Clear all user preferences and class vars.\',
												'Save Image and Changes with update number.\',
												'Quit Cuis.\') withNewLines.
				} asDictionary.
			}`! !
!PreferenceSet class methodsFor: 'sys event handlers' stamp: 'jmv 5/13/2025 16:04:28' prior: 16930437!
                     machine: machinePref
" Update the preferences for this kind of machine (#default, #slow or #smalltalk80) "
	| prefArray selector |
	selector := machinePref caseOf: {
			[#default]		 		-> [#machineDefault].
			[#slow] 				-> [#machineSlow].
			[#smalltalk80] 			-> [#machineSmalltalk80] }
		otherwise: [ #machineDefault ].
	prefArray := self perform: selector.
	prefArray do: [:array | 		self sysPreferences at: array first put: array second].
	machinePref value == #slow ifTrue: [		self runningWorld backgroundImageData: nil].! !
!TextEditor class methodsFor: 'menu-world' stamp: 'jmv 5/13/2025 15:51:20' prior: 16983776!
                  worldMenuOptions
	^ `{{
			#submenuOf 	-> 		TheWorldMenu openLabel.
			#itemGroup 	-> 		10.
			#itemOrder 	-> 		10.
			#label 			-> 		'Text Editor'.
			#object 		-> 		TextEditor.
			#selector 		-> 		#open.
			#icon 			-> 		#textEditorIcon.
			#balloonText 	-> 		'A window for composing text'.
		} asDictionary}`! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 5/13/2025 16:04:42' prior: 16809155!
   notInstallOrTestRun

	^Installing isNil or: [
		(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]]
	
	"
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name = 'TestRunner' ]	-> Test
	(Installing beginsWith: Install-')															-> Install
	Installing isNil 																			-> Normal
	(Installing beginsWith: 'RunningTest-') and: [ Processor activeProcess name ~= 'TestRunner' ]	-> Normal
	"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7158-CodeFormatting-JuanVuletich-2025May13-15h40m-jmv.001.cs.st----!

----QUIT----(13 May 2025 17:35:54) Cuis7.3-7158.image priorSource: 850041!

----STARTUP---- (24 May 2025 10:43:02) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.3-7158.image!


'From Cuis7.3 [latest update: #7158] on 14 May 2025 at 11:06:20 am'!
!CompiledMethod methodsFor: '[mk] printing' stamp: 'jmv 5/14/2025 10:40:39' prior: 16833360!
                            printClassAndSelectorOn: aStream

	aStream
		print: self methodClass;
		nextPutAll: '>>'.
	self selector storeOn: aStream! !
!CompiledMethod methodsFor: '[mk] printing' stamp: 'jmv 5/14/2025 10:35:47' prior: 16833367 overrides: 50355187!
                  printOn: aStream
	"Overrides method inherited from the byte arrayed collection."

	aStream nextPut: $(.
	self printClassAndSelectorOn: aStream.
	aStream space; nextPut: $"; nextPut: $a; space.
	aStream nextPutAll: self class name.
	aStream nextPut: $:; print: self size.
	aStream nextPut: $(; print: self identityHash; nextPut: $); nextPut: $"; nextPut: $)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7159-MinimalKernel-JuanVuletich-2025May14-10h25m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7158] on 14 May 2025 at 11:23:56 am'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7160-MinimalKernel-JuanVuletich-2025May14-11h06m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7160] on 14 May 2025 at 3:44:23 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7161-MinimalKernel-JuanVuletich-2025May14-15h05m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7160] on 14 May 2025 at 3:57:28 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7162-MinimalKernel-JuanVuletich-2025May14-15h44m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7160] on 14 May 2025 at 4:10:32 pm'!
!WeakSet methodsFor: '[mkSymbol] accessing' stamp: 'jmv 5/14/2025 16:10:12' prior: 50341641 overrides: 16827542!
  size
	| answer |
	answer := 0.
	buckets do: [ :bucket |
		bucket notNil ifTrue: [
			bucket do: [ :elem |
				elem notNil ifTrue: [ answer := answer + 1 ]]]].
	^answer.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7163-MinimalKernel-JuanVuletich-2025May14-15h57m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7160] on 14 May 2025 at 4:42:52 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7164-MinimalKernel-JuanVuletich-2025May14-16h10m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7160] on 15 May 2025 at 9:57:57 am'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7165-MinimalKernel-JuanVuletich-2025May14-16h42m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7165] on 15 May 2025 at 2:33:30 pm'!
!ProtoObject methodsFor: '[mk] printing' stamp: 'jmv 5/15/2025 14:19:33'!
       printOn: aStream
	"Append to the argument, aStream, a sequence of characters that  
	identifies the receiver.
	"
	self class isMeta
		ifFalse: [ aStream nextPutAll: 'an instance of ' ]
		ifTrue: [ aStream nextPutAll: 'class ' ].
	self class theNonMetaClass printNameOn: aStream.! !
!ProtoObject methodsFor: '[mk] error handling' stamp: 'jmv 5/15/2025 14:20:01' prior: 50369960!
      doesNotUnderstand: aMessage
	"
	Note: Subclasses of ProtoObject will redefine this message.
	This implementation will only be used when the Exception based one at Object is missing.
	This may happen in minimal bootstrapped images.
	"
	| context count |
	StdIOWriteStream stdout flush.
	StdIOWriteStream stdout newLine;
		nextPutAll: 'Message not understood.'; newLine;
		nextPutAll: 'Receiver: '.
	self printOn: StdIOWriteStream stdout.
	StdIOWriteStream stdout
		nextPutAll: ' selector: #';
		nextPutAll: aMessage selector; newLine;
		nextPutAll: '------ Call Stack: '; newLine;
		flush.

	context := thisContext sender.
	count := 0.
	[context notNil and: [ count < 10 ]] whileTrue: [
		context printOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout newLine.
		context := context sender.
		count := count + 1 ].

	StdIOWriteStream stdout newLine;
		nextPutAll: 'Will exit now.';
		newLine;
		flush.

	Smalltalk quitPrimitive: 127.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7166-MinimalKernel-JuanVuletich-2025May15-14h17m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7158] on 15 May 2025 at 7:17:20 pm'!
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 5/15/2025 17:15:57' overrides: 16920698!
                visitAssignmentNode: anAssignmentNode 
	
	self addToEquivalentsIfOneStatementEquivalentTo: anAssignmentNode.
	
	^super visitAssignmentNode: anAssignmentNode 
! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 5/15/2025 17:18:13' overrides: 16920707!
                           visitBacktickNode: aBacktickNode 
	
	self addToEquivalentsIfOneStatementEquivalentTo: aBacktickNode.
	
	^super visitBacktickNode: aBacktickNode! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 5/15/2025 19:08:30'!
                              skipSeparatorsFrom: aStartIndex by: aStep in: aSourceCode
	
	| char index |
	
	index := aStartIndex + aStep.
	[ char := aSourceCode at: index ifAbsent: [ Character null ].
	char isSeparator ] whileTrue: [ index := index + aStep ].
	
	^char -> index! !
!MessageNode methodsFor: 'source ranges' stamp: 'HAW 5/15/2025 14:08:46' prior: 50365042 overrides: 16920006!
                      expandRanges: aSourceRange basedOn: sourceRanges using: sourceCode

	| receiverExpandedRanges expandedRangeWithReceiver |
	
	receiverExpandedRanges := self isCascade
		ifTrue: [ aSourceRange ] "not expanded because expansion is handled in CascadeNode"
		ifFalse: [ originalReceiver expandRanges: (self receiverSourceRangesFrom: sourceRanges) basedOn: sourceRanges using: sourceCode ].
	expandedRangeWithReceiver := self
		expandRange: (aSourceRange isInterval ifTrue: [ aSourceRange ] ifFalse: [ aSourceRange first ])
		basedOn: receiverExpandedRanges.
	^ super
		expandRanges: expandedRangeWithReceiver
		basedOn: expandedRangeWithReceiver
		using: sourceCode! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 5/15/2025 19:15:42' prior: 16958081!
         expandToMatchExpressionOn: aSourceCode
	"takes a source code and if the source range references an expression
	that can be expanded and still is valid, it returns the source range
	'grown'. Examples: (*3 + 4*) to *(3 + 4)*; `*3 + 4*` to *`3 + 4`*"

	| firstCharAndIndex lastCharAndIndex |
	 
	firstCharAndIndex := self skipSeparatorsFrom: start by: -1 in: aSourceCode.
	lastCharAndIndex := self skipSeparatorsFrom: stop by: 1 in: aSourceCode.
	
	^ (self canBeExpandedStartingWith: firstCharAndIndex key endingWith: lastCharAndIndex key)
		ifTrue: [ self class from: firstCharAndIndex value to: lastCharAndIndex value ]
		ifFalse: [ self ]! !
!CompiledMethod methodsFor: 'method node' stamp: 'HAW 5/15/2025 18:24:41' prior: 16834198!
   createMethodNodeOptimizeSpecialSends: doOptimizeSpecialSends
	"Creates the parse tree that represents self"
	| aClass source |
	aClass := self methodClass.
	source := self
		getSourceFor: (self selector ifNil: [ self defaultSelector ])
		in: aClass.
	"OMeta2 (and maybe others) could do source code transformations that mean #methodNodeFor: could fail.
	To avoid incopatibility with other parsers, we only send the message methodNodeFor:noPattern:optimizeSpecialSends: 
	when it is false that is the special case needed for the refactorings - Hernan"
	^ (doOptimizeSpecialSends
		ifTrue: [ 	(aClass methodNodeFor: source) ]
		ifFalse: [ (aClass methodNodeFor: source noPattern: false optimizeSpecialSends: false) ]) 
			ifNil: [ self decompile ].! !
!SourceCodeOfMethodToBeExtractedPrecondition methodsFor: 'private' stamp: 'HAW 5/15/2025 17:30:28' prior: 16958610!
                              findSourceRangeOfCloserStatementIn: listOfAncestors ifNone: noneBlock

	^ (listOfAncestors
		detect: [ :assoc | assoc key isBlockNode or: [ assoc key isReturn ]]
		ifFound: [ :assoc | listOfAncestors before: assoc ifNone: noneBlock ]
		ifNone: noneBlock) value! !

SourceCodeInterval removeSelector: #expandBy:!

!methodRemoval: SourceCodeInterval #expandBy: stamp: 'Install-7167-ExtractMethodFixes-HernanWilkinson-2025May15-12h29m-HAW.001.cs.st 5/24/2025 10:43:03'!
expandBy: quantity

	^ (start - quantity to: stop + quantity) asSourceCodeInterval!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7167-ExtractMethodFixes-HernanWilkinson-2025May15-12h29m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7158] on 15 May 2025 at 7:20:19 pm'!
!SimulationSideEffectWarning methodsFor: 'printing' stamp: 'HAW 5/15/2025 19:19:55' prior: 50346733 overrides: 16856659!
                       messageText

	^ messageText ifNil: [
		'The code being simulated is trying to control a process ({1}). {2}' translated format: {
			self context method asMethodReference.
			self isSimulationGuard
				ifTrue: ['If you proceed, your image may be locked. Continue at own risk, and better save your image before.' translated]
				ifFalse: ['Process controlling cannot be simulated. If you proceed, side effects may occur outside the observable area of the simulator.' translated]}]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7168-SimulationSideEffectWarningMessageTextFix-HernanWilkinson-2025May15-19h19m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7166] on 17 May 2025 at 7:04:09 pm'!
!Halt methodsFor: 'description' stamp: 'jmv 5/17/2025 18:40:16' prior: 16872886 overrides: 16856664!
                         noHandler
	"If this preference is set, Halt behaves like any other Exception:
		- following any appropriate exception handler
		- throwing the UnhandledError exception if no handler
	This means that Halt can be masked (hidden) by a handler of UnhandledError.
	This is the traditional behavior, but can be a pain if such handler is present."
	(Preferences at: #haltThrowsUnhandledError) ifTrue: [
		super noHandler.
		^self ].

	"Usually Halt should not be caught by an UnhandledError handler, meaning that a Debugger will open
	even in the presence of a handler of UnhandledError that hides most exceptions."
	UnhandledError defaultActionForException: self! !
!ContextPart methodsFor: 'controlling' stamp: 'jmv 5/17/2025 19:03:11' prior: 16837856!
                    runUntilErrorOrReturnFrom: aSenderContext
	"ASSUMES aSenderContext is a sender of self.  Execute self's stack until aSenderContext returns or an unhandled exception is raised.  Return a pair containing the new top context and a possibly nil exception.  The exception is not nil if it was raised before aSenderContext returned and it was not handled.  The exception is returned rather than openning the debugger, giving the caller the choice of how to handle it."
	"Self is run by jumping directly to it (the active process abandons thisContext and executes self).  However, before jumping to self we insert an ensure block under aSenderContext that jumps back to thisContext when evaluated.  We also insert an exception handler under aSenderContext that jumps back to thisContext when an unhandled exception is raised.  In either case, the inserted ensure and exception handler are removed once control jumps back to thisContext."

	| error exceptionHandlerContext ensureContext ctxt here topContext |
	aSenderContext method isQuick ifTrue: [ 
		^ {aSenderContext step. nil}
	].
	
	here := thisContext.

	"Insert ensure and exception handler contexts under aSenderContext.
	As Halt may not raise an UnhandledError (see #noHandler), it may need to be handled explicitly here."
	error := nil.
	exceptionHandlerContext := ContextPart
		contextOn: UnhandledError, Halt do: [ :unhandledErrorOrException |
			error ifNil: [
				topContext := thisContext.
				error := (unhandledErrorOrException isKindOf: UnhandledError)
					ifTrue: [ unhandledErrorOrException exception ]
					ifFalse: [ unhandledErrorOrException ].
				Debugger updateDebuggersLeadingTo: aSenderContext for: error.
				unhandledErrorOrException resumeUnchecked: here jump ]
			ifNotNil: [unhandledErrorOrException pass ]].
	ctxt := aSenderContext insertSender: exceptionHandlerContext.
	ensureContext := ContextPart
		contextEnsure: [
			error ifNil: [
				topContext := thisContext.
				here jump ]].
	ctxt := ctxt insertSender: ensureContext.
	self jump.  "Control jumps to self"

	"Control resumes here once above ensure block or exception handler is executed"
	^ error ifNil: [
		"No error was raised, remove ensure context by stepping until popped"
		[ctxt isDead or: [topContext isNil]] whileFalse: [topContext := topContext stepToCalleeOrNil].
		{topContext. nil}

	] ifNotNil: [
		"Error was raised, remove inserted above contexts then return signaler context"
		aSenderContext terminateTo: ctxt sender.  "remove above ensure and handler contexts"
		{topContext. error}
	].! !
!Process methodsFor: 'changing suspended state' stamp: 'jmv 5/17/2025 18:51:23' prior: 50367649!
          stepToHome: aContext 
	"Resume self until the home of top context is aContext.  Top context may be a block context.
	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext
	 if so. Note that this will cause weird effects if using through to step through UnhandledError
	 code, but as the doctor ordered, don't do that; use over or into instead."

	| home |
	home := aContext home.
	[
		suspendedContext := suspendedContext step.
		home == suspendedContext home or: [ suspendedContext sender isNil or: [suspendedContext sender isDead]]
	] whileFalse:
		[
			self ifSuspendedContextIsUnhandledErrorDo:
				[ :anError |
					anError signalerContext ifNotNil:
						[ :unhandledErrorSignalerContext |
							self completeStepUpTo: unhandledErrorSignalerContext.
							"Give a debugger a chance to update its title to reflect the new exception"
							 Notification signalToUpdateDebuggerOn: unhandledErrorSignalerContext dueTo: anError.
							^unhandledErrorSignalerContext ]]].
		
	^suspendedContext! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 5/17/2025 18:33:33' prior: 16930186!
             prefSystem
	^ #(
		#(allowNonLocalReturnsInExceptionHandlers true )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges true )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(warnAndOfferLastUserChanges true )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #cuis #(cuis roots) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(useUserPrefsFile true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
		#(saveReleaseOptionsInWorldMenu false)
	)! !
!PreferenceSet class methodsFor: 'sys preference' stamp: 'jmv 5/17/2025 18:36:20' prior: 50358336!
                       installMiscPreferences
" Preferences with value defined as a closure. We could insert in a dynamic array...
  Preferences with an event handler.
  Preferences with default value of anything but simple literals."
	self sysPreferences

		name: #haloHandleSize 
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize * 5 // 6 * 2 max: 16];

		name: #halosMorphBoundsFrameColor
		description: 'When set, use this color for a rectangle on halos morph bounds. Useful for debugging morph sizes.' 
		category: #gui 
		type: Object "Using Object as type as the property value can be either nil or a Color."
		value: nil;

		name: #halosMorphBoundsFillColor
		description: 'When set, use this color for filling a rectangle on halos morph bounds. Useful for debugging morph sizes.'
		category: #gui
		type: Object "Using Object as type as the property value can be either nil or a Color."
		value: nil;

		name: #roundedButtonRadius 	
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize * 8 // 14];

		name: #roundedWindowRadius 	
		category: #gui 
		value: [(Preferences at: #standardListFont) pointSize] ;

		name: #scrollbarThickness 
		category: #gui 		
		value: [(Preferences at: #windowTitleFont) pointSize + 2];

		name: #backgroundEffect
		description: 'determines how backgroundImage is applied'
		category: #gui
		type: Symbol
		value: #stretch;

		name: #classFinder 
		category: #programming 
		value: [ Smalltalk findAndBrowseClass ];

		name: #defaultAuthorName 
		category: #programming 
		value: [Utilities authorName];

		name: #worldMenu
		category: #system
		value: TheWorldMenu;

		name: #browserWindowClass
		category: #programming
		value: BrowserWindow.

	Preferences
		name: #haltThrowsUnhandledError
		description: 'If set, the Halt exception will be catched by an UnhandledError exception handler.'
		category: #system type: Boolean value: false.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	Preferences
		name: #haltThrowsUnhandledError
		description: 'If set, the Halt exception will be catched by an UanhandledError exception handler.'
		category: #system type: Boolean value: false.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7169-HaltWhileDebuggingShouldNotOpenAnotherDebugger-JuanVuletich-2025May17-18h33m-jmv.003.cs.st----!

'From Cuis7.3 [latest update: #7167] on 17 May 2025 at 7:31:56 pm'!
!Process methodsFor: 'changing suspended state' stamp: 'jmv 5/17/2025 19:31:23' prior: 50371749!
               stepToHome: aContext 
	"Resume self until the home of top context is aContext.  Top context may be a block context.
	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext
	 if so. Note that this will cause weird effects if using through to step through UnhandledError
	 code, but as the doctor ordered, don't do that; use over or into instead."

	| home |
	home := aContext home.
	[
		suspendedContext := suspendedContext step.
		suspendedContext sender = aContext or:
			[ suspendedContext home == home or:
				[ suspendedContext sender isNil or: [suspendedContext sender isDead]]]
	] whileFalse:
		[
			self ifSuspendedContextIsUnhandledErrorDo:
				[ :anError |
					anError signalerContext ifNotNil:
						[ :unhandledErrorSignalerContext |
							self completeStepUpTo: unhandledErrorSignalerContext.
							"Give a debugger a chance to update its title to reflect the new exception"
							 Notification signalToUpdateDebuggerOn: unhandledErrorSignalerContext dueTo: anError.
							^unhandledErrorSignalerContext ]]].
	^suspendedContext! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7170-Through-mustFinishWhenDone-JuanVuletich-2025May17-19h30m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7170] on 18 May 2025 at 9:59:22 am'!
!Text methodsFor: 'copying' stamp: 'jmv 5/18/2025 09:58:49' prior: 50360215 overrides: 16948944!
             copyReplaceFrom: start to: stop with: replacement
	| rep newRuns newString answer |
	rep := replacement asText.	"might be a string"
	newString := string copyReplaceFrom: start to: stop with: rep string.
	newRuns := runs copyReplaceFrom: start to: stop with: rep runs.
	answer := self class string: newString runs: newRuns.
	self fixParagraphAttributesFrom: start to: start + replacement size - 1.
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected"
	^ answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7171-Text-copyReplace-fix-JuanVuletich-2025May18-09h57m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7171] on 18 May 2025 at 11:19:48 am'!
!SourceCodeInterval methodsFor: 'source code' stamp: 'HAW 5/18/2025 11:19:21' prior: 50371535!
   expandToMatchExpressionOn: aSourceCode
	"takes a source code and if the source range references an expression
	that can be expanded and still is valid, it returns the source range
	'grown'. Examples: (*3 + 4*) to *(3 + 4)*; `*3 + 4*` to *`3 + 4`*"

	| firstCharAndIndex lastCharAndIndex |
	 
	firstCharAndIndex := self skipSeparatorsFrom: start by: -1 in: aSourceCode.
	lastCharAndIndex := self skipSeparatorsFrom: stop by: 1 in: aSourceCode.
	
	^ (self canBeExpandedStartingWith: firstCharAndIndex key endingWith: lastCharAndIndex key)
		ifTrue: [ (self class from: firstCharAndIndex value to: lastCharAndIndex value) expandToMatchExpressionOn: aSourceCode ]
		ifFalse: [ self ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7172-7167Fix-HernanWilkinson-2025May18-11h19m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7170] on 18 May 2025 at 9:59:22 am'!
!Text methodsFor: 'copying' stamp: 'jmv 5/18/2025 09:58:49' prior: 50371951 overrides: 16948944!
                      copyReplaceFrom: start to: stop with: replacement
	| rep newRuns newString answer |
	rep := replacement asText.	"might be a string"
	newString := string copyReplaceFrom: start to: stop with: rep string.
	newRuns := runs copyReplaceFrom: start to: stop with: rep runs.
	answer := self class string: newString runs: newRuns.
	answer fixParagraphAttributesFrom: start to: start + replacement size - 1.
	"Ensure the ParagraphAttributes invariant for the interval that could have been affected"
	^ answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7173-Text-copyReplace-fix-JuanVuletich-2025May18-09h57m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7173] on 19 May 2025 at 10:39:59 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/19/2025 10:39:40' prior: 50367783!
  knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all := Smalltalk allContributors asSet.
ok := (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('and' 						'Alan Dao')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BAP'						'Barry Perryman')
	#('BenComan' 				'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('CAP' 						'Cristián Abel Pérez')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('chaider'					'Christian Haider')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('dkh'						'Dale Henrichs')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSG'						'David Graham')
	#('DSM' 						'Duane Maxwell')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('Ez3' 						'Ezequiel Birman')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 			'Fernando Olivero')
	#('FernanodOlivero' 			'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('fgz'						'Felipe Zak')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 		'Gabriel Omar Cotelli')
	#('GC' 						'Gastón Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 			'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('JCM'						'Juan Cruz Montero')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('JEC'						'Joel Esteban Cámera')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jfr' 						'Jon Raiford')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' 						'John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jpb' 						'Josef Philip Bernhart')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('kdpm' 					'Kevin Pérez Machado')
	#('KenD' 					'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('L C' 						'Lisandro Córdoba')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 			'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 			'Marcus Denker')
	#('marcus.denker' 			'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('MEGL' 					'MarceloLamperti')
	#('mga' 						'Markus Galli')
	#('MGD'						'Matías Dinota')
	#('MH'						'Matías Halperin')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('ml' 						'Matías Lang')
	#('MM'	 					'Mariano Montone')
	#('mnqpr'	 				'Szabolcs Komaromi')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('NMS'						'Nicolás Sarfati')
	#('nop' 						'Jay Carlson')
	#('NPM'						'Nicolás Papagna Maldonado')
	#('NS' 						'Nathanael Schaerli')
	#('ovv' 						'Octavio Valentín Vives')
	#('panda' 					'Michael Rueger')
	#('pau'						'Paula Perez Bianchi')
	#('pb'						'Phil Bellalouna')
	#('PB'						'Paolo Belforte')
	#('PHK' 						'Peter Keeler')
	#('pmon'					'Paolo Montrasi')
	#('PM' 						'Peter Mikkelsen')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('ra' 						'Robert Aurednik')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 	'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RMV' 						'R. Mark Volkmann')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 					'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'				'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'				'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'				'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'				'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSC' 						'Santiago Salvador Cubino')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'					'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 		'Stephane Ducasse')
	#('stephaneducasse'	 		'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 					'Masato Sumi')
	#('S.V.' 						'Sebastián M. Vintoñuke')
	#('svc' 						'Sven Van Caekenberghe')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('TS' 						'Tomás Spognardi')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 					'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('VGF' 						'Gabriel Fierro')
	#('ward' 					'Ward Cunningham')
	#('wbsl'						'Wéslleymberg Lisboa')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7174-AddRobertAsKnownAuthor-JuanVuletich-2025May19-10h39m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7173] on 19 May 2025 at 10:40:45 am'!
!Bitmap methodsFor: 'accessing' stamp: 'ra 5/19/2025 10:40:21' prior: 16792635!
             byteAt: byteAddress bigEndian: isBigEndian
	"Extract a byte from a Bitmap.  Note that this is a byte address and it is one-order.  For repeated use, create an instance of BitBlt and use pixelAt:.  See Form pixelAt:  7/1/96 tk"
	| lowBits shift |
	lowBits := byteAddress - 1 bitAnd: 3.
	shift := isBigEndian 
		ifTrue: [ (lowBits - 3) * 8 ]
		ifFalse: [ (0 - lowBits) * 8 ].
	^((self at: byteAddress - 1 - lowBits // 4 + 1)
		bitShift: shift)
		bitAnd: 16rFF! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7175-Bitmap-byteAtbigEndian-fix-RobertAurednik-2025May19-10h39m-ra.001.cs.st----!

'From Cuis7.3 [latest update: #7175] on 19 May 2025 at 11:09:41 am'!
!BoxMorph commentStamp: '<historical>' prior: 16796184!
           Hierarchy for morphs that are rectangle like, and that occupy an area that can be specified as a Rectangle. This means that, besides being of rectangular shape, sides are aligned with local coordinate axes. Shapes that are not strictly rectangles, but close enough, including rectangles with rounded corners are possible too. The idea is that the 'extent' ivar is all that's needed to establish our dimensions and shape.
Subclasses can add things like 'roundedCornerRadius' or such.
Note: Answers false to #submorphsMightProtrude. If you need a box like morph that can hold submorphs that can protrude it (i.e. submorphs may extend beyond box bounds) DONT subclass from here.!
!ColoredBoxMorph commentStamp: '<historical>' prior: 16832595!
                            ColoredBoxMorph adds a customizable background color to BoxMorph.!
!BorderedBoxMorph commentStamp: '<historical>' prior: 16795844!
                             BorderedBoxMorph adds customizable border, see instanceVariables borderWidth and borderColor.
Subclasses can use a variety of border styles: simple, inset, raised. It also adds padding, a separation between the border and inner contents. Some subclasses may ignore either border or padding.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7176-ColoredBoxMorph-classComment-KenDickey-2025May19-11h06m-KenD.001.cs.st----!

'From Cuis7.3 [latest update: #7122] on 8 May 2025 at 7:24:10 pm'!
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'JEC 5/8/2025 14:54:06' prior: 16924338!
                 label: aStringOrNil font: aFontOrNil
	"Label this button with the given string."
	label := aStringOrNil.
	font := aFontOrNil.
	(self fontToUse notNil and: [ label notNil ])
		ifTrue: [ "Add a bit of padding"
			self morphExtent: (self fontToUse widthOfString: label) + 10 @ (self fontToUse lineSpacing + 10) ]
		ifFalse: [ self redrawNeeded ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7177-PluggableButtonMorph-fix-JEC.001.cs.st----!

'From Cuis7.3 [latest update: #7158] on 15 May 2025 at 12:09:56 pm'!
!Morph methodsFor: 'events' stamp: 'JEC 5/15/2025 10:09:39' prior: 16905406!
         mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse button 2 down event.
	This message will only be sent to Morphs that answer true to #handlesMouseDown:"

	self
		valueOfProperty: #'mouseButton2Down:localPosition:'
		ifPresentDo: [ :handler |
			handler value: aMouseButtonEvent value: localEventPosition.
			^self ].

	self mouseButton2Activity.! !
!Morph methodsFor: 'events' stamp: 'JEC 5/15/2025 10:09:53' prior: 16905415!
                 mouseButton2Up: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse button 2 up event.
	This message will only be sent to Morphs that answer true to #handlesMouseDown:"

	self
		valueOfProperty: #'mouseButton2Up:localPosition:'
		ifPresentDo: [ :handler | handler value: aMouseButtonEvent value: localEventPosition ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7178-MouseButton2Events-JEC.002.cs.st----!

'From Cuis7.3 [latest update: #7178] on 19 May 2025 at 6:25:21 pm'!
!Behavior methodsFor: '[mk] class hierarchy' stamp: 'jmv 5/19/2025 18:21:34'!
                         deepSubclassNamed: aName
	"Or nil"
	self allSubclassesDo: [ :cls | cls name = aName ifTrue: [ ^cls ]].
	^nil.! !
!ProtoObject methodsFor: '[mk] error handling' stamp: 'jmv 5/19/2025 18:24:23' prior: 50371442!
               doesNotUnderstand: aMessage
	"
	Note: Subclasses of ProtoObject will redefine this message.
	This implementation will only be used when the Exception based one at Object is missing.
	This may happen in minimal bootstrapped images.
	"
	| exception context count |

	"Use the MEssageNotUnderstood exception if present"
	exception := Exception deepSubclassNamed: 'MessageNotUnderstood'.
	exception notNil ifTrue:
		[ ^ exception new 
			message: aMessage;
			receiver: self;
			signal ].

	"Or do the best we can in a bare bones system"
	StdIOWriteStream stdout flush.
	StdIOWriteStream stdout newLine;
		nextPutAll: 'Message not understood.'; newLine;
		nextPutAll: 'Receiver: '.
	self printOn: StdIOWriteStream stdout.
	StdIOWriteStream stdout
		nextPutAll: ' selector: #';
		nextPutAll: aMessage selector; newLine;
		nextPutAll: '------ Call Stack: '; newLine;
		flush.

	context := thisContext sender.
	count := 0.
	[context notNil and: [ count < 10 ]] whileTrue: [
		context printOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout newLine.
		context := context sender.
		count := count + 1 ].

	StdIOWriteStream stdout newLine;
		nextPutAll: 'Will exit now.';
		newLine;
		flush.

	Smalltalk quitPrimitive: 127.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7179-ProObject-doesNotUnderstand-raiseExceptionIfPossible-JuanVuletich-2025May19-18h18m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7178] on 19 May 2025 at 5:05:41 pm'!
!MenuMorph methodsFor: 'modal progress dialog' stamp: 'HAW 5/19/2025 17:04:50' prior: 16895812!
                   displayAt: aPoint during: aBlock
	"Add this menu to the Morphic world during the execution of the given block."

	self runningWorld ifNotNil: [ :w |
		w addMorph: self centeredNear: aPoint.
		w displayWorldOn: w mainCanvas.  "show myself"
		].
	aBlock ensure: [ self delete ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7180-AlwaysCloseInformUserDuring-HernanWilkinson-2025May19-17h04m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7180] on 20 May 2025 at 9:06:46 am'!
!EntryFieldMorph methodsFor: 'events' stamp: 'jmv 5/20/2025 09:00:36' prior: 16855495!
                               clickAndHalf: aMouseButtonEvent localPosition: localEventPosition
	self editor clickAndHalf.
	self redrawNeeded.! !
!EntryFieldMorph methodsFor: 'events' stamp: 'jmv 5/20/2025 09:02:17' prior: 50356310 overrides: 16905314!
 keyStroke: aKeyboardEvent
	"Handle a keystroke event."
	super keyStroke: aKeyboardEvent.
	aKeyboardEvent wasHandled ifTrue: [ 
		contents := self editor string.
		self morphExtent: (self morphExtent max: self minimumExtent). "big enough to fit"
		self redrawNeeded.
		^self ].

	self pauseBlinking.

	"Return - check for special action"
	aKeyboardEvent isReturnKey ifTrue: [
		self crAction ifNotNil: [ :action |
			^action value ]].

	"Esc - check for special action"
	aKeyboardEvent isEsc ifTrue: [			
		self escAction ifNotNil: [ :action |
			^action value ]].

	self editor processKeystrokeEvent: aKeyboardEvent.
	contents := self editor string.
	self morphExtent: (self morphExtent max: self minimumExtent). "big enough to fit"
	self redrawNeeded.! !
!EntryFieldMorph methodsFor: 'events' stamp: 'jmv 5/20/2025 09:01:00' prior: 16855520 overrides: 16905376!
 mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	aMouseButtonEvent hand newKeyboardFocus: self.

	self editor mouseDown: aMouseButtonEvent index: (self characterIndexAtPoint: localEventPosition).
	self redrawNeeded.

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!EntryFieldMorph methodsFor: 'events' stamp: 'jmv 5/20/2025 09:01:09' prior: 16855556 overrides: 16905489!
                     mouseMove: aMouseMoveEvent localPosition: localEventPosition

	aMouseMoveEvent mouseButton1Pressed ifFalse: [ ^ self ].
	self editor mouseMove: aMouseMoveEvent index: (self characterIndexAtPoint: localEventPosition).
	self redrawNeeded.! !

EntryFieldMorph removeSelector: #updateFromContents!

!methodRemoval: EntryFieldMorph #updateFromContents stamp: 'Install-7181-EntryFieldMorph-fix-cleanup-JuanVuletich-2025May20-09h05m-jmv.001.cs.st 5/24/2025 10:43:03'!
updateFromContents

	contents := self editor string.
	self redrawNeeded!

EntryFieldMorph removeSelector: #handleInteraction:!

!methodRemoval: EntryFieldMorph #handleInteraction: stamp: 'Install-7181-EntryFieldMorph-fix-cleanup-JuanVuletich-2025May20-09h05m-jmv.001.cs.st 5/24/2025 10:43:03'!
handleInteraction: interactionBlock
	"Perform the changes in interactionBlock, noting any change in selection
	and possibly a change in the size of the composition"

	"Also couple the editor to Morphic keyboard events"

	| oldEditor oldContents |
	oldEditor := editor.
	oldContents := contents.
	interactionBlock value.
	oldContents == contents 
		ifTrue: [ 						"this will not work if the composition changed"
			editor := oldEditor					"since it may have been changed while in block"].
	self redrawNeeded!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7181-EntryFieldMorph-fix-cleanup-JuanVuletich-2025May20-09h05m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7181] on 20 May 2025 at 9:50:50 am'!
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 5/20/2025 09:50:22' prior: 16911839 overrides: 16910368!
                      sendEventTo: aMorph
	"Dispatch the receiver into aMorph.
	See #asMouseEnter, #asMouseLeave, #asMouseMove, #asMouseOver."

	type == #mouseOver ifTrue: [
		^aMorph processMouseOver: self localPosition: (aMorph internalizeFromWorld: position) ].
	type == #mouseEnter ifTrue: [
		^ aMorph processMouseEnter: self localPosition: (aMorph internalizeFromWorld: position) ].
	type == #mouseLeave ifTrue: [
		^aMorph processMouseLeave: self localPosition: (aMorph internalizeFromWorld: position) ].

	"Backstop. Just in case."
	^ super sendEventTo: aMorph! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 5/20/2025 09:49:47' prior: 16911420 overrides: 50372612!
         sendEventTo: aMorph
	"Dispatch the receiver into anObject"

	type == #mouseDown ifTrue: [
		^ aMorph processMouseDown: self localPosition: (aMorph internalizeFromWorld: position) ].
	type == #mouseUp ifTrue: [
		^ aMorph processMouseUp: self localPosition: (aMorph internalizeFromWorld: position) ].

	"Because any MouseEvent can be of the kinds handled by super."
	^super sendEventTo: aMorph! !
!MouseMoveEvent methodsFor: 'dispatching' stamp: 'jmv 5/20/2025 09:49:32' prior: 16911941 overrides: 50372612!
     sendEventTo: aMorph
	"Dispatch the receiver into anObject"

	type == #mouseMove ifTrue: [
		^ aMorph processMouseMove: self localPosition: (aMorph internalizeFromWorld: position) ].

	"Because any MouseEvent can be of the kinds handled by super."
	^ super sendEventTo: aMorph! !
!MouseScrollEvent methodsFor: 'dispatching' stamp: 'jmv 5/20/2025 09:49:24' prior: 16912159 overrides: 50372612!
                        sendEventTo: aMorph
	"Dispatch the receiver into anObject"

	type == #mouseScroll ifTrue: [
		^ aMorph processMouseScroll: self localPosition: (aMorph internalizeFromWorld: position) ].

	"Because any MouseEvent can be of the kinds handled by super."
	^ super sendEventTo: aMorph! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7182-MouseScrollEvent-canAlsoBeMouseEnterOrMouseLeave-JuanVuletich-2025May20-09h48m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7182] on 20 May 2025 at 4:35:02 pm'!
!Process methodsFor: 'changing suspended state' stamp: 'jmv 5/20/2025 13:22:52' prior: 50371906!
stepToHome: requestedContext
	"Resume self until the home of top context is aContext.  Top context may be a block context.
	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext
	 if so. Note that this will cause weird effects if using through to step through UnhandledError
	 code, but as the doctor ordered, don't do that; use over or into instead."

	| requestedHome |
	requestedHome := requestedContext home.
	[
		suspendedContext := suspendedContext step.
	
		"We reached the home context of the block we are doing [Through] on."
		suspendedContext home == requestedHome ifTrue:
			[ ^suspendedContext ].
	
		"But if the requestedHome is dead, meaning that we'll never reach back there,
		stop when we get back to where [Through] was requested."
		requestedHome isDead ifTrue: [
			suspendedContext = requestedContext ifTrue: [
				^suspendedContext ]].
	
		"There's nowhere to continue stepping into. Don't do it."
		(suspendedContext sender isNil or: [suspendedContext sender isDead]) ifTrue: [
			^suspendedContext ].
	
		self ifSuspendedContextIsUnhandledErrorDo: [ :anError |
			anError signalerContext ifNotNil: [ :unhandledErrorSignalerContext |
				self completeStepUpTo: unhandledErrorSignalerContext.
				"Give a debugger a chance to update its title to reflect the new exception"
				 Notification signalToUpdateDebuggerOn: unhandledErrorSignalerContext dueTo: anError.
				^unhandledErrorSignalerContext ]]
	
	] repeat.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7183-Debugger-Through-Fix-JuanVuletich-2025May20-16h34m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7182] on 20 May 2025 at 4:35:46 pm'!
!Debugger class methodsFor: 'constants' stamp: 'jmv 5/20/2025 14:24:05'!
  debuggingTerminatedProcessName
	^'debugging terminated'! !
!Debugger methodsFor: 'context stack menu' stamp: 'jmv 5/20/2025 13:16:27' prior: 16843435!
         doStep
	"Send the selected message in the accessed method, and regain control 
	after the invoked method returns.
	Button [Over] in the Debugger."
	
	| currentContext newContext |

	interruptedProcess isTerminated ifTrue: [^self inform: 'Debugging terminated'].

	currentContext := self selectedContext.
	newContext := self handleLabelUpdatesIn: [interruptedProcess completeStep: currentContext]
						whenExecuting: currentContext.
	newContext == currentContext ifTrue:
		[newContext := interruptedProcess stepToSendOrReturn].
	self contextStackIndex > 1
		ifTrue: [self resetContext: newContext]
		ifFalse:
			[newContext == currentContext
				ifTrue: [self changed: #contentsSelection.
						self updateInspectors]
				ifFalse: [self resetContext: newContext]].! !
!Debugger methodsFor: 'context stack menu' stamp: 'jmv 5/20/2025 13:16:35' prior: 16843578!
    send
	"Send the selected message in the accessed method, and take control in 
	the method invoked to allow further step or send.
	Button [Into] in the Debugger."

	interruptedProcess isTerminated ifTrue: [^self inform: 'Debugging terminated'].

	self checkContextSelection.
	interruptedProcess step: self selectedContext.
	self resetContext: interruptedProcess stepToSendOrReturn.
! !
!Debugger methodsFor: 'context stack menu' stamp: 'jmv 5/20/2025 14:24:21' prior: 50368290!
   stepIntoBlock
	"Send messages until you return to the present method context.
	 Used to step into a block in the method.
	Button [Through] in the Debugger."

	interruptedProcess isTerminated ifTrue: [^self inform: 'Debugging terminated'].
	"It is actually suspended, not terminated!!"
	interruptedProcess name = Debugger debuggingTerminatedProcessName ifTrue: [
		^self inform: 'Debugging terminated'].

	self selectedContext method isQuick ifTrue: [ ^self doStep ].

	self 
		handleLabelUpdatesIn: [
			interruptedProcess stepToHome: self selectedContext ]
		whenExecuting: self selectedContext.
	self resetContext: interruptedProcess stepToSendOrReturn.! !
!BlockClosure methodsFor: 'scheduling' stamp: 'jmv 5/20/2025 14:24:28' prior: 16793592!
                     newProcessForDebugging
	"Answer a Process running the code in the receiver. The process is not 
	scheduled."
	<primitive: 19> "Simulation guard"
	| p |
	p := Process
		forContext: [
			self value.
			p name: Debugger debuggingTerminatedProcessName.
			p terminate] asContext
		priority: Processor activePriority.
	^p! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7184-Debugger-DontDebugPastProcessTermination-JuanVuletich-2025May20-16h35m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7182] on 20 May 2025 at 4:37:35 pm'!
!Process methodsFor: 'changing suspended state' stamp: 'jmv 5/20/2025 16:23:09' prior: 50372682!
   stepToHome: requestedContext
	"Resume self until the home of top context is aContext.  Top context may be a block context.
	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext
	 if so. Note that this will cause weird effects if using through to step through UnhandledError
	 code, but as the doctor ordered, don't do that; use over or into instead."

	| requestedHome |

	requestedHome := requestedContext home.
	[
		(suspendedContext selector == #halt or: [suspendedContext selector == #halt:]) ifTrue: [
			self completeStepUpTo: requestedContext.
			^suspendedContext ].
		
		suspendedContext := suspendedContext step.
	
		"We reached the home context of the block we are doing [Through] on."
		suspendedContext home == requestedHome ifTrue: [
			^suspendedContext ].
	
		"But if the requestedHome is dead, meaning that we'll never reach back there,
		stop when we get back to where [Through] was requested."
		requestedHome isDead ifTrue: [
			suspendedContext = requestedContext ifTrue: [
				^suspendedContext ]].
	
		"There's nowhere to continue stepping into. Don't do it."
		(suspendedContext sender isNil or: [suspendedContext sender isDead]) ifTrue: [
			^suspendedContext ].
	
		self ifSuspendedContextIsUnhandledErrorDo: [ :anError |
			anError signalerContext ifNotNil: [ :unhandledErrorSignalerContext |
				self completeStepUpTo: unhandledErrorSignalerContext.
				"Give a debugger a chance to update its title to reflect the new exception"
				 Notification signalToUpdateDebuggerOn: unhandledErrorSignalerContext dueTo: anError.
				^unhandledErrorSignalerContext ]]
	
	] repeat.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7185-Debugger-Through-over-Halt-JuanVuletich-2025May20-16h35m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7185] on 21 May 2025 at 1:07:50 pm'!
!Debugger methodsFor: 'context stack menu' stamp: 'jmv 5/21/2025 13:03:53' prior: 50372785!
      stepIntoBlock
	"Send messages until you return to the present method context.
	 Used to step into a block in the method.
	Button [Through] in the Debugger."

	interruptedProcess isTerminated ifTrue: [^self inform: 'Debugging terminated'].
	"It is actually suspended, not terminated!!"
	interruptedProcess name = Debugger debuggingTerminatedProcessName ifTrue: [
		^self inform: 'Debugging terminated'].

	self selectedContext method isQuick ifTrue: [ ^self doStep ].

	(self selectedContext = interruptedProcess suspendedContext and: [
		self selectedContext selector == #halt or: [self selectedContext selector == #halt:]]) ifTrue: [
			^self doStep ].

	(self selectedContext = interruptedProcess suspendedContext and: [
			interruptedProcess suspendedContext atEnd and: [interruptedProcess suspendedContext closure isNil]])
		ifTrue: [
			^self doStep ].

	self 
		handleLabelUpdatesIn: [
			interruptedProcess stepToHome: self selectedContext ]
		whenExecuting: self selectedContext.
	self resetContext: interruptedProcess stepToSendOrReturn.! !
!Process methodsFor: 'changing suspended state' stamp: 'jmv 5/21/2025 12:59:36' prior: 50372830!
     stepToHome: requestedContext
	"Resume self until the home of top context is aContext.  Top context may be a block context.
	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext
	 if so. Note that this will cause weird effects if using through to step through UnhandledError
	 code, but as the doctor ordered, don't do that; use over or into instead."

	| requestedHome |

	requestedHome := requestedContext home.
	[
		(Preferences at: #haltThrowsUnhandledError) ifFalse: [
			(suspendedContext selector == #halt or: [suspendedContext selector == #halt:]) ifTrue: [
				self completeStepUpTo: requestedContext.
				^suspendedContext ]].
		
		suspendedContext := suspendedContext step.
	
		"We reached the home context of the block we are doing [Through] on."
		suspendedContext home == requestedHome ifTrue: [
			^suspendedContext ].
	
		"But if the requestedHome is dead, meaning that we'll never reach back there,
		stop when we get back to where [Through] was requested."
		requestedHome isDead ifTrue: [
			suspendedContext = requestedContext ifTrue: [
				^suspendedContext ]].
	
		"There's nowhere to continue stepping into. Don't do it."
		(suspendedContext sender isNil or: [suspendedContext sender isDead]) ifTrue: [
			^suspendedContext ].
	
		self ifSuspendedContextIsUnhandledErrorDo: [ :anError |
			anError signalerContext ifNotNil: [ :unhandledErrorSignalerContext |
				self completeStepUpTo: unhandledErrorSignalerContext.
				"Give a debugger a chance to update its title to reflect the new exception"
				 Notification signalToUpdateDebuggerOn: unhandledErrorSignalerContext dueTo: anError.
				^unhandledErrorSignalerContext ]]
	
	] repeat.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7186-ThroughStopsOnHaltIfUnhandledError-JuanVuletich-2025May21-12h56m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7182] on 20 May 2025 at 5:42:29 pm'!
!CodeWindow methodsFor: 'menu commands' stamp: 'HAW 5/20/2025 17:40:50' prior: 16827094!
    browseVersions
	"Create and schedule a Versions Browser, showing all versions of the 
	currently selected message. Answer the browser or nil."
	| method class |
	model selectedMessageName isNil ifTrue: [
		^ VersionsBrowserWindow
			browseCommentOf: model selectedClass ].
	method := model currentCompiledMethod.
	"because maybe the method has been removed --- unhelpful"
	method isNil ifTrue: [^self].
	class := method methodClass.
	^ VersionsBrowserWindow 
		browseVersionsOf: method
		class: class theNonMetaClass 
		meta: class isMeta
		category: (class organization categoryOfElement: method selector)
		selector: method selector! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7187-BrowseVersionOfClassMethodsFix-HernanWilkinson-2025May20-17h34m-HAW.001.cs.st----!

'From Cuis7.3 [latest update: #7187] on 21 May 2025 at 3:05:06 pm'!

Exception subclass: #UnhandledHalt
	instanceVariableNames: 'exception'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions-Kernel'!

!classDefinition: #UnhandledHalt category: #'Exceptions-Kernel' stamp: 'Install-7188-UnhandledHalt-JuanVuletich-2025May21-14h45m-jmv.001.cs.st 5/24/2025 10:43:03'!
Exception subclass: #UnhandledHalt
	instanceVariableNames: 'exception'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions-Kernel'!
!UnhandledHalt commentStamp: '<historical>' prior: 0!
       UnhandledHalt is an alternative for UnhandledError for Halts.

The idea is that even if UnhandledError is handled and masked, you still may want to get Halts.!
!UnhandledHalt methodsFor: 'priv handling' stamp: 'jmv 5/21/2025 14:55:52' overrides: 16856644!
defaultAction
	"The current computation is terminated. The cause of the error should be logged or reported to the user. If the program is operating in an interactive debugging environment the computation should be suspended and the debugger activated."

	Smalltalk isDevelopmentEnvironmentPresent
		ifTrue: [ self devDefaultAction ]
		ifFalse: [ self standaloneAppDefaultAction ]! !
!UnhandledHalt methodsFor: 'priv handling' stamp: 'jmv 5/21/2025 14:55:52'!
                     devDefaultAction

	Processor activeProcess
		debugContext: exception signalerContext
		title: exception description.! !
!UnhandledHalt methodsFor: 'priv handling' stamp: 'jmv 5/21/2025 14:55:52' overrides: 16856870!
        isResumable
	
	^ false! !
!UnhandledHalt methodsFor: 'priv handling' stamp: 'jmv 5/21/2025 14:55:52'!
                          standaloneAppDefaultAction
	"Dump the stack trace to a log file, then exit the program (image)."
	
	Smalltalk logError: self description inContext: self signalerContext to: 'CuisDebug'.
	Smalltalk quitPrimitive: 1! !
!UnhandledHalt methodsFor: 'accessing' stamp: 'jmv 5/21/2025 14:55:52'!
                               exception

	^ exception! !
!UnhandledHalt methodsFor: 'accessing' stamp: 'jmv 5/21/2025 14:55:52'!
                             exception: anError

	exception := anError! !
!UnhandledHalt class methodsFor: 'as yet unclassified' stamp: 'jmv 5/21/2025 14:55:52'!
                           signalForException: anError

	^ self new
		exception: anError;
		signal! !
!Halt methodsFor: 'description' stamp: 'jmv 5/21/2025 14:59:01' prior: 50371642 overrides: 16856664!
                noHandler
	"If this preference is set, Halt behaves like any other Exception:
		- following any appropriate exception handler
		- throwing the UnhandledError exception if no handler
	This means that Halt can be masked (hidden) by a handler of UnhandledError.
	This is the traditional behavior, but can be a pain if such handler is present."
	(Preferences at: #haltThrowsUnhandledError) ifTrue: [
		super noHandler.
		^self ].

	"Usually Halt should not be caught by an UnhandledError handler, meaning that a Debugger will open
	even in the presence of a handler of UnhandledError that hides most exceptions."
	UnhandledHalt signalForException: self! !
!ContextPart methodsFor: 'controlling' stamp: 'jmv 5/21/2025 15:01:00' prior: 50371666!
                            runUntilErrorOrReturnFrom: aSenderContext
	"ASSUMES aSenderContext is a sender of self.  Execute self's stack until aSenderContext returns or an unhandled exception is raised.  Return a pair containing the new top context and a possibly nil exception.  The exception is not nil if it was raised before aSenderContext returned and it was not handled.  The exception is returned rather than openning the debugger, giving the caller the choice of how to handle it."
	"Self is run by jumping directly to it (the active process abandons thisContext and executes self).  However, before jumping to self we insert an ensure block under aSenderContext that jumps back to thisContext when evaluated.  We also insert an exception handler under aSenderContext that jumps back to thisContext when an unhandled exception is raised.  In either case, the inserted ensure and exception handler are removed once control jumps back to thisContext."

	| error exceptionHandlerContext ensureContext ctxt here topContext |
	aSenderContext method isQuick ifTrue: [ 
		^ {aSenderContext step. nil}
	].
	
	here := thisContext.

	"Insert ensure and exception handler contexts under aSenderContext.
	As Halt may not raise an UnhandledError (see #noHandler), it may need to be handled explicitly here."
	error := nil.
	exceptionHandlerContext := ContextPart
		contextOn: UnhandledError, UnhandledHalt do: [ :unhandledError |
			error ifNil: [
				error := unhandledError exception.
				topContext := thisContext.
				Debugger updateDebuggersLeadingTo: aSenderContext for: error.
				unhandledError resumeUnchecked: here jump ]
			ifNotNil: [unhandledError pass ]].
	ctxt := aSenderContext insertSender: exceptionHandlerContext.
	ensureContext := ContextPart
		contextEnsure: [
			error ifNil: [
				topContext := thisContext.
				here jump ]].
	ctxt := ctxt insertSender: ensureContext.
	self jump.  "Control jumps to self"

	"Control resumes here once above ensure block or exception handler is executed"
	^ error ifNil: [
		"No error was raised, remove ensure context by stepping until popped"
		[ctxt isDead or: [topContext isNil]] whileFalse: [topContext := topContext stepToCalleeOrNil].
		{topContext. nil}

	] ifNotNil: [
		"Error was raised, remove inserted above contexts then return signaler context"
		aSenderContext terminateTo: ctxt sender.  "remove above ensure and handler contexts"
		{topContext. error}
	].! !
!Process methodsFor: 'changing suspended state' stamp: 'jmv 5/21/2025 15:03:48' prior: 16930856!
                               isSuspendedContextSignalUnhandledError

	^ suspendedContext selector == #signalForException:
		and: [suspendedContext receiver isBehavior 
		and: [
			(suspendedContext receiver includesBehavior: UnhandledError) or: [
				suspendedContext receiver includesBehavior: UnhandledHalt ]]]! !

UnhandledHalt class removeSelector: #defaultActionForException:!

UnhandledError class removeSelector: #defaultActionForException:!

!methodRemoval: UnhandledError class #defaultActionForException: stamp: 'Install-7188-UnhandledHalt-JuanVuletich-2025May21-14h45m-jmv.001.cs.st 5/24/2025 10:43:03'!
defaultActionForException: anError

	^ self new
		exception: anError;
		defaultAction!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7188-UnhandledHalt-JuanVuletich-2025May21-14h45m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7188] on 21 May 2025 at 3:28:51 pm'!
!Debugger methodsFor: 'context stack menu' stamp: 'jmv 5/21/2025 15:26:26' prior: 50372892!
  stepIntoBlock
	"Send messages until you return to the present method context.
	 Used to step into a block in the method.
	Button [Through] in the Debugger."

	interruptedProcess isTerminated ifTrue: [^self inform: 'Debugging terminated'].
	"It is actually suspended, not terminated!!"
	interruptedProcess name = Debugger debuggingTerminatedProcessName ifTrue: [
		^self inform: 'Debugging terminated'].

	self selectedContext method isQuick ifTrue: [ ^self doStep ].

	(self selectedContext = interruptedProcess suspendedContext and: [
			interruptedProcess suspendedContext willReturn and: [
				interruptedProcess suspendedContext closure isNil]])
		ifTrue: [
			^self doStep ].

	self 
		handleLabelUpdatesIn: [
			interruptedProcess stepToHome: self selectedContext ]
		whenExecuting: self selectedContext.
	self resetContext: interruptedProcess stepToSendOrReturn.! !
!Process methodsFor: 'changing suspended state' stamp: 'jmv 5/20/2025 13:22:52' prior: 50372928!
                      stepToHome: requestedContext
	"Resume self until the home of top context is aContext.  Top context may be a block context.
	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext
	 if so. Note that this will cause weird effects if using through to step through UnhandledError
	 code, but as the doctor ordered, don't do that; use over or into instead."

	| requestedHome |
	requestedHome := requestedContext home.
	[
		suspendedContext := suspendedContext step.
	
		"We reached the home context of the block we are doing [Through] on."
		suspendedContext home == requestedHome ifTrue: [
			^suspendedContext ].
	
		"But if the requestedHome is dead, meaning that we'll never reach back there,
		stop when we get back to where [Through] was requested."
		requestedHome isDead ifTrue: [
			suspendedContext = requestedContext ifTrue: [
				^suspendedContext ]].
	
		"There's nowhere to continue stepping into. Don't do it."
		(suspendedContext sender isNil or: [suspendedContext sender isDead]) ifTrue: [
			^suspendedContext ].
	
		self ifSuspendedContextIsUnhandledErrorDo: [ :anError |
			anError signalerContext ifNotNil: [ :unhandledErrorSignalerContext |
				self completeStepUpTo: unhandledErrorSignalerContext.
				"Give a debugger a chance to update its title to reflect the new exception"
				 Notification signalToUpdateDebuggerOn: unhandledErrorSignalerContext dueTo: anError.
				^unhandledErrorSignalerContext ]]
	
	] repeat.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7189-Through-tweaks-JuanVuletich-2025May21-15h27m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7081] on 18 March 2025 at 5:04:24 pm'!

VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId currentClipsSubmorphs clipCurrentMorph '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineDrawer category: #'Morphic-Support' stamp: 'Install-7190-Disable-bitMask-style-submorphClipping-JuanVuletich-2025Mar18-16h56m-jmv.001.cs.st 5/24/2025 10:43:03'!
VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId currentClipsSubmorphs clipCurrentMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!
!Morph methodsFor: 'change reporting' stamp: 'jmv 3/11/2025 16:09:44' prior: 16904839!
     invalidateDisplayRect: damageRect for: aMorph
	"
	If we clip submorphs, then we clip damageRect.
	
	aMorph is the morph that changed and therefore should be redrawn. In some cases, damage reporting is done by no longer occupying some area, and requesting whatever appropriate morph to be drawn there. In such cases, aMorph should be nil. See senders."

	| clippedRect b |
	self visible ifFalse: [ ^self].

	clippedRect := damageRect.
	aMorph == self ifFalse: [
		self clipsSubmorphs ifTrue: [
			b := self displayBounds.
			b ifNil: [ ^self ].
			clippedRect := damageRect intersect: b ]].
	owner ifNotNil: [
		owner invalidateDisplayRect: clippedRect for: aMorph ].! !
!Morph methodsFor: 'geometry' stamp: 'jmv 3/11/2025 16:09:41' prior: 16906198!
                   displayFullBounds
	"Answer a rectangle that completely bounds receiver and submorphs when last drawn 
		(if the world was to be fully drawn, i.e. only to be used on a Canvas on the full world).
	Integer pixel coordinates!!"

	| answer |
	answer := self basicDisplayBounds.
	(self submorphsMightProtrude and: [self clipsSubmorphs not]) ifTrue: [
		self submorphsDo: [ :m |
			answer := answer
				ifNil: [m displayFullBounds]
				ifNotNil: [answer quickMerge: m displayFullBounds]]].
	^answer! !
!Morph methodsFor: 'updating' stamp: 'jmv 3/11/2025 16:09:48' prior: 16908576!
  redrawNeeded
	"Report that the area occupied by this morph should be redrawn.
	Usually because we changed in some way.
	Notes:
		Area used before any change is reported here.
		Area used after any changes is reported when displayBounds are updated.
			See updateBoundsIn:addDamageTo: and senders.
	"

	self needsRedraw: true.
	self allOwnersDo: [ :m | m submorphNeedsRedraw: true ].
	self basicDisplayBounds ifNotNil: [ :b |
		self invalidateDisplayRect: b for: self ].
	(self submorphsMightProtrude and: [self clipsSubmorphs not]) ifTrue: [
		self submorphsReverseDo: [ :m | m redrawNeeded ]].
	self haloRedrawMayBeNeeded.
	self removeProperty: #bitMask.
	self removeProperty: #fullBoundsInOwner.! !
!MorphicCanvas methodsFor: 'private' stamp: 'jmv 3/11/2025 16:09:53' prior: 16909793!
             clippingByCurrentMorphDo: aBlock
	"Do clipping only if currentMorph says so"

	| prevClipRect prevClippingMorphRect |

	currentMorph clipsSubmorphs ifFalse: [ ^aBlock value ].

	prevClipRect := clipRect.
	prevClippingMorphRect := clippingMorphDisplayBounds.
	clippingMorphDisplayBounds := self boundingRectOfCurrentMorphAfterDraw insetBy: 1.
	self setClipRect: (prevClipRect
		ifNil: [clippingMorphDisplayBounds]
		ifNotNil: [prevClipRect intersect: clippingMorphDisplayBounds]).
	self clipCurrentMorph: true.
	aBlock ensure: [
		self clipCurrentMorph: false.
		self setClipRect: prevClipRect.
		clippingMorphDisplayBounds := prevClippingMorphRect ]! !
!BoundsFinderCanvas methodsFor: 'morphic' stamp: 'jmv 3/11/2025 16:09:57' prior: 16796059!
                        fullUpdateCurrentProtrudingBounds
	"Recursively update display bounds, for currentMorph and all submorphs,
	but only for those whose bounds may go outside owner bounds."

	currentMorph knowsOwnLocalBounds
		ifTrue: [self displayBoundsSetOnCurrentMorph]
		ifFalse: [
			currentMorph isKnownFailing
				ifTrue: [
					self drawCurrentAsError ]
				ifFalse: [
					"In these cases, #drawOn: is required to find bounds.
					#displayBoundsSetFrom: will use the bounds found by us in these case.
					See #displayBoundsSetFrom:"
					currentMorph drawOn: self.
					self displayBoundsSetOnCurrentMorph.
					(currentMorph postDrawOn: self) ifTrue: [
						self displayBoundsUpdateOnCurrentMorph ].
					(currentMorph submorphsMightProtrude and: [currentMorph clipsSubmorphs not]) ifTrue: [
						currentMorph submorphsDo: [ :m |
							self fullUpdateProtrudingBounds: m ]]]].! !
!VectorEngineDrawer methodsFor: 'accessing' stamp: 'jmv 3/10/2025 10:24:22' prior: 17001599!
                        currentMorph: aMorph
	aMorph
		ifNil: [
			currentMorphId := 0 ]
		ifNotNil: [
			currentMorphId := aMorph morphId ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/18/2025 16:51:04' prior: 50365730!
                        blendFillOnlyAt: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside antiAliasAlphasWord: antiAliasAlphasWord
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB alphaRBits alphaGBits alphaBBits alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB resultAlpha targetAlpha |

	"In this method, antiAliasAlphas are not used to blend stroke, but fill.
	This means that in the inside of the shape, and away from the stroke, they must be 1.0 (not 0.0).
	Next lines try to be in a simd friendly style."
	alphaRBits := antiAliasAlphasWord at: 3.
	alphaGBits := antiAliasAlphasWord at: 2.
	alphaBBits := antiAliasAlphasWord at: 1.
	isRedInside ifTrue: [ alphaRBits := 127 - alphaRBits ].
	isGreenInside ifTrue: [ alphaGBits := 127 - alphaGBits ].
	isBlueInside ifTrue: [ alphaBBits := 127 - alphaBBits ].
	alphaR := alphaRBits / 127.0.
	alphaG := alphaGBits / 127.0.
	alphaB := alphaBBits / 127.0.
	alphaR := alphaR * fillColor alpha.
	alphaG := alphaG * fillColor alpha.
	alphaB := alphaB * fillColor alpha.

	alphaR + alphaG + alphaB = 0.0 ifFalse: [
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.

		"These if are not really needed. just ignore them if we use simd instructions."
		alphaR = 0.0 ifFalse: [
			unAlphaR := 1.0 - alphaR.
			resultAlpha := alphaR + (unAlphaR * targetAlpha).
			resultR := alphaR * fillColor red * 255 + (unAlphaR * (targetWord at: 3) * targetAlpha).
			resultR := resultR/resultAlpha.
			targetWord at: 3 put: resultR rounded ].

		alphaG = 0.0 ifFalse: [
			unAlphaG := 1.0 - alphaG.
			resultAlpha := alphaG + (unAlphaG * targetAlpha).
			resultG := alphaG * fillColor green * 255 + (unAlphaG * (targetWord at: 2) * targetAlpha).
			resultG := resultG/resultAlpha.
			targetWord at: 2 put: resultG rounded.
			targetWord at: 4 put: (resultAlpha*255) rounded ].

		alphaB = 0.0 ifFalse: [
			unAlphaB := 1.0 - alphaB.
			resultAlpha := alphaB + (unAlphaB * targetAlpha).
			resultB := alphaB * fillColor blue * 255 + (unAlphaB * (targetWord at: 1) * targetAlpha).
			resultB := resultB/resultAlpha.
			targetWord at: 1 put: resultB rounded ].

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId<<8 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/18/2025 16:52:06' prior: 50365912!
                               blendStrokeAndFillAt: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside antiAliasAlphasWord: strokeAntiAliasAlphasWord
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB strokeAARedAlphaBits strokeAARedAlpha strokeAAGreenAlphaBits strokeAAGreenAlpha strokeAABlueAlphaBits strokeAABlueAlpha alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB foreR foreG foreB targetAlpha resultAlpha |

	"Next lines try to be in a simd friendly style."
	strokeAARedAlphaBits := strokeAntiAliasAlphasWord at: 3.
	strokeAAGreenAlphaBits := strokeAntiAliasAlphasWord at: 2.
	strokeAABlueAlphaBits := strokeAntiAliasAlphasWord at: 1.
	strokeAARedAlpha := strokeAARedAlphaBits / 127.0.
	strokeAAGreenAlpha := strokeAAGreenAlphaBits / 127.0.
	strokeAABlueAlpha := strokeAABlueAlphaBits / 127.0.

	isRedInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaR := strokeAARedAlpha * strokeColor alpha + ((1.0-strokeAARedAlpha) * fillColor alpha).
			foreR := strokeAARedAlpha * strokeColor red * 255 + ((1.0-strokeAARedAlpha) * fillColor red * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaR := strokeAARedAlpha * strokeColor alpha.
			foreR := strokeColor red * 255 ].

	isGreenInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaG := strokeAAGreenAlpha * strokeColor alpha + ((1.0-strokeAAGreenAlpha) * fillColor alpha).
			foreG := strokeAAGreenAlpha * strokeColor green * 255 + ((1.0-strokeAAGreenAlpha) * fillColor green * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaG := strokeAAGreenAlpha * strokeColor alpha.
			foreG := strokeColor green * 255 ].

	isBlueInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaB := strokeAABlueAlpha * strokeColor alpha + ((1.0-strokeAABlueAlpha) * fillColor alpha).
			foreB := strokeAABlueAlpha * strokeColor blue * 255 + ((1.0-strokeAABlueAlpha) * fillColor blue * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaB := strokeAABlueAlpha * strokeColor alpha.
			foreB := strokeColor blue * 255 ].

	alphaR + alphaG + alphaB = 0.0 ifFalse: [
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.

		"These if are not really needed. just ignore them if we use simd instructions."
		alphaR = 0.0 ifFalse: [
			unAlphaR := 1.0 - alphaR.
			resultAlpha := alphaR + (unAlphaR * targetAlpha).
			resultR := alphaR * foreR + (unAlphaR * (targetWord at: 3) * targetAlpha).
			resultR := resultR/resultAlpha.
			targetWord at: 3 put: resultR rounded ].
		alphaG = 0.0 ifFalse: [
			unAlphaG := 1.0 - alphaG.
			resultAlpha := alphaG + (unAlphaG * targetAlpha).
			resultG := alphaG * foreG + (unAlphaG * (targetWord at: 2) * targetAlpha).
			resultG := resultG/resultAlpha.
			targetWord at: 2 put: resultG rounded.
			targetWord at: 4 put: (resultAlpha*255) rounded ].
		alphaB = 0.0 ifFalse: [
			unAlphaB := 1.0 - alphaB.
			resultAlpha := alphaB + (unAlphaB * targetAlpha).
			resultB := alphaB * foreB + (unAlphaB * (targetWord at: 1) * targetAlpha).
			resultB := resultB/resultAlpha.
			targetWord at: 1 put: resultB rounded ].

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId<<8 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/18/2025 16:52:26' prior: 50366087!
                            blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord
	"Blends stroke color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB alphaRBits alphaGBits alphaBBits alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB resultAlpha targetAlpha |

	"Next lines try to be in a simd friendly style."
	alphaRBits := strokeAntiAliasAlphasWord at: 3.
	alphaGBits := strokeAntiAliasAlphasWord at: 2.
	alphaBBits := strokeAntiAliasAlphasWord at: 1.
	alphaR := alphaRBits / 127.0.
	alphaG := alphaGBits / 127.0.
	alphaB := alphaBBits / 127.0.
	alphaR := alphaR * strokeColor alpha.
	alphaG := alphaG * strokeColor alpha.
	alphaB := alphaB * strokeColor alpha.

	alphaR + alphaG + alphaB = 0.0 ifFalse: [
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.

		"These if are not really needed. just ignore them if we use simd instructions."
		alphaR = 0.0 ifFalse: [
			unAlphaR := 1.0 - alphaR.
			resultAlpha := alphaR + (unAlphaR * targetAlpha).
			resultR := alphaR * strokeColor red * 255 + (unAlphaR * (targetWord at: 3) * targetAlpha).
			resultR := resultR/resultAlpha.
			targetWord at: 3 put: resultR rounded ].

		alphaG = 0.0 ifFalse: [
			unAlphaG := 1.0 - alphaG.
			resultAlpha := alphaG + (unAlphaG * targetAlpha).
			resultG := alphaG * strokeColor green * 255 + (unAlphaG * (targetWord at: 2) * targetAlpha).
			resultG := resultG/resultAlpha.
			targetWord at: 2 put: resultG rounded.
			targetWord at: 4 put: (resultAlpha*255) rounded ].

		alphaB = 0.0 ifFalse: [
			unAlphaB := 1.0 - alphaB.
			resultAlpha := alphaB + (unAlphaB * targetAlpha).
			resultB := alphaB * strokeColor blue * 255 + (unAlphaB * (targetWord at: 1) * targetAlpha).
			resultB := resultB/resultAlpha.
			targetWord at: 1 put: resultB rounded ].

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId<<8 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/18/2025 16:52:37' prior: 17003668!
blendFillOnlyAt: pixelIndex antiAliasAlphaByte: antiAliasAlphaBits
	"Blends fill color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| resultR resultG resultB antiAliasAlpha alpha unAlpha resultAlpha targetWord targetAlpha |

	antiAliasAlpha := antiAliasAlphaBits / 127.0.
	alpha := antiAliasAlpha * fillColor alpha.

	alpha = 0.0 ifFalse: [
		unAlpha := 1.0 - alpha.
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.
		resultAlpha := alpha + (unAlpha * targetAlpha).
		targetWord at: 4 put: (resultAlpha*255) rounded.
		
		resultR := alpha * fillColor red * 255 + (unAlpha * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded.

		resultG := alpha * fillColor green * 255 + (unAlpha * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.

		resultB := alpha * fillColor blue * 255 + (unAlpha * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded.

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId<<8 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/18/2025 16:52:51' prior: 50366230!
                blendStrokeAndFillAt: pixelIndex isInside: isInside antiAliasAlphaByte: strokeAntiAliasAlphaBits
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB strokeAAAlpha alpha unAlpha foreR foreG foreB targetAlpha resultAlpha |

	strokeAAAlpha := strokeAntiAliasAlphaBits / 127.0.

	isInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha := strokeAAAlpha * strokeColor alpha + ((1-strokeAAAlpha) * fillColor alpha).
			foreR := strokeAAAlpha * strokeColor red * 255 + ((1-strokeAAAlpha) * fillColor red * 255).
			foreG := strokeAAAlpha * strokeColor green * 255 + ((1-strokeAAAlpha) * fillColor green * 255).
			foreB := strokeAAAlpha * strokeColor blue * 255 + ((1-strokeAAAlpha) * fillColor blue * 255) ]
		ifFalse: [							"Blend stroke over background"
			alpha := strokeAAAlpha * strokeColor alpha.
			foreR := strokeColor red * 255.
			foreG := strokeColor green * 255.
			foreB := strokeColor blue * 255 ].

	alpha = 0.0 ifFalse: [
		unAlpha := 1.0 - alpha.
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.
		resultAlpha := alpha + (unAlpha * targetAlpha).
		targetWord at: 4 put: (resultAlpha*255) rounded.

		resultR := alpha * foreR + (unAlpha * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded.

		resultG := alpha * foreG + (unAlpha * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.

		resultB := alpha * foreB + (unAlpha * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded.

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId<<8 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/18/2025 16:53:03' prior: 50366344!
 blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits
	"Blends stroke color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB alpha unAlpha resultAlpha targetAlpha |
	alpha := strokeAntiAliasAlphaBits / 127.0.
	alpha := alpha * strokeColor alpha.

	alpha = 0.0 ifFalse: [
		unAlpha := 1.0 - alpha.
		targetWord := targetForm bits bytesAt: pixelIndex.

		targetAlpha := (targetWord at: 4) / 255.0.
		resultAlpha := alpha + (unAlpha * targetAlpha).
		targetWord at: 4 put: (resultAlpha*255) rounded.

		resultR := alpha * strokeColor red * 255 + (unAlpha * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded.

		resultG := alpha * strokeColor green * 255 + (unAlpha * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.

		resultB := alpha * strokeColor blue * 255 + (unAlpha * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded.

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId<<8 ].! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 3/11/2025 15:48:09' prior: 17004243 overrides: 17000856!
                         initializePath

	super initializePath.

	"Set all plugin state. There might be several instances of this class, all using the same plugin.
	Only one of them will use the plugin during a path draw operation. See class variable PluginAccess."
	self
		primTargetBits: targetForm bits
		morphIds: morphIds
		edgeCounts: edgeCounts
		alphaMask: alphaMask
		contour: contour
		targetWidth: targetWidth
		targetHeight: targetHeight.
	self
		primAntiAliasingWidth: antiAliasingWidth asFloat
		subPixelDelta: self subPixelDelta asFloat
		hopLength: hop asFloat.
	self primClipLeft: clipLeft clipTop: clipTop clipRight: clipRight clipBottom: clipBottom.
	self primCurrentMorphId: currentMorphId currentClipsSubmorphs: false.
	self primClipCurrentMorph: false morphIds: morphIds.
	self
		primGeometryTxA11: geometryTransformation a11 asFloat
		a12: geometryTransformation a12 asFloat
		a13: geometryTransformation a13 asFloat
		a21: geometryTransformation a21 asFloat
		a22: geometryTransformation a22 asFloat
		a23: geometryTransformation a23 asFloat.
	self primStrokeWidth: strokeWidth.
	self primStrokeColor: strokeColor.
	self primFillColor: fillColor.

	self primInitializePath.! !

VectorEngineSmalltalk removeSelector: #clipCurrentMorph:!

!methodRemoval: VectorEngineSmalltalk #clipCurrentMorph: stamp: 'Install-7190-Disable-bitMask-style-submorphClipping-JuanVuletich-2025Mar18-16h56m-jmv.001.cs.st 5/24/2025 10:43:03'!
clipCurrentMorph: aBoolean
	(clipCurrentMorph and: [ aBoolean not ]) ifTrue: [
		| pixelIndex |
		clipTop to: clipBottom do: [ :displayY |
			pixelIndex := displayY * targetWidth + clipLeft.
			clipLeft to: clipRight do: [ :displayX |
				pixelIndex := pixelIndex + 1.
				morphIds at: pixelIndex put: ((morphIds at: pixelIndex) >>8 <<8) ]]].
	clipCurrentMorph := aBoolean.!

VectorEngineDrawer removeSelector: #clipCurrentMorph:!

!methodRemoval: VectorEngineDrawer #clipCurrentMorph: stamp: 'Install-7190-Disable-bitMask-style-submorphClipping-JuanVuletich-2025Mar18-16h56m-jmv.001.cs.st 5/24/2025 10:43:03'!
clipCurrentMorph: aBoolean
	clipCurrentMorph := aBoolean.!

VectorEngine removeSelector: #clipCurrentMorph:!

!methodRemoval: VectorEngine #clipCurrentMorph: stamp: 'Install-7190-Disable-bitMask-style-submorphClipping-JuanVuletich-2025Mar18-16h56m-jmv.001.cs.st 5/24/2025 10:43:03'!
clipCurrentMorph: aBoolean
	"To be redefined as needed"!

VectorCanvas removeSelector: #clipCurrentMorph:!

!methodRemoval: VectorCanvas #clipCurrentMorph: stamp: 'Install-7190-Disable-bitMask-style-submorphClipping-JuanVuletich-2025Mar18-16h56m-jmv.001.cs.st 5/24/2025 10:43:03'!
clipCurrentMorph: aBoolean
	engine clipCurrentMorph: aBoolean!

Morph removeSelector: #clipsSubmorphsReally!

!methodRemoval: Morph #clipsSubmorphsReally stamp: 'Install-7190-Disable-bitMask-style-submorphClipping-JuanVuletich-2025Mar18-16h56m-jmv.001.cs.st 5/24/2025 10:43:03'!
clipsSubmorphsReally
	"Currently only one level of clipping is supported.
	This means that if a morph clipsSubmorphs, then no submorph in its tree can do it.
	This is a current limitation of VectorCanvas"

	self clipsSubmorphs ifFalse: [ ^false ].
	self allOwnersDo: [ :o | o clipsSubmorphs ifTrue: [ ^false ]].
	^true!

VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineDrawer category: #'Morphic-Support' stamp: 'Install-7190-Disable-bitMask-style-submorphClipping-JuanVuletich-2025Mar18-16h56m-jmv.001.cs.st 5/24/2025 10:43:03'!
VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7190-Disable-bitMask-style-submorphClipping-JuanVuletich-2025Mar18-16h56m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7080] on 18 March 2025 at 3:42:12 pm'!
!WorldMorph methodsFor: 'canvas' stamp: 'jmv 3/18/2025 15:39:34'!
      setupNewCanvasAndEngine
	canvas := nil.
	self setupCanvas.
	self whenUIinSafeState: [self whenUIinSafeState: [self restoreDisplay]].! !
!VectorCanvas methodsFor: 'initialization' stamp: 'jmv 3/18/2025 15:40:07' prior: 16999910!
                            setForm: aForm subPixelAntiAliasing: aBoolean
	"nil means use default kind of anti aliasing"
	"
	self runningWorld setupNewCanvasAndEngine
	"
	aForm depth = 32 ifFalse: [ self error: 'VectorCanvas can only work on 32 bit target' ].
	form := aForm.
	engine := VectorEngine onForm: form subPixelAntiAliasing: aBoolean.
	engine canvas: self.
	auxBitBltEngine := BitBltCanvasEngine toForm: form.
	self newClipRect: nil.! !
!VectorCanvas class methodsFor: 'class initialization' stamp: 'jmv 3/18/2025 15:27:23' prior: 17000074 overrides: 16779143!
 initialize
	UISupervisor whenUIinSafeState: [
		(VectorEngineWithPlugin isPluginAvailable
			ifTrue: [
				MorphicCanvas activeSubclass: HybridCanvas
				"MorphicCanvas activeSubclass: VectorCanvas"
				]
			ifFalse: [
				'VectorEnginePlugin (VM plugin) is not available. HybridCanvas will be activated.' print.
				MorphicCanvas activeSubclass: HybridCanvas ]) ].! !
!VectorEngineWithPlugin class methodsFor: 'instance creation' stamp: 'jmv 3/11/2025 15:59:08' prior: 50362654!
isPluginAvailable
	"
	VectorEngineWithPlugin isPluginAvailable
	Check if services provided by VM plugin match this class requirements.
	"
	| pluginApiVersion |
	pluginApiVersion := self pluginApiVersion.
	^ pluginApiVersion = 17! !

VectorCanvas initialize!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
| activeProc guiRoot |
(nil inform: 'After this update, #7191,
we need to restart the User Interface process.
Please do World / Changes... / [Install New Updates].').
[
	ChangeSet installing: '7191-DisableVectorGraphicsPlugin-JuanVuletich-2025Mar18-15h27m-jmv.001.cs.st' do: [].
	cs _ ChangeSet changeSetForBaseSystem.
	(cs name beginsWith: '7191') ifTrue: [
		ChangeSet removeChangeSet: cs ].
	'Installed ChangeSet: 7191-DisableVectorGraphicsPlugin-JuanVuletich-2025Mar18-15h27m-jmv.001.cs.st' print.
	'Please do World / Changes... / [Install New Updates].' print.
	Utilities logsUserChanges: true.
] forkAt: 39.
UISupervisor ui setupNewCanvasAndEngine.
UISupervisor newUIProcess.
Processor activeProcess terminate.
!

'From Cuis7.3 [latest update: #7070] on 11 March 2025 at 3:11:24 pm'!

AbstractVectorCanvas subclass: #VectorCanvas
	instanceVariableNames: 'boundsFinderCanvas auxBitBltEngine attachedCanvas csi clippingSpecStack '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorCanvas category: #'Morphic-Support' stamp: 'Install-7192-VectorCanvas-ClippingSpecStack-JuanVuletich-2025Mar11-15h01m-jmv.001.cs.st 5/24/2025 10:43:11'!
AbstractVectorCanvas subclass: #VectorCanvas
	instanceVariableNames: 'boundsFinderCanvas auxBitBltEngine attachedCanvas csi clippingSpecStack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!
!VectorCanvas methodsFor: 'morphic' stamp: 'jmv 3/7/2025 16:05:02' overrides: 16909539!
              clipCurrentMorph: aBoolean
	| prevClipSpec thisClipSpec |
	aBoolean
		ifTrue: 
		[
			prevClipSpec := clippingSpecStack at: csi.
			csi := csi+1.
			clippingSpecStack size < csi
				ifTrue: [
					thisClipSpec := prevClipSpec copy.
					clippingSpecStack add: thisClipSpec ]
				ifFalse: [
					thisClipSpec := clippingSpecStack at: csi.
					thisClipSpec fillWith: prevClipSpec ].
			engine morphContourAfterDrawInterectInto: thisClipSpec.
		]
		ifFalse: 
		[
			csi := csi-1.
			thisClipSpec := clippingSpecStack at: csi.
		].! !
!VectorCanvas methodsFor: 'initialization' stamp: 'jmv 3/7/2025 10:35:49' prior: 16999888 overrides: 16909516!
                             initializeWithTranslation: aPoint
	| h w initialClipSpec |

	super initializeWithTranslation: aPoint.
	engine geometryTransformation: currentTransformation.

	h := form height.
	w := form width.
	initialClipSpec := IntegerArray new: h * 2.
	0 to: form height-1 do: [ :y |
		initialClipSpec at: y * 2 + 1 put: 0.
		initialClipSpec at: y * 2 + 2 put: w ].
	clippingSpecStack := OrderedCollection with: initialClipSpec.
	csi := 1.

	boundsFinderCanvas := BoundsFinderCanvas new initializeWithTranslation: aPoint.
	"So bounds found are exactly the same as our engine would find."
	boundsFinderCanvas engine antiAliasingWidth: engine antiAliasingWidth.
	boundsFinderCanvas engine subPixelDelta: engine subPixelDelta.
	attachedCanvas ifNotNil: [
		attachedCanvas
			currentMorph: currentMorph drawingMorphStack: drawingMorphStack
			currentTransformation: currentTransformation transformations: transformations
			cti: cti ]! !

AbstractVectorCanvas subclass: #VectorCanvas
	instanceVariableNames: 'clippingSpecStack csi boundsFinderCanvas auxBitBltEngine attachedCanvas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorCanvas category: #'Morphic-Support' stamp: 'Install-7192-VectorCanvas-ClippingSpecStack-JuanVuletich-2025Mar11-15h01m-jmv.001.cs.st 5/24/2025 10:43:12'!
AbstractVectorCanvas subclass: #VectorCanvas
	instanceVariableNames: 'clippingSpecStack csi boundsFinderCanvas auxBitBltEngine attachedCanvas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
| e initialClipSpec |
VectorCanvas allSubInstancesDo: [ :canvas |
	canvas form ifNotNil: [
		e := canvas extent.
		initialClipSpec := IntegerArray new: e y * 2.
		0 to: e y-1 do: [ :y |
			initialClipSpec at: y * 2 + 1 put: 0.
			initialClipSpec at: y * 2 + 2 put: e x ].
		canvas instVarNamed: 'clippingSpecStack' put:​ (OrderedCollection with: initialClipSpec).
		canvas instVarNamed: 'csi' put:​ 1 ]].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7192-VectorCanvas-ClippingSpecStack-JuanVuletich-2025Mar11-15h01m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7076] on 11 March 2025 at 4:45:23 pm'!

VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineDrawer category: #'Morphic-Support' stamp: 'Install-7193-VectorEngine-set-ClippingSpec-JuanVuletich-2025Mar11-16h24m-jmv.001.cs.st 5/24/2025 10:43:12'!
VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 3/11/2025 16:41:53'!
                           clipByCurrentMorphStart! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 3/11/2025 16:42:18'!
                               clipByCurrentMorphStop! !
!BoundsFinderCanvas methodsFor: 'morphic' stamp: 'jmv 3/11/2025 16:41:56' overrides: 50374280!
       clipByCurrentMorphStart! !
!BoundsFinderCanvas methodsFor: 'morphic' stamp: 'jmv 3/11/2025 16:42:22' overrides: 50374284!
      clipByCurrentMorphStop! !
!VectorCanvas methodsFor: 'morphic' stamp: 'jmv 3/11/2025 16:43:24' overrides: 50374280!
             clipByCurrentMorphStart
	| prevClipSpec thisClipSpec |
	prevClipSpec := clippingSpecStack at: csi.
	csi := csi+1.
	clippingSpecStack size < csi
		ifTrue: [
			thisClipSpec := prevClipSpec copy.
			clippingSpecStack add: thisClipSpec ]
		ifFalse: [
			thisClipSpec := clippingSpecStack at: csi.
			thisClipSpec fillWith: prevClipSpec ].
	engine morphContourAfterDrawInterectInto: thisClipSpec.
	engine clippingSpec: thisClipSpec.! !
!VectorCanvas methodsFor: 'morphic' stamp: 'jmv 3/11/2025 16:43:51' overrides: 50374284!
                       clipByCurrentMorphStop
	| prevClipSpec |
	csi := csi-1.
	prevClipSpec := clippingSpecStack at: csi.
	engine clippingSpec: prevClipSpec.! !
!VectorEngineDrawer methodsFor: 'accessing' stamp: 'jmv 3/11/2025 16:34:24'!
        clippingSpec: aClippingSpec
	clippingSpec := aClippingSpec.! !
!MorphicCanvas methodsFor: 'private' stamp: 'jmv 3/11/2025 16:44:13' prior: 50373415!
           clippingByCurrentMorphDo: aBlock
	"Do clipping only if currentMorph says so"

	| prevClipRect prevClippingMorphRect |

	currentMorph clipsSubmorphs ifFalse: [ ^aBlock value ].

	prevClipRect := clipRect.
	prevClippingMorphRect := clippingMorphDisplayBounds.
	clippingMorphDisplayBounds := self boundingRectOfCurrentMorphAfterDraw insetBy: 1.
	self setClipRect: (prevClipRect
		ifNil: [clippingMorphDisplayBounds]
		ifNotNil: [prevClipRect intersect: clippingMorphDisplayBounds]).
	self clipByCurrentMorphStart.
	aBlock ensure: [
		self clipByCurrentMorphStop.
		self setClipRect: prevClipRect.
		clippingMorphDisplayBounds := prevClippingMorphRect ]! !

VectorCanvas removeSelector: #clipCurrentMorph:!

!methodRemoval: VectorCanvas #clipCurrentMorph: stamp: 'Install-7193-VectorEngine-set-ClippingSpec-JuanVuletich-2025Mar11-16h24m-jmv.001.cs.st 5/24/2025 10:43:12'!
clipCurrentMorph: aBoolean
	| prevClipSpec thisClipSpec |
	aBoolean
		ifTrue: 
		[
			prevClipSpec := clippingSpecStack at: csi.
			csi := csi+1.
			clippingSpecStack size < csi
				ifTrue: [
					thisClipSpec := prevClipSpec copy.
					clippingSpecStack add: thisClipSpec ]
				ifFalse: [
					thisClipSpec := clippingSpecStack at: csi.
					thisClipSpec fillWith: prevClipSpec ].
			engine morphContourAfterDrawInterectInto: thisClipSpec.
		]
		ifFalse: 
		[
			csi := csi-1.
			thisClipSpec := clippingSpecStack at: csi.
		].!

BoundsFinderCanvas removeSelector: #clipCurrentMorph:!

!methodRemoval: BoundsFinderCanvas #clipCurrentMorph: stamp: 'Install-7193-VectorEngine-set-ClippingSpec-JuanVuletich-2025Mar11-16h24m-jmv.001.cs.st 5/24/2025 10:43:12'!
clipCurrentMorph: aBoolean!

MorphicCanvas removeSelector: #clipCurrentMorph:!

!methodRemoval: MorphicCanvas #clipCurrentMorph: stamp: 'Install-7193-VectorEngine-set-ClippingSpec-JuanVuletich-2025Mar11-16h24m-jmv.001.cs.st 5/24/2025 10:43:12'!
clipCurrentMorph: aBoolean!

VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineDrawer category: #'Morphic-Support' stamp: 'Install-7193-VectorEngine-set-ClippingSpec-JuanVuletich-2025Mar11-16h24m-jmv.001.cs.st 5/24/2025 10:43:12'!
VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7193-VectorEngine-set-ClippingSpec-JuanVuletich-2025Mar11-16h24m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7077] on 12 March 2025 at 12:24:19 pm'!
!Sample01Star methodsFor: 'drawing' stamp: 'jmv 3/12/2025 12:22:22' prior: 16945465 overrides: 16905026!
    drawOn: aCanvas
	"A 5 point star.
	Feel free to experiment with this code.
	The worst thing that could happen is that your morph breaks. That will only mean extra fun!!
	Sample01Star new openInHand
	"

	aCanvas strokeWidth: 12 color: Color lightOrange do: [
	"aCanvas fillColor: Color lightOrange do: ["
	"aCanvas strokeWidth: 12 color: Color lightOrange fillColor: Color yellow do: ["
		aCanvas
				moveTo: (Point rho: 100 theta: 90 degreesToRadians);
				lineTo: (Point rho: 100 theta: (360/5*2+90) degreesToRadians);
				lineTo: (Point rho: 100 theta: (360/5*4+90) degreesToRadians);
				lineTo: (Point rho: 100 theta: (360/5*6+90) degreesToRadians);
				lineTo: (Point rho: 100 theta: (360/5*8+90) degreesToRadians);
				lineTo: (Point rho: 100 theta: 90 degreesToRadians).
		].! !
!MorphicCanvas class methodsFor: 'instance creation' stamp: 'jmv 3/12/2025 12:19:03' prior: 16910251!
        onForm: aForm translation: aPoint

	^ self subclassToUse basicNew
		setForm: aForm subPixelAntiAliasing: false" not";
		initializeWithTranslation: aPoint.! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:17:45' prior: 50365658 overrides: 17002504!
                               blendFillOnly
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedLeftPixel antiAliasedRightPixel mustResetColor realFillColor |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedLeftPixel := targetWidth."targetWidth is effectively NOP"
	antiAliasedRightPixel := targetWidth."targetWidth is effectively NOP"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.

			edgesThisPixel := edgeCounts bytesAt: pixelIndex.
			edgeCounts at: pixelIndex put: 0.
			edgesThisPixelR := edgesThisPixel at: 3.
			edgesThisPixelG := edgesThisPixel at: 2.
			edgesThisPixelB := edgesThisPixel at: 1.

			"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
			edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
			edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
			edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].

			edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
			edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
			edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
			isRedInside := edgesUpToThisPixelR ~= 0.
			isGreenInside := edgesUpToThisPixelG ~= 0.
			isBlueInside := edgesUpToThisPixelB ~= 0.

			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
				alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedLeftPixel or: [ displayX = antiAliasedRightPixel])
					ifTrue: [ realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25. mustResetColor := true ]
					ifFalse: [
						(displayX-1 = antiAliasedLeftPixel or: [ displayX+1 = antiAliasedRightPixel]) ifTrue: [
							realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.75. mustResetColor := true ]].
				(strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] or: [
					isRedInside or: [ isGreenInside or: [ isBlueInside ]]]) ifTrue: [
						"At least one subpixel inside the shape, or in the anti aliasing area"
						self blendFillOnlyAt: pixelIndex
							redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
							antiAliasAlphasWord: strokeAntiAliasAlphasWord ].
				mustResetColor ifTrue: [
					fillColor := realFillColor. mustResetColor := false ]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:17:50' prior: 50365836 overrides: 17002509!
 blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedLeftPixel antiAliasedRightPixel mustResetColors realStrokeColor realFillColor |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedLeftPixel := targetWidth."targetWidth is effectively NOP"
	antiAliasedRightPixel := targetWidth."targetWidth is effectively NOP"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColors := false.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.

			edgesThisPixel := edgeCounts bytesAt: pixelIndex.
			edgeCounts at: pixelIndex put: 0.
			edgesThisPixelR := edgesThisPixel at: 3.
			edgesThisPixelG := edgesThisPixel at: 2.
			edgesThisPixelB := edgesThisPixel at: 1.

			"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
			edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
			edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
			edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].

			edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
			edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
			edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
			isRedInside := edgesUpToThisPixelR ~= 0.
			isGreenInside := edgesUpToThisPixelG ~= 0.
			isBlueInside := edgesUpToThisPixelB ~= 0.

			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
				alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedLeftPixel or: [ displayX = antiAliasedRightPixel])
					ifTrue: [
						realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25. mustResetColors := true ]
					ifFalse: [
						(displayX-1 = antiAliasedLeftPixel or: [ displayX+1 = antiAliasedRightPixel]) ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
							realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.75. mustResetColors := true ]].
				(strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] or: [
					isRedInside or: [ isGreenInside or: [ isBlueInside ]]]) ifTrue: [
						"At least one subpixel in the stroke or inside the shape"
						self blendStrokeAndFillAt: pixelIndex
							redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
							antiAliasAlphasWord: strokeAntiAliasAlphasWord ].mustResetColors ifTrue: [
				strokeColor := realStrokeColor. fillColor := realFillColor. mustResetColors := false ]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:17:53' prior: 50366058 overrides: 17002514!
   blendStrokeOnly
	"Blends stroke color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedLeftPixel antiAliasedRightPixel mustResetColor realStrokeColor |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedLeftPixel := targetWidth."targetWidth is effectively NOP"
	antiAliasedRightPixel := targetWidth."targetWidth is effectively NOP"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			"At least one subpixel in the stroke."
			strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] ifFalse: [
				alphaMask at: pixelIndex put: 0.
				(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
					(displayX = antiAliasedLeftPixel or: [ displayX = antiAliasedRightPixel])
						ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25. mustResetColor := true ]
						ifFalse: [
							(displayX-1 = antiAliasedLeftPixel or: [ displayX+1 = antiAliasedRightPixel]) ifTrue: [
								realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.75. mustResetColor := true ]].
					self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord.
					mustResetColor ifTrue: [
						strokeColor := realStrokeColor. mustResetColor := false ]]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:07:06' prior: 50362488 overrides: 17002504!
                           blendFillOnly
	"Blends fill color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixel edgesThisPixel pixelIndex antiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedLeftPixel antiAliasedRightPixel mustResetColor realFillColor |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedLeftPixel := targetWidth."targetWidth is effectively NOP"
	antiAliasedRightPixel := targetWidth."targetWidth is effectively NOP"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			edgesThisPixel := edgeCounts at: pixelIndex.
			edgesThisPixel = 0 ifFalse: [
				edgeCounts at: pixelIndex put: 0.
				"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
				edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
				edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
			antiAliasAlphaBits := alphaMask at: pixelIndex.
			antiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedLeftPixel or: [ displayX = antiAliasedRightPixel])
					ifTrue: [ realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25. mustResetColor := true ]
					ifFalse: [
						(displayX-1 = antiAliasedLeftPixel or: [ displayX+1 = antiAliasedRightPixel]) ifTrue: [
							realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.75. mustResetColor := true ]].
				edgesUpToThisPixel = 0
					ifFalse: [		"Inside the shape. Turn stroke anti aliasing into fill anti aliasing."
						antiAliasAlphaBits := 127 - antiAliasAlphaBits.
						self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: antiAliasAlphaBits ]
					ifTrue: [		"Still in the anti aliasing area, but outside the shape, strictly speaking."
						antiAliasAlphaBits = 0 ifFalse: [
							self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: antiAliasAlphaBits ]].
				mustResetColor ifTrue: [
					fillColor := realFillColor. mustResetColor := false ]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:07:23' prior: 50366181 overrides: 17002509!
           blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixel edgesThisPixel pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedLeftPixel antiAliasedRightPixel mustResetColors realStrokeColor realFillColor |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedLeftPixel := targetWidth."targetWidth is effectively NOP"
	antiAliasedRightPixel := targetWidth."targetWidth is effectively NOP"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColors := false.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			edgesThisPixel := edgeCounts at: pixelIndex.
			edgesThisPixel = 0 ifFalse: [
				edgeCounts at: pixelIndex put: 0.
				"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
				edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
				edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
			strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
			strokeAntiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedLeftPixel or: [ displayX = antiAliasedRightPixel])
					ifTrue: [
						realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25. mustResetColors := true ]
					ifFalse: [
						(displayX-1 = antiAliasedLeftPixel or: [ displayX+1 = antiAliasedRightPixel]) ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
							realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.75. mustResetColors := true ]].
				edgesUpToThisPixel = 0
					ifFalse: [			"Inside the shape"
						self blendStrokeAndFillAt: pixelIndex isInside: true antiAliasAlphaByte: strokeAntiAliasAlphaBits ]
					ifTrue: [			"Still in the stroke, but outside the shape, strictly speaking."
						strokeAntiAliasAlphaBits = 0 ifFalse: [
							self blendStrokeAndFillAt: pixelIndex isInside: false antiAliasAlphaByte: strokeAntiAliasAlphaBits ]].
				mustResetColors ifTrue: [
					strokeColor := realStrokeColor. fillColor := realFillColor. mustResetColors := false ]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:07:32' prior: 50366320 overrides: 17002514!
      blendStrokeOnly
	"Blends stroke color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedLeftPixel antiAliasedRightPixel mustResetColor realStrokeColor |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedLeftPixel := targetWidth."targetWidth is effectively NOP"
	antiAliasedRightPixel := targetWidth."targetWidth is effectively NOP"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
			strokeAntiAliasAlphaBits = 0 ifFalse: [			"In the stroke"
				alphaMask at: pixelIndex put: 0.
				(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
					(displayX = antiAliasedLeftPixel or: [ displayX = antiAliasedRightPixel])
						ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25. mustResetColor := true ]
						ifFalse: [
							(displayX-1 = antiAliasedLeftPixel or: [ displayX+1 = antiAliasedRightPixel]) ifTrue: [
								realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.75. mustResetColor := true ]].
					self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits.
					mustResetColor ifTrue: [
						strokeColor := realStrokeColor. mustResetColor := false ]]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7194-SmalltalkEngines-use-ClippingSpec-JuanVuletich-2025Mar12-10h27m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #7078] on 12 March 2025 at 12:42:56 pm'!
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 3/12/2025 12:38:20' prior: 50362230 overrides: 16909119!
               image: srcForm at: aPoint
	"Workaround using WarpBlt until properly implemented in VectorEngine.
	 (WarpBlt might not give desired result, i.e. a properly filtered and resamples image)

	In the general case, use WarpBlt to apply currentTransformation.
	Prior to that, set morphIds for affected pixels, and update bounds in engine.
	This is expensive!!

	If No scaling and no rotation, use BitBlt instead (way faster). This is useful, for instance, for halo handles.
	We expect to replace them with vector graphics icons, anyway.

	But if drawing the world background, finding bounds is not needed. Use two BitBlts then:
	One to paint pixels, and a second one to set morphIds.
	In this way, performance is same as in HybridCanvas, and not too different from BitBltCanvas.
	This is especially important, the default World background is a Form!!"

	| p bits |

	"Special case for our world:
	- No bounds needed
	- currentTransformation is identity: No translation, no rotation, no scaling.
	BitBlt is enough, but we need two of them!!"
	(world notNil and: [currentMorph == world]) ifTrue: [
		p := (currentTransformation transform: aPoint) roundedHAFZ.
		auxBitBltEngine
			sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
			colorMap: (srcForm colormapIfNeededFor: form);
			clipRect: clipRect;
			sourceX: 0; sourceY: 0;
			destX: p x destY: p y width: srcForm width height: srcForm height;
			copyBits.
		bits := form bits.
		[
			form bits: engine morphIds.
			auxBitBltEngine
				sourceForm: nil;
				fillBitmap: (Bitmap with: (currentMorph morphId));
				combinationRule: `Form over`;
				colorMap: nil;
				copyBits.
		] ensure: [ form bits: bits ].
		^self ].

	"Otherwise, we need to compute bounds. While we are at it, set morphID for affected pixels."
	self fillRectangle: (srcForm boundingBox translatedBy: aPoint) color: `Color gray alpha: 0.01`.
	currentTransformation isPureTranslation
		ifTrue: [
			p := (currentTransformation transform: aPoint) roundedHAFZ.
			auxBitBltEngine
				sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				sourceX: 0; sourceY: 0;
				destX: p x destY: p y width: srcForm width height: srcForm height;
				copyBits ]
		ifFalse: [
			| bb cellSize dstBox srcBox srcQuad |
			cellSize := 4.
			srcBox := srcForm boundingBox.
			dstBox := (currentTransformation externalBoundingRectOf: srcBox)
				encompassingIntegerRectangle.
			srcQuad := dstBox corners collect: [ :pt | (currentTransformation inverseTransform: pt) roundedHAFZ ].
			dstBox := (srcBox translatedBy: aPoint).
			dstBox := dstBox origin extent: dstBox extent + 1.1.
			dstBox := ((currentTransformation externalBoundingRectOf: dstBox))
				encompassingIntegerRectangle.
			bb := WarpBlt toForm: form.
			bb
				sourceForm: srcForm; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				cellSize: cellSize;
				copyQuad: srcQuad toRect: dstBox ].! !
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 3/12/2025 12:38:29' prior: 50362329!
       image: srcForm at: aPoint sourceRect: sourceRect
	"Workaround using WarpBlt until properly implemented in VectorEngine.
	 (WarpBlt might not give desired result, i.e. a properly filtered and resamples image)

	In the general case, use WarpBlt to apply currentTransformation.
	Prior to that, set morphIds for affected pixels, and update bounds in engine.
	This is expensive!!

	If No scaling and no rotation, use BitBlt instead (way faster). This is useful, for instance, for halo handles.
	We expect to replace them with vector graphics icons, anyway.

	But if drawing the world background, finding bounds is not needed. Use two BitBlts then:
	One to paint pixels, and a second one to set morphIds.
	In this way, performance is same as in HybridCanvas, and not too different from BitBltCanvas.
	This is especially important, the default World background is a Form!!"

	| p bits |

	"Special case for our world:
	- No bounds needed
	- currentTransformation is identity: No translation, no rotation, no scaling.
	BitBlt is enough, but we need two of them!!"
	currentMorph == world ifTrue: [
		p := (currentTransformation transform: aPoint) roundedHAFZ.
		auxBitBltEngine
			sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
			colorMap: (srcForm colormapIfNeededFor: form);
			clipRect: clipRect;
			sourceX: sourceRect left; sourceY: sourceRect top;
			destX: p x destY: p y width: sourceRect width height: sourceRect height;
			copyBits.
		bits := form bits.
		[
			form bits: engine morphIds.
			auxBitBltEngine
				sourceForm: nil;
				fillBitmap: (Bitmap with: (currentMorph morphId));
				combinationRule: `Form over`;
				colorMap: nil;
				copyBits.
		] ensure: [ form bits: bits ].
		^self ].

	"Otherwise, we need to compute bounds. While we are at it, set morphID for affected pixels."
	self fillRectangle: (sourceRect translatedBy: aPoint) color: `Color gray alpha: 0.01`.
	currentTransformation isPureTranslation
		ifTrue: [
			p := (currentTransformation transform: aPoint) roundedHAFZ.
			auxBitBltEngine
				sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				sourceX: sourceRect left; sourceY: sourceRect top;
				destX: p x destY: p y width: sourceRect width height: sourceRect height;
				copyBits ]
		ifFalse: [
			| bb cellSize dstBox srcBox srcQuad |
			cellSize := 4.
			srcBox := sourceRect.
			dstBox := (currentTransformation externalBoundingRectOf: srcBox)
				encompassingIntegerRectangle.
			srcQuad := dstBox corners collect: [ :pt | (currentTransformation inverseTransform: pt) roundedHAFZ ].
			dstBox := (currentTransformation externalBoundingRectOf: (srcBox translatedBy: aPoint-0.5))
				encompassingIntegerRectangle.
			bb := WarpBlt toForm: form.
			bb
				sourceForm: srcForm; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				cellSize: cellSize;
				copyQuad: srcQuad toRect: dstBox ].! !
!VectorEngineDrawer methodsFor: 'private' stamp: 'jmv 3/12/2025 12:39:57' prior: 50362426!
                    morphIdAt: aPoint
	| index |
	index := aPoint y * targetWidth + aPoint x + 1.
	(index between: 1 and: morphIds size) ifFalse: [ ^0 ].
	^morphIds at: index! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:38:46' prior: 50373478!
                   blendFillOnlyAt: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside antiAliasAlphasWord: strokeAntiAliasAlphasWord
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB alphaRBits alphaGBits alphaBBits alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB resultAlpha targetAlpha |

	"In this method, antiAliasAlphas are not used to blend stroke, but fill.
	This means that in the inside of the shape, and away from the stroke, they must be 1.0 (not 0.0).
	Next lines try to be in a simd friendly style."
	alphaRBits := strokeAntiAliasAlphasWord at: 3.
	alphaGBits := strokeAntiAliasAlphasWord at: 2.
	alphaBBits := strokeAntiAliasAlphasWord at: 1.
	isRedInside ifTrue: [ alphaRBits := 127 - alphaRBits ].
	isGreenInside ifTrue: [ alphaGBits := 127 - alphaGBits ].
	isBlueInside ifTrue: [ alphaBBits := 127 - alphaBBits ].
	alphaR := alphaRBits / 127.0.
	alphaG := alphaGBits / 127.0.
	alphaB := alphaBBits / 127.0.
	alphaR := alphaR * fillColor alpha.
	alphaG := alphaR * fillColor alpha.
	alphaB := alphaR * fillColor alpha.

	alphaR + alphaG + alphaB = 0.0 ifFalse: [
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.

		"These if are not really needed. just ignore them if we use simd instructions."
		alphaR = 0.0 ifFalse: [
			unAlphaR := 1.0 - alphaR.
			resultAlpha := alphaR + (unAlphaR * targetAlpha).
			resultR := alphaR * fillColor red * 255 + (unAlphaR * (targetWord at: 3) * targetAlpha).
			resultR := resultR/resultAlpha.
			targetWord at: 3 put: resultR rounded ].

		alphaG = 0.0 ifFalse: [
			unAlphaG := 1.0 - alphaG.
			resultAlpha := alphaG + (unAlphaG * targetAlpha).
			resultG := alphaG * fillColor green * 255 + (unAlphaG * (targetWord at: 2) * targetAlpha).
			resultG := resultG/resultAlpha.
			targetWord at: 2 put: resultG rounded.
			targetWord at: 4 put: (resultAlpha*255) rounded ].

		alphaB = 0.0 ifFalse: [
			unAlphaB := 1.0 - alphaB.
			resultAlpha := alphaB + (unAlphaB * targetAlpha).
			resultB := alphaB * fillColor blue * 255 + (unAlphaB * (targetWord at: 1) * targetAlpha).
			resultB := resultB/resultAlpha.
			targetWord at: 1 put: resultB rounded ].

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:38:56' prior: 50373561!
          blendStrokeAndFillAt: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside antiAliasAlphasWord: strokeAntiAliasAlphasWord
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB strokeAARedAlphaBits strokeAARedAlpha strokeAAGreenAlphaBits strokeAAGreenAlpha strokeAABlueAlphaBits strokeAABlueAlpha alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB foreR foreG foreB targetAlpha resultAlpha |

	"Next lines try to be in a simd friendly style."
	strokeAARedAlphaBits := strokeAntiAliasAlphasWord at: 3.
	strokeAAGreenAlphaBits := strokeAntiAliasAlphasWord at: 2.
	strokeAABlueAlphaBits := strokeAntiAliasAlphasWord at: 1.
	strokeAARedAlpha := strokeAARedAlphaBits / 127.0.
	strokeAAGreenAlpha := strokeAAGreenAlphaBits / 127.0.
	strokeAABlueAlpha := strokeAABlueAlphaBits / 127.0.

	isRedInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaR := strokeAARedAlpha * strokeColor alpha + ((1.0-strokeAARedAlpha) * fillColor alpha).
			foreR := strokeAARedAlpha * strokeColor red * 255 + ((1.0-strokeAARedAlpha) * fillColor red * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaR := strokeAARedAlpha * strokeColor alpha.
			foreR := strokeColor red * 255 ].

	isGreenInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaG := strokeAAGreenAlpha * strokeColor alpha + ((1.0-strokeAAGreenAlpha) * fillColor alpha).
			foreG := strokeAAGreenAlpha * strokeColor green * 255 + ((1.0-strokeAAGreenAlpha) * fillColor green * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaG := strokeAAGreenAlpha * strokeColor alpha.
			foreG := strokeColor green * 255 ].

	isBlueInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaB := strokeAABlueAlpha * strokeColor alpha + ((1.0-strokeAABlueAlpha) * fillColor alpha).
			foreB := strokeAABlueAlpha * strokeColor blue * 255 + ((1.0-strokeAABlueAlpha) * fillColor blue * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaB := strokeAABlueAlpha * strokeColor alpha.
			foreB := strokeColor blue * 255 ].

	alphaR + alphaG + alphaB = 0.0 ifFalse: [
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.

		"These if are not really needed. just ignore them if we use simd instructions."
		alphaR = 0.0 ifFalse: [
			unAlphaR := 1.0 - alphaR.
			resultAlpha := alphaR + (unAlphaR * targetAlpha).
			resultR := alphaR * foreR + (unAlphaR * (targetWord at: 3) * targetAlpha).
			resultR := resultR/resultAlpha.
			targetWord at: 3 put: resultR rounded ].
		alphaG = 0.0 ifFalse: [
			unAlphaG := 1.0 - alphaG.
			resultAlpha := alphaG + (unAlphaG * targetAlpha).
			resultG := alphaG * foreG + (unAlphaG * (targetWord at: 2) * targetAlpha).
			resultG := resultG/resultAlpha.
			targetWord at: 2 put: resultG rounded.
			targetWord at: 4 put: (resultAlpha*255) rounded ].
		alphaB = 0.0 ifFalse: [
			unAlphaB := 1.0 - alphaB.
			resultAlpha := alphaB + (unAlphaB * targetAlpha).
			resultB := alphaB * foreB + (unAlphaB * (targetWord at: 1) * targetAlpha).
			resultB := resultB/resultAlpha.
			targetWord at: 1 put: resultB rounded ].

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:39:02' prior: 50373681!
                               blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord
	"Blends stroke color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB alphaRBits alphaGBits alphaBBits alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB resultAlpha targetAlpha |

	"Next lines try to be in a simd friendly style."
	alphaRBits := strokeAntiAliasAlphasWord at: 3.
	alphaGBits := strokeAntiAliasAlphasWord at: 2.
	alphaBBits := strokeAntiAliasAlphasWord at: 1.
	alphaR := alphaRBits / 127.0.
	alphaG := alphaGBits / 127.0.
	alphaB := alphaBBits / 127.0.
	alphaR := alphaR * strokeColor alpha.
	alphaG := alphaG * strokeColor alpha.
	alphaB := alphaB * strokeColor alpha.

	alphaR + alphaG + alphaB = 0.0 ifFalse: [
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.

		"These if are not really needed. just ignore them if we use simd instructions."
		alphaR = 0.0 ifFalse: [
			unAlphaR := 1.0 - alphaR.
			resultAlpha := alphaR + (unAlphaR * targetAlpha).
			resultR := alphaR * strokeColor red * 255 + (unAlphaR * (targetWord at: 3) * targetAlpha).
			resultR := resultR/resultAlpha.
			targetWord at: 3 put: resultR rounded ].

		alphaG = 0.0 ifFalse: [
			unAlphaG := 1.0 - alphaG.
			resultAlpha := alphaG + (unAlphaG * targetAlpha).
			resultG := alphaG * strokeColor green * 255 + (unAlphaG * (targetWord at: 2) * targetAlpha).
			resultG := resultG/resultAlpha.
			targetWord at: 2 put: resultG rounded.
			targetWord at: 4 put: (resultAlpha*255) rounded ].

		alphaB = 0.0 ifFalse: [
			unAlphaB := 1.0 - alphaB.
			resultAlpha := alphaB + (unAlphaB * targetAlpha).
			resultB := alphaB * strokeColor blue * 255 + (unAlphaB * (targetWord at: 1) * targetAlpha).
			resultB := resultB/resultAlpha.
			targetWord at: 1 put: resultB rounded ].

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:39:08' prior: 50373751!
   blendFillOnlyAt: pixelIndex antiAliasAlphaByte: antiAliasAlphaBits
	"Blends fill color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| resultR resultG resultB antiAliasAlpha alpha unAlpha resultAlpha targetWord targetAlpha |

	antiAliasAlpha := antiAliasAlphaBits / 127.0.
	alpha := antiAliasAlpha * fillColor alpha.

	alpha = 0.0 ifFalse: [
		unAlpha := 1.0 - alpha.
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.
		resultAlpha := alpha + (unAlpha * targetAlpha).
		targetWord at: 4 put: (resultAlpha*255) rounded.
		
		resultR := alpha * fillColor red * 255 + (unAlpha * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded.

		resultG := alpha * fillColor green * 255 + (unAlpha * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.

		resultB := alpha * fillColor blue * 255 + (unAlpha * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded.

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:39:15' prior: 50373795!
                   blendStrokeAndFillAt: pixelIndex isInside: isInside antiAliasAlphaByte: strokeAntiAliasAlphaBits
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB strokeAAAlpha alpha unAlpha foreR foreG foreB targetAlpha resultAlpha |

	strokeAAAlpha := strokeAntiAliasAlphaBits / 127.0.

	isInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha := strokeAAAlpha * strokeColor alpha + ((1-strokeAAAlpha) * fillColor alpha).
			foreR := strokeAAAlpha * strokeColor red * 255 + ((1-strokeAAAlpha) * fillColor red * 255).
			foreG := strokeAAAlpha * strokeColor green * 255 + ((1-strokeAAAlpha) * fillColor green * 255).
			foreB := strokeAAAlpha * strokeColor blue * 255 + ((1-strokeAAAlpha) * fillColor blue * 255) ]
		ifFalse: [							"Blend stroke over background"
			alpha := strokeAAAlpha * strokeColor alpha.
			foreR := strokeColor red * 255.
			foreG := strokeColor green * 255.
			foreB := strokeColor blue * 255 ].

	alpha = 0.0 ifFalse: [
		unAlpha := 1.0 - alpha.
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.
		resultAlpha := alpha + (unAlpha * targetAlpha).
		targetWord at: 4 put: (resultAlpha*255) rounded.

		resultR := alpha * foreR + (unAlpha * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded.

		resultG := alpha * foreG + (unAlpha * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.

		resultB := alpha * foreB + (unAlpha * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded.

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/12/2025 12:39:23' prior: 50373862!
    blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits
	"Blends stroke color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB alpha unAlpha resultAlpha targetAlpha |
	alpha := strokeAntiAliasAlphaBits / 127.0.
	alpha := alpha * strokeColor alpha.

	alpha = 0.0 ifFalse: [
		unAlpha := 1.0 - alpha.
		targetWord := targetForm bits bytesAt: pixelIndex.

		targetAlpha := (targetWord at: 4) / 255.0.
		resultAlpha := alpha + (unAlpha * targetAlpha).
		targetWord at: 4 put: (resultAlpha*255) rounded.

		resultR := alpha * strokeColor red * 255 + (unAlpha * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded.

		resultG := alpha * strokeColor green * 255 + (unAlpha * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.

		resultB := alpha * strokeColor blue * 255 + (unAlpha * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded.

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7195-morphIds-allBitsForIt-JuanVuletich-2025Mar12-12h38m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7092] on 27 March 2025 at 8:30:23 am'!

VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec targetAssumedOpaque '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineDrawer category: #'Morphic-Support' stamp: 'Install-7196-SmalltalkEngines-OpaqueAndTranslucentTarget-JuanVuletich-2025Mar27-08h19m-jmv.001.cs.st 5/24/2025 10:43:12'!
VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec targetAssumedOpaque'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!
!VectorEngineDrawer methodsFor: 'accessing' stamp: 'jmv 3/21/2025 14:53:58'!
           disableTargetTranslucency
	"Avoid the cost of computing correct target transucency.
	This is the default behavior. Target translucency is not required when drawing to Display for live Morphic.
	See #enableTargetTranslucency."

	targetAssumedOpaque := true! !
!VectorEngineDrawer methodsFor: 'accessing' stamp: 'jmv 3/21/2025 14:52:30'!
                enableTargetTranslucency
	"Compute correct target transucency.
	This is usually not needed, and it is computationally more expensive. Default is #disableTargetTranslucency.
	It is required, for instance, for #imageForm and similar methods, so result is transparent outside of the drawing."

	targetAssumedOpaque := false! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 17:30:41'!
                           blendStrokeAndFillAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits
	"Do an appropriate (anti aliased) mix between stoke color and fill color. Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB strokeAAAlpha alpha unAlpha foreR foreG foreB targetAlpha resultAlpha |

	strokeAAAlpha := strokeAntiAliasAlphaBits / 127.0.

	"Do gradient between stroke and fill. Blend the result over background"
	foreR := strokeAAAlpha * strokeColor red * 255 + ((1-strokeAAAlpha) * fillColor red * 255).
	foreG := strokeAAAlpha * strokeColor green * 255 + ((1-strokeAAAlpha) * fillColor green * 255).
	foreB := strokeAAAlpha * strokeColor blue * 255 + ((1-strokeAAAlpha) * fillColor blue * 255).
	alpha := strokeAAAlpha * strokeColor alpha + ((1-strokeAAAlpha) * fillColor alpha).
	unAlpha := 1.0 - alpha.

	targetWord := targetForm bits bytesAt: pixelIndex.
	targetAlpha := (targetWord at: 4) / 255.0.

	resultAlpha := alpha + (unAlpha * targetAlpha).
	targetWord at: 4 put: (resultAlpha*255) rounded.

	resultR := alpha * foreR + (unAlpha * (targetWord at: 3) * targetAlpha).
	resultR := resultR/resultAlpha.
	targetWord at: 3 put: resultR rounded.

	resultG := alpha * foreG + (unAlpha * (targetWord at: 2) * targetAlpha).
	resultG := resultG/resultAlpha.
	targetWord at: 2 put: resultG rounded.

	resultB := alpha * foreB + (unAlpha * (targetWord at: 1) * targetAlpha).
	resultB := resultB/resultAlpha.
	targetWord at: 1 put: resultB rounded.

	targetForm bits bytesAt: pixelIndex put: targetWord.
	morphIds at: pixelIndex put: currentMorphId.! !
!VectorEngineDrawer methodsFor: 'private' stamp: 'jmv 3/20/2025 09:13:45' prior: 50362615!
             pvtSetForm: aForm

	| s |
	targetForm := aForm.
	targetWidth := targetForm width.
	targetHeight := targetForm height.
	targetAssumedOpaque := true. 		"Set to false for true translucency on target."
	s := targetWidth * targetHeight.
	morphIds := WordArray new: s.
	edgeCounts := self auxPixelDataClass new: s.
	alphaMask := self auxPixelDataClass new: s.
	contour := Float32Array new: targetHeight * 2.
	0 to: targetHeight-1 do: [ :y |
		contour at: y * 2 + 1 put: targetWidth.
		contour at: y * 2 + 2 put: 0 ].
	self resetMorphBounds.
	self clipRect: targetForm boundingBox.
	self antiAliasingWidth: self class defaultAntiAliasingWidth.
	geometryTransformation := MorphicTranslation identity.! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 16:49:36' prior: 50374463 overrides: 17002504!
     blendFillOnly
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realFillColor opaqueFillColorWord realOpaqueFillColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ fillColor alpha = 1.0 ]) ifTrue: [
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			
			edgesThisPixel := edgeCounts bytesAt: pixelIndex.
			edgeCounts at: pixelIndex put: 0.
			edgesThisPixelR := edgesThisPixel at: 3.
			edgesThisPixelG := edgesThisPixel at: 2.
			edgesThisPixelB := edgesThisPixel at: 1.
			
			"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
			edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
			edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
			edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
			
			edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
			edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
			edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
			isRedInside := edgesUpToThisPixelR ~= 0.
			isGreenInside := edgesUpToThisPixelG ~= 0.
			isBlueInside := edgesUpToThisPixelB ~= 0.
			
			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
				alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
					ifTrue: [
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realFillColor := fillColor.  fillColor := fillColor alpha: fillColor alpha * 0.75.
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]].
				
				(strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] or: [
					isRedInside or: [ isGreenInside or: [ isBlueInside ]]]) ifTrue: [
					
						(strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] and: [ opaqueFillColorWord ~= 0 ])
							ifTrue: [
								"Fully inside the shape, far from anti aliasing. Color is opaque. Target is too. Just overwrite with fill color."
								targetForm bits at: pixelIndex put: opaqueFillColorWord.
								morphIds at: pixelIndex put: currentMorphId ]
							ifFalse: [
								"At least one subpixel inside the shape, or in the anti aliasing area"
								self blendFillOnlyAt: pixelIndex
									redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
									antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].
				
				mustResetColor ifTrue: [
					fillColor := realFillColor. opaqueFillColorWord := realOpaqueFillColorWord. mustResetColor := false ]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 17:24:32' prior: 50375262!
                 blendFillOnlyAt: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside antiAliasAlphasWord: strokeAntiAliasAlphasWord
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB alphaRBits alphaGBits alphaBBits alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB resultAlpha targetAlpha |

	"In this method, antiAliasAlphas are not used to blend stroke, but fill.
	This means that in the inside of the shape, and away from the stroke, they must be 1.0 (not 0.0).
	Next lines try to be in a simd friendly style."
	alphaRBits := strokeAntiAliasAlphasWord at: 3.
	alphaGBits := strokeAntiAliasAlphasWord at: 2.
	alphaBBits := strokeAntiAliasAlphasWord at: 1.
	isRedInside ifTrue: [ alphaRBits := 127 - alphaRBits ].
	isGreenInside ifTrue: [ alphaGBits := 127 - alphaGBits ].
	isBlueInside ifTrue: [ alphaBBits := 127 - alphaBBits ].
	alphaR := alphaRBits / 127.0.
	alphaG := alphaGBits / 127.0.
	alphaB := alphaBBits / 127.0.
	alphaR := alphaR * fillColor alpha.
	alphaG := alphaG * fillColor alpha.
	alphaB := alphaB * fillColor alpha.

	targetWord := targetForm bits bytesAt: pixelIndex.
	targetAlpha := (targetWord at: 4) / 255.0.

	"These if are not really needed. just ignore them if we use simd instructions."
	alphaR = 0.0 ifFalse: [
		unAlphaR := 1.0 - alphaR.
		resultAlpha := alphaR + (unAlphaR * targetAlpha).
		resultR := alphaR * fillColor red * 255 + (unAlphaR * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded ].

	alphaG = 0.0 ifFalse: [
		unAlphaG := 1.0 - alphaG.
		resultAlpha := alphaG + (unAlphaG * targetAlpha).
		resultG := alphaG * fillColor green * 255 + (unAlphaG * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.
		targetWord at: 4 put: (resultAlpha*255) rounded ].

	alphaB = 0.0 ifFalse: [
		unAlphaB := 1.0 - alphaB.
		resultAlpha := alphaB + (unAlphaB * targetAlpha).
		resultB := alphaB * fillColor blue * 255 + (unAlphaB * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded ].

	targetForm bits bytesAt: pixelIndex put: targetWord.
	morphIds at: pixelIndex put: currentMorphId.! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 17:15:57' prior: 50374581 overrides: 17002509!
                           blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColors realStrokeColor realFillColor opaqueStrokeColorWord opaqueFillColorWord realOpaqueStrokeColorWord realOpaqueFillColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColors := false.
	opaqueStrokeColorWord := 0.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha * fillColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000.
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			
			edgesThisPixel := edgeCounts bytesAt: pixelIndex.
			edgeCounts at: pixelIndex put: 0.
			edgesThisPixelR := edgesThisPixel at: 3.
			edgesThisPixelG := edgesThisPixel at: 2.
			edgesThisPixelB := edgesThisPixel at: 1.
			
			"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
			edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
			edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
			edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
			
			edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
			edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
			edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
			isRedInside := edgesUpToThisPixelR ~= 0.
			isGreenInside := edgesUpToThisPixelG ~= 0.
			isBlueInside := edgesUpToThisPixelB ~= 0.
			
			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
				alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel ])
					ifTrue: [
						realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]].
				
				strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00]
					ifTrue: [ 		"Not in the stroke at all. Either fully in the fill, or outside the shape (pixel is unaffected)."
						isGreenInside
							ifTrue: [
								"Fully inside the fill, far from anti aliasing. (Here isGreenInside also implies isRedInside and isBlueInside)"
								opaqueFillColorWord ~= 0
									ifTrue: [
										"Fill color is opaque. Target is too. Just overwrite with fill color."
										targetForm bits at: pixelIndex put: opaqueFillColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of fill over target."
										self blendFillOnlyAt: pixelIndex
											redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
											antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]]
					ifFalse: [		"At least one subpixel in the stroke."
						strokeAntiAliasAlphasWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00]
							ifTrue: [
								"Fully inside the stroke, far from anti aliasing."
								opaqueStrokeColorWord ~= 0
									ifTrue: [
										"Stroke color is opaque. Target is too. Just overwrite with stroke color."
										targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of stroke over target."
										self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]
							ifFalse: [
								"In an anti aliased part of the stroke. Either blend stroke over background, or pre-mix stroke and fill."
								self blendStrokeAndFillAt: pixelIndex
									redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
									antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].					
				
				mustResetColors ifTrue: [
					strokeColor := realStrokeColor. fillColor := realFillColor.
					opaqueStrokeColorWord := realOpaqueStrokeColorWord. opaqueFillColorWord := realOpaqueFillColorWord.
					mustResetColors := false ]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 17:25:21' prior: 50375345!
            blendStrokeAndFillAt: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside antiAliasAlphasWord: strokeAntiAliasAlphasWord
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB strokeAARedAlphaBits strokeAARedAlpha strokeAAGreenAlphaBits strokeAAGreenAlpha strokeAABlueAlphaBits strokeAABlueAlpha alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB foreR foreG foreB targetAlpha resultAlpha |

	"Next lines try to be in a simd friendly style."
	strokeAARedAlphaBits := strokeAntiAliasAlphasWord at: 3.
	strokeAAGreenAlphaBits := strokeAntiAliasAlphasWord at: 2.
	strokeAABlueAlphaBits := strokeAntiAliasAlphasWord at: 1.
	strokeAARedAlpha := strokeAARedAlphaBits / 127.0.
	strokeAAGreenAlpha := strokeAAGreenAlphaBits / 127.0.
	strokeAABlueAlpha := strokeAABlueAlphaBits / 127.0.

	isRedInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaR := strokeAARedAlpha * strokeColor alpha + ((1.0-strokeAARedAlpha) * fillColor alpha).
			foreR := strokeAARedAlpha * strokeColor red * 255 + ((1.0-strokeAARedAlpha) * fillColor red * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaR := strokeAARedAlpha * strokeColor alpha.
			foreR := strokeColor red * 255 ].

	isGreenInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaG := strokeAAGreenAlpha * strokeColor alpha + ((1.0-strokeAAGreenAlpha) * fillColor alpha).
			foreG := strokeAAGreenAlpha * strokeColor green * 255 + ((1.0-strokeAAGreenAlpha) * fillColor green * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaG := strokeAAGreenAlpha * strokeColor alpha.
			foreG := strokeColor green * 255 ].

	isBlueInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alphaB := strokeAABlueAlpha * strokeColor alpha + ((1.0-strokeAABlueAlpha) * fillColor alpha).
			foreB := strokeAABlueAlpha * strokeColor blue * 255 + ((1.0-strokeAABlueAlpha) * fillColor blue * 255) ]
		ifFalse: [							"Blend stroke over background"
			alphaB := strokeAABlueAlpha * strokeColor alpha.
			foreB := strokeColor blue * 255 ].

	targetWord := targetForm bits bytesAt: pixelIndex.
	targetAlpha := (targetWord at: 4) / 255.0.

	"These if are not really needed. just ignore them if we use simd instructions."
	alphaR = 0.0 ifFalse: [
		unAlphaR := 1.0 - alphaR.
		resultAlpha := alphaR + (unAlphaR * targetAlpha).
		resultR := alphaR * foreR + (unAlphaR * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded ].
	alphaG = 0.0 ifFalse: [
		unAlphaG := 1.0 - alphaG.
		resultAlpha := alphaG + (unAlphaG * targetAlpha).
		resultG := alphaG * foreG + (unAlphaG * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.
		targetWord at: 4 put: (resultAlpha*255) rounded ].
	alphaB = 0.0 ifFalse: [
		unAlphaB := 1.0 - alphaB.
		resultAlpha := alphaB + (unAlphaB * targetAlpha).
		resultB := alphaB * foreB + (unAlphaB * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded ].

	targetForm bits bytesAt: pixelIndex put: targetWord.
	morphIds at: pixelIndex put: currentMorphId.! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 17:06:56' prior: 50374710 overrides: 17002514!
                blendStrokeOnly
	"Blends stroke color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realStrokeColor opaqueStrokeColorWord realOpaqueStrokeColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueStrokeColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			"At least one subpixel in the stroke."
			strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] ifFalse: [
				alphaMask at: pixelIndex put: 0.
				(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
					(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
						ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]
						ifFalse: [
							(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
								realStrokeColor := strokeColor.  strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
								realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]].
					
					(opaqueStrokeColorWord ~= 0 and: [strokeAntiAliasAlphasWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00]])
						ifTrue: [
							"Fully inside the stroke, far from anti aliasing. Color is opaque. Target is too. Just overwrite with stroke color."
							targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
							morphIds at: pixelIndex put: currentMorphId ]
						ifFalse: [
							"At least one subpixel in the anti aliasing area of the stroke, or color is translucent, or target translucency is desired."
							self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord ].
					
					mustResetColor ifTrue: [
						strokeColor := realStrokeColor. opaqueStrokeColorWord := realOpaqueStrokeColorWord. mustResetColor := false ]]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 17:25:58' prior: 50375465!
                           blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord
	"Blends stroke color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB alphaRBits alphaGBits alphaBBits alphaR alphaG alphaB unAlphaR unAlphaG unAlphaB resultAlpha targetAlpha |

	"Next lines try to be in a simd friendly style."
	alphaRBits := strokeAntiAliasAlphasWord at: 3.
	alphaGBits := strokeAntiAliasAlphasWord at: 2.
	alphaBBits := strokeAntiAliasAlphasWord at: 1.
	alphaR := alphaRBits / 127.0.
	alphaG := alphaGBits / 127.0.
	alphaB := alphaBBits / 127.0.
	alphaR := alphaR * strokeColor alpha.
	alphaG := alphaG * strokeColor alpha.
	alphaB := alphaB * strokeColor alpha.

	targetWord := targetForm bits bytesAt: pixelIndex.
	targetAlpha := (targetWord at: 4) / 255.0.

	"These if are not really needed. just ignore them if we use simd instructions."
	alphaR = 0.0 ifFalse: [
		unAlphaR := 1.0 - alphaR.
		resultAlpha := alphaR + (unAlphaR * targetAlpha).
		resultR := alphaR * strokeColor red * 255 + (unAlphaR * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded ].

	alphaG = 0.0 ifFalse: [
		unAlphaG := 1.0 - alphaG.
		resultAlpha := alphaG + (unAlphaG * targetAlpha).
		resultG := alphaG * strokeColor green * 255 + (unAlphaG * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.
		targetWord at: 4 put: (resultAlpha*255) rounded ].

	alphaB = 0.0 ifFalse: [
		unAlphaB := 1.0 - alphaB.
		resultAlpha := alphaB + (unAlphaB * targetAlpha).
		resultB := alphaB * strokeColor blue * 255 + (unAlphaB * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded ].

	targetForm bits bytesAt: pixelIndex put: targetWord.
	morphIds at: pixelIndex put: currentMorphId.! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 17:00:48' prior: 50374786 overrides: 17002504!
                    blendFillOnly
	"Blends fill color over background.
	If targetAssumedOpaque is false, target translucency is computed correctly.
	If targetAssumedOpaque is true (and target translucency is actually 255 on input), an optimization is made and target translucency is set to 255.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]."

	| edgesUpToThisPixel edgesThisPixel pixelIndex antiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realFillColor opaqueFillColorWord realOpaqueFillColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ fillColor alpha = 1.0 ]) ifTrue: [
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			edgesThisPixel := edgeCounts at: pixelIndex.
			edgesThisPixel = 0 ifFalse: [
				edgeCounts at: pixelIndex put: 0.
				"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
				edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
				edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
			antiAliasAlphaBits := alphaMask at: pixelIndex.
			antiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
					ifTrue: [
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realFillColor := fillColor.  fillColor := fillColor alpha: fillColor alpha * 0.75.
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]].
				
				edgesUpToThisPixel = 0
					ifFalse: [ "Inside the shape"
						(antiAliasAlphaBits = 0 and: [ opaqueFillColorWord ~= 0 ])
							ifTrue: [
								"Fully inside the shape, far from anti aliasing. Color is opaque. Target is too. Just overwrite with fill color."
								targetForm bits at: pixelIndex put: opaqueFillColorWord.
								morphIds at: pixelIndex put: currentMorphId ]
							ifFalse: [
								"Inside the shape. Turn stroke anti aliasing into fill anti aliasing."
								self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: 127 - antiAliasAlphaBits ]]
					ifTrue: [ "Still in the anti aliasing area, but outside the shape, strictly speaking."
						antiAliasAlphaBits = 0 ifFalse: [
							self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: antiAliasAlphaBits ]].
				
				mustResetColor ifTrue: [
					fillColor := realFillColor. opaqueFillColorWord := realOpaqueFillColorWord. mustResetColor := false ]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 17:31:00' prior: 50375535!
                               blendFillOnlyAt: pixelIndex antiAliasAlphaByte: antiAliasAlphaBits
	"Blends fill color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| resultR resultG resultB antiAliasAlpha alpha unAlpha resultAlpha targetWord targetAlpha |

	antiAliasAlpha := antiAliasAlphaBits / 127.0.
	alpha := antiAliasAlpha * fillColor alpha.
	unAlpha := 1.0 - alpha.

	targetWord := targetForm bits bytesAt: pixelIndex.
	targetAlpha := (targetWord at: 4) / 255.0.

	resultAlpha := alpha + (unAlpha * targetAlpha).
	targetWord at: 4 put: (resultAlpha*255) rounded.
	
	resultR := alpha * fillColor red * 255 + (unAlpha * (targetWord at: 3) * targetAlpha).
	resultR := resultR/resultAlpha.
	targetWord at: 3 put: resultR rounded.

	resultG := alpha * fillColor green * 255 + (unAlpha * (targetWord at: 2) * targetAlpha).
	resultG := resultG/resultAlpha.
	targetWord at: 2 put: resultG rounded.

	resultB := alpha * fillColor blue * 255 + (unAlpha * (targetWord at: 1) * targetAlpha).
	resultB := resultB/resultAlpha.
	targetWord at: 1 put: resultB rounded.

	targetForm bits bytesAt: pixelIndex put: targetWord.
	morphIds at: pixelIndex put: currentMorphId.! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 17:12:47' prior: 50374878 overrides: 17002509!
         blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixel edgesThisPixel pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColors realStrokeColor realFillColor opaqueStrokeColorWord opaqueFillColorWord realOpaqueStrokeColorWord realOpaqueFillColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColors := false.
	opaqueStrokeColorWord := 0.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha * fillColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000.
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			edgesThisPixel := edgeCounts at: pixelIndex.
			edgesThisPixel = 0 ifFalse: [
				edgeCounts at: pixelIndex put: 0.
				"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
				edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
				edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
			strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
			strokeAntiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel ])
					ifTrue: [
						realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]].
				
				strokeAntiAliasAlphaBits = 0
					ifTrue: [ 		"Not in the stroke at all. Either fully in the fill, or outside the shape (pixel is unaffected)."
						edgesUpToThisPixel ~= 0
							ifTrue: [
								"Fully inside the fill, far from anti aliasing."
								opaqueFillColorWord ~= 0
									ifTrue: [
										"Color is opaque. Target is too. Just overwrite with fill color."
										targetForm bits at: pixelIndex put: opaqueFillColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of fill over target."
										self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: 127 ]]]
					ifFalse: [		"In the stroke."
						strokeAntiAliasAlphaBits = 127
							ifTrue: [
								"Fully inside the stroke, far from anti aliasing."
								opaqueStrokeColorWord ~= 0
									ifTrue: [
										"Color is opaque. Target is too. Just overwrite with stroke color."
										targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of stroke over target."
										self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: 127 ]]
							ifFalse: [
								"In an anti aliased part of the stroke. Either blend stroke over background, or pre-mix stroke and fill."
								edgesUpToThisPixel ~= 0
									ifTrue: [ 
										"Inside the shape. Blend stroke and fill, blend result over target."
										self blendStrokeAndFillAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]
									ifFalse: [
										"In the outer anti aliasing area of the stroke. Blend stroke over background."
										self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]]].
				
				mustResetColors ifTrue: [
					strokeColor := realStrokeColor. fillColor := realFillColor.
					opaqueStrokeColorWord := realOpaqueStrokeColorWord. opaqueFillColorWord := realOpaqueFillColorWord.
					mustResetColors := false ]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 17:09:12' prior: 50374980 overrides: 17002514!
     blendStrokeOnly
	"Blends stroke color over background.
	If targetAssumedOpaque is false, target translucency is computed correctly.
	If targetAssumedOpaque is true (and target translucency is actually 255 on input), an optimization is made and target translucency is set to 255.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realStrokeColor opaqueStrokeColorWord realOpaqueStrokeColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueStrokeColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + spanLeft.
		spanLeft to: spanRight do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
			strokeAntiAliasAlphaBits = 0 ifFalse: [			"In the stroke"
				alphaMask at: pixelIndex put: 0.
				(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
					(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
						ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]
						ifFalse: [
							(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
								realStrokeColor := strokeColor.  strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
								realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]].
					
					(opaqueStrokeColorWord ~= 0 and: [strokeAntiAliasAlphaBits = 127])
						ifTrue: [
							"Fully inside the stroke, far from anti aliasing. Color is opaque. Target is too. Just overwrite with stroke color."
							targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
							morphIds at: pixelIndex put: currentMorphId ]
						ifFalse: [
							"At least one subpixel in the anti aliasing area of the stroke, or color is translucent, or target translucency is desired."
							self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ].
					
					mustResetColor ifTrue: [
						strokeColor := realStrokeColor. opaqueStrokeColorWord := realOpaqueStrokeColorWord. mustResetColor := false ]]]].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 3/26/2025 17:31:34' prior: 50375646!
                blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits
	"Blends stroke color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB antiAliasAlpha alpha unAlpha resultAlpha targetAlpha |

	antiAliasAlpha := strokeAntiAliasAlphaBits / 127.0.
	alpha := antiAliasAlpha * strokeColor alpha.
	unAlpha := 1.0 - alpha.

	targetWord := targetForm bits bytesAt: pixelIndex.
	targetAlpha := (targetWord at: 4) / 255.0.

	resultAlpha := alpha + (unAlpha * targetAlpha).
	targetWord at: 4 put: (resultAlpha*255) rounded.

	resultR := alpha * strokeColor red * 255 + (unAlpha * (targetWord at: 3) * targetAlpha).
	resultR := resultR/resultAlpha.
	targetWord at: 3 put: resultR rounded.

	resultG := alpha * strokeColor green * 255 + (unAlpha * (targetWord at: 2) * targetAlpha).
	resultG := resultG/resultAlpha.
	targetWord at: 2 put: resultG rounded.

	resultB := alpha * strokeColor blue * 255 + (unAlpha * (targetWord at: 1) * targetAlpha).
	resultB := resultB/resultAlpha.
	targetWord at: 1 put: resultB rounded.

	targetForm bits bytesAt: pixelIndex put: targetWord.
	morphIds at: pixelIndex put: currentMorphId.! !

VectorEngineWholePixel removeSelector: #blendStrokeAndFillAt:isInside:antiAliasAlphaByte:!

!methodRemoval: VectorEngineWholePixel #blendStrokeAndFillAt:isInside:antiAliasAlphaByte: stamp: 'Install-7196-SmalltalkEngines-OpaqueAndTranslucentTarget-JuanVuletich-2025Mar27-08h19m-jmv.001.cs.st 5/24/2025 10:43:12'!
blendStrokeAndFillAt: pixelIndex isInside: isInside antiAliasAlphaByte: strokeAntiAliasAlphaBits
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord resultR resultG resultB strokeAAAlpha alpha unAlpha foreR foreG foreB targetAlpha resultAlpha |

	strokeAAAlpha := strokeAntiAliasAlphaBits / 127.0.

	isInside
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha := strokeAAAlpha * strokeColor alpha + ((1-strokeAAAlpha) * fillColor alpha).
			foreR := strokeAAAlpha * strokeColor red * 255 + ((1-strokeAAAlpha) * fillColor red * 255).
			foreG := strokeAAAlpha * strokeColor green * 255 + ((1-strokeAAAlpha) * fillColor green * 255).
			foreB := strokeAAAlpha * strokeColor blue * 255 + ((1-strokeAAAlpha) * fillColor blue * 255) ]
		ifFalse: [							"Blend stroke over background"
			alpha := strokeAAAlpha * strokeColor alpha.
			foreR := strokeColor red * 255.
			foreG := strokeColor green * 255.
			foreB := strokeColor blue * 255 ].

	alpha = 0.0 ifFalse: [
		unAlpha := 1.0 - alpha.
		targetWord := targetForm bits bytesAt: pixelIndex.
		targetAlpha := (targetWord at: 4) / 255.0.
		resultAlpha := alpha + (unAlpha * targetAlpha).
		targetWord at: 4 put: (resultAlpha*255) rounded.

		resultR := alpha * foreR + (unAlpha * (targetWord at: 3) * targetAlpha).
		resultR := resultR/resultAlpha.
		targetWord at: 3 put: resultR rounded.

		resultG := alpha * foreG + (unAlpha * (targetWord at: 2) * targetAlpha).
		resultG := resultG/resultAlpha.
		targetWord at: 2 put: resultG rounded.

		resultB := alpha * foreB + (unAlpha * (targetWord at: 1) * targetAlpha).
		resultB := resultB/resultAlpha.
		targetWord at: 1 put: resultB rounded.

		targetForm bits bytesAt: pixelIndex put: targetWord.
		morphIds at: pixelIndex put: currentMorphId ].!

VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight targetAssumedOpaque morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineDrawer category: #'Morphic-Support' stamp: 'Install-7196-SmalltalkEngines-OpaqueAndTranslucentTarget-JuanVuletich-2025Mar27-08h19m-jmv.001.cs.st 5/24/2025 10:43:12'!
VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight targetAssumedOpaque morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

VectorEngineDrawer allSubInstancesDo: [ :engine |
	engine instVarNamed: 'targetAssumedOpaque' put:​ true ].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7196-SmalltalkEngines-OpaqueAndTranslucentTarget-JuanVuletich-2025Mar27-08h19m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7089] on 21 March 2025 at 12:47:45 pm'!
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 3/21/2025 12:47:06' prior: 50361062!
                               displayByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try BOTH!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.'.
e displayByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsTop boundsBottom numContours numBeziers x y cx cy contourStart |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	 "Should use a specific table with 256 entries"
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8. "Should use a specific table with 256 entries"
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		startIndex to: stopIndex do: [ :charIndex | | latin1Code i |
			latin1Code := (aString at: charIndex) asciiValue.
			i := contourDataIndexes at: latin1Code + 1.
			advanceWidth := contourData at: i. i := i + 1.
			boundsLeft := contourData at: i. i := i + 1.
			boundsRight := contourData at: i. i := i + 1.
			boundsBottom := contourData at: i. i := i + 1.
			boundsTop := contourData at: i. i := i + 1.
			numContours := (contourData at: i) asInteger. i := i + 1.
			numContours timesRepeat: [
				numBeziers := (contourData at: i) asInteger. i := i + 1.
				ttMoveToX := contourData at: i. i := i + 1.
				ttMoveToY := contourData at: i. i := i + 1.
				x := ttMoveToX * sx + nextGlyphX.
				y := ttMoveToY * sy + nextGlyphY.
				contourStart := x@y.
				self moveTo: contourStart.
				numBeziers timesRepeat: [
					ttEndX := contourData at: i. i := i + 1.
					ttEndY := contourData at: i. i := i + 1.
					ttControlX := contourData at: i. i := i + 1.
					ttControlY := contourData at: i. i := i + 1.
					cx := ttControlX * sx + x.
					cy := ttControlY * sy + y.
					x := ttEndX * sx + x.
					y := ttEndY * sy + y.
					self quadraticBezierTo: x@y control: cx@cy ].
				self lineTo: contourStart ].
			nextGlyphX := nextGlyphX + (advanceWidth * sx) ]].
	^ nextGlyphX@nextGlyphY! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 3/21/2025 11:58:10' prior: 50361160!
             displayUtf32: aWordArray from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f utf32 |
'Try BOTH!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf32 _ #(4314 4317 4320 4308 4315 32 4312 4324 4321 4323 4315 32 4307 4317 4314 4317 4320 32 4321 4312 4311 32 4304 4315 4308 4311 44 32 4327 4323 4317 32 4323 4311 32 4307 4312 4330 4304 4311 32 4304 4314 4312 4327 4323 4312 4307 44 32 4304 4307 32 4314 4312 4305 4320 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4320 4308 4324 4320 4308 4336 4308 4316 4307 4323 4316 4311 32 4308 4321 4311 46 32 4314 4308 4306 4308 4320 4308 32 4330 4317 4320 4324 4317 4320 4304 32 4308 4324 4324 4312 4330 4312 4304 4316 4311 4323 4320 32 4304 4311 32 4308 4304 4315 44 32 4316 4317 32 4327 4323 4304 4321 32 4315 4308 4316 4304 4316 4307 4320 4312 32 4320 4308 4324 4308 4320 4320 4308 4316 4311 4323 4320 32 4327 4323 4312 46 32 4311 4308 32 4324 4323 4311 4308 4316 4311 32 4315 4317 4314 4314 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4309 4312 4321 46 32 4309 4312 4315 32 4307 4308 4316 4312 4327 4323 4308 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4311 4336 4308 4317 4324 4336 4320 4304 4321 4311 4323 4321 32 4308 4334 44 32 4308 4304 32 4336 4304 4321 32 4309 4317 4314 4323 4315 4323 4321 32 4324 4304 4321 4311 4312 4307 4312 4312 32 4307 4308 4321 4308 4320 4323 4316 4311 46 32 4308 4334 32 4317 4324 4324 4312 4330 4312 4312 4321 32 4311 4317 4320 4327 4323 4304 4311 4317 4321 32 4315 4308 4312 44 32 4307 4317 4330 4311 4323 4321 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4312 4316 32 4327 4323 4317 46 32 4321 4323 4315 4315 4317 32 4311 4320 4304 4330 4311 4304 4311 4317 4321 32 4308 4312 32 4312 4323 4321 44 32 4323 4311 32 4317 4315 4316 4308 4321 32 4309 4312 4320 4311 4323 4311 4308 32 4307 4308 4311 4320 4304 4334 4312 4311 46) asWordArray.
e displayUtf32: utf32 from: 1 to: utf32 size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"
"
| e f utf8a utf8b utf8c utf32a utf32b utf32c |
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf8a := #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32 105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ].
utf8b := #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97	].
utf8c := #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 105 195 173 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97 105 105 204 129 	].
utf32a := #(105 105 769 32 105 768 32 105 770 32 105 771 32 105 772 32 105 773 32 105 774 32 105 775 32 105 776 32 105 777) asWordArray.
utf32b :=  #(97 233 97 232 97 241 97 209 252 64 97 101 769 97 101 768 97 110 771 97 78 771 117 776 97) asWordArray.
utf32c :=  #(97 233 97 232 97 241 97 209 252 105 237 64 97 101 769 97 101 768 97 110 771 97 78 771 117 776 97 105 105 769) asWordArray.
e displayUtf8: utf8a fromByte: 1 toByte: utf8a size at: 10@120 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e displayUtf32: utf32a from: 1 to: utf32a size at: 10@220 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e displayUtf8: utf8b fromByte: 1 toByte: utf8b size at: 10@320 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e displayUtf32: utf32b from: 1 to: utf32b size at: 10@420 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e displayUtf8: utf8c fromByte: 1 toByte: utf8c size at: 10@520 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e displayUtf32: utf32c from: 1 to: utf32c size at: 10@620 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsTop boundsBottom numContours numBeziers x y cx cy contourStart deltaXToCenter deltaXForBaseGlyph deltaXForDiacriticalMark baseBoundsTop deltaYForDiacriticalMark |
	deltaXForBaseGlyph := 0.0.
	baseBoundsTop := 0.
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		startIndex to: stopIndex do: [ :utf32Index | | utf32 utf8Byte1 uft8Byte2 utf8Byte3 utf8Byte4 i |
			utf32 := aWordArray at: utf32Index.
			
			"$i followed by a Combining Diacritical Mark is replaced by CodePoint 16r131 Dotless i
			This should also be done for VectorEngineWithPlugin"
			(utf32 = 16r69 and: [ utf32Index < stopIndex ] and: [
				(aWordArray at: utf32Index+1) between: 16r300 and: 16r36F ])
					ifTrue: [ utf32 := 16r131 ].
			
			utf32 <= 16r7F
				ifTrue: [
					utf8Byte1 := utf32.
					i := contourDataIndexes at: utf8Byte1 + 1 ]
				ifFalse: [ utf32 <= 16r7FF
				ifTrue: [
					utf8Byte1 := (utf32 bitShift: -6) bitOr: 2r11000000.
					uft8Byte2 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1 ]
				ifFalse: [ utf32 <= 16rFFFF
				ifTrue: [
					utf8Byte1 := (utf32 bitShift: -12) bitOr: 2r11100000.
					uft8Byte2 := ((utf32 bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte3 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1.
					i := contourDataIndexes at: utf8Byte3 - i + 1 ]
				ifFalse: [
					utf8Byte1 := (utf32 bitShift: -18) bitOr: 2r11110000.
					uft8Byte2 := ((utf32 bitShift: -12) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte3 := ((utf32 bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte4 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1.
					i := contourDataIndexes at: utf8Byte3 - i + 1.
					i := contourDataIndexes at: utf8Byte4 - i + 1 ]]].
			advanceWidth := contourData at: i. i := i + 1.
			boundsLeft := contourData at: i. i := i + 1.
			boundsRight := contourData at: i. i := i + 1.
			boundsBottom := contourData at: i. i := i + 1.
			boundsTop := contourData at: i. i := i + 1.
			numContours := (contourData at: i) asInteger. i := i + 1.
			
			"TrueType doesn't speciy how to position diacritics wrt base character glyph.
			Horizontally center diacriticals wrt base glyph.
			See
				basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
				formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
				displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
			This should also be done for VectorEngineWithPlugin
			Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
			deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
			utf32 = 16r300 ifTrue: [	"Combining Grave Accent"
				deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
			utf32 = 16r301 ifTrue: [ 	"Combining Acute Accent"
				deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ].
			"DoubleWidth code points that combine above previous and following characters.
			Codepoints between 16r035C and 16r0363.
			Example: o͢o
			Don't center them"
			(utf32 between: 16r035C and: 16r0363) ifTrue: [
				deltaXToCenter := 0.0 ].
					
			deltaXForDiacriticalMark := 0.0.
			deltaYForDiacriticalMark := 0.
			advanceWidth = 0.0
				ifFalse: [ "Regular glyph"
					deltaXForBaseGlyph := deltaXToCenter.
					baseBoundsTop := boundsTop ]
				ifTrue: [ "Diacritical mark"
					deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
						ifFalse: [
							deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
							baseBoundsTop > boundsBottom ifTrue: [
								deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
			nextGlyphX := nextGlyphX + deltaXForDiacriticalMark.
			
			numContours timesRepeat: [
				numBeziers := (contourData at: i) asInteger. i := i + 1.
				ttMoveToX := contourData at: i. i := i + 1.
				ttMoveToY := contourData at: i. i := i + 1.
				x := ttMoveToX * sx + nextGlyphX.
				y := ttMoveToY * sy + nextGlyphY + deltaYForDiacriticalMark.
				contourStart := x@y.
				self moveTo: contourStart.
				numBeziers timesRepeat: [
					ttEndX := contourData at: i. i := i + 1.
					ttEndY := contourData at: i. i := i + 1.
					ttControlX := contourData at: i. i := i + 1.
					ttControlY := contourData at: i. i := i + 1.
					cx := ttControlX * sx + x.
					cy := ttControlY * sy + y.
					x := ttEndX * sx + x.
					y := ttEndY * sy + y.
					self quadraticBezierTo: x@y control: cx@cy ].
				self lineTo: contourStart ].
			nextGlyphX := nextGlyphX + (advanceWidth * sx) - deltaXForDiacriticalMark ]].
	^ nextGlyphX@nextGlyphY! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 3/21/2025 11:57:39' prior: 50361581!
                            displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours numBeziers baseIndex x y cx cy contourStart deltaXToCenter deltaXForBaseGlyph deltaXForDiacriticalMark baseBoundsTop deltaYForDiacriticalMark byte1 byte2OrNil |
	deltaXForBaseGlyph := 0.0.
	baseBoundsTop := 0.
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	byte1 := nil.
	byte2OrNil := nil.
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		baseIndex := 0.
		byteStartIndex to: byteStopIndex do: [ :byteIndex | | byte i |
			byte := aByteArray at: byteIndex.
			byte1 isNil ifTrue: [byte1 := byte ] ifFalse: [ byte2OrNil isNil ifTrue: [ byte2OrNil := byte ]].
			i := contourDataIndexes at: baseIndex + byte + 1.
			
			"$i followed by a Combining Diacritical Mark is replaced by CodePoint 305 Dotless i, UTF-8 #[196 177]
			(UnicodeString fromUtf8Bytes: #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32
				105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ]) edit
			This should also be done for VectorEngineWithPlugin"
			(byte1 = 105 and: [ byteIndex < (byteStopIndex-1) ] and: [
				(aByteArray at: byteIndex+1) = 204 or: [ (aByteArray at: byteIndex+1) = 205 and: [ (aByteArray at: byteIndex+2) < 176 ]]])
					ifTrue: [
						i := contourDataIndexes at: 196 + 1.
						i := contourDataIndexes at: i negated + 177 + 1 ].
			
			i < 0
				ifTrue: [ baseIndex := i negated ]
				ifFalse: [
					advanceWidth := contourData at: i. i := i + 1.
					boundsLeft := contourData at: i. i := i + 1.
					boundsRight := contourData at: i. i := i + 1.
					boundsBottom := contourData at: i. i := i + 1.
					boundsTop := contourData at: i. i := i + 1.
					numContours := (contourData at: i) asInteger. i := i + 1.
					"TrueType doesn't speciy how to position diacritics wrt base character glyph.
					Horizontally center diacriticals wrt base glyph.
					See
						basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
						formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
						displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
					This should also be done for VectorEngineWithPlugin
					Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
					deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
					byte1 = 204 ifTrue: [
						byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
							deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
						byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
							deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ]].
					"DoubleWidth code points that combine above previous and following characters.
					Codepoints between 16r035C and 16r0363.
					Example: o͢o
					Don't center them"
					(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
						deltaXToCenter := 0.0 ].
					
					deltaXForDiacriticalMark := 0.0.
					deltaYForDiacriticalMark := 0.
					advanceWidth = 0.0
						ifFalse: [ "Regular glyph"
							deltaXForBaseGlyph := deltaXToCenter.
							baseBoundsTop := boundsTop ]
						ifTrue: [ "Diacritical mark"
							deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
								ifFalse: [
									deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
									baseBoundsTop > boundsBottom ifTrue: [
										deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
					nextGlyphX := nextGlyphX + deltaXForDiacriticalMark.
					
					numContours timesRepeat: [
						numBeziers := (contourData at: i) asInteger. i := i + 1.
						ttMoveToX := contourData at: i. i := i + 1.
						ttMoveToY := contourData at: i. i := i + 1.
						x := ttMoveToX * sx + nextGlyphX.
						y := ttMoveToY * sy + nextGlyphY + deltaYForDiacriticalMark.
						contourStart := x@y.
						self moveTo: contourStart.
						numBeziers timesRepeat: [
							ttEndX := contourData at: i. i := i + 1.
							ttEndY := contourData at: i. i := i + 1.
							ttControlX := contourData at: i. i := i + 1.
							ttControlY := contourData at: i. i := i + 1.
							cx := ttControlX * sx + x.
							cy := ttControlY * sy + y.
							x := ttEndX * sx + x.
							y := ttEndY * sy + y.
							self quadraticBezierTo: x@y control: cx@cy ].
						self lineTo: contourStart ].
					nextGlyphX := nextGlyphX + (advanceWidth * sx) - deltaXForDiacriticalMark.
					baseIndex := 0.
					byte1 := nil.
					byte2OrNil := nil ]]].
	^ nextGlyphX@nextGlyphY! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7197-SmalltalkEngine-centeringOfDiacritics-JuanVuletich-2025Mar21-12h46m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7090] on 21 March 2025 at 3:37:48 pm'!
!VectorEngineWithPluginWholePixel commentStamp: 'jmv 3/21/2025 14:43:23' prior: 50365516!
                         Does only whole pixel antialiasing. Appropriate for very high resolution displays, or slower systems where the extra computational load of VectorEngineWithPluginSubPixel is not affordable.
Variables edgeCounts and alphaMask are single byte per pixel.

Uses VectorEnginePlugin for performance.!
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 15:23:35'!
      primCurrentMorphId: aNumber
	<primitive: 'primCurrentMorphId' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 14:59:58'!
              primDisplayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primDisplayByteString' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 14:38:02'!
             primDisplayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primDisplayUtf32' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 14:38:20'!
                    primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primDisplayUtf8' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 15:00:17'!
    primDisplayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primDisplayByteStringWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 14:38:07'!
         primDisplayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primDisplayUtf32WP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 14:38:26'!
                primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primDisplayUtf8WP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!Morph methodsFor: 'drawing' stamp: 'jmv 3/21/2025 14:54:35' prior: 50369744!
                  imageFormVG: extentOrNil depth: depth
	"Draw using a VectorCanvas
	Scale as needed. Draw unrotated."

	| prevNotVisibleFlag bounds extent fauxLocation answer auxCanvas |
	"Position and scale us in order to fill required extent, but disregard any rotation.
	Do it without triggering any invalidation at all."
	prevNotVisibleFlag := self privateFlagAt: 3.
	[
		bounds := self findFullBoundsInOwner.
		extentOrNil
			ifNotNil: [ | scale |
				extent := extentOrNil.
				scale := extent x asFloat / bounds width min: extent y asFloat / bounds height.
				fauxLocation := AffineTransformation withScale: scale position: bounds origin negated +1 * scale ]
			ifNil: [
				extent := bounds extent.
				fauxLocation := MorphicTranslation withTranslation: bounds origin negated ].
		answer := Form extent: extent depth: 32.
		auxCanvas := VectorCanvas onForm: answer.
		auxCanvas engine enableTargetTranslucency.
		auxCanvas geometryTransformation: fauxLocation.
		depth = 32 ifFalse: [
			"Only 32 bpp can hold translucent anti aliasing over transparent background"
			answer fillColor: Color veryLightGray ].
		self privateFlagAt: 3 put: false.
		auxCanvas fullDraw: self.
	] ensure: [
		self privateFlagAt: 3 put: prevNotVisibleFlag ].
	^answer asFormOfDepth: depth.! !
!Morph methodsFor: 'geometry services' stamp: 'jmv 3/21/2025 14:54:24' prior: 50365597!
                        bitMask
	"Answer an 1bpp Form with our bitMask.
	Include all pixels drawn by any morph in our submorphs tree.
	Query with #pixelValueAt:
	Pixels drawn by us (or any submorph) are 0. Pixels not drawn by us (or any submorph) are 1.
	Remember to do `self removeProperty: #bitMask when appropriate!!
	(i.e. when we change in such a way to make the bitMask invalid)
	
	Also see senders of #contour"

	| prevNotVisibleFlag bounds answer auxCanvas |

	(self valueOfProperty: #bitMask) ifNotNil: [ :bitMask |
		^bitMask ].

	"Position and scale us in order to fill required extent, but disregard any rotation.
	Do it without triggering any invalidation at all."
	prevNotVisibleFlag := self privateFlagAt: 3.
	bounds := self findFullBoundsInOwner.
	[
		answer := Form extent: bounds extent depth: 32.
		auxCanvas := VectorCanvas onForm: answer translation: bounds origin negated.
		auxCanvas engine enableTargetTranslucency.
		self privateFlagAt: 3 put: false.
		auxCanvas fullDraw: self.
	] ensure: [
		self privateFlagAt: 3 put: prevNotVisibleFlag ].
	^self setProperty: #bitMask toValue:
		"Reverse it so we get bit=1 for affected pixels."
		((answer asGrayForm: 1) asFormOfDepth: 1) reverse.! !
!VectorEngineBoundsFinder methodsFor: 'private' stamp: 'jmv 3/21/2025 15:21:18' prior: 17001527 overrides: 17000856!
     initializePath

	super initializePath.

	spanTop := 16r3FFFFFFF.				"drawable bottom. Will later be refined."
	spanBottom := 0.					"drawable top. Will later be refined."
	spanLeft := 16r3FFFFFFF.				"drawable right. Will later be refined."
	spanRight := 0.						"drawable left. Will later be refined."! !
!VectorEngineSmalltalk methodsFor: 'private' stamp: 'jmv 3/21/2025 15:20:57' prior: 17002440 overrides: 17000856!
                            initializePath

	super initializePath.

	spanTop := targetHeight.				"drawable bottom. Will later be refined."
	spanBottom := 0.					"drawable top. Will later be refined."
	spanLeft := targetWidth.				"drawable right. Will later be refined."
	spanRight := 0.						"drawable left. Will later be refined."
	prevYRounded := 16r3FFFFFFF.! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 3/21/2025 14:37:19' prior: 50361351 overrides: 50377204!
               displayByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try BOTH!!'.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.'.
e displayByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale asFloat.
	sy := scale * trueTypeScale asFloat.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	 "Should use a specific table with 256 entries"
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8. "Should use a specific table with 256 entries"
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayByteString: aString from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
			edgeCounts: edgeCounts
			alphaMask: alphaMask
		].
	^ nextGlyphX @ nextGlyphY! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 3/21/2025 14:38:09' prior: 50361416 overrides: 50377302!
     displayUtf32: aWordArray from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f utf32 |
'Try BOTH!!'.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf32 _ #(4314 4317 4320 4308 4315 32 4312 4324 4321 4323 4315 32 4307 4317 4314 4317 4320 32 4321 4312 4311 32 4304 4315 4308 4311 44 32 4327 4323 4317 32 4323 4311 32 4307 4312 4330 4304 4311 32 4304 4314 4312 4327 4323 4312 4307 44 32 4304 4307 32 4314 4312 4305 4320 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4320 4308 4324 4320 4308 4336 4308 4316 4307 4323 4316 4311 32 4308 4321 4311 46 32 4314 4308 4306 4308 4320 4308 32 4330 4317 4320 4324 4317 4320 4304 32 4308 4324 4324 4312 4330 4312 4304 4316 4311 4323 4320 32 4304 4311 32 4308 4304 4315 44 32 4316 4317 32 4327 4323 4304 4321 32 4315 4308 4316 4304 4316 4307 4320 4312 32 4320 4308 4324 4308 4320 4320 4308 4316 4311 4323 4320 32 4327 4323 4312 46 32 4311 4308 32 4324 4323 4311 4308 4316 4311 32 4315 4317 4314 4314 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4309 4312 4321 46 32 4309 4312 4315 32 4307 4308 4316 4312 4327 4323 4308 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4311 4336 4308 4317 4324 4336 4320 4304 4321 4311 4323 4321 32 4308 4334 44 32 4308 4304 32 4336 4304 4321 32 4309 4317 4314 4323 4315 4323 4321 32 4324 4304 4321 4311 4312 4307 4312 4312 32 4307 4308 4321 4308 4320 4323 4316 4311 46 32 4308 4334 32 4317 4324 4324 4312 4330 4312 4312 4321 32 4311 4317 4320 4327 4323 4304 4311 4317 4321 32 4315 4308 4312 44 32 4307 4317 4330 4311 4323 4321 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4312 4316 32 4327 4323 4317 46 32 4321 4323 4315 4315 4317 32 4311 4320 4304 4330 4311 4304 4311 4317 4321 32 4308 4312 32 4312 4323 4321 44 32 4323 4311 32 4317 4315 4316 4308 4321 32 4309 4312 4320 4311 4323 4311 4308 32 4307 4308 4311 4320 4304 4334 4312 4311 46) asWordArray.
e displayUtf32: utf32 from: 1 to: utf32 size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen."

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayUtf32: aWordArray from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
			edgeCounts: edgeCounts
			alphaMask: alphaMask
		].
	^ nextGlyphX @ nextGlyphY! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 3/21/2025 14:38:34' prior: 17004096 overrides: 50377613!
                             displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
			edgeCounts: edgeCounts
			alphaMask: alphaMask
		].
	^ nextGlyphX @ nextGlyphY! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 3/21/2025 15:23:45' prior: 50373906 overrides: 17000856!
                         initializePath

	super initializePath.

	"Set all plugin state. There might be several instances of this class, all using the same plugin.
	Only one of them will use the plugin during a path draw operation. See class variable AccessLock."
	self
		primTargetBits: targetForm bits
		morphIds: morphIds
		edgeCounts: edgeCounts
		alphaMask: alphaMask
		contour: contour
		targetWidth: targetWidth
		targetHeight: targetHeight.
	self
		primAntiAliasingWidth: antiAliasingWidth asFloat
		subPixelDelta: self subPixelDelta asFloat
		hopLength: hop asFloat.
	self primClipLeft: clipLeft clipTop: clipTop clipRight: clipRight clipBottom: clipBottom.
	self primCurrentMorphId: currentMorphId.
	self
		primGeometryTxA11: geometryTransformation a11 asFloat
		a12: geometryTransformation a12 asFloat
		a13: geometryTransformation a13 asFloat
		a21: geometryTransformation a21 asFloat
		a22: geometryTransformation a22 asFloat
		a23: geometryTransformation a23 asFloat.
	self primStrokeWidth: strokeWidth.
	self primStrokeColor: strokeColor.
	self primFillColor: fillColor.

	self primInitializePath.! !
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 14:59:29' prior: 50362638!
                         primResetContourTop: t bottom: b contour: aFloat32Array
	<primitive: 'primResetContour' module: 'VectorEnginePlugin'>
	self primitiveFailed.! !
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 14:59:42' prior: 50362646!
            primUpdateContourLastLine: aFloat32Array
	<primitive: 'primUpdateContourLastLine' module: 'VectorEnginePlugin'>
	self primitiveFailed.! !
!VectorEngineWithPlugin class methodsFor: 'private' stamp: 'jmv 3/21/2025 14:58:53' prior: 17004719!
                 pluginApiVersion
	"
	VectorEngineWithPlugin isPluginAvailable
	Note: this is Api version, not package version. If no Api change, Api version doesn't change, regardless of changes in the Plugin or Smalltalk code.
	See senders and implementors.
	"
	<primitive: 'pluginApiVersion' module: 'VectorEnginePlugin'>

	^ 0! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 14:42:38' prior: 17005009!
                     primBlendFillOnlyLeft: l top: t right: r bottom: b targetBits: aBitmap morphIds: aWordArray edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primBlendFillOnlyWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 14:42:42' prior: 17005020!
    primBlendStrokeAndFillLeft: l top: t right: r bottom: b targetBits: aBitmap morphIds: aWordArray edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primBlendStrokeAndFillWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 3/21/2025 14:42:47' prior: 17005031!
                          primBlendStrokeOnlyLeft: l top: t right: r bottom: b targetBits: aBitmap morphIds: aWordArray alphaMask: anotherByteArray
	<primitive: 'primBlendStrokeOnlyWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !

VectorEngineWithPluginWholePixel removeSelector: #primDisplayByteString:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginWholePixel #primDisplayByteString:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: stamp: 'Install-7198-UpdatesForPluginApiV7-JuanVuletich-2025Mar21-14h37m-jmv.002.cs.st 5/24/2025 10:43:13'!
primDisplayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes useST80Glyphs: aBoolean edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primDisplayStringWP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primDisplayUtf32:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginWholePixel #primDisplayUtf32:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: stamp: 'Install-7198-UpdatesForPluginApiV7-JuanVuletich-2025Mar21-14h37m-jmv.002.cs.st 5/24/2025 10:43:13'!
primDisplayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes useST80Glyphs: aBoolean edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primDisplayUtf32WP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primDisplayUtf8:fromByte:toByte:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginWholePixel #primDisplayUtf8:fromByte:toByte:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: stamp: 'Install-7198-UpdatesForPluginApiV7-JuanVuletich-2025Mar21-14h37m-jmv.002.cs.st 5/24/2025 10:43:13'!
primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes useST80Glyphs: aBoolean edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primDisplayUtf8WP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primDisplayByteString:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginSubPixel #primDisplayByteString:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: stamp: 'Install-7198-UpdatesForPluginApiV7-JuanVuletich-2025Mar21-14h37m-jmv.002.cs.st 5/24/2025 10:43:13'!
primDisplayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes useST80Glyphs: aBoolean edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primDisplayString' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primDisplayUtf32:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginSubPixel #primDisplayUtf32:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: stamp: 'Install-7198-UpdatesForPluginApiV7-JuanVuletich-2025Mar21-14h37m-jmv.002.cs.st 5/24/2025 10:43:13'!
primDisplayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes useST80Glyphs: aBoolean edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primDisplayUtf32' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primDisplayUtf8:fromByte:toByte:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginSubPixel #primDisplayUtf8:fromByte:toByte:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: stamp: 'Install-7198-UpdatesForPluginApiV7-JuanVuletich-2025Mar21-14h37m-jmv.002.cs.st 5/24/2025 10:43:13'!
primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes useST80Glyphs: aBoolean edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primDisplayUtf8' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPlugin removeSelector: #primClipCurrentMorph:morphIds:!

!methodRemoval: VectorEngineWithPlugin #primClipCurrentMorph:morphIds: stamp: 'Install-7198-UpdatesForPluginApiV7-JuanVuletich-2025Mar21-14h37m-jmv.002.cs.st 5/24/2025 10:43:13'!
primClipCurrentMorph: aBoolean morphIds: aWordArray
	<primitive: 'primClipCurrentMorph' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPlugin removeSelector: #primCurrentMorphId:currentClipsSubmorphs:!

!methodRemoval: VectorEngineWithPlugin #primCurrentMorphId:currentClipsSubmorphs: stamp: 'Install-7198-UpdatesForPluginApiV7-JuanVuletich-2025Mar21-14h37m-jmv.002.cs.st 5/24/2025 10:43:13'!
primCurrentMorphId: aNumber currentClipsSubmorphs: aBoolean
	<primitive: 'primCurrentMorphIdcurrentClipsSubmorphs' module: 'VectorEnginePlugin'>

	self primitiveFailed!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7198-UpdatesForPluginApiV7-JuanVuletich-2025Mar21-14h37m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7092] on 27 March 2025 at 11:34:30 am'!
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 3/27/2025 11:21:52'!
                            primTargetAssumedOpaque: aBoolean
	<primitive: 'primTargetAssumedOpaque' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 3/27/2025 11:32:56' prior: 50378228 overrides: 17000856!
            initializePath

	super initializePath.

	"Set all plugin state. There might be several instances of this class, all using the same plugin.
	Only one of them will use the plugin during a path draw operation. See class variable AccessLock."
	self
		primTargetBits: targetForm bits
		morphIds: morphIds
		edgeCounts: edgeCounts
		alphaMask: alphaMask
		contour: contour
		targetWidth: targetWidth
		targetHeight: targetHeight.
	self primTargetAssumedOpaque: targetAssumedOpaque.
	self
		primAntiAliasingWidth: antiAliasingWidth asFloat
		subPixelDelta: self subPixelDelta asFloat
		hopLength: hop asFloat.
	self primClipLeft: clipLeft clipTop: clipTop clipRight: clipRight clipBottom: clipBottom.
	self primCurrentMorphId: currentMorphId.
	self
		primGeometryTxA11: geometryTransformation a11 asFloat
		a12: geometryTransformation a12 asFloat
		a13: geometryTransformation a13 asFloat
		a21: geometryTransformation a21 asFloat
		a22: geometryTransformation a22 asFloat
		a23: geometryTransformation a23 asFloat.
	self primStrokeWidth: strokeWidth.
	self primStrokeColor: strokeColor.
	self primFillColor: fillColor.

	self primInitializePath.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7199-UpdatesForPluginApiV7-JuanVuletich-2025Mar27-11h21m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7092] on 27 March 2025 at 8:38:44 am'!
!Sample01Star methodsFor: 'drawing' stamp: 'jmv 3/21/2025 17:36:27' prior: 50374425 overrides: 16905026!
                     drawOn: aCanvas
	"A 5 point star.
	Feel free to experiment with this code.
	The worst thing that could happen is that your morph breaks. That will only mean extra fun!!
	Sample01Star new openInHand
	"

	aCanvas strokeWidth: 12 color: `Color lightOrange` do: [
	"aCanvas fillColor: Color lightOrange do: ["
	"aCanvas strokeWidth: 12 color: Color lightOrange fillColor: Color yellow do: ["
		aCanvas
				moveTo: `(Point rho: 100 theta: 90 degreesToRadians)`;
				lineTo: `(Point rho: 100 theta: (360/5*2+90) degreesToRadians)`;
				lineTo: `(Point rho: 100 theta: (360/5*4+90) degreesToRadians)`;
				lineTo: `(Point rho: 100 theta: (360/5*6+90) degreesToRadians)`;
				lineTo: `(Point rho: 100 theta: (360/5*8+90) degreesToRadians)`;
				lineTo: `(Point rho: 100 theta: 90 degreesToRadians)`.
		].! !
!Sample02Bezier methodsFor: 'drawing' stamp: 'jmv 3/21/2025 17:46:23' prior: 50361000 overrides: 16905026!
                     drawOn: aCanvas
	"Two Bezier curves. A Quadratic one (with start, end and a single control point), and a Cubic one (with start, end, and two control points)
	Sample02Bezier new openInHand
	"

	aCanvas strokeWidth: 2 color: `Color green` strokeDashArray: #(10 10) strokeDashArrayOffset: dashOffset do: [
		aCanvas
				moveTo: aStart;
				quadraticBezierTo: aEnd control: aControlPoint ].
	aCanvas strokeWidth: 1 color: `Color darkGray` strokeDashArray: #(1 3) strokeDashArrayOffset: Random next * 4 do: [
		aCanvas
				moveTo: aStart;
				lineTo: aControlPoint;
				lineTo: aEnd ].

	aCanvas strokeWidth: 3 color: `Color red` strokeDashArray: #(10 35) strokeDashArrayOffset: dashOffset do: [
		aCanvas
				moveTo: bStart;
				cubicBezierTo: bEnd control1: bControlPoint1 control2: bControlPoint2 ].
	aCanvas strokeWidth: 1 color: `Color darkGray` strokeDashArray: #(15 8) strokeDashArrayOffset: dashOffset do: [
		aCanvas
				moveTo: bStart;
				lineTo: bControlPoint1;
				lineTo: bControlPoint2;
				lineTo: bEnd ].! !
!Sample03Smiley methodsFor: 'drawing' stamp: 'jmv 3/21/2025 17:35:40' prior: 16945614 overrides: 16905026!
                         drawOn: aCanvas
	"Example of the #pathSequence drawing operation, that can represent many drawing operations
			in one compact literal, and draw them at once.
	0.0		x	y									Move pen to position x@y
	1.0		x	y									Draw a line to position x@y
	2.0		toX	toY	controlX		controlY						Draw a Quadratic Bezier Curve
	3.0		toX	toY	control1X	control1Y			control2X	control2Y			Draw a Cubic Bezier Curve
	See #circleApproximationExamples
	Sample03Smiley new openInHand
	"

	aCanvas strokeWidth: 30 color: `Color gray` fillColor: `Color lightGreen duller` do: [
		aCanvas
				pathSequence: `#[
					0.0  150.0  150.0
					3.0  300.0  300.0  150.0  233.0  217.0  300.0
					3.0  450.0  150.0  380.3  300.0  450.0  233.0
					3.0  300.0  0.0      450.0  67.0    383.0  0.0
					3.0  150.0  150.0  210.7  0.0      150.0  67.0
					] asFloat32Array`
		].

	aCanvas strokeWidth: 30 color: `Color gray` do: [
		aCanvas
				pathSequence: `#[
					0.0 220.0 190.0
					2.0 300.0 240.0 245.0 240.0
					2.0 380.0 190.0 355.0 240.0
					0.0 250.0 100.0
					1.0 250.0 120.0
					0.0 350.0 100.0
					1.0 350.0 120.0
					] asFloat32Array`
		].! !
!Sample04Pacman methodsFor: 'drawing' stamp: 'jmv 3/21/2025 17:47:22' prior: 16945678 overrides: 16905026!
         drawOn: aCanvas

	aCanvas fillColor: color do: [
		aCanvas circleCenter: `30@60` radius: 15.
		aCanvas
			moveTo: `0@0`;
			lineTo: `100@ -50`;
			arcTo: `100@ 50` radius: 110 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			lineTo: `0@0`.
		].! !
!Sample07Clipping methodsFor: 'drawing' stamp: 'jmv 3/21/2025 17:48:13' prior: 16945797 overrides: 16905026!
                        drawOn: aCanvas

	aCanvas strokeWidth: 15 color: `Color green darker` fillColor: `Color red darker` do: [
		aCanvas
			roundRectangleMinX: -10 maxX: 220 minY: -10 maxY: 120  rx: 120 ry: 50 ]! !
!Sample09Clock methodsFor: 'drawing' stamp: 'jmv 3/21/2025 17:33:11' prior: 16945864 overrides: 16905026!
                    drawOn: aCanvas

	| f |
	aCanvas
		strokeWidth: 10 color: `Color lightCyan`
		fillColor: `Color veryVeryLightGray lighter` do: [ :canvas |
			canvas circleCenter:  0@0 radius: 100 ].
	f := FontFamily familyName: 'DejaVu Sans' pointSize: 14.
	aCanvas drawString: 'XII' at: `-13 @ 58` font: f color: `Color brown`.
	aCanvas drawString: 'III' at: `73 @ -24` font: f color: `Color brown`.
	aCanvas drawString: 'VI' at: `-9 @ -106` font: f color: `Color brown`.
	aCanvas drawString: 'IX' at: `-90 @ -24` font: f color: `Color brown`.

	f := FontFamily familyName: 'Alex Brush' pointSize: 16.
	aCanvas drawString: 'Chaque Heure' atCenterX: `0@ 18` font: f color: `Color black`.
	f := FontFamily familyName: 'Alex Brush' pointSize: 8.
	aCanvas drawString: 'pour la Minorie' atCenterX: `0@ -60` font: f color: `Color black`.! !
!Sample09ClockHourHand methodsFor: 'drawing' stamp: 'jmv 3/21/2025 17:34:17' prior: 16945931 overrides: 16905026!
                          drawOn: aCanvas

	aCanvas fillColor: `Color darkGray` do: [
		aCanvas
			moveTo: `0 @ 10`;
			lineTo: `-5 @ 0`;
			lineTo: `0 @ -50`;
			lineTo: `5 @ 0`;
			lineTo: `0 @ 10` ].! !
!Sample09ClockMinuteHand methodsFor: 'drawing' stamp: 'jmv 3/21/2025 17:35:01' prior: 16945950 overrides: 16905026!
                        drawOn: aCanvas

	aCanvas fillColor: `Color darkGray` do: [
		aCanvas
			moveTo: `0 @ 8`;
			lineTo: `-4 @ 0`;
			lineTo: `0 @ -82`;
			lineTo: `4 @ 0`;
			lineTo: `0 @ 8` ].! !
!Sample09ClockSecondHand methodsFor: 'drawing' stamp: 'jmv 3/21/2025 17:35:13' prior: 16945969 overrides: 16905026!
                          drawOn: aCanvas

	aCanvas strokeWidth: 3.5 color: Color red do: [
		aCanvas
			moveTo: `0 @ 0`;
			lineTo: `0 @ -85` ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7200-SampleMorphsTweaks-JuanVuletich-2025Mar27-08h36m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7086] on 18 March 2025 at 4:21:44 pm'!
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 3/18/2025 16:14:34' prior: 17004152 overrides: 17000845!
          doPath: pathCommandsBlock ensureClosePath: ensureClosePath
	"Evaluate a sequence of path commands. Path parameters already set.
	VectorEnginePlugin is not reentrant.
	- Any other process must wait.
	- Nested calls in the same process are not supported, and ignored."

	self class protected: [
		super doPath: pathCommandsBlock ensureClosePath: ensureClosePath ].! !

VectorEngineWithPluginWholePixel removeSelector: #dashedStroke_doPath:ensureClosePath:!

!methodRemoval: VectorEngineWithPluginWholePixel #dashedStroke_doPath:ensureClosePath: stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_doPath: pathCommandsBlock ensureClosePath: ensureClosePath
	"Ask a VectorEngineSmalltalk for help"


	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	self class protected: [ | smalltalkVGE |
		self initializePath.
		smalltalkVGE := VectorEngineWholePixel new dashedStroke_ToFollow: self.
		smalltalkVGE initializePath.
		canvas instVarNamed: 'engine' put: smalltalkVGE.
		pathCommandsBlock valueWithPossibleArgument: (canvas ifNil:[smalltalkVGE]).
		self dashedStroke_finishPath: ensureClosePath smalltalkVGE: smalltalkVGE.
		canvas instVarNamed: 'engine' put: self.
		].
!

VectorEngineWithPluginSubPixel removeSelector: #dashedStroke_doPath:ensureClosePath:!

!methodRemoval: VectorEngineWithPluginSubPixel #dashedStroke_doPath:ensureClosePath: stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_doPath: pathCommandsBlock ensureClosePath: ensureClosePath
	"Ask a VectorEngineSmalltalk for help"


	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	self class protected: [ | smalltalkVGE |
		self initializePath.
		smalltalkVGE := VectorEngineSubPixel new dashedStroke_ToFollow: self.
		smalltalkVGE initializePath.
		canvas instVarNamed: 'engine' put: smalltalkVGE.
		pathCommandsBlock valueWithPossibleArgument: (canvas ifNil:[smalltalkVGE]).
		self dashedStroke_finishPath: ensureClosePath smalltalkVGE: smalltalkVGE.
		canvas instVarNamed: 'engine' put: self.
		].
!

VectorEngineWithPlugin removeSelector: #dashedStroke_clipBottom!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_clipBottom stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_clipBottom

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^clipBottom!

VectorEngineWithPlugin removeSelector: #dashedStroke_contour!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_contour stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_contour

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^contour!

VectorEngineWithPlugin removeSelector: #dashedStroke_edgeCounts!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_edgeCounts stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_edgeCounts

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^edgeCounts!

VectorEngineWithPlugin removeSelector: #dashedStroke_clipLeft!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_clipLeft stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_clipLeft

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^clipLeft!

VectorEngineWithPlugin removeSelector: #dashedStroke_finishPath:smalltalkVGE:!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_finishPath:smalltalkVGE: stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_finishPath: ensureClosePath smalltalkVGE: smalltalkVGE
	"Blend stroke and/or fill over background, according to the just computed pen alphas (distance from pixel to center of stroke)"
	| spanLeft spanTop spanRight spanBottom |

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.

	smalltalkVGE dashedStroke_finishPath: ensureClosePath.

	spanLeft := smalltalkVGE dashedStroke_spanLeft.
	spanTop := smalltalkVGE dashedStroke_spanTop.
	spanRight := smalltalkVGE dashedStroke_spanRight.
	spanBottom := smalltalkVGE dashedStroke_spanBottom.

	"morphBounds is not affected by clipRect"
	morphBoundsLeft := morphBoundsLeft min: spanLeft.
	morphBoundsTop := morphBoundsTop min: spanTop.
	morphBoundsRight := morphBoundsRight max: spanRight.
	morphBoundsBottom := morphBoundsBottom max: spanBottom.

	spanLeft< clipLeft ifTrue: [ spanLeft := clipLeft ].
	spanTop < clipTop ifTrue: [ spanTop := clipTop ].
	spanRight > clipRight ifTrue: [ spanRight := clipRight ].
	spanBottom > clipBottom ifTrue: [ spanBottom := clipBottom ].

	(spanRight >= spanLeft and: [ spanBottom >= spanTop ]) ifTrue: [
		fillColor notNil ifTrue: [
			strokeColor notNil
				ifTrue: [ self primBlendStrokeAndFillLeft: spanLeft top: spanTop right: spanRight bottom: spanBottom targetBits: targetForm bits morphIds: morphIds edgeCounts: edgeCounts alphaMask: alphaMask ]
				ifFalse: [ self primBlendFillOnlyLeft: spanLeft top: spanTop right: spanRight bottom: spanBottom targetBits: targetForm bits morphIds: morphIds edgeCounts: edgeCounts alphaMask: alphaMask ]]
			ifFalse: [
				self primBlendStrokeOnlyLeft: spanLeft top: spanTop right: spanRight bottom: spanBottom targetBits: targetForm bits morphIds: morphIds alphaMask: alphaMask ]].!

VectorEngineWithPlugin removeSelector: #dashedStroke_geometryTransformation!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_geometryTransformation stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_geometryTransformation

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^geometryTransformation!

VectorEngineWithPlugin removeSelector: #dashedStroke_strokeDashArrayLast!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_strokeDashArrayLast stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_strokeDashArrayLast

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^strokeDashArrayLast!

VectorEngineWithPlugin removeSelector: #dashedStroke_strokeDashArray!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_strokeDashArray stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_strokeDashArray

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^strokeDashArray!

VectorEngineWithPlugin removeSelector: #dashedStroke_strokeDashLength!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_strokeDashLength stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_strokeDashLength

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^strokeDashLength!

VectorEngineWithPlugin removeSelector: #dashedStroke_targetForm!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_targetForm stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_targetForm

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^targetForm!

VectorEngineWithPlugin removeSelector: #dashedStroke_clipRight!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_clipRight stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_clipRight

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^clipRight!

VectorEngineWithPlugin removeSelector: #dashedStroke_morphIds!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_morphIds stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_morphIds

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^morphIds!

VectorEngineWithPlugin removeSelector: #dashedStroke_strokeDashArrayOffset!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_strokeDashArrayOffset stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_strokeDashArrayOffset

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^strokeDashArrayOffset!

VectorEngineWithPlugin removeSelector: #dashedStroke_strokeWidth!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_strokeWidth stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_strokeWidth

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^strokeWidth!

VectorEngineWithPlugin removeSelector: #dashedStroke_alphaMask!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_alphaMask stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_alphaMask

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^alphaMask!

VectorEngineWithPlugin removeSelector: #dashedStroke_clipTop!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_clipTop stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_clipTop

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^clipTop!

VectorEngineWithPlugin removeSelector: #dashedStroke_strokeColor!

!methodRemoval: VectorEngineWithPlugin #dashedStroke_strokeColor stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_strokeColor

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	^strokeColor!

VectorEngineWholePixel removeSelector: #dashedStroke_ToFollow:!

!methodRemoval: VectorEngineWholePixel #dashedStroke_ToFollow: stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_ToFollow: aVectorEngineWithPlugin

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	
	self currentMorph: nil.	
	
	"Based on #pvtSetForm:"
	targetForm := aVectorEngineWithPlugin dashedStroke_targetForm.
	targetWidth := targetForm width.
	targetHeight := targetForm height.
	morphIds := aVectorEngineWithPlugin dashedStroke_morphIds.
	edgeCounts := aVectorEngineWithPlugin dashedStroke_edgeCounts.
	alphaMask := aVectorEngineWithPlugin dashedStroke_alphaMask.
	contour := aVectorEngineWithPlugin dashedStroke_contour.
	self resetMorphBounds.
	self antiAliasingWidth: self class defaultAntiAliasingWidth.
	clipLeft := aVectorEngineWithPlugin dashedStroke_clipLeft.
	clipTop := aVectorEngineWithPlugin dashedStroke_clipTop.
	clipRight := aVectorEngineWithPlugin dashedStroke_clipRight.
	clipBottom := aVectorEngineWithPlugin dashedStroke_clipBottom.
	geometryTransformation := aVectorEngineWithPlugin dashedStroke_geometryTransformation.
	
	self pvtStrokeWidth: aVectorEngineWithPlugin dashedStroke_strokeWidth.
	self pvtStrokeColor: aVectorEngineWithPlugin dashedStroke_strokeColor.
	self pvtFillColor: nil.
	self pvtHopLength: 0.5.

	strokeDashLength := aVectorEngineWithPlugin dashedStroke_strokeDashLength.
	strokeDashArray := aVectorEngineWithPlugin dashedStroke_strokeDashArray.
	strokeDashArrayLast := aVectorEngineWithPlugin dashedStroke_strokeDashArrayLast.
	strokeDashArrayOffset := aVectorEngineWithPlugin dashedStroke_strokeDashArrayOffset.!

VectorEngineSubPixel removeSelector: #dashedStroke_ToFollow:!

!methodRemoval: VectorEngineSubPixel #dashedStroke_ToFollow: stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_ToFollow: aVectorEngineWithPlugin

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
	
	self currentMorph: nil.	
	
	"Based on #pvtSetForm:"
	targetForm := aVectorEngineWithPlugin dashedStroke_targetForm.
	targetWidth := targetForm width.
	targetHeight := targetForm height.
	morphIds := aVectorEngineWithPlugin dashedStroke_morphIds.
	edgeCounts := aVectorEngineWithPlugin dashedStroke_edgeCounts.
	alphaMask := aVectorEngineWithPlugin dashedStroke_alphaMask.
	contour := aVectorEngineWithPlugin dashedStroke_contour.
	self resetMorphBounds.
	self antiAliasingWidth: self class defaultAntiAliasingWidth.
	clipLeft := aVectorEngineWithPlugin dashedStroke_clipLeft.
	clipTop := aVectorEngineWithPlugin dashedStroke_clipTop.
	clipRight := aVectorEngineWithPlugin dashedStroke_clipRight.
	clipBottom := aVectorEngineWithPlugin dashedStroke_clipBottom.
	geometryTransformation := aVectorEngineWithPlugin dashedStroke_geometryTransformation.

	subPixelDelta := self class defaultSubPixelDelta.
	
	self pvtStrokeWidth: aVectorEngineWithPlugin dashedStroke_strokeWidth.
	self pvtStrokeColor: aVectorEngineWithPlugin dashedStroke_strokeColor.
	self pvtFillColor: nil.
	self pvtHopLength: 0.5.

	strokeDashLength := aVectorEngineWithPlugin dashedStroke_strokeDashLength.
	strokeDashArray := aVectorEngineWithPlugin dashedStroke_strokeDashArray.
	strokeDashArrayLast := aVectorEngineWithPlugin dashedStroke_strokeDashArrayLast.
	strokeDashArrayOffset := aVectorEngineWithPlugin dashedStroke_strokeDashArrayOffset.!

VectorEngineSmalltalk removeSelector: #dashedStroke_spanBottom!

!methodRemoval: VectorEngineSmalltalk #dashedStroke_spanBottom stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_spanBottom

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
^spanBottom!

VectorEngineSmalltalk removeSelector: #dashedStroke_spanTop!

!methodRemoval: VectorEngineSmalltalk #dashedStroke_spanTop stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_spanTop

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
^spanTop!

VectorEngineSmalltalk removeSelector: #dashedStroke_finishPath:!

!methodRemoval: VectorEngineSmalltalk #dashedStroke_finishPath: stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_finishPath: ensureClosePath
	"Blend stroke and/or fill over background, according to the just computed pen alphas (distance from pixel to center of stroke)"

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.

	"If we are doing a fill, and caller forgot to close the trajectory, then do it anyway."
	ensureClosePath ifTrue: [
		firstX isNaN ifFalse: [
			(firstX = currentX and: [ firstY = currentY ]) ifFalse: [
				"This is actually an error condition. If we are asked to fill, then the path should be closed.
				This is a workaround. If width > 0.0, we'll be adding a visible edge to the path."
				self lineToFirstPoint ]]].
	self updateContourLastLine.

	spanLeft := (spanLeft - swDilatedHalf - self subPixelDelta + 1) truncated.																	"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	spanTop := (spanTop - swDilatedHalf + 1) truncated.																	"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	spanRight := (spanRight + swDilatedHalf + self subPixelDelta) truncated + 1. 																	"Make room not just for updated mask, but also edges (hence, +1)"
	spanBottom := (spanBottom + swDilatedHalf) truncated.

!

VectorEngineSmalltalk removeSelector: #dashedStroke_spanLeft!

!methodRemoval: VectorEngineSmalltalk #dashedStroke_spanLeft stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_spanLeft

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
^spanLeft!

VectorEngineSmalltalk removeSelector: #dashedStroke_spanRight!

!methodRemoval: VectorEngineSmalltalk #dashedStroke_spanRight stamp: 'Install-7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st 5/24/2025 10:43:13'!
dashedStroke_spanRight

	"Please delete this method when VectorEnginePlugin supports dashed strokes."
	self flag: #dashedStrokesNotInPlugin.
^spanRight!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7201-PluginEngine-dontAskStEngineForDashedStrokes-JuanVuletich-2025Mar18-15h57m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7106] on 1 April 2025 at 9:33:56 am'!

VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight targetAssumedOpaque morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec dashBitOffset dashBitCount dashBitLength dashedStrokeBits '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineDrawer category: #'Morphic-Support' stamp: 'Install-7202-NewDashedStrokes-SmalltalkEngine-JuanVuletich-2025Apr01-09h20m-jmv.001.cs.st 5/24/2025 10:43:13'!
VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight targetAssumedOpaque morphIds edgeCounts alphaMask contour strokeColor strokeDashLength strokeDashArray strokeDashArrayLast strokeDashArrayOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec dashBitOffset dashBitCount dashBitLength dashedStrokeBits'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!
!AbstractVectorCanvas methodsFor: 'stroke & fill' stamp: 'jmv 3/28/2025 18:39:29'!
                          strokeWidth: strokeWidth color: aStrokeColor dashedStrokeBits: onOffBitSequence dashBitLength: lengthOfEachBit dashBitOffset: offsetOrNil do: pathCommandsBlock
	"Prepare parameters for drawing stroke.
	Do dashed strokes. This spec is periodic, the pattern is repeated as needed.
		- onOffBitSequence is an integer number, a sequence of bits specifying on/off parts
		- lengthOfEachBit is exactly that, the actual length of stroke for each bit
		- offsetOrNil can be used to do 'walking dashes' effects. It is an integer (nil defaults to 0).
	+ onOffBitSequence is usually stated in base-2.
	A possible example is 2r1110000100000. This draws '---    -     '
	"

	self initializePath.
	engine
		strokeWidth: strokeWidth
		color: aStrokeColor
		dashedStrokeBits: onOffBitSequence dashBitLength: lengthOfEachBit dashBitOffset: offsetOrNil
		do: pathCommandsBlock.! !
!AbstractVectorCanvas methodsFor: 'stroke & fill' stamp: 'jmv 3/28/2025 18:35:59'!
              strokeWidth: strokeWidth color: aStrokeColor dashedStrokeBits: onOffBitSequence do: pathCommandsBlock
	"Prepare parameters for drawing stroke.
	Do dashed strokes. This spec is periodic, the pattern is repeated as needed.
		- onOffBitSequence is an integer number, a sequence of bits specifying on/off parts
			A possible example is 2r1110000100000. This draws '---    -     '
	"

	self strokeWidth: strokeWidth
		color: aStrokeColor
		dashedStrokeBits: onOffBitSequence
		dashBitLength: nil
		dashBitOffset: nil
		do: pathCommandsBlock! !
!VectorEngineBoundsFinder methodsFor: 'stroke & fill' stamp: 'jmv 3/28/2025 18:30:14'!
              strokeWidth: clientStrokeWidth color: aStrokeColor dashedStrokeBits: onOffBitSequence dashBitLength: clientLengthOfEachBit dashBitOffset: offsetOrNil do: pathCommandsBlock

	^self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 3/28/2025 11:58:36'!
               basicStrokeWidth: aStrokeWidth color: aStrokeColor dashedStrokeBits: onOffBitSequence dashBitCount: numberOfBitsInSequence dashBitLength: lengthOfEachBit dashBitOffset: offset do: pathCommandsBlock ensureClosePath: ensureClosePath
	"Prepare parameters for drawing stroke.
	Do dashed strokes. This spec is periodic, the pattern is repeated as needed.
		onOffBitSequence is an integer number, a sequence of bits specifying on/off parts
		numberOfBitsInSequence is the number of bits in onOffBitSequence
		lengthOfEachBit is exactly that.
		Offset can be used to do 'walking dashes' effects. It is an integer in [0 .. numberOfBitsInSequence-1]."

	| sharper apparentWeight |
	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self ].
	aStrokeWidth = 0.0 ifTrue: [ ^self ].
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"There are two possible strategies when requested stroke width is narrower than anti aliasing filter.
			To more effectively avoid aliasing, set sharper to false.
			To draw sharper thin lines, at the price of very little extra aliasing in them, set sharper to true.
			This could be turned into a Preference."
			sharper := true.
			sharper ifTrue: [
				"If the requested stroke width is used, filter will be clipped, resulting in an incorrect weight for the stroke."
				apparentWeight := ((aStrokeWidth squared / antiAliasingWidth) + (2.0 * aStrokeWidth) + antiAliasingWidth) / 4.0.
				"{'(sharper)desired weight'. aStrokeWidth. 'but would get'. apparentWeight. 'correction'. aStrokeWidth / apparentWeight} print."
				self pvtStrokeWidth: aStrokeWidth.
				self pvtStrokeColor: (aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / apparentWeight)]
			ifFalse: [
				"If the requested stroke width is too thin, make them wide enough to be properly sampled."
				"{'(wider)desired weight'. aStrokeWidth. 'but would get'. antiAliasingWidth. 'correction'. aStrokeWidth / antiAliasingWidth} print."
				self pvtStrokeWidth: antiAliasingWidth.
				self pvtStrokeColor: (aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / antiAliasingWidth)]
			]
		ifFalse: [
			self pvtStrokeWidth: aStrokeWidth.
			self pvtStrokeColor: aStrokeColor ].
	self pvtFillColor: nil.
	self pvtHopLength: 0.5.									"See #experimentHopsPerPixel2"

	"For dashed strokes"
	dashedStrokeBits := onOffBitSequence.
	dashBitCount := numberOfBitsInSequence.
	dashBitLength := lengthOfEachBit.
	dashBitOffset := offset.

	self doPath: pathCommandsBlock ensureClosePath: ensureClosePath.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/1/2025 09:13:48'!
         strokeWidth: clientStrokeWidth color: aStrokeColor dashedStrokeBits: onOffBitSequence dashBitLength: clientLengthOfEachBit dashBitOffset: offsetOrNil do: pathCommandsBlock
	"Prepare parameters for drawing a dashed stroke. This spec is periodic, the pattern is repeated as needed.
		- onOffBitSequence is an integer number, a sequence of bits specifying on/off parts
		- clientLengthOfEachBit is exactly that, the actual length of stroke for each bit
		- offsetOrNil can be used to do 'walking dashes' effects. It is an integer (nil defaults to 0)."

	| bitSequence bitSequenceLength lengthOfEachBit offset |
	bitSequence := onOffBitSequence asInteger max: 1.
	bitSequenceLength := bitSequence highBit.
	lengthOfEachBit := clientLengthOfEachBit ifNil: [ 1.0 ].
	lengthOfEachBit := lengthOfEachBit asFloat.
	lengthOfEachBit <= 0.0 ifTrue: [ lengthOfEachBit := 1.0 ].
	lengthOfEachBit := geometryTransformation externalizeScalar: lengthOfEachBit.
	offset := offsetOrNil ifNil: [0].
	offset := offset asInteger \\ bitSequenceLength.

	self
		basicStrokeWidth: (geometryTransformation externalizeScalar: clientStrokeWidth)
		color: aStrokeColor
		dashedStrokeBits: bitSequence
		dashBitCount: bitSequence highBit 
		dashBitLength: lengthOfEachBit
		dashBitOffset: offset
		do: pathCommandsBlock
		ensureClosePath: false! !
!Sample02Bezier methodsFor: 'drawing' stamp: 'jmv 3/28/2025 18:33:07' prior: 50378590 overrides: 16905026!
               drawOn: aCanvas
	"Two Bezier curves. A Quadratic one (with start, end and a single control point), and a Cubic one (with start, end, and two control points)
	Sample02Bezier new openInHand
	"

	aCanvas strokeWidth: 4 color: Color green dashedStrokeBits: 2r1111000010000 dashBitLength: 2 dashBitOffset: dashOffset do: [
		aCanvas
				moveTo: aStart;
				quadraticBezierTo: aEnd control: aControlPoint ].

	aCanvas strokeWidth: 1 color: Color darkGray dashedStrokeBits: 16rFFFF0000 dashBitLength: 0.3 dashBitOffset: 0 do: [
		aCanvas
				moveTo: aStart;
				lineTo: aControlPoint;
				lineTo: aEnd ].

	aCanvas strokeWidth: 3 color: Color red dashedStrokeBits: 2r1000000010000000 dashBitLength: 2 dashBitOffset: dashOffset do: [
		aCanvas
				moveTo: bStart;
				cubicBezierTo: bEnd control1: bControlPoint1 control2: bControlPoint2 ].
	aCanvas strokeWidth: 1 color: Color darkGray dashedStrokeBits: 2r01010101010101010101010101010101 dashBitLength: 2 dashBitOffset: 0 do: [
		aCanvas
				moveTo: bStart;
				lineTo: bControlPoint1;
				lineTo: bControlPoint2;
				lineTo: bEnd ].! !
!Sample02Bezier methodsFor: 'stepping' stamp: 'jmv 3/28/2025 11:03:23' prior: 50360971 overrides: 16907759!
                           step

	dashOffset := dashOffset + 1.
	self redrawNeeded.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 3/28/2025 11:58:44' prior: 17001806!
   basicStrokeWidth: aStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	(aFillColor isNil or: [ aFillColor alpha = 0.0]) ifTrue: [
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: false ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		canvas ifNotNil: [ canvas initializePath ].
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: true ].

	self pvtStrokeWidth: aStrokeWidth.
	self pvtStrokeColor: aStrokeColor.
	self pvtFillColor: aFillColor.
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"Strokes are really thin, but strokeColor is same as fillColor, so there's no problem sampling them."
			self pvtHopLength: 0.5 ]								"See #experimentHopsPerPixel1"
		ifFalse: [
			self pvtHopLength: 0.5 ].								"See #experimentHopsPerPixel2."

	"Only used for strokes with no fill"
	dashedStrokeBits := 0.
	dashBitCount := 0.
	dashBitLength := 0.0.
	dashBitOffset := 0.

	self doPath: pathCommandsBlock ensureClosePath: true.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 3/28/2025 11:58:50' prior: 17001941!
                    fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	(aFillColor isNil or: [ aFillColor alpha = 0.0]) ifTrue: [ ^ self ].
	self pvtStrokeWidth: 0.0.
	self pvtStrokeColor: nil.
	self pvtFillColor: aFillColor.
	self pvtHopLength: 0.5.										"See #experimentHopsPerPixel3"

	"Only used for strokes with no fill"
	dashedStrokeBits := 0.
	dashBitCount := 0.
	dashBitLength := 0.0.
	dashBitOffset := 0.

	self doPath: pathCommandsBlock ensureClosePath: true.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 3/28/2025 11:55:58' prior: 17001960!
                   strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke."

	self
		basicStrokeWidth: (geometryTransformation externalizeScalar: clientStrokeWidth)
		color: aStrokeColor
		dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
		do: pathCommandsBlock
		ensureClosePath: false! !
!VectorEngineSubPixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/1/2025 09:30:25' prior: 17002623!
                 updateAlphasForX: x y: y
	| distanceToAxisSquared alpha t b l r alphaWord doUpdate dySquared dx dxSquared dy pixelIndex dxp bit |

	"If dashed strokes, only draw if in a dash, not in a gap."
	dashBitLength = 0.0 ifFalse: [
		"Compute trajectory length. This is not precise. In many cases the actual hop used is smaller than this."
		trajectoryLength := trajectoryLength + hop.
		"Correct behavior for negative offset given by #floor and #\\"
		bit := (trajectoryLength / dashBitLength + dashBitOffset) floor \\ dashBitCount.
		(dashedStrokeBits bitAt: dashBitCount - bit) = 1 ifFalse: [ ^self ]].

	"Compute affected rect. Honor clipRect"
	t := (y - swDilatedHalf + 1) truncated.		"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	t < clipTop ifTrue: [ t := clipTop ].
	b := (y + swDilatedHalf) truncated.
	b > clipBottom ifTrue: [ b := clipBottom ].
	l := (x - swDilatedHalf - subPixelDelta + 1) truncated.		"(z+1) truncated works equally well than (z ceiling)"
	l < clipLeft ifTrue: [ l := clipLeft ].
	r := (x + swDilatedHalf + subPixelDelta) truncated.
	r > clipRight ifTrue: [ r := clipRight ].

	t to: b do: [ :displayY |
		pixelIndex := displayY * targetWidth + l.
		l to: r do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			alphaWord := alphaMask bytesAt: pixelIndex.
			alphaWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00] ifFalse: [
				doUpdate := false.
				dy := displayY - y.
				dySquared := dy * dy.
				dx := displayX - x.
				"Red"
				dxp := dx - subPixelDelta.
				dxSquared := dxp * dxp.
				distanceToAxisSquared := dxSquared + dySquared.
				distanceToAxisSquared < swDilatedHalfSquared
					ifTrue: [
						alpha := distanceToAxisSquared <= swErodedHalfSquared
							ifTrue: [ 16r7F ]
							ifFalse: [ (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated ].
						alpha > (alphaWord at: 3) ifTrue: [
							alphaWord at: 3 put: alpha.
							doUpdate := true ]].
				"Green"
				dxSquared := dx * dx.
				distanceToAxisSquared := dxSquared + dySquared.
				distanceToAxisSquared < swDilatedHalfSquared
					ifTrue: [
						alpha := distanceToAxisSquared <= swErodedHalfSquared
							ifTrue: [ 16r7F ]
							ifFalse: [ (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated ].
						alpha > (alphaWord at: 2) ifTrue: [
							alphaWord at: 2 put: alpha.
							doUpdate := true ]].
				"Blue"
				dxp := dx + subPixelDelta.
				dxSquared := dxp * dxp.
				distanceToAxisSquared := dxSquared + dySquared.
				distanceToAxisSquared < swDilatedHalfSquared
					ifTrue: [
						alpha := distanceToAxisSquared <= swErodedHalfSquared
							ifTrue: [ 16r7F ]
							ifFalse: [ (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated ].
						alpha > (alphaWord at: 1) ifTrue: [
							alphaWord at: 1 put: alpha.
							doUpdate := true ]].
				doUpdate ifTrue: [
					alphaMask bytesAt: pixelIndex put: alphaWord ]]]]! !
!VectorEngineWholePixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/1/2025 09:30:35' prior: 17003494!
                              updateAlphasForX: x y: y
	| distanceToAxisSquared alpha t b l r prevAlpha dx dy pixelIndex bit |

	"If dashed strokes, only draw if in a dash, not in a gap."
	dashBitLength = 0.0 ifFalse: [
		"Compute trajectory length. This is not precise. In many cases the actual hop used is smaller than this."
		trajectoryLength := trajectoryLength + hop.
		"Correct behavior for negative offset given by #floor and #\\"
		bit := (trajectoryLength / dashBitLength + dashBitOffset) floor \\ dashBitCount.
		(dashedStrokeBits bitAt: dashBitCount - bit) = 1 ifFalse: [ ^self ]].

	"Compute affected rect. Honor clipRect."
	t := (y - swDilatedHalf + 1) truncated.			"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	t < clipTop ifTrue: [ t := clipTop ].
	b := (y + swDilatedHalf) truncated.
	b > clipBottom ifTrue: [ b := clipBottom ].
	l := (x - swDilatedHalf + 1) truncated.			"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	l < clipLeft ifTrue: [ l := clipLeft ].
	r := (x + swDilatedHalf) truncated.
	r > clipRight ifTrue: [ r := clipRight ].

	t to: b do: [ :displayY |
		pixelIndex := displayY * targetWidth + l.
		dy := displayY - y.
		l to: r do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			prevAlpha := alphaMask at: pixelIndex.
			prevAlpha = 16r7F ifFalse: [
				dx := displayX - x.
				distanceToAxisSquared := (dx*dx) + (dy*dy).
				distanceToAxisSquared < swDilatedHalfSquared
					ifTrue: [
						alpha := distanceToAxisSquared <= swErodedHalfSquared
							ifTrue: [ 16r7F ]
							ifFalse: [ (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated ].
						alpha > prevAlpha ifTrue: [
							alphaMask at: pixelIndex put: alpha ]]]]]! !

VectorEngineDrawer removeSelector: #strokeWidth:color:strokeDashArray:strokeDashArrayOffset:do:!

!methodRemoval: VectorEngineDrawer #strokeWidth:color:strokeDashArray:strokeDashArrayOffset:do: stamp: 'Install-7202-NewDashedStrokes-SmalltalkEngine-JuanVuletich-2025Apr01-09h20m-jmv.001.cs.st 5/24/2025 10:43:13'!
strokeWidth: clientStrokeWidth color: aStrokeColor strokeDashArray: clientSda strokeDashArrayOffset: clientSdao do: pathCommandsBlock
	"Prepare parameters for drawing stroke.
	sda must be of even size (or nil). Meaning is #(dashLen gapLen dashLen gapLen ...)
	sdao is simply added as an offset"

	| sda sdao last |
	sda := nil.
	last := 0.0.
	sdao := 0.0.
	(clientSda notNil and: [clientSda size even]) ifTrue: [
		"Parameter is #(dashLen gapLen dashLen gapLen ...)
		convert to #(dashEnd gapEnd dashEnd gapEnd ...)"
		sda := clientSda withIndexCollect: [ :each :i |
				last := last + each.
				 geometryTransformation externalizeScalar: last].
		sdao := geometryTransformation externalizeScalar: clientSdao ].
	last := geometryTransformation externalizeScalar: last.
		
	self
		basicStrokeWidth: (geometryTransformation externalizeScalar: clientStrokeWidth)
		color: aStrokeColor
		strokeDashArray: sda strokeDashArrayLast: last strokeDashArrayOffset: sdao
		do: pathCommandsBlock
		ensureClosePath: false!

VectorEngineDrawer removeSelector: #basicStrokeWidth:color:strokeDashArray:strokeDashArrayLast:strokeDashArrayOffset:do:ensureClosePath:!

!methodRemoval: VectorEngineDrawer #basicStrokeWidth:color:strokeDashArray:strokeDashArrayLast:strokeDashArrayOffset:do:ensureClosePath: stamp: 'Install-7202-NewDashedStrokes-SmalltalkEngine-JuanVuletich-2025Apr01-09h20m-jmv.001.cs.st 5/24/2025 10:43:13'!
basicStrokeWidth: aStrokeWidth color: aStrokeColor strokeDashArray: sda strokeDashArrayLast: sdal strokeDashArrayOffset: sdao do: pathCommandsBlock ensureClosePath: ensureClosePath
	"Prepare parameters for drawing stroke.
	sda is #(dashEnd gapEnd dashEnd gapEnd ...)
	sdao is simply added as an offset"

	| sharper apparentWeight |
	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self ].
	aStrokeWidth = 0.0 ifTrue: [ ^self ].
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"There are two possible strategies when requested stroke width is narrower than anti aliasing filter.
			To more effectively avoid aliasing, set sharper to false.
			To draw sharper thin lines, at the price of very little extra aliasing in them, set sharper to true.
			This could be turned into a Preference."
			sharper := true.
			sharper ifTrue: [
				"If the requested stroke width is used, filter will be clipped, resulting in an incorrect weight for the stroke."
				apparentWeight := ((aStrokeWidth squared / antiAliasingWidth) + (2.0 * aStrokeWidth) + antiAliasingWidth) / 4.0.
				"{'(sharper)desired weight'. aStrokeWidth. 'but would get'. apparentWeight. 'correction'. aStrokeWidth / apparentWeight} print."
				self pvtStrokeWidth: aStrokeWidth.
				self pvtStrokeColor: (aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / apparentWeight)]
			ifFalse: [
				"If the requested stroke width is too thin, make them wide enough to be properly sampled."
				"{'(wider)desired weight'. aStrokeWidth. 'but would get'. antiAliasingWidth. 'correction'. aStrokeWidth / antiAliasingWidth} print."
				self pvtStrokeWidth: antiAliasingWidth.
				self pvtStrokeColor: (aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / antiAliasingWidth)]
			]
		ifFalse: [
			self pvtStrokeWidth: aStrokeWidth.
			self pvtStrokeColor: aStrokeColor ].
	self pvtFillColor: nil.
	self pvtHopLength: 0.5.									"See #experimentHopsPerPixel2"

	"strokeDashLength is not zero only if there is one dash length followed by one dash gap (i.e. the simplest possible dash array)"
	strokeDashLength := (sda notNil and: [ sda size = 2 ])
		ifTrue: [ sda first ]
		ifFalse: [ 0.0 ].
	strokeDashArray := sda.
	strokeDashArrayLast := sdal.
	strokeDashArrayOffset := sdao.

	self doPath: pathCommandsBlock ensureClosePath: ensureClosePath.!

VectorEngineBoundsFinder removeSelector: #strokeWidth:color:strokeDashArray:strokeDashArrayOffset:do:!

!methodRemoval: VectorEngineBoundsFinder #strokeWidth:color:strokeDashArray:strokeDashArrayOffset:do: stamp: 'Install-7202-NewDashedStrokes-SmalltalkEngine-JuanVuletich-2025Apr01-09h20m-jmv.001.cs.st 5/24/2025 10:43:13'!
strokeWidth: clientStrokeWidth color: aStrokeColor strokeDashArray: clientSda strokeDashArrayOffset: clientSdao do: pathCommandsBlock
	^self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock!

AbstractVectorCanvas removeSelector: #strokeWidth:color:strokeDashArray:strokeDashArrayOffset:do:!

!methodRemoval: AbstractVectorCanvas #strokeWidth:color:strokeDashArray:strokeDashArrayOffset:do: stamp: 'Install-7202-NewDashedStrokes-SmalltalkEngine-JuanVuletich-2025Apr01-09h20m-jmv.001.cs.st 5/24/2025 10:43:13'!
strokeWidth: strokeWidth color: aStrokeColor strokeDashArray: sda strokeDashArrayOffset: sdao do: pathCommandsBlock
	"Prepare parameters for drawing stroke.
	Optionally include parameter for dashed strokes."

	self initializePath.
	engine
		strokeWidth: strokeWidth
		color: aStrokeColor
		strokeDashArray: sda strokeDashArrayOffset: sdao 
		do: pathCommandsBlock.!

VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight targetAssumedOpaque morphIds edgeCounts alphaMask contour strokeColor dashedStrokeBits dashBitCount dashBitLength dashBitOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineDrawer category: #'Morphic-Support' stamp: 'Install-7202-NewDashedStrokes-SmalltalkEngine-JuanVuletich-2025Apr01-09h20m-jmv.001.cs.st 5/24/2025 10:43:13'!
VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight targetAssumedOpaque morphIds edgeCounts alphaMask contour strokeColor dashedStrokeBits dashBitCount dashBitLength dashBitOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7202-NewDashedStrokes-SmalltalkEngine-JuanVuletich-2025Apr01-09h20m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7106] on 1 April 2025 at 9:52:08 am'!
!VectorCanvas methodsFor: 'morphic' stamp: 'jmv 4/1/2025 09:50:18' prior: 50374313 overrides: 50374284!
          clipByCurrentMorphStop
	| prevClipSpec |
	csi := csi-1.
	prevClipSpec := csi = 1
		"Using nil instead of the initial clipping spec when no clipping is an optimization."
		ifFalse: [ clippingSpecStack at: csi ].
	engine clippingSpec: prevClipSpec.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7203-nilClippingSpecForTopMorph-JuanVuletich-2025Apr01-09h33m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7109] on 3 April 2025 at 10:20:49 am'!
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:20:12' prior: 50375834 overrides: 17002504!
                    blendFillOnly
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realFillColor opaqueFillColorWord realOpaqueFillColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ fillColor alpha = 1.0 ]) ifTrue: [
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		spanLeft to: spanRight do: [ :displayX |
			
			edgesThisPixel := edgeCounts bytesAt: pixelIndex.
			edgeCounts at: pixelIndex put: 0.
			edgesThisPixelR := edgesThisPixel at: 3.
			edgesThisPixelG := edgesThisPixel at: 2.
			edgesThisPixelB := edgesThisPixel at: 1.
			
			"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
			edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
			edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
			edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
			
			edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
			edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
			edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
			isRedInside := edgesUpToThisPixelR ~= 0.
			isGreenInside := edgesUpToThisPixelG ~= 0.
			isBlueInside := edgesUpToThisPixelB ~= 0.
			
			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
				alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
					ifTrue: [
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realFillColor := fillColor.  fillColor := fillColor alpha: fillColor alpha * 0.75.
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]].
				
				(strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] or: [
					isRedInside or: [ isGreenInside or: [ isBlueInside ]]]) ifTrue: [
					
						(strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] and: [ opaqueFillColorWord ~= 0 ])
							ifTrue: [
								"Fully inside the shape, far from anti aliasing. Color is opaque. Target is too. Just overwrite with fill color."
								targetForm bits at: pixelIndex put: opaqueFillColorWord.
								morphIds at: pixelIndex put: currentMorphId ]
							ifFalse: [
								"At least one subpixel inside the shape, or in the anti aliasing area"
								self blendFillOnlyAt: pixelIndex
									redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
									antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].
				
				mustResetColor ifTrue: [
					fillColor := realFillColor. opaqueFillColorWord := realOpaqueFillColorWord. mustResetColor := false ]].
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:20:28' prior: 50376066 overrides: 17002509!
  blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColors realStrokeColor realFillColor opaqueStrokeColorWord opaqueFillColorWord realOpaqueStrokeColorWord realOpaqueFillColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColors := false.
	opaqueStrokeColorWord := 0.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha * fillColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000.
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		spanLeft to: spanRight do: [ :displayX |
			
			edgesThisPixel := edgeCounts bytesAt: pixelIndex.
			edgeCounts at: pixelIndex put: 0.
			edgesThisPixelR := edgesThisPixel at: 3.
			edgesThisPixelG := edgesThisPixel at: 2.
			edgesThisPixelB := edgesThisPixel at: 1.
			
			"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
			edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
			edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
			edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
			
			edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
			edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
			edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
			isRedInside := edgesUpToThisPixelR ~= 0.
			isGreenInside := edgesUpToThisPixelG ~= 0.
			isBlueInside := edgesUpToThisPixelB ~= 0.
			
			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
				alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel ])
					ifTrue: [
						realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]].
				
				strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00]
					ifTrue: [ 		"Not in the stroke at all. Either fully in the fill, or outside the shape (pixel is unaffected)."
						isGreenInside
							ifTrue: [
								"Fully inside the fill, far from anti aliasing. (Here isGreenInside also implies isRedInside and isBlueInside)"
								opaqueFillColorWord ~= 0
									ifTrue: [
										"Fill color is opaque. Target is too. Just overwrite with fill color."
										targetForm bits at: pixelIndex put: opaqueFillColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of fill over target."
										self blendFillOnlyAt: pixelIndex
											redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
											antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]]
					ifFalse: [		"At least one subpixel in the stroke."
						strokeAntiAliasAlphasWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00]
							ifTrue: [
								"Fully inside the stroke, far from anti aliasing."
								opaqueStrokeColorWord ~= 0
									ifTrue: [
										"Stroke color is opaque. Target is too. Just overwrite with stroke color."
										targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of stroke over target."
										self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]
							ifFalse: [
								"In an anti aliased part of the stroke. Either blend stroke over background, or pre-mix stroke and fill."
								self blendStrokeAndFillAt: pixelIndex
									redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
									antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].					
				
				mustResetColors ifTrue: [
					strokeColor := realStrokeColor. fillColor := realFillColor.
					opaqueStrokeColorWord := realOpaqueStrokeColorWord. opaqueFillColorWord := realOpaqueFillColorWord.
					mustResetColors := false ]].
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:19:59' prior: 50376394 overrides: 17002514!
                             blendStrokeOnly
	"Blends stroke color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realStrokeColor opaqueStrokeColorWord realOpaqueStrokeColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueStrokeColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		spanLeft to: spanRight do: [ :displayX |
			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			"At least one subpixel in the stroke."
			strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] ifFalse: [
				alphaMask at: pixelIndex put: 0.
				(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
					(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
						ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]
						ifFalse: [
							(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
								realStrokeColor := strokeColor.  strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
								realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]].
					
					(opaqueStrokeColorWord ~= 0 and: [strokeAntiAliasAlphasWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00]])
						ifTrue: [
							"Fully inside the stroke, far from anti aliasing. Color is opaque. Target is too. Just overwrite with stroke color."
							targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
							morphIds at: pixelIndex put: currentMorphId ]
						ifFalse: [
							"At least one subpixel in the anti aliasing area of the stroke, or color is translucent, or target translucency is desired."
							self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord ].
					
					mustResetColor ifTrue: [
						strokeColor := realStrokeColor. opaqueStrokeColorWord := realOpaqueStrokeColorWord. mustResetColor := false ]]].
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:20:08' prior: 50376575 overrides: 17002504!
          blendFillOnly
	"Blends fill color over background.
	If targetAssumedOpaque is false, target translucency is computed correctly.
	If targetAssumedOpaque is true (and target translucency is actually 255 on input), an optimization is made and target translucency is set to 255.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]."

	| edgesUpToThisPixel edgesThisPixel pixelIndex antiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realFillColor opaqueFillColorWord realOpaqueFillColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ fillColor alpha = 1.0 ]) ifTrue: [
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		spanLeft to: spanRight do: [ :displayX |
			edgesThisPixel := edgeCounts at: pixelIndex.
			edgesThisPixel = 0 ifFalse: [
				edgeCounts at: pixelIndex put: 0.
				"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
				edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
				edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
			antiAliasAlphaBits := alphaMask at: pixelIndex.
			antiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
					ifTrue: [
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realFillColor := fillColor.  fillColor := fillColor alpha: fillColor alpha * 0.75.
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]].
				
				edgesUpToThisPixel = 0
					ifFalse: [ "Inside the shape"
						(antiAliasAlphaBits = 0 and: [ opaqueFillColorWord ~= 0 ])
							ifTrue: [
								"Fully inside the shape, far from anti aliasing. Color is opaque. Target is too. Just overwrite with fill color."
								targetForm bits at: pixelIndex put: opaqueFillColorWord.
								morphIds at: pixelIndex put: currentMorphId ]
							ifFalse: [
								"Inside the shape. Turn stroke anti aliasing into fill anti aliasing."
								self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: 127 - antiAliasAlphaBits ]]
					ifTrue: [ "Still in the anti aliasing area, but outside the shape, strictly speaking."
						antiAliasAlphaBits = 0 ifFalse: [
							self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: antiAliasAlphaBits ]].
				
				mustResetColor ifTrue: [
					fillColor := realFillColor. opaqueFillColorWord := realOpaqueFillColorWord. mustResetColor := false ]].
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:20:34' prior: 50376745 overrides: 17002509!
                blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixel edgesThisPixel pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColors realStrokeColor realFillColor opaqueStrokeColorWord opaqueFillColorWord realOpaqueStrokeColorWord realOpaqueFillColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColors := false.
	opaqueStrokeColorWord := 0.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha * fillColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000.
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		spanLeft to: spanRight do: [ :displayX |
			edgesThisPixel := edgeCounts at: pixelIndex.
			edgesThisPixel = 0 ifFalse: [
				edgeCounts at: pixelIndex put: 0.
				"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
				edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
				edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
			strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
			strokeAntiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel ])
					ifTrue: [
						realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]].
				
				strokeAntiAliasAlphaBits = 0
					ifTrue: [ 		"Not in the stroke at all. Either fully in the fill, or outside the shape (pixel is unaffected)."
						edgesUpToThisPixel ~= 0
							ifTrue: [
								"Fully inside the fill, far from anti aliasing."
								opaqueFillColorWord ~= 0
									ifTrue: [
										"Color is opaque. Target is too. Just overwrite with fill color."
										targetForm bits at: pixelIndex put: opaqueFillColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of fill over target."
										self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: 127 ]]]
					ifFalse: [		"In the stroke."
						strokeAntiAliasAlphaBits = 127
							ifTrue: [
								"Fully inside the stroke, far from anti aliasing."
								opaqueStrokeColorWord ~= 0
									ifTrue: [
										"Color is opaque. Target is too. Just overwrite with stroke color."
										targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of stroke over target."
										self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: 127 ]]
							ifFalse: [
								"In an anti aliased part of the stroke. Either blend stroke over background, or pre-mix stroke and fill."
								edgesUpToThisPixel ~= 0
									ifTrue: [ 
										"Inside the shape. Blend stroke and fill, blend result over target."
										self blendStrokeAndFillAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]
									ifFalse: [
										"In the outer anti aliasing area of the stroke. Blend stroke over background."
										self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]]].
				
				mustResetColors ifTrue: [
					strokeColor := realStrokeColor. fillColor := realFillColor.
					opaqueStrokeColorWord := realOpaqueStrokeColorWord. opaqueFillColorWord := realOpaqueFillColorWord.
					mustResetColors := false ]].
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:20:03' prior: 50376925 overrides: 17002514!
          blendStrokeOnly
	"Blends stroke color over background.
	If targetAssumedOpaque is false, target translucency is computed correctly.
	If targetAssumedOpaque is true (and target translucency is actually 255 on input), an optimization is made and target translucency is set to 255.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realStrokeColor opaqueStrokeColorWord realOpaqueStrokeColorWord |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueStrokeColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		spanLeft to: spanRight do: [ :displayX |
			strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
			strokeAntiAliasAlphaBits = 0 ifFalse: [			"In the stroke"
				alphaMask at: pixelIndex put: 0.
				(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
					(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
						ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]
						ifFalse: [
							(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
								realStrokeColor := strokeColor.  strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
								realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]].
					
					(opaqueStrokeColorWord ~= 0 and: [strokeAntiAliasAlphaBits = 127])
						ifTrue: [
							"Fully inside the stroke, far from anti aliasing. Color is opaque. Target is too. Just overwrite with stroke color."
							targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
							morphIds at: pixelIndex put: currentMorphId ]
						ifFalse: [
							"At least one subpixel in the anti aliasing area of the stroke, or color is translucent, or target translucency is desired."
							self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ].
					
					mustResetColor ifTrue: [
						strokeColor := realStrokeColor. opaqueStrokeColorWord := realOpaqueStrokeColorWord. mustResetColor := false ]]].
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7204-Prep1-JuanVuletich-2025Apr03-10h12m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7109] on 3 April 2025 at 10:26:10 am'!
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:25:27' prior: 50380059 overrides: 17002504!
        blendFillOnly
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realFillColor opaqueFillColorWord realOpaqueFillColorWord displayX |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ fillColor alpha = 1.0 ]) ifTrue: [
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			
			edgesThisPixel := edgeCounts bytesAt: pixelIndex.
			edgeCounts at: pixelIndex put: 0.
			edgesThisPixelR := edgesThisPixel at: 3.
			edgesThisPixelG := edgesThisPixel at: 2.
			edgesThisPixelB := edgesThisPixel at: 1.
			
			"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
			edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
			edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
			edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
			
			edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
			edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
			edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
			isRedInside := edgesUpToThisPixelR ~= 0.
			isGreenInside := edgesUpToThisPixelG ~= 0.
			isBlueInside := edgesUpToThisPixelB ~= 0.
			
			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
				alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
					ifTrue: [
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realFillColor := fillColor.  fillColor := fillColor alpha: fillColor alpha * 0.75.
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]].
				
				(strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] or: [
					isRedInside or: [ isGreenInside or: [ isBlueInside ]]]) ifTrue: [
					
						(strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] and: [ opaqueFillColorWord ~= 0 ])
							ifTrue: [
								"Fully inside the shape, far from anti aliasing. Color is opaque. Target is too. Just overwrite with fill color."
								targetForm bits at: pixelIndex put: opaqueFillColorWord.
								morphIds at: pixelIndex put: currentMorphId ]
							ifFalse: [
								"At least one subpixel inside the shape, or in the anti aliasing area"
								self blendFillOnlyAt: pixelIndex
									redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
									antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].
				
				mustResetColor ifTrue: [
					fillColor := realFillColor. opaqueFillColorWord := realOpaqueFillColorWord. mustResetColor := false ]].
			displayX := displayX + 1.
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:25:00' prior: 50380210 overrides: 17002509!
      blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColors realStrokeColor realFillColor opaqueStrokeColorWord opaqueFillColorWord realOpaqueStrokeColorWord realOpaqueFillColorWord displayX |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColors := false.
	opaqueStrokeColorWord := 0.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha * fillColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000.
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			
			edgesThisPixel := edgeCounts bytesAt: pixelIndex.
			edgeCounts at: pixelIndex put: 0.
			edgesThisPixelR := edgesThisPixel at: 3.
			edgesThisPixelG := edgesThisPixel at: 2.
			edgesThisPixelB := edgesThisPixel at: 1.
			
			"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
			edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
			edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
			edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
			
			edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
			edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
			edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
			isRedInside := edgesUpToThisPixelR ~= 0.
			isGreenInside := edgesUpToThisPixelG ~= 0.
			isBlueInside := edgesUpToThisPixelB ~= 0.
			
			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
				alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel ])
					ifTrue: [
						realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]].
				
				strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00]
					ifTrue: [ 		"Not in the stroke at all. Either fully in the fill, or outside the shape (pixel is unaffected)."
						isGreenInside
							ifTrue: [
								"Fully inside the fill, far from anti aliasing. (Here isGreenInside also implies isRedInside and isBlueInside)"
								opaqueFillColorWord ~= 0
									ifTrue: [
										"Fill color is opaque. Target is too. Just overwrite with fill color."
										targetForm bits at: pixelIndex put: opaqueFillColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of fill over target."
										self blendFillOnlyAt: pixelIndex
											redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
											antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]]
					ifFalse: [		"At least one subpixel in the stroke."
						strokeAntiAliasAlphasWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00]
							ifTrue: [
								"Fully inside the stroke, far from anti aliasing."
								opaqueStrokeColorWord ~= 0
									ifTrue: [
										"Stroke color is opaque. Target is too. Just overwrite with stroke color."
										targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of stroke over target."
										self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]
							ifFalse: [
								"In an anti aliased part of the stroke. Either blend stroke over background, or pre-mix stroke and fill."
								self blendStrokeAndFillAt: pixelIndex
									redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
									antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].					
				
				mustResetColors ifTrue: [
					strokeColor := realStrokeColor. fillColor := realFillColor.
					opaqueStrokeColorWord := realOpaqueStrokeColorWord. opaqueFillColorWord := realOpaqueFillColorWord.
					mustResetColors := false ]].
			displayX := displayX + 1.
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:25:13' prior: 50380422 overrides: 17002514!
 blendStrokeOnly
	"Blends stroke color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realStrokeColor opaqueStrokeColorWord realOpaqueStrokeColorWord displayX |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueStrokeColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
			"At least one subpixel in the stroke."
			strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] ifFalse: [
				alphaMask at: pixelIndex put: 0.
				(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
					(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
						ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]
						ifFalse: [
							(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
								realStrokeColor := strokeColor.  strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
								realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]].
					
					(opaqueStrokeColorWord ~= 0 and: [strokeAntiAliasAlphasWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00]])
						ifTrue: [
							"Fully inside the stroke, far from anti aliasing. Color is opaque. Target is too. Just overwrite with stroke color."
							targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
							morphIds at: pixelIndex put: currentMorphId ]
						ifFalse: [
							"At least one subpixel in the anti aliasing area of the stroke, or color is translucent, or target translucency is desired."
							self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord ].
					
					mustResetColor ifTrue: [
						strokeColor := realStrokeColor. opaqueStrokeColorWord := realOpaqueStrokeColorWord. mustResetColor := false ]]].
			displayX := displayX + 1.
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:25:23' prior: 50380535 overrides: 17002504!
              blendFillOnly
	"Blends fill color over background.
	If targetAssumedOpaque is false, target translucency is computed correctly.
	If targetAssumedOpaque is true (and target translucency is actually 255 on input), an optimization is made and target translucency is set to 255.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]."

	| edgesUpToThisPixel edgesThisPixel pixelIndex antiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realFillColor opaqueFillColorWord realOpaqueFillColorWord displayX |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ fillColor alpha = 1.0 ]) ifTrue: [
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			edgesThisPixel := edgeCounts at: pixelIndex.
			edgesThisPixel = 0 ifFalse: [
				edgeCounts at: pixelIndex put: 0.
				"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
				edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
				edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
			antiAliasAlphaBits := alphaMask at: pixelIndex.
			antiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
					ifTrue: [
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realFillColor := fillColor.  fillColor := fillColor alpha: fillColor alpha * 0.75.
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]].
				
				edgesUpToThisPixel = 0
					ifFalse: [ "Inside the shape"
						(antiAliasAlphaBits = 0 and: [ opaqueFillColorWord ~= 0 ])
							ifTrue: [
								"Fully inside the shape, far from anti aliasing. Color is opaque. Target is too. Just overwrite with fill color."
								targetForm bits at: pixelIndex put: opaqueFillColorWord.
								morphIds at: pixelIndex put: currentMorphId ]
							ifFalse: [
								"Inside the shape. Turn stroke anti aliasing into fill anti aliasing."
								self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: 127 - antiAliasAlphaBits ]]
					ifTrue: [ "Still in the anti aliasing area, but outside the shape, strictly speaking."
						antiAliasAlphaBits = 0 ifFalse: [
							self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: antiAliasAlphaBits ]].
				
				mustResetColor ifTrue: [
					fillColor := realFillColor. opaqueFillColorWord := realOpaqueFillColorWord. mustResetColor := false ]].
			displayX := displayX + 1.
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:25:04' prior: 50380663 overrides: 17002509!
                    blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixel edgesThisPixel pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColors realStrokeColor realFillColor opaqueStrokeColorWord opaqueFillColorWord realOpaqueStrokeColorWord realOpaqueFillColorWord displayX |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColors := false.
	opaqueStrokeColorWord := 0.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha * fillColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000.
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			edgesThisPixel := edgeCounts at: pixelIndex.
			edgesThisPixel = 0 ifFalse: [
				edgeCounts at: pixelIndex put: 0.
				"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
				edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
				edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
			strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
			strokeAntiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ].
			(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
				(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel ])
					ifTrue: [
						realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
						realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
						realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
						realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]
					ifFalse: [
						(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
							realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]].
				
				strokeAntiAliasAlphaBits = 0
					ifTrue: [ 		"Not in the stroke at all. Either fully in the fill, or outside the shape (pixel is unaffected)."
						edgesUpToThisPixel ~= 0
							ifTrue: [
								"Fully inside the fill, far from anti aliasing."
								opaqueFillColorWord ~= 0
									ifTrue: [
										"Color is opaque. Target is too. Just overwrite with fill color."
										targetForm bits at: pixelIndex put: opaqueFillColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of fill over target."
										self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: 127 ]]]
					ifFalse: [		"In the stroke."
						strokeAntiAliasAlphaBits = 127
							ifTrue: [
								"Fully inside the stroke, far from anti aliasing."
								opaqueStrokeColorWord ~= 0
									ifTrue: [
										"Color is opaque. Target is too. Just overwrite with stroke color."
										targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Translucent color or target. Do proper blend of stroke over target."
										self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: 127 ]]
							ifFalse: [
								"In an anti aliased part of the stroke. Either blend stroke over background, or pre-mix stroke and fill."
								edgesUpToThisPixel ~= 0
									ifTrue: [ 
										"Inside the shape. Blend stroke and fill, blend result over target."
										self blendStrokeAndFillAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]
									ifFalse: [
										"In the outer anti aliasing area of the stroke. Blend stroke over background."
										self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]]].
				
				mustResetColors ifTrue: [
					strokeColor := realStrokeColor. fillColor := realFillColor.
					opaqueStrokeColorWord := realOpaqueStrokeColorWord. opaqueFillColorWord := realOpaqueFillColorWord.
					mustResetColors := false ]].
			displayX := displayX + 1.
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/3/2025 10:25:18' prior: 50380844 overrides: 17002514!
              blendStrokeOnly
	"Blends stroke color over background.
	If targetAssumedOpaque is false, target translucency is computed correctly.
	If targetAssumedOpaque is true (and target translucency is actually 255 on input), an optimization is made and target translucency is set to 255.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realStrokeColor opaqueStrokeColorWord realOpaqueStrokeColorWord displayX |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueStrokeColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000 ].
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
			strokeAntiAliasAlphaBits = 0 ifFalse: [			"In the stroke"
				alphaMask at: pixelIndex put: 0.
				(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
					(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
						ifTrue: [
							realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
							realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]
						ifFalse: [
							(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
								realStrokeColor := strokeColor.  strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
								realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]].
					
					(opaqueStrokeColorWord ~= 0 and: [strokeAntiAliasAlphaBits = 127])
						ifTrue: [
							"Fully inside the stroke, far from anti aliasing. Color is opaque. Target is too. Just overwrite with stroke color."
							targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
							morphIds at: pixelIndex put: currentMorphId ]
						ifFalse: [
							"At least one subpixel in the anti aliasing area of the stroke, or color is translucent, or target translucency is desired."
							self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ].
					
					mustResetColor ifTrue: [
						strokeColor := realStrokeColor. opaqueStrokeColorWord := realOpaqueStrokeColorWord. mustResetColor := false ]]].
			displayX := displayX + 1.
			pixelIndex := pixelIndex + 1 ].
		clippingSpecIndex := clippingSpecIndex + 2 ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7205-Prep2-JuanVuletich-2025Apr03-10h20m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7108] on 3 April 2025 at 9:51:26 am'!

VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight targetAssumedOpaque morphIds edgeCounts alphaMask contour strokeColor dashedStrokeBits dashBitCount dashBitLength dashBitOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec affectedBits '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineDrawer category: #'Morphic-Support' stamp: 'Install-7206-affectedBits-ClassShape-JuanVuletich-2025Apr03-09h51m-jmv.001.cs.st 5/24/2025 10:43:14'!
VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight targetAssumedOpaque morphIds edgeCounts alphaMask contour strokeColor dashedStrokeBits dashBitCount dashBitLength dashBitOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec affectedBits'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!
!VectorEngineDrawer methodsFor: 'private' stamp: 'jmv 4/1/2025 15:42:31' prior: 50375808!
     pvtSetForm: aForm

	| s |
	targetForm := aForm.
	targetWidth := targetForm width.
	targetHeight := targetForm height.
	targetAssumedOpaque := true. 		"Set to false for true translucency on target."
	s := targetWidth * targetHeight.
	morphIds := WordArray new: s.
	edgeCounts := self auxPixelDataClass new: s.
	alphaMask := self auxPixelDataClass new: s.
	affectedBits := ByteArray new: s+15 // 16.
	contour := Float32Array new: targetHeight * 2.
	0 to: targetHeight-1 do: [ :y |
		contour at: y * 2 + 1 put: targetWidth.
		contour at: y * 2 + 2 put: 0 ].
	self resetMorphBounds.
	self clipRect: targetForm boundingBox.
	self antiAliasingWidth: self class defaultAntiAliasingWidth.
	geometryTransformation := MorphicTranslation identity.! !
!VectorEngineDrawer methodsFor: 'services' stamp: 'jmv 4/1/2025 10:30:00' prior: 17002037!
 pinArrays
	"Pin if pinning is supported by the VM, NOP otherwise."
	"Warning: #pin may fail for Spur images if run on the SqueakJS VM, at least on October 2023."

	targetForm bits pin.
	morphIds pin.
	edgeCounts pin.
	alphaMask pin.
	affectedBits pin.
	contour pin.! !
!VectorEngineDrawer methodsFor: 'services' stamp: 'jmv 4/1/2025 10:29:52' prior: 17002048!
                        unpinAndFreeMemory

	"Unpin, if possible, any pinned large arrays."
	"Unpin if pinning is supported by the VM, NOP otherwise."
	targetForm ifNotNil: [
		targetForm == Display ifFalse: [
			targetForm bits unpin ]].
	morphIds ifNotNil: [ morphIds unpin ].
	edgeCounts ifNotNil: [ edgeCounts unpin ].
	alphaMask ifNotNil: [ alphaMask unpin ].
	affectedBits ifNotNil: [ affectedBits unpin ].
	contour ifNotNil: [ contour unpin ].

	targetForm := nil.
	morphIds := nil.
	edgeCounts := nil.
	alphaMask := nil.
	affectedBits := nil.
	contour := nil.! !

VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight targetAssumedOpaque morphIds edgeCounts alphaMask affectedBits contour strokeColor dashedStrokeBits dashBitCount dashBitLength dashBitOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineDrawer category: #'Morphic-Support' stamp: 'Install-7206-affectedBits-ClassShape-JuanVuletich-2025Apr03-09h51m-jmv.001.cs.st 5/24/2025 10:43:14'!
VectorEngine subclass: #VectorEngineDrawer
	instanceVariableNames: 'targetForm targetWidth targetHeight targetAssumedOpaque morphIds edgeCounts alphaMask affectedBits contour strokeColor dashedStrokeBits dashBitCount dashBitLength dashBitOffset fillColor clipLeft clipTop clipRight clipBottom currentMorphId clippingSpec'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
| activeProc guiRoot |
(nil inform: 'After this update, #7206,
we need to restart the User Interface process.
Please do World / Changes... / [Install New Updates].').
[
	ChangeSet installing: '7206-affectedBits-ClassShape-JuanVuletich-2025Apr03-09h51m-jmv.001.cs.st' do: [].
	cs _ ChangeSet changeSetForBaseSystem.
	(cs name beginsWith: '7206') ifTrue: [
		ChangeSet removeChangeSet: cs ].
	'Installed ChangeSet: 7206-affectedBits-ClassShape-JuanVuletich-2025Apr03-09h51m-jmv.001.cs.st' print.
	'Please do World / Changes... / [Install New Updates].' print.
	Utilities logsUserChanges: true.
] forkAt: 39.
UISupervisor ui setupNewCanvasAndEngine.
UISupervisor newUIProcess.
Processor activeProcess terminate.
!

'From Cuis7.3 [latest update: #7111] on 3 April 2025 at 3:38:51 pm'!
!VectorEngineSubPixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/3/2025 13:32:18' prior: 50379684!
                           updateAlphasForX: x y: y
	| distanceToAxisSquared alpha t b l r alphaWord doUpdate dySquared dx dxSquared dy pixelIndex dxp bit lastUpdated affectedBitsIndex |

	"If dashed strokes, only draw if in a dash, not in a gap."
	dashBitLength = 0.0 ifFalse: [
		"Compute trajectory length. This is not precise. In many cases the actual hop used is smaller than this."
		trajectoryLength := trajectoryLength + hop.
		"Correct behavior for negative offset given by #floor and #\\"
		bit := (trajectoryLength / dashBitLength + dashBitOffset) floor \\ dashBitCount.
		(dashedStrokeBits bitAt: dashBitCount - bit) = 1 ifFalse: [ ^self ]].

	"Compute affected rect. Honor clipRect"
	t := (y - swDilatedHalf + 1) truncated.		"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	t < clipTop ifTrue: [ t := clipTop ].
	b := (y + swDilatedHalf) truncated.
	b > clipBottom ifTrue: [ b := clipBottom ].
	l := (x - swDilatedHalf - subPixelDelta + 1) truncated.		"(z+1) truncated works equally well than (z ceiling)"
	l < clipLeft ifTrue: [ l := clipLeft ].
	r := (x + swDilatedHalf + subPixelDelta) truncated.
	r > clipRight ifTrue: [ r := clipRight ].
lastUpdated := -1.
	t to: b do: [ :displayY |
		pixelIndex := displayY * targetWidth + l.
		l to: r do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			alphaWord := alphaMask bytesAt: pixelIndex.
			alphaWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00] ifFalse: [
				doUpdate := false.
				dy := displayY - y.
				dySquared := dy * dy.
				dx := displayX - x.
				"Red"
				dxp := dx - subPixelDelta.
				dxSquared := dxp * dxp.
				distanceToAxisSquared := dxSquared + dySquared.
				distanceToAxisSquared < swDilatedHalfSquared
					ifTrue: [
						alpha := distanceToAxisSquared <= swErodedHalfSquared
							ifTrue: [ 16r7F ]
							ifFalse: [ (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated ].
						alpha > (alphaWord at: 3) ifTrue: [
							alphaWord at: 3 put: alpha.
							doUpdate := true ]].
				"Green"
				dxSquared := dx * dx.
				distanceToAxisSquared := dxSquared + dySquared.
				distanceToAxisSquared < swDilatedHalfSquared
					ifTrue: [
						alpha := distanceToAxisSquared <= swErodedHalfSquared
							ifTrue: [ 16r7F ]
							ifFalse: [ (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated ].
						alpha > (alphaWord at: 2) ifTrue: [
							alphaWord at: 2 put: alpha.
							doUpdate := true ]].
				"Blue"
				dxp := dx + subPixelDelta.
				dxSquared := dxp * dxp.
				distanceToAxisSquared := dxSquared + dySquared.
				distanceToAxisSquared < swDilatedHalfSquared
					ifTrue: [
						alpha := distanceToAxisSquared <= swErodedHalfSquared
							ifTrue: [ 16r7F ]
							ifFalse: [ (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated ].
						alpha > (alphaWord at: 1) ifTrue: [
							alphaWord at: 1 put: alpha.
							doUpdate := true ]].
				doUpdate ifTrue: [
					
					"ESTO"
					"solo pixelIndex>>4 en slang"
					affectedBitsIndex := pixelIndex-1>>4+1.
					lastUpdated = affectedBitsIndex
						ifFalse: [
							"Esta pobre optimizacion baja a la 3ra parte.
							Lo óptimo sería la 1ma parte!!"
							(affectedBits at: affectedBitsIndex) = 1
								ifFalse: [
									affectedBits at: affectedBitsIndex put: 1.
									lastUpdated := affectedBitsIndex ]].
							"esto obviamente reescribe todavia muchas veces, de llamados anteriores.
							optimizar si es posible."
					
					alphaMask bytesAt: pixelIndex put: alphaWord ]]]]! !
!VectorEngineSubPixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/3/2025 14:40:44' prior: 17002725!
                              updateEdgeCountAtX: x y: y
	"Compute edges intersecting with this horizontal line, for fills.
		
	See https://en.wikipedia.org/wiki/Nonzero-rule .

Where it says 'pick a ray in any direction', we pick an horizontal ray pointing to the left. This means that for any point (actually for every pixel) p1=(x1, y1), we record any crossings of y1, i.e. any sequence of path points (... pp1, pp2, .....) where the jump from pp1 to pp2 crosses y1, and pp1.x and pp2.x are at the left of x1. If the path is going up, it is clockwwise. If it is going down, it is counter clockwise.

As an additional optimization, as we need to store for every pixel all the crossings to the left, what we actually store are the crossings at each pixel (i.e. within 1 pixel distance to the left). Then, when we use them, the algorithms iterates from left to right, and accumulates the counters from previous pixels.
	"

	| thisYTruncated pixelY pixelIndexBase redPixelIndex greenPixelIndex bluePixelIndex increment countWord redCount greenCount blueCount redOffset greenOffset blueOffset affectedBitsIndex affectedBitsIndex2 |

	thisYTruncated := y truncated.
	thisYTruncated = prevYTruncated ifTrue: [
		^ self].
	(thisYTruncated between: clipTop-1 and: clipBottom) ifFalse: [
		^ self ].
	prevYTruncated = 16r3FFFFFFF ifTrue: [ 
		^ prevYTruncated := thisYTruncated ].

	thisYTruncated > prevYTruncated
		ifTrue: [
			pixelY := thisYTruncated.
			increment := 1 ]
		ifFalse: [
			pixelY := prevYTruncated.
			increment := -1 ].
	prevYTruncated := thisYTruncated.

	"All edge count at the left of the clipRect are added there (at the left of the clipRect).
	The effect is the same, and we need to clean up less stuff afterwards.
	More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses."
	pixelIndexBase := pixelY * targetWidth.
	redOffset := (x+subPixelDelta+1) truncated max: clipLeft.			"take the next red subpixel center to the right of x"
	greenOffset := (x+1) truncated max: clipLeft.											"take the next green subpixel center to the right of x"
	blueOffset := (x-subPixelDelta+1) truncated max: clipLeft.		"take the next blue subpixel center to the right of x"
	redPixelIndex := pixelIndexBase + redOffset +1.
	greenPixelIndex := pixelIndexBase + greenOffset +1.
	bluePixelIndex := pixelIndexBase + blueOffset +1.

	"Three possible cases here: RGB in one word (pixel); RG in one, and G in another; R in one, GB in another"
	redPixelIndex = bluePixelIndex
		ifTrue: [						"First case: RGB in the same word"
			redOffset <= clipRight ifTrue: [
				countWord := edgeCounts bytesAt: redPixelIndex.
				redCount := (countWord at: 3) + increment bitAnd: 16rFF.
				countWord at: 3 put: redCount.
				greenCount := (countWord at: 2) + increment bitAnd: 16rFF.
				countWord at: 2 put: greenCount.
				blueCount := (countWord at: 1) + increment bitAnd: 16rFF.
				countWord at: 1 put: blueCount.
				edgeCounts bytesAt: redPixelIndex put: countWord.
				affectedBitsIndex := redPixelIndex-1>>4+1.
				(affectedBits at: affectedBitsIndex) = 1 ifFalse: [
					affectedBits at: affectedBitsIndex put: 1 ] ].
		]
		ifFalse: [
			redPixelIndex = greenPixelIndex
				ifTrue: [				"Second case: RG in one word, B in previous"
					redOffset <= clipRight ifTrue: [
						countWord := edgeCounts bytesAt: redPixelIndex.
						redCount := (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						greenCount := (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						edgeCounts bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord := edgeCounts bytesAt: bluePixelIndex.
						blueCount := (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCounts bytesAt: bluePixelIndex put: countWord ].
				]
				ifFalse: [			"Third case: R in one word, GB in the previous"
					redOffset <= clipRight ifTrue: [
						countWord := edgeCounts bytesAt: redPixelIndex.
						redCount := (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						edgeCounts bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord := edgeCounts bytesAt: bluePixelIndex.
						greenCount := (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						blueCount := (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCounts bytesAt: bluePixelIndex put: countWord ].
				].
				affectedBitsIndex := redPixelIndex-1>>4+1.
				(affectedBits at: affectedBitsIndex) = 1 ifFalse: [
					affectedBits at: affectedBitsIndex put: 1 ].
				affectedBitsIndex2 := bluePixelIndex-1>>4+1.
				affectedBitsIndex2 = affectedBitsIndex ifFalse: [
					(affectedBits at: affectedBitsIndex2) = 1 ifFalse: [
						affectedBits at: affectedBitsIndex2 put: 1 ]].
		].! !
!VectorEngineWholePixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/3/2025 13:32:31' prior: 50379780!
  updateAlphasForX: x y: y
	| distanceToAxisSquared alpha t b l r prevAlpha dx dy pixelIndex bit lastUpdated affectedBitsIndex |

	"If dashed strokes, only draw if in a dash, not in a gap."
	dashBitLength = 0.0 ifFalse: [
		"Compute trajectory length. This is not precise. In many cases the actual hop used is smaller than this."
		trajectoryLength := trajectoryLength + hop.
		"Correct behavior for negative offset given by #floor and #\\"
		bit := (trajectoryLength / dashBitLength + dashBitOffset) floor \\ dashBitCount.
		(dashedStrokeBits bitAt: dashBitCount - bit) = 1 ifFalse: [ ^self ]].

	"Compute affected rect. Honor clipRect."
	t := (y - swDilatedHalf + 1) truncated.			"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	t < clipTop ifTrue: [ t := clipTop ].
	b := (y + swDilatedHalf) truncated.
	b > clipBottom ifTrue: [ b := clipBottom ].
	l := (x - swDilatedHalf + 1) truncated.			"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	l < clipLeft ifTrue: [ l := clipLeft ].
	r := (x + swDilatedHalf) truncated.
	r > clipRight ifTrue: [ r := clipRight ].

lastUpdated := -1.
	t to: b do: [ :displayY |
		pixelIndex := displayY * targetWidth + l.
		dy := displayY - y.
		l to: r do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			prevAlpha := alphaMask at: pixelIndex.
			prevAlpha = 16r7F ifFalse: [
				dx := displayX - x.
				distanceToAxisSquared := (dx*dx) + (dy*dy).
				distanceToAxisSquared < swDilatedHalfSquared
					ifTrue: [
						alpha := distanceToAxisSquared <= swErodedHalfSquared
							ifTrue: [ 16r7F ]
							ifFalse: [ (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated ].
						alpha > prevAlpha ifTrue: [
							
							"ESTO"
							"solo pixelIndex>>4 en slang"
							affectedBitsIndex := pixelIndex-1>>4+1.
							lastUpdated = affectedBitsIndex
								ifFalse: [
									"Esta pobre optimizacion baja a la 3ra parte.
									Lo óptimo sería la 1ma parte!!"
									(affectedBits at: affectedBitsIndex) = 1
										ifFalse: [
											affectedBits at: affectedBitsIndex put: 1.
											lastUpdated := affectedBitsIndex ]].
									"esto obviamente reescribe todavia muchas veces, de llamados anteriores.
									optimizar si es posible."
							
							alphaMask at: pixelIndex put: alpha ]]]]]! !
!VectorEngineWholePixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/3/2025 14:37:12' prior: 17003554!
                              updateEdgeCountAtX: x y: y
	"Compute edges intersecting with this horizontal line, for fills.
		
	See https://en.wikipedia.org/wiki/Nonzero-rule .

Where it says 'pick a ray in any direction', we pick an horizontal ray pointing to the left. This means that for any point (actually for every pixel) p1=(x1, y1), we record any crossings of y1, i.e. any sequence of path points (... pp1, pp2, .....) where the jump from pp1 to pp2 crosses y1, and pp1.x and pp2.x are at the left of x1. If the path is going up, it is clockwwise. If it is going down, it is counter clockwise.

As an additional optimization, as we need to store for every pixel all the crossings to the left, what we actually store are the crossings at each pixel (i.e. within 1 pixel distance to the left). Then, when we use them, the algorithms iterates from left to right, and accumulates the counters from previous pixels.
	"

	| thisYTruncated pixelY pixelIndex increment count pixelX affectedBitsIndex |

	thisYTruncated := y truncated.
	thisYTruncated = prevYTruncated ifTrue: [
		^ self].
	(thisYTruncated between: clipTop-1 and: clipBottom) ifFalse: [
		^ self ].
	prevYTruncated = 16r3FFFFFFF ifTrue: [ 
		^ prevYTruncated := thisYTruncated ].

	"All edge count at the left of the clipRect are added there (at the left of the clipRect).
	The effect is the same, and we need to clean up less stuff afterwards.
	More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses."
	pixelX := (x+1) truncated max: clipLeft.		"take the next pixel center to the right of x"
	pixelX <= clipRight ifTrue: [
		pixelY := thisYTruncated max: prevYTruncated.
		increment := (thisYTruncated - prevYTruncated) sign.
		pixelIndex := pixelY * targetWidth + pixelX +1.
		count := edgeCounts at: pixelIndex.
		count := count + increment bitAnd: 16rFF.
		edgeCounts at: pixelIndex put: count.
		affectedBitsIndex := pixelIndex-1>>4+1.
		(affectedBits at: affectedBitsIndex) = 1 ifFalse: [
			affectedBits at: affectedBitsIndex put: 1 ]].
	prevYTruncated := thisYTruncated.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7207-affectedBits-set-JuanVuletich-2025Apr03-15h35m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7112] on 5 April 2025 at 12:25:56 pm'!
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/5/2025 12:24:51' prior: 50380963 overrides: 17002504!
               blendFillOnly
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realFillColor opaqueFillColorWord realOpaqueFillColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ fillColor alpha = 1.0 ]) ifTrue: [
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		isRedInside := isGreenInside := isBlueInside := false.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment | isGreenInside ifTrue: [
				"Some alpha not zero in this segment of length delta, or painting inside the shape."
				(segmentLength min: (spanRight-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphasWord := "16r00000000" #[16r00 16r00 16r00 16r00].
					alphasOrEdgeCountsInThisSegment ifTrue: [
						edgesThisPixel := edgeCounts bytesAt: pixelIndex.
						edgeCounts at: pixelIndex put: 0.
						edgesThisPixelR := edgesThisPixel at: 3.
						edgesThisPixelG := edgesThisPixel at: 2.
						edgesThisPixelB := edgesThisPixel at: 1.
						"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
						edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
						edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
						edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
						edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
						edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
						edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
						isRedInside := edgesUpToThisPixelR ~= 0.
						isGreenInside := edgesUpToThisPixelG ~= 0.
						isBlueInside := edgesUpToThisPixelB ~= 0.
						strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
						strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
							alphaMask at: pixelIndex put: 0 ]].
					
					(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
						(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
							ifTrue: [
								realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
								realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]
							ifFalse: [
								(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
									realFillColor := fillColor.  fillColor := fillColor alpha: fillColor alpha * 0.75.
									realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]].
						
						(opaqueFillColorWord ~= 0 and: [strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] and: [ isGreenInside ]])
							ifTrue: [ "If no alpha, and isGreenInside is true, isRedInside and isBlueInside are also true"
								"Fully inside the shape, far from anti aliasing. Color is opaque. Target is too. Just overwrite with fill color."
								targetForm bits at: pixelIndex put: opaqueFillColorWord.
								morphIds at: pixelIndex put: currentMorphId ]
							ifFalse: [
								"General case. (strokeAntiAliasAlphasWord = 0 and outside the shape means NOP)"
								(strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] or: [ isGreenInside ]) ifTrue: [
									"If no alpha, and isGreenInside is true, isRedInside and isBlueInside are also true
									If there is any alpha, isRedInside, isGreenInside, isBlueInside may be different."
									self blendFillOnlyAt: pixelIndex
										redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
										antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].
						
						mustResetColor ifTrue: [
							fillColor := realFillColor. opaqueFillColorWord := realOpaqueFillColorWord. mustResetColor := false ]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
		
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/5/2025 11:59:12' prior: 50381116 overrides: 17002509!
                 blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColors realStrokeColor realFillColor opaqueStrokeColorWord opaqueFillColorWord realOpaqueStrokeColorWord realOpaqueFillColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColors := false.
	opaqueStrokeColorWord := 0.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha * fillColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000.
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		isRedInside := isGreenInside := isBlueInside := false.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment | isGreenInside ifTrue: [
				"Some alpha not zero in this segment of length delta, or painting inside the shape."
				(segmentLength min: (spanRight-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphasWord := "16r00000000" #[16r00 16r00 16r00 16r00].
					alphasOrEdgeCountsInThisSegment ifTrue: [
						edgesThisPixel := edgeCounts bytesAt: pixelIndex.
						edgeCounts at: pixelIndex put: 0.
						edgesThisPixelR := edgesThisPixel at: 3.
						edgesThisPixelG := edgesThisPixel at: 2.
						edgesThisPixelB := edgesThisPixel at: 1.
						"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
						edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
						edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
						edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
						edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
						edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
						edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
						isRedInside := edgesUpToThisPixelR ~= 0.
						isGreenInside := edgesUpToThisPixelG ~= 0.
						isBlueInside := edgesUpToThisPixelB ~= 0.
						strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
						strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
							alphaMask at: pixelIndex put: 0 ]].
					
					(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
						(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel ])
							ifTrue: [
								realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
								realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
								realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
								realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]
							ifFalse: [
								(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
									realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
									realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
									realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
									realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]].
						
						strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00]
							ifTrue: [ 		"Not in the stroke at all. Either fully in the fill, or outside the shape (pixel is unaffected)."
								isGreenInside
									ifTrue: [
										"Fully inside the fill, far from anti aliasing. (Here isGreenInside also implies isRedInside and isBlueInside)"
										opaqueFillColorWord ~= 0
											ifTrue: [
												"Fill color is opaque. Target is too. Just overwrite with fill color."
												targetForm bits at: pixelIndex put: opaqueFillColorWord.
												morphIds at: pixelIndex put: currentMorphId ]
											ifFalse: [
												"Translucent color or target. Do proper blend of fill over target."
												self blendFillOnlyAt: pixelIndex
													redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
													antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]]
							ifFalse: [		"At least one subpixel in the stroke."
								strokeAntiAliasAlphasWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00]
									ifTrue: [
										"Fully inside the stroke, far from anti aliasing."
										opaqueStrokeColorWord ~= 0
											ifTrue: [
												"Stroke color is opaque. Target is too. Just overwrite with stroke color."
												targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
												morphIds at: pixelIndex put: currentMorphId ]
											ifFalse: [
												"Translucent color or target. Do proper blend of stroke over target."
												self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]
									ifFalse: [
										"In an anti aliased part of the stroke. Either blend stroke over background, or pre-mix stroke and fill."
										self blendStrokeAndFillAt: pixelIndex
											redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
											antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].					
						
						mustResetColors ifTrue: [
							strokeColor := realStrokeColor. fillColor := realFillColor.
							opaqueStrokeColorWord := realOpaqueStrokeColorWord. opaqueFillColorWord := realOpaqueFillColorWord.
							mustResetColors := false ]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
		
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/5/2025 11:59:18' prior: 50381329 overrides: 17002514!
 blendStrokeOnly
	"Blends stroke color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realStrokeColor opaqueStrokeColorWord realOpaqueStrokeColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueStrokeColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment ifTrue: [
				"Some alpha not zero in this segment of length delta"
				(segmentLength min: (spanRight-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
					"At least one subpixel in the stroke."
					strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] ifFalse: [
						alphaMask at: pixelIndex put: 0.
						
						(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
							(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
								ifTrue: [
									realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
									realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]
								ifFalse: [
									(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
										realStrokeColor := strokeColor.  strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
										realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]].
							
							(opaqueStrokeColorWord ~= 0 and: [strokeAntiAliasAlphasWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00]])
								ifTrue: [
									"Fully inside the stroke, far from anti aliasing. Color is opaque. Target is too. Just overwrite with stroke color."
									targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
									morphIds at: pixelIndex put: currentMorphId ]
								ifFalse: [
									"At least one subpixel in the anti aliasing area of the stroke, or color is translucent, or target translucency is desired."
									self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord ].
							
							mustResetColor ifTrue: [
								strokeColor := realStrokeColor. opaqueStrokeColorWord := realOpaqueStrokeColorWord. mustResetColor := false ]]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
		
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/5/2025 11:51:45' prior: 50381444 overrides: 17002504!
           blendFillOnly
	"Blends fill color over background.
	If targetAssumedOpaque is false, target translucency is computed correctly.
	If targetAssumedOpaque is true (and target translucency is actually 255 on input), an optimization is made and target translucency is set to 255.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]."

	| edgesUpToThisPixel edgesThisPixel pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realFillColor opaqueFillColorWord realOpaqueFillColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ fillColor alpha = 1.0 ]) ifTrue: [
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment  | (edgesUpToThisPixel ~= 0) ifTrue: [
				"Some alpha not zero in this segment of length delta, or painting inside the shape."
				(segmentLength min: (spanRight-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphaBits := 0.
					alphasOrEdgeCountsInThisSegment ifTrue: [
						edgesThisPixel := edgeCounts at: pixelIndex.
						edgesThisPixel = 0 ifFalse: [
							edgeCounts at: pixelIndex put: 0.
							"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
							edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
							edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
						strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
						strokeAntiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ]].
					
					(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
						(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
							ifTrue: [
								realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
								realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]
							ifFalse: [
								(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
									realFillColor := fillColor.  fillColor := fillColor alpha: fillColor alpha * 0.75.
									realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]].
						
						edgesUpToThisPixel = 0
							ifFalse: [ "Inside the shape"
								(strokeAntiAliasAlphaBits = 0 and: [ opaqueFillColorWord ~= 0 ])
									ifTrue: [
										"Fully inside the shape, far from anti aliasing. Color is opaque. Target is too. Just overwrite with fill color."
										targetForm bits at: pixelIndex put: opaqueFillColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Inside the shape. Turn stroke anti aliasing into fill anti aliasing."
										self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: 127 - strokeAntiAliasAlphaBits ]]
							ifTrue: [ "Still in the anti aliasing area, but outside the shape, strictly speaking."
								strokeAntiAliasAlphaBits = 0 ifFalse: [
									self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]].
						
						mustResetColor ifTrue: [
							fillColor := realFillColor. opaqueFillColorWord := realOpaqueFillColorWord. mustResetColor := false ]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
			
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/5/2025 12:04:27' prior: 50381574 overrides: 17002509!
                             blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| edgesUpToThisPixel edgesThisPixel pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColors realStrokeColor realFillColor opaqueStrokeColorWord opaqueFillColorWord realOpaqueStrokeColorWord realOpaqueFillColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColors := false.
	opaqueStrokeColorWord := 0.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha * fillColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000.
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment  | (edgesUpToThisPixel ~= 0) ifTrue: [
				"Some alpha not zero in this segment of length delta, or painting inside the shape."
				(segmentLength min: (spanRight-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphaBits := 0.
					alphasOrEdgeCountsInThisSegment ifTrue: [
						edgesThisPixel := edgeCounts at: pixelIndex.
						edgesThisPixel = 0 ifFalse: [
							edgeCounts at: pixelIndex put: 0.
							"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
							edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
							edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
						strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
						strokeAntiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ]].
					
					(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
						(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel ])
							ifTrue: [
								realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
								realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
								realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
								realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]
							ifFalse: [
								(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
									realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
									realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
									realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
									realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]].
						
						strokeAntiAliasAlphaBits = 0
							ifTrue: [ 		"Not in the stroke at all. Either fully in the fill, or outside the shape (pixel is unaffected)."
								edgesUpToThisPixel ~= 0
									ifTrue: [
										"Fully inside the fill, far from anti aliasing."
										opaqueFillColorWord ~= 0
											ifTrue: [
												"Fill color is opaque. Target is too. Just overwrite with fill color."
												targetForm bits at: pixelIndex put: opaqueFillColorWord.
												morphIds at: pixelIndex put: currentMorphId ]
											ifFalse: [
												"Translucent color or target. Do proper blend of fill over target."
												self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: 127 ]]]
							ifFalse: [		"In the stroke."
								strokeAntiAliasAlphaBits = 127
									ifTrue: [
										"Fully inside the stroke, far from anti aliasing."
										opaqueStrokeColorWord ~= 0
											ifTrue: [
												"Stroke color is opaque. Target is too. Just overwrite with stroke color."
												targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
												morphIds at: pixelIndex put: currentMorphId ]
											ifFalse: [
												"Translucent color or target. Do proper blend of stroke over target."
												self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: 127 ]]
									ifFalse: [
										"In an anti aliased part of the stroke. Either blend stroke over background, or pre-mix stroke and fill."
										edgesUpToThisPixel ~= 0
											ifTrue: [ 
												"Inside the shape. Blend stroke and fill, blend result over target."
												self blendStrokeAndFillAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]
											ifFalse: [
												"In the outer anti aliasing area of the stroke. Blend stroke over background."
												self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]]].
						
						mustResetColors ifTrue: [
							strokeColor := realStrokeColor. fillColor := realFillColor.
							opaqueStrokeColorWord := realOpaqueStrokeColorWord. opaqueFillColorWord := realOpaqueFillColorWord.
							mustResetColors := false ]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
			
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/5/2025 12:06:24' prior: 50381757 overrides: 17002514!
                               blendStrokeOnly
	"Blends stroke color over background.
	If targetAssumedOpaque is false, target translucency is computed correctly.
	If targetAssumedOpaque is true (and target translucency is actually 255 on input), an optimization is made and target translucency is set to 255.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realStrokeColor opaqueStrokeColorWord realOpaqueStrokeColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := spanTop * 2 + 1.
	mustResetColor := false.
	opaqueStrokeColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	spanTop to: spanBottom do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= spanLeft ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= spanRight ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + spanLeft + 1. "+1 solo en Smalltalk"
		displayX := spanLeft.
		[ displayX <= spanRight ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment ifTrue: [
				"Some alpha not zero in this segment of length delta"
				(segmentLength min: (spanRight-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
					strokeAntiAliasAlphaBits = 0 ifFalse: [			"In the stroke"
						alphaMask at: pixelIndex put: 0.
						
						(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
							(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
								ifTrue: [
									realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
									realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]
								ifFalse: [
									(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
										realStrokeColor := strokeColor.  strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
										realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]].
							
							(opaqueStrokeColorWord ~= 0 and: [strokeAntiAliasAlphaBits = 127])
								ifTrue: [
									"Optimize inner part of a wide stroke: Fully opaque stroke (and target), no anti aliasing, no clipping at this point."
									targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
									morphIds at: pixelIndex put: currentMorphId ]
								ifFalse: [
									"In the anti aliasing area of the stroke, or color is translucent, or target translucency is desired."
									self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ].
							
							mustResetColor ifTrue: [
								strokeColor := realStrokeColor. opaqueStrokeColorWord := realOpaqueStrokeColorWord. mustResetColor := false ]]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
		
		clippingSpecIndex := clippingSpecIndex + 2 ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7208-affectedBits-use-JuanVuletich-2025Apr05-10h29m-jmv.005.cs.st----!

'From Cuis7.3 [latest update: #7113] on 6 April 2025 at 1:48:51 pm'!
!VectorEngine class methodsFor: 'experiments' stamp: 'jmv 4/6/2025 13:47:42' prior: 17001144!
                         experimentHopsPerPixel2
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 2: Stroke of various widths, no fill
	VectorEngine experimentHopsPerPixel2
	"
	"In the following script, err is the error admitted. It is consistent with a hop of 0.5 for fills."
	"
	| err r rads hop hopx |
	'------' print.
	err := 0.25.
	#(0.001 0.01 0.1 0.2 0.25 0.3 0.5 1 1.4 10 100 200 265 400 800 1600 3200 6400 12800) do: [ :w |
		r := w / 2.
		rads := (1-(err/r)) arcCos.
		hop := rads sin * r. 'theoretical'.
		hopx := w sqrt / 2.0 max: 0.5. 'approximated'.
		{r. hop. hopx} print ].
	"
	| d engine f1 f2 hops1 hops2 strokeWidth |
	hops1 := 200.
	hops1 := 20.
	hops2 := 3.
	strokeWidth := 1.4.
	f1 := Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine := self onForm: f1 subPixelAntiAliasing: true.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hop' put: 1.0 / hops1.
		engine
			moveTo: 50@30;
			lineTo: 190@135; lineTo: 50 @50;
			lineTo: 135@390; lineTo: 30@50;
			lineToFirstPoint ].
	f1 displayAt: 0@0.

	f2 := Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine := self onForm: f2 subPixelAntiAliasing: true.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hop' put: 1.0 / hops2.
		engine
			moveTo: 50@30;
			lineTo: 190@135; lineTo: 50@50;
			lineTo: 135@390; lineTo: 30@50;
			lineToFirstPoint ].
	f2 displayAt: 220@0.

Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d := (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d := (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !
!VectorEngineBoundsFinder methodsFor: 'stroke & fill' stamp: 'jmv 4/6/2025 13:33:35' prior: 17001286!
     basicStrokeWidth: aStrokeWidth color: aStrokeColor do: pathCommandsBlock ensureClosePath: ensureClosePath
	"Prepare parameters for drawing stroke."

	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self ].
	aStrokeWidth = 0.0 ifTrue: [ ^self ].
	self pvtStrokeWidth: (aStrokeWidth max: antiAliasingWidth).
	self pvtHopLength: (aStrokeWidth sqrt / 2.0 max: 0.5). "See #experimentHopsPerPixel2"
	self doPath: pathCommandsBlock ensureClosePath: ensureClosePath.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/6/2025 13:48:03' prior: 50379421!
 basicStrokeWidth: aStrokeWidth color: aStrokeColor dashedStrokeBits: onOffBitSequence dashBitCount: numberOfBitsInSequence dashBitLength: lengthOfEachBit dashBitOffset: offset do: pathCommandsBlock ensureClosePath: ensureClosePath
	"Prepare parameters for drawing stroke.
	Do dashed strokes. This spec is periodic, the pattern is repeated as needed.
		onOffBitSequence is an integer number, a sequence of bits specifying on/off parts
		numberOfBitsInSequence is the number of bits in onOffBitSequence
		lengthOfEachBit is exactly that.
		Offset can be used to do 'walking dashes' effects. It is an integer in [0 .. numberOfBitsInSequence-1]."

	| sharper apparentWeight |
	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self ].
	aStrokeWidth = 0.0 ifTrue: [ ^self ].
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"There are two possible strategies when requested stroke width is narrower than anti aliasing filter.
			To more effectively avoid aliasing, set sharper to false.
			To draw sharper thin lines, at the price of very little extra aliasing in them, set sharper to true.
			This could be turned into a Preference."
			sharper := true.
			sharper ifTrue: [
				"If the requested stroke width is used, filter will be clipped, resulting in an incorrect weight for the stroke."
				apparentWeight := ((aStrokeWidth squared / antiAliasingWidth) + (2.0 * aStrokeWidth) + antiAliasingWidth) / 4.0.
				"{'(sharper)desired weight'. aStrokeWidth. 'but would get'. apparentWeight. 'correction'. aStrokeWidth / apparentWeight} print."
				self pvtStrokeWidth: aStrokeWidth.
				self pvtStrokeColor: (aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / apparentWeight)]
			ifFalse: [
				"If the requested stroke width is too thin, make them wide enough to be properly sampled."
				"{'(wider)desired weight'. aStrokeWidth. 'but would get'. antiAliasingWidth. 'correction'. aStrokeWidth / antiAliasingWidth} print."
				self pvtStrokeWidth: antiAliasingWidth.
				self pvtStrokeColor: (aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / antiAliasingWidth)]
			]
		ifFalse: [
			self pvtStrokeWidth: aStrokeWidth.
			self pvtStrokeColor: aStrokeColor ].
	self pvtFillColor: nil.
	self pvtHopLength: (aStrokeWidth sqrt / 2.0 max: 0.5).  "See #experimentHopsPerPixel2"

	"For dashed strokes"
	dashedStrokeBits := onOffBitSequence.
	dashBitCount := numberOfBitsInSequence.
	dashBitLength := lengthOfEachBit.
	dashBitOffset := offset.

	self doPath: pathCommandsBlock ensureClosePath: ensureClosePath.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/6/2025 13:43:47' prior: 50379590!
 basicStrokeWidth: aStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	(aFillColor isNil or: [ aFillColor alpha = 0.0]) ifTrue: [
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: false ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		canvas ifNotNil: [ canvas initializePath ].
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: true ].

	self pvtStrokeWidth: aStrokeWidth.
	self pvtStrokeColor: aStrokeColor.
	self pvtFillColor: aFillColor.
	aStrokeWidth < 4
		ifTrue: [ "See #experimentHopsPerPixel1"
			self pvtHopLength: 0.5 ]
		ifFalse: [ "See #experimentHopsPerPixel2."
			"Correct edgeCount for fills requires visiting at least once every y coordinate, hop can not be larger than 1."
			self pvtHopLength: 1.0 ].	

	"Only used for strokes with no fill"
	dashedStrokeBits := 0.
	dashBitCount := 0.
	dashBitLength := 0.0.
	dashBitOffset := 0.

	self doPath: pathCommandsBlock ensureClosePath: true.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/6/2025 13:43:59' prior: 50379650!
        fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	(aFillColor isNil or: [ aFillColor alpha = 0.0]) ifTrue: [ ^ self ].
	self pvtStrokeWidth: 0.0.
	self pvtStrokeColor: nil.
	self pvtFillColor: aFillColor.
	self pvtHopLength: 0.5.		"See #experimentHopsPerPixel3"

	"Only used for strokes with no fill"
	dashedStrokeBits := 0.
	dashBitCount := 0.
	dashBitLength := 0.0.
	dashBitOffset := 0.

	self doPath: pathCommandsBlock ensureClosePath: true.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7209-Optimization-Alphas-CoarserHopForWideStrokes-JuanVuletich-2025Apr06-12h42m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7114] on 7 April 2025 at 11:25:45 am'!

VectorEngineDrawer subclass: #VectorEngineSmalltalk
	instanceVariableNames: 'spanLeft spanTop spanRight spanBottom prevYTruncated prevYRounded leftAtThisY rightAtThisY aawScaledInverse swDilatedHalf swDilatedHalfSquared swErodedHalfSquared trajectoryLength needsFullAlphaCircle '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineSmalltalk category: #'Morphic-Support' stamp: 'Install-7210-Optimization-UseRingNibWhenPossible-JuanVuletich-2025Apr07-10h45m-jmv.001.cs.st 5/24/2025 10:43:19'!
VectorEngineDrawer subclass: #VectorEngineSmalltalk
	instanceVariableNames: 'spanLeft spanTop spanRight spanBottom prevYTruncated prevYRounded leftAtThisY rightAtThisY aawScaledInverse swDilatedHalf swDilatedHalfSquared swErodedHalfSquared trajectoryLength needsFullAlphaCircle'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!
!VectorEngine methodsFor: 'private' stamp: 'jmv 4/7/2025 10:47:53'!
             pvtStrokeWidth: aNumber hop: aFloat

	strokeWidth := aNumber.
	hop := aFloat.! !
!VectorEngineBoundsFinder methodsFor: 'private' stamp: 'jmv 4/7/2025 11:04:07' overrides: 50383858!
           pvtStrokeWidth: aNumber hop: aFloat

	strokeWidth := aNumber.
	hop := aFloat.
	swDilatedHalf := strokeWidth + antiAliasingWidth * 0.5.! !
!VectorEngineSmalltalk methodsFor: 'private' stamp: 'jmv 4/7/2025 11:11:52' overrides: 50383858!
                     pvtStrokeWidth: aNumber hop: aFloat

	| swErodedHalf |
	strokeWidth := aNumber.
	hop := aFloat.
	swDilatedHalf := strokeWidth + antiAliasingWidth * 0.5.
	swDilatedHalfSquared := swDilatedHalf * swDilatedHalf.
	"swErodedHalf is the inner radious of the alphas ring.
	See #updateAlphasForX:y:"
	swErodedHalf := strokeWidth - antiAliasingWidth * 0.5 -hop - 2.
	swErodedHalfSquared := swErodedHalf * swErodedHalf abs.! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/7/2025 11:04:22' overrides: 50383858!
                             pvtStrokeWidth: aNumber hop: aFloat

	strokeWidth := aNumber.
	hop := aFloat.
	self primStrokeWidth: strokeWidth hop: hop.! !
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 4/7/2025 11:02:56'!
               primAntiAliasingWidth: aNumber subPixelDelta: otherFloat
	<primitive: 'primAntiAliasingWidthsubPixelDelta' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 4/7/2025 11:00:15'!
          primStrokeWidth: aNumber hop: aFloat
	<primitive: 'primStrokeWidthHop' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineBoundsFinder methodsFor: 'stroke & fill' stamp: 'jmv 4/7/2025 11:13:02' prior: 50383645!
                           basicStrokeWidth: aStrokeWidth color: aStrokeColor do: pathCommandsBlock ensureClosePath: ensureClosePath
	"Prepare parameters for drawing stroke."

	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self ].
	aStrokeWidth = 0.0 ifTrue: [ ^self ].
	self
		pvtStrokeWidth: (aStrokeWidth max: antiAliasingWidth)
		hop: (aStrokeWidth sqrt / 2.0 max: 0.5). "See #experimentHopsPerPixel2"
	self doPath: pathCommandsBlock ensureClosePath: ensureClosePath.! !
!VectorEngineBoundsFinder methodsFor: 'stroke & fill' stamp: 'jmv 4/7/2025 11:13:28' prior: 17001302!
       fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	(aFillColor isNil or: [ aFillColor alpha = 0.0]) ifTrue: [ ^ self ].
	self pvtStrokeWidth: 0.0 hop: 0.5.	"See #experimentHopsPerPixel3"
	self doPath: pathCommandsBlock ensureClosePath: true.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/7/2025 11:24:26' prior: 50383663!
        basicStrokeWidth: aStrokeWidth color: aStrokeColor dashedStrokeBits: onOffBitSequence dashBitCount: numberOfBitsInSequence dashBitLength: lengthOfEachBit dashBitOffset: offset do: pathCommandsBlock ensureClosePath: ensureClosePath
	"Prepare parameters for drawing stroke.
	Do dashed strokes. This spec is periodic, the pattern is repeated as needed.
		onOffBitSequence is an integer number, a sequence of bits specifying on/off parts
		numberOfBitsInSequence is the number of bits in onOffBitSequence
		lengthOfEachBit is exactly that.
		Offset can be used to do 'walking dashes' effects. It is an integer in [0 .. numberOfBitsInSequence-1]."

	| sharper apparentWeight strokeColorToUse strokeWidthToUse |
	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self ].
	aStrokeWidth = 0.0 ifTrue: [ ^self ].
	strokeWidthToUse := aStrokeWidth.
	strokeColorToUse := aStrokeColor.
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"There are two possible strategies when requested stroke width is narrower than anti aliasing filter.
			To more effectively avoid aliasing, set sharper to false.
			To draw sharper thin lines, at the price of very little extra aliasing in them, set sharper to true.
			This could be turned into a Preference."
			sharper := true.
			sharper ifTrue: [
				"If the requested stroke width is used, filter will be clipped, resulting in an incorrect weight for the stroke."
				apparentWeight := ((aStrokeWidth squared / antiAliasingWidth) + (2.0 * aStrokeWidth) + antiAliasingWidth) / 4.0.
				"{'(sharper)desired weight'. aStrokeWidth. 'but would get'. apparentWeight. 'correction'. aStrokeWidth / apparentWeight} print."
				strokeColorToUse := aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / apparentWeight ]
			ifFalse: [
				"If the requested stroke width is too thin, make them wide enough to be properly sampled."
				"{'(wider)desired weight'. aStrokeWidth. 'but would get'. antiAliasingWidth. 'correction'. aStrokeWidth / antiAliasingWidth} print."
				strokeWidthToUse := antiAliasingWidth.
				strokeColorToUse := aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / antiAliasingWidth ]].
	self pvtStrokeWidth: strokeWidthToUse hop: (aStrokeWidth sqrt / 2.0 max: 0.5).  "See #experimentHopsPerPixel2"
	self pvtStrokeColor: strokeColorToUse.
	self pvtFillColor: nil.

	"For dashed strokes"
	dashedStrokeBits := onOffBitSequence.
	dashBitCount := numberOfBitsInSequence.
	dashBitLength := lengthOfEachBit.
	dashBitOffset := offset.

	self doPath: pathCommandsBlock ensureClosePath: ensureClosePath.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/7/2025 11:17:41' prior: 50383745!
   basicStrokeWidth: aStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	| hopToUse |
	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	(aFillColor isNil or: [ aFillColor alpha = 0.0]) ifTrue: [
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: false ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		canvas ifNotNil: [ canvas initializePath ].
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: true ].

	hopToUse := aStrokeWidth < 4
		ifTrue: [ 0.5 ] "See #experimentHopsPerPixel1"
		ifFalse: [ 1.0 ]. "See #experimentHopsPerPixel2."
				"Correct edgeCount for fills requires visiting at least once every y coordinate, hop can not be larger than 1."
	self pvtStrokeWidth: aStrokeWidth hop: hopToUse.
	self pvtStrokeColor: aStrokeColor.
	self pvtFillColor: aFillColor.

	"Only used for strokes with no fill"
	dashedStrokeBits := 0.
	dashBitCount := 0.
	dashBitLength := 0.0.
	dashBitOffset := 0.

	self doPath: pathCommandsBlock ensureClosePath: true.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/7/2025 11:18:07' prior: 50383804!
            fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	(aFillColor isNil or: [ aFillColor alpha = 0.0]) ifTrue: [ ^ self ].
	self pvtStrokeWidth: 0.0 hop: 0.5. "See #experimentHopsPerPixel3"
	self pvtStrokeColor: nil.
	self pvtFillColor: aFillColor.

	"Only used for strokes with no fill"
	dashedStrokeBits := 0.
	dashBitCount := 0.
	dashBitLength := 0.0.
	dashBitOffset := 0.

	self doPath: pathCommandsBlock ensureClosePath: true.! !
!VectorEngineSmalltalk methodsFor: 'primitive algorithms' stamp: 'jmv 4/6/2025 15:38:40' prior: 50337229!
   arcCenterX: cx centerY: cy radiusX: rx radiusY: ry start: startAngle sweep: sweepAngle rotationCos: thetaCos rotationSin: thetaSin

	| dx dy trx try tcx tcy center angle xp yp x y d hops |
	trajectoryLength := 0.0.
	needsFullAlphaCircle := true.
	
	dx := geometryTransformation externalizeDelta: rx@0.
	dy := geometryTransformation externalizeDelta: 0@ry.
	trx := dx r.
	try := dy r.
	hops := ((trx max: try) * sweepAngle abs / hop) truncated + 2.
	d := hops asFloat.
	center := geometryTransformation externalizePosition: cx@cy.
	tcx := center x.
	tcy := center y.
	0 to: hops do: [ :h |
		angle := h / d * sweepAngle + startAngle.
		xp := angle cos * trx.
		yp := angle sin * try.
		x := thetaCos * xp - (thetaSin * yp) + tcx.
		y := thetaSin * xp + (thetaCos * yp) + tcy.
		spanLeft := spanLeft min: x.
		spanTop := spanTop min: y.
		spanRight := spanRight max: x.
		spanBottom := spanBottom max: y.
		self updateAlphasForX: x y: y.
		fillColor notNil ifTrue: [
			self updateEdgeCountAtX: x y: y ].
		self updateContourForX: x y: y. ].! !
!VectorEngineSmalltalk methodsFor: 'primitive algorithms' stamp: 'jmv 4/6/2025 15:38:35' prior: 17002135!
   cubicBezierFromX: xFrom y: yFrom toX: xTo y: yTo control1X: xControl1 y: yControl1 control2X: xControl2 y: yControl2

	| p txFrom tyFrom txTo tyTo txControl1 tyControl1 txControl2 tyControl2 dx dy hops xMinEnd xMaxEnd yMinEnd yMaxEnd t oneLessT increment f2 f3 f1 f23 f4 x y |
	trajectoryLength := 0.0.
	needsFullAlphaCircle := true.
	
	p := geometryTransformation externalizePosition: xFrom@yFrom. txFrom := p x. tyFrom := p y.
	p := geometryTransformation externalizePosition: xTo@yTo. txTo := p x. tyTo := p y.
	p := geometryTransformation externalizePosition: xControl1@yControl1. txControl1 := p x. tyControl1 := p y.
	p := geometryTransformation externalizePosition: xControl2@yControl2. txControl2 := p x. tyControl2 := p y.
	"Factors found by trial and error. Seems to honor hopsPerPixel in the worst case."
	dx := ((txControl1-txFrom) abs max: (txTo-txControl2) abs)*3 max: (txControl2-txControl1) abs*1.5.
	dy := ((tyControl1-tyFrom) abs max: (tyTo-tyControl2) abs)*3 max: (tyControl2-tyControl1) abs*1.5.
	hops := ((dx max: dy) / hop) truncated + 1.

	"This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe."
	xMinEnd := txFrom min: txTo.
	xMaxEnd := txFrom max: txTo.
	yMinEnd := tyFrom min: tyTo.
	yMaxEnd := tyFrom max: tyTo.
	spanLeft := spanLeft min: (xMinEnd min: xMinEnd*0.25 + ((txControl1 min: txControl2)*0.75)).
	spanRight := spanRight max: (xMaxEnd max: xMaxEnd*0.25 + ((txControl1 max: txControl2)*0.75)).
	spanTop := spanTop min: (yMinEnd min: yMinEnd*0.25 + ((tyControl1 min: tyControl2)*0.75)).
	spanBottom := spanBottom max: (yMaxEnd max: yMaxEnd*0.25 + ((tyControl1 max: tyControl2)*0.75)).

	t := 0.0.
	increment := 1.0 / hops.
	[ t < 1.0 ] whileTrue: [
		oneLessT := 1.0 - t.
		f1 := oneLessT * oneLessT * oneLessT.
		f23 := 3.0 * oneLessT * t.
		f2 := f23 * oneLessT.
		f3 := f23 * t.
		f4 := t * t * t.
		x := (f1 * txFrom) + (f2 * txControl1) + (f3 * txControl2) + (f4 * txTo).
		y := (f1 * tyFrom) + (f2 * tyControl1) + (f3 * tyControl2) + (f4 * tyTo).
		self updateAlphasForX: x y: y.
		fillColor notNil ifTrue: [
			self updateEdgeCountAtX: x y: y ].
		self updateContourForX: x y: y.
		t := t + increment. ].
	self updateAlphasForX: txTo y: tyTo.
	fillColor notNil ifTrue: [
		self updateEdgeCountAtX: txTo y: tyTo ].
	self updateContourForX: txTo y: tyTo.! !
!VectorEngineSmalltalk methodsFor: 'primitive algorithms' stamp: 'jmv 4/6/2025 15:38:30' prior: 17002210!
                lineFromX: xFrom y: yFrom toX: xTo y: yTo

	| p txFrom tyFrom txTo tyTo dx dy hops t oneLessT increment x y |
	trajectoryLength := 0.0.
	needsFullAlphaCircle := true.
	
	p := geometryTransformation externalizePosition: xFrom@yFrom. txFrom := p x. tyFrom := p y.
	p := geometryTransformation externalizePosition: xTo@yTo. txTo := p x. tyTo := p y.
	dx := (txTo - txFrom) abs.
	dy := (tyTo - tyFrom) abs.
	hops := ((dx max: dy) / hop) truncated + 1.

	spanLeft := spanLeft min: (txFrom min: txTo).
	spanRight := spanRight max: (txFrom max: txTo).
	spanTop := spanTop min: (tyFrom min: tyTo).
	spanBottom := spanBottom max: (tyFrom max: tyTo).

	t := 0.0.
	increment := 1.0 / hops.
	[ t < 1.0 ] whileTrue: [
		oneLessT := 1.0 - t.
		x := (oneLessT * txFrom) + (t * txTo).
		y := (oneLessT * tyFrom) + (t * tyTo).
		self updateAlphasForX: x y: y.
		fillColor notNil ifTrue: [
			self updateEdgeCountAtX: x y: y ].
		self updateContourForX: x y: y.
		t := t + increment. ].
	self updateAlphasForX: txTo y: tyTo.
	fillColor notNil ifTrue: [
		self updateEdgeCountAtX: txTo y: tyTo ].
	self updateContourForX: txTo y: tyTo.! !
!VectorEngineSmalltalk methodsFor: 'primitive algorithms' stamp: 'jmv 4/6/2025 15:38:24' prior: 17002247!
                      quadraticBezierFromX: xFrom y: yFrom toX: xTo y: yTo controlX: xControl y: yControl

	| p txFrom tyFrom txTo tyTo txControl tyControl dx dy dx2 dy2 xMinEnd xMaxEnd yMinEnd yMaxEnd t oneLessT increment f2 f3 f1 x y t0 x0 y0 length correction |

	"If control point is bogus, just draw a line"
	(xControl = xTo and: [ yControl = yTo ]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].
	(xControl = xFrom and: [ yControl = yFrom ]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].
	
	trajectoryLength := 0.0.
	needsFullAlphaCircle := true.

	p := geometryTransformation externalizePosition: xFrom@yFrom. txFrom := p x. tyFrom := p y.
	p := geometryTransformation externalizePosition: xTo@yTo. txTo := p x. tyTo := p y.
	p := geometryTransformation externalizePosition: xControl@yControl. txControl := p x. tyControl := p y.

	dx := (txTo-txFrom) abs.
	dx2 := (txControl-txFrom) abs.
	dy := (tyTo-tyFrom) abs.
	dy2 := (tyControl-tyFrom) abs.

	"If almost a vertical line, just draw a line. (Ignoring control point)"
	(dx < 1.0 and: [dx2 < 1.0]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].

	"If almost an horizontal line, just draw a line. (Ignoring control point)"
	(dy < 1.0 and: [dy2 < 1.0]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].

	"This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe."
	xMinEnd := txFrom min: txTo.
	xMaxEnd := txFrom max: txTo.
	yMinEnd := tyFrom min: tyTo.
	yMaxEnd := tyFrom max: tyTo.
	spanLeft := spanLeft min: (xMinEnd min: (xMinEnd+txControl) / 2.0).
	spanRight := spanRight max: (xMaxEnd max: (xMaxEnd+txControl) / 2.0).
	spanTop := spanTop min: (yMinEnd min: (yMinEnd+tyControl) / 2.0).
	spanBottom := spanBottom max: (yMaxEnd max: (yMaxEnd+tyControl) / 2.0).

	"Case t = 0.0"
	x := txFrom.
	y := tyFrom.
	self updateAlphasForX: x y: y.
	fillColor notNil ifTrue: [
		self updateEdgeCountAtX: x y: y ].
	self updateContourForX: x y: y.

	"Will be corrected for each hop. This, being close to pointFrom, is a good initial guess for first correction."
	increment := 0.5 / (dx max: dy) min: 0.5.
	t := 0.0.
	[
		t0 := t. x0 := x. y0 := y.
		"Compute next point"
		t := t0 + increment. oneLessT := 1.0 - t.
		f1 := oneLessT * oneLessT. f2 := 2.0 * oneLessT * t. f3 := t * t.
		x := (f1 * txFrom) + (f2 * txControl) + (f3 * txTo).
		y := (f1 * tyFrom) + (f2 * tyControl) + (f3 * tyTo).
		"Now adjust the increment to aim at the required hop length, and recompute next point."
		length := ((x-x0)@(y-y0)) r.
		correction := hop / length.
		[
			increment := increment * correction.
			t := t0 + increment. oneLessT := 1.0 - t.
			f1 := oneLessT * oneLessT. f2 := 2.0 * oneLessT * t. f3 := t * t.
			x := (f1 * txFrom) + (f2 * txControl) + (f3 * txTo).
			y := (f1 * tyFrom) + (f2 * tyControl) + (f3 * tyTo).
			length := ((x-x0)@(y-y0)) r.
			correction := hop / length.
			correction < 1.0]  whileTrue.		   "Keep adjusting if hop would be too big"
		t < 1.0 ]
	whileTrue: [
		self updateAlphasForX: x y: y.
		fillColor notNil ifTrue: [
			self updateEdgeCountAtX: x y: y ].
		self updateContourForX: x y: y ].

	"Case t= 1.0"
	self updateAlphasForX: txTo y: tyTo.
	fillColor notNil ifTrue: [
		self updateEdgeCountAtX: txTo y: tyTo ].
	self updateContourForX: txTo y: tyTo.! !
!VectorEngineSmalltalk methodsFor: 'private' stamp: 'jmv 4/6/2025 15:38:47' prior: 17002454 overrides: 17000862!
                             newTrajectoryFragment

	prevYTruncated := 16r3FFFFFFF.! !
!VectorEngineSubPixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/7/2025 11:11:28' prior: 50382030!
                       updateAlphasForX: x y: y
	| distanceToAxisSquared alpha t b l r alphaWord doUpdate dySquared dx dy pixelIndex dxp bit lastUpdated affectedBitsIndex |
	
	"In a basic implementation, this method computes anti aliasing translucency for all possibly affected pixels as determined by
	the outer radius of the pen nib: swDilatedHalfSquared.
	But usually the next point visited is very close to the last, and there's no real need to fill the inner part of the pen nib as opaque,
	as it was already set. So, unless needsFullAlphaCircle, only the outer ring is computed and stored.
	The inner radius of this ring is swErodedHalfSquared"

	"If dashed strokes, only draw if in a dash, not in a gap."
	dashBitLength = 0.0 ifFalse: [
		"Compute trajectory length. This is not precise. In many cases the actual hop used is smaller than this."
		trajectoryLength := trajectoryLength + hop.
		"This code is robust against #floor and #\\ (and their translation to C, and the C compiler) because dashBitOffset is guaranteed to be non negative."
		bit := (trajectoryLength / dashBitLength + dashBitOffset) floor \\ dashBitCount.
		(dashedStrokeBits bitAt: dashBitCount - bit) = 1 ifFalse: [
			needsFullAlphaCircle := true.
			^self ]].

	"Compute affected rect. Honor clipRect"
	t := (y - swDilatedHalf + 1) truncated.		"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	t < clipTop ifTrue: [ t := clipTop ].
	b := (y + swDilatedHalf) truncated.
	b > clipBottom ifTrue: [ b := clipBottom ].
	l := (x - swDilatedHalf - subPixelDelta + 1) truncated.		"(z+1) truncated works equally well than (z ceiling)"
	l < clipLeft ifTrue: [ l := clipLeft ].
	r := (x + swDilatedHalf + subPixelDelta) truncated.
	r > clipRight ifTrue: [ r := clipRight ].

	lastUpdated := -1.
	t to: b do: [ :displayY |
		pixelIndex := displayY * targetWidth + l.
		dy := displayY - y.
		dySquared := dy * dy.
		l to: r do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			dx := displayX - x.
			distanceToAxisSquared := dx * dx + dySquared. "Use Green subpixel for this."
			(needsFullAlphaCircle or: [distanceToAxisSquared > swErodedHalfSquared]) ifTrue: [
				alphaWord := alphaMask bytesAt: pixelIndex.
				alphaWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00] ifFalse: [
					doUpdate := false.
					"Red"
					dxp := dx - subPixelDelta.
					distanceToAxisSquared := dxp * dxp + dySquared.
					distanceToAxisSquared < swDilatedHalfSquared
						ifTrue: [
							alpha := (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated.
							alpha > (alphaWord at: 3) ifTrue: [
								alphaWord at: 3 put: (alpha min: 16r7F).
								doUpdate := true ]].
					"Green"
					distanceToAxisSquared := dx * dx + dySquared.
					distanceToAxisSquared < swDilatedHalfSquared
						ifTrue: [
							alpha := (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated.
							alpha > (alphaWord at: 2) ifTrue: [
								alphaWord at: 2 put: (alpha min: 16r7F).
								doUpdate := true ]].
					"Blue"
					dxp := dx + subPixelDelta.
					distanceToAxisSquared := dxp * dxp + dySquared.
					distanceToAxisSquared < swDilatedHalfSquared
						ifTrue: [
							alpha := (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated.
							alpha > (alphaWord at: 1) ifTrue: [
								alphaWord at: 1 put: (alpha min: 16r7F).
								doUpdate := true ]].
					doUpdate ifTrue: [
						affectedBitsIndex := pixelIndex-1>>4+1.
						lastUpdated = affectedBitsIndex ifFalse: [ "Slight optimization"
							(affectedBits at: affectedBitsIndex) = 1 ifFalse: [
								affectedBits at: affectedBitsIndex put: 1.
								lastUpdated := affectedBitsIndex ]].
						alphaMask bytesAt: pixelIndex put: alphaWord ]]]]].
	needsFullAlphaCircle := false.! !
!VectorEngineWholePixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/6/2025 15:29:49' prior: 50382301!
      updateAlphasForX: x y: y
	| distanceToAxisSquared alpha t b l r prevAlpha dx dy pixelIndex bit lastUpdated affectedBitsIndex |
	
	"In a basic implementation, this method computes anti aliasing translucency for all possibly affected pixels as determined by
	the outer radius of the pen nib: swDilatedHalfSquared.
	But usually the next point visited is very close to the last, and there's no real need to fill the inner part of the pen nib as opaque,
	as it was already set. So, unless needsFullAlphaCircle, only the outer ring is computed and stored.
	The inner radius of this ring is swErodedHalfSquared"

	"If dashed strokes, only draw if in a dash, not in a gap."
	dashBitLength = 0.0 ifFalse: [
		"Compute trajectory length. This is not precise. In many cases the actual hop used is smaller than this."
		trajectoryLength := trajectoryLength + hop.
		"This code is robust against #floor and #\\ (and their translation to C, and the C compiler) because dashBitOffset is guaranteed to be non negative."
		bit := (trajectoryLength / dashBitLength + dashBitOffset) floor \\ dashBitCount.
		(dashedStrokeBits bitAt: dashBitCount - bit) = 1 ifFalse: [
			needsFullAlphaCircle := true.
			^self ]].

	"Compute affected rect. Honor clipRect."
	t := (y - swDilatedHalf + 1) truncated.			"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	t < clipTop ifTrue: [ t := clipTop ].
	b := (y + swDilatedHalf) truncated.
	b > clipBottom ifTrue: [ b := clipBottom ].
	l := (x - swDilatedHalf + 1) truncated.			"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	l < clipLeft ifTrue: [ l := clipLeft ].
	r := (x + swDilatedHalf) truncated.
	r > clipRight ifTrue: [ r := clipRight ].

	lastUpdated := -1.
	t to: b do: [ :displayY |
		pixelIndex := displayY * targetWidth + l.
		dy := displayY - y.
		l to: r do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			dx := displayX - x.
			distanceToAxisSquared := (dx*dx) + (dy*dy).
			(needsFullAlphaCircle or: [distanceToAxisSquared > swErodedHalfSquared]) ifTrue: [
				prevAlpha := alphaMask at: pixelIndex.
				prevAlpha = 16r7F ifFalse: [
					distanceToAxisSquared < swDilatedHalfSquared
						ifTrue: [
							alpha := (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated.
							alpha > prevAlpha ifTrue: [
								affectedBitsIndex := pixelIndex-1>>4+1.
								lastUpdated = affectedBitsIndex ifFalse: [ "Slight optimization"
									(affectedBits at: affectedBitsIndex) = 1 ifFalse: [
										affectedBits at: affectedBitsIndex put: 1.
										lastUpdated := affectedBitsIndex ]].
								alphaMask at: pixelIndex put: (alpha min: 16r7F) ]]]]]].
	needsFullAlphaCircle := false.! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/7/2025 11:03:07' prior: 50378514 overrides: 17000856!
         initializePath

	super initializePath.

	"Set all plugin state. There might be several instances of this class, all using the same plugin.
	Only one of them will use the plugin during a path draw operation. See class variable AccessLock."
	self
		primTargetBits: targetForm bits
		morphIds: morphIds
		edgeCounts: edgeCounts
		alphaMask: alphaMask
		contour: contour
		targetWidth: targetWidth
		targetHeight: targetHeight.
	self primTargetAssumedOpaque: targetAssumedOpaque.
	self
		primAntiAliasingWidth: antiAliasingWidth asFloat
		subPixelDelta: self subPixelDelta asFloat.
	self primClipLeft: clipLeft clipTop: clipTop clipRight: clipRight clipBottom: clipBottom.
	self primCurrentMorphId: currentMorphId.
	self
		primGeometryTxA11: geometryTransformation a11 asFloat
		a12: geometryTransformation a12 asFloat
		a13: geometryTransformation a13 asFloat
		a21: geometryTransformation a21 asFloat
		a22: geometryTransformation a22 asFloat
		a23: geometryTransformation a23 asFloat.
	self primStrokeWidth: strokeWidth hop: hop asFloat.
	self primStrokeColor: strokeColor.
	self primFillColor: fillColor.

	self primInitializePath.! !

VectorEngineWithPlugin removeSelector: #primStrokeWidth:!

!methodRemoval: VectorEngineWithPlugin #primStrokeWidth: stamp: 'Install-7210-Optimization-UseRingNibWhenPossible-JuanVuletich-2025Apr07-10h45m-jmv.001.cs.st 5/24/2025 10:43:20'!
primStrokeWidth: aNumber
	<primitive: 'primStrokeWidth' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPlugin removeSelector: #primAntiAliasingWidth:subPixelDelta:hopLength:!

!methodRemoval: VectorEngineWithPlugin #primAntiAliasingWidth:subPixelDelta:hopLength: stamp: 'Install-7210-Optimization-UseRingNibWhenPossible-JuanVuletich-2025Apr07-10h45m-jmv.001.cs.st 5/24/2025 10:43:20'!
primAntiAliasingWidth: aNumber subPixelDelta: otherFloat hopLength: anotherFloat
	<primitive: 'primAntiAliasingWidthsubPixelDeltaHopLength' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPlugin removeSelector: #pvtStrokeWidth:!

!methodRemoval: VectorEngineWithPlugin #pvtStrokeWidth: stamp: 'Install-7210-Optimization-UseRingNibWhenPossible-JuanVuletich-2025Apr07-10h45m-jmv.001.cs.st 5/24/2025 10:43:20'!
pvtStrokeWidth: aNumber

	super pvtStrokeWidth: aNumber asFloat.
	self primStrokeWidth: strokeWidth.!

VectorEngineSmalltalk removeSelector: #pvtStrokeWidth:!

!methodRemoval: VectorEngineSmalltalk #pvtStrokeWidth: stamp: 'Install-7210-Optimization-UseRingNibWhenPossible-JuanVuletich-2025Apr07-10h45m-jmv.001.cs.st 5/24/2025 10:43:20'!
pvtStrokeWidth: aNumber

	| swErodedHalf |
	super pvtStrokeWidth: aNumber.
	swDilatedHalf := strokeWidth + antiAliasingWidth * 0.5.
	swDilatedHalfSquared := swDilatedHalf * swDilatedHalf.
	swErodedHalf := strokeWidth - antiAliasingWidth * 0.5.
	swErodedHalfSquared := swErodedHalf * swErodedHalf abs.!

VectorEngineBoundsFinder removeSelector: #pvtStrokeWidth:!

!methodRemoval: VectorEngineBoundsFinder #pvtStrokeWidth: stamp: 'Install-7210-Optimization-UseRingNibWhenPossible-JuanVuletich-2025Apr07-10h45m-jmv.001.cs.st 5/24/2025 10:43:20'!
pvtStrokeWidth: aNumber

	super pvtStrokeWidth: aNumber.
	swDilatedHalf := strokeWidth + antiAliasingWidth * 0.5.!

VectorEngine removeSelector: #pvtHopLength:!

!methodRemoval: VectorEngine #pvtHopLength: stamp: 'Install-7210-Optimization-UseRingNibWhenPossible-JuanVuletich-2025Apr07-10h45m-jmv.001.cs.st 5/24/2025 10:43:20'!
pvtHopLength: aFloat
	hop := aFloat!

VectorEngine removeSelector: #pvtStrokeWidth:!

!methodRemoval: VectorEngine #pvtStrokeWidth: stamp: 'Install-7210-Optimization-UseRingNibWhenPossible-JuanVuletich-2025Apr07-10h45m-jmv.001.cs.st 5/24/2025 10:43:20'!
pvtStrokeWidth: aNumber

	strokeWidth := aNumber.!

VectorEngineDrawer subclass: #VectorEngineSmalltalk
	instanceVariableNames: 'spanLeft spanTop spanRight spanBottom prevYTruncated prevYRounded leftAtThisY rightAtThisY aawScaledInverse swDilatedHalf swDilatedHalfSquared swErodedHalfSquared trajectoryLength needsFullAlphaCircle'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorEngineSmalltalk category: #'Morphic-Support' stamp: 'Install-7210-Optimization-UseRingNibWhenPossible-JuanVuletich-2025Apr07-10h45m-jmv.001.cs.st 5/24/2025 10:43:20'!
VectorEngineDrawer subclass: #VectorEngineSmalltalk
	instanceVariableNames: 'spanLeft spanTop spanRight spanBottom prevYTruncated prevYRounded leftAtThisY rightAtThisY aawScaledInverse swDilatedHalf swDilatedHalfSquared swErodedHalfSquared trajectoryLength needsFullAlphaCircle'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7210-Optimization-UseRingNibWhenPossible-JuanVuletich-2025Apr07-10h45m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7118] on 8 April 2025 at 12:35:56 pm'!
!AbstractVectorCanvas methodsFor: 'stroke & fill' stamp: 'jmv 4/8/2025 12:34:38'!
                              initForPath
	"Perform any initialization needed before starting a Path"

	firstPoint := nil.
	currentPoint := `0.0@0.0`.
	lastControlPoint := currentPoint.! !
!AbstractVectorCanvas methodsFor: 'stroke & fill' stamp: 'jmv 4/8/2025 12:34:42' prior: 16777478!
                               fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	self initForPath.
	engine fillColor: aFillColor do: pathCommandsBlock.! !
!AbstractVectorCanvas methodsFor: 'stroke & fill' stamp: 'jmv 4/8/2025 12:34:47' prior: 50379360!
             strokeWidth: strokeWidth color: aStrokeColor dashedStrokeBits: onOffBitSequence dashBitLength: lengthOfEachBit dashBitOffset: offsetOrNil do: pathCommandsBlock
	"Prepare parameters for drawing stroke.
	Do dashed strokes. This spec is periodic, the pattern is repeated as needed.
		- onOffBitSequence is an integer number, a sequence of bits specifying on/off parts
		- lengthOfEachBit is exactly that, the actual length of stroke for each bit
		- offsetOrNil can be used to do 'walking dashes' effects. It is an integer (nil defaults to 0).
	+ onOffBitSequence is usually stated in base-2.
	A possible example is 2r1110000100000. This draws '---    -     '
	"

	self initForPath.
	engine
		strokeWidth: strokeWidth
		color: aStrokeColor
		dashedStrokeBits: onOffBitSequence dashBitLength: lengthOfEachBit dashBitOffset: offsetOrNil
		do: pathCommandsBlock.! !
!AbstractVectorCanvas methodsFor: 'stroke & fill' stamp: 'jmv 4/8/2025 12:34:51' prior: 16777495!
  strokeWidth: strokeWidth color: aStrokeColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke."

	self initForPath.
	engine
		strokeWidth: strokeWidth
		color: aStrokeColor
		do: pathCommandsBlock.! !
!AbstractVectorCanvas methodsFor: 'stroke & fill' stamp: 'jmv 4/8/2025 12:34:56' prior: 16777505!
        strokeWidth: strokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	self initForPath.
	engine
		strokeWidth: strokeWidth
		color: aStrokeColor
		fillColor: aFillColor
		do: pathCommandsBlock.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/8/2025 12:35:07' prior: 50384025!
             basicStrokeWidth: aStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	| hopToUse |
	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	(aFillColor isNil or: [ aFillColor alpha = 0.0]) ifTrue: [
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: false ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		canvas ifNotNil: [ canvas initForPath ].
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: true ].

	hopToUse := aStrokeWidth < 4
		ifTrue: [ 0.5 ] "See #experimentHopsPerPixel1"
		ifFalse: [ 1.0 ]. "See #experimentHopsPerPixel2."
				"Correct edgeCount for fills requires visiting at least once every y coordinate, hop can not be larger than 1."
	self pvtStrokeWidth: aStrokeWidth hop: hopToUse.
	self pvtStrokeColor: aStrokeColor.
	self pvtFillColor: aFillColor.

	"Only used for strokes with no fill"
	dashedStrokeBits := 0.
	dashBitCount := 0.
	dashBitLength := 0.0.
	dashBitOffset := 0.

	self doPath: pathCommandsBlock ensureClosePath: true.! !

AbstractVectorCanvas removeSelector: #initializePath!

!methodRemoval: AbstractVectorCanvas #initializePath stamp: 'Install-7211-CureFalsePolymorphism-JuanVuletich-2025Apr08-12h17m-jmv.001.cs.st 5/24/2025 10:43:20'!
initializePath
	"Perform any initialization needed before starting a Path"

	firstPoint := nil.
	currentPoint := `0.0@0.0`.
	lastControlPoint := currentPoint.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7211-CureFalsePolymorphism-JuanVuletich-2025Apr08-12h17m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7118] on 8 April 2025 at 12:45:11 pm'!
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/8/2025 12:42:06' prior: 50384577 overrides: 17000856!
                         initializePath

	super initializePath.

	"Set all plugin state. There might be several instances of this class, all using the same plugin.
	Only one of them will use the plugin during a path draw operation. See class variable AccessLock."
	self
		primTargetBits: targetForm bits
		morphIds: morphIds
		edgeCounts: edgeCounts
		alphaMask: alphaMask
		contour: contour
		targetWidth: targetWidth
		targetHeight: targetHeight.
	self primTargetAssumedOpaque: targetAssumedOpaque.
	self
		primAntiAliasingWidth: antiAliasingWidth asFloat
		subPixelDelta: self subPixelDelta asFloat.
	self primClipLeft: clipLeft clipTop: clipTop clipRight: clipRight clipBottom: clipBottom.
	self primCurrentMorphId: currentMorphId.
	self
		primGeometryTxA11: geometryTransformation a11 asFloat
		a12: geometryTransformation a12 asFloat
		a13: geometryTransformation a13 asFloat
		a21: geometryTransformation a21 asFloat
		a22: geometryTransformation a22 asFloat
		a23: geometryTransformation a23 asFloat.

	self primInitializePath.! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/8/2025 12:39:36' prior: 17004289!
            pvtFillColor: aFillColorOrNil
	fillColor := aFillColorOrNil.
	aFillColorOrNil notNil
		ifTrue: [
			self
				primFillR: aFillColorOrNil red
				g: aFillColorOrNil green
				b: aFillColorOrNil blue
				a: aFillColorOrNil alpha]
		ifFalse: [self primFillR: 0.0 g: 0.0 b: 0.0 a: 0.0].! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/8/2025 12:39:43' prior: 17004295!
     pvtStrokeColor: aStrokeColorOrNil
	strokeColor := aStrokeColorOrNil.
	aStrokeColorOrNil notNil
		ifTrue: [
			self
				primStrokeR: aStrokeColorOrNil red
				g: aStrokeColorOrNil green
				b: aStrokeColorOrNil blue
				a: aStrokeColorOrNil alpha]
		ifFalse: [self primStrokeR: 0.0 g: 0.0 b: 0.0 a: 0.0]! !

VectorEngineWithPlugin removeSelector: #primStrokeColor:!

!methodRemoval: VectorEngineWithPlugin #primStrokeColor: stamp: 'Install-7212-VEP-Cleanup-JuanVuletich-2025Apr08-12h35m-jmv.001.cs.st 5/24/2025 10:43:20'!
primStrokeColor: aStrokeColorOrNil
	aStrokeColorOrNil notNil
		ifTrue: [
			self
				primStrokeR: aStrokeColorOrNil red
				g: aStrokeColorOrNil green
				b: aStrokeColorOrNil blue
				a: aStrokeColorOrNil alpha]
		ifFalse: [self primStrokeR: 0.0 g: 0.0 b: 0.0 a: 0.0]!

VectorEngineWithPlugin removeSelector: #primFillColor:!

!methodRemoval: VectorEngineWithPlugin #primFillColor: stamp: 'Install-7212-VEP-Cleanup-JuanVuletich-2025Apr08-12h35m-jmv.001.cs.st 5/24/2025 10:43:20'!
primFillColor: aFillColorOrNil
	aFillColorOrNil notNil
		ifTrue: [
			self
				primFillR: aFillColorOrNil red
				g: aFillColorOrNil green
				b: aFillColorOrNil blue
				a: aFillColorOrNil alpha]
		ifFalse: [self primFillR: 0.0 g: 0.0 b: 0.0 a: 0.0].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7212-VEP-Cleanup-JuanVuletich-2025Apr08-12h35m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7120] on 8 April 2025 at 3:22:11 pm'!
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:56:21'!
      primResetContourTop: t bottom: b
	<primitive: 'primResetContour' module: 'VectorEnginePlugin'>
	self primitiveFailed.! !
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 3/27/2025 15:13:36'!
                   primSetClippingSpec: anIntegerArray
	<primitive: 'primSetClippingSpec' module: 'VectorEnginePlugin'>
'falle' print.
	self primitiveFailed! !
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:56:57'!
primUpdateContourLastLine
	<primitive: 'primUpdateContourLastLine' module: 'VectorEnginePlugin'>
	self primitiveFailed.! !
!VectorEngineWithPlugin methodsFor: 'accessing' stamp: 'jmv 3/27/2025 15:08:58' overrides: 50374320!
clippingSpec: aClippingSpec
	super clippingSpec: aClippingSpec.
	self primSetClippingSpec: clippingSpec.! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:50:21'!
                         primArcCenterX: centerX centerY: centerY radiusX: radiusPointX radiusY: radiusPointY start: startAngle sweep: sweepAngle rotationCos: tthetaCos rotationSin: tthetaSin
	<primitive: 'primArc' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:03:11'!
               primBlendFillOnlyLeft: l top: t right: r bottom: b
	<primitive: 'primBlendFillOnly' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:03:47'!
                         primBlendStrokeAndFillLeft: l top: t right: r bottom: b
	<primitive: 'primBlendStrokeAndFill' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:04:27'!
               primBlendStrokeOnlyLeft: l top: t right: r bottom: b
	<primitive: 'primBlendStrokeOnly' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:52:20'!
                     primCubicBezierFromX: xFrom y: yFrom toX: xTo y: yTo control1X: xControl1 y: yControl1 control2X: xControl2 y: yControl2
	<primitive: 'primCubicBezier' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:15:10'!
                     primDisplayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	<primitive: 'primDisplayByteString' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:15:15'!
     primDisplayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	<primitive: 'primDisplayUtf32' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:15:22'!
            primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	<primitive: 'primDisplayUtf8' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:53:29'!
                              primLineFromX: xFrom y: yFrom toX: xTo y: yTo
	<primitive: 'primLine' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:58:37'!
       primPathSequence: aFloat32Array size: s
	<primitive: 'primPathSequence' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:54:31'!
     primQuadraticBezierFromX: xFrom y: yFrom toX: xTo y: yTo controlX: xControl y: yControl
	<primitive: 'primQuadraticBezier' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginSubPixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 15:14:49'!
                  primTargetBits: aBitmap morphIds: aWordArray edgeCounts: otherWordArray alphaMask: anotherWordArray affectedBits: aByteArray contour: aFloat32Array targetWidth: aNumber targetHeight: otherNumber
	<primitive: 'primSetTarget' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:50:28'!
           primArcCenterX: centerX centerY: centerY radiusX: radiusPointX radiusY: radiusPointY start: startAngle sweep: sweepAngle rotationCos: tthetaCos rotationSin: tthetaSin
	<primitive: 'primArcWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:03:16'!
           primBlendFillOnlyLeft: l top: t right: r bottom: b
	<primitive: 'primBlendFillOnlyWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:03:52'!
                     primBlendStrokeAndFillLeft: l top: t right: r bottom: b
	<primitive: 'primBlendStrokeAndFillWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:04:32'!
           primBlendStrokeOnlyLeft: l top: t right: r bottom: b
	<primitive: 'primBlendStrokeOnlyWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:52:26'!
                 primCubicBezierFromX: xFrom y: yFrom toX: xTo y: yTo control1X: xControl1 y: yControl1 control2X: xControl2 y: yControl2
	<primitive: 'primCubicBezierWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:15:30'!
                 primDisplayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	<primitive: 'primDisplayByteStringWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:15:37'!
 primDisplayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	<primitive: 'primDisplayUtf32WP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 12:15:43'!
        primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	<primitive: 'primDisplayUtf8WP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:53:35'!
                          primLineFromX: xFrom y: yFrom toX: xTo y: yTo
	<primitive: 'primLineWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:58:41'!
   primPathSequence: aFloat32Array size: s
	<primitive: 'primPathSequenceWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 11:54:36'!
 primQuadraticBezierFromX: xFrom y: yFrom toX: xTo y: yTo controlX: xControl y: yControl
	<primitive: 'primQuadraticBezierWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPluginWholePixel methodsFor: 'plugin calls' stamp: 'jmv 4/8/2025 15:14:53'!
              primTargetBits: aBitmap morphIds: aWordArray edgeCounts: otherByteArray alphaMask: anotherByteArray affectedBits: aByteArray contour: aFloat32Array targetWidth: aNumber targetHeight: otherNumber
	<primitive: 'primSetTargetWP' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineWithPlugin methodsFor: 'path algorithms' stamp: 'jmv 4/8/2025 11:50:40' prior: 17004043!
arcCenterX: cx centerY: cy radiusX: rx radiusY: ry start: startAngle sweep: sweepAngle rotationCos: thetaCos rotationSin: thetaSin

	self
		primArcCenterX: cx asFloat centerY: cy asFloat
		radiusX: rx asFloat radiusY: ry asFloat
		start: startAngle asFloat
		sweep: sweepAngle asFloat
		rotationCos: thetaCos asFloat rotationSin: thetaSin asFloat! !
!VectorEngineWithPlugin methodsFor: 'path algorithms' stamp: 'jmv 4/8/2025 11:52:31' prior: 17004059!
                            cubicBezierFromX: xFrom y: yFrom toX: xTo y: yTo control1X: xControl1 y: yControl1 control2X: xControl2 y: yControl2

	self
		primCubicBezierFromX: xFrom asFloat y: yFrom asFloat
		toX: xTo asFloat y: yTo asFloat
		control1X: xControl1 asFloat y: yControl1 asFloat
		control2X: xControl2 asFloat y: yControl2 asFloat! !
!VectorEngineWithPlugin methodsFor: 'path algorithms' stamp: 'jmv 4/8/2025 11:53:39' prior: 17004074!
                          lineFromX: xFrom y: yFrom toX: xTo y: yTo

	self
		primLineFromX: xFrom asFloat y: yFrom asFloat
		toX: xTo asFloat y: yTo asFloat! !
!VectorEngineWithPlugin methodsFor: 'path algorithms' stamp: 'jmv 4/8/2025 11:54:44' prior: 17004083!
                    quadraticBezierFromX: xFrom y: yFrom toX: xTo y: yTo controlX: xControl y: yControl

	self
		primQuadraticBezierFromX: xFrom asFloat y: yFrom asFloat
		toX: xTo asFloat y: yTo asFloat
		controlX: xControl asFloat y: yControl asFloat! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 4/8/2025 12:15:59' prior: 50378007 overrides: 50377204!
                     displayByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try BOTH!!'.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.'.
e displayByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale asFloat.
	sy := scale * trueTypeScale asFloat.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	 "Should use a specific table with 256 entries"
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8. "Should use a specific table with 256 entries"
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayByteString: aString from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
		].
	^ nextGlyphX @ nextGlyphY! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 4/8/2025 12:16:11' prior: 50378071 overrides: 50377302!
                        displayUtf32: aWordArray from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f utf32 |
'Try BOTH!!'.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf32 _ #(4314 4317 4320 4308 4315 32 4312 4324 4321 4323 4315 32 4307 4317 4314 4317 4320 32 4321 4312 4311 32 4304 4315 4308 4311 44 32 4327 4323 4317 32 4323 4311 32 4307 4312 4330 4304 4311 32 4304 4314 4312 4327 4323 4312 4307 44 32 4304 4307 32 4314 4312 4305 4320 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4320 4308 4324 4320 4308 4336 4308 4316 4307 4323 4316 4311 32 4308 4321 4311 46 32 4314 4308 4306 4308 4320 4308 32 4330 4317 4320 4324 4317 4320 4304 32 4308 4324 4324 4312 4330 4312 4304 4316 4311 4323 4320 32 4304 4311 32 4308 4304 4315 44 32 4316 4317 32 4327 4323 4304 4321 32 4315 4308 4316 4304 4316 4307 4320 4312 32 4320 4308 4324 4308 4320 4320 4308 4316 4311 4323 4320 32 4327 4323 4312 46 32 4311 4308 32 4324 4323 4311 4308 4316 4311 32 4315 4317 4314 4314 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4309 4312 4321 46 32 4309 4312 4315 32 4307 4308 4316 4312 4327 4323 4308 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4311 4336 4308 4317 4324 4336 4320 4304 4321 4311 4323 4321 32 4308 4334 44 32 4308 4304 32 4336 4304 4321 32 4309 4317 4314 4323 4315 4323 4321 32 4324 4304 4321 4311 4312 4307 4312 4312 32 4307 4308 4321 4308 4320 4323 4316 4311 46 32 4308 4334 32 4317 4324 4324 4312 4330 4312 4312 4321 32 4311 4317 4320 4327 4323 4304 4311 4317 4321 32 4315 4308 4312 44 32 4307 4317 4330 4311 4323 4321 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4312 4316 32 4327 4323 4317 46 32 4321 4323 4315 4315 4317 32 4311 4320 4304 4330 4311 4304 4311 4317 4321 32 4308 4312 32 4312 4323 4321 44 32 4323 4311 32 4317 4315 4316 4308 4321 32 4309 4312 4320 4311 4323 4311 4308 32 4307 4308 4311 4320 4304 4334 4312 4311 46) asWordArray.
e displayUtf32: utf32 from: 1 to: utf32 size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen."

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayUtf32: aWordArray from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
		].
	^ nextGlyphX @ nextGlyphY! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 4/8/2025 12:16:20' prior: 50378181 overrides: 50377613!
                displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
		].
	^ nextGlyphX @ nextGlyphY! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 4/8/2025 11:58:59' prior: 17004143 overrides: 50361755!
                               pathSequence: aFloat32Array

	self primPathSequence: aFloat32Array asFloat32Array size: aFloat32Array size! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/8/2025 12:04:48' prior: 17004178!
                    finishPath: ensureClosePath
	"Blend stroke and/or fill over background, according to the just computed pen alphas (distance from pixel to center of stroke)"
	| spanLeft spanTop spanRight spanBottom |

	"If we are doing a fill, and caller forgot to close the trajectory, then do it anyway."
	ensureClosePath ifTrue: [
		firstX isNaN ifFalse: [
			(firstX = currentX and: [ firstY = currentY ]) ifFalse: [
				"This is actually an error condition. If we are asked to fill, then the path should be closed.
				This is a workaround. If width > 0.0, we'll be adding a visible edge to the path."
				self lineToFirstPoint ]]].
	self primUpdateContourLastLine.

	spanLeft := self primSpanLeft.
	spanTop := self primSpanTop.
	spanRight := self primSpanRight.
	spanBottom := self primSpanBottom.

	"morphBounds is not affected by clipRect"
	morphBoundsLeft := morphBoundsLeft min: spanLeft.
	morphBoundsTop := morphBoundsTop min: spanTop.
	morphBoundsRight := morphBoundsRight max: spanRight.
	morphBoundsBottom := morphBoundsBottom max: spanBottom.

	spanLeft< clipLeft ifTrue: [ spanLeft := clipLeft ].
	spanTop < clipTop ifTrue: [ spanTop := clipTop ].
	spanRight > clipRight ifTrue: [ spanRight := clipRight ].
	spanBottom > clipBottom ifTrue: [ spanBottom := clipBottom ].

	(spanRight >= spanLeft and: [ spanBottom >= spanTop ]) ifTrue: [
		fillColor notNil ifTrue: [
			strokeColor notNil
				ifTrue: [ self primBlendStrokeAndFillLeft: spanLeft top: spanTop right: spanRight bottom: spanBottom ]
				ifFalse: [ self primBlendFillOnlyLeft: spanLeft top: spanTop right: spanRight bottom: spanBottom ]]
			ifFalse: [
				self primBlendStrokeOnlyLeft: spanLeft top: spanTop right: spanRight bottom: spanBottom ]].! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/8/2025 15:15:08' prior: 50384882 overrides: 17000856!
                               initializePath

	super initializePath.

	"Set all plugin state. There might be several instances of this class, all using the same plugin.
	Only one of them will use the plugin during a path draw operation. See class variable AccessLock."
	self
		primTargetBits: targetForm bits
		morphIds: morphIds
		edgeCounts: edgeCounts
		alphaMask: alphaMask
		affectedBits: affectedBits
		contour: contour
		targetWidth: targetWidth
		targetHeight: targetHeight.
	self primTargetAssumedOpaque: targetAssumedOpaque.
"No estoy seguro si hace falta."
	self primSetClippingSpec: clippingSpec.
	self
		primAntiAliasingWidth: antiAliasingWidth asFloat
		subPixelDelta: self subPixelDelta asFloat.
	self primClipLeft: clipLeft clipTop: clipTop clipRight: clipRight clipBottom: clipBottom.
	self primCurrentMorphId: currentMorphId.
	self
		primGeometryTxA11: geometryTransformation a11 asFloat
		a12: geometryTransformation a12 asFloat
		a13: geometryTransformation a13 asFloat
		a21: geometryTransformation a21 asFloat
		a22: geometryTransformation a22 asFloat
		a23: geometryTransformation a23 asFloat.

	self primInitializePath.! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/8/2025 11:56:30' prior: 17004307 overrides: 17001798!
                 resetMorphBounds

	"Clear any possible contour."
	morphBoundsTop ifNotNil: [
		self
			primResetContourTop: (morphBoundsTop max: 0)
			bottom: (morphBoundsBottom min: targetHeight -1) ].
	super resetMorphBounds.! !

VectorEngineWithPluginWholePixel removeSelector: #primCubicBezierFromX:y:toX:y:control1X:y:control2X:y:edgeCounts:alphaMask:contour:!

!methodRemoval: VectorEngineWithPluginWholePixel #primCubicBezierFromX:y:toX:y:control1X:y:control2X:y:edgeCounts:alphaMask:contour: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primCubicBezierFromX: xFrom y: yFrom toX: xTo y: yTo control1X: xControl1 y: yControl1 control2X: xControl2 y: yControl2 edgeCounts: otherByteArray alphaMask: anotherByteArray contour: aFloat32Array
	<primitive: 'primCubicBezierWP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primArcCenterX:centerY:radiusX:radiusY:start:sweep:rotationCos:rotationSin:edgeCounts:alphaMask:contour:!

!methodRemoval: VectorEngineWithPluginWholePixel #primArcCenterX:centerY:radiusX:radiusY:start:sweep:rotationCos:rotationSin:edgeCounts:alphaMask:contour: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primArcCenterX: centerX centerY: centerY radiusX: radiusPointX radiusY: radiusPointY start: startAngle sweep: sweepAngle rotationCos: tthetaCos rotationSin: tthetaSin edgeCounts: otherByteArray alphaMask: anotherByteArray contour: aFloat32Array
	<primitive: 'primArcWP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primQuadraticBezierFromX:y:toX:y:controlX:y:edgeCounts:alphaMask:contour:!

!methodRemoval: VectorEngineWithPluginWholePixel #primQuadraticBezierFromX:y:toX:y:controlX:y:edgeCounts:alphaMask:contour: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primQuadraticBezierFromX: xFrom y: yFrom toX: xTo y: yTo controlX: xControl y: yControl edgeCounts: otherWordArray alphaMask: anotherWordArray contour: aFloat32Array
	<primitive: 'primQuadraticBezierWP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primBlendStrokeAndFillLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginWholePixel #primBlendStrokeAndFillLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primBlendStrokeAndFillLeft: l top: t right: r bottom: b targetBits: aBitmap morphIds: aWordArray edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primBlendStrokeAndFillWP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primPathSequence:size:edgeCounts:alphaMask:contour:!

!methodRemoval: VectorEngineWithPluginWholePixel #primPathSequence:size:edgeCounts:alphaMask:contour: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primPathSequence: aFloat32Array size: s edgeCounts: otherByteArray alphaMask: anotherByteArray contour: otherFloat32Array
	<primitive: 'primPathSequenceWP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primBlendStrokeOnlyLeft:top:right:bottom:targetBits:morphIds:alphaMask:!

!methodRemoval: VectorEngineWithPluginWholePixel #primBlendStrokeOnlyLeft:top:right:bottom:targetBits:morphIds:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primBlendStrokeOnlyLeft: l top: t right: r bottom: b targetBits: aBitmap morphIds: aWordArray alphaMask: anotherByteArray
	<primitive: 'primBlendStrokeOnlyWP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primDisplayByteString:from:to:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginWholePixel #primDisplayByteString:from:to:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primDisplayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primDisplayByteStringWP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primTargetBits:morphIds:edgeCounts:alphaMask:contour:targetWidth:targetHeight:!

!methodRemoval: VectorEngineWithPluginWholePixel #primTargetBits:morphIds:edgeCounts:alphaMask:contour:targetWidth:targetHeight: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primTargetBits: aBitmap morphIds: aWordArray edgeCounts: otherByteArray alphaMask: anotherByteArray contour: aFloat32Array targetWidth: aNumber targetHeight: otherNumber
	<primitive: 'primSetTargetWP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primDisplayUtf8:fromByte:toByte:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginWholePixel #primDisplayUtf8:fromByte:toByte:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primDisplayUtf8WP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primLineFromX:y:toX:y:edgeCounts:alphaMask:contour:!

!methodRemoval: VectorEngineWithPluginWholePixel #primLineFromX:y:toX:y:edgeCounts:alphaMask:contour: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primLineFromX: xFrom y: yFrom toX: xTo y: yTo edgeCounts: otherByteArray alphaMask: anotherByteArray contour: aFloat32Array
	<primitive: 'primLineWP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primBlendFillOnlyLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginWholePixel #primBlendFillOnlyLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primBlendFillOnlyLeft: l top: t right: r bottom: b targetBits: aBitmap morphIds: aWordArray edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primBlendFillOnlyWP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginWholePixel removeSelector: #primDisplayUtf32:from:to:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginWholePixel #primDisplayUtf32:from:to:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primDisplayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherByteArray alphaMask: anotherByteArray
	<primitive: 'primDisplayUtf32WP' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primCubicBezierFromX:y:toX:y:control1X:y:control2X:y:edgeCounts:alphaMask:contour:!

!methodRemoval: VectorEngineWithPluginSubPixel #primCubicBezierFromX:y:toX:y:control1X:y:control2X:y:edgeCounts:alphaMask:contour: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primCubicBezierFromX: xFrom y: yFrom toX: xTo y: yTo control1X: xControl1 y: yControl1 control2X: xControl2 y: yControl2 edgeCounts: otherWordArray alphaMask: anotherWordArray contour: aFloat32Array
	<primitive: 'primCubicBezier' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primArcCenterX:centerY:radiusX:radiusY:start:sweep:rotationCos:rotationSin:edgeCounts:alphaMask:contour:!

!methodRemoval: VectorEngineWithPluginSubPixel #primArcCenterX:centerY:radiusX:radiusY:start:sweep:rotationCos:rotationSin:edgeCounts:alphaMask:contour: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primArcCenterX: centerX centerY: centerY radiusX: radiusPointX radiusY: radiusPointY start: startAngle sweep: sweepAngle rotationCos: tthetaCos rotationSin: tthetaSin edgeCounts: otherWordArray alphaMask: anotherWordArray contour: aFloat32Array
	<primitive: 'primArc' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primQuadraticBezierFromX:y:toX:y:controlX:y:edgeCounts:alphaMask:contour:!

!methodRemoval: VectorEngineWithPluginSubPixel #primQuadraticBezierFromX:y:toX:y:controlX:y:edgeCounts:alphaMask:contour: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primQuadraticBezierFromX: xFrom y: yFrom toX: xTo y: yTo controlX: xControl y: yControl edgeCounts: otherWordArray alphaMask: anotherWordArray contour: aFloat32Array
	<primitive: 'primQuadraticBezier' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primBlendStrokeAndFillLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginSubPixel #primBlendStrokeAndFillLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primBlendStrokeAndFillLeft: l top: t right: r bottom: b targetBits: aBitmap morphIds: aWordArray edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primBlendStrokeAndFill' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primPathSequence:size:edgeCounts:alphaMask:contour:!

!methodRemoval: VectorEngineWithPluginSubPixel #primPathSequence:size:edgeCounts:alphaMask:contour: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primPathSequence: aFloat32Array size: s edgeCounts: otherWordArray alphaMask: anotherWordArray contour: otherFloat32Array
	<primitive: 'primPathSequence' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primBlendStrokeOnlyLeft:top:right:bottom:targetBits:morphIds:alphaMask:!

!methodRemoval: VectorEngineWithPluginSubPixel #primBlendStrokeOnlyLeft:top:right:bottom:targetBits:morphIds:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primBlendStrokeOnlyLeft: l top: t right: r bottom: b targetBits: aBitmap morphIds: aWordArray alphaMask: anotherWordArray
	<primitive: 'primBlendStrokeOnly' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primDisplayByteString:from:to:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginSubPixel #primDisplayByteString:from:to:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primDisplayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primDisplayByteString' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primTargetBits:morphIds:edgeCounts:alphaMask:contour:targetWidth:targetHeight:!

!methodRemoval: VectorEngineWithPluginSubPixel #primTargetBits:morphIds:edgeCounts:alphaMask:contour:targetWidth:targetHeight: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primTargetBits: aBitmap morphIds: aWordArray edgeCounts: otherWordArray alphaMask: anotherWordArray contour: aFloat32Array targetWidth: aNumber targetHeight: otherNumber
	<primitive: 'primSetTarget' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primDisplayUtf8:fromByte:toByte:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginSubPixel #primDisplayUtf8:fromByte:toByte:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primDisplayUtf8' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primLineFromX:y:toX:y:edgeCounts:alphaMask:contour:!

!methodRemoval: VectorEngineWithPluginSubPixel #primLineFromX:y:toX:y:edgeCounts:alphaMask:contour: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primLineFromX: xFrom y: yFrom toX: xTo y: yTo edgeCounts: otherWordArray alphaMask: anotherWordArray contour: aFloat32Array
	<primitive: 'primLine' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primBlendFillOnlyLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginSubPixel #primBlendFillOnlyLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primBlendFillOnlyLeft: l top: t right: r bottom: b targetBits: aBitmap morphIds: aWordArray edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primBlendFillOnly' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPluginSubPixel removeSelector: #primDisplayUtf32:from:to:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask:!

!methodRemoval: VectorEngineWithPluginSubPixel #primDisplayUtf32:from:to:atx:y:scalex:y:contourData:contourDataIndexes:edgeCounts:alphaMask: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primDisplayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes edgeCounts: otherWordArray alphaMask: anotherWordArray
	<primitive: 'primDisplayUtf32' module: 'VectorEnginePlugin'>

	self primitiveFailed!

VectorEngineWithPlugin removeSelector: #primResetContourTop:bottom:contour:!

!methodRemoval: VectorEngineWithPlugin #primResetContourTop:bottom:contour: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primResetContourTop: t bottom: b contour: aFloat32Array
	<primitive: 'primResetContour' module: 'VectorEnginePlugin'>
	self primitiveFailed.!

VectorEngineWithPlugin removeSelector: #primUpdateContourLastLine:!

!methodRemoval: VectorEngineWithPlugin #primUpdateContourLastLine: stamp: 'Install-7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st 5/24/2025 10:43:20'!
primUpdateContourLastLine: aFloat32Array
	<primitive: 'primUpdateContourLastLine' module: 'VectorEnginePlugin'>
	self primitiveFailed.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7213-UpdatedVEPluginProtocol-JuanVuletich-2025Apr08-15h03m-jmv.003.cs.st----!

'From Cuis7.3 [latest update: #7121] on 9 April 2025 at 8:23:53 am'!
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/9/2025 08:18:51' prior: 50382454 overrides: 17002504!
 blendFillOnly
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| t b l r edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realFillColor opaqueFillColorWord realOpaqueFillColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	t := spanTop. b := spanBottom. l := spanLeft. r := spanRight.	"On the VectorEnginePlugin, they are different variables, of different type. Make code similar."
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := t * 2 + 1.
	mustResetColor := false.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ fillColor alpha = 1.0 ]) ifTrue: [
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	t to: b do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= l ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= r ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		isRedInside := isGreenInside := isBlueInside := false.
		pixelIndex := displayY * targetWidth + l + 1. "+1 solo en Smalltalk"
		displayX := l.
		[ displayX <= r ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment | isGreenInside ifTrue: [
				"Some alpha not zero in this segment of length delta, or painting inside the shape."
				(segmentLength min: (r-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphasWord := "16r00000000" #[16r00 16r00 16r00 16r00].
					alphasOrEdgeCountsInThisSegment ifTrue: [
						edgesThisPixel := edgeCounts bytesAt: pixelIndex.
						edgeCounts at: pixelIndex put: 0.
						edgesThisPixelR := edgesThisPixel at: 3.
						edgesThisPixelG := edgesThisPixel at: 2.
						edgesThisPixelB := edgesThisPixel at: 1.
						"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
						edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
						edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
						edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
						edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
						edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
						edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
						isRedInside := edgesUpToThisPixelR ~= 0.
						isGreenInside := edgesUpToThisPixelG ~= 0.
						isBlueInside := edgesUpToThisPixelB ~= 0.
						strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
						strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
							alphaMask at: pixelIndex put: 0 ]].
					
					(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
						(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
							ifTrue: [
								realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
								realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]
							ifFalse: [
								(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
									realFillColor := fillColor.  fillColor := fillColor alpha: fillColor alpha * 0.75.
									realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]].
						
						(opaqueFillColorWord ~= 0 and: [strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] and: [ isGreenInside ]])
							ifTrue: [ "If no alpha, and isGreenInside is true, isRedInside and isBlueInside are also true"
								"Fully inside the shape, far from anti aliasing. Color is opaque. Target is too. Just overwrite with fill color."
								targetForm bits at: pixelIndex put: opaqueFillColorWord.
								morphIds at: pixelIndex put: currentMorphId ]
							ifFalse: [
								"General case. (strokeAntiAliasAlphasWord = 0 and outside the shape means NOP)"
								(strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] or: [ isGreenInside ]) ifTrue: [
									"If no alpha, and isGreenInside is true, isRedInside and isBlueInside are also true
									If there is any alpha, isRedInside, isGreenInside, isBlueInside may be different."
									self blendFillOnlyAt: pixelIndex
										redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
										antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].
						
						mustResetColor ifTrue: [
							fillColor := realFillColor. opaqueFillColorWord := realOpaqueFillColorWord. mustResetColor := false ]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
		
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/9/2025 08:20:57' prior: 50382652 overrides: 17002509!
           blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| t b l r edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColors realStrokeColor realFillColor opaqueStrokeColorWord opaqueFillColorWord realOpaqueStrokeColorWord realOpaqueFillColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	t := spanTop. b := spanBottom. l := spanLeft. r := spanRight.	"On the VectorEnginePlugin, they are different variables, of different type. Make code similar."
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := t * 2 + 1.
	mustResetColors := false.
	opaqueStrokeColorWord := 0.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha * fillColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000.
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	t to: b do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= l ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= r ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		isRedInside := isGreenInside := isBlueInside := false.
		pixelIndex := displayY * targetWidth + l + 1. "+1 solo en Smalltalk"
		displayX := l.
		[ displayX <= r ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment | isGreenInside ifTrue: [
				"Some alpha not zero in this segment of length delta, or painting inside the shape."
				(segmentLength min: (r-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphasWord := "16r00000000" #[16r00 16r00 16r00 16r00].
					alphasOrEdgeCountsInThisSegment ifTrue: [
						edgesThisPixel := edgeCounts bytesAt: pixelIndex.
						edgeCounts at: pixelIndex put: 0.
						edgesThisPixelR := edgesThisPixel at: 3.
						edgesThisPixelG := edgesThisPixel at: 2.
						edgesThisPixelB := edgesThisPixel at: 1.
						"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
						edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
						edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
						edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
						edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
						edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
						edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
						isRedInside := edgesUpToThisPixelR ~= 0.
						isGreenInside := edgesUpToThisPixelG ~= 0.
						isBlueInside := edgesUpToThisPixelB ~= 0.
						strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
						strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
							alphaMask at: pixelIndex put: 0 ]].
					
					(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
						(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel ])
							ifTrue: [
								realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
								realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
								realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
								realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]
							ifFalse: [
								(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
									realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
									realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
									realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
									realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]].
						
						strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00]
							ifTrue: [ 		"Not in the stroke at all. Either fully in the fill, or outside the shape (pixel is unaffected)."
								isGreenInside
									ifTrue: [
										"Fully inside the fill, far from anti aliasing. (Here isGreenInside also implies isRedInside and isBlueInside)"
										opaqueFillColorWord ~= 0
											ifTrue: [
												"Fill color is opaque. Target is too. Just overwrite with fill color."
												targetForm bits at: pixelIndex put: opaqueFillColorWord.
												morphIds at: pixelIndex put: currentMorphId ]
											ifFalse: [
												"Translucent color or target. Do proper blend of fill over target."
												self blendFillOnlyAt: pixelIndex
													redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
													antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]]
							ifFalse: [		"At least one subpixel in the stroke."
								strokeAntiAliasAlphasWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00]
									ifTrue: [
										"Fully inside the stroke, far from anti aliasing."
										opaqueStrokeColorWord ~= 0
											ifTrue: [
												"Stroke color is opaque. Target is too. Just overwrite with stroke color."
												targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
												morphIds at: pixelIndex put: currentMorphId ]
											ifFalse: [
												"Translucent color or target. Do proper blend of stroke over target."
												self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]
									ifFalse: [
										"In an anti aliased part of the stroke. Either blend stroke over background, or pre-mix stroke and fill."
										self blendStrokeAndFillAt: pixelIndex
											redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
											antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].					
						
						mustResetColors ifTrue: [
							strokeColor := realStrokeColor. fillColor := realFillColor.
							opaqueStrokeColorWord := realOpaqueStrokeColorWord. opaqueFillColorWord := realOpaqueFillColorWord.
							mustResetColors := false ]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
		
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/9/2025 08:22:30' prior: 50382904 overrides: 17002514!
                           blendStrokeOnly
	"Blends stroke color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| t b l r pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realStrokeColor opaqueStrokeColorWord realOpaqueStrokeColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	t := spanTop. b := spanBottom. l := spanLeft. r := spanRight.	"On the VectorEnginePlugin, they are different variables, of different type. Make code similar."
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := t * 2 + 1.
	mustResetColor := false.
	opaqueStrokeColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	t to: b do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= l ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= r ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + l + 1. "+1 solo en Smalltalk"
		displayX := l.
		[ displayX <= r ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment ifTrue: [
				"Some alpha not zero in this segment of length delta"
				(segmentLength min: (r-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
					"At least one subpixel in the stroke."
					strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] ifFalse: [
						alphaMask at: pixelIndex put: 0.
						
						(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
							(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
								ifTrue: [
									realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
									realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]
								ifFalse: [
									(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
										realStrokeColor := strokeColor.  strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
										realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]].
							
							(opaqueStrokeColorWord ~= 0 and: [strokeAntiAliasAlphasWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00]])
								ifTrue: [
									"Fully inside the stroke, far from anti aliasing. Color is opaque. Target is too. Just overwrite with stroke color."
									targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
									morphIds at: pixelIndex put: currentMorphId ]
								ifFalse: [
									"At least one subpixel in the anti aliasing area of the stroke, or color is translucent, or target translucency is desired."
									self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: strokeAntiAliasAlphasWord ].
							
							mustResetColor ifTrue: [
								strokeColor := realStrokeColor. opaqueStrokeColorWord := realOpaqueStrokeColorWord. mustResetColor := false ]]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
		
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/9/2025 08:19:59' prior: 50383048 overrides: 17002504!
     blendFillOnly
	"Blends fill color over background.
	If targetAssumedOpaque is false, target translucency is computed correctly.
	If targetAssumedOpaque is true (and target translucency is actually 255 on input), an optimization is made and target translucency is set to 255.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]."

	| t b l r edgesUpToThisPixel edgesThisPixel pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realFillColor opaqueFillColorWord realOpaqueFillColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	t := spanTop. b := spanBottom. l := spanLeft. r := spanRight.	"On the VectorEnginePlugin, they are different variables, of different type. Make code similar."
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := t * 2 + 1.
	mustResetColor := false.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ fillColor alpha = 1.0 ]) ifTrue: [
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	t to: b do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= l ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= r ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + l + 1. "+1 solo en Smalltalk"
		displayX := l.
		[ displayX <= r ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment  | (edgesUpToThisPixel ~= 0) ifTrue: [
				"Some alpha not zero in this segment of length delta, or painting inside the shape."
				(segmentLength min: (r-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphaBits := 0.
					alphasOrEdgeCountsInThisSegment ifTrue: [
						edgesThisPixel := edgeCounts at: pixelIndex.
						edgesThisPixel = 0 ifFalse: [
							edgeCounts at: pixelIndex put: 0.
							"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
							edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
							edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
						strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
						strokeAntiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ]].
					
					(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
						(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
							ifTrue: [
								realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
								realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]
							ifFalse: [
								(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
									realFillColor := fillColor.  fillColor := fillColor alpha: fillColor alpha * 0.75.
									realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]].
						
						edgesUpToThisPixel = 0
							ifFalse: [ "Inside the shape"
								(strokeAntiAliasAlphaBits = 0 and: [ opaqueFillColorWord ~= 0 ])
									ifTrue: [
										"Fully inside the shape, far from anti aliasing. Color is opaque. Target is too. Just overwrite with fill color."
										targetForm bits at: pixelIndex put: opaqueFillColorWord.
										morphIds at: pixelIndex put: currentMorphId ]
									ifFalse: [
										"Inside the shape. Turn stroke anti aliasing into fill anti aliasing."
										self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: 127 - strokeAntiAliasAlphaBits ]]
							ifTrue: [ "Still in the anti aliasing area, but outside the shape, strictly speaking."
								strokeAntiAliasAlphaBits = 0 ifFalse: [
									self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]].
						
						mustResetColor ifTrue: [
							fillColor := realFillColor. opaqueFillColorWord := realOpaqueFillColorWord. mustResetColor := false ]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
			
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/9/2025 08:21:42' prior: 50383214 overrides: 17002509!
                       blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| t b l r edgesUpToThisPixel edgesThisPixel pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColors realStrokeColor realFillColor opaqueStrokeColorWord opaqueFillColorWord realOpaqueStrokeColorWord realOpaqueFillColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	t := spanTop. b := spanBottom. l := spanLeft. r := spanRight.	"On the VectorEnginePlugin, they are different variables, of different type. Make code similar."
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := t * 2 + 1.
	mustResetColors := false.
	opaqueStrokeColorWord := 0.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha * fillColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000.
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	t to: b do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= l ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= r ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixel := 0.
		pixelIndex := displayY * targetWidth + l + 1. "+1 solo en Smalltalk"
		displayX := l.
		[ displayX <= r ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment  | (edgesUpToThisPixel ~= 0) ifTrue: [
				"Some alpha not zero in this segment of length delta, or painting inside the shape."
				(segmentLength min: (r-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphaBits := 0.
					alphasOrEdgeCountsInThisSegment ifTrue: [
						edgesThisPixel := edgeCounts at: pixelIndex.
						edgesThisPixel = 0 ifFalse: [
							edgeCounts at: pixelIndex put: 0.
							"Not needed in C or OpenCL, just use a wraparound 8 bit type, such uint8_t"
							edgesThisPixel > 127 ifTrue: [ edgesThisPixel := edgesThisPixel - 256 ].
							edgesUpToThisPixel := edgesUpToThisPixel + edgesThisPixel ].
						strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
						strokeAntiAliasAlphaBits = 0 ifFalse: [ alphaMask at: pixelIndex put: 0 ]].
					
					(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
						(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel ])
							ifTrue: [
								realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
								realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
								realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
								realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]
							ifFalse: [
								(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
									realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
									realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
									realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
									realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]].
						
						strokeAntiAliasAlphaBits = 0
							ifTrue: [ 		"Not in the stroke at all. Either fully in the fill, or outside the shape (pixel is unaffected)."
								edgesUpToThisPixel ~= 0
									ifTrue: [
										"Fully inside the fill, far from anti aliasing."
										opaqueFillColorWord ~= 0
											ifTrue: [
												"Fill color is opaque. Target is too. Just overwrite with fill color."
												targetForm bits at: pixelIndex put: opaqueFillColorWord.
												morphIds at: pixelIndex put: currentMorphId ]
											ifFalse: [
												"Translucent color or target. Do proper blend of fill over target."
												self blendFillOnlyAt: pixelIndex antiAliasAlphaByte: 127 ]]]
							ifFalse: [		"In the stroke."
								strokeAntiAliasAlphaBits = 127
									ifTrue: [
										"Fully inside the stroke, far from anti aliasing."
										opaqueStrokeColorWord ~= 0
											ifTrue: [
												"Stroke color is opaque. Target is too. Just overwrite with stroke color."
												targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
												morphIds at: pixelIndex put: currentMorphId ]
											ifFalse: [
												"Translucent color or target. Do proper blend of stroke over target."
												self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: 127 ]]
									ifFalse: [
										"In an anti aliased part of the stroke. Either blend stroke over background, or pre-mix stroke and fill."
										edgesUpToThisPixel ~= 0
											ifTrue: [ 
												"Inside the shape. Blend stroke and fill, blend result over target."
												self blendStrokeAndFillAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]
											ifFalse: [
												"In the outer anti aliasing area of the stroke. Blend stroke over background."
												self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ]]].
						
						mustResetColors ifTrue: [
							strokeColor := realStrokeColor. fillColor := realFillColor.
							opaqueStrokeColorWord := realOpaqueStrokeColorWord. opaqueFillColorWord := realOpaqueFillColorWord.
							mustResetColors := false ]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
			
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineWholePixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/9/2025 08:23:10' prior: 50383434 overrides: 17002514!
                         blendStrokeOnly
	"Blends stroke color over background.
	If targetAssumedOpaque is false, target translucency is computed correctly.
	If targetAssumedOpaque is true (and target translucency is actually 255 on input), an optimization is made and target translucency is set to 255.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| t b l r pixelIndex strokeAntiAliasAlphaBits clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realStrokeColor opaqueStrokeColorWord realOpaqueStrokeColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	t := spanTop. b := spanBottom. l := spanLeft. r := spanRight.	"On the VectorEnginePlugin, they are different variables, of different type. Make code similar."
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := t * 2 + 1.
	mustResetColor := false.
	opaqueStrokeColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	t to: b do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= l ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= r ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		pixelIndex := displayY * targetWidth + l + 1. "+1 solo en Smalltalk"
		displayX := l.
		[ displayX <= r ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment ifTrue: [
				"Some alpha not zero in this segment of length delta"
				(segmentLength min: (r-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphaBits := alphaMask at: pixelIndex.
					strokeAntiAliasAlphaBits = 0 ifFalse: [			"In the stroke"
						alphaMask at: pixelIndex put: 0.
						
						(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
							(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
								ifTrue: [
									realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
									realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]
								ifFalse: [
									(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
										realStrokeColor := strokeColor.  strokeColor := strokeColor alpha: strokeColor alpha * 0.75.
										realOpaqueStrokeColorWord := opaqueStrokeColorWord. realOpaqueStrokeColorWord := 0. mustResetColor := true ]].
							
							(opaqueStrokeColorWord ~= 0 and: [strokeAntiAliasAlphaBits = 127])
								ifTrue: [
									"Optimize inner part of a wide stroke: Fully opaque stroke (and target), no anti aliasing, no clipping at this point."
									targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
									morphIds at: pixelIndex put: currentMorphId ]
								ifFalse: [
									"In the anti aliasing area of the stroke, or color is translucent, or target translucency is desired."
									self blendStrokeOnlyAt: pixelIndex antiAliasAlphaByte: strokeAntiAliasAlphaBits ].
							
							mustResetColor ifTrue: [
								strokeColor := realStrokeColor. opaqueStrokeColorWord := realOpaqueStrokeColorWord. mustResetColor := false ]]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
		
		clippingSpecIndex := clippingSpecIndex + 2 ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7214-NamesMoreLikeInSlangVEP-JuanVuletich-2025Apr09-08h12m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7121] on 9 April 2025 at 8:31:31 am'!
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 4/9/2025 08:29:28'!
                       primClearClippingSpec
	<primitive: 'primClearClippingSpec' module: 'VectorEnginePlugin'>
	self primitiveFailed! !
!VectorEngineDrawer methodsFor: 'accessing' stamp: 'jmv 4/9/2025 08:30:45' prior: 50374320!
                  clippingSpec: aClippingSpecOrNil
	clippingSpec := aClippingSpecOrNil.! !
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 4/9/2025 08:29:02' prior: 50384985!
                    primSetClippingSpec: anIntegerArray
	<primitive: 'primSetClippingSpec' module: 'VectorEnginePlugin'>
	self primitiveFailed! !
!VectorEngineWithPlugin methodsFor: 'accessing' stamp: 'jmv 4/9/2025 08:31:07' prior: 50384999 overrides: 50387279!
              clippingSpec: aClippingSpecOrNil
	clippingSpec := aClippingSpecOrNil.
	clippingSpec
		ifNil: [ self primClearClippingSpec ]
		ifNotNil: [ self primSetClippingSpec: clippingSpec ].! !

VectorEngineWithPlugin removeSelector: #primClearClippingSpec:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7215-ClippingSpecParameterHandling-JuanVuletich-2025Apr09-08h23m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7123] on 9 April 2025 at 10:00:14 am'!
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/9/2025 09:20:07' prior: 50386124 overrides: 17002504!
                   blendFillOnly
	"Blends fill color over background. Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| t b l r edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColor realFillColor opaqueFillColorWord realOpaqueFillColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	t := spanTop. b := spanBottom. l := spanLeft. r := spanRight.	"On the VectorEnginePlugin, they are different variables, of different type. Make code similar."
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := t * 2 + 1.
	mustResetColor := false.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ fillColor alpha = 1.0 ]) ifTrue: [
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	t to: b do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= l ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= r ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		isRedInside := isGreenInside := isBlueInside := false.
		pixelIndex := displayY * targetWidth + l + 1. "+1 solo en Smalltalk"
		displayX := l.
		[ displayX <= r ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment | isGreenInside ifTrue: [
				"Some alpha not zero in this segment of length delta, or painting inside the shape."
				(segmentLength min: (r-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphasWord := "16r00000000" #[16r00 16r00 16r00 16r00].
					alphasOrEdgeCountsInThisSegment ifTrue: [
						edgesThisPixel := edgeCounts bytesAt: pixelIndex.
						edgesThisPixel ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
							edgeCounts at: pixelIndex put: 0.
							edgesThisPixelR := edgesThisPixel at: 3.
							edgesThisPixelG := edgesThisPixel at: 2.
							edgesThisPixelB := edgesThisPixel at: 1.
							"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
							edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
							edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
							edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
							edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
							edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
							edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
							isRedInside := edgesUpToThisPixelR ~= 0.
							isGreenInside := edgesUpToThisPixelG ~= 0.
							isBlueInside := edgesUpToThisPixelB ~= 0 ].
						strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
						strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
							alphaMask at: pixelIndex put: 0 ]].
					
					(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
						(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel])
							ifTrue: [
								realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
								realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]
							ifFalse: [
								(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
									realFillColor := fillColor.  fillColor := fillColor alpha: fillColor alpha * 0.75.
									realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColor := true ]].
						
						(opaqueFillColorWord ~= 0 and: [strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00] and: [ isGreenInside ]])
							ifTrue: [ "If no alpha, and isGreenInside is true, isRedInside and isBlueInside are also true"
								"Fully inside the shape, far from anti aliasing. Color is opaque. Target is too. Just overwrite with fill color."
								targetForm bits at: pixelIndex put: opaqueFillColorWord.
								morphIds at: pixelIndex put: currentMorphId ]
							ifFalse: [
								"General case. (strokeAntiAliasAlphasWord = 0 and outside the shape means NOP)"
								(strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] or: [ isGreenInside ]) ifTrue: [
									"If no alpha, and isGreenInside is true, isRedInside and isBlueInside are also true
									If there is any alpha, isRedInside, isGreenInside, isBlueInside may be different."
									self blendFillOnlyAt: pixelIndex
										redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
										antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].
						
						mustResetColor ifTrue: [
							fillColor := realFillColor. opaqueFillColorWord := realOpaqueFillColorWord. mustResetColor := false ]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
		
		clippingSpecIndex := clippingSpecIndex + 2 ].! !
!VectorEngineSubPixel methodsFor: 'private - blend with mask' stamp: 'jmv 4/9/2025 09:38:42' prior: 50386325 overrides: 17002509!
                blendStrokeAndFill
	"Do an appropriate (anti aliased) mix between stoke color and fill color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	Sub pixel anti aliasing means each R, G, B subpixel might use a different anti aliasing alpha.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| t b l r edgesUpToThisPixelR edgesUpToThisPixelG edgesUpToThisPixelB edgesThisPixel edgesThisPixelR edgesThisPixelG edgesThisPixelB isRedInside isGreenInside isBlueInside pixelIndex strokeAntiAliasAlphasWord clippingSpecL clippingSpecR clippingSpecIndex antiAliasedClippedLeftPixel antiAliasedClippedRightPixel mustResetColors realStrokeColor realFillColor opaqueStrokeColorWord opaqueFillColorWord realOpaqueStrokeColorWord realOpaqueFillColorWord displayX affectedBitsIndex segmentLength alphasOrEdgeCountsInThisSegment lastSegmentIndex |
	t := spanTop. b := spanBottom. l := spanLeft. r := spanRight.	"On the VectorEnginePlugin, they are different variables, of different type. Make code similar."
	clippingSpecL := 0.
	clippingSpecR := targetWidth-1.
	antiAliasedClippedLeftPixel := targetWidth."targetWidth means effectively no AA for clipping"
	antiAliasedClippedRightPixel := targetWidth."targetWidth means effectively no AA for clipping"
	clippingSpecIndex := t * 2 + 1.
	mustResetColors := false.
	opaqueStrokeColorWord := 0.
	opaqueFillColorWord := 0.
	(targetAssumedOpaque and: [ strokeColor alpha * fillColor alpha = 1.0 ]) ifTrue: [
		opaqueStrokeColorWord := (strokeColor red * 255) rounded * 256+(strokeColor green * 255) rounded * 256 + (strokeColor blue*255) rounded + 16rFF000000.
		opaqueFillColorWord := (fillColor red * 255) rounded * 256+(fillColor green * 255) rounded * 256 + (fillColor blue*255) rounded + 16rFF000000 ].
	lastSegmentIndex := -1.
	t to: b do: [ :displayY |
		clippingSpec ifNotNil: [ "Not needed if moved to a clippingSpec specific method."
			clippingSpecL := clippingSpec at: clippingSpecIndex.
			clippingSpecR := clippingSpec at: clippingSpecIndex+1.
			antiAliasedClippedLeftPixel := clippingSpecL >= l ifTrue: [clippingSpecL] ifFalse: [targetWidth].
			antiAliasedClippedRightPixel := clippingSpecR <= r ifTrue: [clippingSpecR] ifFalse:  [targetWidth]].
		edgesUpToThisPixelR := 0.
		edgesUpToThisPixelG := 0.
		edgesUpToThisPixelB := 0.
		isRedInside := isGreenInside := isBlueInside := false.
		pixelIndex := displayY * targetWidth + l + 1. "+1 solo en Smalltalk"
		displayX := l.
		[ displayX <= r ] whileTrue: [
			
			"pixelIndex >> 4 in Slang / C"
			affectedBitsIndex := pixelIndex-1>>4+1.
			lastSegmentIndex = affectedBitsIndex ifFalse: [
				alphasOrEdgeCountsInThisSegment := (affectedBits at: affectedBitsIndex) = 1.
				lastSegmentIndex := affectedBitsIndex.
				alphasOrEdgeCountsInThisSegment ifTrue: [
					affectedBits at: affectedBitsIndex put: 0 ]].
			segmentLength := affectedBitsIndex << 4+1 - pixelIndex.
			alphasOrEdgeCountsInThisSegment | isGreenInside ifTrue: [
				"Some alpha not zero in this segment of length delta, or painting inside the shape."
				(segmentLength min: (r-displayX+1)) timesRepeat: [
					
					strokeAntiAliasAlphasWord := "16r00000000" #[16r00 16r00 16r00 16r00].
					alphasOrEdgeCountsInThisSegment ifTrue: [
						edgesThisPixel := edgeCounts bytesAt: pixelIndex.
						edgesThisPixel ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
							edgeCounts at: pixelIndex put: 0.
							edgesThisPixelR := edgesThisPixel at: 3.
							edgesThisPixelG := edgesThisPixel at: 2.
							edgesThisPixelB := edgesThisPixel at: 1.
							"Not needed in C or OpenCL, use signed char, i.e. a type where 16rFF means -1 and not 255"
							edgesThisPixelR > 127 ifTrue: [ edgesThisPixelR := edgesThisPixelR - 256 ].
							edgesThisPixelG > 127 ifTrue: [ edgesThisPixelG := edgesThisPixelG - 256 ].
							edgesThisPixelB > 127 ifTrue: [ edgesThisPixelB := edgesThisPixelB - 256 ].
							edgesUpToThisPixelR := edgesUpToThisPixelR + edgesThisPixelR.
							edgesUpToThisPixelG := edgesUpToThisPixelG + edgesThisPixelG.
							edgesUpToThisPixelB := edgesUpToThisPixelB + edgesThisPixelB.
							isRedInside := edgesUpToThisPixelR ~= 0.
							isGreenInside := edgesUpToThisPixelG ~= 0.
							isBlueInside := edgesUpToThisPixelB ~= 0 ].
						strokeAntiAliasAlphasWord := alphaMask bytesAt: pixelIndex.
						strokeAntiAliasAlphasWord ~= "16r00000000" #[16r00 16r00 16r00 16r00] ifTrue: [
							alphaMask at: pixelIndex put: 0 ]].
					
					(displayX >= clippingSpecL and: [ displayX <= clippingSpecR ]) ifTrue: [
						(displayX = antiAliasedClippedLeftPixel or: [ displayX = antiAliasedClippedRightPixel ])
							ifTrue: [
								realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
								realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
								realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
								realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]
							ifFalse: [
								(displayX-1 = antiAliasedClippedLeftPixel or: [ displayX+1 = antiAliasedClippedRightPixel]) ifTrue: [
									realStrokeColor := strokeColor. strokeColor := strokeColor alpha: strokeColor alpha * 0.25.
									realFillColor := fillColor. fillColor := fillColor alpha: fillColor alpha * 0.25.
									realOpaqueStrokeColorWord := opaqueStrokeColorWord. opaqueStrokeColorWord := 0. 
									realOpaqueFillColorWord := opaqueFillColorWord. opaqueFillColorWord := 0. mustResetColors := true ]].
						
						strokeAntiAliasAlphasWord = "16r00000000" #[16r00 16r00 16r00 16r00]
							ifTrue: [ 		"Not in the stroke at all. Either fully in the fill, or outside the shape (pixel is unaffected)."
								isGreenInside
									ifTrue: [
										"Fully inside the fill, far from anti aliasing. (Here isGreenInside also implies isRedInside and isBlueInside)"
										opaqueFillColorWord ~= 0
											ifTrue: [
												"Fill color is opaque. Target is too. Just overwrite with fill color."
												targetForm bits at: pixelIndex put: opaqueFillColorWord.
												morphIds at: pixelIndex put: currentMorphId ]
											ifFalse: [
												"Translucent color or target. Do proper blend of fill over target."
												self blendFillOnlyAt: pixelIndex
													redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
													antiAliasAlphasWord: strokeAntiAliasAlphasWord ]]]
							ifFalse: [		"At least one subpixel in the stroke."
								strokeAntiAliasAlphasWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00]
									ifTrue: [
										"Fully inside the stroke, far from anti aliasing."
										opaqueStrokeColorWord ~= 0
											ifTrue: [
												"Stroke color is opaque. Target is too. Just overwrite with stroke color."
												targetForm bits at: pixelIndex put: opaqueStrokeColorWord.
												morphIds at: pixelIndex put: currentMorphId ]
											ifFalse: [
												"Translucent color or target. Do proper blend of stroke over target."
												self blendStrokeOnlyAt: pixelIndex antiAliasAlphasWord: #[16r7F 16r7F 16r7F 16r00] ]]
									ifFalse: [
										"In an anti aliased part of the stroke. Either blend stroke over background, or pre-mix stroke and fill."
										self blendStrokeAndFillAt: pixelIndex
											redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside
											antiAliasAlphasWord: strokeAntiAliasAlphasWord ]].					
						
						mustResetColors ifTrue: [
							strokeColor := realStrokeColor. fillColor := realFillColor.
							opaqueStrokeColorWord := realOpaqueStrokeColorWord. opaqueFillColorWord := realOpaqueFillColorWord.
							mustResetColors := false ]].
					displayX := displayX + 1.
					pixelIndex := pixelIndex + 1 ]]
			ifFalse: [				"All alphas and edgeCounts are zero in this segment of length delta"
				displayX := displayX + segmentLength.
				pixelIndex := pixelIndex + segmentLength ]].
		
		clippingSpecIndex := clippingSpecIndex + 2 ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7216-Fixes-JuanVuletich-2025Apr09-08h37m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7123] on 9 April 2025 at 10:26:21 am'!
!VectorEngineDrawer methodsFor: 'private' stamp: 'jmv 4/9/2025 10:22:21'!
                            pvtDashedStrokeBits: onOffBitSequence dashBitCount: numberOfBitsInSequence dashBitLength: lengthOfEachBit dashBitOffset: offset
	"For dashed strokes"

	dashedStrokeBits := onOffBitSequence.
	dashBitCount := numberOfBitsInSequence.
	dashBitLength := lengthOfEachBit.
	dashBitOffset := offset.! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/9/2025 10:23:54' overrides: 50387781!
                       pvtDashedStrokeBits: onOffBitSequence dashBitCount: numberOfBitsInSequence dashBitLength: lengthOfEachBit dashBitOffset: offset
	"For dashed strokes"

	dashedStrokeBits := onOffBitSequence.
	dashBitCount := numberOfBitsInSequence.
	dashBitLength := lengthOfEachBit.
	dashBitOffset := offset.
	self
		primDashedStrokeBits: dashedStrokeBits
		dashBitCount: dashBitCount
		dashBitLength: dashBitLength
		dashBitOffset: dashBitOffset.! !
!VectorEngineWithPlugin methodsFor: 'plugin calls' stamp: 'jmv 4/9/2025 10:23:26'!
                           primDashedStrokeBits: onOffBitSequence dashBitCount: numberOfBitsInSequence dashBitLength: lengthOfEachBit dashBitOffset: offset
	<primitive: 'dashedStrokeBitsSet' module: 'VectorEnginePlugin'>

	self primitiveFailed! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/9/2025 10:25:34' prior: 50383942!
    basicStrokeWidth: aStrokeWidth color: aStrokeColor dashedStrokeBits: onOffBitSequence dashBitCount: numberOfBitsInSequence dashBitLength: lengthOfEachBit dashBitOffset: offset do: pathCommandsBlock ensureClosePath: ensureClosePath
	"Prepare parameters for drawing stroke.
	Do dashed strokes. This spec is periodic, the pattern is repeated as needed.
		onOffBitSequence is an integer number, a sequence of bits specifying on/off parts
		numberOfBitsInSequence is the number of bits in onOffBitSequence
		lengthOfEachBit is exactly that.
		Offset can be used to do 'walking dashes' effects. It is an integer in [0 .. numberOfBitsInSequence-1]."

	| sharper apparentWeight strokeColorToUse strokeWidthToUse |
	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self ].
	aStrokeWidth = 0.0 ifTrue: [ ^self ].
	strokeWidthToUse := aStrokeWidth.
	strokeColorToUse := aStrokeColor.
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"There are two possible strategies when requested stroke width is narrower than anti aliasing filter.
			To more effectively avoid aliasing, set sharper to false.
			To draw sharper thin lines, at the price of very little extra aliasing in them, set sharper to true.
			This could be turned into a Preference."
			sharper := true.
			sharper ifTrue: [
				"If the requested stroke width is used, filter will be clipped, resulting in an incorrect weight for the stroke."
				apparentWeight := ((aStrokeWidth squared / antiAliasingWidth) + (2.0 * aStrokeWidth) + antiAliasingWidth) / 4.0.
				"{'(sharper)desired weight'. aStrokeWidth. 'but would get'. apparentWeight. 'correction'. aStrokeWidth / apparentWeight} print."
				strokeColorToUse := aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / apparentWeight ]
			ifFalse: [
				"If the requested stroke width is too thin, make them wide enough to be properly sampled."
				"{'(wider)desired weight'. aStrokeWidth. 'but would get'. antiAliasingWidth. 'correction'. aStrokeWidth / antiAliasingWidth} print."
				strokeWidthToUse := antiAliasingWidth.
				strokeColorToUse := aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / antiAliasingWidth ]].
	self pvtStrokeWidth: strokeWidthToUse hop: (aStrokeWidth sqrt / 2.0 max: 0.5).  "See #experimentHopsPerPixel2"
	self pvtStrokeColor: strokeColorToUse.
	self pvtFillColor: nil.

	"For dashed strokes"
	self pvtDashedStrokeBits: onOffBitSequence dashBitCount: numberOfBitsInSequence dashBitLength: lengthOfEachBit dashBitOffset: offset.

	self doPath: pathCommandsBlock ensureClosePath: ensureClosePath.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/9/2025 10:24:51' prior: 50384803!
         basicStrokeWidth: aStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	| hopToUse |
	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	(aFillColor isNil or: [ aFillColor alpha = 0.0]) ifTrue: [
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: false ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		canvas ifNotNil: [ canvas initForPath ].
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: true ].

	hopToUse := aStrokeWidth < 4
		ifTrue: [ 0.5 ] "See #experimentHopsPerPixel1"
		ifFalse: [ 1.0 ]. "See #experimentHopsPerPixel2."
				"Correct edgeCount for fills requires visiting at least once every y coordinate, hop can not be larger than 1."
	self pvtStrokeWidth: aStrokeWidth hop: hopToUse.
	self pvtStrokeColor: aStrokeColor.
	self pvtFillColor: aFillColor.

	"Only used for strokes with no fill"
	self pvtDashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0.

	self doPath: pathCommandsBlock ensureClosePath: true.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/9/2025 10:25:06' prior: 50384084!
                     fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	(aFillColor isNil or: [ aFillColor alpha = 0.0]) ifTrue: [ ^ self ].
	self pvtStrokeWidth: 0.0 hop: 0.5. "See #experimentHopsPerPixel3"
	self pvtStrokeColor: nil.
	self pvtFillColor: aFillColor.

	"Only used for strokes with no fill"
	self pvtDashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0.

	self doPath: pathCommandsBlock ensureClosePath: true.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7217-DashedStrokesParameters-JuanVuletich-2025Apr09-10h00m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7127] on 9 April 2025 at 11:34:04 am'!
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/9/2025 11:31:12' prior: 50385565 overrides: 17000856!
                    initializePath

	super initializePath.

	"Set all plugin state. There might be several instances of this class, all using the same plugin.
	Only one of them will use the plugin during a path draw operation. See class variable AccessLock."
	self
		primTargetBits: targetForm bits
		morphIds: morphIds
		edgeCounts: edgeCounts
		alphaMask: alphaMask
		affectedBits: affectedBits
		contour: contour
		targetWidth: targetWidth
		targetHeight: targetHeight.
	self primTargetAssumedOpaque: targetAssumedOpaque.
	self
		primAntiAliasingWidth: antiAliasingWidth asFloat
		subPixelDelta: self subPixelDelta asFloat.
	self primClipLeft: clipLeft clipTop: clipTop clipRight: clipRight clipBottom: clipBottom.
	self clippingSpec: clippingSpec.
	self primCurrentMorphId: currentMorphId.
	self
		primGeometryTxA11: geometryTransformation a11 asFloat
		a12: geometryTransformation a12 asFloat
		a13: geometryTransformation a13 asFloat
		a21: geometryTransformation a21 asFloat
		a22: geometryTransformation a22 asFloat
		a23: geometryTransformation a23 asFloat.

	self primInitializePath.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7218-SetClippingSpecOnInitializePath-JuanVuletich-2025Apr09-11h28m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7127] on 9 April 2025 at 11:40:30 am'!
!VectorEngineSubPixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/9/2025 11:39:19' prior: 50384368!
       updateAlphasForX: x y: y
	| distanceToAxisSquared alpha t b l r alphaWord doUpdate dySquared dx dy pixelIndex dxp bit lastUpdated affectedBitsIndex |
	
	"In a basic implementation, this method computes anti aliasing translucency for all possibly affected pixels as determined by
	the outer radius of the pen nib: swDilatedHalfSquared.
	But usually the next point visited is very close to the last, and there's no real need to fill the inner part of the pen nib as opaque,
	as it was already set. So, unless needsFullAlphaCircle, only the outer ring is computed and stored.
	The inner radius of this ring is swErodedHalfSquared"

	"If dashed strokes, only draw if in a dash, not in a gap."
	dashBitLength = 0.0 ifFalse: [
		"Compute trajectory length. This is not precise. In many cases the actual hop used is smaller than this."
		trajectoryLength := trajectoryLength + hop.
		"This code is robust against #floor and #\\ (and their translation to C, and the C compiler) because dashBitOffset is guaranteed to be non negative."
		bit := (trajectoryLength / dashBitLength) floor + dashBitOffset \\ dashBitCount.
		(dashedStrokeBits bitAt: dashBitCount - bit) = 1 ifFalse: [
			needsFullAlphaCircle := true.
			^self ]].

	"Compute affected rect. Honor clipRect"
	t := (y - swDilatedHalf + 1) truncated.		"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	t < clipTop ifTrue: [ t := clipTop ].
	b := (y + swDilatedHalf) truncated.
	b > clipBottom ifTrue: [ b := clipBottom ].
	l := (x - swDilatedHalf - subPixelDelta + 1) truncated.		"(z+1) truncated works equally well than (z ceiling)"
	l < clipLeft ifTrue: [ l := clipLeft ].
	r := (x + swDilatedHalf + subPixelDelta) truncated.
	r > clipRight ifTrue: [ r := clipRight ].

	lastUpdated := -1.
	t to: b do: [ :displayY |
		pixelIndex := displayY * targetWidth + l.
		dy := displayY - y.
		dySquared := dy * dy.
		l to: r do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			dx := displayX - x.
			distanceToAxisSquared := dx * dx + dySquared. "Use Green subpixel for this."
			(needsFullAlphaCircle or: [distanceToAxisSquared > swErodedHalfSquared]) ifTrue: [
				alphaWord := alphaMask bytesAt: pixelIndex.
				alphaWord = "16r007F7F7F" #[16r7F 16r7F 16r7F 16r00] ifFalse: [
					doUpdate := false.
					"Red"
					dxp := dx - subPixelDelta.
					distanceToAxisSquared := dxp * dxp + dySquared.
					distanceToAxisSquared < swDilatedHalfSquared
						ifTrue: [
							alpha := (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated.
							alpha > (alphaWord at: 3) ifTrue: [
								alphaWord at: 3 put: (alpha min: 16r7F).
								doUpdate := true ]].
					"Green"
					distanceToAxisSquared := dx * dx + dySquared.
					distanceToAxisSquared < swDilatedHalfSquared
						ifTrue: [
							alpha := (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated.
							alpha > (alphaWord at: 2) ifTrue: [
								alphaWord at: 2 put: (alpha min: 16r7F).
								doUpdate := true ]].
					"Blue"
					dxp := dx + subPixelDelta.
					distanceToAxisSquared := dxp * dxp + dySquared.
					distanceToAxisSquared < swDilatedHalfSquared
						ifTrue: [
							alpha := (swDilatedHalf - distanceToAxisSquared sqrt * aawScaledInverse) truncated.
							alpha > (alphaWord at: 1) ifTrue: [
								alphaWord at: 1 put: (alpha min: 16r7F).
								doUpdate := true ]].
					doUpdate ifTrue: [
						affectedBitsIndex := pixelIndex-1>>4+1.
						lastUpdated = affectedBitsIndex ifFalse: [ "Slight optimization"
							(affectedBits at: affectedBitsIndex) = 1 ifFalse: [
								affectedBits at: affectedBitsIndex put: 1.
								lastUpdated := affectedBitsIndex ]].
						alphaMask bytesAt: pixelIndex put: alphaWord ]]]]].
	needsFullAlphaCircle := false.! !
!VectorEngineWholePixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/9/2025 11:39:31' prior: 50384489!
      updateAlphasForX: x y: y
	| distanceToAxisSquared alpha t b l r prevAlpha dx dy pixelIndex bit lastUpdated affectedBitsIndex |
	
	"In a basic implementation, this method computes anti aliasing translucency for all possibly affected pixels as determined by
	the outer radius of the pen nib: swDilatedHalfSquared.
	But usually the next point visited is very close to the last, and there's no real need to fill the inner part of the pen nib as opaque,
	as it was already set. So, unless needsFullAlphaCircle, only the outer ring is computed and stored.
	The inner radius of this ring is swErodedHalfSquared"

	"If dashed strokes, only draw if in a dash, not in a gap."
	dashBitLength = 0.0 ifFalse: [
		"Compute trajectory length. This is not precise. In many cases the actual hop used is smaller than this."
		trajectoryLength := trajectoryLength + hop.
		"This code is robust against #floor and #\\ (and their translation to C, and the C compiler) because dashBitOffset is guaranteed to be non negative."
		bit := (trajectoryLength / dashBitLength) floor + dashBitOffset \\ dashBitCount.
		(dashedStrokeBits bitAt: dashBitCount - bit) = 1 ifFalse: [
			needsFullAlphaCircle := true.
			^self ]].

	"Compute affected rect. Honor clipRect."
	t := (y - swDilatedHalf + 1) truncated.			"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	t < clipTop ifTrue: [ t := clipTop ].
	b := (y + swDilatedHalf) truncated.
	b > clipBottom ifTrue: [ b := clipBottom ].
	l := (x - swDilatedHalf + 1) truncated.			"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	l < clipLeft ifTrue: [ l := clipLeft ].
	r := (x + swDilatedHalf) truncated.
	r > clipRight ifTrue: [ r := clipRight ].

	lastUpdated := -1.
	t to: b do: [ :displayY |
		pixelIndex := displayY * targetWidth + l.
		dy := displayY - y.
		l to: r do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			dx := displayX - x.
			distanceToAxisSquared := (dx*dx) + (dy*dy).
			(needsFullAlphaCircle or: [distanceToAxisSquared > swErodedHalfSquared]) ifTrue: [
				prevAlpha := alphaMask at: pixelIndex.
				prevAlpha = 16r7F ifFalse: [
					distanceToAxisSquared < swDilatedHalfSquared
						ifTrue: [
							alpha := ((swDilatedHalf - distanceToAxisSquared sqrt min: antiAliasingWidth) * aawScaledInverse) truncated.
							alpha > prevAlpha ifTrue: [
								affectedBitsIndex := pixelIndex-1>>4+1.
								lastUpdated = affectedBitsIndex ifFalse: [ "Slight optimization"
									(affectedBits at: affectedBitsIndex) = 1 ifFalse: [
										affectedBits at: affectedBitsIndex put: 1.
										lastUpdated := affectedBitsIndex ]].
								alphaMask at: pixelIndex put: alpha ]]]]]].
	needsFullAlphaCircle := false.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7219-TweaksToHelpSlang-JuanVuletich-2025Apr09-11h34m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7129] on 9 April 2025 at 3:11:37 pm'!
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/9/2025 15:09:32' prior: 50387821!
         basicStrokeWidth: aStrokeWidth color: aStrokeColor dashedStrokeBits: onOffBitSequence dashBitCount: numberOfBitsInSequence dashBitLength: lengthOfEachBit dashBitOffset: offset do: pathCommandsBlock ensureClosePath: ensureClosePath
	"Prepare parameters for drawing stroke.
	Do dashed strokes. This spec is periodic, the pattern is repeated as needed.
		onOffBitSequence is an integer number, a sequence of bits specifying on/off parts
		numberOfBitsInSequence is the number of bits in onOffBitSequence
		lengthOfEachBit is exactly that.
		Offset can be used to do 'walking dashes' effects. It is an integer in [0 .. numberOfBitsInSequence-1]."

	| sharper apparentWeight strokeColorToUse strokeWidthToUse hopToUse |
	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self ].
	aStrokeWidth = 0.0 ifTrue: [ ^self ].
	strokeWidthToUse := aStrokeWidth.
	strokeColorToUse := aStrokeColor.
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"There are two possible strategies when requested stroke width is narrower than anti aliasing filter.
			To more effectively avoid aliasing, set sharper to false.
			To draw sharper thin lines, at the price of very little extra aliasing in them, set sharper to true.
			This could be turned into a Preference."
			sharper := true.
			sharper ifTrue: [
				"If the requested stroke width is used, filter will be clipped, resulting in an incorrect weight for the stroke."
				apparentWeight := ((aStrokeWidth squared / antiAliasingWidth) + (2.0 * aStrokeWidth) + antiAliasingWidth) / 4.0.
				"{'(sharper)desired weight'. aStrokeWidth. 'but would get'. apparentWeight. 'correction'. aStrokeWidth / apparentWeight} print."
				strokeColorToUse := aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / apparentWeight ]
			ifFalse: [
				"If the requested stroke width is too thin, make them wide enough to be properly sampled."
				"{'(wider)desired weight'. aStrokeWidth. 'but would get'. antiAliasingWidth. 'correction'. aStrokeWidth / antiAliasingWidth} print."
				strokeWidthToUse := antiAliasingWidth.
				strokeColorToUse := aStrokeColor alpha: aStrokeColor alpha * aStrokeWidth / antiAliasingWidth ]].
	hopToUse := onOffBitSequence > 0
		ifTrue: [ 0.5 ] 								"Don't use larger hop. Always start each dash from the beginning."
		ifFalse: [ aStrokeWidth sqrt / 2.0 max: 0.5 ]. 	"See #experimentHopsPerPixel2."
	self pvtStrokeWidth: strokeWidthToUse hop: hopToUse.
	self pvtStrokeColor: strokeColorToUse.
	self pvtFillColor: nil.

	"For dashed strokes"
	self pvtDashedStrokeBits: onOffBitSequence dashBitCount: numberOfBitsInSequence dashBitLength: lengthOfEachBit dashBitOffset: offset.

	self doPath: pathCommandsBlock ensureClosePath: ensureClosePath.! !
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/9/2025 14:44:06' prior: 50379502!
         strokeWidth: clientStrokeWidth color: aStrokeColor dashedStrokeBits: onOffBitSequence dashBitLength: clientLengthOfEachBit dashBitOffset: offsetOrNil do: pathCommandsBlock
	"Prepare parameters for drawing a dashed stroke.
	This spec is periodic, the pattern is repeated as needed.
		- onOffBitSequence is an integer number, a sequence of bits specifying on/off parts
		- clientLengthOfEachBit is exactly that, the actual length of stroke for each bit
		- offsetOrNil can be used to do 'walking dashes' effects. It is an integer (nil defaults to 0)."

	| bitSequence bitSequenceLength lengthOfEachBit offset |
	bitSequence := onOffBitSequence asInteger max: 1.
	bitSequenceLength := bitSequence highBit.
	lengthOfEachBit := clientLengthOfEachBit ifNil: [ 1.0 ].
	lengthOfEachBit := lengthOfEachBit asFloat.
	lengthOfEachBit <= 0.0 ifTrue: [ lengthOfEachBit := 1.0 ].
	lengthOfEachBit := geometryTransformation externalizeScalar: lengthOfEachBit.
	offset := offsetOrNil ifNil: [0].
	offset := offset asInteger \\ bitSequenceLength.

	self
		basicStrokeWidth: (geometryTransformation externalizeScalar: clientStrokeWidth)
		color: aStrokeColor
		dashedStrokeBits: bitSequence
		dashBitCount: bitSequence highBit 
		dashBitLength: lengthOfEachBit
		dashBitOffset: offset
		do: pathCommandsBlock
		ensureClosePath: false! !
!VectorEngineSmalltalk methodsFor: 'private' stamp: 'jmv 4/9/2025 15:07:28' prior: 50383872 overrides: 50383858!
        pvtStrokeWidth: aNumber hop: aFloat

	| swErodedHalf |
	strokeWidth := aNumber.
	hop := aFloat.
	swDilatedHalf := strokeWidth + antiAliasingWidth * 0.5.
	swDilatedHalfSquared := swDilatedHalf * swDilatedHalf.
	"swErodedHalf is the inner radious of the alphas ring.
	See #updateAlphasForX:y:"
	swErodedHalf := strokeWidth - antiAliasingWidth * 0.5 -hop - 2.5.
	swErodedHalfSquared := swErodedHalf * swErodedHalf abs.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7220-smallHopForDashedStrokes-JuanVuletich-2025Apr09-14h44m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7129] on 9 April 2025 at 3:16:15 pm'!
!VectorEngineWithPlugin class methodsFor: 'instance creation' stamp: 'jmv 4/8/2025 15:24:27' prior: 50374085!
  isPluginAvailable
	"
	VectorEngineWithPlugin isPluginAvailable
	Check if services provided by VM plugin match this class requirements.
	"
	| pluginApiVersion |
	pluginApiVersion := self pluginApiVersion.
	^ pluginApiVersion = 7! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
| activeProc guiRoot |
(nil inform: 'After this update, #7221,
we need to restart the User Interface process.
Please do World / Changes... / [Install New Updates].').
[
	ChangeSet installing: '7221-EnableVectorEnginePluginV7-JuanVuletich-2025Apr09-15h11m-jmv.001.cs.st' do: [].
	cs _ ChangeSet changeSetForBaseSystem.
	(cs name beginsWith: '7221') ifTrue: [
		ChangeSet removeChangeSet: cs ].
	'Installed ChangeSet: 7221-EnableVectorEnginePluginV7-JuanVuletich-2025Apr09-15h11m-jmv.001.cs.st' print.
	'Please do World / Changes... / [Install New Updates].' print.
	Utilities logsUserChanges: true.
] forkAt: 39.
UISupervisor ui setupNewCanvasAndEngine.
UISupervisor newUIProcess.
Processor activeProcess terminate.
!

'From Cuis7.3 [latest update: #7129] on 11 April 2025 at 2:06:42 pm'!
!VectorEngineSmalltalk methodsFor: 'primitive algorithms' stamp: 'jmv 4/11/2025 14:06:32' prior: 50384254!
   quadraticBezierFromX: xFrom y: yFrom toX: xTo y: yTo controlX: xControl y: yControl

	| p txFrom tyFrom txTo tyTo txControl tyControl dx dy dx2 dy2 xMinEnd xMaxEnd yMinEnd yMaxEnd t oneLessT increment f2 f3 f1 x y t0 x0 y0 length correction |

	"If control point is bogus, just draw a line"
	(xControl = xTo and: [ yControl = yTo ]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].
	(xControl = xFrom and: [ yControl = yFrom ]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].
	
	trajectoryLength := 0.0.
	needsFullAlphaCircle := true.

	p := geometryTransformation externalizePosition: xFrom@yFrom. txFrom := p x. tyFrom := p y.
	p := geometryTransformation externalizePosition: xTo@yTo. txTo := p x. tyTo := p y.
	p := geometryTransformation externalizePosition: xControl@yControl. txControl := p x. tyControl := p y.

	dx := (txTo-txFrom) abs.
	dx2 := (txControl-txFrom) abs.
	dy := (tyTo-tyFrom) abs.
	dy2 := (tyControl-tyFrom) abs.

	"If almost a vertical line, just draw a line. (Ignoring control point)"
	(dx < 1.0 and: [dx2 < 1.0]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].

	"If almost an horizontal line, just draw a line. (Ignoring control point)"
	(dy < 1.0 and: [dy2 < 1.0]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].

	"This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe."
	xMinEnd := txFrom min: txTo.
	xMaxEnd := txFrom max: txTo.
	yMinEnd := tyFrom min: tyTo.
	yMaxEnd := tyFrom max: tyTo.
	spanLeft := spanLeft min: (xMinEnd min: (xMinEnd+txControl) / 2.0).
	spanRight := spanRight max: (xMaxEnd max: (xMaxEnd+txControl) / 2.0).
	spanTop := spanTop min: (yMinEnd min: (yMinEnd+tyControl) / 2.0).
	spanBottom := spanBottom max: (yMaxEnd max: (yMaxEnd+tyControl) / 2.0).

	"Case t = 0.0"
	x := txFrom.
	y := tyFrom.
	self updateAlphasForX: x y: y.
	fillColor notNil ifTrue: [
		self updateEdgeCountAtX: x y: y ].
	self updateContourForX: x y: y.

	"Will be corrected for each hop. This, being close to pointFrom, is a good initial guess for first correction."
	increment := 0.5 / (dx max: dy) min: 0.5.
	t := 0.0.
	[
		t0 := t. x0 := x. y0 := y.
		"Compute next point"
		t := t0 + increment. oneLessT := 1.0 - t.
		f1 := oneLessT * oneLessT. f2 := 2.0 * oneLessT * t. f3 := t * t.
		x := (f1 * txFrom) + (f2 * txControl) + (f3 * txTo).
		y := (f1 * tyFrom) + (f2 * tyControl) + (f3 * tyTo).
		"Now adjust the increment to aim at the required hop length, and recompute next point."
		length := ((x-x0)@(y-y0)) r.
		correction := hop / length.
		[
			increment := increment * correction.
			t := t0 + increment. oneLessT := 1.0 - t.
			f1 := oneLessT * oneLessT. f2 := 2.0 * oneLessT * t. f3 := t * t.
			x := (f1 * txFrom) + (f2 * txControl) + (f3 * txTo).
			y := (f1 * tyFrom) + (f2 * tyControl) + (f3 * tyTo).
			length := ((x-x0)@(y-y0)) r.
			correction := hop / length.
			correction < 0.99]  whileTrue.		   "Keep adjusting if actual hop would be too big"
		t < 1.0 ]
	whileTrue: [
		self updateAlphasForX: x y: y.
		fillColor notNil ifTrue: [
			self updateEdgeCountAtX: x y: y ].
		self updateContourForX: x y: y ].

	"Case t= 1.0"
	self updateAlphasForX: txTo y: tyTo.
	fillColor notNil ifTrue: [
		self updateEdgeCountAtX: txTo y: tyTo ].
	self updateContourForX: txTo y: tyTo.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7222-QuadBezier-robustAgainst32BitFloatRoundingInPlugin-JuanVuletich-2025Apr11-12h33m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7130] on 11 April 2025 at 2:48:44 pm'!
!VectorEngineSubPixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/11/2025 14:30:15'!
                              updateAlphasZeroStrokeForX: x y: y
	"This optimization is currently only implemented for the Whole Pixel engine.
	See implementors and senders."

	self updateAlphasForX: x y: y! !
!VectorEngineWholePixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/11/2025 14:40:11'!
          updateAlphasZeroStrokeForX: x y: y
	"Optimization.
	Assumptions:
		- strokeWidth = 0.0
		- antiAliasingWidth = 1.6 (Default for whole pixel anti aliasing)
	Therefore:
		- swDilatedHalf = 0.8
		- swDilatedHalfSquared = 0.64
		- aawScaledInverse = 79.375
		- No use for needsFullAlphaCircle, swErodedHalfSquared
		- No support for dashedStrokes
		"
	| distanceToAxisSquared alpha t b l r prevAlpha dx dxSquared dx2 dx2Squared dy dySquared dy2 dy2Squared pixelIndex affectedBitsIndex1 affectedBitsIndex2 |
	"Compute affected rect. Honor clipRect."
	t := y truncated.
	b := t + 1.
	l := x truncated.
	r := l + 1.
	t < clipTop ifTrue: [ t := clipTop ].
	b > clipBottom ifTrue: [ b := clipBottom ].
	l < clipLeft ifTrue: [ l := clipLeft ].
	r > clipRight ifTrue: [ r := clipRight ].
	t> b ifTrue: [ ^self ].
	l > r ifTrue: [ ^self ].

	pixelIndex := t * targetWidth + l + 1.
	affectedBitsIndex1 := -1.
	dy := t - y.
	dySquared := dy * dy.
	dx := l - x.
	dxSquared := dx * dx.
	distanceToAxisSquared := dxSquared + dySquared.
	distanceToAxisSquared < 0.64 ifTrue: [
		prevAlpha := alphaMask at: pixelIndex.
		prevAlpha = 16r7F ifFalse: [
			alpha := ((0.8 - distanceToAxisSquared sqrt) * 79.375) truncated.
			alpha > prevAlpha ifTrue: [
				affectedBitsIndex1 := pixelIndex-1>>4+1.
				(affectedBits at: affectedBitsIndex1) = 0 ifTrue: [
					affectedBits at: affectedBitsIndex1 put: 1 ].
				alphaMask at: pixelIndex put: alpha ]].
		distanceToAxisSquared < 0.36 ifTrue: [ ^self ]].

	r = l ifFalse: [
		dx2 := dx + 1.
		dx2Squared := dx2 * dx2.
		distanceToAxisSquared := dx2Squared + dySquared.
		distanceToAxisSquared < 0.64 ifTrue: [
			prevAlpha := alphaMask at: pixelIndex+1.
			prevAlpha = 16r7F ifFalse: [
				alpha := ((0.8 - distanceToAxisSquared sqrt) * 79.375) truncated.
				alpha > prevAlpha ifTrue: [
					affectedBitsIndex2 := pixelIndex+1-1>>4+1.
					affectedBitsIndex2 = affectedBitsIndex1 ifFalse: [
						(affectedBits at: affectedBitsIndex2) = 0 ifTrue: [
							affectedBits at: affectedBitsIndex2 put: 1 ]].
					alphaMask at: pixelIndex+1 put: alpha ]].
			distanceToAxisSquared < 0.36 ifTrue: [ ^self ]]].

	t = b ifTrue: [ ^self ].

	pixelIndex := b * targetWidth + l + 1.
	affectedBitsIndex1 := -1.
	dy2 := dy + 1.
	dy2Squared := dy2 * dy2.
	distanceToAxisSquared := dxSquared + dy2Squared.
	distanceToAxisSquared < 0.64 ifTrue: [
		prevAlpha := alphaMask at: pixelIndex.
		prevAlpha = 16r7F ifFalse: [
			alpha := ((0.8 - distanceToAxisSquared sqrt) * 79.375) truncated.
			alpha > prevAlpha ifTrue: [
				affectedBitsIndex1 := pixelIndex-1>>4+1.
				(affectedBits at: affectedBitsIndex1) = 0 ifTrue: [
					affectedBits at: affectedBitsIndex1 put: 1 ].
				alphaMask at: pixelIndex put: alpha ]].
		distanceToAxisSquared < 0.36 ifTrue: [ ^self ]].

	r = l ifFalse: [
		distanceToAxisSquared := dx2Squared + dy2Squared.
		distanceToAxisSquared < 0.64 ifTrue: [
			prevAlpha := alphaMask at: pixelIndex+1.
			prevAlpha = 16r7F ifFalse: [
				alpha := ((0.8 - distanceToAxisSquared sqrt) * 79.375) truncated.
				alpha > prevAlpha ifTrue: [
					affectedBitsIndex2 := pixelIndex+1-1>>4+1.
					affectedBitsIndex2 = affectedBitsIndex1 ifFalse: [
						(affectedBits at: affectedBitsIndex2) = 0 ifTrue: [
							affectedBits at: affectedBitsIndex2 put: 1 ]].
					alphaMask at: pixelIndex+1 put: alpha ]]]].! !
!VectorEngineWholePixel methodsFor: 'primitive algorithms - aux' stamp: 'jmv 4/11/2025 14:30:26' prior: 50388155!
           updateAlphasForX: x y: y
	| distanceToAxisSquared alpha t b l r prevAlpha dx dy pixelIndex bit lastUpdated affectedBitsIndex |

	"Use this optimized varsion if possible."	
	(strokeWidth = 0.0 and: [antiAliasingWidth = 1.6]) ifTrue: [
		^self updateAlphasZeroStrokeForX: x y: y ].

	"In a basic implementation, this method computes anti aliasing translucency for all possibly affected pixels as determined by
	the outer radius of the pen nib: swDilatedHalfSquared.
	But usually the next point visited is very close to the last, and there's no real need to fill the inner part of the pen nib as opaque,
	as it was already set. So, unless needsFullAlphaCircle, only the outer ring is computed and stored.
	The inner radius of this ring is swErodedHalfSquared"

	"If dashed strokes, only draw if in a dash, not in a gap."
	dashBitLength = 0.0 ifFalse: [
		"Compute trajectory length. This is not precise. In many cases the actual hop used is smaller than this."
		trajectoryLength := trajectoryLength + hop.
		"This code is robust against #floor and #\\ (and their translation to C, and the C compiler) because dashBitOffset is guaranteed to be non negative."
		bit := (trajectoryLength / dashBitLength) floor + dashBitOffset \\ dashBitCount.
		(dashedStrokeBits bitAt: dashBitCount - bit) = 1 ifFalse: [
			needsFullAlphaCircle := true.
			^self ]].

	"Compute affected rect. Honor clipRect."
	t := (y - swDilatedHalf + 1) truncated.			"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	t < clipTop ifTrue: [ t := clipTop ].
	b := (y + swDilatedHalf) truncated.
	b > clipBottom ifTrue: [ b := clipBottom ].
	l := (x - swDilatedHalf + 1) truncated.			"(z+1) truncated works equally well than the more intuitive (z ceiling)"
	l < clipLeft ifTrue: [ l := clipLeft ].
	r := (x + swDilatedHalf) truncated.
	r > clipRight ifTrue: [ r := clipRight ].

	lastUpdated := -1.
	t to: b do: [ :displayY |
		pixelIndex := displayY * targetWidth + l.
		dy := displayY - y.
		l to: r do: [ :displayX |
			pixelIndex := pixelIndex + 1.
			dx := displayX - x.
			distanceToAxisSquared := (dx*dx) + (dy*dy).
			(needsFullAlphaCircle or: [distanceToAxisSquared > swErodedHalfSquared]) ifTrue: [
				prevAlpha := alphaMask at: pixelIndex.
				prevAlpha = 16r7F ifFalse: [
					distanceToAxisSquared < swDilatedHalfSquared
						ifTrue: [
							alpha := ((swDilatedHalf - distanceToAxisSquared sqrt min: antiAliasingWidth) * aawScaledInverse) truncated.
							alpha > prevAlpha ifTrue: [
								affectedBitsIndex := pixelIndex-1>>4+1.
								lastUpdated = affectedBitsIndex ifFalse: [ "Slight optimization"
									(affectedBits at: affectedBitsIndex) = 1 ifFalse: [
										affectedBits at: affectedBitsIndex put: 1.
										lastUpdated := affectedBitsIndex ]].
								alphaMask at: pixelIndex put: alpha ]]]]]].
	needsFullAlphaCircle := false.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7223-ZeroStrokeOptimization-JuanVuletich-2025Apr11-14h11m-jmv.004.cs.st----!

'From Cuis7.3 [latest update: #7131] on 11 April 2025 at 3:11:56 pm'!
!Morph methodsFor: 'drawing' stamp: 'jmv 4/11/2025 15:10:16' prior: 50369721!
                             imageForm: extentOrNil depth: depth

	| answerExtent answer auxCanvas bounds |
	self ensureMinimumExtent.

	self requiresVectorCanvas ifTrue: [	
		^ self imageFormVG: extentOrNil depth: depth ].

	bounds := self fullBoundsInOwner.
	answerExtent := bounds extent.
	extentOrNil ifNotNil: [ answerExtent := answerExtent min: extentOrNil * 4 ].
	auxCanvas := MorphicCanvas depth: depth over: (bounds origin extent: answerExtent ceiling).
	auxCanvas fullDraw: self.
	answer := auxCanvas form.
	"answer divideByAlpha."
	answer makeAllPixelsOpaque.
	extentOrNil ifNotNil: [ answer := answer magnifyTo: extentOrNil ].
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7224-imageForm-Fix-JuanVuletich-2025Apr11-15h05m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7132] on 13 April 2025 at 7:51:55 pm'!
!UnicodeString methodsFor: 'dispatch' stamp: 'jmv 4/13/2025 19:45:19'!
        drawOnBitBltCanvasEngine: engine from: startIndex to: stopIndex at: p font: aTrueTypeFont color: color

	| byteStartIndex byteStopIndex |
	byteStartIndex := self byteIndexAt: startIndex.
	byteStopIndex := (self byteIndexAt: stopIndex+1)-1.
	^engine
		drawUtf8: bytes
		fromByte: byteStartIndex
		toByte: byteStopIndex
		at: p
		trueTypeFont: aTrueTypeFont
		color: color.! !
!UnicodeString methodsFor: 'dispatch' stamp: 'jmv 4/13/2025 19:44:38'!
  drawOnVectorEngine: engine from: startIndex to: stopIndex at: aPoint font: aTrueTypeFont color: color

	| byteStartIndex byteStopIndex p answer d |
	byteStartIndex := self byteIndexAt: startIndex.
	byteStopIndex := (self byteIndexAt: stopIndex+1)-1.
	"Please keep consistent with #basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:"
	p := aTrueTypeFont isSuperscript
		ifTrue: [ aPoint x  @ (aPoint y - (aTrueTypeFont ascent*0.55)) ]
		ifFalse: [
			aTrueTypeFont isSubscript
				ifTrue: [aPoint x @ (aPoint y + (aTrueTypeFont ascent*0.3))]
				ifFalse: [ aPoint ]].
	answer := engine
		displayUtf8: bytes
		fromByte: byteStartIndex toByte: byteStopIndex
		at: p
		trueTypeFont: aTrueTypeFont fontDescription
		color: color
		scale: aTrueTypeFont pointSize
		preventMirroring: true.
	"Please keep consistent with #makeUnderlinedGlyph:"
	aTrueTypeFont isUnderlined ifTrue: [
		d := aTrueTypeFont descent *0.7.
		engine strokeWidth: 2 color: color do: [
			engine moveTo: p + (0@d); lineTo: answer + (0@d) ]].
	"Please keep consistent with #makeStruckThroughGlyph:"
	aTrueTypeFont isStruckThrough ifTrue: [
		d := aTrueTypeFont ascent * 0.25.
		engine strokeWidth: 1 color: color do: [
			engine moveTo: p - (0@d); lineTo: answer - (0@d) ]].
	^answer! !
!BitBltCanvasEngine methodsFor: 'text' stamp: 'jmv 4/13/2025 19:46:37'!
                     drawUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTrueTypeFont color: foregroundColor
	"If required, do a second pass with new rule and colorMap.
	Answer position to place next glyph
	Answer nil if nothing was done
	"

	| answer prevRule secondPassMap sourceDepth destDepth |

	"Slight optimization when there's nothing to do."
	clipHeight = 0 ifTrue: [^nil].
	clipWidth = 0 ifTrue: [^nil].

	sourceForm := nil. "Set it for each glyph"
	sourceX := 0.
	sourceY := 0.
	height := nil. "Set it for each glyph as sourceForm height".
	self setRuleAndMapFor: 32 foregroundColor: (foregroundColor alpha: 1).

	"If combinationRule is rgbMul, we might need the special two-pass technique for component alpha blending.
	If not, do it simply"
	combinationRule = 37 "rgbMul" ifFalse: [
		^self basicDrawUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTrueTypeFont ].
	
	"We need to do a second pass. The colormap set is for use in the second pass."
	secondPassMap := colorMap.
	sourceDepth := aTrueTypeFont cachedFormDepth.
	destDepth := destForm depth.
	colorMap := sourceDepth ~= destDepth
		ifTrue: [ Color cachedColormapFrom: sourceDepth to: destDepth ].
	answer := self basicDrawUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTrueTypeFont.
	colorMap := secondPassMap.
	secondPassMap ifNotNil: [
		prevRule := combinationRule.
		combinationRule := 20. "rgbAdd"
		self basicDrawUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTrueTypeFont.
		combinationRule := prevRule ].
	^answer! !
!BitBltCanvasEngine methodsFor: 'private' stamp: 'jmv 4/13/2025 19:46:11'!
       basicDrawUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTrueTypeFont
	"Answer position to place next glyph"

	| fdestX glyph firstByte maxHeight byteIndex n ascent lineGap deltaXToCenter deltaXForBaseGlyph deltaXForDiacriticalMark baseGlyphTopOffset deltaYForDiacriticalMark |
	deltaXForBaseGlyph := 0.
	baseGlyphTopOffset := 0.
	ascent := aTrueTypeFont ascent.		  "expensive"
	lineGap := aTrueTypeFont lineGap."expensive"
	destY := aPoint y.
	fdestX := aPoint x.
	maxHeight := 0.
	byteIndex := byteStartIndex.
	[  byteIndex <= byteStopIndex ] whileTrue: [
		n := Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
			into: [ :byte1 :byte2 :byte3 :byte4 |
				glyph := aTrueTypeFont glyphAtUtf8Byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.
				firstByte := byte1 ] 
			into: nil.

		"$i followed by a Combining Diacritical Mark is replaced by CodePoint 305 Dotless i, UTF-8 #[196 177]
		(UnicodeString fromUtf8Bytes: #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32 105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137	]) edit
		This should also be done for VectorEngineWithPlugin at
			displayUtf8:fromByte:toByte:at:trueTypeFont:color:scale:preventMirroring:
		"
		(firstByte = 105 and: [ byteIndex < (byteStopIndex-1) ] and: [
			(aByteArray at: byteIndex+1) = 204 or: [ (aByteArray at: byteIndex+1) = 205 and: [ (aByteArray at: byteIndex+2) < 176 ]]])
				ifTrue: [ glyph := aTrueTypeFont glyphAtUtf8Byte1: 196 byte2: 177 byte3: nil byte4: nil ].

		"Center diacriticals marks.
		See building of FormGlyph at
		formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
		Implement equivalent behavior at 
			displayUtf8:fromByte:toByte:at:trueTypeFont:color:scale:preventMirroring:
		(Done in Smalltalk VectorEngine, still to be done for VectorEngineWithPlugin)."
		"Tested at various sizes of DejaVu Sans, DejaVu Serif, JetBrains Mono NL, Kiwi Maru Light (except ~ and `), Kurinto Sans, Neo Euler, Source Sans 3
		Test text (at sizes 10, 13, 144):
		(UnicodeString fromUtf8Bytes: #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97	]) edit
		"
		deltaXToCenter := glyph deltaXToCenter.
		deltaXForDiacriticalMark := 0.
		deltaYForDiacriticalMark := 0.
		glyph advanceWidth = 0.0
			ifFalse: [ "Regular glyph"
				deltaXForBaseGlyph := deltaXToCenter.
				baseGlyphTopOffset := glyph topOffset ]
			ifTrue: [ "Diacritical mark"
				deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph.
				"Alternative implementation, perhaps closer to what  is done at VectorEngine >> #displayUtf8:fromByte:toByte:at:trueTypeFont:color:scale:preventMirroring:"
				"
				xtraSpaceForAntiAliasingAndRounding := 3. 'see #formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:'.
				baseBoundsTop := baseGlyphTopOffset-xtraSpaceForAntiAliasingAndRounding.
				boundsBottom := glyph topOffset-xtraSpaceForAntiAliasingAndRounding - (glyph form height-xtraSpaceForAntiAliasingAndRounding).
				boundsBottom := glyph topOffset - glyph form height.
				baseBoundsTop * 0.9 > boundsBottom ifTrue: [
					deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom ].
				"
				"Only if placed over a glyph with a top offset"
				baseGlyphTopOffset = 0 					ifFalse: [
					deltaYForDiacriticalMark :=  baseGlyphTopOffset - (glyph topOffset * 0.76).
					deltaYForDiacriticalMark := deltaYForDiacriticalMark max: 0 ]].
		destX := (fdestX + glyph leftOffset + deltaXForDiacriticalMark) roundedHAFZ.
		destY := (aPoint y + ascent + lineGap-1 - glyph topOffset - deltaYForDiacriticalMark) roundedHAFZ.
		"Please keep consistent with #displayOnVectorEngine:from:to:at:font:color:"
		aTrueTypeFont isSuperscript
			ifTrue: [destY := destY - (ascent*0.55)]
			ifFalse: [
				aTrueTypeFont isSubscript
					ifTrue: [destY := destY + (ascent*0.3)]].
		destY := destY roundedHAFZ.
		sourceForm := glyph form.
		height := sourceForm height.
		width := sourceForm width.
		self copyBits.
		fdestX := fdestX + "width + aTrueTypeFont baseKern"glyph advanceWidth.
		maxHeight := maxHeight max: height.
		byteIndex := byteIndex + n
	].
	^ fdestX ceiling@(destY+maxHeight).! !
!AbstractVectorCanvas methodsFor: 'drawing - text' stamp: 'jmv 4/13/2025 19:44:46' prior: 16778414 overrides: 16909312!
                              drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: aTrueTypeFont color: aColor
	"Answer position to place next glyph"
	"
| s c f |
c := VectorCanvas onForm: Display.
c geometryTransformation: (AffineTransformation withRadians: 0.1).
f := FontFamily familyName: 'DejaVu Sans' pointSize: 72.
s := 'Latin text in VectorGraphics'.
(c drawString: s from: 1 to: s size atBaseline: 100@100 font: f color: Color black) print.
c strokeWidth: 1 color: Color red do: [ c moveTo: 100@100; lineTo: 1000@100 ].
Display forceToScreen
	"
	^ aString asUnicodeString drawOnVectorEngine: engine from: firstIndex to: lastIndex
		at: aPoint font: aTrueTypeFont color: aColor.! !
!VectorCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/13/2025 19:43:40' prior: 16999330 overrides: 50389060!
       drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: aTrueTypeFont color: aColor
	"Answer position to place next glyph"
	"
| s c f |
c := VectorCanvas onForm: Display.
c geometryTransformation: (AffineTransformation withRadians: 0.1).
f := FontFamily familyName: 'DejaVu Sans' pointSize: 72.
s := 'Latin text in VectorGraphics'.
(c drawString: s from: 1 to: s size atBaseline: 100@100 font: f color: Color black) print.
c strokeWidth: 1 color: Color red do: [ c moveTo: 100@100; lineTo: 1000@100 ].
Display forceToScreen
	"
	| p1 answer |
	"Don't waste any time if NOP"
	lastIndex = 0 ifTrue: [
		^nil ].

	currentTransformation isPureTranslation ifTrue: [
		(Preferences at: #cacheTrueTypeGlyphs) ifTrue: [
			p1 := currentTransformation transform: aPoint roundedHAFZ.
			p1 := p1 + (0@(0 - (aTrueTypeFont ascent + aTrueTypeFont lineGap-1))).
			p1 := p1 roundedHAFZ.
			answer := aString asUnicodeString drawOnBitBltCanvasEngine: auxBitBltEngine
				from: firstIndex to: lastIndex at: p1 font: aTrueTypeFont color: aColor.
			answer ifNotNil: [
				engine updateMorphBoundsLeft: p1 x top: p1 y
					right: answer x bottom: answer y ].
			^answer ]].

	^super drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: aTrueTypeFont color: aColor! !
!BitBltCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/13/2025 19:43:44' prior: 16791450 overrides: 16909312!
       drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: font color: aColor
	"Answer position to place next glyph
	Answer nil if nothing was done"

	| p1 |
	"Don't waste any time if NOP"
	lastIndex = 0 ifTrue: [
		^nil ].

	p1 := currentTransformation transform: aPoint roundedHAFZ.
	p1 := p1 + (0@(0 - (font ascent + font lineGap-1))).
	p1 := p1 roundedHAFZ.
	engine colorMap: nil.
	^aString asUnicodeString drawOnBitBltCanvasEngine: engine
		from: firstIndex
		to: lastIndex
		at: p1
		font: font
		color: aColor! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 4/13/2025 19:43:48' prior: 16990254!
           drawString: s at: pt font: font color: aColor
	"Answer position to place next glyph
	Answer nil if nothing was done"

	displayEngine colorMap: nil.
	^s asUnicodeString drawOnBitBltCanvasEngine: displayEngine
		from: 1
		to: s size
		at: pt roundedHAFZ
		font: font
		color: aColor! !

BitBltCanvasEngine removeSelector: #basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:!

!methodRemoval: BitBltCanvasEngine #basicDisplayUtf8:fromByte:toByte:at:trueTypeFont: stamp: 'Install-7225-CleanStringDrawProtocol-p1-JuanVuletich-2025Apr13-19h43m-jmv.006.cs.st 5/24/2025 10:43:25'!
basicDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTrueTypeFont
	"Answer position to place next glyph"

	| fdestX glyph firstByte maxHeight byteIndex n ascent lineGap deltaXToCenter deltaXForBaseGlyph deltaXForDiacriticalMark baseGlyphTopOffset deltaYForDiacriticalMark |
	deltaXForBaseGlyph := 0.
	baseGlyphTopOffset := 0.
	ascent := aTrueTypeFont ascent.		  "expensive"
	lineGap := aTrueTypeFont lineGap."expensive"
	destY := aPoint y.
	fdestX := aPoint x.
	maxHeight := 0.
	byteIndex := byteStartIndex.
	[  byteIndex <= byteStopIndex ] whileTrue: [
		n := Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
			into: [ :byte1 :byte2 :byte3 :byte4 |
				glyph := aTrueTypeFont glyphAtUtf8Byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.
				firstByte := byte1 ] 
			into: nil.

		"$i followed by a Combining Diacritical Mark is replaced by CodePoint 305 Dotless i, UTF-8 #[196 177]
		(UnicodeString fromUtf8Bytes: #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32 105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137	]) edit
		This should also be done for VectorEngineWithPlugin at
			displayUtf8:fromByte:toByte:at:trueTypeFont:color:scale:preventMirroring:
		"
		(firstByte = 105 and: [ byteIndex < (byteStopIndex-1) ] and: [
			(aByteArray at: byteIndex+1) = 204 or: [ (aByteArray at: byteIndex+1) = 205 and: [ (aByteArray at: byteIndex+2) < 176 ]]])
				ifTrue: [ glyph := aTrueTypeFont glyphAtUtf8Byte1: 196 byte2: 177 byte3: nil byte4: nil ].

		"Center diacriticals marks.
		See building of FormGlyph at
		formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
		Implement equivalent behavior at 
			displayUtf8:fromByte:toByte:at:trueTypeFont:color:scale:preventMirroring:
		(Done in Smalltalk VectorEngine, still to be done for VectorEngineWithPlugin)."
		"Tested at various sizes of DejaVu Sans, DejaVu Serif, JetBrains Mono NL, Kiwi Maru Light (except ~ and `), Kurinto Sans, Neo Euler, Source Sans 3
		Test text (at sizes 10, 13, 144):
		(UnicodeString fromUtf8Bytes: #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97	]) edit
		"
		deltaXToCenter := glyph deltaXToCenter.
		deltaXForDiacriticalMark := 0.
		deltaYForDiacriticalMark := 0.
		glyph advanceWidth = 0.0
			ifFalse: [ "Regular glyph"
				deltaXForBaseGlyph := deltaXToCenter.
				baseGlyphTopOffset := glyph topOffset ]
			ifTrue: [ "Diacritical mark"
				deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph.
				"Alternative implementation, perhaps closer to what  is done at VectorEngine >> #displayUtf8:fromByte:toByte:at:trueTypeFont:color:scale:preventMirroring:"
				"
				xtraSpaceForAntiAliasingAndRounding := 3. 'see #formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:'.
				baseBoundsTop := baseGlyphTopOffset-xtraSpaceForAntiAliasingAndRounding.
				boundsBottom := glyph topOffset-xtraSpaceForAntiAliasingAndRounding - (glyph form height-xtraSpaceForAntiAliasingAndRounding).
				boundsBottom := glyph topOffset - glyph form height.
				baseBoundsTop * 0.9 > boundsBottom ifTrue: [
					deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom ].
				"
				"Only if placed over a glyph with a top offset"
				baseGlyphTopOffset = 0 					ifFalse: [
					deltaYForDiacriticalMark :=  baseGlyphTopOffset - (glyph topOffset * 0.76).
					deltaYForDiacriticalMark := deltaYForDiacriticalMark max: 0 ]].
		destX := (fdestX + glyph leftOffset + deltaXForDiacriticalMark) roundedHAFZ.
		destY := (aPoint y + ascent + lineGap-1 - glyph topOffset - deltaYForDiacriticalMark) roundedHAFZ.
		"Please keep consistent with #displayOnVectorEngine:from:to:at:font:color:"
		aTrueTypeFont isSuperscript
			ifTrue: [destY := destY - (ascent*0.55)]
			ifFalse: [
				aTrueTypeFont isSubscript
					ifTrue: [destY := destY + (ascent*0.3)]].
		destY := destY roundedHAFZ.
		sourceForm := glyph form.
		height := sourceForm height.
		width := sourceForm width.
		self copyBits.
		fdestX := fdestX + "width + aTrueTypeFont baseKern"glyph advanceWidth.
		maxHeight := maxHeight max: height.
		byteIndex := byteIndex + n
	].
	^ fdestX ceiling@(destY+maxHeight).!

BitBltCanvasEngine removeSelector: #displayUtf8:fromByte:toByte:at:trueTypeFont:color:!

!methodRemoval: BitBltCanvasEngine #displayUtf8:fromByte:toByte:at:trueTypeFont:color: stamp: 'Install-7225-CleanStringDrawProtocol-p1-JuanVuletich-2025Apr13-19h43m-jmv.006.cs.st 5/24/2025 10:43:25'!
displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTrueTypeFont color: foregroundColor
	"If required, do a second pass with new rule and colorMap.
	Answer position to place next glyph
	Answer nil if nothing was done
	"

	| answer prevRule secondPassMap sourceDepth destDepth |

	"Slight optimization when there's nothing to do."
	clipHeight = 0 ifTrue: [^nil].
	clipWidth = 0 ifTrue: [^nil].

	sourceForm := nil. "Set it for each glyph"
	sourceX := 0.
	sourceY := 0.
	height := nil. "Set it for each glyph as sourceForm height".
	self setRuleAndMapFor: 32 foregroundColor: (foregroundColor alpha: 1).

	"If combinationRule is rgbMul, we might need the special two-pass technique for component alpha blending.
	If not, do it simply"
	combinationRule = 37 "rgbMul" ifFalse: [
		^self basicDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTrueTypeFont ].
	
	"We need to do a second pass. The colormap set is for use in the second pass."
	secondPassMap := colorMap.
	sourceDepth := aTrueTypeFont cachedFormDepth.
	destDepth := destForm depth.
	colorMap := sourceDepth ~= destDepth
		ifTrue: [ Color cachedColormapFrom: sourceDepth to: destDepth ].
	answer := self basicDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTrueTypeFont.
	colorMap := secondPassMap.
	secondPassMap ifNotNil: [
		prevRule := combinationRule.
		combinationRule := 20. "rgbAdd"
		self basicDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTrueTypeFont.
		combinationRule := prevRule ].
	^answer!

UnicodeString removeSelector: #displayOnVectorEngine:from:to:at:font:color:!

!methodRemoval: UnicodeString #displayOnVectorEngine:from:to:at:font:color: stamp: 'Install-7225-CleanStringDrawProtocol-p1-JuanVuletich-2025Apr13-19h43m-jmv.006.cs.st 5/24/2025 10:43:25'!
displayOnVectorEngine: engine from: startIndex to: stopIndex at: aPoint font: aTrueTypeFont color: color

	| byteStartIndex byteStopIndex p answer d |
	byteStartIndex := self byteIndexAt: startIndex.
	byteStopIndex := (self byteIndexAt: stopIndex+1)-1.
	"Please keep consistent with #basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:"
	p := aTrueTypeFont isSuperscript
		ifTrue: [ aPoint x  @ (aPoint y - (aTrueTypeFont ascent*0.55)) ]
		ifFalse: [
			aTrueTypeFont isSubscript
				ifTrue: [aPoint x @ (aPoint y + (aTrueTypeFont ascent*0.3))]
				ifFalse: [ aPoint ]].
	answer := engine
		displayUtf8: bytes
		fromByte: byteStartIndex toByte: byteStopIndex
		at: p
		trueTypeFont: aTrueTypeFont fontDescription
		color: color
		scale: aTrueTypeFont pointSize
		preventMirroring: true.
	"Please keep consistent with #makeUnderlinedGlyph:"
	aTrueTypeFont isUnderlined ifTrue: [
		d := aTrueTypeFont descent *0.7.
		engine strokeWidth: 2 color: color do: [
			engine moveTo: p + (0@d); lineTo: answer + (0@d) ]].
	"Please keep consistent with #makeStruckThroughGlyph:"
	aTrueTypeFont isStruckThrough ifTrue: [
		d := aTrueTypeFont ascent * 0.25.
		engine strokeWidth: 1 color: color do: [
			engine moveTo: p - (0@d); lineTo: answer - (0@d) ]].
	^answer!

UnicodeString removeSelector: #displayOnBitBltCanvasEngine:from:to:at:font:color:!

!methodRemoval: UnicodeString #displayOnBitBltCanvasEngine:from:to:at:font:color: stamp: 'Install-7225-CleanStringDrawProtocol-p1-JuanVuletich-2025Apr13-19h43m-jmv.006.cs.st 5/24/2025 10:43:25'!
displayOnBitBltCanvasEngine: engine from: startIndex to: stopIndex at: p font: aTrueTypeFont color: color

	| byteStartIndex byteStopIndex |
	byteStartIndex := self byteIndexAt: startIndex.
	byteStopIndex := (self byteIndexAt: stopIndex+1)-1.
	^engine
		displayUtf8: bytes
		fromByte: byteStartIndex
		toByte: byteStopIndex
		at: p
		trueTypeFont: aTrueTypeFont
		color: color.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7225-CleanStringDrawProtocol-p1-JuanVuletich-2025Apr13-19h43m-jmv.006.cs.st----!

'From Cuis7.3 [latest update: #7133] on 14 April 2025 at 10:50:11 am'!
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 10:42:27'!
                         drawByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try BOTH!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.'.
e drawByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsTop boundsBottom numContours numBeziers x y cx cy contourStart |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	 "Should use a specific table with 256 entries"
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8. "Should use a specific table with 256 entries"
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		startIndex to: stopIndex do: [ :charIndex | | latin1Code i |
			latin1Code := (aString at: charIndex) asciiValue.
			i := contourDataIndexes at: latin1Code + 1.
			advanceWidth := contourData at: i. i := i + 1.
			boundsLeft := contourData at: i. i := i + 1.
			boundsRight := contourData at: i. i := i + 1.
			boundsBottom := contourData at: i. i := i + 1.
			boundsTop := contourData at: i. i := i + 1.
			numContours := (contourData at: i) asInteger. i := i + 1.
			numContours timesRepeat: [
				numBeziers := (contourData at: i) asInteger. i := i + 1.
				ttMoveToX := contourData at: i. i := i + 1.
				ttMoveToY := contourData at: i. i := i + 1.
				x := ttMoveToX * sx + nextGlyphX.
				y := ttMoveToY * sy + nextGlyphY.
				contourStart := x@y.
				self moveTo: contourStart.
				numBeziers timesRepeat: [
					ttEndX := contourData at: i. i := i + 1.
					ttEndY := contourData at: i. i := i + 1.
					ttControlX := contourData at: i. i := i + 1.
					ttControlY := contourData at: i. i := i + 1.
					cx := ttControlX * sx + x.
					cy := ttControlY * sy + y.
					x := ttEndX * sx + x.
					y := ttEndY * sy + y.
					self quadraticBezierTo: x@y control: cx@cy ].
				self lineTo: contourStart ].
			nextGlyphX := nextGlyphX + (advanceWidth * sx) ]].
	^ nextGlyphX@nextGlyphY! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 10:43:52'!
   drawUtf32String: aWordArray from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f utf32 |
'Try BOTH!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf32 _ #(4314 4317 4320 4308 4315 32 4312 4324 4321 4323 4315 32 4307 4317 4314 4317 4320 32 4321 4312 4311 32 4304 4315 4308 4311 44 32 4327 4323 4317 32 4323 4311 32 4307 4312 4330 4304 4311 32 4304 4314 4312 4327 4323 4312 4307 44 32 4304 4307 32 4314 4312 4305 4320 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4320 4308 4324 4320 4308 4336 4308 4316 4307 4323 4316 4311 32 4308 4321 4311 46 32 4314 4308 4306 4308 4320 4308 32 4330 4317 4320 4324 4317 4320 4304 32 4308 4324 4324 4312 4330 4312 4304 4316 4311 4323 4320 32 4304 4311 32 4308 4304 4315 44 32 4316 4317 32 4327 4323 4304 4321 32 4315 4308 4316 4304 4316 4307 4320 4312 32 4320 4308 4324 4308 4320 4320 4308 4316 4311 4323 4320 32 4327 4323 4312 46 32 4311 4308 32 4324 4323 4311 4308 4316 4311 32 4315 4317 4314 4314 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4309 4312 4321 46 32 4309 4312 4315 32 4307 4308 4316 4312 4327 4323 4308 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4311 4336 4308 4317 4324 4336 4320 4304 4321 4311 4323 4321 32 4308 4334 44 32 4308 4304 32 4336 4304 4321 32 4309 4317 4314 4323 4315 4323 4321 32 4324 4304 4321 4311 4312 4307 4312 4312 32 4307 4308 4321 4308 4320 4323 4316 4311 46 32 4308 4334 32 4317 4324 4324 4312 4330 4312 4312 4321 32 4311 4317 4320 4327 4323 4304 4311 4317 4321 32 4315 4308 4312 44 32 4307 4317 4330 4311 4323 4321 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4312 4316 32 4327 4323 4317 46 32 4321 4323 4315 4315 4317 32 4311 4320 4304 4330 4311 4304 4311 4317 4321 32 4308 4312 32 4312 4323 4321 44 32 4323 4311 32 4317 4315 4316 4308 4321 32 4309 4312 4320 4311 4323 4311 4308 32 4307 4308 4311 4320 4304 4334 4312 4311 46) asWordArray.
e drawUtf32String: utf32 from: 1 to: utf32 size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"
"
| e f utf8a utf8b utf8c utf32a utf32b utf32c |
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf8a := #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32 105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ].
utf8b := #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97	].
utf8c := #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 105 195 173 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97 105 105 204 129 	].
utf32a := #(105 105 769 32 105 768 32 105 770 32 105 771 32 105 772 32 105 773 32 105 774 32 105 775 32 105 776 32 105 777) asWordArray.
utf32b :=  #(97 233 97 232 97 241 97 209 252 64 97 101 769 97 101 768 97 110 771 97 78 771 117 776 97) asWordArray.
utf32c :=  #(97 233 97 232 97 241 97 209 252 105 237 64 97 101 769 97 101 768 97 110 771 97 78 771 117 776 97 105 105 769) asWordArray.
e drawUtf8String: utf8a fromByte: 1 toByte: utf8a size at: 10@120 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf32String: utf32a from: 1 to: utf32a size at: 10@220 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf8String: utf8b fromByte: 1 toByte: utf8b size at: 10@320 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf32String: utf32b from: 1 to: utf32b size at: 10@420 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf8String: utf8c fromByte: 1 toByte: utf8c size at: 10@520 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf32String: utf32c from: 1 to: utf32c size at: 10@620 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsTop boundsBottom numContours numBeziers x y cx cy contourStart deltaXToCenter deltaXForBaseGlyph deltaXForDiacriticalMark baseBoundsTop deltaYForDiacriticalMark |
	deltaXForBaseGlyph := 0.0.
	baseBoundsTop := 0.
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		startIndex to: stopIndex do: [ :utf32Index | | utf32 utf8Byte1 uft8Byte2 utf8Byte3 utf8Byte4 i |
			utf32 := aWordArray at: utf32Index.
			
			"$i followed by a Combining Diacritical Mark is replaced by CodePoint 16r131 Dotless i
			This should also be done for VectorEngineWithPlugin"
			(utf32 = 16r69 and: [ utf32Index < stopIndex ] and: [
				(aWordArray at: utf32Index+1) between: 16r300 and: 16r36F ])
					ifTrue: [ utf32 := 16r131 ].
			
			utf32 <= 16r7F
				ifTrue: [
					utf8Byte1 := utf32.
					i := contourDataIndexes at: utf8Byte1 + 1 ]
				ifFalse: [ utf32 <= 16r7FF
				ifTrue: [
					utf8Byte1 := (utf32 bitShift: -6) bitOr: 2r11000000.
					uft8Byte2 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1 ]
				ifFalse: [ utf32 <= 16rFFFF
				ifTrue: [
					utf8Byte1 := (utf32 bitShift: -12) bitOr: 2r11100000.
					uft8Byte2 := ((utf32 bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte3 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1.
					i := contourDataIndexes at: utf8Byte3 - i + 1 ]
				ifFalse: [
					utf8Byte1 := (utf32 bitShift: -18) bitOr: 2r11110000.
					uft8Byte2 := ((utf32 bitShift: -12) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte3 := ((utf32 bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte4 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1.
					i := contourDataIndexes at: utf8Byte3 - i + 1.
					i := contourDataIndexes at: utf8Byte4 - i + 1 ]]].
			advanceWidth := contourData at: i. i := i + 1.
			boundsLeft := contourData at: i. i := i + 1.
			boundsRight := contourData at: i. i := i + 1.
			boundsBottom := contourData at: i. i := i + 1.
			boundsTop := contourData at: i. i := i + 1.
			numContours := (contourData at: i) asInteger. i := i + 1.
			
			"TrueType doesn't speciy how to position diacritics wrt base character glyph.
			Horizontally center diacriticals wrt base glyph.
			See
				basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
				formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
				displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
			This should also be done for VectorEngineWithPlugin
			Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
			deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
			utf32 = 16r300 ifTrue: [	"Combining Grave Accent"
				deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
			utf32 = 16r301 ifTrue: [ 	"Combining Acute Accent"
				deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ].
			"DoubleWidth code points that combine above previous and following characters.
			Codepoints between 16r035C and 16r0363.
			Example: o͢o
			Don't center them"
			(utf32 between: 16r035C and: 16r0363) ifTrue: [
				deltaXToCenter := 0.0 ].
					
			deltaXForDiacriticalMark := 0.0.
			deltaYForDiacriticalMark := 0.
			advanceWidth = 0.0
				ifFalse: [ "Regular glyph"
					deltaXForBaseGlyph := deltaXToCenter.
					baseBoundsTop := boundsTop ]
				ifTrue: [ "Diacritical mark"
					deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
						ifFalse: [
							deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
							baseBoundsTop > boundsBottom ifTrue: [
								deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
			nextGlyphX := nextGlyphX + deltaXForDiacriticalMark.
			
			numContours timesRepeat: [
				numBeziers := (contourData at: i) asInteger. i := i + 1.
				ttMoveToX := contourData at: i. i := i + 1.
				ttMoveToY := contourData at: i. i := i + 1.
				x := ttMoveToX * sx + nextGlyphX.
				y := ttMoveToY * sy + nextGlyphY + deltaYForDiacriticalMark.
				contourStart := x@y.
				self moveTo: contourStart.
				numBeziers timesRepeat: [
					ttEndX := contourData at: i. i := i + 1.
					ttEndY := contourData at: i. i := i + 1.
					ttControlX := contourData at: i. i := i + 1.
					ttControlY := contourData at: i. i := i + 1.
					cx := ttControlX * sx + x.
					cy := ttControlY * sy + y.
					x := ttEndX * sx + x.
					y := ttEndY * sy + y.
					self quadraticBezierTo: x@y control: cx@cy ].
				self lineTo: contourStart ].
			nextGlyphX := nextGlyphX + (advanceWidth * sx) - deltaXForDiacriticalMark ]].
	^ nextGlyphX@nextGlyphY! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 10:36:40'!
                    drawUtf8String: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours numBeziers baseIndex x y cx cy contourStart deltaXToCenter deltaXForBaseGlyph deltaXForDiacriticalMark baseBoundsTop deltaYForDiacriticalMark byte1 byte2OrNil |
	deltaXForBaseGlyph := 0.0.
	baseBoundsTop := 0.
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	byte1 := nil.
	byte2OrNil := nil.
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		baseIndex := 0.
		byteStartIndex to: byteStopIndex do: [ :byteIndex | | byte i |
			byte := aByteArray at: byteIndex.
			byte1 isNil ifTrue: [byte1 := byte ] ifFalse: [ byte2OrNil isNil ifTrue: [ byte2OrNil := byte ]].
			i := contourDataIndexes at: baseIndex + byte + 1.
			
			"$i followed by a Combining Diacritical Mark is replaced by CodePoint 305 Dotless i, UTF-8 #[196 177]
			(UnicodeString fromUtf8Bytes: #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32
				105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ]) edit
			This should also be done for VectorEngineWithPlugin"
			(byte1 = 105 and: [ byteIndex < (byteStopIndex-1) ] and: [
				(aByteArray at: byteIndex+1) = 204 or: [ (aByteArray at: byteIndex+1) = 205 and: [ (aByteArray at: byteIndex+2) < 176 ]]])
					ifTrue: [
						i := contourDataIndexes at: 196 + 1.
						i := contourDataIndexes at: i negated + 177 + 1 ].
			
			i < 0
				ifTrue: [ baseIndex := i negated ]
				ifFalse: [
					advanceWidth := contourData at: i. i := i + 1.
					boundsLeft := contourData at: i. i := i + 1.
					boundsRight := contourData at: i. i := i + 1.
					boundsBottom := contourData at: i. i := i + 1.
					boundsTop := contourData at: i. i := i + 1.
					numContours := (contourData at: i) asInteger. i := i + 1.
					"TrueType doesn't speciy how to position diacritics wrt base character glyph.
					Horizontally center diacriticals wrt base glyph.
					See
						basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
						formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
						displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
					This should also be done for VectorEngineWithPlugin
					Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
					deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
					byte1 = 204 ifTrue: [
						byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
							deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
						byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
							deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ]].
					"DoubleWidth code points that combine above previous and following characters.
					Codepoints between 16r035C and 16r0363.
					Example: o͢o
					Don't center them"
					(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
						deltaXToCenter := 0.0 ].
					
					deltaXForDiacriticalMark := 0.0.
					deltaYForDiacriticalMark := 0.
					advanceWidth = 0.0
						ifFalse: [ "Regular glyph"
							deltaXForBaseGlyph := deltaXToCenter.
							baseBoundsTop := boundsTop ]
						ifTrue: [ "Diacritical mark"
							deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
								ifFalse: [
									deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
									baseBoundsTop > boundsBottom ifTrue: [
										deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
					nextGlyphX := nextGlyphX + deltaXForDiacriticalMark.
					
					numContours timesRepeat: [
						numBeziers := (contourData at: i) asInteger. i := i + 1.
						ttMoveToX := contourData at: i. i := i + 1.
						ttMoveToY := contourData at: i. i := i + 1.
						x := ttMoveToX * sx + nextGlyphX.
						y := ttMoveToY * sy + nextGlyphY + deltaYForDiacriticalMark.
						contourStart := x@y.
						self moveTo: contourStart.
						numBeziers timesRepeat: [
							ttEndX := contourData at: i. i := i + 1.
							ttEndY := contourData at: i. i := i + 1.
							ttControlX := contourData at: i. i := i + 1.
							ttControlY := contourData at: i. i := i + 1.
							cx := ttControlX * sx + x.
							cy := ttControlY * sy + y.
							x := ttEndX * sx + x.
							y := ttEndY * sy + y.
							self quadraticBezierTo: x@y control: cx@cy ].
						self lineTo: contourStart ].
					nextGlyphX := nextGlyphX + (advanceWidth * sx) - deltaXForDiacriticalMark.
					baseIndex := 0.
					byte1 := nil.
					byte2OrNil := nil ]]].
	^ nextGlyphX@nextGlyphY! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 10:40:56' overrides: 50389439!
                           drawByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try BOTH!!'.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.'.
e drawByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale asFloat.
	sy := scale * trueTypeScale asFloat.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	 "Should use a specific table with 256 entries"
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8. "Should use a specific table with 256 entries"
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayByteString: aString from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
		].
	^ nextGlyphX @ nextGlyphY! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 10:41:45' overrides: 50389536!
             drawUtf32String: aWordArray from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f utf32 |
'Try BOTH!!'.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf32 _ #(4314 4317 4320 4308 4315 32 4312 4324 4321 4323 4315 32 4307 4317 4314 4317 4320 32 4321 4312 4311 32 4304 4315 4308 4311 44 32 4327 4323 4317 32 4323 4311 32 4307 4312 4330 4304 4311 32 4304 4314 4312 4327 4323 4312 4307 44 32 4304 4307 32 4314 4312 4305 4320 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4320 4308 4324 4320 4308 4336 4308 4316 4307 4323 4316 4311 32 4308 4321 4311 46 32 4314 4308 4306 4308 4320 4308 32 4330 4317 4320 4324 4317 4320 4304 32 4308 4324 4324 4312 4330 4312 4304 4316 4311 4323 4320 32 4304 4311 32 4308 4304 4315 44 32 4316 4317 32 4327 4323 4304 4321 32 4315 4308 4316 4304 4316 4307 4320 4312 32 4320 4308 4324 4308 4320 4320 4308 4316 4311 4323 4320 32 4327 4323 4312 46 32 4311 4308 32 4324 4323 4311 4308 4316 4311 32 4315 4317 4314 4314 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4309 4312 4321 46 32 4309 4312 4315 32 4307 4308 4316 4312 4327 4323 4308 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4311 4336 4308 4317 4324 4336 4320 4304 4321 4311 4323 4321 32 4308 4334 44 32 4308 4304 32 4336 4304 4321 32 4309 4317 4314 4323 4315 4323 4321 32 4324 4304 4321 4311 4312 4307 4312 4312 32 4307 4308 4321 4308 4320 4323 4316 4311 46 32 4308 4334 32 4317 4324 4324 4312 4330 4312 4312 4321 32 4311 4317 4320 4327 4323 4304 4311 4317 4321 32 4315 4308 4312 44 32 4307 4317 4330 4311 4323 4321 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4312 4316 32 4327 4323 4317 46 32 4321 4323 4315 4315 4317 32 4311 4320 4304 4330 4311 4304 4311 4317 4321 32 4308 4312 32 4312 4323 4321 44 32 4323 4311 32 4317 4315 4316 4308 4321 32 4309 4312 4320 4311 4323 4311 4308 32 4307 4308 4311 4320 4304 4334 4312 4311 46) asWordArray.
e drawUtf32String: utf32 from: 1 to: utf32 size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen."

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayUtf32: aWordArray from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
		].
	^ nextGlyphX @ nextGlyphY! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 10:37:30' overrides: 50389847!
                         drawUtf8String: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
		].
	^ nextGlyphX @ nextGlyphY! !
!UnicodeString methodsFor: 'dispatch' stamp: 'jmv 4/14/2025 10:22:23' prior: 50388827!
    drawOnVectorEngine: engine from: startIndex to: stopIndex at: aPoint font: aTrueTypeFont color: color

	| byteStartIndex byteStopIndex p answer d |
	byteStartIndex := self byteIndexAt: startIndex.
	byteStopIndex := (self byteIndexAt: stopIndex+1)-1.
	"Please keep consistent with #basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:"
	p := aTrueTypeFont isSuperscript
		ifTrue: [ aPoint x  @ (aPoint y - (aTrueTypeFont ascent*0.55)) ]
		ifFalse: [
			aTrueTypeFont isSubscript
				ifTrue: [aPoint x @ (aPoint y + (aTrueTypeFont ascent*0.3))]
				ifFalse: [ aPoint ]].
	answer := engine
		drawUtf8String: bytes
		fromByte: byteStartIndex toByte: byteStopIndex
		at: p
		trueTypeFont: aTrueTypeFont fontDescription
		color: color
		scale: aTrueTypeFont pointSize
		preventMirroring: true.
	"Please keep consistent with #makeUnderlinedGlyph:"
	aTrueTypeFont isUnderlined ifTrue: [
		d := aTrueTypeFont descent *0.7.
		engine strokeWidth: 2 color: color do: [
			engine moveTo: p + (0@d); lineTo: answer + (0@d) ]].
	"Please keep consistent with #makeStruckThroughGlyph:"
	aTrueTypeFont isStruckThrough ifTrue: [
		d := aTrueTypeFont ascent * 0.25.
		engine strokeWidth: 1 color: color do: [
			engine moveTo: p - (0@d); lineTo: answer - (0@d) ]].
	^answer! !
!TTFontDescription methodsFor: 'conversion' stamp: 'jmv 4/14/2025 10:22:32' prior: 16974080!
                             formGlyphForUtf8Byte1: aByte1 byte2: aByte2OrNil byte3: aByte3OrNil byte4: aByte4OrNil pixelSize: pixelSize
	"Needed only for BitBltCanvasEngine"
	| byte1 byte2OrNil byte3OrNil byte4OrNil utf8ByteArray toPixelsScale formWidth formHeight leftPixelOffset topPixelOffset xtraSpaceForAntiAliasingAndRounding horizontalStrokesAtPixelCenter form canvas advanceWidth boundsLeft boundsRight boundsBottom boundsTop i deltaXToCenter |

	byte1 := aByte1.
	byte2OrNil := aByte2OrNil.
	byte3OrNil := aByte3OrNil.
	byte4OrNil := aByte4OrNil.
	i := contourDataIndexesByUtf8 at: byte1 + 1.
	utf8ByteArray := ByteArray with: byte1.
	byte2OrNil notNil ifTrue: [
		i := contourDataIndexesByUtf8 at: i negated + byte2OrNil + 1.
		utf8ByteArray := ByteArray with: byte1 with: byte2OrNil.
		byte3OrNil notNil ifTrue: [
			i := contourDataIndexesByUtf8 at: i negated + byte3OrNil + 1.
			utf8ByteArray := ByteArray with: byte1 with: byte2OrNil with: byte3OrNil.
			byte4OrNil notNil ifTrue: [
				i := contourDataIndexesByUtf8 at: i negated + byte4OrNil + 1.
				utf8ByteArray := ByteArray with: byte1 with: byte2OrNil with: byte3OrNil with: byte4OrNil ]]].

	"If glyph not found, take first glyph 'theUnknownGlyph'"
	i = 0 ifTrue: [ i := 1 ].

	advanceWidth := contourDataForUtf8 at: i. i := i + 1.
	boundsLeft := contourDataForUtf8 at: i. i := i + 1.
	boundsRight := contourDataForUtf8 at: i. i := i + 1.
	boundsBottom := contourDataForUtf8 at: i. i := i + 1.
	boundsTop := contourDataForUtf8 at: i. i := i + 1.

	horizontalStrokesAtPixelCenter := 0.5.
	xtraSpaceForAntiAliasingAndRounding := 3.
	toPixelsScale := 0.0 + pixelSize / self letterMTopSideBearing.

	"If positive, pixels we save at the left. if negative, xtra pix needed"
	leftPixelOffset := (boundsLeft * toPixelsScale - xtraSpaceForAntiAliasingAndRounding) floor.
	formWidth := (boundsRight - boundsLeft) * toPixelsScale + (xtraSpaceForAntiAliasingAndRounding*2).

	"Usually positive. Needed pixels above the baseline"
	topPixelOffset := (boundsTop * toPixelsScale + xtraSpaceForAntiAliasingAndRounding) ceiling.
	formHeight := (boundsTop - boundsBottom) * toPixelsScale + (xtraSpaceForAntiAliasingAndRounding*2).
	
	form := Form extent: formWidth@formHeight depth: 32.
	form fillColor: Color white.
	canvas := VectorCanvas onFormWithSubPixelAntiAliasing: form.
	canvas 
		engine
			drawUtf8String: utf8ByteArray
			fromByte: 1
			toByte: utf8ByteArray size
			at: leftPixelOffset negated@(topPixelOffset - horizontalStrokesAtPixelCenter)
			trueTypeFont: self
			color: Color black
			scale: 1.0 * pixelSize
			preventMirroring: true.

	"TrueType doesn't speciy how to position diacritics wrt base character glyph.
	Horizontally center diacriticals wrt base glyph.
	See
	basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
	Apparently OpenType can do better than TrueType, as it includes the GPOS table."
	deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.51)) * toPixelsScale.
	byte1 = 204 ifTrue: [
		byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.43)) * toPixelsScale ].
		byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.65)) * toPixelsScale ]].

	"DoubleWidth code points that combine above previous and following characters.
	Codepoints between 16r035C and 16r0363.
	Example: o͢o
	Don't center them"
	(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
		deltaXToCenter := 0 ].
	
	^(FormGlyph
		form: form
		leftOffset: leftPixelOffset
		topOffset: topPixelOffset
		advanceWidth: (advanceWidth * toPixelsScale))
			deltaXToCenter: deltaXToCenter.
! !

VectorEngineWithPlugin removeSelector: #displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:!

!methodRemoval: VectorEngineWithPlugin #displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring: stamp: 'Install-7226-CleanStringDrawProtocol-p2-JuanVuletich-2025Apr14-10h47m-jmv.003.cs.st 5/24/2025 10:43:25'!
displayUtf32: aWordArray from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f utf32 |
'Try BOTH!!'.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf32 _ #(4314 4317 4320 4308 4315 32 4312 4324 4321 4323 4315 32 4307 4317 4314 4317 4320 32 4321 4312 4311 32 4304 4315 4308 4311 44 32 4327 4323 4317 32 4323 4311 32 4307 4312 4330 4304 4311 32 4304 4314 4312 4327 4323 4312 4307 44 32 4304 4307 32 4314 4312 4305 4320 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4320 4308 4324 4320 4308 4336 4308 4316 4307 4323 4316 4311 32 4308 4321 4311 46 32 4314 4308 4306 4308 4320 4308 32 4330 4317 4320 4324 4317 4320 4304 32 4308 4324 4324 4312 4330 4312 4304 4316 4311 4323 4320 32 4304 4311 32 4308 4304 4315 44 32 4316 4317 32 4327 4323 4304 4321 32 4315 4308 4316 4304 4316 4307 4320 4312 32 4320 4308 4324 4308 4320 4320 4308 4316 4311 4323 4320 32 4327 4323 4312 46 32 4311 4308 32 4324 4323 4311 4308 4316 4311 32 4315 4317 4314 4314 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4309 4312 4321 46 32 4309 4312 4315 32 4307 4308 4316 4312 4327 4323 4308 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4311 4336 4308 4317 4324 4336 4320 4304 4321 4311 4323 4321 32 4308 4334 44 32 4308 4304 32 4336 4304 4321 32 4309 4317 4314 4323 4315 4323 4321 32 4324 4304 4321 4311 4312 4307 4312 4312 32 4307 4308 4321 4308 4320 4323 4316 4311 46 32 4308 4334 32 4317 4324 4324 4312 4330 4312 4312 4321 32 4311 4317 4320 4327 4323 4304 4311 4317 4321 32 4315 4308 4312 44 32 4307 4317 4330 4311 4323 4321 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4312 4316 32 4327 4323 4317 46 32 4321 4323 4315 4315 4317 32 4311 4320 4304 4330 4311 4304 4311 4317 4321 32 4308 4312 32 4312 4323 4321 44 32 4323 4311 32 4317 4315 4316 4308 4321 32 4309 4312 4320 4311 4323 4311 4308 32 4307 4308 4311 4320 4304 4334 4312 4311 46) asWordArray.
e displayUtf32: utf32 from: 1 to: utf32 size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen."

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayUtf32: aWordArray from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
		].
	^ nextGlyphX @ nextGlyphY!

VectorEngineWithPlugin removeSelector: #displayUtf8:fromByte:toByte:at:trueTypeFont:color:scale:preventMirroring:!

!methodRemoval: VectorEngineWithPlugin #displayUtf8:fromByte:toByte:at:trueTypeFont:color:scale:preventMirroring: stamp: 'Install-7226-CleanStringDrawProtocol-p2-JuanVuletich-2025Apr14-10h47m-jmv.003.cs.st 5/24/2025 10:43:25'!
displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
		].
	^ nextGlyphX @ nextGlyphY!

VectorEngineWithPlugin removeSelector: #displayByteString:from:to:at:trueTypeFont:color:scale:preventMirroring:!

!methodRemoval: VectorEngineWithPlugin #displayByteString:from:to:at:trueTypeFont:color:scale:preventMirroring: stamp: 'Install-7226-CleanStringDrawProtocol-p2-JuanVuletich-2025Apr14-10h47m-jmv.003.cs.st 5/24/2025 10:43:25'!
displayByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try BOTH!!'.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.'.
e displayByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale asFloat.
	sy := scale * trueTypeScale asFloat.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	 "Should use a specific table with 256 entries"
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8. "Should use a specific table with 256 entries"
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayByteString: aString from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes
		].
	^ nextGlyphX @ nextGlyphY!

VectorEngine removeSelector: #displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:!

!methodRemoval: VectorEngine #displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring: stamp: 'Install-7226-CleanStringDrawProtocol-p2-JuanVuletich-2025Apr14-10h47m-jmv.003.cs.st 5/24/2025 10:43:25'!
displayUtf32: aWordArray from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f utf32 |
'Try BOTH!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf32 _ #(4314 4317 4320 4308 4315 32 4312 4324 4321 4323 4315 32 4307 4317 4314 4317 4320 32 4321 4312 4311 32 4304 4315 4308 4311 44 32 4327 4323 4317 32 4323 4311 32 4307 4312 4330 4304 4311 32 4304 4314 4312 4327 4323 4312 4307 44 32 4304 4307 32 4314 4312 4305 4320 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4320 4308 4324 4320 4308 4336 4308 4316 4307 4323 4316 4311 32 4308 4321 4311 46 32 4314 4308 4306 4308 4320 4308 32 4330 4317 4320 4324 4317 4320 4304 32 4308 4324 4324 4312 4330 4312 4304 4316 4311 4323 4320 32 4304 4311 32 4308 4304 4315 44 32 4316 4317 32 4327 4323 4304 4321 32 4315 4308 4316 4304 4316 4307 4320 4312 32 4320 4308 4324 4308 4320 4320 4308 4316 4311 4323 4320 32 4327 4323 4312 46 32 4311 4308 32 4324 4323 4311 4308 4316 4311 32 4315 4317 4314 4314 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4309 4312 4321 46 32 4309 4312 4315 32 4307 4308 4316 4312 4327 4323 4308 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4311 4336 4308 4317 4324 4336 4320 4304 4321 4311 4323 4321 32 4308 4334 44 32 4308 4304 32 4336 4304 4321 32 4309 4317 4314 4323 4315 4323 4321 32 4324 4304 4321 4311 4312 4307 4312 4312 32 4307 4308 4321 4308 4320 4323 4316 4311 46 32 4308 4334 32 4317 4324 4324 4312 4330 4312 4312 4321 32 4311 4317 4320 4327 4323 4304 4311 4317 4321 32 4315 4308 4312 44 32 4307 4317 4330 4311 4323 4321 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4312 4316 32 4327 4323 4317 46 32 4321 4323 4315 4315 4317 32 4311 4320 4304 4330 4311 4304 4311 4317 4321 32 4308 4312 32 4312 4323 4321 44 32 4323 4311 32 4317 4315 4316 4308 4321 32 4309 4312 4320 4311 4323 4311 4308 32 4307 4308 4311 4320 4304 4334 4312 4311 46) asWordArray.
e displayUtf32: utf32 from: 1 to: utf32 size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"
"
| e f utf8a utf8b utf8c utf32a utf32b utf32c |
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf8a := #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32 105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ].
utf8b := #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97	].
utf8c := #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 105 195 173 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97 105 105 204 129 	].
utf32a := #(105 105 769 32 105 768 32 105 770 32 105 771 32 105 772 32 105 773 32 105 774 32 105 775 32 105 776 32 105 777) asWordArray.
utf32b :=  #(97 233 97 232 97 241 97 209 252 64 97 101 769 97 101 768 97 110 771 97 78 771 117 776 97) asWordArray.
utf32c :=  #(97 233 97 232 97 241 97 209 252 105 237 64 97 101 769 97 101 768 97 110 771 97 78 771 117 776 97 105 105 769) asWordArray.
e displayUtf8: utf8a fromByte: 1 toByte: utf8a size at: 10@120 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e displayUtf32: utf32a from: 1 to: utf32a size at: 10@220 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e displayUtf8: utf8b fromByte: 1 toByte: utf8b size at: 10@320 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e displayUtf32: utf32b from: 1 to: utf32b size at: 10@420 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e displayUtf8: utf8c fromByte: 1 toByte: utf8c size at: 10@520 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e displayUtf32: utf32c from: 1 to: utf32c size at: 10@620 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsTop boundsBottom numContours numBeziers x y cx cy contourStart deltaXToCenter deltaXForBaseGlyph deltaXForDiacriticalMark baseBoundsTop deltaYForDiacriticalMark |
	deltaXForBaseGlyph := 0.0.
	baseBoundsTop := 0.
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		startIndex to: stopIndex do: [ :utf32Index | | utf32 utf8Byte1 uft8Byte2 utf8Byte3 utf8Byte4 i |
			utf32 := aWordArray at: utf32Index.
			
			"$i followed by a Combining Diacritical Mark is replaced by CodePoint 16r131 Dotless i
			This should also be done for VectorEngineWithPlugin"
			(utf32 = 16r69 and: [ utf32Index < stopIndex ] and: [
				(aWordArray at: utf32Index+1) between: 16r300 and: 16r36F ])
					ifTrue: [ utf32 := 16r131 ].
			
			utf32 <= 16r7F
				ifTrue: [
					utf8Byte1 := utf32.
					i := contourDataIndexes at: utf8Byte1 + 1 ]
				ifFalse: [ utf32 <= 16r7FF
				ifTrue: [
					utf8Byte1 := (utf32 bitShift: -6) bitOr: 2r11000000.
					uft8Byte2 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1 ]
				ifFalse: [ utf32 <= 16rFFFF
				ifTrue: [
					utf8Byte1 := (utf32 bitShift: -12) bitOr: 2r11100000.
					uft8Byte2 := ((utf32 bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte3 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1.
					i := contourDataIndexes at: utf8Byte3 - i + 1 ]
				ifFalse: [
					utf8Byte1 := (utf32 bitShift: -18) bitOr: 2r11110000.
					uft8Byte2 := ((utf32 bitShift: -12) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte3 := ((utf32 bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
					utf8Byte4 := (utf32 bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i := contourDataIndexes at: uft8Byte2 - i + 1.
					i := contourDataIndexes at: utf8Byte3 - i + 1.
					i := contourDataIndexes at: utf8Byte4 - i + 1 ]]].
			advanceWidth := contourData at: i. i := i + 1.
			boundsLeft := contourData at: i. i := i + 1.
			boundsRight := contourData at: i. i := i + 1.
			boundsBottom := contourData at: i. i := i + 1.
			boundsTop := contourData at: i. i := i + 1.
			numContours := (contourData at: i) asInteger. i := i + 1.
			
			"TrueType doesn't speciy how to position diacritics wrt base character glyph.
			Horizontally center diacriticals wrt base glyph.
			See
				basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
				formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
				displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
			This should also be done for VectorEngineWithPlugin
			Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
			deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
			utf32 = 16r300 ifTrue: [	"Combining Grave Accent"
				deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
			utf32 = 16r301 ifTrue: [ 	"Combining Acute Accent"
				deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ].
			"DoubleWidth code points that combine above previous and following characters.
			Codepoints between 16r035C and 16r0363.
			Example: o͢o
			Don't center them"
			(utf32 between: 16r035C and: 16r0363) ifTrue: [
				deltaXToCenter := 0.0 ].
					
			deltaXForDiacriticalMark := 0.0.
			deltaYForDiacriticalMark := 0.
			advanceWidth = 0.0
				ifFalse: [ "Regular glyph"
					deltaXForBaseGlyph := deltaXToCenter.
					baseBoundsTop := boundsTop ]
				ifTrue: [ "Diacritical mark"
					deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
						ifFalse: [
							deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
							baseBoundsTop > boundsBottom ifTrue: [
								deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
			nextGlyphX := nextGlyphX + deltaXForDiacriticalMark.
			
			numContours timesRepeat: [
				numBeziers := (contourData at: i) asInteger. i := i + 1.
				ttMoveToX := contourData at: i. i := i + 1.
				ttMoveToY := contourData at: i. i := i + 1.
				x := ttMoveToX * sx + nextGlyphX.
				y := ttMoveToY * sy + nextGlyphY + deltaYForDiacriticalMark.
				contourStart := x@y.
				self moveTo: contourStart.
				numBeziers timesRepeat: [
					ttEndX := contourData at: i. i := i + 1.
					ttEndY := contourData at: i. i := i + 1.
					ttControlX := contourData at: i. i := i + 1.
					ttControlY := contourData at: i. i := i + 1.
					cx := ttControlX * sx + x.
					cy := ttControlY * sy + y.
					x := ttEndX * sx + x.
					y := ttEndY * sy + y.
					self quadraticBezierTo: x@y control: cx@cy ].
				self lineTo: contourStart ].
			nextGlyphX := nextGlyphX + (advanceWidth * sx) - deltaXForDiacriticalMark ]].
	^ nextGlyphX@nextGlyphY!

VectorEngine removeSelector: #displayUtf8:fromByte:toByte:at:trueTypeFont:color:scale:preventMirroring:!

!methodRemoval: VectorEngine #displayUtf8:fromByte:toByte:at:trueTypeFont:color:scale:preventMirroring: stamp: 'Install-7226-CleanStringDrawProtocol-p2-JuanVuletich-2025Apr14-10h47m-jmv.003.cs.st 5/24/2025 10:43:25'!
displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours numBeziers baseIndex x y cx cy contourStart deltaXToCenter deltaXForBaseGlyph deltaXForDiacriticalMark baseBoundsTop deltaYForDiacriticalMark byte1 byte2OrNil |
	deltaXForBaseGlyph := 0.0.
	baseBoundsTop := 0.
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	byte1 := nil.
	byte2OrNil := nil.
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		baseIndex := 0.
		byteStartIndex to: byteStopIndex do: [ :byteIndex | | byte i |
			byte := aByteArray at: byteIndex.
			byte1 isNil ifTrue: [byte1 := byte ] ifFalse: [ byte2OrNil isNil ifTrue: [ byte2OrNil := byte ]].
			i := contourDataIndexes at: baseIndex + byte + 1.
			
			"$i followed by a Combining Diacritical Mark is replaced by CodePoint 305 Dotless i, UTF-8 #[196 177]
			(UnicodeString fromUtf8Bytes: #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32
				105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ]) edit
			This should also be done for VectorEngineWithPlugin"
			(byte1 = 105 and: [ byteIndex < (byteStopIndex-1) ] and: [
				(aByteArray at: byteIndex+1) = 204 or: [ (aByteArray at: byteIndex+1) = 205 and: [ (aByteArray at: byteIndex+2) < 176 ]]])
					ifTrue: [
						i := contourDataIndexes at: 196 + 1.
						i := contourDataIndexes at: i negated + 177 + 1 ].
			
			i < 0
				ifTrue: [ baseIndex := i negated ]
				ifFalse: [
					advanceWidth := contourData at: i. i := i + 1.
					boundsLeft := contourData at: i. i := i + 1.
					boundsRight := contourData at: i. i := i + 1.
					boundsBottom := contourData at: i. i := i + 1.
					boundsTop := contourData at: i. i := i + 1.
					numContours := (contourData at: i) asInteger. i := i + 1.
					"TrueType doesn't speciy how to position diacritics wrt base character glyph.
					Horizontally center diacriticals wrt base glyph.
					See
						basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
						formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
						displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
					This should also be done for VectorEngineWithPlugin
					Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
					deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
					byte1 = 204 ifTrue: [
						byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
							deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
						byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
							deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ]].
					"DoubleWidth code points that combine above previous and following characters.
					Codepoints between 16r035C and 16r0363.
					Example: o͢o
					Don't center them"
					(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
						deltaXToCenter := 0.0 ].
					
					deltaXForDiacriticalMark := 0.0.
					deltaYForDiacriticalMark := 0.
					advanceWidth = 0.0
						ifFalse: [ "Regular glyph"
							deltaXForBaseGlyph := deltaXToCenter.
							baseBoundsTop := boundsTop ]
						ifTrue: [ "Diacritical mark"
							deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
								ifFalse: [
									deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
									baseBoundsTop > boundsBottom ifTrue: [
										deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
					nextGlyphX := nextGlyphX + deltaXForDiacriticalMark.
					
					numContours timesRepeat: [
						numBeziers := (contourData at: i) asInteger. i := i + 1.
						ttMoveToX := contourData at: i. i := i + 1.
						ttMoveToY := contourData at: i. i := i + 1.
						x := ttMoveToX * sx + nextGlyphX.
						y := ttMoveToY * sy + nextGlyphY + deltaYForDiacriticalMark.
						contourStart := x@y.
						self moveTo: contourStart.
						numBeziers timesRepeat: [
							ttEndX := contourData at: i. i := i + 1.
							ttEndY := contourData at: i. i := i + 1.
							ttControlX := contourData at: i. i := i + 1.
							ttControlY := contourData at: i. i := i + 1.
							cx := ttControlX * sx + x.
							cy := ttControlY * sy + y.
							x := ttEndX * sx + x.
							y := ttEndY * sy + y.
							self quadraticBezierTo: x@y control: cx@cy ].
						self lineTo: contourStart ].
					nextGlyphX := nextGlyphX + (advanceWidth * sx) - deltaXForDiacriticalMark.
					baseIndex := 0.
					byte1 := nil.
					byte2OrNil := nil ]]].
	^ nextGlyphX@nextGlyphY!

VectorEngine removeSelector: #displayByteString:from:to:at:trueTypeFont:color:scale:preventMirroring:!

!methodRemoval: VectorEngine #displayByteString:from:to:at:trueTypeFont:color:scale:preventMirroring: stamp: 'Install-7226-CleanStringDrawProtocol-p2-JuanVuletich-2025Apr14-10h47m-jmv.003.cs.st 5/24/2025 10:43:25'!
displayByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try BOTH!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.'.
e displayByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale ttMoveToX ttMoveToY ttEndX ttEndY ttControlX ttControlY advanceWidth boundsLeft boundsRight boundsTop boundsBottom numContours numBeziers x y cx cy contourStart |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	 "Should use a specific table with 256 entries"
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8. "Should use a specific table with 256 entries"
	self fillColor: aColor do: [
		nextGlyphX := aPoint x.
		nextGlyphY := aPoint y.
		startIndex to: stopIndex do: [ :charIndex | | latin1Code i |
			latin1Code := (aString at: charIndex) asciiValue.
			i := contourDataIndexes at: latin1Code + 1.
			advanceWidth := contourData at: i. i := i + 1.
			boundsLeft := contourData at: i. i := i + 1.
			boundsRight := contourData at: i. i := i + 1.
			boundsBottom := contourData at: i. i := i + 1.
			boundsTop := contourData at: i. i := i + 1.
			numContours := (contourData at: i) asInteger. i := i + 1.
			numContours timesRepeat: [
				numBeziers := (contourData at: i) asInteger. i := i + 1.
				ttMoveToX := contourData at: i. i := i + 1.
				ttMoveToY := contourData at: i. i := i + 1.
				x := ttMoveToX * sx + nextGlyphX.
				y := ttMoveToY * sy + nextGlyphY.
				contourStart := x@y.
				self moveTo: contourStart.
				numBeziers timesRepeat: [
					ttEndX := contourData at: i. i := i + 1.
					ttEndY := contourData at: i. i := i + 1.
					ttControlX := contourData at: i. i := i + 1.
					ttControlY := contourData at: i. i := i + 1.
					cx := ttControlX * sx + x.
					cy := ttControlY * sy + y.
					x := ttEndX * sx + x.
					y := ttEndY * sy + y.
					self quadraticBezierTo: x@y control: cx@cy ].
				self lineTo: contourStart ].
			nextGlyphX := nextGlyphX + (advanceWidth * sx) ]].
	^ nextGlyphX@nextGlyphY!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7226-CleanStringDrawProtocol-p2-JuanVuletich-2025Apr14-10h47m-jmv.003.cs.st----!

'From Cuis7.3 [latest update: #7134] on 14 April 2025 at 12:44:00 pm'!
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 12:29:26'!
        drawUtf8String: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor strokeWidth: sw strokeColor: sc scale: scale preventMirroring: doPreventMirroring
	"Allows adding a colored border to text display.
	TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
	"
	| e f s byteStartIndex byteStopIndex |
	'-----Try all FOUR of them!!' print.
	Display fillColor: Color veryLightGray.
	e := VectorEngineWholePixel onForm: Display.
	e := VectorEngineSubPixel onForm: Display.
	e := VectorEngineWithPluginWholePixel onForm: Display.
	e := VectorEngineWithPluginSubPixel onForm: Display.
	f := 	FontFamily defaultFamilyAndPointSize fontDescription.
	s := 'Hello World!! This is TrueType text rasterization in VectorEngine.' asUnicodeString.
	byteStartIndex := s byteIndexAt: 1.
	byteStopIndex := (s byteIndexAt: s size+1)-1.
	[e drawUtf8String: s asUtf8Bytes fromByte: byteStartIndex toByte: byteStopIndex at: 10@150 trueTypeFont: f color: Color random scale: 130 preventMirroring: true] timeToRun print.
	[e drawUtf8String: s asUtf8Bytes fromByte: byteStartIndex toByte: byteStopIndex at: 10@300 trueTypeFont: f color: Color random strokeWidth: 2 strokeColor: Color black scale: 130 preventMirroring: true] timeToRun print.
	Display forceToScreen.
	"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self strokeWidth: sw color: sc fillColor: aColor do: [
		nextGlyphX := self
			displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes ].
	^ nextGlyphX @ nextGlyphY.! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 4/14/2025 09:20:14'!
                      contourDataIndexForUtf32: codePoint contourDataIndexes: contourDataIndexes
	"contourDataIndexes is designed to be directly accessible via UTF-8 bytes of a CodePoint.
	This allows for a compact and efficient packing of TrueType contour data.
	In order to be used for a plain Code Point (as expressed in UTF-32), the UTF-8 bytes of
	the code point need to be extracted and used to access contourDataIndexes."

	| i utf8Byte1 utf8Byte2 utf8Byte3 utf8Byte4 |
	codePoint <= 16r7F
		ifTrue: [
			utf8Byte1 := codePoint.
			i := contourDataIndexes at: utf8Byte1 + 1 ]
		ifFalse: [ codePoint <= 16r7FF
		ifTrue: [
			utf8Byte1 := (codePoint bitShift: -6) bitOr: 2r11000000.
			utf8Byte2 := (codePoint bitAnd: 2r00111111) bitOr: 2r10000000.
			i := contourDataIndexes at: utf8Byte1 + 1.
			i := contourDataIndexes at: i negated + utf8Byte2 + 1 ]
		ifFalse: [ codePoint <= 16rFFFF
		ifTrue: [
			utf8Byte1 := (codePoint bitShift: -12) bitOr: 2r11100000.
			utf8Byte2 := ((codePoint bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
			utf8Byte3 := (codePoint bitAnd: 2r00111111) bitOr: 2r10000000.
			i := contourDataIndexes at: utf8Byte1 + 1.
			i := contourDataIndexes at: i negated + utf8Byte2 + 1.
			i := contourDataIndexes at: i negated + utf8Byte3 + 1 ]
		ifFalse: [
			utf8Byte1 := (codePoint bitShift: -18) bitOr: 2r11110000.
			utf8Byte2 := ((codePoint bitShift: -12) bitAnd: 2r00111111) bitOr: 2r10000000.
			utf8Byte3 := ((codePoint bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
			utf8Byte4 := (codePoint bitAnd: 2r00111111) bitOr: 2r10000000.
			i := contourDataIndexes at: utf8Byte1 + 1.
			i := contourDataIndexes at: i negated + utf8Byte2 + 1.
			i := contourDataIndexes at: i negated + utf8Byte3 + 1.
			i := contourDataIndexes at: i negated + utf8Byte4 + 1 ]]].
	^i! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 4/14/2025 12:14:24'!
                               displayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours |
	nextGlyphX := destX.
	startIndex to: stopIndex do: [ :charIndex | | latin1Code i |
		latin1Code := (aString at: charIndex) asciiValue.
		i := contourDataIndexes at: latin1Code + 1.
		advanceWidth := contourData at: i. i := i + 1.
		boundsLeft := contourData at: i. i := i + 1.
		boundsRight := contourData at: i. i := i + 1.
		boundsBottom := contourData at: i. i := i + 1.
		boundsTop := contourData at: i. i := i + 1.
		numContours := (contourData at: i) asInteger. i := i + 1.
		i := self glyphContours: numContours atx: nextGlyphX y: destY scalex: sx y: sy contourData: contourData i: i.
		nextGlyphX := nextGlyphX + (advanceWidth * sx) ].
	^nextGlyphX! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 4/14/2025 12:14:03'!
              displayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours deltaXToCenter deltaXForDiacriticalMark deltaYForDiacriticalMark deltaXForBaseGlyph baseBoundsTop |
	nextGlyphX := destX.
	startIndex to: stopIndex do: [ :utf32Index | | utf32 i |
		utf32 := aWordArray at: utf32Index.
		
		"$i followed by a Combining Diacritical Mark is replaced by CodePoint 16r131 Dotless i
		This should also be done for VectorEngineWithPlugin"
		(utf32 = 16r69 and: [ utf32Index < stopIndex ] and: [
			(aWordArray at: utf32Index+1) between: 16r300 and: 16r36F ])
				ifTrue: [ utf32 := 16r131 ].
		i :=  self contourDataIndexForUtf32: utf32 contourDataIndexes: contourDataIndexes.
		advanceWidth := contourData at: i. i := i + 1.
		boundsLeft := contourData at: i. i := i + 1.
		boundsRight := contourData at: i. i := i + 1.
		boundsBottom := contourData at: i. i := i + 1.
		boundsTop := contourData at: i. i := i + 1.
		numContours := (contourData at: i) asInteger. i := i + 1.
		
		"TrueType doesn't speciy how to position diacritics wrt base character glyph.
		Horizontally center diacriticals wrt base glyph.
		See
			basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
			formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
			displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
		This should also be done for VectorEngineWithPlugin
		Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
		deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
		utf32 = 16r300 ifTrue: [	"Combining Grave Accent"
			deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
		utf32 = 16r301 ifTrue: [ 	"Combining Acute Accent"
			deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ].
		"DoubleWidth code points that combine above previous and following characters.
		Codepoints between 16r035C and 16r0363.
		Example: o͢o
		Don't center them"
		(utf32 between: 16r035C and: 16r0363) ifTrue: [
			deltaXToCenter := 0.0 ].
				
		deltaXForDiacriticalMark := 0.0.
		deltaYForDiacriticalMark := 0.
		advanceWidth = 0.0
			ifFalse: [ "Regular glyph"
				deltaXForBaseGlyph := deltaXToCenter.
				baseBoundsTop := boundsTop ]
			ifTrue: [ "Diacritical mark"
				deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
					ifFalse: [
						deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
						baseBoundsTop > boundsBottom ifTrue: [
							deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
		
		i := self
			glyphContours: numContours
			atx: nextGlyphX + deltaXForDiacriticalMark y: destY + deltaYForDiacriticalMark
			scalex: sx y: sy
			contourData: contourData i: i.
		
		nextGlyphX := nextGlyphX + (advanceWidth * sx) ].
	^nextGlyphX! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 4/14/2025 12:13:33'!
            displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX byte1 byte2OrNil baseIndex advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours deltaXToCenter deltaXForDiacriticalMark deltaYForDiacriticalMark deltaXForBaseGlyph baseBoundsTop |
	nextGlyphX := destX.
	byte1 := nil.
	byte2OrNil := nil.
	baseIndex := 0.
	byteStartIndex to: byteStopIndex do: [ :byteIndex | | byte i |
		byte := aByteArray at: byteIndex.
		byte1 isNil ifTrue: [byte1 := byte ] ifFalse: [ byte2OrNil isNil ifTrue: [ byte2OrNil := byte ]].
		i := contourDataIndexes at: baseIndex + byte + 1.
		
		"$i followed by a Combining Diacritical Mark is replaced by CodePoint 305 Dotless i, UTF-8 #[196 177]
		(UnicodeString fromUtf8Bytes: #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32
			105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ]) edit
		This should also be done for VectorEngineWithPlugin"
		(byte1 = 105 and: [ byteIndex < (byteStopIndex-1) ] and: [
			(aByteArray at: byteIndex+1) = 204 or: [ (aByteArray at: byteIndex+1) = 205 and: [ (aByteArray at: byteIndex+2) < 176 ]]])
				ifTrue: [
					i := contourDataIndexes at: 196 + 1.
					i := contourDataIndexes at: i negated + 177 + 1 ].
		
		i < 0
			ifTrue: [ baseIndex := i negated ]
			ifFalse: [
				advanceWidth := contourData at: i. i := i + 1.
				boundsLeft := contourData at: i. i := i + 1.
				boundsRight := contourData at: i. i := i + 1.
				boundsBottom := contourData at: i. i := i + 1.
				boundsTop := contourData at: i. i := i + 1.
				numContours := (contourData at: i) asInteger. i := i + 1.
				"TrueType doesn't speciy how to position diacritics wrt base character glyph.
				Horizontally center diacriticals wrt base glyph.
				See
					basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
					formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
					displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
				This should also be done for VectorEngineWithPlugin
				Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
				deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
				byte1 = 204 ifTrue: [
					byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
						deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
					byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
						deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ]].
				"DoubleWidth code points that combine above previous and following characters.
				Codepoints between 16r035C and 16r0363.
				Example: o͢o
				Don't center them"
				(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
					deltaXToCenter := 0.0 ].
				
				deltaXForDiacriticalMark := 0.0.
				deltaYForDiacriticalMark := 0.
				advanceWidth = 0.0
					ifFalse: [ "Regular glyph"
						deltaXForBaseGlyph := deltaXToCenter.
						baseBoundsTop := boundsTop ]
					ifTrue: [ "Diacritical mark"
						deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
							ifFalse: [
								deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
								baseBoundsTop > boundsBottom ifTrue: [
									deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
				
				i := self
					glyphContours: numContours
					atx: nextGlyphX + deltaXForDiacriticalMark y: destY + deltaYForDiacriticalMark
					scalex: sx y: sy
					contourData: contourData i: i.
				
				nextGlyphX := nextGlyphX + (advanceWidth * sx).
				baseIndex := 0.
				byte1 := nil.
				byte2OrNil := nil ]].
	^nextGlyphX! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 4/14/2025 09:05:25'!
                          glyphContours: numContours atx: nextGlyphX y: nextGlyphY scalex: sx y: sy contourData: contourData i: contourDataIndex

		| i contourStart numBeziers ttMoveToX ttMoveToY x y |
		i := contourDataIndex.
		numContours timesRepeat: [
			numBeziers := (contourData at: i) asInteger. i := i + 1.
			ttMoveToX := contourData at: i. i := i + 1.
			ttMoveToY := contourData at: i. i := i + 1.
			x := ttMoveToX * sx + nextGlyphX.
			y := ttMoveToY * sy + nextGlyphY.
			contourStart := x@y.
			self moveTo: contourStart.
			numBeziers timesRepeat: [ | cx cy ttControlX ttControlY ttEndX ttEndY |
				ttEndX := contourData at: i. i := i + 1.
				ttEndY := contourData at: i. i := i + 1.
				ttControlX := contourData at: i. i := i + 1.
				ttControlY := contourData at: i. i := i + 1.
				cx := ttControlX * sx + x.
				cy := ttControlY * sy + y.
				x := ttEndX * sx + x.
				y := ttEndY * sy + y.
				self quadraticBezierTo: x@y control: cx@cy ].
			self lineTo: contourStart ].
		^i! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 12:33:16' prior: 50390024 overrides: 50389439!
             drawByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try all FOUR of the,!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only in this example. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.' asByteString.
e drawByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale asFloat.
	sy := scale * trueTypeScale asFloat.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	 "Should use a specific table with 256 entries"
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8. "Should use a specific table with 256 entries"
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayByteString: aString from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes ].
	^ nextGlyphX @ nextGlyphY.! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 12:33:20' prior: 50390086 overrides: 50389536!
                             drawUtf32String: aWordArray from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f utf32 |
'Try All four!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf32 _ #(4314 4317 4320 4308 4315 32 4312 4324 4321 4323 4315 32 4307 4317 4314 4317 4320 32 4321 4312 4311 32 4304 4315 4308 4311 44 32 4327 4323 4317 32 4323 4311 32 4307 4312 4330 4304 4311 32 4304 4314 4312 4327 4323 4312 4307 44 32 4304 4307 32 4314 4312 4305 4320 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4320 4308 4324 4320 4308 4336 4308 4316 4307 4323 4316 4311 32 4308 4321 4311 46 32 4314 4308 4306 4308 4320 4308 32 4330 4317 4320 4324 4317 4320 4304 32 4308 4324 4324 4312 4330 4312 4304 4316 4311 4323 4320 32 4304 4311 32 4308 4304 4315 44 32 4316 4317 32 4327 4323 4304 4321 32 4315 4308 4316 4304 4316 4307 4320 4312 32 4320 4308 4324 4308 4320 4320 4308 4316 4311 4323 4320 32 4327 4323 4312 46 32 4311 4308 32 4324 4323 4311 4308 4316 4311 32 4315 4317 4314 4314 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4309 4312 4321 46 32 4309 4312 4315 32 4307 4308 4316 4312 4327 4323 4308 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4311 4336 4308 4317 4324 4336 4320 4304 4321 4311 4323 4321 32 4308 4334 44 32 4308 4304 32 4336 4304 4321 32 4309 4317 4314 4323 4315 4323 4321 32 4324 4304 4321 4311 4312 4307 4312 4312 32 4307 4308 4321 4308 4320 4323 4316 4311 46 32 4308 4334 32 4317 4324 4324 4312 4330 4312 4312 4321 32 4311 4317 4320 4327 4323 4304 4311 4317 4321 32 4315 4308 4312 44 32 4307 4317 4330 4311 4323 4321 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4312 4316 32 4327 4323 4317 46 32 4321 4323 4315 4315 4317 32 4311 4320 4304 4330 4311 4304 4311 4317 4321 32 4308 4312 32 4312 4323 4321 44 32 4323 4311 32 4317 4315 4316 4308 4321 32 4309 4312 4320 4311 4323 4311 4308 32 4307 4308 4311 4320 4304 4334 4312 4311 46) asWordArray.
e drawUtf32String: utf32 from: 1 to: utf32 size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"
"
| e f utf8a utf8b utf8c utf32a utf32b utf32c |
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf8a := #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32 105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ].
utf8b := #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97	].
utf8c := #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 105 195 173 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97 105 105 204 129 	].
utf32a := #(105 105 769 32 105 768 32 105 770 32 105 771 32 105 772 32 105 773 32 105 774 32 105 775 32 105 776 32 105 777) asWordArray.
utf32b :=  #(97 233 97 232 97 241 97 209 252 64 97 101 769 97 101 768 97 110 771 97 78 771 117 776 97) asWordArray.
utf32c :=  #(97 233 97 232 97 241 97 209 252 105 237 64 97 101 769 97 101 768 97 110 771 97 78 771 117 776 97 105 105 769) asWordArray.
e drawUtf8String: utf8a fromByte: 1 toByte: utf8a size at: 10@120 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf32String: utf32a from: 1 to: utf32a size at: 10@220 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf8String: utf8b fromByte: 1 toByte: utf8b size at: 10@320 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf32String: utf32b from: 1 to: utf32b size at: 10@420 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf8String: utf8c fromByte: 1 toByte: utf8c size at: 10@520 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf32String: utf32c from: 1 to: utf32c size at: 10@620 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayUtf32: aWordArray from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes ].
	^ nextGlyphX @ nextGlyphY.! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 12:33:27' prior: 50390194 overrides: 50389847!
                     drawUtf8String: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
	"
	| e f s byteStartIndex byteStopIndex |
	'-----Try all FOUR of them!!' print.
	Display fillColor: Color veryLightGray.
	e := VectorEngineWholePixel onForm: Display.
	e := VectorEngineSubPixel onForm: Display.
	e := VectorEngineWithPluginWholePixel onForm: Display.
	e := VectorEngineWithPluginSubPixel onForm: Display.
	f := 	FontFamily defaultFamilyAndPointSize fontDescription.
	s := 'Hello World!! This is TrueType text rasterization in VectorEngine.' asUnicodeString.
	byteStartIndex := s byteIndexAt: 1.
	byteStopIndex := (s byteIndexAt: s size+1)-1.
	[e drawUtf8String: s asUtf8Bytes fromByte: byteStartIndex toByte: byteStopIndex at: 10@150 trueTypeFont: f color: Color random scale: 130 preventMirroring: true] timeToRun print.
	[e drawUtf8String: s asUtf8Bytes fromByte: byteStartIndex toByte: byteStopIndex at: 10@300 trueTypeFont: f color: Color random strokeWidth: 2 strokeColor: Color black scale: 130 preventMirroring: true] timeToRun print.
	Display forceToScreen.
	"
	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes ].
	^ nextGlyphX @ nextGlyphY.! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/14/2025 12:07:54'!
                    primDisplayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	self subclassResponsibility! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/14/2025 12:08:07'!
              primDisplayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	self subclassResponsibility! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/14/2025 12:08:15'!
                primDisplayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	self subclassResponsibility! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 12:36:03' prior: 50389439!
              drawByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try all FOUR of the,!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only in this example. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.' asByteString.
e drawByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale asFloat.
	sy := scale * trueTypeScale asFloat.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	 "Should use a specific table with 256 entries"
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8. "Should use a specific table with 256 entries"
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			displayByteString: aString from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes ].
	^ nextGlyphX @ nextGlyphY.! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 12:34:49' prior: 50389536!
                               drawUtf32String: aWordArray from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f utf32 |
'Try All four!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf32 _ #(4314 4317 4320 4308 4315 32 4312 4324 4321 4323 4315 32 4307 4317 4314 4317 4320 32 4321 4312 4311 32 4304 4315 4308 4311 44 32 4327 4323 4317 32 4323 4311 32 4307 4312 4330 4304 4311 32 4304 4314 4312 4327 4323 4312 4307 44 32 4304 4307 32 4314 4312 4305 4320 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4320 4308 4324 4320 4308 4336 4308 4316 4307 4323 4316 4311 32 4308 4321 4311 46 32 4314 4308 4306 4308 4320 4308 32 4330 4317 4320 4324 4317 4320 4304 32 4308 4324 4324 4312 4330 4312 4304 4316 4311 4323 4320 32 4304 4311 32 4308 4304 4315 44 32 4316 4317 32 4327 4323 4304 4321 32 4315 4308 4316 4304 4316 4307 4320 4312 32 4320 4308 4324 4308 4320 4320 4308 4316 4311 4323 4320 32 4327 4323 4312 46 32 4311 4308 32 4324 4323 4311 4308 4316 4311 32 4315 4317 4314 4314 4312 4321 32 4330 4308 4311 4308 4320 4317 4321 32 4309 4312 4321 46 32 4309 4312 4315 32 4307 4308 4316 4312 4327 4323 4308 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4311 4336 4308 4317 4324 4336 4320 4304 4321 4311 4323 4321 32 4308 4334 44 32 4308 4304 32 4336 4304 4321 32 4309 4317 4314 4323 4315 4323 4321 32 4324 4304 4321 4311 4312 4307 4312 4312 32 4307 4308 4321 4308 4320 4323 4316 4311 46 32 4308 4334 32 4317 4324 4324 4312 4330 4312 4312 4321 32 4311 4317 4320 4327 4323 4304 4311 4317 4321 32 4315 4308 4312 44 32 4307 4317 4330 4311 4323 4321 32 4309 4312 4309 4308 4316 4307 4323 4315 32 4312 4316 32 4327 4323 4317 46 32 4321 4323 4315 4315 4317 32 4311 4320 4304 4330 4311 4304 4311 4317 4321 32 4308 4312 32 4312 4323 4321 44 32 4323 4311 32 4317 4315 4316 4308 4321 32 4309 4312 4320 4311 4323 4311 4308 32 4307 4308 4311 4320 4304 4334 4312 4311 46) asWordArray.
e drawUtf32String: utf32 from: 1 to: utf32 size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"
"
| e f utf8a utf8b utf8c utf32a utf32b utf32c |
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
utf8a := #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32 105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ].
utf8b := #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97	].
utf8c := #[97 	195 169 97 195 168 	97 	195 177 97 	195 145 195 188 105 195 173 64 97 	101 204 129 97 101 204 128 97 	110 204 131 97 	78 204 131 117 204 136 97 105 105 204 129 	].
utf32a := #(105 105 769 32 105 768 32 105 770 32 105 771 32 105 772 32 105 773 32 105 774 32 105 775 32 105 776 32 105 777) asWordArray.
utf32b :=  #(97 233 97 232 97 241 97 209 252 64 97 101 769 97 101 768 97 110 771 97 78 771 117 776 97) asWordArray.
utf32c :=  #(97 233 97 232 97 241 97 209 252 105 237 64 97 101 769 97 101 768 97 110 771 97 78 771 117 776 97 105 105 769) asWordArray.
e drawUtf8String: utf8a fromByte: 1 toByte: utf8a size at: 10@120 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf32String: utf32a from: 1 to: utf32a size at: 10@220 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf8String: utf8b fromByte: 1 toByte: utf8b size at: 10@320 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf32String: utf32b from: 1 to: utf32b size at: 10@420 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf8String: utf8c fromByte: 1 toByte: utf8c size at: 10@520 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
e drawUtf32String: utf32c from: 1 to: utf32c size at: 10@620 trueTypeFont: f color: Color black scale: 50 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			displayUtf32: aWordArray from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes ].
	^ nextGlyphX @ nextGlyphY.! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 4/14/2025 12:34:12' prior: 50389847!
                       drawUtf8String: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
	"
	| e f s byteStartIndex byteStopIndex |
	'-----Try all FOUR of them!!' print.
	Display fillColor: Color veryLightGray.
	e := VectorEngineWholePixel onForm: Display.
	e := VectorEngineSubPixel onForm: Display.
	e := VectorEngineWithPluginWholePixel onForm: Display.
	e := VectorEngineWithPluginSubPixel onForm: Display.
	f := 	FontFamily defaultFamilyAndPointSize fontDescription.
	s := 'Hello World!! This is TrueType text rasterization in VectorEngine.' asUnicodeString.
	byteStartIndex := s byteIndexAt: 1.
	byteStopIndex := (s byteIndexAt: s size+1)-1.
	[e drawUtf8String: s asUtf8Bytes fromByte: byteStartIndex toByte: byteStopIndex at: 10@150 trueTypeFont: f color: Color random scale: 130 preventMirroring: true] timeToRun print.
	[e drawUtf8String: s asUtf8Bytes fromByte: byteStartIndex toByte: byteStopIndex at: 10@300 trueTypeFont: f color: Color random strokeWidth: 2 strokeColor: Color black scale: 130 preventMirroring: true] timeToRun print.
	Display forceToScreen.
	"
	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes ].
	^ nextGlyphX @ nextGlyphY.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
(Delay forSeconds: 1) wait.
Smalltalk garbageCollect.
{'V7 Vector Graphics Plugin enabled: '. VectorEngine allSubInstances collect: [ :e | e class ] :: asBag } print.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7227-BorderedText-DrawTextRefactor-JuanVuletich-2025Apr14-12h40m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7137] on 15 April 2025 at 5:57:32 pm'!
!HaloMorph methodsFor: 'drawing' stamp: 'jmv 4/15/2025 17:57:12' prior: 16871975!
  drawCoordinateSystemOn: aCanvas

	| x0 x1 y0 y1 c stepX stepY haloTargetTx prevTx font strokeWidth tickLength stepXDecimals stepYDecimals |
	haloTargetTx := MorphicTranslation identity.
	target allOwnersReverseDo: [ :o | haloTargetTx := haloTargetTx composedWith: o location ].
	haloTargetTx := haloTargetTx composedWith: target location.

	target knowsOwnLocalBounds
		ifTrue: [ | r |
			r := target localBounds.
			x0 := r left.
			x1 := r right.
			y0 := r top.
			y1 := r bottom ]
		ifFalse: [
			x0 := x1 := y0 := y1 := 0.
			target displayFullBounds corners collect: [ :pt | | p |
				p := haloTargetTx inverseTransform: pt.
				x0 := x0 min: p x.
				x1 := x1 max: p x.
				y0 := y0 min: p y.
				y1 := y1 max: p y.]].

	font := FontFamily defaultFamilyPointSize: (FontFamily defaultPointSize * 1.5 / haloTargetTx scale) rounded.
	stepX := (font pointSize * 9) round4perMagnitudeOrder asFloat.
	stepXDecimals := stepX log rounded negated + 1.
	stepY := (font pointSize * 5) round4perMagnitudeOrder asFloat.
	stepYDecimals := stepY log rounded negated + 1.
	strokeWidth := 3/ haloTargetTx scale.
	tickLength := 5 / haloTargetTx scale.

	prevTx := aCanvas currentTransformation.
	aCanvas geometryTransformation: haloTargetTx.

	c := `Color black alpha: 0.4`.
	aCanvas line: x0@0 to: x1@0 width: strokeWidth color: c.
	aCanvas line: 0@y0 to: 0@y1 width: strokeWidth color: c.

	(x0 truncateTo: stepX) to: x1 by: stepX do: [ :x |
		aCanvas line: x @ tickLength negated to: x @ tickLength width: strokeWidth color: c.
		aCanvas drawString: (x printStringFractionDigits: stepXDecimals) atWaistCenter: x @ (tickLength*4) negated font: font color: c ].
	  aCanvas drawString: 'x' atCenterX: x1 - (tickLength*3) @ 0 font: font color: c.

	(y0 truncateTo: stepY) to: y1 by: stepY do: [ :y |
		aCanvas line: tickLength negated @ y to: tickLength @ y width: strokeWidth color: c.
		aCanvas drawString: (y printStringFractionDigits: stepYDecimals), ' ' atWaistRight: tickLength negated @ y font: font color: c ].
	  aCanvas drawString: 'y' atWaist: tickLength @ (y1 - (tickLength*4)) font: font color: c.

	aCanvas geometryTransformation: prevTx.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7228-HaloCoordiatesDrawTweak-JuanVuletich-2025Apr15-17h56m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7138] on 16 April 2025 at 9:58:00 am'!
!VectorEngineWithPlugin methodsFor: 'accessing' stamp: 'jmv 4/16/2025 09:55:27' prior: 50387293 overrides: 50387279!
                              clippingSpec: aClippingSpecOrNil
	clippingSpec := aClippingSpecOrNil.
	clippingSpec
		ifNil: [ self primClearClippingSpec ]
		ifNotNil: [
			clippingSpec pin.
			self primSetClippingSpec: clippingSpec ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7229-pin-clippingSpec-JuanVuletich-2025Apr16-09h55m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7138] on 16 April 2025 at 9:59:24 am'!
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/16/2025 09:59:03' prior: 50385507!
            finishPath: ensureClosePath
	"Blend stroke and/or fill over background, according to the just computed pen alphas (distance from pixel to center of stroke)"
	| spanLeft spanTop spanRight spanBottom |

	"If we are doing a fill, and caller forgot to close the trajectory, then do it anyway."
	ensureClosePath ifTrue: [
		firstX isNaN ifFalse: [
			(firstX = currentX and: [ firstY = currentY ]) ifFalse: [
				"This is actually an error condition. If we are asked to fill, then the path should be closed.
				This is a workaround. If width > 0.0, we'll be adding a visible edge to the path."
				self lineToFirstPoint ]]].
	self primUpdateContourLastLine.

	spanLeft := self primSpanLeft.
	spanTop := self primSpanTop.
	spanRight := self primSpanRight.
	spanBottom := self primSpanBottom.

	"morphBounds is not affected by clipRect"
	morphBoundsLeft := morphBoundsLeft min: spanLeft.
	morphBoundsTop := morphBoundsTop min: spanTop.
	morphBoundsRight := morphBoundsRight max: spanRight.
	morphBoundsBottom := morphBoundsBottom max: spanBottom.

	spanLeft< clipLeft ifTrue: [ spanLeft := clipLeft ].
	spanTop < clipTop ifTrue: [ spanTop := clipTop ].
	spanRight > clipRight ifTrue: [ spanRight := clipRight ].
	spanBottom > clipBottom ifTrue: [ spanBottom := clipBottom ].

	(spanRight >= spanLeft and: [ spanBottom >= spanTop ]) ifTrue: [
		self clippingSpec: clippingSpec.
		fillColor notNil ifTrue: [
			strokeColor notNil
				ifTrue: [ self primBlendStrokeAndFillLeft: spanLeft top: spanTop right: spanRight bottom: spanBottom ]
				ifFalse: [ self primBlendFillOnlyLeft: spanLeft top: spanTop right: spanRight bottom: spanBottom ]]
			ifFalse: [
				self primBlendStrokeOnlyLeft: spanLeft top: spanTop right: spanRight bottom: spanBottom ]].! !
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 4/16/2025 09:58:53' prior: 50387989 overrides: 17000856!
                           initializePath

	super initializePath.

	"Set all plugin state. There might be several instances of this class, all using the same plugin.
	Only one of them will use the plugin during a path draw operation. See class variable AccessLock."
	self
		primTargetBits: targetForm bits
		morphIds: morphIds
		edgeCounts: edgeCounts
		alphaMask: alphaMask
		affectedBits: affectedBits
		contour: contour
		targetWidth: targetWidth
		targetHeight: targetHeight.
	self primTargetAssumedOpaque: targetAssumedOpaque.
	self
		primAntiAliasingWidth: antiAliasingWidth asFloat
		subPixelDelta: self subPixelDelta asFloat.
	self primClipLeft: clipLeft clipTop: clipTop clipRight: clipRight clipBottom: clipBottom.
	self primCurrentMorphId: currentMorphId.
	self
		primGeometryTxA11: geometryTransformation a11 asFloat
		a12: geometryTransformation a12 asFloat
		a13: geometryTransformation a13 asFloat
		a21: geometryTransformation a21 asFloat
		a22: geometryTransformation a22 asFloat
		a23: geometryTransformation a23 asFloat.

	self primInitializePath.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7230-setClippingSpecOn-finishPath-JuanVuletich-2025Apr16-09h58m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7140] on 16 April 2025 at 12:03:44 pm'!
!WorldMorph commentStamp: 'jmv 4/16/2025 11:44:38' prior: 17008867!
                      A WorldMorph is a kind of PasteUpMorph that can act as the root morph of a Morphic system. Usually uses the whole Display.

activeHand 				-- a HandMorph
hands 					-- Array of HandMorphs (typically only one) representing the Cursor and its event queue.
canvas 					-- BitBlitCanvas on the DisplayScreen. (Display getCanvas)
damageRecorder 		-- the DamageRecorder for the Display
stepList 					-- a Heap of StepMessage.  Each morph which wants stepping has a StepMessage here.
								See comment in #Morph>>stepAt:
lastStepTime 			-- 'now' as last sampled at step. (Time localMillisecondClock)
lastStepMessage 		-- nil or a selector
lastCycleTime 			-- 'now' as last sampled (Time localMillisecondClock)
alarms 					-- a Heap of MorphicAlarm.  See comment in #Morph>>addAlarm:after:
								An _alarm_ is an action to be done once, vs a _step_ which is cycled.
lastAlarm 				-- 'now' as sampled at last alarm (Time localMillisecondClock).
drawingFailureMorphs 	-- a WeakIdentitySet of Morphs with drawing failures
waitDelay 				-- a Delay
pause 					-- A 'phase-locked loop' style value to help regularise the step/alarm/event service rate.
lastCycleHadAnyEvent 	-- a boolean
!

AbstractVectorCanvas subclass: #VectorCanvas
	instanceVariableNames: 'clippingSpecStack csi boundsFinderCanvas auxBitBltEngine attachedCanvas '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorCanvas category: #'Morphic-Support' stamp: 'Install-7231-VectorCanvas-Remove-auxBitBlt-JuanVuletich-2025Apr16-11h54m-jmv.001.cs.st 5/24/2025 10:43:26'!
AbstractVectorCanvas subclass: #VectorCanvas
	instanceVariableNames: 'clippingSpecStack csi boundsFinderCanvas auxBitBltEngine attachedCanvas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!
!AbstractVectorCanvas methodsFor: 'drawing - text' stamp: 'jmv 4/16/2025 11:42:47' prior: 50389060 overrides: 16909312!
   drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: aTrueTypeFont color: aColor
	"Answer position to place next glyph"
	"
| s c f |
c := VectorCanvas onForm: Display.
c geometryTransformation: (AffineTransformation withRadians: 0.1).
f := FontFamily familyName: 'DejaVu Sans' pointSize: 72.
s := 'Latin text in VectorGraphics'.
(c drawString: s from: 1 to: s size atBaseline: 100@100 font: f color: Color black) print.
c strokeWidth: 1 color: Color red do: [ c moveTo: 100@100; lineTo: 1000@100 ].
Display forceToScreen
	"
	"Don't waste any time if NOP"
	lastIndex = 0 ifTrue: [
		^nil ].

	^ aString asUnicodeString drawOnVectorEngine: engine from: firstIndex to: lastIndex
		at: aPoint font: aTrueTypeFont color: aColor.! !
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 4/16/2025 12:02:22' prior: 50375058 overrides: 16909119!
                image: srcForm at: aPoint
	"Workaround using WarpBlt until properly implemented in VectorEngine.
	 (WarpBlt might not give desired result, i.e. a properly filtered and resampled image)

	In the general case, use WarpBlt to apply currentTransformation.
	Prior to that, set morphIds for affected pixels, and update bounds in engine.
	This is expensive!!

	If No scaling and no rotation, use BitBlt instead (way faster). This is useful, for instance, for halo handles.
	We expect to replace them with vector graphics icons, anyway."

	"We need to compute bounds. While we are at it, set morphID for affected pixels."
	self fillRectangle: (srcForm boundingBox translatedBy: aPoint) color: `Color gray alpha: 0.01`.
	currentTransformation isPureTranslation
		ifTrue: [
			| p bitBlt |
			p := (currentTransformation transform: aPoint) roundedHAFZ.
			bitBlt := BitBltCanvasEngine toForm: form.
			bitBlt
				sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				sourceX: 0; sourceY: 0;
				destX: p x destY: p y width: srcForm width height: srcForm height;
				copyBits ]
		ifFalse: [
			| bb cellSize dstBox srcBox srcQuad |
			cellSize := 4.
			srcBox := srcForm boundingBox.
			dstBox := (currentTransformation externalBoundingRectOf: srcBox)
				encompassingIntegerRectangle.
			srcQuad := dstBox corners collect: [ :pt | (currentTransformation inverseTransform: pt) roundedHAFZ ].
			dstBox := (srcBox translatedBy: aPoint).
			dstBox := dstBox origin extent: dstBox extent + 1.1.
			dstBox := ((currentTransformation externalBoundingRectOf: dstBox))
				encompassingIntegerRectangle.
			bb := WarpBlt toForm: form.
			bb
				sourceForm: srcForm; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				cellSize: cellSize;
				copyQuad: srcQuad toRect: dstBox ].! !
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 4/16/2025 12:03:10' prior: 50375156!
                             image: srcForm at: aPoint sourceRect: sourceRect
	"Workaround using WarpBlt until properly implemented in VectorEngine.
	 (WarpBlt might not give desired result, i.e. a properly filtered and resampled image)

	In the general case, use WarpBlt to apply currentTransformation.
	Prior to that, set morphIds for affected pixels, and update bounds in engine.
	This is expensive!!

	If No scaling and no rotation, use BitBlt instead (way faster). This is useful, for instance, for halo handles.
	We expect to replace them with vector graphics icons, anyway."

	"We need to compute bounds. While we are at it, set morphID for affected pixels."
	self fillRectangle: (sourceRect translatedBy: aPoint) color: `Color gray alpha: 0.01`.
	currentTransformation isPureTranslation
		ifTrue: [
			| p bitBlt |
			p := (currentTransformation transform: aPoint) roundedHAFZ.
			bitBlt := BitBltCanvasEngine toForm: form.
			bitBlt
				sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				sourceX: sourceRect left; sourceY: sourceRect top;
				destX: p x destY: p y width: sourceRect width height: sourceRect height;
				copyBits ]
		ifFalse: [
			| bb cellSize dstBox srcBox srcQuad |
			cellSize := 4.
			srcBox := sourceRect.
			dstBox := (currentTransformation externalBoundingRectOf: srcBox)
				encompassingIntegerRectangle.
			srcQuad := dstBox corners collect: [ :pt | (currentTransformation inverseTransform: pt) roundedHAFZ ].
			dstBox := (currentTransformation externalBoundingRectOf: (srcBox translatedBy: aPoint-0.5))
				encompassingIntegerRectangle.
			bb := WarpBlt toForm: form.
			bb
				sourceForm: srcForm; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				cellSize: cellSize;
				copyQuad: srcQuad toRect: dstBox ].! !
!VectorCanvas methodsFor: 'initialization' stamp: 'jmv 4/16/2025 11:52:50' prior: 50374053!
                    setForm: aForm subPixelAntiAliasing: aBoolean
	"nil means use default kind of anti aliasing"
	"
	self runningWorld setupNewCanvasAndEngine
	"
	aForm depth = 32 ifFalse: [ self error: 'VectorCanvas can only work on 32 bit target' ].
	form := aForm.
	engine := VectorEngine onForm: form subPixelAntiAliasing: aBoolean.
	engine canvas: self.
	self newClipRect: nil.! !
!VectorCanvas methodsFor: 'initialization' stamp: 'jmv 4/16/2025 11:53:07' prior: 16999926!
                      setVectorEngine: vectorEngineToReuse

	form := vectorEngineToReuse target.
	engine := vectorEngineToReuse.
	self doOwnEngine.
	self newClipRect: nil.! !
!VectorCanvas methodsFor: 'private' stamp: 'jmv 4/16/2025 11:52:44' prior: 16999953 overrides: 16909827!
                              nilState
	"Nil possibly trouble making references. See senders."
	super nilState.
	boundsFinderCanvas notNil ifTrue: [
		boundsFinderCanvas nilState ].! !
!VectorCanvas methodsFor: 'private' stamp: 'jmv 4/16/2025 11:52:40' prior: 16999978 overrides: 16909833!
                            setClipRect: aRectangle
	"In targetForm coordinates"

	super setClipRect: aRectangle.
	engine clipRect: aRectangle.
	boundsFinderCanvas ifNotNil: [
		boundsFinderCanvas setClipRect: aRectangle ].! !
!VectorCanvas methodsFor: 'private-framework' stamp: 'jmv 4/16/2025 11:52:24' prior: 16999990 overrides: 16909843!
      privateFrameAndFillGlobalRect: rect fillColor: fillColor borderWidth: borderWidth color: borderColor
	"
	(VectorCanvas onForm: Display)
		privateFrameAndFillGlobalRect: (10@10 extent: 300@200)
		fillColor: Color yellow
		borderWidth: 20
		color: Color green.
	Display forceToScreen
	"
	| bitBlt |
	bitBlt := BitBltCanvasEngine toForm: form.
	bitBlt clipRect: rect.
	bitBlt
		sourceForm: nil;
		combinationRule: (borderColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: borderColor;
		frameRect: rect borderWidth: borderWidth;
		combinationRule: (fillColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: fillColor;
		fillRect: (rect insetBy: borderWidth).! !
!VectorCanvas methodsFor: 'private-framework' stamp: 'jmv 4/16/2025 11:51:45' prior: 17000017 overrides: 16909850!
                 privateFrameGlobalRect: rect borderWidth: borderWidth color: borderColor
	"
	(VectorCanvas onForm: Display)
		privateFrameGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20
		color: Color red.
	Display forceToScreen
	"
	| bitBlt |
	bitBlt := BitBltCanvasEngine toForm: form.
	bitBlt clipRect: rect.
	bitBlt
		sourceForm: nil;
		combinationRule: (borderColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: borderColor;
		frameRect: rect borderWidth: borderWidth.! !
!VectorCanvas methodsFor: 'private-framework' stamp: 'jmv 4/16/2025 11:51:12' prior: 17000037 overrides: 16909856!
     privateFrameReverseGlobalRect: rect borderWidth: borderWidth
	"
	(VectorCanvas onForm: Display)
		privateFrameReverseGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	| bitBlt |
	bitBlt := BitBltCanvasEngine toForm: form.
	bitBlt clipRect: rect.
	bitBlt
		sourceForm: nil;
		fillColor: `Color gray: 0.5`;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth.! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 4/16/2025 11:43:10' prior: 16930104!
  prefFont

	^ #(
		#(defaultFontSize 18 SmallInteger defaultFontSize:)
		#(aaFontsColormapDepth 4)
		#(properDisplayAlphaForFonts false )	
		#(subPixelRenderColorFonts true )
		#(subPixelRenderFonts true )	
	)! !

VectorCanvas removeSelector: #drawString:from:to:atBaseline:font:color:!

!methodRemoval: VectorCanvas #drawString:from:to:atBaseline:font:color: stamp: 'Install-7231-VectorCanvas-Remove-auxBitBlt-JuanVuletich-2025Apr16-11h54m-jmv.001.cs.st 5/24/2025 10:43:26'!
drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: aTrueTypeFont color: aColor
	"Answer position to place next glyph"
	"
| s c f |
c := VectorCanvas onForm: Display.
c geometryTransformation: (AffineTransformation withRadians: 0.1).
f := FontFamily familyName: 'DejaVu Sans' pointSize: 72.
s := 'Latin text in VectorGraphics'.
(c drawString: s from: 1 to: s size atBaseline: 100@100 font: f color: Color black) print.
c strokeWidth: 1 color: Color red do: [ c moveTo: 100@100; lineTo: 1000@100 ].
Display forceToScreen
	"
	| p1 answer |
	"Don't waste any time if NOP"
	lastIndex = 0 ifTrue: [
		^nil ].

	currentTransformation isPureTranslation ifTrue: [
		(Preferences at: #cacheTrueTypeGlyphs) ifTrue: [
			p1 := currentTransformation transform: aPoint roundedHAFZ.
			p1 := p1 + (0@(0 - (aTrueTypeFont ascent + aTrueTypeFont lineGap-1))).
			p1 := p1 roundedHAFZ.
			answer := aString asUnicodeString drawOnBitBltCanvasEngine: auxBitBltEngine
				from: firstIndex to: lastIndex at: p1 font: aTrueTypeFont color: aColor.
			answer ifNotNil: [
				engine updateMorphBoundsLeft: p1 x top: p1 y
					right: answer x bottom: answer y ].
			^answer ]].

	^super drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: aTrueTypeFont color: aColor!

AbstractVectorCanvas subclass: #VectorCanvas
	instanceVariableNames: 'clippingSpecStack csi boundsFinderCanvas attachedCanvas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

!classDefinition: #VectorCanvas category: #'Morphic-Support' stamp: 'Install-7231-VectorCanvas-Remove-auxBitBlt-JuanVuletich-2025Apr16-11h54m-jmv.001.cs.st 5/24/2025 10:43:26'!
AbstractVectorCanvas subclass: #VectorCanvas
	instanceVariableNames: 'clippingSpecStack csi boundsFinderCanvas attachedCanvas'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7231-VectorCanvas-Remove-auxBitBlt-JuanVuletich-2025Apr16-11h54m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7141] on 22 April 2025 at 12:35:52 pm'!
!VectorEngineDrawer methodsFor: 'stroke & fill' stamp: 'jmv 4/21/2025 11:31:32' prior: 50387904!
                              basicStrokeWidth: aStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	| hopToUse |
	(aStrokeColor isNil or: [ aStrokeColor alpha = 0.0]) ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	(aFillColor isNil or: [ aFillColor alpha = 0.0]) ifTrue: [
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: false ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		canvas ifNotNil: [ canvas initForPath ].
		^ self basicStrokeWidth: aStrokeWidth color: aStrokeColor
			dashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0
			do: pathCommandsBlock ensureClosePath: true ].

	hopToUse := aStrokeWidth < 4
		ifTrue: [ 0.5 ] "See #experimentHopsPerPixel1"
		ifFalse: [ 0.9 ]. "See #experimentHopsPerPixel2."
				"Correct edgeCount for fills requires visiting at least once every y coordinate, hop can
				not be larger than 1. 0.9 gives a security margin for hop estimation in Bezier curves."
	self pvtStrokeWidth: aStrokeWidth hop: hopToUse.
	self pvtStrokeColor: aStrokeColor.
	self pvtFillColor: aFillColor.

	"Only used for strokes with no fill"
	self pvtDashedStrokeBits: 0 dashBitCount: 0 dashBitLength: 0.0 dashBitOffset: 0.

	self doPath: pathCommandsBlock ensureClosePath: true.! !
!VectorEngineSmalltalk methodsFor: 'primitive algorithms' stamp: 'jmv 4/21/2025 16:47:17' prior: 50384138!
     cubicBezierFromX: xFrom y: yFrom toX: xTo y: yTo control1X: xControl1 y: yControl1 control2X: xControl2 y: yControl2

	| p txFrom tyFrom txTo tyTo txControl1 tyControl1 txControl2 tyControl2 dx dy xMinEnd xMaxEnd yMinEnd yMaxEnd t oneLessT increment f2 f3 f1 f23 f4 x y t0 x0 y0 length correction |
	trajectoryLength := 0.0.
	needsFullAlphaCircle := true.
	
	p := geometryTransformation externalizePosition: xFrom@yFrom. txFrom := p x. tyFrom := p y.
	p := geometryTransformation externalizePosition: xTo@yTo. txTo := p x. tyTo := p y.
	p := geometryTransformation externalizePosition: xControl1@yControl1. txControl1 := p x. tyControl1 := p y.
	p := geometryTransformation externalizePosition: xControl2@yControl2. txControl2 := p x. tyControl2 := p y.

	"This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe."
	xMinEnd := txFrom min: txTo.
	xMaxEnd := txFrom max: txTo.
	yMinEnd := tyFrom min: tyTo.
	yMaxEnd := tyFrom max: tyTo.
	spanLeft := spanLeft min: (xMinEnd min: xMinEnd*0.25 + ((txControl1 min: txControl2)*0.75)).
	spanRight := spanRight max: (xMaxEnd max: xMaxEnd*0.25 + ((txControl1 max: txControl2)*0.75)).
	spanTop := spanTop min: (yMinEnd min: yMinEnd*0.25 + ((tyControl1 min: tyControl2)*0.75)).
	spanBottom := spanBottom max: (yMaxEnd max: yMaxEnd*0.25 + ((tyControl1 max: tyControl2)*0.75)).

	"Case t = 0.0"
	x := txFrom.
	y := tyFrom.
	self updateAlphasForX: x y: y.
	fillColor notNil ifTrue: [
		self updateEdgeCountAtX: x y: y ].
	self updateContourForX: x y: y.

	dx := (txTo-txFrom) abs.
	dy := (tyTo-tyFrom) abs.
	
	"Will be corrected for each hop. This, being close to pointFrom, is a good initial guess for first correction."
	increment := 0.5 / (dx max: dy) min: 0.5.
	t := 0.0.
	[
		t0 := t. x0 := x. y0 := y.
		"Compute next point"
		t := t0 + increment. oneLessT := 1.0 - t.
		f1 := oneLessT * oneLessT * oneLessT. f23 := 3.0 * oneLessT * t. f2 := f23 * oneLessT. f3 := f23 * t. f4 := t * t * t.
		x := (f1 * txFrom) + (f2 * txControl1) + (f3 * txControl2) + (f4 * txTo).
		y := (f1 * tyFrom) + (f2 * tyControl1) + (f3 * tyControl2) + (f4 * tyTo).
		"Now adjust the increment to aim at the required hop length, and recompute next point."
		length := ((x-x0)@(y-y0)) r.
		correction := hop / (length max: 0.1). "Don't grow increment too much in one step. More importantly, don't divide by zero under any circumstances."
		[
			increment := increment * correction.
			t := t0 + increment. oneLessT := 1.0 - t.
			f1 := oneLessT * oneLessT * oneLessT. f23 := 3.0 * oneLessT * t. f2 := f23 * oneLessT. f3 := f23 * t. f4 := t * t * t.
			x := (f1 * txFrom) + (f2 * txControl1) + (f3 * txControl2) + (f4 * txTo).
			y := (f1 * tyFrom) + (f2 * tyControl1) + (f3 * tyControl2) + (f4 * tyTo).
			length := ((x-x0)@(y-y0)) r.
			correction := hop / (length max: 0.1). "Don't grow increment too much in one step. More importantly, don't divide by zero under any circumstances."
			correction < 0.99]  whileTrue.		   "Keep adjusting if actual hop would be too big"
		t < 1.0 ]
	whileTrue: [
		self updateAlphasForX: x y: y.
		fillColor notNil ifTrue: [
			self updateEdgeCountAtX: x y: y ].
		self updateContourForX: x y: y ].

	"Case t= 1.0"
	self updateAlphasForX: txTo y: tyTo.
	fillColor notNil ifTrue: [
		self updateEdgeCountAtX: txTo y: tyTo ].
	self updateContourForX: txTo y: tyTo.! !
!VectorEngineSmalltalk methodsFor: 'primitive algorithms' stamp: 'jmv 4/21/2025 16:47:33' prior: 50388451!
                     quadraticBezierFromX: xFrom y: yFrom toX: xTo y: yTo controlX: xControl y: yControl

	| p txFrom tyFrom txTo tyTo txControl tyControl dx dy dx2 dy2 xMinEnd xMaxEnd yMinEnd yMaxEnd t oneLessT increment f2 f3 f1 x y t0 x0 y0 length correction |

	"If control point is bogus, just draw a line"
	(xControl = xTo and: [ yControl = yTo ]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].
	(xControl = xFrom and: [ yControl = yFrom ]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].
	
	trajectoryLength := 0.0.
	needsFullAlphaCircle := true.

	p := geometryTransformation externalizePosition: xFrom@yFrom. txFrom := p x. tyFrom := p y.
	p := geometryTransformation externalizePosition: xTo@yTo. txTo := p x. tyTo := p y.
	p := geometryTransformation externalizePosition: xControl@yControl. txControl := p x. tyControl := p y.

	dx := (txTo-txFrom) abs.
	dx2 := (txControl-txFrom) abs.
	dy := (tyTo-tyFrom) abs.
	dy2 := (tyControl-tyFrom) abs.

	"If almost a vertical line, just draw a line. (Ignoring control point)"
	(dx < 1.0 and: [dx2 < 1.0]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].

	"If almost an horizontal line, just draw a line. (Ignoring control point)"
	(dy < 1.0 and: [dy2 < 1.0]) ifTrue: [
		^self lineFromX: xFrom y: yFrom toX: xTo y: yTo ].

	"This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe."
	xMinEnd := txFrom min: txTo.
	xMaxEnd := txFrom max: txTo.
	yMinEnd := tyFrom min: tyTo.
	yMaxEnd := tyFrom max: tyTo.
	spanLeft := spanLeft min: (xMinEnd min: (xMinEnd+txControl) / 2.0).
	spanRight := spanRight max: (xMaxEnd max: (xMaxEnd+txControl) / 2.0).
	spanTop := spanTop min: (yMinEnd min: (yMinEnd+tyControl) / 2.0).
	spanBottom := spanBottom max: (yMaxEnd max: (yMaxEnd+tyControl) / 2.0).

	"Case t = 0.0"
	x := txFrom.
	y := tyFrom.
	self updateAlphasForX: x y: y.
	fillColor notNil ifTrue: [
		self updateEdgeCountAtX: x y: y ].
	self updateContourForX: x y: y.

	"Will be corrected for each hop. This, being close to pointFrom, is a good initial guess for first correction."
	increment := 0.5 / (dx max: dy) min: 0.5.
	t := 0.0.
	[
		t0 := t. x0 := x. y0 := y.
		"Compute next point"
		t := t0 + increment. oneLessT := 1.0 - t.
		f1 := oneLessT * oneLessT. f2 := 2.0 * oneLessT * t. f3 := t * t.
		x := (f1 * txFrom) + (f2 * txControl) + (f3 * txTo).
		y := (f1 * tyFrom) + (f2 * tyControl) + (f3 * tyTo).
		"Now adjust the increment to aim at the required hop length, and recompute next point."
		length := ((x-x0)@(y-y0)) r.
		correction := hop / (length max: 0.1). "Don't grow increment too much in one step. More importantly, don't divide by zero under any circumstances."
		[
			increment := increment * correction.
			t := t0 + increment. oneLessT := 1.0 - t.
			f1 := oneLessT * oneLessT. f2 := 2.0 * oneLessT * t. f3 := t * t.
			x := (f1 * txFrom) + (f2 * txControl) + (f3 * txTo).
			y := (f1 * tyFrom) + (f2 * tyControl) + (f3 * tyTo).
			length := ((x-x0)@(y-y0)) r.
			correction := hop / (length max: 0.1). "Don't grow increment too much in one step. More importantly, don't divide by zero under any circumstances."
			correction < 0.99]  whileTrue.		   "Keep adjusting if actual hop would be too big"
		t < 1.0 ]
	whileTrue: [
		self updateAlphasForX: x y: y.
		fillColor notNil ifTrue: [
			self updateEdgeCountAtX: x y: y ].
		self updateContourForX: x y: y ].

	"Case t= 1.0"
	self updateAlphasForX: txTo y: tyTo.
	fillColor notNil ifTrue: [
		self updateEdgeCountAtX: txTo y: tyTo ].
	self updateContourForX: txTo y: tyTo.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7232-VectorGraphicsEngine-Fixes-JuanVuletich-2025Apr22-12h35m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7145] on 23 April 2025 at 3:18:09 pm'!
!UnicodeString methodsFor: 'dispatch' stamp: 'jmv 4/23/2025 14:41:01'!
                               drawOnVectorEngine: engine from: startIndex to: stopIndex at: aPoint font: aTrueTypeFont color: color borderWidth: sw borderColor: sc

	| byteStartIndex byteStopIndex p answer d |
	byteStartIndex := self byteIndexAt: startIndex.
	byteStopIndex := (self byteIndexAt: stopIndex+1)-1.
	"Please keep consistent with #basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:"
	p := aTrueTypeFont isSuperscript
		ifTrue: [ aPoint x  @ (aPoint y - (aTrueTypeFont ascent*0.55)) ]
		ifFalse: [
			aTrueTypeFont isSubscript
				ifTrue: [aPoint x @ (aPoint y + (aTrueTypeFont ascent*0.3))]
				ifFalse: [ aPoint ]].
	answer := engine
		drawUtf8String: bytes
		fromByte: byteStartIndex toByte: byteStopIndex
		at: p
		trueTypeFont: aTrueTypeFont fontDescription
		color: color
		strokeWidth: sw strokeColor: sc
		scale: aTrueTypeFont pointSize
		preventMirroring: true.
	"Please keep consistent with #makeUnderlinedGlyph:"
	aTrueTypeFont isUnderlined ifTrue: [
		d := aTrueTypeFont descent *0.7.
		engine strokeWidth: 2 color: color do: [
			engine moveTo: p + (0@d); lineTo: answer + (0@d) ]].
	"Please keep consistent with #makeStruckThroughGlyph:"
	aTrueTypeFont isStruckThrough ifTrue: [
		d := aTrueTypeFont ascent * 0.25.
		engine strokeWidth: 1 color: color do: [
			engine moveTo: p - (0@d); lineTo: answer - (0@d) ]].
	^answer! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/23/2025 15:16:16'!
             drawString: s at: pt font: fontOrNil color: aColor borderWidth: sw borderColor: sc
	"Answer position to place next glyph
	Answer nil if nothing was done"

	^self drawString: s from: 1 to: s size at: pt font: (self fontToUse: fontOrNil) color: aColor borderWidth: sw borderColor: sc! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/23/2025 15:13:45'!
                        drawString: s atBaseline: pt font: fontOrNil color: aColor borderWidth: sw borderColor: sc
	"Answer position to place next glyph
	Answer nil if nothing was done"

	| font |
	font := self fontToUse: fontOrNil.
	^self drawString: s from: 1 to: s size atBaseline: pt font: font color: aColor borderWidth: sw borderColor: sc! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/23/2025 15:15:21'!
                 drawString: aString from: firstIndex to: lastIndex at: aPoint font: font color: aColor borderWidth: sw borderColor: sc
	"Eventually, convert all senders to the 'Baseline' protocol"

	^self drawString: aString from: firstIndex to: lastIndex
		atBaseline: aPoint + (0@(font ascent + font lineGap-1))
		font: font color: aColor
		borderWidth: sw borderColor: sc! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/23/2025 15:13:16'!
           drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: aTrueTypeFont color: aColor borderWidth: sw borderColor: sc
	"Ignore border if not supported"
	^self drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: aTrueTypeFont color: aColor! !
!AbstractVectorCanvas methodsFor: 'drawing - text' stamp: 'jmv 4/23/2025 14:43:34' overrides: 50393319!
                            drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: aTrueTypeFont color: aColor borderWidth: sw borderColor: sc
	"Answer position to place next glyph"
	"
| s c f |
c := VectorCanvas onForm: Display.
c geometryTransformation: (AffineTransformation withRadians: 0.1).
f := FontFamily familyName: 'DejaVu Sans' pointSize: 72.
s := 'Latin text in VectorGraphics'.
(c drawString: s from: 1 to: s size atBaseline: 100@100 font: f color: Color black) print.
c strokeWidth: 1 color: Color red do: [ c moveTo: 100@100; lineTo: 1000@100 ].
(c drawString: s from: 1 to: s size atBaseline: 100@180 font: f color: Color black borderWidth: 3 borderColor: Color red) print.
c strokeWidth: 1 color: Color black do: [ c moveTo: 100@180; lineTo: 1000@180 ].
Display forceToScreen
	"
	"Don't waste any time if NOP"
	lastIndex = 0 ifTrue: [
		^nil ].

	^ aString asUnicodeString drawOnVectorEngine: engine from: firstIndex to: lastIndex
		at: aPoint font: aTrueTypeFont color: aColor borderWidth: sw borderColor: sc.! !
!HybridCanvas methodsFor: 'drawing-text' stamp: 'jmv 4/23/2025 15:11:57' overrides: 50393319!
  drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: aTrueTypeFont color: aColor borderWidth: sw borderColor: sc

	^vectorCanvas drawString: aString from: firstIndex to: lastIndex atBaseline: aPoint font: aTrueTypeFont color: aColor borderWidth: sw borderColor: sc! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 4/23/2025 15:08:19' prior: 50392247!
                           drawUtf8String: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
	"
	| e f s byteStartIndex byteStopIndex |
	'-----Try all FOUR of them!!' print.
	Display fillColor: Color veryLightGray.
	e := VectorEngineWholePixel onForm: Display.
	e := VectorEngineSubPixel onForm: Display.
	e := VectorEngineWithPluginWholePixel onForm: Display.
	e := VectorEngineWithPluginSubPixel onForm: Display.
	f := 	FontFamily defaultFamilyAndPointSize fontDescription.
	s := 'Hello World!! This is TrueType text rasterization in VectorEngine.' asUnicodeString.
	byteStartIndex := s byteIndexAt: 1.
	byteStopIndex := (s byteIndexAt: s size+1)-1.
	[e drawUtf8String: s asUtf8Bytes fromByte: byteStartIndex toByte: byteStopIndex at: 10@150 trueTypeFont: f color: Color random scale: 130 preventMirroring: true] timeToRun print.
	[e drawUtf8String: s asUtf8Bytes fromByte: byteStartIndex toByte: byteStopIndex at: 10@300 trueTypeFont: f color: Color random strokeWidth: 2 strokeColor: Color black scale: 130 preventMirroring: true] timeToRun print.
	Display forceToScreen.
	"
	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := aPoint x asFloat. "If #fillColor:do: decides to evaluate this block more than once, set correct start x each time."
		nextGlyphX := self
			displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes ].
	^ nextGlyphX @ nextGlyphY.! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 4/23/2025 15:08:34' prior: 50391244!
 drawUtf8String: aByteArray fromByte: byteStartIndex toByte: byteStopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor strokeWidth: sw strokeColor: sc scale: scale preventMirroring: doPreventMirroring
	"Allows adding a colored border to text display.
	TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
	"
	| e f s byteStartIndex byteStopIndex |
	'-----Try all FOUR of them!!' print.
	Display fillColor: Color veryLightGray.
	e := VectorEngineWholePixel onForm: Display.
	e := VectorEngineSubPixel onForm: Display.
	e := VectorEngineWithPluginWholePixel onForm: Display.
	e := VectorEngineWithPluginSubPixel onForm: Display.
	f := 	FontFamily defaultFamilyAndPointSize fontDescription.
	s := 'Hello World!! This is TrueType text rasterization in VectorEngine.' asUnicodeString.
	byteStartIndex := s byteIndexAt: 1.
	byteStopIndex := (s byteIndexAt: s size+1)-1.
	[e drawUtf8String: s asUtf8Bytes fromByte: byteStartIndex toByte: byteStopIndex at: 10@150 trueTypeFont: f color: Color random scale: 130 preventMirroring: true] timeToRun print.
	[e drawUtf8String: s asUtf8Bytes fromByte: byteStartIndex toByte: byteStopIndex at: 10@300 trueTypeFont: f color: Color random strokeWidth: 2 strokeColor: Color black scale: 130 preventMirroring: true] timeToRun print.
	Display forceToScreen.
	"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale.
	sy := scale * trueTypeScale.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByUtf8.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self strokeWidth: sw color: sc fillColor: aColor do: [
		nextGlyphX := aPoint x asFloat. "If #strokeWidth:color:fillColor:do: decides to evaluate this block more than once, set correct start x each time."
		nextGlyphX := self
			displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes ].
	^ nextGlyphX @ nextGlyphY.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7233-BorderedText-JuanVuletich-2025Apr23-15h06m-jmv.002.cs.st----!

'From Cuis7.3 [latest update: #7146] on 24 April 2025 at 9:30:55 am'!
!VectorEngine methodsFor: 'private' stamp: 'jmv 4/24/2025 09:29:51' prior: 50391381!
              displayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours |
	nextGlyphX := destX.
	startIndex to: stopIndex do: [ :charIndex | | latin1Code i |
		latin1Code := (aString at: charIndex) codePoint.
		i := contourDataIndexes at: latin1Code + 1.
		i < 1 ifTrue: [ i := 1 ].
		advanceWidth := contourData at: i. i := i + 1.
		boundsLeft := contourData at: i. i := i + 1.
		boundsRight := contourData at: i. i := i + 1.
		boundsBottom := contourData at: i. i := i + 1.
		boundsTop := contourData at: i. i := i + 1.
		numContours := (contourData at: i) asInteger. i := i + 1.
		i := self glyphContours: numContours atx: nextGlyphX y: destY scalex: sx y: sy contourData: contourData i: i.
		nextGlyphX := nextGlyphX + (advanceWidth * sx) ].
	^nextGlyphX! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7234-ByteString-display-JuanVuletich-2025Apr24-09h29m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7147] on 24 April 2025 at 11:06:43 am'!

Object subclass: #TTFontDescription
	instanceVariableNames: 'folderName contourDataForUtf8 contourDataIndexesByUtf8 kernPairs copyright familyName fullName subfamilyName uniqueName versionName postscriptName trademark bounds unitsPerEm ascent descent lineGap letterMTopSideBearing contourDataIndexesByLatin1 '
	classVariableNames: 'Descriptions '
	poolDictionaries: ''
	category: 'Graphics-TrueType'!

!classDefinition: #TTFontDescription category: #'Graphics-TrueType' stamp: 'Install-7235-Latin1-FontDescription-JuanVuletich-2025Apr24-11h04m-jmv.001.cs.st 5/24/2025 10:43:26'!
Object subclass: #TTFontDescription
	instanceVariableNames: 'folderName contourDataForUtf8 contourDataIndexesByUtf8 kernPairs copyright familyName fullName subfamilyName uniqueName versionName postscriptName trademark bounds unitsPerEm ascent descent lineGap letterMTopSideBearing contourDataIndexesByLatin1'
	classVariableNames: 'Descriptions'
	poolDictionaries: ''
	category: 'Graphics-TrueType'!
!TTFontDescription methodsFor: 'accessing' stamp: 'jmv 4/24/2025 10:15:09'!
                contourDataIndexesByLatin1
	^contourDataIndexesByLatin1 ! !
!TTFontDescription methodsFor: 'private-initialization' stamp: 'jmv 4/24/2025 11:05:54' prior: 16973994!
                           glyphsByUtf8Bytes: glyphsByUTF8 unknownGlyph: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs

	| mGlyph |
	
	mGlyph := glyphsByUTF8 at: $M asciiValue + 1.
	letterMTopSideBearing := (mGlyph ifNil: [theUnknownGlyph]) topSideBearing.

	contourDataIndexesByUtf8 := (IntegerArray new: 256) as: OrderedCollection.
	contourDataForUtf8 := Float32Array streamContents: [ :stream |
		theUnknownGlyph addGlyphDataTo: stream tx: nil.		"First data is for unknownGlyph"	
		self fullName, ' - Processing glyph data' 
			displayProgressAt: 100@100
			from: 1 
			to: glyphsByUTF8 size 
			during: [ :bar |
				self appendGlyphDataTo: stream glyphsArray: glyphsByUTF8 indexes: contourDataIndexesByUtf8
					base: 0 bar: bar unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs ]].
	contourDataIndexesByUtf8 := contourDataIndexesByUtf8 as: IntegerArray.
	contourDataIndexesByLatin1 := (IntegerArray new: 256).
	0 to: 255 do: [ :cp | | i |
		Character
			evaluateOnce: [ :byte1 :byte2OrNil :byte3OrNil :byte4OrNil |
				i := contourDataIndexesByUtf8 at: byte1 + 1.
				byte2OrNil notNil ifTrue: [
					i := contourDataIndexesByUtf8 at: i negated + byte2OrNil + 1 ].
				contourDataIndexesByLatin1 at: cp+1 put: i ]
			withUtf8BytesOf: cp ].! !
!VectorEngine methodsFor: 'text and multi paths' stamp: 'jmv 4/24/2025 11:02:07' prior: 50392008!
                    drawByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try all FOUR of the,!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only in this example. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.' asByteString.
e drawByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale asFloat.
	sy := scale * trueTypeScale asFloat.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.	
	contourDataIndexes := aTTFontDescription contourDataIndexesByLatin1.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			displayByteString: aString from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes ].
	^ nextGlyphX @ nextGlyphY.! !
!VectorEngineWithPlugin methodsFor: 'text and multi paths' stamp: 'jmv 4/24/2025 11:02:17' prior: 50391664 overrides: 50393667!
                             drawByteString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aTTFontDescription color: aColor scale: scale preventMirroring: doPreventMirroring
	"TrueType assumes a Math like coordinate system (Y increasing upwards).
	But Display and Form Y coordinates in Cuis increase downwards, as it is done in most computer hardware and software.
	If doPreventMirroring is true, ensure that glyphs don't look mirrored, by having a negative y scale."
"
| e f s |
'Try all FOUR of the,!!'.
e := VectorEngineWholePixel onForm: Display.
e := VectorEngineSubPixel onForm: Display.
e := VectorEngineWithPluginWholePixel onForm: Display.
e := VectorEngineWithPluginSubPixel onForm: Display.
f := 	FontFamily defaultFamilyAndPointSize fontDescription.
s := 'Hello World!! (Ascii Only in this example. Latin-1 requires an additional single byte table in the Font, that Cuis does not include.' asByteString.
e drawByteString: s from: 1 to: s size at: 10@120 trueTypeFont: f color: Color black scale: 30 preventMirroring: true.
Display forceToScreen.
"

	| nextGlyphX nextGlyphY sx sy contourData contourDataIndexes trueTypeScale |
	trueTypeScale := 1.0 / aTTFontDescription letterMTopSideBearing.	"Perhaps measures in TTFontDescription should be normalized"
	sx := scale * trueTypeScale asFloat.
	sy := scale * trueTypeScale asFloat.
	(doPreventMirroring and: [ geometryTransformation doesMirror not ]) ifTrue: [ sy := sy negated ].
	contourData := aTTFontDescription contourDataForUtf8.
	contourDataIndexes := aTTFontDescription contourDataIndexesByLatin1.
	nextGlyphX := aPoint x asFloat.
	nextGlyphY := aPoint y asFloat.
	self fillColor: aColor do: [
		nextGlyphX := self
			primDisplayByteString: aString from: startIndex to: stopIndex
			atx: nextGlyphX y: nextGlyphY
			scalex: sx y: sy
			contourData: contourData
			contourDataIndexes: contourDataIndexes ].
	^ nextGlyphX @ nextGlyphY.! !

Object subclass: #TTFontDescription
	instanceVariableNames: 'folderName contourDataForUtf8 contourDataIndexesByUtf8 contourDataIndexesByLatin1 kernPairs copyright familyName fullName subfamilyName uniqueName versionName postscriptName trademark bounds unitsPerEm ascent descent lineGap letterMTopSideBearing'
	classVariableNames: 'Descriptions'
	poolDictionaries: ''
	category: 'Graphics-TrueType'!

!classDefinition: #TTFontDescription category: #'Graphics-TrueType' stamp: 'Install-7235-Latin1-FontDescription-JuanVuletich-2025Apr24-11h04m-jmv.001.cs.st 5/24/2025 10:43:27'!
Object subclass: #TTFontDescription
	instanceVariableNames: 'folderName contourDataForUtf8 contourDataIndexesByUtf8 contourDataIndexesByLatin1 kernPairs copyright familyName fullName subfamilyName uniqueName versionName postscriptName trademark bounds unitsPerEm ascent descent lineGap letterMTopSideBearing'
	classVariableNames: 'Descriptions'
	poolDictionaries: ''
	category: 'Graphics-TrueType'!

VectorCanvas initialize!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	TrueTypeFontFamily readAllTrueTypeFontsIn: DirectoryEntry trueTypeFontsDirectory / 'DejaVu' / 'DejaVuSans'
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7235-Latin1-FontDescription-JuanVuletich-2025Apr24-11h04m-jmv.001.cs.st----!

----QUIT----(24 May 2025 10:43:34) Cuis7.3-7235.image priorSource: 1270065!

----STARTUP---- (24 May 2025 10:46:14) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.3-7235.image!


----QUIT----(24 May 2025 10:46:18) Cuis7.3-7235.001.image priorSource: 1990106!