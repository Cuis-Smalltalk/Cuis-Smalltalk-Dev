'From Cuis7.4 [latest update: #7257] on 30 May 2025 at 6:32:36 pm'!


----SNAPSHOT----(30 May 2025 18:32:36) Cuis7.4.image priorSource: 0!

Preferences at: #saveReleaseOptionsInWorldMenu put: true!

----QUIT----(30 May 2025 18:33:31) Cuis7.5-7257.image priorSource: 68!

----STARTUP---- (15 July 2025 11:02:08) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.5-7257.image!


'From Cuis7.5 [latest update: #7257] on 2 June 2025 at 2:40:50 pm'!
!WeakSet commentStamp: '<historical>' prior: 17016074!
                  An implementation of WeakSet that gives good performance for large instances.

It is implemented as a two level hash table. The outer level is a closed hash table, and is accessed using the higher bits of each element's hash value. At each position a Bucket is stored.

The lower bits of the hash are used to acess each Bucket. The buckets for an open hash table. Each bucket has a fixed size for direct access using the hash, and after it, a variable size area to store elements with duplicated (partial) hashes.

Currently, the Buckets use 8 positions for O(1) direct access using the lower 3 bits of the hash. The iterable part after it can grow as needed.

Buckets are WeakArrays.

The idea for small WeakArrays as buckets is from a previous SymbolSet by Andrés Valloud.
The idea of buckets having a direct access part, and an variable sized overflow part for (partial) hash collisions is from Juan Vuletich, specific for this class.

Note: An implementations using these ideas, could be good for Set et al.
Note: Perhaps a three level table, with a fixed size outer level, and where the mid level arrays grow as needed, could further improve performance for very large collections.!
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 6/2/2025 14:07:59'!
               recreateObsoleteClassesCollection
	"
	Behavior recreateObsoleteClassesCollection
	"
	ObsoleteSubclasses := nil.
	Smalltalk garbageCollect.
	Smalltalk allObjectsDo: [ :cl |
		(cl isBehavior and: [cl isObsolete]) ifTrue: [
			ObsoleteSubclasses ifNil: [
				ObsoleteSubclasses := WeakIdentitySet new ].
			ObsoleteSubclasses add: cl]].! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 6/2/2025 13:25:19' prior: 16789725!
                   addObsoleteSubclass: aClass
	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"

	ObsoleteSubclasses ifNil: [
		ObsoleteSubclasses := WeakIdentitySet new ].
	ObsoleteSubclasses add: aClass.! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 6/2/2025 13:25:44' prior: 16789741!
     obsoleteSubclasses
	"Return all the weakly remembered obsolete subclasses of the receiver.
	Clean out the already collected ones."

	ObsoleteSubclasses ifNil: [
		^#() ].
	^ObsoleteSubclasses select: [ :any |
		any superclass == self ].! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 6/2/2025 13:30:18' prior: 16789776!
                    removeObsoleteSubclass: aClass
	"Remove aClass from the weakly remembered obsolete subclasses."

	ObsoleteSubclasses ifNil: [
		^ self ].
	ObsoleteSubclasses remove: aClass ifAbsent: [].! !
!WeakSet class methodsFor: '[mkSymbol] instance creation' stamp: 'jmv 6/2/2025 14:38:40' prior: 17016625!
                        newWithRoomForMoreThan: nElements
	"Create a Set large enough to hold nElements without growing
	WeakSet newWithRoomForMoreThan: 31
	WeakSet newWithRoomForMoreThan: 32
	"

	| answer |
	answer := self basicNew.
	answer init: (2 raisedToInteger: (nElements // answer bucketDesiredMeanOccupation max: 1) highBit -1).
	^answer! !

Metaclass removeSelector: #replaceObsoleteInstanceWith:!

!methodRemoval: Metaclass #replaceObsoleteInstanceWith: stamp: 'Install-7258-ObsoleteClasses-simplify-JuanVuletich-2025Jun02-14h26m-jmv.001.cs.st 7/15/2025 11:02:08'!
replaceObsoleteInstanceWith: newInstance
	thisClass class == self ifTrue:[^self error:'I am fine, thanks'].
	newInstance class == self ifFalse:[^self error:'Not an instance of me'].
	thisClass := newInstance.!

Behavior removeSelector: #removeAllObsoleteSubclasses!

!methodRemoval: Behavior #removeAllObsoleteSubclasses stamp: 'Install-7258-ObsoleteClasses-simplify-JuanVuletich-2025Jun02-14h26m-jmv.001.cs.st 7/15/2025 11:02:08'!
removeAllObsoleteSubclasses
	"Remove all the obsolete subclasses of the receiver"
	ObsoleteSubclasses ifNotNil: [
		ObsoleteSubclasses removeKey: self ifAbsent: nil ]!

Behavior removeSelector: #recreateObsoleteSubclassesCollection!

!methodRemoval: Behavior #recreateObsoleteSubclassesCollection stamp: 'Install-7258-ObsoleteClasses-simplify-JuanVuletich-2025Jun02-14h26m-jmv.001.cs.st 7/15/2025 11:02:08'!
recreateObsoleteSubclassesCollection
	"
	Behavior recreateObsoleteSubclassesCollection
	"
	| newOne |
	newOne := EphemeronIdentityDictionary new.
	ObsoleteSubclasses ifNotNil:
		[:oldOne|
		oldOne keysAndValuesDo:
			[ :k :v | newOne at: k put: v ] ].
	ObsoleteSubclasses := newOne.!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	Behavior recreateObsoleteClassesCollection!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7258-ObsoleteClasses-simplify-JuanVuletich-2025Jun02-14h26m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7258] on 2 June 2025 at 4:51:09 pm'!
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 6/2/2025 16:50:18'!
                      noButtonShape
	"Draw only the icon and or label, with no button shape"
	roundButtonStyle := #none.
	self redrawNeeded.! !

PluggableButtonMorph removeSelector: #iconOnly:!

!methodRemoval: PluggableButtonMorph #iconOnly: stamp: 'Install-7259-PluggableButtonMorph-noButtonShape-JuanVuletich-2025Jun02-16h49m-jmv.001.cs.st 7/15/2025 11:02:08'!
iconOnly: aForm
	"Draw only the icon, with no button shape or mouse over indication"
	icon := aForm.
	magnifiedIcon := nil.
	roundButtonStyle := #none.
	self redrawNeeded.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7259-PluggableButtonMorph-noButtonShape-JuanVuletich-2025Jun02-16h49m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7259] on 5 June 2025 at 11:11:13 am'!
!Morph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:46:20'!
       defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	Please make them natural numbers.
	See implementors."

	^100! !
!HaloMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:46:26' overrides: 50331849!
        defaultLayerNumber
	^ 20! !
!HoverHelpMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:46:45' overrides: 50331849!
        defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be on top."

	^10! !
!ProgressMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 11:00:48' overrides: 50331849!
    defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^10! !
!StringRequestMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:46:48' overrides: 50331849!
                        defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be above regular morphs."

	^30! !
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:58:40' overrides: 50331849!
                          defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^20! !
!AutoCompleterMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:47:03' overrides: 50331849!
                        defaultLayerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^20! !
!Morph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:48:36' prior: 16910428!
         layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	See #defaultLayerNumber."

	^self
		valueOfProperty: #layerNumber
		ifAbsent: [self defaultLayerNumber]! !
!Morph methodsFor: 'private' stamp: 'jmv 6/5/2025 10:42:19' prior: 16914633!
              privateFixLayerOrder
	"Ensure that morphs with smaller #layerNumber are above morphs with larger #layerNumber.
	Keep current sorting inside each set with same #layerNumber."

	| layerNumbers sortedSubmorphs newIndex |
	self honorsLayerOrder ifFalse: [ ^self ].
	submorphs size < 2 ifTrue: [ ^self ].
	layerNumbers := Set new.
	submorphs do: [ :m | layerNumbers add: m layerNumber ].
	layerNumbers := layerNumbers asArray sort.
	sortedSubmorphs := Array new: submorphs size.
	newIndex := 1.
	layerNumbers do: [ :layerNumber |
		submorphs withIndexDo: [ :m :i |
			m layerNumber = layerNumber ifTrue: [
				sortedSubmorphs at: newIndex put: m.
				newIndex = i ifFalse: [ m invalidateBounds ].
				newIndex := newIndex + 1 ]]].
	submorphs := sortedSubmorphs.! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 6/5/2025 11:00:51' prior: 16940092 overrides: 16896737!
                        initialize
	super initialize.
	self separation: 0.
	labelMorph := LabelMorph contents: '' font: FontFamily defaultFamilyAndPointSize.
	subLabelMorph := LabelMorph contents: '' font: FontFamily defaultFamilyAndPointSize.
	progress := ProgressBarMorph new.
	progress morphExtent: 200 @ FontFamily defaultLineSpacing.
	self addMorphFront: labelMorph.
	self addMorphFront: subLabelMorph.
	self addMorph: progress fixedHeight: FontFamily defaultLineSpacing.! !
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 6/5/2025 10:59:39' prior: 16900367!
     stayUp: aBoolean

	stayUp := aBoolean.
	aBoolean ifTrue: [ self removeStayUpBox ].
	self taskbar ifNotNil: [ :tb | tb refreshTaskbarFor: self ].! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 6/5/2025 10:35:38' prior: 16980057!
                           addWindowControlTo: aMenu

	aMenu
		add: 'send to back' 				action: #sendToBack 				icon: #goBottomIcon;
		add: 'make next-to-topmost' 	action: #makeSecondTopmost 		icon: #goUpIcon;
		addLine;
		add: (self isSticky ifTrue: [ 'make draggable' ] ifFalse: [ 'make undraggable' ])
										action: #toggleStickiness 			icon: (self isSticky ifFalse: [#pushPinIcon]);
		addLine;
		add: 'close' 						action: #delete 						icon: #closeIcon;
		add: 'collapse' 					action: #collapse 					icon: #collapseIcon;
		add: 'expand / contract' 			action: #expandBoxHit 				icon: #expandIcon;
		addLine;
		add: 'resize...' 					action: #resize.
		
	^aMenu! !

AutoCompleterMorph removeSelector: #layerNumber!

!methodRemoval: AutoCompleterMorph #layerNumber stamp: 'Install-7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st 7/15/2025 11:02:08'!
layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^20!

MenuMorph removeSelector: #layerNumber!

!methodRemoval: MenuMorph #layerNumber stamp: 'Install-7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st 7/15/2025 11:02:08'!
layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	stayUp ifTrue: [ ^super layerNumber ].
	^20!

StringRequestMorph removeSelector: #layerNumber!

!methodRemoval: StringRequestMorph #layerNumber stamp: 'Install-7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st 7/15/2025 11:02:08'!
layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be above regular morphs."

	^30!

HoverHelpMorph removeSelector: #layerNumber!

!methodRemoval: HoverHelpMorph #layerNumber stamp: 'Install-7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st 7/15/2025 11:02:08'!
layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be on top."

	^10!

HaloMorph removeSelector: #layerNumber!

!methodRemoval: HaloMorph #layerNumber stamp: 'Install-7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st 7/15/2025 11:02:08'!
layerNumber
	^ 10!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7260-defautLayerNumber-JuanVuletich-2025Jun05-11h09m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7259] on 5 June 2025 at 11:06:45 am'!
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 6/5/2025 11:06:02' prior: 16914012!
                           comeToFront

	"Restore default #layerNumber for us.
	We may still end behind other 'more topMost' morphs."
	self removeProperty: #layerNumber.
	self atFront ifFalse: [owner privateMoveFrontMorph: self]! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 6/5/2025 11:06:36' prior: 16914043!
                         goBehind
	| regularLayerNumber |
	"Set our #layerNumber to the default for most morphs, allowing us
	to go behind them."
	regularLayerNumber  := 100.
	self layerNumber = regularLayerNumber ifFalse: [
		self setProperty: #layerNumber toValue: regularLayerNumber ].
	owner privateMoveBackMorph: self.
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7261-goBehind-despiteLayerNumber-JuanVuletich-2025Jun05-11h01m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7261] on 5 June 2025 at 12:00:20 pm'!
!MenuMorph methodsFor: 'construction' stamp: 'jmv 6/5/2025 11:57:45' prior: 16900676!
           addStayUpIcons
	| closeButton pinButton w buttonHW |
	(Preferences at: #optionalButtons) ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	buttonHW := Theme current titleBarButtonsExtent x.
	closeButton := PluggableButtonMorph model: self action: #delete.
	closeButton iconDrawSelector: #drawCloseIcon; noButtonShape.
	pinButton := PluggableButtonMorph model: self action: #stayUp.
	pinButton iconDrawSelector: #drawPushPinIcon; noButtonShape.
	w := (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + (buttonHW*2).
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: buttonHW * 12 // 10);
			color: `Color transparent`;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//10;
			addMorph: (closeButton layoutSpec: (LayoutSpec fixedWidth: buttonHW fixedHeight: buttonHW));
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: pinButton fixedWidth: buttonHW;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//3).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7262-MenuStayUpButtonTweak-JuanVuletich-2025Jun05-11h57m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7262] on 9 June 2025 at 9:38:08 am'!
!ChangeSorterWindow methodsFor: 'menu commands' stamp: 'NPM 6/9/2025 09:23:31'!
      trimHistory
	
	(self confirm: self trimHistoryConfirmationMessage)
		ifFalse: [ ^ self ].
	
	model trimHistory
	
	! !
!ChangeSorterWindow methodsFor: 'menu commands' stamp: 'NPM 6/9/2025 09:23:19'!
                          trimHistoryConfirmationMessage
	
	^ String streamContents: [ :confirmationMessage |
		confirmationMessage
			nextPutAll: 'You are about to permanently remove non-essential history,';
			newLine;
			nextPutAll: 'including methods that were added and then removed,';
			newLine;
			nextPutAll: 'as well as renames and reorganizations of newly added classes.';
			newLine;
			newLine;
			nextPutAll: 'This action cannot be undone.';
			newLine;
			newLine;
			nextPutAll: 'Do you want to continue?'
		]! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'NPM 6/9/2025 09:28:00' prior: 16809899!
              trimHistory
	"Drop non-essential history (rename, reorg, method removals) from newly-added classes."

	myChangeSet trimHistory.
	
	self showChangeSet: myChangeSet

! !
!ChangeSorterWindow methodsFor: 'menu & kbd shortcuts' stamp: 'NPM 6/9/2025 09:35:33' prior: 16810351!
                 changeSetListMenuSpec
	"Spec for the menu and shortcut keys for the changesets list.
	See coment at Morph >> #getMenu
	"
	| answer |
	answer := #(
			#(0 		'Change Set' 						true)
			#(10 		'File out, start a new cs (o)' 			$o 	model 		fileOutAndRemove 				fileOutIcon)
			#(20 		'File out, keep current cs (k)' 			$k 	model 		fileOutAndKeep 				fileOutIcon)
			#(30 		'-----')
			#(40 		'Rename change set (R)' 				$R 	model 		rename 						saveAsIcon)
			#(50 		'Destroy change set (x)' 			 	$x 	model 		remove 						warningIcon)
	).
	model currentCanHavePreambleAndPostscript ifTrue: [
		model currentHasPreamble
			ifTrue: [ answer  := answer, #(
				#(60 	'-----')
				#(70 	'Edit preamble (p)' 					$p 	model 		addPreamble 					textEditorIcon)
				#(80 	'Remove preamble' 					nil 	model 		removePreamble 				listRemoveIcon)) ]
			ifFalse: [ answer  := answer, #(
				#(60 	'-----')
				#(70 	'Add preamble (p)' 					$p 	model 		addPreamble 					listAddIcon) )].
		model currentHasPostscript
			ifTrue: [ answer  := answer, #(
				#(90 	'Edit postscript...' 					nil 	model 		editPostscript 					textEditorIcon)
				#(100 	'Remove postscript' 					nil 	model 		removePostscript 				listRemoveIcon)) ]
			ifFalse: [ answer  := answer, #(
				#(90 	'Add postscript...' 					nil 	model 		editPostscript 					listAddIcon) )].
	].

	answer  := answer, #(
		#(110 			'-----')
		#(120 			'Conflicts with other change sets' 		nil 	window		browseMethodConflicts 		emblemImportantIcon
			'Browse all methods that occur both in this change set and in at least one other change set.')
		#(130 			'-----')
		#(140 			'Trim history' 						nil 	window		trimHistory 					clockIcon
			'Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.
 NOTE: can cause confusion if later filed in over an earlier version of these changes.')
		#(150 			'View affected class categories' 		nil 	model 		viewAffectedClassCategories	packageIcon
			'Show class categories affected by any contained change')
	).
	model csIsForBase ifFalse: [ "Maybe disable a few: Copy them the same as above, but without selector."
		answer := answer, #(
			#(40 		'Rename change set (R)' 				$R 	model 		nil 								saveAsIcon)
			#(50 		'Destroy change set (x)' 		 		$x 	model 		nil 								warningIcon)) ].
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7263-ChangeSet-trimHistory-tweaks-NicolasPapagnaMaldonado-2025Jun09-09h09m-NPM.001.cs.st----!

'From Cuis7.5 [latest update: #7263] on 13 June 2025 at 10:12:24 am'!

ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize nodeVisitedCounter methodNode selectionToKeep uniqueNodeVisitedCounter '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!classDefinition: #EquivalentNodesFinder category: #'Compiler-Support' stamp: 'Install-7264-FindsRepeatedBlocks-HernanWilkinson-2025Jun12-14h25m-HAW.001.cs.st 7/15/2025 11:02:08'!
ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize nodeVisitedCounter methodNode selectionToKeep uniqueNodeVisitedCounter'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!
!EquivalentNodesFinder methodsFor: 'private - visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860204!
                            completeSourceRangeOf: aNode

	| sourceRangeIndex completeSourceRanges completeRange trimmedRange |
	
	sourceRangeIndex := uniqueNodeVisitedCounter occurrencesOf: aNode.
	sourceRangeIndex = 0 ifTrue: [ sourceRangeIndex := 1 ].
	
	"It should always find the completeSourceRanges of aNode and a range at the sourceRangeIndex - Hernan"
	completeSourceRanges := methodNode completeSourceRanges at: aNode.
	completeRange := completeSourceRanges at: sourceRangeIndex.
	
	"See ExtractMethodFinderTest>>test27FindsInsideParentesis - Hernan"
	trimmedRange := nodesToLookForSize = 1 
		ifTrue: [ completeRange trimToMatchExpressionOn: methodNode sourceText ]
		ifFalse: [ completeRange ].
	
	^trimmedRange! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 10:00:04' prior: 16860298 overrides: 16927072!
                  visitBlockNode: blockNode

	| blockStatements |

	self addToEquivalentsIfOneStatementEquivalentTo: blockNode.

	super visitBlockNode: blockNode.
	
	nodesToLookForSize > 1 ifTrue: [ 
		blockStatements := blockNode statements. 
		"I need to add temp declaration to statements becuase user could have selected the temp declaration
		See ExtractMethodFinderTest>>test22FindsTemporaryWhenSelectingDefinitionInInnerClosure - Hernan"
		blockNode declaresAnyVariable ifTrue: [ blockStatements addFirst: blockNode temporariesDeclaration ].
		self addEquivalentNodesOf: blockStatements ]
		! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860317 overrides: 16927080!
     visitBraceNode: aBraceNode 
	
	uniqueNodeVisitedCounter add: aBraceNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aBraceNode.
	
	^super visitBraceNode: aBraceNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860332 overrides: 16927093!
                           visitInstanceVariableNode: anInstanceVariableNode 

	uniqueNodeVisitedCounter add: anInstanceVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: anInstanceVariableNode.

	^super visitInstanceVariableNode: anInstanceVariableNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860343 overrides: 16927097!
                       visitLiteralNode: aLiteralNode

	uniqueNodeVisitedCounter add: aLiteralNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aLiteralNode.

	^super visitLiteralNode: aLiteralNode! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860352 overrides: 16927101!
                   visitLiteralVariableNode: aLiteralVariableNode 
	
	uniqueNodeVisitedCounter add: aLiteralVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aLiteralVariableNode.
	
	^super visitLiteralVariableNode: aLiteralVariableNode ! !
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860369 overrides: 16927147!
                               visitTempVariableNode: aTempVariableNode 
	
	uniqueNodeVisitedCounter add: aTempVariableNode.
	
	self addToEquivalentsIfOneStatementEquivalentTo: aTempVariableNode.
	
	^super visitTempVariableNode: aTempVariableNode ! !
!EquivalentNodesFinder methodsFor: 'initialization' stamp: 'HAW 6/13/2025 09:58:24' prior: 16860379!
                               initializeFor: aNodesToLookFor in: aMethodNode keepingSelection: aSelectionToKeep

	nodesToLookFor := aNodesToLookFor.
	methodNode := aMethodNode.
	selectionToKeep := aSelectionToKeep.
	
	nodesToLookForSize := nodesToLookFor size.
	uniqueNodeVisitedCounter := IdentityBag new.
	equivalentNodesRanges := OrderedCollection new.
	! !

ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize uniqueNodeVisitedCounter methodNode selectionToKeep'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

!classDefinition: #EquivalentNodesFinder category: #'Compiler-Support' stamp: 'Install-7264-FindsRepeatedBlocks-HernanWilkinson-2025Jun12-14h25m-HAW.001.cs.st 7/15/2025 11:02:08'!
ParseNodeVisitor subclass: #EquivalentNodesFinder
	instanceVariableNames: 'nodesToLookFor equivalentNodesRanges nodesToLookForSize uniqueNodeVisitedCounter methodNode selectionToKeep'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Compiler-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7264-FindsRepeatedBlocks-HernanWilkinson-2025Jun12-14h25m-HAW.001.cs.st----!

'From Cuis7.5 [latest update: #7263] on 13 June 2025 at 11:46:57 am'!
!ChangeList class methodsFor: 'public access' stamp: 'jmv 6/13/2025 11:45:20' prior: 16805317!
          browsePackageContents: aFileEntry
	"Opens a changeList on a fileStream"
	| changeList packageFile |
	packageFile := CodePackageFile onFileEntry: aFileEntry.
	changeList := aFileEntry readStreamDo: [ :stream |
		self new scanFile: stream from: 0 to: stream size ].
	"Add deletions of methods and classes that are in the CodePackage (i.e., active in the system)
	but are no longer in the CodePackageFile being viewed."
	packageFile methodsToRemove do: [ :methodReference |
		changeList
			addItem: (MethodDeletionChangeRecord new
				methodReference: methodReference;
				doItOnlyIfInBaseSystem: false)
			text: 'method no longer in package: ', methodReference stringVersion ].
	packageFile classesToRemove do: [ :clsName |
		changeList
			addItem: (ClassDeletionChangeRecord new
				className: clsName;
				doItOnlyIfInBaseSystem: false)
			text: 'class no longer in package: ', clsName ].
	changeList clearSelections.
	ChangeListWindow open: changeList label: aFileEntry name! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7265-browsePackageContents-fix-JuanVuletich-2025Jun13-11h37m-jmv.001.cs.st----!

'From Cuis7.3 [latest update: #7246] on 26 May 2025 at 4:16:40 pm'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
FontFamily releaseClassCachedState!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7266-ReleaseFontCache-afterTroublesomeFirstProgressUpdate-JuanVuletich-2025May26-16h16m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7263] on 9 June 2025 at 4:41:03 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7267-InstructionStream-cleanup-JuanVuletich-2025Jun09-16h38m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7267] on 17 June 2025 at 5:18:17 pm'!
!Object methodsFor: 'user interface' stamp: 'len 5/20/2020 04:00:44' prior: 16923457!
                         request: queryString do: acceptBlock
	"Non-modal. Method returns immediately.
	Uses acceptBlock to process user's answer later, when provided by them."
	^ self request: queryString initialAnswer: '' verifying: [:aString| true] do: acceptBlock orCancel: [nil]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:57' prior: 16856550 overrides: 16802555!
                         instVarReadScanBlockFor: varIndexCode using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of the inst var with zero-relative index varIndexCode.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"	0-15	0000 i i i i 				Push Receiver Variable #iiii
	*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b < 16 and: [b = varIndexCode])
	    or: [b = 226
			and: [scanner followingByte + prevext = varIndexCode]]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'eem 5/18/2014 18:59' prior: 16856577 overrides: 16802568!
       instVarWriteScanBlockFor: varIndexCode using: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for writes of the inst var with zero-relative index varIndexCode.
	 N.B. Don't assume the compiler uses the most compact encoding available."

	"	200-207	11001 iii					Pop and Store Receiver Variable #iii
	*	224			11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	240			11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)
	*	243			11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b| | prevext |
	   prevext := extension.
	   extension := b = 224 ifTrue: [scanner followingByte bitShift: 8] ifFalse: [0].
	   (b >= 200
	    and: [b < 208
	    and: [b - 200 = varIndexCode]])
	   or: [(b = 240 or: [b = 243])
		  and: [scanner followingByte + prevext = varIndexCode]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7268-FormattingTweaks-JuanVuletich-2025Jun17-17h16m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7268] on 17 June 2025 at 5:19:13 pm'!
!DataStream class methodsFor: '[mkObjectSerialization] cached state access' stamp: 'jmv 6/17/2025 16:24:25' prior: 16842455!
                       initCachedState
	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  #nextPut: writes these IDs to the data stream.
	NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  
	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)
	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"
	"
	DataStream initCachedState
	"
	| t |
	t := TypeMap := Dictionary newWithRoomForMoreThan: 80. "sparse for fast hashing"

	t at: #UndefinedObject put: 1.
	t at: #True put: 2.
	t at: #False put: 3.
	t at: #SmallInteger put: 4.
	"(type ID 5 was for Squeak's old String format)"
	t at: #Symbol put: 6.
	t at: #ByteArray put: 7.
	t at: #Array put: 8.
	"(type ID 9 is for arbitrary instances of any class. See #typeIDFor: See #writeInstance: See #readInstance)"
	"(type ID 10 is for references, See ReferenceStream>>tryToPutReference:typeID:)"
	t at: #Bitmap put: 11.
	t at: #Metaclass put: 12.
	"Type ID 13 was for Squeak's  HyperSqueak User classes."
	t at: #Float put: 14.
	t at: #BoxedFloat64 put: 14.
	t at: #SmallFloat64 put: 14.
	"(type ID 15 was for Squeak's old Deprecated compact Rects."
	"type ID 16 is an instance with short header.  See #beginInstance:size:"
	t at: #String put: 17.	"'new' String format, 1 or 4 bytes of length"
	t at: #WordArray put: 18.
	"type ID 19 was for Squeak's Word Array for Segment."
	"For all classes that are like WordArrays, store them as bits, and able to change endianness."
	Smalltalk do: [:cls |
		cls isBehavior ifTrue: [
			cls isPointers not & cls isVariable & cls isWords ifTrue: [
				(t includesKey: cls name) ifFalse: [
					t at: cls name put: 20 ]]]].
	t at: #CompiledMethod put: 21.	"special creation method"
	t at: #Character put: 22.
	t at: #UnicodeString put: 23.
	t at: #UnicodeSymbol put: 24.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7269-RemoveSlip-JuanVuletich-2025Jun17-17h18m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7268] on 17 June 2025 at 5:20:33 pm'!
!EncoderForSistaV1 commentStamp: 'eem 12/22/2024 19:07' prior: 16854876!
                           EncoderForSistaV1 encodes a bytecode set for Smalltalk that lifts limits on the number of literals, branch distances, the number of temporary variables, and provides extended push integer and push character bytecodes.  The bytecode set also supports creating FullBlockClosures, closures whose method is separate from their home method's.  Bytecodes are ordered by length to make decoding easier.  Bytecodes marked with an * are extensible via a prefix extension bytecode.

N.B.  Extension bytecodes can only come before extensible bytecodes, and only if valid (one cannot extend a bytecode extensible by Ext A with an Ext B).  An extensible bytecode consumes (and zeros) its extension(s).  Hence the hidden implicit variables holding extensions are always zero except after a valid sequence of extension bytecodes.  The implication is that a bytecode interpreter should maintain the extension values in static variables initialized to zero at start-up, and live only from the start of a sequence of extension bytecodes to the end of the extended bytecode immediately following.

While the bytecode set lifts limits, it still assumes there are no more than 65535 literals (as of 2020 the CompiledCode header word imposes a 32,767 limit on number of literals), and no more than 256 stack slots (used for arguments, temporaries, and stack contents) in a Context.

EncoderForSistaV1 also includes an extended set of bytecodes for Sista, the Speculative Inlining Smalltalk Architecture, a project by Clément Bera and Eliot Miranda.  Scorch is an optimizer that exists in the Smalltalk image, /not/ in the VM,  and optimizes by substituting normal bytecoded methods by optimized bytecoded methods that may use special bytecodes for which the Cogit can generate faster code.  These bytecodes eliminate overheads such as bounds checks or polymorphic code (indexing Array, ByteArray, String etc).  But the bulk of the optimization performed is in inlining blocks and sends for the common path.  This bytecode set therefore differs from a normal Smalltalk set in providing a set of inlined primitives that do not validate their arguments that the compiler generates only when it can prove that the primitives' arguments are valid.

The basic scheme is that the Cogit generates code containing performance counters.  When these counters trip, a callback into the image is performed, at which point Scorch analyses some portion of the stack, looking at performance data for the methods on the stack, and optimises based on the stack and performance data.  Execution then resumes in the optimized code.

The Sista Cogit (e.g. SistaStackToRegisterMappingCogit) adds counters to conditional branches.  Each branch has an executed and a taken count.  On execution the executed count is decremented and if the count goes below zero the VM sends a message at a special index in the specialObjectsArray (as of writing, conditionalCounterTrippedOn:).  Then if the branch is taken the taken count is decremented.  The two counter values allow the Sista optimizer to collect basic block execution paths and to know what are the "hot" paths through execution that are worth agressively optimizing.  Since conditional branches are about 1/6 as frequent as sends, and since they can be used to determine the hot path through code, they are a better choice to count than, for example, method or block entry.

The VM provides a primitive that fills an Array with the state of the counters, and the state of each linked send in a method.  The optimizer obtains the branch and send data for a method via this primitive.

Instance Variables (inherited)

Here is the list of bytecodes.  An asterisk implies the bytecode takes either extA or extB extensions. Two asterisks imply it takes both extA and extB extensions.  A number in parentheses is a note.  See the notes at the end of the table.

1 Byte Bytecodes
	code (note)	binary				name
	0-15		0000 iiii 				Push Receiver Variable #iiii
	16-31		0001 iiii				Push Literal Variable #iiii
	32-63		001 iiiii				Push Literal #iiiii
	64-71		01000 iii				Push Temp #iii
	72-75		010010 ii			Push Temp #ii + 8
	76			01001100			Push Receiver
	77			01001101			Push true
	78			01001110			Push false
	79			01001111			Push nil
	80			01010000			Push 0
	81			01010001			Push 1
*	82			01010010			Push thisContext, (then Extend B = 1 => push thisProcess)
	83			01010011			Duplicate Stack Top
	84-87		010101 ii			UNASSIGNED
	88-91		010110 ii			Return Receiver/true/false/nil
	92			01011100			Return top
	93			01011101			BlockReturn nil
*	94			01011110			BlockReturn Top [* return from enclosing block N, N = Extend A, then jump by Ext B ]
*	95			01011111			Nop
	96-111		0110 iiii				Send Arithmetic Message #iiii (+ - < > <= >= = ~= * / \\ @ bitShift: // bitAnd: bitOr:)
	112-119	01110 iii				Send Special Message #iii + 0 (at: at:put: size next nextPut: atEnd == class)
	120-127	01111 iii				Send Special Message #iii + 8 (~~ value value: do: new new: x y)
	128-143	1000 iiii				Send Literal Selector #iiii With 0 Argument
	144-159	1001 iiii				Send Literal Selector #iiii With 1 Arguments
	160-175	1010 iiii				Send Literal Selector #iiii With 2 Arguments
	176-183	10110 iii				Jump iii + 1 (i.e., 1 through 8)
	184-191	10111 iii				Pop and Jump 0n True iii +1 (i.e., 1 through 8)
	192-199	11000 iii				Pop and Jump 0n False iii +1 (i.e., 1 through 8)
	200-207	11001 iii				Pop and Store Receiver Variable #iii
	208-215	11010 iii				Pop and Store Temporary Variable #iii
	216			11011000			Pop Stack Top
	217	(5)		11011001			Unconditional trap
	218-219	1101101 i			UNASSIGNED
	220-223	110111 ii			UNASSIGNED

2 Byte Bytecodes
*	224			11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A) A is an unsigned extension.
*	225			11100001	bbbbbbbb	Extend B (Ext B = Ext B prev * 256 + Ext B) B is a signed extension.
*	226			11100010	iiiiiiii		Push Receiver Variable #iiiiiiii (+ Extend A * 256)
*	227			11100011	iiiiiiii		Push Literal Variable #iiiiiiii (+ Extend A * 256)
*	228			11100100	iiiiiiii		Push Literal #iiiiiiii (+ Extend A * 256)
	229			11100101	iiiiiiii		Push Temporary Variable #iiiiiiii
	230			11100110	iiiiiiii		UNASSIGNED (was pushNClosureTemps)
	231			11100111	jkkkkkkk		Push (Array new: kkkkkkk) (j = 0)
									&	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)
*	232			11101000	iiiiiiii		Push Integer #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, d=0, s=1)
*	233			11101001	iiiiiiii		Push Character #iiiiiiii (+ Extend A * 256)
**	234			11101010	iiiiijjj		Send Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments
**	235	(1)		11101011	iiiiijjj		ExtendB < 64
										ifTrue: [Send To Superclass Literal Selector #iiiii (+ Extend A * 32) with jjj (+ Extend B * 8) Arguments]
										ifFalse: [Send To Superclass of Stacked Class Literal Selector #iiiii (+ Extend A * 32) with jjj (+ (Extend B bitAnd: 63) * 8) Arguments]
	236			11101100	iiiiiiii		UNASSIGNED
*	237			11101101	iiiiiiii		Jump #iiiiiiii (+ Extend B * 256, where bbbbbbbb = sddddddd, e.g. -32768 = i=0, d=0, s=1)
**	238	(4)		11101110	iiiiiiii		Pop and Jump 0n True #iiiiiiii (+ Extend B * 256, where Extend B >= 0)
**	239	(4)		11101111	iiiiiiii		Pop and Jump 0n False #iiiiiiii (+ Extend B * 256, where Extend B >= 0)
**	240	(3)		11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256) 
**	241	(3)		11110001	iiiiiiii		Pop and Store Literal Variable #iiiiiiii (+ Extend A * 256) 
	242			11110010	iiiiiiii		Pop and Store Temporary Variable #iiiiiiii
**	243	(3)		11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256) 
**	244	(3)		11110100	iiiiiiii		Store Literal Variable #iiiiiiii (+ Extend A * 256) 
	245			11110110	iiiiiiii		Store Temporary Variable #iiiiiiii
	246-247	1111011 i	xxxxxxxx	UNASSIGNED

3 Byte Bytecodes
	248	(2)	11111000 	iiiiiiii		mssjjjjj		Call Primitive #iiiiiiii + (jjjjj * 256) 
												m=1 means inlined primitive, no hard return after execution. 
												ss defines the unsafe operation set used to encode the operations. 
												(ss = 0 means sista unsafe operations, ss = 01 means lowcode operations, other numbers are as yet unused)
												Lowcode inlined primitives may have extensions.
*	249		11111001 	xxxxxxxx	siyyyyyy		Push Closure Compiled block literal index xxxxxxxx (+ Extend A * 256) numCopied yyyyyy receiverOnStack: s = 1 ignoreOuterContext: i = 1
**	250		11111010 	eeiiikkk		jjjjjjjj		Push Closure Num Copied iii (+ExtA//16*8) Num Args kkk (+ ExtA\\16*8) BlockSize jjjjjjjj (+ExtB*256). ee = num extensions
	251		11111011 	kkkkkkkk	sjjjjjjj		Push Temp At kkkkkkkk In Temp Vector At: jjjjjjj, s = 1 implies remote inst var access instead of remote temp vector access 
*	252	(3)	11111100 	kkkkkkkk	sjjjjjjj		Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access 
*	253	(3)	11111101 	kkkkkkkk	sjjjjjjj		Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjj s = 1 implies remote inst var access instead of remote temp vector access
**	254	(5)	11111110	kkkkkkkk	jjjjjjjj		branch If Not Instance Of Behavior/Array Of Behavior literal kkkkkkkk (+ Extend A * 256, where Extend A >= 0) distance jjjjjjjj (+ Extend B * 256, where Extend B >= 0 and <= 127)
**	254	(5)	11111110	kkkkkkkk	jjjjjjjj		branch If Instance Of Behavior/Array Of Behavior literal kkkkkkkk (+ Extend A * 256, where Extend A >= 0) distance jjjjjjjj (+ (Extend B bitAnd: 127) * 256, where Extend B >= 128 and <= 255)
*	255		11111111	xxxxxxxx	jjjjjjjj		UNASSIGNED

(1) Bytecode 235 is a super send bytecode that starts the lookup in the superclass of some class.  It has two forms, "normal" and "directed". In the normal form, the class is the value of the method's methodClassAssociation which must be the last literal.  In the directed form the class is the class on top of stack.

(2) The Call Primitive Bytecode (see below) specifies either a primitive in the primitive table (m=0) or an inlined primitive (m=1). Non-inlined primitives from the primitive table have index (jjjjjjj * 256) + iiiiiiii and return from the method if they succeed.  This bytecode is only valid as the first bytecode of a method.  Inline primitives have index (jjjjjjj * 256) + iiiiiiii, cannot fail, and do not return when they succeed, yielding a result (typically on top of stack after popping their arguments, but possibly in a byte data stack, for example for unboxed floating-point primitives).

(3) ExtB lowest bit implies no store check is needed, ExtB second bit implies the object may be a context, ExtB third bit implies no immutability/read-only check is needed, other bits in the extension are unused.

(4) ExtA = 1 implies no mustBeBoolean trampoline is needed, other bits in the extension are unused

(5) these are Scorch/Sista bytecodes generated by an optimizing compiler and not used in normal Smalltalk code.


The CallPrimitive bytecode is divided into two halves, those for normal primtiives, occurring at the beginning of a method, and those for inline primitives, anywhere within the body of a method.  This is a three byte bytecode, the first byte being 248, and the second byte being a big-endian 16-bit primitive index. If the top bit of the first byte of the primitive index is 1 then this is a normal primitive invocation.  If it is zero then the remaining 15 bits define 32k primitives, organized as four 8k "pages".  The first page is used for and reserved by the Sista optimizing compiler.  The second page is usd for and reserved by the Lowcode FFI marshalling primitive set.  The other two sets are unspecified and unused.

Here is the specification of the Sista unsafe instructions (unsafe operations, set 00). The lowcode set uses external specifications.
We sort the inline primitive operations by arity.  Nullary primitives occupy the 0-999 range. Unary primitives occupy the 1-1999 range, up until 8 args. 8191 instructions can be encoded in each unsafe operation set, instructions from 0 to 7 arguments can have 1000 different instructions each, while 8 args instructions can have 192 different instructions.

Sista defines the following inlined primitives (CallPrimitive iiiiiiii 100jjjjj, n = jjjjjiiiiiiii)
1000	class
1001	pointer numSlots
1002	pointer basicSize
1003	byte8Type format numBytes (includes CompiledMethod)
1004	short16Type format numShorts
1005	word32Type format numWords
1006	doubleWord64Type format numDoubleWords
	
1010	ensure number of bytes available.
1011	fixed-sized new. (objects with 0 to n inst vars)
	
1020 	identityHash (non-immediate, non-Behavior)
1021	identityHash (SmallInteger)
1022	identityHash (Character)
1023	identityHash (SmallFloat64)
1024	identityHash (Behavior, has hash?)

1030 	immediateAsInteger (Character)
1031 	immediateAsInteger (SmallFloat64)
1035 	immediateAsFloat 	(Smallinteger)
	
2000	SmallInteger #+.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2001	SmallInteger #-.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2002	SmallInteger #*.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2003	SmallInteger #/.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2004	SmallInteger #//.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2005	SmallInteger #\\.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2006	SmallInteger #quo:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)

2011	Variable-sized pointers new (new:). Array, etc.
2012	Variable-sized byte new (new:). ByteArray, ByteString, etc.
2013	Variable-sized 16-bit new (new:). DoubleByteArray, etc.
2014	Variable-sized 32-bit new (new:). Bitmap, FloatArray, etc.
2015	Variable-sized 64-bit new (new:). DoubleWordArray, etc.

2016	SmallInteger #bitAnd:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2017	SmallInteger #bitOr:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2018	SmallInteger #bitXor:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2019	SmallInteger #bitShiftLeft:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)
2020	SmallInteger #bitShiftRight:.  Both arguments are SmallIntegers and the result fits in a SmallInteger (* depends on word size)

2032	SmallInteger #>.  Both arguments are SmallIntegers
2033	SmallInteger #<.  Both arguments are SmallIntegers
2034	SmallInteger #>=.  Both arguments are SmallIntegers
2035	SmallInteger #<=.  Both arguments are SmallIntegers
2036	SmallInteger #=.  Both arguments are SmallIntegers
2037	SmallInteger #~=.  Both arguments are SmallIntegers

2064	Pointer Object>>at:.				The receiver is guaranteed to be a pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger
2065	Byte Object>>at:.				The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger.
2066	16-bit Word Object>>at:.		The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger.
2067	32-bit DoubleWord Object>>at:.	The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger or a LargePositiveInteger.
2068	64-bit QuadWord Object>>at:.	The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The result is a SmallInteger or a LargePositiveInteger.

The following instructions can have the ExtB check flag (See (3)).
3000	Pointer Object>>at:put:.			The receiver is guaranteed to be a pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger
3001	Byte Object>>at:put:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 8 bits.
3002	Word Object>>at:put:.			The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 16 bits.
3003	DoubleWord Object>>at:put:.		The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 32 bits.
3004	QuadWord Object>>at:put:.		The receiver is guaranteed to be a non-pointer object.  The 0-relative (1-relative?) index is an in-range SmallInteger.  The argument is a SmallInteger.  The primitive stores the least significant 64 bits.
			
3021	Byte Object >> equals:length:	The receiver and the arguments are both byte objects and have both the same size (length). The length argument is a smallinteger. Answers true if all fields are equal, false if not. Comparison is bulked to word comparison.

4000	Pointer Object>> fillFrom:to:with: The receiver is a Pointer object. the middle two arguments are smallintegers. Last argument is any object. Fills the object in between the two indexes with last argument. Receiver is guaranteed to be mutable. The pointer accesses are raw (no inst var check). If ExtB is set to 1, no store check is present. Else a single store check is done for the bulk operation. Answers the receiver.
	
5000	Pointer Object>> replaceFrom:to:with:startingAt: Src and dest are pointer objects. ScrPos, scrLast and destLast are smallintegers. Receiver is guaranteed to be mutable.  Both ranges are in-bounds. The pointer accesses are raw (no inst var check). As for the normal primitive, the copy is linear. Answers the receiver.


Lowcode defines inlined primitives for the range CallPrimitive iiiiiiii 101jjjjj, n = jjjjjiiiiiiii.!
!EncoderForV3PlusClosures commentStamp: 'jmv 9/20/2016 19:42:38' prior: 16857279!
                        I add behaviour to Encoder to size and emit bytecodes for the Squeak V3.x VM bytecode set, a close variant of the original Smalltalk-80 bytecode set defined in the Blue Book.

	0-15 		0000iiii 			Push Receiver Variable #iiii
	16-31 		0001iiii 			Push Temporary Location #iiii
	32-63 		001iiiii 			Push Literal Constant #iiiii
	64-95 		010iiiii 			Push Literal Variable #iiiii
	96-103 		01100iii 			Pop and Store Receiver Variable #iii
	104-111 	01101iii 			Pop and Store Temporary Location #iii
	112-119 	01110iii 			Push (receiver, true, false, nil, -1, 0, 1, 2) [iii]
	120-123 	011110ii 		Return (receiver, true, false, nil) [ii] From Message
	124-125 	0111110i 		Return Stack Top From (Message, Block) [i]
	(126-127 unassigned)
	128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk
	129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk
	130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk
	131 	10000011 jjjkkkkk 	Send Literal Selector #kkkkk With jjj Arguments
	132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj (for sends jjjjj = numArgs)
	133 	10000011 jjjkkkkk 	Send Literal Selector #kkkkk To Superclass With jjj Arguments
	134 	10000011 jjjkkkkk 	Send Literal Selector #kkkkk With jjj Arguments
	135 		10000111 		Pop Stack Top
	136 		10001000 		Duplicate Stack Top
	137 		10001001 		Push Active Context
	(138-143 unassigned)
	144-151 	10010iii 			Jump iii + 1 (i.e., 1 through 8)
	152-159 	10011iii 			Pop and Jump 0n False iii +1 (i.e., 1 through 8)
	160-167 	10100iii jjjjjjjj 	Jump(iii - 4) *256+jjjjjjjj
	168-171 	101010ii jjjjjjjj 	Pop and Jump On True ii *256+jjjjjjjj
	172-175 	101011ii jjjjjjjj 	Pop and Jump On False ii *256+jjjjjjjj
	176-191 	1011iiii 			Send Arithmetic Message #iiii
	192-207 	1100iiii 			Send Special Message #iiii
	208-223 	1101iiii 			Send Literal Selector #iiii With No Arguments
	224-239 	1110iiii 			Send Literal Selector #iiii With 1 Argument
	240-255 	1111iiii 			Send Literal Selector #iiii With 2 Arguments

An encoder for the V3 bytecode set augmented with the following bytecodes that are part of the full closure implementation.
	138   10001010 jkkkkkkk		Push (Array new: kkkkkkk) (j = 0)
								or	Pop kkkkkkk elements into: (Array new: kkkkkkk) (j = 1)
	139   10001011 kkkkkkkk jjjjjjjj 	Invoke primitive number jjjjjjjjkkkkkkkk
	140   10001100 kkkkkkkk jjjjjjjj 	Push Temp At kkkkkkkk In Temp Vector At: jjjjjjjj
	141   10001101 kkkkkkkk jjjjjjjj 	Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj
	142   10001110 kkkkkkkk jjjjjjjj 	Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj
	143   10001111 llllkkkk jjjjjjjj iiiiiiii	Push Closure Num Copied llll Num Args kkkk BlockSize jjjjjjjjiiiiiiii
This is an exact duplicate of EncoderForLongFormV3PlusClosures.
Could be a trait (or in Newspeak, a Mixin).
For now we impose upon you to synchronise any and all changes between these two classes.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7270-ByteEncoderClassCommentFormatting-EliotMiranda-JuanVuletich-2025Jun17-17h19m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7270] on 17 June 2025 at 5:25:12 pm'!
!BytecodeEncoder class methodsFor: 'compiled method support' stamp: 'jmv 6/17/2025 16:51:19'!
              nonLocalReturnScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor:
	 that answers true for non-local returns."
	self subclassResponsibility! !
!EncoderForSistaV1 class methodsFor: 'instruction stream support' stamp: 'jmv 6/17/2025 16:54:59' overrides: 50333325!
                             nonLocalReturnScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor:
	 that answers true for non-local returns."

	"88-91		010110 ii			Return Receiver/true/false/nil
	 92			01011100			Return top"

	^[ :instr |
		instr between: 88 and: 92 ]! !
!EncoderForV3PlusClosures class methodsFor: 'compiled method support' stamp: 'jmv 6/17/2025 16:53:09' overrides: 50333325!
                       nonLocalReturnScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor:
	 that answers true for non-local returns."

	^[ :instr |
		instr between: 120 and: 124 ]! !
!CompiledMethod methodsFor: 'closures' stamp: 'jmv 6/9/2025 17:12:52' prior: 16833983!
            containsBlockClosures

	| scanner |
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		self encoderClass createClosureScanBlock! !
!CompiledMethod methodsFor: 'scanning' stamp: 'jmv 6/9/2025 17:09:09' prior: 16834982!
                           readsField: varIndex 
	"Answer whether the receiver loads the instance variable indexed by the 
	 argument."
	"eem 5/24/2008 Rewritten to no longer assume the compiler uses the
	 most compact encoding available (for EncoderForLongFormV3 support)."

	| varIndexCode scanner |
	varIndexCode := varIndex - 1.
	self isReturnField ifTrue: [^self returnField = varIndexCode].
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		(self encoderClass instVarReadScanBlockFor: varIndexCode using: scanner)! !
!CompiledMethod methodsFor: 'scanning' stamp: 'jmv 6/9/2025 17:09:22' prior: 16835007!
             readsRef: literalAssociation 
	"Answer whether the receiver loads the argument."
	"eem 5/24/2008 Rewritten to no longer assume the compler uses the
	 most compact encoding available (for EncoderForLongFormV3 support)."

	| litIndex scanner |
	(litIndex := self indexOfLiteral: literalAssociation) = 0 ifTrue:
		[^false].
	litIndex := litIndex - 1.
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		(self encoderClass bindingReadScanBlockFor: litIndex using: scanner)! !
!CompiledMethod methodsFor: 'scanning' stamp: 'jmv 6/9/2025 17:30:36' prior: 16835103!
       sendsToSuper
	"Answer whether the receiver sends any message to super."
	| scanner |
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		(self encoderClass superSendScanBlockUsing: scanner)! !
!CompiledMethod methodsFor: 'scanning' stamp: 'jmv 6/9/2025 17:08:55' prior: 16835114!
                              writesField: varIndex
	"Answer whether the receiver stores into the instance variable indexed
	 by the argument."
	"eem 5/24/2008 Rewritten to no longer assume the compler uses the
	 most compact encoding available (for EncoderForLongFormV3 support)."

	| varIndexCode scanner |
	self isQuick ifTrue: [^false].
	varIndexCode := varIndex - 1.
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		(self encoderClass instVarWriteScanBlockFor: varIndexCode using: scanner)! !
!CompiledMethod methodsFor: 'scanning' stamp: 'jmv 6/9/2025 17:10:28' prior: 16835148!
        writesRef: literalAssociation 
	"Answer whether the receiver stores into the argument."
	"eem 5/24/2008 Rewritten to no longer assume the compler uses the
	 most compact encoding available (for EncoderForLongFormV3 support)."

	| litIndex scanner |
	(litIndex := self indexOfLiteral: literalAssociation) = 0 ifTrue:
		[^false].
	litIndex := litIndex - 1.
	scanner := InstructionStream on: self.
	^ scanner scanFor:
		(self encoderClass bindingWriteScanBlockFor: litIndex using: scanner)! !
!CompiledMethod methodsFor: 'testing' stamp: 'jmv 6/17/2025 16:31:27' prior: 16835666!
                               usesClosureBytecodes
	"Answer whether the receiver was compiled using the closure compiler.
	 This is used to help DebuggerMethodMap choose which mechanisms to
	 use to inspect activations of the receiver.
	In Cuis all the subclasses of BytecodeEncoder #supportsClosures."
	
	^true! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 6/17/2025 16:55:24' prior: 16794105!
              hasNonLocalReturn
	"Answer whether the receiver has a method-return ('^') in its code."
	| myMethod scanner end |
	myMethod := self method.
	scanner := InstructionStream new method: myMethod pc: startpc.
	end := self endpc.
	scanner scanFor: [ :byte |
		((myMethod encoderClass nonLocalReturnScanBlockUsing: scanner)
			value: byte)
				or: [scanner pc > end]].
	^scanner pc <= end! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 6/17/2025 16:39:58' prior: 16794160!
          sendsToSuper
	"Answer whether the receiver sends any message to super."
	| myMethod scanner end |
	myMethod := self method.
	scanner := InstructionStream new method: myMethod pc: startpc.
	end := self endpc.
	scanner scanFor: [ :byte |
		((myMethod encoderClass superSendScanBlockUsing: scanner)
			value: byte)
				or: [scanner pc > end]].
	^scanner pc <= end! !

Decompiler removeSelector: #blockScopeRefersOnlyOnceToTemp:!

!methodRemoval: Decompiler #blockScopeRefersOnlyOnceToTemp: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:09'!
blockScopeRefersOnlyOnceToTemp: offset
	| nRefs byteCode extension scanner scan |
	scanner := InstructionStream on: method.
	nRefs := 0.
	scan := offset <= 15
				ifTrue:
					[byteCode := 16 + offset.
					 [:instr |
					  instr = byteCode ifTrue:
						[nRefs := nRefs + 1].
					  nRefs > 1]]
				ifFalse:
					[extension := 64 + offset.
					 [:instr |
					  (instr = 128 and: [scanner followingByte = extension]) ifTrue:
						[nRefs := nRefs + 1].
					   nRefs > 1]].
	self scanBlockScopeFor: pc from: method initialPC to: method endPC with: scan scanner: scanner.
	^nRefs = 1!

CompiledMethod removeSelector: #scanLongStore:!

!methodRemoval: CompiledMethod #scanLongStore: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:09'!
scanLongStore: extension 
	"Answer whether the receiver contains a long store whose extension is 
	the argument."
	| scanner |
	scanner := InstructionStream on: self.
	^scanner scanFor: 
		[:instr |  (instr = 129 or: [instr = 130]) and: [scanner followingByte = extension]]!

CompiledMethod removeSelector: #writesFieldCode:with:using:!

!methodRemoval: CompiledMethod #writesFieldCode:with:using: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:09'!
writesFieldCode: varIndexCode with: byteCode using: scanner 

	^byteCode >= 96
		and: [byteCode <= 103
			ifTrue: [byteCode - 96 = varIndexCode]
			ifFalse:
				[(byteCode = 129 or: [byteCode = 130])
					ifTrue: [scanner followingByte = varIndexCode and: [varIndexCode <= 63]]
					ifFalse:
						[byteCode = 132
						 and: [(scanner followingByte between: 160 and: 223)
						 and: [scanner thirdByte = varIndexCode]]]]]
!

CompiledMethod removeSelector: #scanVeryLongStore:offset:!

!methodRemoval: CompiledMethod #scanVeryLongStore:offset: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:09'!
scanVeryLongStore: extension offset: offset
	"Answer whether the receiver contains a long load with the given offset.
	Note that the constant +32 is the known difference between a
	store and a storePop for instVars, and it will always fail on literal variables,
	but these only use store (followed by pop) anyway."
	| scanner |
	scanner := InstructionStream on: self.
	^scanner scanFor:
		[:instr | | ext |
		(instr = 132 and: [(ext := scanner followingByte) = extension
											or: ["might be a store/pop into rcvr"
												ext = (extension+32)]])
		and: [scanner thirdByte = offset]]!

CompiledMethod removeSelector: #scanLongLoad:!

!methodRemoval: CompiledMethod #scanLongLoad: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:09'!
scanLongLoad: extension 
	"Answer whether the receiver contains a long load whose extension is the
	argument."

	| scanner |
	scanner := InstructionStream on: self.
	^scanner scanFor: [:instr | instr = 128 and: [scanner followingByte = extension]]!

CompiledMethod removeSelector: #scanVeryLongLoad:offset:!

!methodRemoval: CompiledMethod #scanVeryLongLoad:offset: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:09'!
scanVeryLongLoad: extension offset: offset
	"Answer whether the receiver contains a long load whose extension is the 
	argument."
	| scanner |
	scanner := InstructionStream on: self.
	^ scanner scanFor: [:instr | (instr = 132 and: [scanner followingByte = extension])
											and: [scanner thirdByte = offset]]!

EncoderForV3PlusClosures class removeSelector: #method:readsField:!

!methodRemoval: EncoderForV3PlusClosures class #method:readsField: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:09'!
method: method readsField: varIndex
	"Answer if method loads the instance variable indexed by varIndex.
	 N.B. Don't assume the compiler uses the most compact encoding available.
	0-15 		0000iiii 	Push Receiver Variable #iiii
	128 		10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk
	132 		10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj (for sends jjjjj = numArgs)"
	| varIndexCode scanner |
	varIndexCode := varIndex - 1.
	method isReturnField ifTrue:
		[^method returnField = varIndexCode].
	^(scanner := InstructionStream on: method) scanFor:
		[:b|
		b < 16
			ifTrue: [b = varIndexCode]
			ifFalse:
				[b = 128
					ifTrue: [scanner followingByte = varIndexCode and: [varIndexCode <= 63]]
					ifFalse:
						[b = 132
						 and: [(scanner followingByte between: 64 and: 95)
						 and: [scanner thirdByte = varIndexCode]]]]]!

EncoderForV3PlusClosures class removeSelector: #method:writesField:!

!methodRemoval: EncoderForV3PlusClosures class #method:writesField: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:09'!
method: method writesField: varIndex
	"Answer if method stores into the instance variable indexed by varIndex.
	 N.B. Don't assume the compiler uses the most compact encoding available.
	96-103 	01100iii 	Pop and Store Receiver Variable #iii
	129 		10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk
	130 		10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk
	132 		10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj (for sends jjjjj = numArgs)"
	| varIndexCode scanner |
	method isQuick ifTrue: [^false].
	varIndexCode := varIndex - 1.
	^(scanner := InstructionStream on: method) scanFor:
		[:b|
		b >= 96
		and: [b <= 103
				ifTrue: [b - 96 = varIndexCode]
				ifFalse:
					[(b = 129 or: [b = 130])
						ifTrue: [scanner followingByte = varIndexCode and: [varIndexCode <= 63]]
						ifFalse:
							[b = 132
							 and: [(scanner followingByte between: 160 and: 223)
							 and: [scanner thirdByte = varIndexCode]]]]]]!

BytecodeEncoder class removeSelector: #method:readsField:!

!methodRemoval: BytecodeEncoder class #method:readsField: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:09'!
method: method readsField: varIndex
	"Answer if method loads the instance variable indexed by varIndex."
	^self subclassResponsibility!

BytecodeEncoder class removeSelector: #method:writesField:!

!methodRemoval: BytecodeEncoder class #method:writesField: stamp: 'Install-7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st 7/15/2025 11:02:09'!
method: method writesField: varIndex
	"Answer if method stores into the instance variable indexed by varIndex."
	^self subclassResponsibility!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7271-SistaCompatibility-JuanVuletich-2025Jun17-17h23m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7271] on 17 June 2025 at 5:54:08 pm'!

SystemDictionary removeSelector: #browseEqSmallConstant!

!methodRemoval: SystemDictionary #browseEqSmallConstant stamp: 'Install-7272-Cleanup-JuanVuletich-2025Jun17-17h53m-jmv.001.cs.st 7/15/2025 11:02:09'!
browseEqSmallConstant

    "Dan Ingalls' search for arithmetic use of ==
Answer whether the receiver contains the pattern <expression> == <constant>,
where constant is -1, 0, 1, or 2...
	Smalltalk browseEqSmallConstant
"

	self browseAllSelect: [:m | m scanForEqSmallConstant]!

CompiledMethod removeSelector: #scanForEqSmallConstant!

!methodRemoval: CompiledMethod #scanForEqSmallConstant stamp: 'Install-7272-Cleanup-JuanVuletich-2025Jun17-17h53m-jmv.001.cs.st 7/15/2025 11:02:09'!
scanForEqSmallConstant

    "Dan Ingalls' search for arithmetic use of ==
Answer whether the receiver contains the pattern <expression> == <constant>,
where constant is -1, 0, 1, or 2...
	Smalltalk browseAllSelect: [:m | m scanForEqSmallConstant]
"



    | scanner |

    scanner := InstructionStream on: self.

    ^ scanner scanFor: [:instr | (instr between: 116 and: 119) and: [scanner followingByte = 198]]



"

Smalltalk browseAllSelect: [:m | m scanForEqSmallConstant]

"!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7272-Cleanup-JuanVuletich-2025Jun17-17h53m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7272] on 18 June 2025 at 5:05:03 pm'!
!Object methodsFor: 'user interface' stamp: 'jmv 6/17/2025 17:57:51' prior: 50332487!
                               request: queryString do: acceptBlock
	"Non-modal. Method returns immediately.
	Uses acceptBlock to process user's answer later, when provided by them."
	^ self request: queryString initialAnswer: '' verifying: [:aString| true] do: acceptBlock orCancel: nil! !
!Object methodsFor: 'user interface' stamp: 'jmv 6/17/2025 17:56:49' prior: 16923476!
      request: queryString initialAnswer: defaultAnswer do: acceptBlock
	"Non-modal. Method returns immediately.
	Uses acceptBlock to process user's answer later, when provided by them."
	^ self request: queryString initialAnswer: defaultAnswer verifying: [:aString| true] do: acceptBlock orCancel: nil! !
!Object methodsFor: 'user interface' stamp: 'jmv 6/17/2025 17:58:27' prior: 16923522!
                              request: queryString initialAnswer: defaultAnswer verifying: validationBlock do: acceptBlock
	"Non-modal. Method returns immediately.
	Uses acceptBlock to process user's answer later, when provided by them."
	^ self request: queryString initialAnswer: defaultAnswer verifying: validationBlock do: acceptBlock orCancel: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7273-RemoveEmptyClosures-JuanVuletich-2025Jun18-16h53m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7272] on 18 June 2025 at 5:36:01 pm'!
!Parser methodsFor: 'expression types' stamp: 'jmv 6/17/2025 18:01:15' prior: 16928464!
                          variable
	
	^self advanceWithRangeDo: [ :variableName :range | | varName result rightRange |
		varName := variableName.
		
		"See ParserTest>>#testRangesAreOkWhenReturningAVariableWithoutSpaceAfterThat
		There is a very difficult bug to fix. It happends when the source code ends with a return of a variable of 
		one char an no other char after that, for example: '^a' 
		In that case the range includes the ^ that is incorrect and makes the rename temporary fail.
		I do this fix becuase changing how the range is calculated is almost imposible due to the coupling 
		and complexity of the parser. This change applies only to variables and therefore it assures no
		unexpected behavior. I'm not cheching for size = 1 because it is redundant - Hernan"
		rightRange := varName size = range size
			ifTrue: [ range ]
			ifFalse: [ range last - varName size + 1 to: range last ].
		
		[result := encoder encodeVariable: varName sourceRange: rightRange ifUnknown: nil.
		result ifNil: [
			result := (UndeclaredVariableReference new)
				parser: self;
				varName: varName;
				varStart: rightRange first;
				varEnd: rightRange last;
				signal ].
		result isString ] whileTrue: [ varName := result].
		encoder addMultiRange: rightRange for: result ].
	! !
!Parser methodsFor: 'error correction' stamp: 'jmv 6/17/2025 18:00:35' prior: 16928713!
 declarationRangesForTemps: someTempNodes
	
	^someTempNodes collect: [ :temporaryNode | 
		(encoder rangeForNode: temporaryNode ifAbsent: nil) first ].! !
!Encoder methodsFor: 'results' stamp: 'jmv 6/17/2025 18:02:03' prior: 16853947!
                      associationForClass
	| assoc |
	assoc := Smalltalk associationAt: class name ifAbsent: nil.
	^assoc value == class
		ifTrue: [ assoc ]
		ifFalse: [ Association new value: class ]! !
!Encoder methodsFor: 'temps' stamp: 'eem 12/1/2008 12:07' prior: 16854156!
                               fixTemp: name
	| node |
	node := scopeTable at: name ifAbsent: nil.
	node class ~~ TempVariableNode ifTrue:
		[self error: 'can only fix a floating temp var'].
	node index: nTemps.
	nTemps := nTemps + 1.
	^node! !
!Encoder methodsFor: 'temps' stamp: 'eem 7/13/2007 14:13' prior: 16854165!
                               floatTemp: node
	(node ~~ (scopeTable at: node name ifAbsent: nil)
	or: [node class ~~ TempVariableNode
	or: [node code ~= (node code: nTemps - 1 type: LdTempType)]]) ifTrue:
		[self error: 'can only float the last allocated temp var'].
	nTemps := nTemps - 1! !
!DecompilerConstructor methodsFor: 'constructor' stamp: 'jmv 6/17/2025 18:51:01' prior: 16847818!
                        codeMethod: selector block: block tempVars: vars primitive: primitive class: class

	| blockNode selectorNode visibleTemps invisibleTemps arguments temporaries properties |
	selectorNode := self codeSelector: selector code: nil.
	tempVars := vars.
	visibleTemps := OrderedCollection new.
	invisibleTemps := OrderedCollection new.
	tempVars do: [:t|
				   ((t isIndirectTempVector or: [t scope >= 0])
						ifTrue: [visibleTemps]
						ifFalse: [invisibleTemps]) addLast: t].
	arguments := visibleTemps copyFrom: 1 to: nArgs.
	temporaries := visibleTemps copyFrom: nArgs + 1 to: visibleTemps size.
	block
		arguments: arguments;
		temporaries: temporaries.
	properties := method properties copy.
	(properties at: #onceCache ifAbsent: nil) ifNotNil:
		[:onceCache|
		 properties := properties copyWithout: (Association
													key: #onceCache
													value: onceCache)].
	blockNode := MethodNode new
		selector: selectorNode
		arguments: arguments
		precedence: selector precedence
		temporaries: temporaries
		block: block
		encoder: (method encoderClass new initScopeAndLiteralTables
					temps: visibleTemps, invisibleTemps
					literals: literalValues
					class: class)
		primitive: primitive
		properties: properties.
	blockNode properties method: blockNode.
	^blockNode! !
!TemporaryVariableDeclarationRemover methodsFor: 'source text generation' stamp: 'EB 5/28/2019 21:22:07' prior: 16984224!
                             sourceTextWithoutTemporaryDeclaration

	| temporaryVariablePositions variableDeclarationPosition | 

	temporaryVariablePositions := methodNode positionsForTemporaryVariable: temporaryVariable ifAbsent: nil.
	variableDeclarationPosition := {temporaryVariablePositions first}.
	^methodNode sourceText copyReplacing: variableDeclarationPosition with: ''! !
!FontFamily class methodsFor: 'accessing fonts' stamp: 'jmv 6/17/2025 18:51:13' prior: 16872535!
                             familyNamed: aString
	"
	FontFamily familyNamed: FontFamily defaultFamilyName
	"
	^AvailableFamilies at: aString ifAbsent: nil.! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'jmv 6/17/2025 18:51:21' prior: 16817562!
 mutateInstances: oldClass to: newClass
	"Mutate the old class and subclasses into newClass and subclasses.
	Note: This method is slightly different from: #mutate:toSuper: since
	here we are at the root of reshaping and have two distinct roots."

	self showProgressFor: oldClass.
	"Convert the subclasses"
	oldClass subclasses do: [ :oldSubclass | | newSubclass |
		newSubclass := newClass subclasses detect: [ :c | c name = oldSubclass name ]. 
		self mutateInstances: oldSubclass to: newSubclass.
	].
	"And any obsolete ones"
	oldClass obsoleteSubclasses do: [ :oldSubclass | | newSubclass |
		oldSubclass ifNotNil: [
			newSubclass := newClass subclasses detect: [ :c | c name = oldSubclass name ] ifNone: nil.
			newSubclass ifNotNil: [
				self mutateInstances: oldSubclass to: newSubclass ].
		].
	].
	self update: oldClass to: newClass.
	^newClass! !
!CodeProvider methodsFor: 'categories' stamp: 'jmv 6/17/2025 18:03:13' prior: 16826164!
               categoryFromUserWithPrompt: aPrompt for: aClass
	"self new categoryFromUserWithPrompt: 'testing' for: SystemDictionary"

	^(MethodCategoriesPrompter 
		staringFrom: aClass 
		rejectingFirst: false) prompt: aPrompt ifNone: nil! !
!Browser methodsFor: 'class list' stamp: 'jmv 6/17/2025 18:03:34' prior: 16798247!
        classListIndex: anInteger
	"Set anInteger to be the index of the current class selection."

	| className recent canSelectClass classList prevSelectedClassName prevSelectedMessage |
	classList := self classList.
	canSelectClass := classList isInBounds: anInteger.
	prevSelectedClassName := selectedClassName.
	selectedClassName := canSelectClass ifTrue: [
		| newClassName |
		newClassName := classList at: anInteger ifAbsent: nil.
		newClassName := newClassName ifNotNil: [newClassName withoutLeadingBlanks asSymbol].
		newClassName ].
	self setClassOrganizer.
	prevSelectedMessage := selectedMessage.
	selectedMessage := nil.

	self classCommentIndicated ifFalse: [
		self editSelection: (canSelectClass
			ifTrue: [#editClass]
			ifFalse: [ metaClassIndicated | selectedSystemCategory isNil
				ifTrue: [#none]
				ifFalse: [#newClass]])].

	self selectedClass ifNotNil: [
		recent := self class recentClasses.
		className := self selectedClass name.
		(recent includes: className) ifTrue: [recent remove: className].
		recent addFirst: className.
		recent size > 16 ifTrue: [recent removeLast]].

	"Clear selectedMessageCategory if there is no match in the new list of categories"
	(self messageCategoryList indexOf: selectedMessageCategory) = 0 ifTrue: [
		selectedMessageCategory := nil].

	self changed: #classSelectionChanged.
	self changed: #classCommentText.
	self changed: #classListIndex.	"update my selection"
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self acceptedContentsChanged.
	prevSelectedClassName = selectedClassName ifFalse: [
		"If clicked on already selected class, deselect selector, so class definition is shown"
		self setSelector: prevSelectedMessage ].! !
!Debugger methodsFor: 'code pane' stamp: 'jmv 6/17/2025 18:07:09' prior: 16844244 overrides: 16992950!
                   contentsSelection

	"If we are just creating the method in the debugger, help the user by selecting the method body."
	| sendInterval |
	currentCompiledMethod ifNotNil: [
		((currentCompiledMethod hasLiteral: #shouldBeImplemented) and: [
			(currentCompiledMethod abstractPCForConcretePC: self selectedContext pc) = 1]) ifTrue: [
				sendInterval := (self selectedContext debuggerMap abstractSourceMap at: 2 ifAbsent: nil).
				sendInterval ifNotNil: [ ^ sendInterval first - 5 to: sendInterval last + 1 ]]].

	^self pcRange! !
!Color methodsFor: 'other' stamp: 'jmv 6/17/2025 18:07:16' prior: 16830184!
    colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color.
	Return nil if named color support is not present"

	Color classPool 
		at: #ColorNamesDict
		ifPresent: [ :dict | ^dict keyAtValue: self ifAbsent: nil].
	^nil! !
!Behavior methodsFor: 'obsolete subclasses' stamp: 'jmv 6/17/2025 18:51:50' prior: 50331740!
     removeObsoleteSubclass: aClass
	"Remove aClass from the weakly remembered obsolete subclasses."

	ObsoleteSubclasses ifNil: [
		^ self ].
	ObsoleteSubclasses remove: aClass ifAbsent: nil.! !
!SourceCodeInterval methodsFor: 'source code' stamp: 'jmv 6/17/2025 18:04:18' prior: 16965459!
  trimToMatchExpressionOn: aSourceCode

	| initialChar endingChar |
	
	initialChar := aSourceCode at: start ifAbsent: nil.
	endingChar := aSourceCode at: stop ifAbsent: nil.
	
	^(initialChar == $( and: [ endingChar == $) ])
		ifTrue: [ self trimParentesisOn: aSourceCode ]
		ifFalse: [ self trimNoParentesisStartingWith: initialChar endingWith: endingChar on: aSourceCode]! !
!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 8/13/2014 13:29' prior: 16835857!
   installPrimaryBytecodeSet: aBytecodeEncoderSubclass
	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:
		[^self].
	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:
		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].
	(self allSubInstances
			detect: [:m| m header >= 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]
			ifNone: nil) ifNotNil:
		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].
	PrimaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass! !
!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 8/13/2014 13:29' prior: 16835878!
                               installSecondaryBytecodeSet: aBytecodeEncoderSubclass
	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:
		[^self].
	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:
		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].
	(self allSubInstances
			detect: [:m| m header < 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]
			ifNone: nil) ifNotNil:
		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].
	SecondaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass! !
!CompiledMethod class methodsFor: 'source code management aux' stamp: 'jmv 6/17/2025 18:09:13' prior: 16836398!
                   overridenMethodReferenceFrom: tokens

	^ self field: #overrides: from: tokens ifAbsentOrNil: nil! !
!CompiledMethod class methodsFor: 'source code management aux' stamp: 'jmv 6/17/2025 18:09:18' prior: 16836405!
            priorReferenceFrom: tokens

	^ self field: #prior: from: tokens ifAbsentOrNil: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7274-RemoveEmptyClosures-JuanVuletich-2025Jun18-17h05m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7272] on 18 June 2025 at 5:40:40 pm'!
!SystemDictionary methodsFor: 'special objects' stamp: 'jmv 6/17/2025 18:53:13' prior: 16975856!
 recreateSpecialObjectsArray
	"Smalltalk recreateSpecialObjectsArray"
	
	"To external package developers:
	**** DO NOT OVERRIDE THIS METHOD.  *****
	If you are writing a plugin and need additional special object(s) for your own use, 
	use addGCRoot() function and use own, separate special objects registry "
	
	"The Special Objects Array is an array of objects used by the Squeak virtual machine.
	 Its contents are critical and accesses to it by the VM are unchecked, so don't even
	 think of playing here unless you know what you are doing."
	| newArray |
	newArray := Array new: 60.
	"Nil false and true get used throughout the interpreter"
	newArray at: 1 put: nil.
	newArray at: 2 put: false.
	newArray at: 3 put: true.
	"This association holds the active processor (a ProcessScheduler)"
	newArray at: 4 put: (self associationAt: #Processor).
	"Numerous classes below used for type checking and instantiation"
	newArray at: 5 put: Bitmap.
	newArray at: 6 put: SmallInteger.
	newArray at: 7 put: String.
	newArray at: 8 put: Array.
	newArray at: 9 put: Smalltalk.
	newArray at: 10 put: BoxedFloat64.
	newArray at: 11 put: MethodContext.
	newArray at: 11 put: (self at: #MethodContext ifAbsent: [self at: #Context]).
	newArray at: 12 put: nil. "was BlockContext."
	newArray at: 13 put: Point.
	newArray at: 14 put: LargePositiveInteger.
	newArray at: 15 put: Display.
	newArray at: 16 put: Message.
	newArray at: 17 put: CompiledMethod.
	newArray at: 18 put: ((self specialObjectsArray at: 18) ifNil: [Semaphore new]). "low space Semaphore"
	newArray at: 19 put: Semaphore.
	newArray at: 20 put: Character.
	newArray at: 21 put: #doesNotUnderstand:.
	newArray at: 22 put: #cannotReturn:.
	newArray at: 23 put: nil. "This is the process signalling low space."
	"An array of the 32 selectors that are compiled as special bytecodes,
	 paired alternately with the number of arguments each takes."
	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1
							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1
							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0
							#blockCopyNOWUNUSED: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).
	newArray at: 25 put: nil. "This is nil in Spur, which has immediate Characters."
	newArray at: 26 put: #mustBeBoolean.
	newArray at: 27 put: ByteArray.
	newArray at: 28 put: Process.
	newArray at: 29 put: nil. "This is nil in Spur, no compact classes."
	newArray at: 30 put: ((self specialObjectsArray at: 30) ifNil: [Semaphore new]). "delay Semaphore"
	newArray at: 31 put: ((self specialObjectsArray at: 31) ifNil: [Semaphore new]). "user interrupt Semaphore"

	"Entries 32 - 34 unreferenced. Previously these contained prototype instances to be copied for fast initialization.
	In Squeak these are: DoubleByteArray, WordArray, DoubleWordArray.
	Understand why."
	newArray at: 32 put: nil. "was the prototype Float"
	newArray at: 33 put: nil. "was the prototype 4-byte LargePositiveInteger"
	newArray at: 34 put: nil. "was the prototype Point"

	newArray at: 35 put: #cannotInterpret:.
	newArray at: 36 put: nil. "was the prototype MethodContext"
	newArray at: 37 put: BlockClosure.
	newArray at: 38 put: nil. "was the prototype BlockContext"

	"array of objects referred to by external code"
	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"
	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"
	newArray at: 41 put: ((self specialObjectsArray at: 41) ifNil: [LinkedList new]). "Reserved for a LinkedList instance for overlapped calls in CogMT"
	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]). "finalization Semaphore"
	newArray at: 43 put: LargeNegativeInteger.
	"External objects for callout.
	 Note: Written so that one can actually completely remove the FFI."
	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: nil).
	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: nil).
	newArray at: 46 put: (self at: #ExternalData ifAbsent: nil).
	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: nil).
	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: nil).
	newArray at: 49 put: #aboutToReturn:through:.
	newArray at: 50 put: #run:with:in:.
	"51 reserved for immutability message"
	newArray at: 51 put: #attemptToAssign:withIndex:.
	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'
							#'bad argument' #'bad index'
							#'bad number of arguments'
							#'inappropriate operation'  #'unsupported operation'
							#'no modification' #'insufficient object memory'
							#'insufficient C memory' #'not found' #'bad method'
							#'internal error in named primitive machinery'
							#'object may move' #'resource limit exceeded'
							#'object is pinned' #'primitive write beyond end of object').
	"53 to 55 are for Alien"
	newArray at: 53 put: (self at: #Alien ifAbsent: nil).
	newArray at: 54 put: #invokeCallbackContext:. "use invokeCallback:stack:registers:jmpbuf: for old Alien callbacks."
	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: nil).

	"Used to be WeakFinalizationList for WeakFinalizationList hasNewFinalization, obsoleted by ephemeron support."
	newArray at: 56 put: nil.

	"reserved for foreign callback process"
	newArray at: 57 put: (self specialObjectsArray at: 57 ifAbsent: nil).

	newArray at: 58 put: #unusedBytecode.
	"59 reserved for Sista counter tripped message"
	newArray at: 59 put: #conditionalBranchCounterTrippedOn:.
	"60 reserved for Sista class trap message"
	newArray at: 60 put: #classTrapFor:.

	"Now replace the interpreter's reference in one atomic operation"
	self specialObjectsArray become: newArray.! !
!SystemDictionary methodsFor: 'query' stamp: 'jmv 6/17/2025 18:52:17' prior: 16977919!
                      methodsWithUnboundGlobals
	"Get all methods that use undeclared global objects that are not listed in Undeclared. For a clean image the result should be empty."
	"
	self assert: Smalltalk methodsWithUnboundGlobals isEmpty
	"
	^ self allSelect: [ :m |
		m literals anySatisfy: [ :l |
			l isVariableBinding and: [
				l key isSymbol and: [
					"avoid class-side methodClass literals"
					(m methodClass bindingOf: l key)
						ifNil: [
							(Undeclared
								associationAt: l key
								ifAbsent: nil) ~~ l ]
						ifNotNil: [ :b |
							b ~~ l ]]]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7275-RemoveEmptyClosures-JuanVuletich-2025Jun18-17h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7272] on 18 June 2025 at 6:03:40 pm'!
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'eem 12/18/2024 11:55:20' prior: 16860127!
                             finalizeEphemeron: anEphemeron

	"Remove the ephemeron from myself.  Note that no finalization of the ephemeron's key is done.
	 Here we are using ephemerons to clean up property tables."

	mutex critical:
		[self removeKey: anEphemeron key ifAbsent: nil]! !
!FinalizationRegistry methodsFor: 'finalization' stamp: 'eem 1/20/2025 17:02:57' prior: 16869046 overrides: 50334388!
       finalizeEphemeron: anEphemeron
	"Finalize the ephemeron's key and remove the ephemeron from myself.
	 N.B. Here we send #finalize since finalization is called for by placing
	 objects in a FinalizationRegistry. i.e. the response to the ephemeron
	 being triggered is a property of the container of the ephemeron, not
	 the ephemeron itself."

	self removeKey: anEphemeron key ifAbsent: nil.
	
	"Usually no executor is needed. The object that is about to be collected, the key needs to be finalized.
	 Some users may prefer to include an executor (an instance of ObjectFinalizer) as the value.
	 N.B. errors here will not stall the finalization process."
	
	(anEphemeron value ifNil: [anEphemeron key]) finalize! !
!UndeclaredVariable methodsFor: 'exception handling' stamp: 'jmv 6/17/2025 18:10:17' prior: 17000284 overrides: 16919632!
                            defaultAction
	
	| labels actions lines caption choice icons |
	
	labels := OrderedCollection new.
	actions := OrderedCollection new.
	lines := OrderedCollection new.
	icons := OrderedCollection new.
	
	self createMenuOptionsAddingTo: labels actions: actions icons: icons lines: lines.
	caption := 'Unknown variable: ' , name , ' please correct, or cancel:'.
	choice := (PopUpMenu labelArray: labels lines: lines icons: icons) startUpWithCaption: caption.
	
	self resume: (actions at: choice ifAbsent: nil).! !
!UnknownSelector methodsFor: 'exception handling' stamp: 'jmv 6/17/2025 18:04:32' prior: 17004612 overrides: 16919632!
          defaultAction 

	| alternatives labels lines caption choice icons |

	alternatives := Symbol possibleSelectorsFor: name.
	labels := Array streamContents: [:s | s nextPut: name; nextPutAll: alternatives; nextPut: 'cancel'].
	lines := {1. alternatives size + 1}.
	icons := Array new: labels size.
	icons at: 1 put: #acceptIcon.
	icons at: icons size put: #cancelIcon.
	caption := 'Unknown selector, please\confirm, correct, or cancel' withNewLines.
	
	choice := (PopUpMenu labelArray: labels lines: lines icons: icons) startUpWithCaption: caption.
	choice = 1 ifTrue: [self resume: name asSymbol].
	choice = labels size ifTrue: [self resume: nil].
	self resume: (alternatives at: choice - 1 ifAbsent: nil)! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'jmv 6/17/2025 18:53:42' prior: 16847082!
                             pushReceiverVariable: offset

	| var |
	(var := instVars at: offset + 1 ifAbsent: nil) == nil
		ifTrue:
			["Not set up yet"
			var := constructor codeInst: offset.
			instVars size < (offset + 1) ifTrue: [
				instVars := (Array new: offset + 1)
					replaceFrom: 1 to: instVars size with: instVars; yourself ].
			instVars at: offset + 1 put: var].
	stack addLast: var! !
!Decompiler methodsFor: 'private' stamp: 'eem 4/25/2017 16:07' prior: 16847375!
                          markTemp: tempVarNode asOutOfScope: scopeFlag
	tempVarNode scope: scopeFlag.
	tempReadCounts removeKey: tempVarNode ifAbsent: nil! !
!Process methodsFor: 'changing process state' stamp: 'jar 8/15/2022 12:48:39' prior: 16937170!
                            suspendAndUnblock
	"ar 12/7/2007 17:10:
	 Primitive. Stop the process that the receiver represents in such a way 
	 that it can be restarted at a later time (by sending the receiver the 
	 message resume). If the receiver represents the activeProcess, suspend it. 
	 Otherwise remove the receiver from the list of waiting processes.
	 The return value of this method is the list the receiver was previously on (if any)."

	<primitive: 88 error: ec>
	"ar 12/7/2007 17:10:
	 This is fallback code for VMs which only support the old primitiveSuspend which 
	 would not accept processes that are waiting to be run."
	 ^myList ifNotNil: "this allows us to use suspend multiple times"
		[:oldList|
		 myList := nil.
		 oldList remove: self ifAbsent: nil.
		 oldList]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'KLG 9/19/2022 10:42:35' prior: 16912809!
       balloonText
	"Answer balloon help text or nil, if no help is available.
	NB: subclasses may override such that they programatically
	construct the text, for economy's sake, such as model phrases in
	a Viewer.
	Allow for dynamic balloon text."

	^ (self valueOfProperty: #balloonText ifAbsent: nil) value.! !
!FindInSourceDialog methodsFor: 'scopes list' stamp: 'jmv 6/17/2025 18:56:03' prior: 16869228!
             scopesList
	| scopeClassName labelList |
	labelList := {
		'This method or text'.
		'All methods in image'. } asOrderedCollection.
	smalltalkEditor selectedClass ifNotNil:
		[ :scopeClass |
			scopeClassName := scopeClass name asString.
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := smalltalkEditor selectedMethod
				ifNotNil: [ :scopeMethod |CodePackage packageOfMethod: scopeMethod ifNone: nil]
				ifNil: [CodePackage packageOfClass: scopeClass ifNone: nil].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
	^labelList! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/17/2025 18:57:38' prior: 16896876!
                   layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.
	
	direction == #horizontal ifTrue: [
		self layoutSubmorphsHorizontallyIn: self layoutBounds ].

	direction == #vertical ifTrue: [
		self layoutSubmorphsVerticallyIn: self layoutBounds ].

	self layoutNeeded: false.! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 6/18/2025 17:49:26' prior: 16969517 overrides: 50333779!
        request: queryString initialAnswer: defaultAnswer do: acceptBlock
	"Non-modal. Method returns immediately.
	Uses acceptBlock to process user's answer later, when provided by them."
	
	^ self
		request: queryString
		centeredAt: self runningWorld activeHand morphPosition
		initialAnswer: defaultAnswer
		validationBlock: [:aString| true]
		acceptBlock: acceptBlock
		cancelBlock: nil! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 6/17/2025 18:57:50' prior: 16969559 overrides: 16923512!
                              request: queryString initialAnswer: defaultAnswer verifying: validationBlock
	"Modal. This method returns when an answer is provided."

	^self request: queryString initialAnswer: defaultAnswer verifying: validationBlock orCancel: nil! !
!PluggableListMorph methodsFor: 'dropping/grabbing' stamp: 'len 6/12/2022 12:54:46' prior: 16931473 overrides: 16911047!
                          acceptDroppingMorph: aMorph event: dropEvent
	| localPosition row dropSelectorArgument dropActionSelector args |
	localPosition := self internalizeFromWorld: dropEvent eventPosition.
	row := self rowAtLocation: localPosition ifNone: nil.
	dropSelectorArgument := aMorph
		valueOfProperty: #dropSelectorArgument
		ifAbsent: [self error: 'aMorph is missing dropSelectorArgument property'].
	dropActionSelector := self valueOfProperty: #dropActionSelector.
	args := dropActionSelector numArgs.
	args = 1 ifTrue: [ ^model perform: dropActionSelector with: dropSelectorArgument ].
	args = 2 ifTrue: [ ^model perform: dropActionSelector with: row with: dropSelectorArgument ].
	self error: 'dropActionSelector must be a 1- or 2-keyword symbol'! !
!PluggableListMorph methodsFor: 'events-processing' stamp: 'jmv 6/17/2025 18:56:15' prior: 16931739 overrides: 16911789!
  processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	scroller highlightedRow: (
		(self viewableArea containsPoint: localEventPosition) ifTrue: [
			self rowAtLocation: localEventPosition ifNone: nil]).
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1 ]! !
!PluggableListMorph methodsFor: 'keyboard navigation' stamp: 'jpb 8/16/2019 17:34:29' prior: 16931875!
       deleteAction
	"Handles deleting action, which happens when the user presses backspace or delete key within me"
	| deleteActionBlock |
	deleteActionBlock := self valueOfProperty: #deleteAction ifAbsent: nil.
	deleteActionBlock isNil
		ifTrue: [ self flash ]
		ifFalse: [ deleteActionBlock value ].
	^self! !
!PluggableListMorphByItem methodsFor: 'model access' stamp: 'jmv 6/17/2025 18:06:07' prior: 16932302 overrides: 16932047!
                   setSelectionIndex: anInteger
	"Change the model's selected item to be the one at the given index."

	| item |
	setIndexSelector ifNotNil: [
		item := itemList at: anInteger ifAbsent: nil.
		model perform: setIndexSelector with: item.
		self privateVisualSelectionIndex: self getCurrentSelectionIndex.
		^ true ].
	^false
	! !
!BrowserWindow class methodsFor: 'services' stamp: 'jmv 6/17/2025 18:11:29' prior: 16800812!
                             findClassFrom: potentialClassNames ifFound: aBlock with: pattern

	| exactMatch foundClass index  classNames toMatch |
	pattern isEmpty ifTrue: [^self flash].

	"If the user entered an exact class name (including case), just use it."
	(potentialClassNames includes: pattern) ifTrue: [
		foundClass := Smalltalk at: pattern asSymbol.
		aBlock value: foundClass.
		^self ].

	toMatch := (pattern copyWithout: $.) asLowercase withBlanksTrimmed.
	classNames := self classNamesFrom: potentialClassNames with: pattern matching: toMatch.
	classNames isEmpty ifTrue: [^self flash].

	exactMatch := classNames detect: [ :each | each asLowercase = toMatch] ifNone: nil.
	index := self indexOfClassFrom: classNames exactMatch: exactMatch.
	index = 0 ifTrue: [^self flash].

	foundClass := Smalltalk at: (classNames at: index) asSymbol.
	aBlock value: foundClass.! !
!BrowserWindow class methodsFor: 'services' stamp: 'jmv 6/17/2025 18:54:10' prior: 16800842!
            indexOfClassFrom: classNames exactMatch: exactMatch

	| options |
	
	classNames size = 1 ifTrue: [ ^1 ].
	
	options := exactMatch
		ifNil: [ PopUpMenu labelArray: classNames lines: #()]
		ifNotNil: [
			classNames remove: exactMatch ifAbsent: nil.
			classNames addFirst: exactMatch.
			PopUpMenu labelArray: classNames lines: #(1)].
		
	^options startUpMenu! !
!WorldMorph methodsFor: 'stepping' stamp: 'jmv 6/17/2025 18:54:16' prior: 17018655!
  runLocalStepMethods: nowTime
	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world."

	| timerBefore timerAfter stepMessage |
	timerAfter := nowTime.
	[ stepList notEmpty and: [ (stepMessage := stepList first) scheduledTime <= nowTime ]] 
		whileTrue: [
			(stepMessage receiver shouldGetStepsFrom: self)
				ifFalse: [
					stepList remove: stepMessage ifAbsent: nil]
				ifTrue: [
					timerBefore := timerAfter.
					stepMessage valueAtTime: nowTime.
					timerAfter := Time localMillisecondClock.
					"No step message should take more than 50% CPU. 
					Reschedule it only after its required time is elapsed again."
					stepMessage rescheduleAfter: timerAfter + (timerAfter - timerBefore).
					"We've just updated the  scheduled time for stepMessage.
					It might have been that stepMessage was removed altogether from stepList.
					It also may be the case that stepList got added or removed other elements while on #valueAtTime:
					Just reSort. It will be ok in any case."
					stepList reSort ]].! !
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 6/18/2025 17:51:35' prior: 16886455!
                               rowAtLocation: aPoint ifNone: aNoneBlock

	| potentialRowNumber |
	
	potentialRowNumber := aPoint y // font lineSpacing + 1.
	
	^(listItems isInBounds: potentialRowNumber) 
		ifTrue: [ potentialRowNumber ]
		ifFalse: [ aNoneBlock value ]! !
!HandMorph methodsFor: 'private' stamp: 'jmv 6/17/2025 18:58:02' prior: 16878976!
                             forgetGrabMorphDataFor: aMorph

	grabMorphData 
		removeKey: aMorph 
		ifAbsent: nil "no error"! !
!DynamicMenuBuilder methodsFor: 'building - private' stamp: 'jmv 6/17/2025 18:54:21' prior: 16852776!
                       addSubMenuTo: aMenuItem

	subMenuItemsDefinition 
		at: aMenuItem contents
		ifPresent: [ :subMenuDefinition | self addSubMenuTo: aMenuItem from: subMenuDefinition ]
		ifAbsent: nil! !
!FileIOAccessor methodsFor: 'actions' stamp: 'pb 5/25/2016 00:32' prior: 16866231!
                    deleteFile: fullPathName
	^self deleteFile: fullPathName ifAbsent: nil! !
!DirectoryEntry methodsFor: 'dictionary-like' stamp: 'pb 5/25/2016 00:31' prior: 16850204!
                           removeKey: localFileName 
	self removeKey: localFileName ifAbsent: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7276-RemoveEmptyClosures-JuanVuletich-2025Jun18-17h40m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7272] on 18 June 2025 at 6:17:39 pm'!
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 6/18/2025 18:16:54' prior: 16820671!
          withSubclassesThatDefineInstanceVariable: aName do: foundBlock ifNone: noneBlock

	| definingSubclasses |

	definingSubclasses := self allSubclasses select: [ :aSubclass |
		aSubclass definesInstanceVariableNamed: aName ].

	^definingSubclasses isEmpty
		ifTrue: [ noneBlock value ]
		ifFalse: [ foundBlock value: definingSubclasses ]! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 6/17/2025 18:58:06' prior: 16961690!
                       debugIt

	self lineSelectAndEmptyCheck: [^self].
	self 
		afterCompiling: self selection string
		do: [ :compiler :method :receiver :context |
			(method notNil and: [method isQuick not]) ifTrue: [
				self debug: method receiver: receiver in: context ]]
		ifFail: nil.! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 6/17/2025 18:54:38' prior: 16961847!
                        selectNodeUnderCursorForInspectionIn: aMethodNode 
	
	aMethodNode
		withParseNodeIncluding: self startIndex
		do: [ :nodeUnderCursor | self selectForInspection: nodeUnderCursor in: aMethodNode ]
		ifAbsent: nil! !
!SmalltalkEditor methodsFor: 'menu & kbd shortcuts' stamp: 'jmv 6/17/2025 18:56:27' prior: 16963475!
     findMethodSourceContainingIt
	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).  Slow!!"
	| searchString selection scopeClass scopeClassName includeSubclasses includeSuperclasses labelList package |

	true ifTrue: [
		^FindInSourceDialog openOn: self ].

	searchString := StringRequestMorph
		request: 'Enter search text:'
		initialAnswer: self selectedString
		orCancel: [^self].
	
	scopeClass := self selectedClass.
	scopeClassName := scopeClass name asString.
	includeSubclasses := false.
	includeSuperclasses := false.

	labelList := {
		'This method'. 
		'All methods in image'. } asOrderedCollection.
	(scopeClass notNil)
		ifTrue: [
			labelList  addAll: {
				'Class ', scopeClassName printString.
				'Class ', scopeClassName printString, ' and subclasses'.
				'Class ', scopeClassName printString, ', subclasses, and superclasses'.}.
			package := self codeProvider isEditingExistingMethod
				ifTrue: [CodePackage packageOfMethod: self codeProvider currentCompiledMethod asMethodReference ifNone: nil]
				ifFalse: [CodePackage packageOfClass: scopeClass ifNone: nil].
			package ifNotNil: [labelList add: 'In my package: ', package packageName]].
				
	selection := (SelectionMenu labelList: labelList selections: nil) startUpWithCaption: 'Search Scope'.

	(selection = 0) ifTrue:[^self].
	(selection = 1) "This method"
		ifTrue:[^self find: searchString].
	(selection = 2) "All methods in image"
		ifTrue:[scopeClass := nil].
	"(selection = 3) ifTrue:[]. ""Class only - nothing to do"
	(selection = 4) "Class and subclasses"
		ifTrue:[includeSubclasses := true].
	(selection = 5) "Class, subclasses, and superclasses"
		ifTrue:[
			includeSubclasses := true.
			includeSuperclasses := true].
	(selection = 6) "In my package if any "
		ifTrue: [^ Smalltalk browseMethodsWithSourceString: searchString in: package].
	Smalltalk browseMethodsWithSourceString: searchString scopeClass: scopeClass includeSubclasses: includeSubclasses includeSuperclasses: includeSuperclasses! !
!MethodCategoriesPrompter methodsFor: 'categories initialization - private' stamp: 'jmv 6/17/2025 18:54:45' prior: 16905406!
                      initializeCategoriesWhenMeta: classCategories

	categories add: Categorizer instanceCreation.
	classCategories remove: Categorizer instanceCreation ifAbsent: nil.
	reject add: Categorizer instanceCreation! !
!TrieNode methodsFor: 'private' stamp: 'jmv 6/17/2025 18:56:33' prior: 16999278!
                               removeChildFor: aString characterIndex: i
	"Answer child at childCode.
	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.
		otherwise, just answer nil."
	| nextSegmentStart nextSegmentFirst |

	nextSegmentStart := i + segmentSize.
	nextSegmentFirst := nextSegmentStart > aString size
		ifTrue: [TrieNode characterForLeaf]
		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].

	"Just one child, if adding, convert references to a collection"
	childrenFirstChars isCollection ifFalse: [
		childrenFirstChars = nextSegmentFirst
			ifTrue: [ childrenFirstChars := nil. children := nil ].
		^self ].
	
	"Already more than one child."
	childrenFirstChars
		findBinaryIndex: [ :each |
			each = nextSegmentFirst ifTrue: [ 0 ]
				ifFalse: [each > nextSegmentFirst ifTrue: [-1] ifFalse: [1]]]
		do: [ :found |
			childrenFirstChars size = 2
				ifTrue: [		"Two children: remove the arrays"
					childrenFirstChars := childrenFirstChars at: 3-found.
					children := children at: 3-found ]
				ifFalse: [	"More than two children. condense the arrays"
					childrenFirstChars := (childrenFirstChars copyFrom: 1 to: found-1), 
						(childrenFirstChars copyFrom: found+1 to: childrenFirstChars size).
					children := (children copyFrom: 1 to: found-1), (children copyFrom: found+1 to: children size) ]]
		ifNone: nil.! !
!MethodReference methodsFor: 'queries' stamp: 'jmv 6/17/2025 18:06:28' prior: 16907931!
       actualClass 

	^self actualClassIfAbsent: nil! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 6/17/2025 18:07:22' prior: 16807753!
                      noteRenameClass: class as: newName 
	"Include indication that a class has been renamed."

	| recorder |
	(recorder := self changeRecorderFor: class)
		noteChangeType: #rename;
		noteNewName: newName asSymbol.
		
	"store under new name (metaclass too)"
	changeRecords at: newName put: recorder.
	changeRecords removeKey: class name.
	self noteClassStructure: class.

	recorder := changeRecords at: class class name ifAbsent: nil.
	recorder ifNotNil: [
		changeRecords at: (newName, ' class') put: recorder.
		changeRecords removeKey: class class name.
		recorder noteNewName: newName , ' class' ].

	self hasUnsavedChanges: true! !
!PopUpMenu methodsFor: 'accessing' stamp: 'jmv 6/17/2025 18:06:34' prior: 16934515!
                     iconAt: aPosition

	^icons at: aPosition ifAbsent: nil! !
!ExtractToTemporary methodsFor: 'private - applying steps' stamp: 'jmv 6/17/2025 18:56:40' prior: 16864458!
                          positionToInsertNewTemporaryVariableAssignment

	| siblings |
	
	siblings := self siblingStatementsOfTemporaryAssignment.
	siblings do: [ :sibling |
		(completeSourceRanges at: sibling) 
			detect: [ :range | range includesAllOf: intervalToExtract ]
			ifFound: [ :range | ^range first ]
			ifNone: nil].
		
	self shouldNotHappenBecause: 'sibling should be part of completeSourceRanges'! !
!InlineTemporaryVariable methodsFor: 'applying primitives - private' stamp: 'FB 5/2/2021 18:20:30' prior: 16885818!
      selectCompleteRangesOfAssignmentsToTemporaryFrom: aParseNode thatMatch: aConditionBlock

	| assignments |

	assignments := Set new.
	aParseNode nodesDo: [:aNode |
		(self nodeIsAssignmentToTemporaryToInline: aNode)
			ifTrue: [
				| nodeRanges satisfyingRanges |
				nodeRanges := methodNode completeSourceRanges at: aNode ifAbsent: nil.
				satisfyingRanges := (nodeRanges select: aConditionBlock)
					collect:[:range | range asSourceCodeInterval
						expandUntilStartOfNextStatementOn: methodNode sourceText].
				assignments addAll: (satisfyingRanges)]
	].

	^assignments






! !
!ScopedRefactoring class methodsFor: 'implementors and senders' stamp: 'HAW 3/19/2025 09:11:50' prior: 16953758!
   addImplementorsOf: anOldSelector to: implementors andSendersTo: senders of: aPotentialClassToRefactor

	| potentialImplementor |

	"Phil B. requested to avoid refactoring OMeta2 classes, so right now
	it avoids implementors and senders whose compilerClass is not register
	as allowed compiler - Hernan"
	(self canRefactor: aPotentialClassToRefactor) ifFalse: [ ^self ].

	potentialImplementor := aPotentialClassToRefactor compiledMethodAt: anOldSelector ifAbsent: nil.
	potentialImplementor ifNotNil: [ implementors add: potentialImplementor ].

	(aPotentialClassToRefactor whichSelectorsReferTo: anOldSelector) do: [ :aSelector |
		self addTo: senders referencesTo: anOldSelector from: aSelector in: aPotentialClassToRefactor ]! !
!ChangeSelectorKeepingParameters class methodsFor: 'pre-conditions' stamp: 'jmv 6/17/2025 18:56:46' prior: 16807137!
               warnIfImplementionsOf: aNewSelector overridesImplementationInSuperclassesOf: implementorsCollection

	implementorsCollection do: [:anImplementor |
		anImplementor methodClass
			withSuperclassThatIncludesSelector: aNewSelector
			do: [ :aSuperclass | self warnImplementionOf: aNewSelector in: anImplementor methodClass willOverrideImplementationIn: aSuperclass ]
			ifNone: nil]! !
!AddParameter class methodsFor: 'pre-conditions' stamp: 'jmv 6/17/2025 18:50:11' prior: 16780204!
assertNewParameterValueCompiles: trimmedNewParameterValue

	^ [ Parser new parse: trimmedNewParameterValue readStream class: self noPattern: true notifying: nil ifFail: nil ]
		on: SyntaxErrorNotification 
		do: [ :error | self signalNewParameterValueDoesNotCompile ].! !
!AddParameter class methodsFor: 'exceptions' stamp: 'jmv 6/17/2025 18:11:39' prior: 16780261!
                  classesDefiningInstanceVariable: aName inAny: implementors
 
	^ implementors 
		inject: Set new
		into: [ :classesDefiningInstVar :implementor | 
			(implementor methodClass whichClassDefinesInstanceVariable: aName ifNone: nil) ifNotNil: [ :classDefiningInstVar |
				classesDefiningInstVar add: classDefiningInstVar ].
			classesDefiningInstVar ]
! !
!TransferMethod class methodsFor: 'warnings' stamp: 'jmv 6/17/2025 18:54:58' prior: 16998595!
  warnIfMethodIsImplementedInSuperClass: aMethodToTransfer

	aMethodToTransfer methodClass superclass
		compiledMethodAt: aMethodToTransfer selector
		ifPresent: [ :superclassMethod | (self shouldWarnIf: aMethodToTransfer isImplementedInSuperclassAs: superclassMethod)
			ifFalse: [ self refactoringWarning: self methodImplementedInSuperclassWarningMessage ]]
		ifAbsent: nil! !
!RefactoringApplier class methodsFor: 'appliers - private' stamp: 'jmv 6/17/2025 18:55:03' prior: 16945033!
                           resetApplierAt: anApplierId

	Appliers removeKey: anApplierId ifAbsent: nil! !
!NewInstanceVariablePrecondition methodsFor: 'pre-conditions' stamp: 'jmv 6/17/2025 18:58:12' prior: 16918863!
  assertIsNotAlreadyDefined
	
	^ classToAddInstVar 
		withClassesThatDefineInHierarchyInstanceVariable: instVarName 
		do: [ :definingClasses | self signalAlreadyDefinedInAll: definingClasses ]
		ifNone: nil.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7277-RemoveEmptyClosures-JuanVuletich-2025Jun18-18h03m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7270] on 18 June 2025 at 12:48:09 pm'!
!FileList methodsFor: 'file list' stamp: 'fgz 6/18/2025 12:44:43' prior: 16867117!
                  fileList
	"Answer the list of display strings for the files in the current volume."

	| font namePad sizePad sizeWithCommasPad |
	font := Preferences at: #standardListFont.
	namePad := list inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad := (list inject: 0 into: [ :mx :entry | entry fileSize ifNil: [mx] ifNotNil: [:fs| mx max: fs]]) printString size.
	sizeWithCommasPad := (list inject: 0 into: [ :mx :entry | mx max: (entry fileSize ifNil: [0])]) printStringWithCommas size.
	^list collect: [ :e |
		self fileNameFormattedFrom: e
			namePad: namePad
			sizePad: sizePad
			sizeWithCommasPad: sizeWithCommasPad ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7278-FileList-fix-FelipeZak-2025Jun18-12h41m-fgz.001.cs.st----!

'From Cuis7.5 [latest update: #7265] on 20 June 2025 at 11:40:59 am'!
!PreferenceSet class methodsFor: 'services' stamp: 'eem 6/20/2025 11:40:47' prior: 16936964!
                      readAndApplyUserPrefs
	"
	PreferenceSet readAndApplyUserPrefs
	"
	| file |
	file := DirectoryEntry userBaseDirectory // 'UserPrefs.txt'.
	file exists ifTrue: [
		file readStreamDo: [ :stream |
			[ stream atEnd ] whileFalse: [ | line parts |
				line := stream nextLine.
				parts := line substringsSeparatedBy: $=.
				[ | pref value |
					pref := Preferences instanceAt: parts first asSymbol.
					value := parts second.
					value first == $# ifTrue: [ value := (value withoutPrefix: '#') asSymbol ].
					pref value: value.
					pref justReadFromDisk.
				]
					on: Error
					do: [ :error |
						'--- UserPrefs.txt Error' print.
						error print.
						line print ].
				]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7279-PreferenceSet-typo-EliotMiranda-11h43m-eem.001.cs.st----!

'From Cuis7.5 [latest update: #7279] on 26 June 2025 at 1:00:31 pm'!
!WorldMorph methodsFor: 'drawing' stamp: 'jmv 6/26/2025 12:53:00' prior: 17018217!
displayWorldOn: aMorphicCanvas
	"Update this world's display on the argument."

	| allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"

	"Restore world drawing under hands and their carried morphs"
	(Preferences at: #cacheDisplayContentWhenMovingMorphs) ifTrue: [
		activeHand restoreSavedPatchOn: aMorphicCanvas ].

	"Update #displayBounds for all dirty morphs (marked as such with #redrawNeeded).
	Also add the updated bounds to aDamageRecorder, and update bounds of morphs carried by hand."
	aMorphicCanvas boundsFinderCanvas updateBoundsIn: self addDamageTo: damageRecorder.

	"repair world's damage on canvas"
	allDamage := aMorphicCanvas drawWorld: self repair: damageRecorder.
	"allDamage ifNotNil: [Display border: allDamage width: 3 fillColor: Color random].	 'Debugging Aid'."
	self submorphNeedsRedraw: false.
	self needsRedraw: false.
	aMorphicCanvas newClipRect: nil.

	"Check which hands need to be drawn.
	(they are not the hardware mouse pointer and carry morphs)"
	self ifHandToBeDrawnForDamage: allDamage do: [
		(Preferences at: #cacheDisplayContentWhenMovingMorphs)
			ifTrue: [ allDamage := (activeHand savePatchFrom: aMorphicCanvas) quickMerge: allDamage ]
			ifFalse: [ allDamage := activeHand displayFullBoundsForPatch quickMerge: allDamage ].
		aMorphicCanvas fullDrawHand: activeHand.
		activeHand needsRedraw: false.
		activeHand submorphNeedsRedraw: false ].

	"Copy altered rects to Display"
	allDamage ifNotNil: [
		aMorphicCanvas drawsOnDisplay
			ifTrue: [
				"For instance for Linux and Windows. Drawing was done to Display, but given that #deferUpdates: is on,
				we need to specifically ask for changes to be visually effective."
				DisplayScreen isDisplayExtentOk ifTrue: [
					Display forceToScreen: allDamage ]]
			ifFalse: [
				"For Mac, drawing was done to off-Display canvas. Copy content to Display.
				#deferUpdates: is off, so no additional indication to show Display contents is needed."
				aMorphicCanvas showAt: self viewBox origin invalidRect: allDamage ]].! !
!MorphicCanvas methodsFor: 'testing' stamp: 'jmv 6/26/2025 12:52:04' prior: 16915687!
  drawsOnDisplay
	"Answer true if we actually draw on (Display shallowCopy)"
	^form == Display | (form bits == Display bits)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7280-WorldAndHandTweaks-optionalNoDetachedDisplayOnMac-JuanVuletich-2025Jun26-12h49m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7280] on 26 June 2025 at 5:21:44 pm'!
!Transcript class methodsFor: 'private' stamp: 'jmv 6/26/2025 16:11:15' prior: 16997755!
   displayEngine
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	"
	Transcript releaseClassCachedState
	"
	(displayEngine isNil or: [
		displayEngine class ~= BitBltCanvasEngine]) ifTrue: [
			displayEngine := BitBltCanvasEngine toForm: Display shallowCopy].
	^ displayEngine! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 6/26/2025 16:11:07' prior: 16997789!
  display
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayOnDisplay.
		Display forceToScreen: bounds ].
	"So any morph in front of us is repaired when Morphic cycles.
	This includes, for instance, the TranscriptWindow that shows our contents if showOnDisplay is false"
	UISupervisor whenUIinSafeState: [ self triggerEvent: #redrawTranscriptArea ].! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 6/26/2025 16:11:02' prior: 16997845!
                   displayUnfinishedEntry
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayUnfinishedEntryOnDisplay ifNotNil: [ :damage |
			Display forceToScreen: bounds ]]! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

	Transcript releaseClassCachedState!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7281-TranscriptOnDisplayCopy-JuanVuletich-2025Jun26-17h21m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7287] on 26 June 2025 at 6:02:54 pm'!
!ProgressInitiationException methodsFor: 'exceptionDescription' stamp: 'jmv 6/26/2025 18:02:44' prior: 16939858 overrides: 16861277!
 defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame lastDrawTime |
	f := FontFamily defaultFamilyAndPointSize.
	h := f lineSpacing * 3//2.
	textWidth := (f widthOfString: progressTitle) + h.
	width := 150 max: textWidth.

	textForm := Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame := Rectangle center: aPoint extent: (width@h) roundedToEven.
	textFrame := `0@0` extent: width@h.
	textFrame := textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + `0@2`.
	outerFrame := barFrame merge: textFrame.
	delta := outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame := barFrame translatedBy: delta.
	textFrame := textFrame translatedBy: delta.
	outerFrame := outerFrame translatedBy: delta.
	range := maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame := barFrame insetBy: 2.
	textForm displayAt: textFrame topLeft.
	Display fillBlack: barFrame.
	Display fillWhite: innerBarFrame.
	Display forceToScreen: outerFrame.
	lastDrawTime := Time localMillisecondClock.
	result := workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal := barVal ]
			ifNil: [
				currentVal := currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal := minVal ]].
		filledWidth := ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		Time localMillisecondClock - lastDrawTime > 100 ifTrue: [
			textForm displayAt: textFrame topLeft.
			Display fillBlack: barFrame.
			Display fillWhite: innerBarFrame.
			Display fillGray: (barFrame topLeft + `2@2` extent: filledWidth@(h-4)).
			Display forceToScreen: outerFrame.
			lastDrawTime := Time localMillisecondClock ]].
	UISupervisor ui ifNotNil: [ :ui | ui invalidateDisplayRect: outerFrame for: nil ].
	self resume: result! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7282-ProgressBar-Performance-JuanVuletich-2025Jun26-18h02m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7282] on 26 June 2025 at 5:33:59 pm'!

DisplayScreen removeSelector: #fillShape:fillColor:at:!

!methodRemoval: DisplayScreen #fillShape:fillColor:at: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:09'!
fillShape: aShapeForm fillColor: aColor at: location
	super fillShape: aShapeForm fillColor: aColor at: location.
	DisplayScreen screenUpdateRequired: nil!

DisplayScreen removeSelector: #eraseShape:!

!methodRemoval: DisplayScreen #eraseShape: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:09'!
eraseShape: bwForm
	super eraseShape: bwForm.
	DisplayScreen screenUpdateRequired: nil!

DisplayScreen removeSelector: #copyBits:from:at:clippingBox:rule:!

!methodRemoval: DisplayScreen #copyBits:from:at:clippingBox:rule: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:09'!
copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule
	super copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule.
	DisplayScreen screenUpdateRequired: clipRect!

DisplayScreen removeSelector: #copy:from:in:rule:!

!methodRemoval: DisplayScreen #copy:from:in:rule: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:09'!
copy: destRectangle from: sourcePt in: sourceForm rule: rule
	super copy: destRectangle from: sourcePt in: sourceForm rule: rule.
	DisplayScreen screenUpdateRequired: destRectangle!

DisplayScreen removeSelector: #copyBits:at:translucent:!

!methodRemoval: DisplayScreen #copyBits:at:translucent: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:09'!
copyBits: sourceForm at: destOrigin translucent: factor
	super copyBits: sourceForm at: destOrigin translucent: factor.
	DisplayScreen screenUpdateRequired: (destOrigin extent: sourceForm extent)!

DisplayScreen removeSelector: #copyBits:from:at:clippingBox:rule:map:!

!methodRemoval: DisplayScreen #copyBits:from:at:clippingBox:rule:map: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:09'!
copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule map: map
	super copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule map: map.
	DisplayScreen screenUpdateRequired: clipRect!

DisplayScreen removeSelector: #fillFromXYColorBlock:!

!methodRemoval: DisplayScreen #fillFromXYColorBlock: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:09'!
fillFromXYColorBlock: colorBlock
	super fillFromXYColorBlock: colorBlock.
	DisplayScreen screenUpdateRequired: nil!

DisplayScreen removeSelector: #fill:rule:fillColor:!

!methodRemoval: DisplayScreen #fill:rule:fillColor: stamp: 'Install-7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st 7/15/2025 11:02:09'!
fill: aRectangle rule: anInteger fillColor: aForm 
	super fill: aRectangle rule: anInteger fillColor: aForm.
	DisplayScreen screenUpdateRequired: aRectangle!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7283-DisplayScreen-Cleanup-JuanVuletich-2025Jun26-17h32m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7282] on 26 June 2025 at 5:35:08 pm'!
!Form class methodsFor: 'instance creation' stamp: 'jmv 6/26/2025 16:52:37' prior: 16875454!
                              fakeSphereAt: aPoint diameter: diameter color: aColor
	"Create a form which contains a round black dot."
	| bb rect d p |
	bb := BitBltCanvasEngine toForm: Display.
	bb fillColor: aColor.
	bb combinationRule: Form blend.
	rect := aPoint extent: diameter.
	bb fillOval: rect.
	p := (diameter * 2 // 5) asPoint + aPoint.
	#(2 3 4 5 6 ) do: [ :i |
		"simulate facade by circles of gray"
		bb fillColor: `Color white alpha: 0.3`.
		d := i * diameter // 10.
		rect := Rectangle
			center: p
			extent: d roundedToEven.
		bb fillOval: rect ].
	Display forceToScreen.
"
	Form fakeSphereAt: 70@70 diameter: 40 color:  (Color red alpha: 0.5)
"! !
!BitBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:40:00' prior: 16790999!
            alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 := Color cachedColormapFrom: Display depth to: 32.
		map32toD := Color cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff := Form extent: 500@50 depth: 32.
	dispToBuff := BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Color red alpha: i/10)
						rule: Form blend].
	buffToDisplay := BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.
	Display forceToScreen.

	"Create a brush with radially varying alpha"
	brush := Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Color red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize := 100.
	buff := Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff := BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff := BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff := BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor isMouseButton2Pressed] whileFalse:
		[prevP := nil.
		buffRect := Sensor mousePoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor isMouseButton1Pressed] whileTrue:
			["Here is the painting loop"
			p := Sensor mousePoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP := p].
				(p dist: prevP) > buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta := (p-prevP) theta.
					p := ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect := p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta := brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect := buffRect translatedBy: delta negated.
					newBuffRect
						areasOutside: buffRect
						do: [ :r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin ].
					buffRect := newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect := (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				Display forceToScreen: updateRect.
				prevP := p]]]! !
!BitBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:40:23' prior: 16791122!
                exampleColorMap	"BitBlt exampleColorMap"
	"This example shows what one can do with the fixed part of a color map. The color map, as setup below, rotates the bits of a pixel all the way around. Thus you'll get a (sometime strange looking ;-) animation of colors which will end up exactly the way it looked at the beginning. The example is given to make you understand that the masks and shifts can be used for a lot more than simply color converting pixels. In this example, for instance, we use only two of the four independent shifters."
	| cc bb |
	cc := ColorMap masks: {
		1 << (Display depth-1). "mask out high bit of color component"
		1 << (Display depth-1) - 1. "mask all other bits"
		0.
		0}
		shifts: {
			1 - Display depth. "shift right to bottom most position"
			1. "shift all other pixels one bit left"
			0.
			0}.
	bb := BitBlt toForm: Display.
	bb 
		sourceForm: Display;
		combinationRule: 3;
		colorMap: cc.
	1 to: Display depth do: [ :i |
		bb copyBits.
		Display forceToScreen.
	]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:55:19' prior: 17015131!
                           test1
	"
	Display restoreAfter: [WarpBlt test1]
	"
	"Demonstrates variable scale and rotate"
	| warp pts r1 p0 p ext box |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 := Rectangle originFromUser: 50@50.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 := Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp := (self toForm: Display)
		clipRect: (0@0 extent: r1 extent*5);
		sourceForm: Display;
		combinationRule: Form over.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt inverseRotatedBy: (p-p0) theta about: r1 center].
		ext := (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.
		box := (r1 extent*5-ext//2 extent: ext).
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box ]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:55:34' prior: 17015163!
    test12
	"
	Display restoreAfter: [WarpBlt test12]
	"
	"Just like test1, but comparing smooth to non-smooth warps"
	| warp pts r1 p0 p ext warp2 box |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 := Rectangle originFromUser: 50@50.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 := Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp := (self toForm: Display)
		cellSize: 2;  "installs a colormap"
		clipRect: (0@0 extent: r1 extent*5);
		sourceForm: Display;
		combinationRule: Form over.
	warp2 := (self toForm: Display)
		clipRect: ((0@0 extent: r1 extent*5) translatedBy: 250@0);
		sourceForm: Display;
		combinationRule: Form over.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt inverseRotatedBy: (p-p0) theta about: r1 center].
		ext := (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.
		box := (r1 extent*5-ext//2 extent: ext).
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box.
		box := ((r1 extent*5-ext//2 extent: ext) translatedBy: 250@0).
		warp2 copyQuad: pts toRect: box.
		Display forceToScreen: box.
		]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:55:51' prior: 17015206!
           test1Mirrored
	"
	Display restoreAfter: [WarpBlt test1Mirrored]
	"
	"Demonstrates variable scale and rotate"
	| warp pts r1 p0 p ext box |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 := Rectangle originFromUser: 50@50.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 := Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp := (self toForm: Display)
		clipRect: (0@0 extent: r1 extent*5);
		sourceForm: Display;
		combinationRule: Form over.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := {r1 topLeft. r1 topRight. r1 bottomRight. r1 bottomLeft}
			collect: [:pt | pt inverseRotatedBy: (p-p0) theta about: r1 center].
		ext := (r1 extent*((p-p0) r / 20.0 max: 0.1)) asIntegerPoint.
		box := (r1 extent*5-ext//2 extent: ext).
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box ]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:56:09' prior: 17015239!
                    test3
	"
	Display restoreAfter: [WarpBlt test3]
	"
	"The Squeak Release Mandala - 9/23/96 di"

	"Move the mouse near the center of the square.
	Up and down affects shrink/grow
	Left and right affect rotation angle"
	| warp pts p0 p box map d t |
	box := 100@100 extent: 300@300.
	Display border: (box expandBy: 2) width: 2.

	"Make a color map that steps through the color space"
	map := (Display depth > 8
		ifTrue: ["RGB is a bit messy..."
				d := Display depth = 16 ifTrue: [5] ifFalse: [8].
				(1 to: 512) collect: [:i | t := i bitAnd: 511.
					((t bitAnd: 16r7) bitShift: d-3)
					+ ((t bitAnd: 16r38) bitShift: d-3*2)
					+ ((t bitAnd: 16r1C0) bitShift: d-3*3)]]
		ifFalse: ["otherwise simple"
				1 to: (1 bitShift: Display depth)])
			as: Bitmap.
	warp := (WarpBlt toForm: Display)
		clipRect: box;
		sourceForm: Display;
		colorMap: map;
		combinationRule: Form over.
	p0 := box center.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := (box insetBy: p y - p0 y) innerCorners
			collect: [:pt | pt inverseRotatedBy: p x - p0 x / 50.0 about: p0].
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box ]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:56:29' prior: 17015278!
      test4
	"
	Display restoreAfter: [WarpBlt test4]
	"
	"The Squeak Release Mandala - 9/23/96 di
	This version does smoothing"

	"Move the mouse near the center ofhe square.
	Up and dn affects shrink/grow
	Left and right affect rotation angle"
	| warp pts p0 p box |
	box := 100@100 extent: 300@300.
	Display border: (box expandBy: 2) width: 2.

	warp := (WarpBlt toForm: Display)
		clipRect: box;
		sourceForm: Display;
		cellSize: 2;  "installs a colormap"
		combinationRule: Form over.
	p0 := box center.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := (box insetBy: p y - p0 y) innerCorners
			collect: [:pt | pt inverseRotatedBy: p x - p0 x / 50.0 about: p0].
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box ]! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:56:44' prior: 17015305!
                   test5
	"
	Display restoreAfter: [WarpBlt test5]
	"
	"Demonstrates variable scale and rotate"
	| warp pts r1 p0 p box |
	Utilities informUser: 'Choose a rectangle with interesting stuff'
		during: [r1 := Rectangle fromUser.
				Sensor waitNoButton].
	Utilities informUser: 'Now click down and up
and move the mouse around the dot'
		during: [p0 := Sensor waitClickButton.
				(Form dotOfSize: 8) displayAt: p0].
	warp := (self toForm: Display)
		cellSize: 1;
		sourceForm: Display;
		cellSize: 2;  "installs a colormap"
		combinationRule: Form over.
	[Sensor isAnyButtonPressed] whileFalse:
		[p := Sensor mousePoint.
		pts := {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}
			collect: [:pt | pt inverseRotatedBy: (p-p0) theta about: r1 center].
		box := (r1 translatedBy: r1 width@0).
		warp copyQuad: pts toRect: box.
		Display forceToScreen: box ]
! !
!WarpBlt class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:57:02' prior: 17015335!
         testSourceDestOverlap
	"Show that if source and destination are the same, then source quad and dest rect should not overlap,
	or data will be lost.
	WarpBlt testSourceDestOverlap
	"
	| warp box | 
	warp := (WarpBlt toForm: Display)
		sourceForm: Display;
		combinationRule: Form over.
	box := (0@0 extent: 160@160).
	warp copyQuad: {0@0. 160@0. 160@160. 0@160} toRect: box.
	Display forceToScreen: box.! !
!CharacterSequence methodsFor: 'displaying' stamp: 'jmv 6/26/2025 16:46:27' prior: 16814821!
             displayAt: aPoint 
	"Display the receiver as a DisplayText at aPoint on the display screen."

	self displayOn: Display at: aPoint.
	Display forceToScreen.! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 6/26/2025 16:33:22' prior: 16998230!
           endEntry
	| c d cb |
	c := self contents.
	DisplayScreen isDisplayExtentOk ifFalse: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame := frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d := textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb := textComposition characterBlockAtPoint:
			`0@0` + (0@(d+FontFamily defaultLineSpacing)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit := position := collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		drawTextComposition: textComposition
		at: `4@4` + frame topLeft
		extent: Display extent
		color: `Color black`
		selectionColor: `Color blue`.
	Display forceToScreen.! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 6/26/2025 16:35:38' prior: 50335330!
                 displayUnfinishedEntry
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayUnfinishedEntryOnDisplay ifNotNil: [ :damage |
			Display forceToScreen: damage ]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7284-DisplayScreen-cleanup-JuanVuletich-2025Jun26-17h33m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7280] on 26 June 2025 at 5:01:47 pm'!

DisplayScreen class removeSelector: #screenUpdateRequired:!

!methodRemoval: DisplayScreen class #screenUpdateRequired: stamp: 'Install-7285-screenUpdateRequired-removal-JuanVuletich-2025Jun26-17h00m-jmv.001.cs.st 7/15/2025 11:02:09'!
screenUpdateRequired: aRectangle

	ScreenUpdaterProcess ifNotNil: [
		Damage := aRectangle
			ifNotNil: [ aRectangle quickMerge: Damage ]
			ifNil: [ Display boundingBox ].
		ScreenUpdaterSemaphore signal ].!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
DisplayScreen terminateScreenUpdater!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7285-screenUpdateRequired-removal-JuanVuletich-2025Jun26-17h00m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7285] on 26 June 2025 at 5:39:06 pm'!

Form subclass: #DisplayScreen
	instanceVariableNames: ''
	classVariableNames: 'Damage ScreenUpdaterProcess ScreenUpdaterSemaphore '
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

!classDefinition: #DisplayScreen category: #'Graphics-Display Objects' stamp: 'Install-7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st 7/15/2025 11:02:09'!
Form subclass: #DisplayScreen
	instanceVariableNames: ''
	classVariableNames: 'Damage ScreenUpdaterProcess ScreenUpdaterSemaphore'
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/26/2025 17:02:54' prior: 16851470!
              setupDisplay
	"
	DisplayScreen setupDisplay.
	Display forceToScreen.
	"

	Display ifNil: [
		Smalltalk at: #Display put: DisplayScreen new.
		"See #recreateSpecialObjectsArray"
		Smalltalk specialObjectsArray at: 15 put: Display ].
	[
		Display setExtent: self actualScreenSize depth: Display nativeDepth.
		"{'New Smalltalk Display:'. self actualScreenSize} print."
	] on: OutOfMemory do: [
		"In case of memory emergency, use a much smaller Display"
		'Display allocation failed - Using Emergency (small) Display.'  print.
		'Resize Display (or OS Window) to retry Display allocation.'  print.
		Display setExtent: self actualScreenSize // 4 depth: Display nativeDepth ].! !
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/26/2025 17:03:00' prior: 16851495 overrides: 16789693!
         shutDown 
	"Minimize Display memory saved in image"
	Display prepareForImageSave.! !
!MorphicCanvas class methodsFor: 'instance creation' stamp: 'jmv 6/26/2025 17:02:39' prior: 16916113!
     onDisplay
	"Answer an instance of the appropriate subclass targetting Display,
	or an intermediate buffer, as appropriate.
	Create a new VectorEngineDrawer or BitBltCanvasEngine as appropriate."
	        "If this platform supports deferred updates
		- Set Display to deferred update mode
		- Use a Canvas on Display
	otherwise
		- Set a non-Display canvas"

	| canvasTarget |
	canvasTarget := (Display deferUpdates: true)
		"Both Linux and Windows VM do support deferUpdates:, so Morphic Canvas target is Display."
		ifNotNil: [ Display ]
		"Mac VMs don't support deferUpdates:, so Morphic Canvas target is this aux Form."
		ifNil: [ Form extent: Display extent depth: Display depth ].
	^self onForm: canvasTarget.! !

DisplayScreen class removeSelector: #terminateScreenUpdater!

!methodRemoval: DisplayScreen class #terminateScreenUpdater stamp: 'Install-7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st 7/15/2025 11:02:09'!
terminateScreenUpdater

	ScreenUpdaterProcess ifNotNil: [
		ScreenUpdaterProcess terminate ].
	ScreenUpdaterProcess := nil.
	ScreenUpdaterSemaphore := nil.
	Damage := nil.!

DisplayScreen class removeSelector: #installScreenUpdater!

!methodRemoval: DisplayScreen class #installScreenUpdater stamp: 'Install-7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st 7/15/2025 11:02:09'!
installScreenUpdater
	"Initialize the event tickler process. Terminate the old process if any."
	"
	DisplayScreen installScreenUpdater
	"

	self terminateScreenUpdater.
	ScreenUpdaterProcess := [ self screenUpdater ] newProcess.
	ScreenUpdaterProcess priority: Processor lowIOPriority.
	ScreenUpdaterProcess name: '[system] Background Screen updater'.
	ScreenUpdaterProcess resume!

DisplayScreen class removeSelector: #screenUpdater!

!methodRemoval: DisplayScreen class #screenUpdater stamp: 'Install-7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st 7/15/2025 11:02:09'!
screenUpdater
	| delay |
	delay := Delay forMilliseconds: 50.
	ScreenUpdaterSemaphore := Semaphore new.
	Damage := nil.
	[
		"Could happen if process is halted and resumed."
		delay beingWaitedOn ifTrue: [ delay := Delay forMilliseconds: delay delayDuration ].
		delay wait.
		ScreenUpdaterSemaphore wait.
		DisplayScreen isDisplayExtentOk ifTrue: [
			Display forceToScreen: Damage.
			ScreenUpdaterSemaphore initSignals.
			Damage := nil ].
	] repeat!

Form subclass: #DisplayScreen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

!classDefinition: #DisplayScreen category: #'Graphics-Display Objects' stamp: 'Install-7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st 7/15/2025 11:02:09'!
Form subclass: #DisplayScreen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Display Objects'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7286-DisplayScreen-backgroundUpdateProcess-Removal-JuanVuletich-2025Jun26-17h37m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7285] on 26 June 2025 at 5:46:45 pm'!
!Color class methodsFor: 'examples' stamp: 'jmv 6/26/2025 17:44:56' prior: 16831377!
                          showColorCube
	"Show a 12x12x12 color cube."
	"
	Color showColorCube
	"

	| offDisplay |
	offDisplay := Display shallowCopy.
	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				offDisplay fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Color r: r g: g b: b range: 11)]]].
	Display forceToScreen.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/26/2025 17:45:46' prior: 16831387!
 showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r offDisplay |
	offDisplay := Display shallowCopy.
	w := Display width // colorList size.
	r := 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		offDisplay fill: r fillColor: c.
		r := r translatedBy: w@0].
	Display forceToScreen.! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/26/2025 17:46:33' prior: 16831398!
                 showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"
	Color showHSVPalettes
	"

	| left top c offDisplay |
	offDisplay := Display shallowCopy.
	left := top := 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left := (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c := Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4).
				offDisplay fill: (left@top extent: 4@4) fillColor: c.

				c := Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4) + 50.
				offDisplay fill: (left@top extent: 4@4) fillColor: c]]].
	Display forceToScreen.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/26/2025 17:45:16' prior: 16831419!
             showHuesInteractively
	"Shows a palette of hues at a (saturation, brightness) point determined by the mouse position. Click the mouse button to exit and return the selected (saturation, brightness) point."
	"
	Color showHuesInteractively
	"

	| p s v |
	[Sensor isAnyButtonPressed] whileFalse: [
		p := Sensor mousePoint.
		s := p x asFloat / 300.0.
		v := p y asFloat / 300.0.
		self showColors: (self wheel: 12 saturation: s brightness: v)].
	^ (s min: 1.0) @ (v min: 1.0)! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/26/2025 16:50:37' prior: 16831300!
             experimentsTowardsANewColorPalette
"
For UIs.
	TopLeft. Show 'selected' color.
	BottomLeft. For selected Hue, change Saturation and brightness.
	TopRight. For selected Luminance, change Hue and Chroma
	BottomRight. For selected Chroma, change Hue and Luminance.
Color experimentsTowardsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance offDisplay |
width := 300.
height := 120.
selectedColor := Color random.
selectedHue := selectedColor hue.
selectedSaturation := selectedColor saturation.
selectedChroma := selectedColor chroma.
selectedV := selectedColor brightness.
selectedLuminance := selectedColor luminance.
"TopLeft. Show 'selected' color."
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
offDisplay := Display shallowCopy.

0 to: height do: [ :y |
	v := 1.0 - (y / height).
	0 to: height do: [ :x |
		s := x / height.
		color := Color new setHue: selectedHue saturation: s brightness: v.
		offDisplay colorAt: x@(y+height) put: color
	].
	Display forceToScreen: (0@y extent: height@y).
].
0 to: height do: [ :y | | c |
	v := 1.0 - (y / height).
	s := 1.0 - (y / height).
	c := s.
	0 to: width do: [ :x |
		h := x / width * 360.
		
		color := Color new setHue: h chroma: c luminance: selectedLuminance.
"		color := Color new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: s brightness: selectedV."
		offDisplay colorAt: x+height@y put: color.
		
		color := Color new setHue: h chroma: selectedChroma luminance: v.
"		color := Color new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: selectedSaturation brightness: v."
		offDisplay colorAt: x+height@(y+height) put: color.
		
	].
	Display forceToScreen: (0@y extent: width@y).
].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7287-ColorExamples-performance-JuanVuletich-2025Jun26-17h39m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7285] on 26 June 2025 at 5:52:31 pm'!
!Form methodsFor: 'transitions' stamp: 'jmv 6/26/2025 17:51:56' prior: 16874930!
                        pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d delay |
	delay := Delay forSeconds: 0.1.
	pageRect := otherImage boundingBox.
	oldPage := self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: `Color black`.
	oldBottom := self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps := 8.
	buffer := Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d := pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
					p := pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: `0@0` rule: Form over.
					p := pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect := pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad := Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp := (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceToScreen: leafRect.
		delay wait.
		].

	buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceToScreen.
	delay wait.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"! !
!Form methodsFor: 'transitions' stamp: 'jmv 6/26/2025 17:49:40' prior: 16875001!
                         slideImage: otherImage at: topLeft delta: delta
	"
	Display slideImage: (Form fromDisplay: (40@40 extent: 300@300)) reverse
		at: 40@40 delta: 3@ -4
	"
	| bb nSteps clipRect |
	bb := otherImage boundingBox.
	clipRect := topLeft extent: otherImage extent.
	nSteps := 1.
	delta x = 0 ifFalse: [nSteps := nSteps max: (bb width//delta x abs) + 1].
	delta y = 0 ifFalse: [nSteps := nSteps max: (bb height//delta y abs) + 1].
	1 to: nSteps do: [ :i | 
			self 
				copyBits: bb from: otherImage
				at: delta*(i-nSteps) + topLeft
				clippingBox: clipRect rule: Form paint.
			Display forceToScreen: clipRect.
		]! !
!Form methodsFor: 'transitions' stamp: 'jmv 6/26/2025 17:49:16' prior: 16875022!
            wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex: rectForIndexBlock

	| i clipRect t rectsOrNil waitTime |
	i := 0.
	clipRect := topLeft extent: otherImage extent.
	clipBox ifNotNil: [ clipRect := clipRect intersect: clipBox ].
	[ rectsOrNil := rectForIndexBlock value: (i := i + 1) ]
		whileNotNil: [
			t := Time localMillisecondClock.
			rectsOrNil do: [ :r |
				self copyBits: r from: otherImage at: topLeft + r topLeft
					clippingBox: clipRect rule: Form over ].
			Display forceToScreen: clipRect.
			waitTime := 3 - (Time localMillisecondClock - t).
			waitTime > 0 ifTrue:
				["(Delay forMilliseconds: waitTime) wait"]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7288-FormExamples-performance-JuanVuletich-2025Jun26-17h47m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7285] on 26 June 2025 at 5:47:45 pm'!
!InputSensor methodsFor: 'joystick' stamp: 'jmv 6/26/2025 17:47:26' prior: 16887847!
                testJoystick: index
	"Sensor testJoystick: 3"

	| f pt buttons status |
	f := Form extent: 110@50 depth: 32.
	[Sensor isAnyButtonPressed] whileFalse: [
		pt := Sensor joystickXY: index.
		buttons := Sensor joystickButtons: index.
		status :=
'xy: ', pt printString, '
buttons: ', buttons hex.
		f fillWhite.
		status displayOn: f at: 10@10.
		f displayOn: Display at: 10@10.
	].
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7289-tweak-JuanVuletich-2025Jun26-17h46m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7289] on 27 June 2025 at 9:18:23 am'!
!DisplayScreen methodsFor: 'copying' stamp: 'jmv 6/27/2025 09:15:59'!
 copyToDisableImmediateUpdates
	"Answer an instance that shares our pixel storage.
	This is useful to prevent the VM from immediately updating the host platform pixels the user actually sees,
	especially on platforms where #deferUpdates: answers ni, meaning it doesn't really support doing this.
	Flicking is possible. See comment at #beDisplay . For this reason Morphic doesn't use this technique.
	Alternatively, the separate Form used as the Morphic Canvas target on such platforms could be made into
	a service provided by this class, together with the appropriate way to update the real host pixels, removing
	this code from #displayWorldOn:.
	"
	^self shallowCopy! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 09:17:40' prior: 50336253!
           experimentsTowardsANewColorPalette
"
For UIs.
	TopLeft. Show 'selected' color.
	BottomLeft. For selected Hue, change Saturation and brightness.
	TopRight. For selected Luminance, change Hue and Chroma
	BottomRight. For selected Chroma, change Hue and Luminance.
Color experimentsTowardsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance offDisplay |
width := 300.
height := 120.
selectedColor := Color random.
selectedHue := selectedColor hue.
selectedSaturation := selectedColor saturation.
selectedChroma := selectedColor chroma.
selectedV := selectedColor brightness.
selectedLuminance := selectedColor luminance.
"TopLeft. Show 'selected' color."
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
offDisplay := Display copyToDisableImmediateUpdates.

0 to: height do: [ :y |
	v := 1.0 - (y / height).
	0 to: height do: [ :x |
		s := x / height.
		color := Color new setHue: selectedHue saturation: s brightness: v.
		offDisplay colorAt: x@(y+height) put: color
	].
	Display forceToScreen: (0@y extent: height@y).
].
0 to: height do: [ :y | | c |
	v := 1.0 - (y / height).
	s := 1.0 - (y / height).
	c := s.
	0 to: width do: [ :x |
		h := x / width * 360.
		
		color := Color new setHue: h chroma: c luminance: selectedLuminance.
"		color := Color new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: s brightness: selectedV."
		offDisplay colorAt: x+height@y put: color.
		
		color := Color new setHue: h chroma: selectedChroma luminance: v.
"		color := Color new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: selectedSaturation brightness: v."
		offDisplay colorAt: x+height@(y+height) put: color.
		
	].
	Display forceToScreen: (0@y extent: width@y).
].! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 09:17:36' prior: 50336184!
                showColorCube
	"Show a 12x12x12 color cube."
	"
	Color showColorCube
	"

	| offDisplay |
	offDisplay := Display copyToDisableImmediateUpdates.
	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				offDisplay fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Color r: r g: g b: b range: 11)]]].
	Display forceToScreen.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 09:17:32' prior: 50336197!
               showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r offDisplay |
	offDisplay := Display copyToDisableImmediateUpdates.
	w := Display width // colorList size.
	r := 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		offDisplay fill: r fillColor: c.
		r := r translatedBy: w@0].
	Display forceToScreen.! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 09:17:29' prior: 50336211!
                               showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"
	Color showHSVPalettes
	"

	| left top c offDisplay |
	offDisplay := Display copyToDisableImmediateUpdates.
	left := top := 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left := (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c := Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4).
				offDisplay fill: (left@top extent: 4@4) fillColor: c.

				c := Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4) + 50.
				offDisplay fill: (left@top extent: 4@4) fillColor: c]]].
	Display forceToScreen.
! !
!MorphicCanvas methodsFor: 'testing' stamp: 'jmv 6/27/2025 09:17:19' prior: 50335287!
                          drawsOnDisplay
	"Answer true if we actually draw on (Display copyToDisableImmediateUpdates)"
	^form == Display | (form bits == Display bits)! !
!Transcript class methodsFor: 'private' stamp: 'jmv 6/27/2025 09:17:24' prior: 50335302!
                       displayEngine
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	"
	Transcript releaseClassCachedState
	"
	(displayEngine isNil or: [
		displayEngine class ~= BitBltCanvasEngine]) ifTrue: [
			displayEngine := BitBltCanvasEngine toForm: Display copyToDisableImmediateUpdates].
	^ displayEngine! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7290-Document-DisplayCopy-technique-JuanVuletich-2025Jun27-09h15m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7289] on 27 June 2025 at 9:24:56 am'!
!Rectangle methodsFor: 'transforming' stamp: 'jmv 6/27/2025 09:23:56' prior: 16944331!
  newRect2From: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect aHand delay offDisplay |
	delay := Delay forMilliseconds: 10.
	rect := self.
	offDisplay := Display copyToDisableImmediateUpdates.
	offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	offDisplay forceToScreen: rect.
	[Sensor isAnyButtonPressed] whileTrue: 
		[delay wait.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			offDisplay border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			offDisplay forceToScreen: (rect merge: newRect).
			rect := newRect]].
	offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	offDisplay forceToScreen: rect.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 6/27/2025 09:23:09' prior: 16944363!
                        newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay offDisplay |
	delay := Delay forMilliseconds: 10.
	buttonStart := buttonNow := Sensor isAnyButtonPressed.
	rect := self.
	offDisplay := Display copyToDisableImmediateUpdates.
	offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	offDisplay forceToScreen: rect.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow := Sensor isAnyButtonPressed.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			offDisplay border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			offDisplay forceToScreen: (rect merge: newRect).
			rect := newRect]].
	offDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	offDisplay forceToScreen: rect.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7291-Rectngle-fromUser-performance-JuanVuletich-2025Jun27-09h18m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7289] on 27 June 2025 at 10:08:39 am'!

DisplayScreen class
	instanceVariableNames: 'DeferredUpdatingDisplay '!

!classDefinition: 'DisplayScreen class' category: #'Graphics-Display Objects' stamp: 'Install-7292-DisplayScreen-deferredUpdatingDisplay-p1-JuanVuletich-2025Jun27-09h24m-jmv.001.cs.st 7/15/2025 11:02:09'!
DisplayScreen class
	instanceVariableNames: 'DeferredUpdatingDisplay'!
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 09:49:49'!
                  clearDeferredUpdatingDisplay

	DeferredUpdatingDisplay ifNotNil: [
		DeferredUpdatingDisplay bits unpin.
		DeferredUpdatingDisplay := nil ].! !
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 09:43:00'!
                          deferredUpdatingDisplay
	"Answer the instance to be used from most clients, including Morphic.
	If the platform supports #deferUpdates:, it will be Display itself.
	If the platform does NOT support #deferUpdates, it will be a separate Form.
	Methods in this category provide convenient access."

	DeferredUpdatingDisplay ifNil: [
		 DeferredUpdatingDisplay := (Display deferUpdates: true)
			"Both Linux and Windows VM do support deferUpdates:, so Morphic Canvas target is Display."
			ifNotNil: [ Display ]
			"Mac VMs don't support deferUpdates:, so Morphic Canvas target is this aux Form."
			ifNil: [ Form extent: Display extent depth: Display depth ]].
	^DeferredUpdatingDisplay! !
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 10:06:24'!
                           isDisplay: aFormOrDisplayScreen
	"Answer true if:
		Display
		DeferredUpdatingDisplay
	flase otherwise."
	aFormOrDisplayScreen == Display ifTrue: [ ^true ].
	aFormOrDisplayScreen == DeferredUpdatingDisplay ifTrue: [ ^true ].
	^false.! !
!DisplayScreen class methodsFor: 'cached state access' stamp: 'jmv 6/27/2025 09:59:01' overrides: 16789661!
       releaseClassCachedState
	self clearDeferredUpdatingDisplay! !
!DisplayScreen methodsFor: 'private' stamp: 'jmv 6/27/2025 09:50:50' prior: 16851275 overrides: 16875229!
                        setExtent: aPoint depth: bitsPerPixel
	"DisplayScreen startUp"
	"This method is critical. If the setExtent fails, there will be no
	proper display on which to show the error condition."

	| bitsPerPixelToUse oldBits |
	DisplayScreen clearDeferredUpdatingDisplay.
	(depth = bitsPerPixel and: [aPoint = self extent and: [
					self supportsDisplayDepth: bitsPerPixel]]) ifFalse: [
		bitsPerPixelToUse := (self supportsDisplayDepth: bitsPerPixel)
			ifTrue: [ bitsPerPixel ]
			ifFalse: [
				(self supportsDisplayDepth: bitsPerPixel negated)
					ifTrue: [ bitsPerPixel negated ]
					ifFalse: [ self findAnyDisplayDepth ]].
		"Keep the old bits with a hard reference until the #beDisplay call below."
		oldBits := bits.
		"This super call will assign the new contents of the 'bits' instance variable.
		The old one may be still used by the VM (see comment at #beDisplay),
		but it is also stored in the oldBits variable, so it is safe."
		super setExtent: aPoint depth: bitsPerPixelToUse.
		"Let the VM know our bits have changed.
		See http://lists.squeakfoundation.org/archives/list/vm-dev@lists.squeakfoundation.org/message/F3I7L5IJT2J5RXCS3QXLLQ3TZ6KU6FD6/	"
		"Usually you don't create new instances of DisplayScreen, but if ever done, do what follows only for the real Display."
		self == Display ifTrue: [
			"It is important to keep oldBits referencing the bits passed to the VM in the previous
			call to #beDisplay until AFTER we passed it the new value in the call that follows."
			self beDisplay ].
		"Most likely not needed, even if some VMs could have pinned it.
		Still, this is a way to ensure that no optimizer may ever try to kill the oldBits before we're sure the VM doesn't need us to keep a reference to it."
		oldBits unpin.
		"Only now it is safe to no longer reference oldBits."
		oldBits := nil.
	].! !
!DisplayScreen methodsFor: 'initialization' stamp: 'jmv 1/15/2018 15:51:20' prior: 16851405 overrides: 16940323!
           initialize
	self
		setExtent: self class actualScreenSize
		depth: (self class actualScreenDepth ifNil: [ 32 ])! !
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/27/2025 09:51:05' prior: 50336049!
               setupDisplay
	"
	DisplayScreen setupDisplay.
	Display forceToScreen.
	"

	Display ifNil: [
		Smalltalk at: #Display put: DisplayScreen new.
		"See #recreateSpecialObjectsArray"
		Smalltalk specialObjectsArray at: 15 put: Display ].
	[
		Display setExtent: self actualScreenSize depth: Display nativeDepth.
		"{'New Smalltalk Display:'. self actualScreenSize} print."
	] on: OutOfMemory do: [
		"In case of memory emergency, use a much smaller Display"
		'Display allocation failed - Using Emergency (small) Display.'  print.
		'Resize Display (or OS Window) to retry Display allocation.'  print.
		Display setExtent: self actualScreenSize // 4 depth: Display nativeDepth ].! !
!VectorEngineDrawer methodsFor: 'services' stamp: 'jmv 6/27/2025 10:07:23' prior: 17010360!
                               unpinAndFreeMemory

	"Unpin, if possible, any pinned large arrays."
	"Unpin if pinning is supported by the VM, NOP otherwise."
	targetForm ifNotNil: [
		(DisplayScreen isDisplay: targetForm) ifFalse: [
			targetForm bits unpin ]].
	morphIds ifNotNil: [ morphIds unpin ].
	edgeCounts ifNotNil: [ edgeCounts unpin ].
	alphaMask ifNotNil: [ alphaMask unpin ].
	affectedBits ifNotNil: [ affectedBits unpin ].
	contour ifNotNil: [ contour unpin ].

	targetForm := nil.
	morphIds := nil.
	edgeCounts := nil.
	alphaMask := nil.
	affectedBits := nil.
	contour := nil.! !

DisplayScreen class
	instanceVariableNames: 'DeferredUpdatingDisplay'!

!classDefinition: 'DisplayScreen class' category: #'Graphics-Display Objects' stamp: 'Install-7292-DisplayScreen-deferredUpdatingDisplay-p1-JuanVuletich-2025Jun27-09h24m-jmv.001.cs.st 7/15/2025 11:02:09'!
DisplayScreen class
	instanceVariableNames: 'DeferredUpdatingDisplay'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7292-DisplayScreen-deferredUpdatingDisplay-p1-JuanVuletich-2025Jun27-09h24m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7289] on 27 June 2025 at 10:25:25 am'!
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 10:22:57'!
                            forceDeferredToScreen
	"Force the entire display area to the screen"
	DeferredUpdatingDisplay ifNotNil: [
		self forceDeferredToScreen: DeferredUpdatingDisplay boundingBox ]! !
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 10:20:09'!
                         forceDeferredToScreen: updateRect
	"Force the given rectangular section of the Display to be copied to the host screen. Make it visible to user."

	DeferredUpdatingDisplay ifNil:
		[ ^self ].
	DisplayScreen isDisplayExtentOk ifFalse:
		[ ^self ].
	DeferredUpdatingDisplay == Display
		ifTrue:
			[Display forceToScreen: updateRect ]
		ifFalse:
			[
			(BitBlt toForm: Display)
				sourceForm: DeferredUpdatingDisplay;
				combinationRule: Form over;
				sourceRect: updateRect;
				destOrigin: updateRect topLeft;
				copyBits ]! !
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 6/27/2025 10:10:40' prior: 50336750!
      deferredUpdatingDisplay
	"Answer the instance to be used from most clients, including Morphic.
	If the platform supports #deferUpdates:
		Set Display to deferred upodating
		Answer will be Display itself.
	If the platform does NOT support #deferUpdates
		Answer a separate Form.
	Methods in this category provide convenient access."

	DeferredUpdatingDisplay ifNil: [
		 DeferredUpdatingDisplay := (Display deferUpdates: true)
			"Both Linux and Windows VM do support deferUpdates:, so Morphic Canvas target is Display."
			ifNotNil: [ Display ]
			"Mac VMs don't support deferUpdates:, so Morphic Canvas target is this aux Form."
			ifNil: [ Form extent: Display extent depth: Display depth ]].
	^DeferredUpdatingDisplay! !
!WorldMorph methodsFor: 'drawing' stamp: 'jmv 6/27/2025 10:20:32' prior: 50335220!
                        displayWorldOn: aMorphicCanvas
	"Update this world's display on the argument."

	| allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"

	"Restore world drawing under hands and their carried morphs"
	(Preferences at: #cacheDisplayContentWhenMovingMorphs) ifTrue: [
		activeHand restoreSavedPatchOn: aMorphicCanvas ].

	"Update #displayBounds for all dirty morphs (marked as such with #redrawNeeded).
	Also add the updated bounds to aDamageRecorder, and update bounds of morphs carried by hand."
	aMorphicCanvas boundsFinderCanvas updateBoundsIn: self addDamageTo: damageRecorder.

	"repair world's damage on canvas"
	allDamage := aMorphicCanvas drawWorld: self repair: damageRecorder.
	"allDamage ifNotNil: [Display border: allDamage width: 3 fillColor: Color random].	 'Debugging Aid'."
	self submorphNeedsRedraw: false.
	self needsRedraw: false.
	aMorphicCanvas newClipRect: nil.

	"Check which hands need to be drawn.
	(they are not the hardware mouse pointer and carry morphs)"
	self ifHandToBeDrawnForDamage: allDamage do: [
		(Preferences at: #cacheDisplayContentWhenMovingMorphs)
			ifTrue: [ allDamage := (activeHand savePatchFrom: aMorphicCanvas) quickMerge: allDamage ]
			ifFalse: [ allDamage := activeHand displayFullBoundsForPatch quickMerge: allDamage ].
		aMorphicCanvas fullDrawHand: activeHand.
		activeHand needsRedraw: false.
		activeHand submorphNeedsRedraw: false ].

	"Copy altered rects to Display"
	allDamage ifNotNil: [
		DisplayScreen forceDeferredToScreen: allDamage ].! !
!WorldMorph methodsFor: 'drawing' stamp: 'jmv 6/27/2025 10:24:45' prior: 17018281 overrides: 16929409!
                      drawOn: aCanvas

	"draw background image."
	backgroundImage
		ifNotNil: [
			super drawOn: aCanvas ]
		ifNil: [
			"draw background fill"
			(aCanvas form == Display and: [ color mightBeTranslucent ])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Cuis Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt toForm: Display) clipRect: aCanvas clipRect;
						copy: Display boundingBox
						from: `0@0` in: nil
						fillColor: color rule: Form over.
					Display forceToScreen]
				ifFalse: [ super drawOn: aCanvas ]]! !
!MorphicCanvas class methodsFor: 'instance creation' stamp: 'jmv 6/27/2025 10:11:44' prior: 50336080!
         onDisplay
	"Answer an instance of the appropriate subclass targetting Display,
	or an intermediate buffer, as appropriate.
	Create a new VectorEngineDrawer or BitBltCanvasEngine as appropriate.
	Use a#deferredUpdatingDisplay, so actual contents are flushed to visible pixels only when appropriate.
	See DisplayScreen 'deferred updating' class methods category."

	| canvasTarget |
	canvasTarget := DisplayScreen deferredUpdatingDisplay.
	^self onForm: canvasTarget.! !

MorphicCanvas removeSelector: #drawsOnDisplay!

!methodRemoval: MorphicCanvas #drawsOnDisplay stamp: 'Install-7293-DisplayScreen-deferredUpdatingDisplay-p2-JuanVuletich-2025Jun27-10h08m-jmv.001.cs.st 7/15/2025 11:02:09'!
drawsOnDisplay
	"Answer true if we actually draw on (Display copyToDisableImmediateUpdates)"
	^form == Display | (form bits == Display bits)!

DisplayScreen class removeSelector: #forceToScreen!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
UISupervisor ui releaseCachedState.
UISupervisor spawnNewMorphicProcessFor: UISupervisor ui

!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7293-DisplayScreen-deferredUpdatingDisplay-p2-JuanVuletich-2025Jun27-10h08m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7289] on 27 June 2025 at 10:54:54 am'!
!DisplayScreen methodsFor: 'copying' stamp: 'jmv 6/27/2025 10:36:57' prior: 50336472!
copyToDisableImmediateUpdates
	"Answer an instance that shares our pixel storage.
	This is useful to prevent the VM from immediately updating the host platform pixels the user actually sees,
	especially on platforms where #deferUpdates: answers ni, meaning it doesn't really support doing this.
	Flicking is possible. For this reason Morphic doesn't use this technique.
	Preferred technique is to use #deferredUpdatingDisplay and related methods.
	"
	^self shallowCopy! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 6/27/2025 10:33:59' prior: 50336642!
                 newRect2From: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect aHand delay |
	delay := Delay forMilliseconds: 10.
	rect := self.
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	[Sensor isAnyButtonPressed] whileTrue: 
		[delay wait.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen deferredUpdatingDisplay border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen forceDeferredToScreen: (rect merge: newRect).
			rect := newRect]].
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 6/27/2025 10:34:20' prior: 50336681!
            newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay := Delay forMilliseconds: 10.
	buttonStart := buttonNow := Sensor isAnyButtonPressed.
	rect := self.
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow := Sensor isAnyButtonPressed.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen deferredUpdatingDisplay border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen forceDeferredToScreen: (rect merge: newRect).
			rect := newRect]].
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 10:34:42' prior: 50336496!
                        experimentsTowardsANewColorPalette
"
For UIs.
	TopLeft. Show 'selected' color.
	BottomLeft. For selected Hue, change Saturation and brightness.
	TopRight. For selected Luminance, change Hue and Chroma
	BottomRight. For selected Chroma, change Hue and Luminance.
Evaluate multiple times and see results:
	Color experimentsTowardsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width := 300.
height := 120.
selectedColor := Color random.
selectedHue := selectedColor hue.
selectedSaturation := selectedColor saturation.
selectedChroma := selectedColor chroma.
selectedV := selectedColor brightness.
selectedLuminance := selectedColor luminance.
"TopLeft. Show 'selected' color."
DisplayScreen deferredUpdatingDisplay getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.

0 to: height do: [ :y |
	v := 1.0 - (y / height).
	0 to: height do: [ :x |
		s := x / height.
		color := Color new setHue: selectedHue saturation: s brightness: v.
		DisplayScreen deferredUpdatingDisplay colorAt: x@(y+height) put: color
	].
	DisplayScreen forceDeferredToScreen: (0@y extent: height@y).
].
0 to: height do: [ :y | | c |
	v := 1.0 - (y / height).
	s := 1.0 - (y / height).
	c := s.
	0 to: width do: [ :x |
		h := x / width * 360.
		
		color := Color new setHue: h chroma: c luminance: selectedLuminance.
"		color := Color new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: s brightness: selectedV."
		DisplayScreen deferredUpdatingDisplay colorAt: x+height@y put: color.
		
		color := Color new setHue: h chroma: selectedChroma luminance: v.
"		color := Color new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color := Color black ].
"		color := Color new setHue: h saturation: selectedSaturation brightness: v."
		DisplayScreen deferredUpdatingDisplay colorAt: x+height@(y+height) put: color.
		
	].
	DisplayScreen forceDeferredToScreen: (0@y extent: width@y).
].! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 10:35:01' prior: 50336560!
                           showColorCube
	"Show a 12x12x12 color cube."
	"
	Color showColorCube
	"

	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				DisplayScreen deferredUpdatingDisplay fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Color r: r g: g b: b range: 11)]]].
	DisplayScreen forceDeferredToScreen.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 10:35:24' prior: 50336574!
            showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r |
	w := DisplayScreen deferredUpdatingDisplay width // colorList size.
	r := 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		DisplayScreen deferredUpdatingDisplay fill: r fillColor: c.
		r := r translatedBy: w@0].
	DisplayScreen forceDeferredToScreen.! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/27/2025 10:35:47' prior: 50336589!
                         showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"
	Color showHSVPalettes
	"

	| left top c |
	left := top := 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left := (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c := Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4).
				DisplayScreen deferredUpdatingDisplay fill: (left@top extent: 4@4) fillColor: c.

				c := Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top := (v * 4) + 50.
				DisplayScreen deferredUpdatingDisplay fill: (left@top extent: 4@4) fillColor: c]]].
	DisplayScreen forceDeferredToScreen.! !
!ProgressInitiationException methodsFor: 'exceptionDescription' stamp: 'jmv 6/27/2025 10:46:14' prior: 50335358 overrides: 16861277!
         defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame lastDrawTime |
	f := FontFamily defaultFamilyAndPointSize.
	h := f lineSpacing * 3//2.
	textWidth := (f widthOfString: progressTitle) + h.
	width := 150 max: textWidth.

	textForm := Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame := Rectangle center: aPoint extent: (width@h) roundedToEven.
	textFrame := `0@0` extent: width@h.
	textFrame := textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + `0@2`.
	outerFrame := barFrame merge: textFrame.
	delta := outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame := barFrame translatedBy: delta.
	textFrame := textFrame translatedBy: delta.
	outerFrame := outerFrame translatedBy: delta.
	range := maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame := barFrame insetBy: 2.
	textForm displayOn: DisplayScreen deferredUpdatingDisplay at: textFrame topLeft.
	DisplayScreen deferredUpdatingDisplay fillBlack: barFrame.
	DisplayScreen deferredUpdatingDisplay fillWhite: innerBarFrame.
	DisplayScreen forceDeferredToScreen: outerFrame.
	lastDrawTime := Time localMillisecondClock.
	result := workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal := barVal ]
			ifNil: [
				currentVal := currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal := minVal ]].
		filledWidth := ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		Time localMillisecondClock - lastDrawTime > 100 ifTrue: [
			textForm displayOn: DisplayScreen deferredUpdatingDisplay at: textFrame topLeft.
			DisplayScreen deferredUpdatingDisplay fillBlack: barFrame.
			DisplayScreen deferredUpdatingDisplay fillWhite: innerBarFrame.
			DisplayScreen deferredUpdatingDisplay fillGray: (barFrame topLeft + `2@2` extent: filledWidth@(h-4)).
			DisplayScreen forceDeferredToScreen: outerFrame.
			lastDrawTime := Time localMillisecondClock ]].
	UISupervisor ui ifNotNil: [ :ui | ui invalidateDisplayRect: outerFrame for: nil ].
	self resume: result! !
!Transcript class methodsFor: 'private' stamp: 'jmv 6/27/2025 10:28:48' prior: 50336622!
                             displayEngine
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	"
	Transcript releaseClassCachedState
	"
	(displayEngine isNil or: [
		displayEngine class ~= BitBltCanvasEngine]) ifTrue: [
			displayEngine := BitBltCanvasEngine toForm: DisplayScreen deferredUpdatingDisplay ].
	^ displayEngine! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 6/27/2025 10:44:05' prior: 50335314!
               display
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayOnDisplay.
		DisplayScreen forceDeferredToScreen: bounds ].
	"So any morph in front of us is repaired when Morphic cycles.
	This includes, for instance, the TranscriptWindow that shows our contents if showOnDisplay is false"
	UISupervisor whenUIinSafeState: [ self triggerEvent: #redrawTranscriptArea ].! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 6/27/2025 10:44:12' prior: 50335982!
     displayUnfinishedEntry
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayUnfinishedEntryOnDisplay ifNotNil: [ :damage |
			DisplayScreen forceDeferredToScreen: damage ]]! !

MorphicCanvas removeSelector: #showAt:invalidRect:!

!methodRemoval: MorphicCanvas #showAt:invalidRect: stamp: 'Install-7294-DisplayScreen-deferredUpdatingDisplay-p3-JuanVuletich-2025Jun27-10h25m-jmv.003.cs.st 7/15/2025 11:02:09'!
showAt: pt invalidRect: updateRect
	| blt |
	blt := (BitBlt toForm: Display)
		sourceForm: form;
		combinationRule: Form over.
	blt sourceRect: updateRect;
		destOrigin: updateRect topLeft + pt;
		copyBits!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Transcript releaseClassCachedState!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7294-DisplayScreen-deferredUpdatingDisplay-p3-JuanVuletich-2025Jun27-10h25m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7294] on 30 June 2025 at 9:12:35 am'!
!Transcript class methodsFor: 'private' stamp: 'jmv 6/30/2025 09:11:45' prior: 50337409!
                         displayEngine
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	"
	Transcript releaseClassCachedState
	"
	| deferredDisplay |
	deferredDisplay := DisplayScreen deferredUpdatingDisplay.
	(displayEngine isNil or: [ displayEngine class ~= BitBltCanvasEngine])
		ifTrue: [
			^ displayEngine := BitBltCanvasEngine toForm: DisplayScreen deferredUpdatingDisplay ].
	displayEngine destForm == deferredDisplay ifFalse: [
		displayEngine setDestForm: deferredDisplay ].
	^ displayEngine! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7295-DisplayScreen-deferredUpdatingDisplay-p4-JuanVuletich-2025Jun30-09h10m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7295] on 30 June 2025 at 3:39:23 pm'!
!ProgressInitiationException methodsFor: 'exceptionDescription' stamp: 'jmv 6/30/2025 15:37:07' prior: 50337333 overrides: 16861277!
                 defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame lastDrawTime |
	f := FontFamily defaultFamilyAndPointSize.
	h := f lineSpacing * 3//2.
	textWidth := (f widthOfString: progressTitle) + h.
	width := 150 max: textWidth.

	textForm := Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame := Rectangle center: aPoint extent: (width@h) roundedToEven.
	textFrame := `0@0` extent: width@h.
	textFrame := textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + `0@2`.
	outerFrame := barFrame merge: textFrame.
	delta := outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame := barFrame translatedBy: delta.
	textFrame := textFrame translatedBy: delta.
	outerFrame := outerFrame translatedBy: delta.
	range := maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame := barFrame insetBy: 2.
	textForm displayOn: DisplayScreen deferredUpdatingDisplay at: textFrame topLeft.
	DisplayScreen deferredUpdatingDisplay fillBlack: barFrame.
	DisplayScreen deferredUpdatingDisplay fillWhite: innerBarFrame.
	DisplayScreen forceDeferredToScreen: outerFrame.
	lastDrawTime := Time localMillisecondClock.
	result := workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal := barVal ]
			ifNil: [
				currentVal := currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal := minVal ]].
		filledWidth := ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		(Time localMillisecondClock - lastDrawTime > 100 or: [
				currentVal = maxVal ]) ifTrue: [
			textForm displayOn: DisplayScreen deferredUpdatingDisplay at: textFrame topLeft.
			DisplayScreen deferredUpdatingDisplay fillBlack: barFrame.
			DisplayScreen deferredUpdatingDisplay fillWhite: innerBarFrame.
			DisplayScreen deferredUpdatingDisplay fillGray: (barFrame topLeft + `2@2` extent: filledWidth@(h-4)).
			DisplayScreen forceDeferredToScreen: outerFrame.
			lastDrawTime := Time localMillisecondClock ]].
	UISupervisor ui ifNotNil: [ :ui | ui invalidateDisplayRect: outerFrame for: nil ].
	self resume: result! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7296-ProgressBar-showCompletionOfVeryFastOnes-JuanVuletich-2025Jun30-15h38m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7296] on 1 July 2025 at 11:06:26 am'!
!Process methodsFor: 'debugging' stamp: 'jmv 7/1/2025 09:59:25'!
                      effectiveProcess
	"If we are debugging a Process, simulating its execution as we step in the Debugger even if it is suspended, answer it.
	Otherwise answer self.
	See #evaluate:onBehalfOf:
	"

	^self environmentAt: #effectiveProcess ifAbsent: self! !
!Process methodsFor: 'debugging' stamp: 'jmv 7/1/2025 10:04:44'!
    evaluate: aBlock onBehalfOf: aProcess
	"Evaluate aBlock setting effectiveProcess to aProcess.
	Needed so #effectiveProcess gives the correct answer.
	See senders."

	| oldEffectiveProcess |
	aProcess == self ifTrue: [^ aBlock value]. "Optimization"
	
	oldEffectiveProcess := self environmentAt: #effectiveProcess ifAbsent: nil.
	self environmentAt: #effectiveProcess put: aProcess.
	^ aBlock ensure: [
		oldEffectiveProcess
			ifNotNil: [ self environmentAt: #effectiveProcess put: oldEffectiveProcess]
			ifNil: [ self environmentRemoveKey: #effectiveProcess ifAbsent: nil ]]! !
!Process methodsFor: 'testing' stamp: 'LM 10/10/2023 14:42'!
                               isInExternalCode
	"In a threaded VM, a Smalltalk Process may run a primitive in the background.
	Answer whether this is currently the case for this Process."

	"Special Object 41 (40 in VM) is the ProcessInExternalCodeTag, which is an empty LinkedList."
	^ myList == (Smalltalk specialObjectsArray at: 41)! !
!Process methodsFor: 'simulate execution' stamp: 'eem 6/23/2014 10:13' prior: 16937258!
                   activateReturn: aContext value: value
	"Activate 'aContext return: value', so execution will return to aContext's sender"

	^Processor activeProcess
		evaluate: [suspendedContext := suspendedContext activateReturn: aContext value: value]
		onBehalfOf: self! !
!Process methodsFor: 'simulate execution' stamp: 'jmv 7/1/2025 10:10:00' prior: 16937275!
  complete: aContext
	"Run self until aContext is popped or an unhandled error is raised.  Return self's new top context, unless an unhandled error was raised then return the signaler context (rather than open a debugger)."

	| ctxt pair error |
	ctxt := suspendedContext.
	suspendedContext := nil. "disable this process while running its stack in active process below"
	pair := Processor activeProcess
		evaluate: [ctxt runUntilErrorOrReturnFrom: aContext]
		onBehalfOf: self.
	suspendedContext := pair first.
	error := pair second.
	error ifNotNil: [^ error signalerContext].
	^ suspendedContext! !
!Process methodsFor: 'simulate execution' stamp: 'eem 4/11/2017 12:03' prior: 16937295!
                 completeStep: aContext 
	"Resume self until aContext is on top, or if already on top, complete next step"

	| callee |
	self isTerminated ifTrue:
		[^ nil].
	self suspendedContext == aContext ifFalse:
		[^ self complete: (self calleeOf: aContext)].
	callee := self step.
	callee == aContext ifTrue: [^ callee].
	aContext isDead ifTrue: [^ self suspendedContext].  "returned"
	^ self complete: callee  "finish send"! !
!Process methodsFor: 'simulate execution' stamp: 'eem 6/23/2014 10:19' prior: 16937358!
      popTo: aContext 
	"Pop self down to aContext by remote returning from aContext's callee.  Unwind blocks will be executed on the way.
	This is done by pushing a new context on top which executes 'aContext callee return' then resuming self until aContext is reached.  This way any errors raised in an unwind block will get handled by senders in self and not by senders in the activeProcess.
	If an unwind block raises an error that is not handled then the popping stops at the error and the signalling context is returned, othewise aContext is returned."

	self == Processor activeProcess ifTrue:
		[^self error: 'The active process cannot pop contexts'].
	^(self calleeOf: aContext)
		ifNil: [aContext]  "aContext is on top"
		ifNotNil:
			[:callee|
			 Processor activeProcess
				evaluate: [self return: callee value: callee receiver]
				onBehalfOf: self]! !
!Process methodsFor: 'simulate execution' stamp: 'eem 6/23/2014 10:19' prior: 16937386!
           popTo: aContext value: aValue
	"Replace the suspendedContext with aContext, releasing all contexts 
	 between the currently suspendedContext and it."

	self == Processor activeProcess ifTrue:
		[^self error: 'The active process cannot pop contexts'].
	^(self calleeOf: aContext)
		ifNil: [aContext]  "aContext is on top"
		ifNotNil:
			[:callee|
			 Processor activeProcess
				evaluate: [self return: callee value: aValue]
				onBehalfOf: self]! !
!Process methodsFor: 'simulate execution' stamp: 'eem 6/23/2014 10:13' prior: 16937418!
       return: aContext value: value
	"Pop thread down to aContext's sender.  Execute any unwind blocks on the way.  See #popTo: comment and #runUntilErrorOrReturnFrom: for more details."

	suspendedContext == aContext ifTrue:
		[^Processor activeProcess
			evaluate: [suspendedContext := aContext return: value from: aContext]
			onBehalfOf: self].
	self activateReturn: aContext value: value.
	^self complete: aContext! !
!Process methodsFor: 'simulate execution' stamp: 'eem 9/7/2009 11:19' prior: 16937432!
        step

	^Processor activeProcess
		evaluate: [suspendedContext := suspendedContext step]
		onBehalfOf: self! !
!Process methodsFor: 'simulate execution' stamp: 'eem 3/15/2013 09:35' prior: 16937437!
                          step: aContext 
	"Resume self until aContext is on top, or if already on top, do next step"

	^Processor activeProcess
		evaluate:
			[self suspendedContext == aContext
				ifTrue: [suspendedContext := suspendedContext step]
				ifFalse: [self complete: (self calleeOf: aContext)]]
		onBehalfOf: self! !
!Process methodsFor: 'simulate execution' stamp: 'eem 9/7/2009 11:52' prior: 16937447!
                         stepToCallee
	"Step until top context changes"

	Processor activeProcess
		evaluate:
			[| ctxt |
			ctxt := suspendedContext.
			[ctxt == suspendedContext] whileTrue: [
				suspendedContext := suspendedContext step]]
		onBehalfOf: self.
	^suspendedContext! !
!Process methodsFor: 'simulate execution' stamp: 'jmv 7/1/2025 10:36:40' prior: 16937456!
  stepToHome: requestedContext
	"Resume self until the home of top context is aContext.  Top context may be a block context.
	 Catch any UnhandledErrors that are created while stepping, answering the relevant signalerContext
	 if so. Note that this will cause weird effects if using through to step through UnhandledError
	 code, but as the doctor ordered, don't do that; use over or into instead."

	| requestedHome |
	Processor activeProcess
		evaluate:
			[
				requestedHome := requestedContext home.
				[
					suspendedContext := suspendedContext step.
				
					"We reached the home context of the block we are doing [Through] on."
					suspendedContext home == requestedHome ifTrue: [
						^suspendedContext ].
				
					"But if the requestedHome is dead, meaning that we'll never reach back there,
					stop when we get back to where [Through] was requested."
					requestedHome isDead ifTrue: [
						suspendedContext = requestedContext ifTrue: [
							^suspendedContext ]].
				
					"There's nowhere to continue stepping into. Don't do it."
					(suspendedContext sender isNil or: [suspendedContext sender isDead]) ifTrue: [
						^suspendedContext ].
				
					self ifSuspendedContextIsUnhandledErrorDo: [ :anError |
						anError signalerContext ifNotNil: [ :unhandledErrorSignalerContext |
							self completeStepUpTo: unhandledErrorSignalerContext.
							"Give a debugger a chance to update its title to reflect the new exception"
							 Notification signalToUpdateDebuggerOn: unhandledErrorSignalerContext dueTo: anError.
							^unhandledErrorSignalerContext ]]
				
				] repeat.
			]
		onBehalfOf: self.! !
!Process methodsFor: 'simulate execution' stamp: 'eem 9/7/2009 11:10' prior: 16937505!
           stepToSendOrReturn

	^Processor activeProcess
		evaluate: [suspendedContext := suspendedContext stepToSendOrReturn]
		onBehalfOf: self! !
!Process methodsFor: 'private' stamp: 'jmv 7/1/2025 10:29:12' prior: 16937645!
       resolvePendingQuickReturns
	| method |	
	method := suspendedContext method.
	method isQuick ifTrue: [
		Processor activeProcess
			evaluate: [suspendedContext := suspendedContext callPrimitive: method primitive]
			onBehalfOf: self ]! !
!Process methodsFor: 'changing suspended state' stamp: 'eem 3/30/2017 15:44' prior: 16937408!
                     restartTopWith: method
	"Rollback top context and replace with new method.  Assumes self is suspended"

	method isQuick 
		ifTrue: [self popTo: suspendedContext sender]
		ifFalse:
			[suspendedContext method frameSize >= method frameSize
				ifTrue: [suspendedContext privRefreshWith: method]
				ifFalse:
					[self assert: suspendedContext isExecutingBlock not.
					 suspendedContext := MethodContext
												sender: suspendedContext sender
												receiver: suspendedContext receiver
												method: method
												arguments: ((1 to: method numArgs) collect:
																[:i| suspendedContext tempAt: i])]].
! !
!Process class methodsFor: 'instance creation' stamp: 'jmv 7/1/2025 10:40:19' prior: 16937852!
     forContext: aMethodContext priority: anInteger 
	"Answer an instance of me that has suspended aContext at priority anInteger."

	| newProcess |
	newProcess := self new.
	newProcess priority: anInteger.
	newProcess suspendedContext: aMethodContext.
	^newProcess! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7297-Process-effectiveProcess-JuanVuletich-2025Jun30-17h53m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7296] on 1 July 2025 at 11:10:00 am'!
!Process methodsFor: 'simulate execution' stamp: 'jmv 7/1/2025 11:09:51'!
 isSimulatingAnotherProcess
	"Answer true if we are a debugger process, simulating the execution of another."

	^self effectiveProcess ~~ self! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7298-Process-isSimulatingAnotherProcess-JuanVuletich-2025Jul01-11h06m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7296] on 1 July 2025 at 11:14:01 am'!
!VectorEngine class methodsFor: 'instance creation' stamp: 'jmv 7/1/2025 11:13:53' prior: 17009452!
                    onForm: aForm subPixelAntiAliasing: aBoolean
	"nil means use default kind of anti aliasing
	Use the VectorEnginePlugin if available."

	| engineClass doSubPixelAntiAliasing |
	self hasSubclasses
		ifFalse: [
			engineClass := self ]
		ifTrue: [
			doSubPixelAntiAliasing := aBoolean ifNil: [
				"Assume high resolution implies high DPI"
				Display width <= 1920 ].
			engineClass := (VectorEngineWithPlugin isPluginAvailable and: [
					"VectorEnginePlugin calls can not be reliably simulated in the Debugger because the plugin holds static state."
					Processor activeProcess isSimulatingAnotherProcess not ])
				ifTrue: [ doSubPixelAntiAliasing
					ifTrue: [VectorEngineWithPluginSubPixel]
					ifFalse: [VectorEngineWithPluginWholePixel]]
				ifFalse: [ doSubPixelAntiAliasing
					ifTrue: [VectorEngineSubPixel]
					ifFalse: [VectorEngineWholePixel]]].
		^engineClass new initializeOnForm: aForm.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7299-DontUseVectorPluginInSimulatedCode-JuanVuletich-2025Jul01-11h10m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7299] on 1 July 2025 at 12:27:24 pm'!
!ContextPart methodsFor: 'private' stamp: 'jmv 7/1/2025 12:26:54' prior: 16839077!
        doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments
	"Simulate a primitive method whose index is primitiveIndex.  The simulated receiver and
	 arguments are given as arguments to this message. If successful, push result and return
	 resuming context, else ^ {errCode, PrimitiveFailToken}. Any primitive which provokes
	 execution needs to be intercepted and simulated to avoid execution running away."

	| value |
	"Test for unsimulatable side effects (that is, code that will be triggered in the image outside of the simulator range). This includes simulation guards, which are traditionally flagged using primitive 19 (a null primitive that doesn't do anything), as well as certain control primitives that might trigger code on other processes. If a side effect is detected, raise a warning to give the user/client a chance to cancel or virtualize the operation."
	"#(19 87) do: [:primitive | self systemNavigation browseAllSelect: [:m | m primitive = primitive]]"
	(primitiveIndex = 19 "simulationGuard" or: [primitiveIndex = 87 "primitiveResume"]) ifTrue:
		[[(SimulationSideEffectWarning forPrimitive: primitiveIndex)
			context: self method: meth receiver: receiver arguments: arguments;
			signalIfSkipped: [^ self]]
				ifCurtailed:
					[self push: receiver "Cheap fix of the context's internal state. Note that unwinding the receiver -- so that the next step would invoke the primitive again -- would be challenging due to to the variety of senders to this method."]].
	
	((primitiveIndex between: 201 and: 222)
	 and: [(self objectClass: receiver) includesBehavior: BlockClosure]) ifTrue:
		[(primitiveIndex = 206
		  or: [primitiveIndex = 208]) ifTrue:						"[Full]BlockClosure>>valueWithArguments:"
			[^receiver simulateValueWithArguments: arguments first caller: self].
		 ((primitiveIndex between: 201 and: 209)			 "[Full]BlockClosure>>value[:value:...]"
		  or: [primitiveIndex between: 221 and: 222]) ifTrue: "[Full]BlockClosure>>valueNoContextSwitch[:]"
			[^receiver simulateValueWithArguments: arguments caller: self]].

	primitiveIndex = 83 ifTrue: "afr 9/11/1998 19:50" "Object>>perform:[with:...]"
		[| selector |
		selector := arguments at: 1 ifAbsent:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: receiver with: arguments allButFirst].
	primitiveIndex = 84 ifTrue: "afr 9/11/1998 19:50 & eem 8/18/2009 17:04" "Object>>perform:withArguments:"
		[| selector args |
		arguments size = 2 ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		selector := arguments first.
		args := arguments second.
		args isArray ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: receiver with: args].
	primitiveIndex = 100 ifTrue: "eem 8/18/2009 16:57" "Object>>perform:withArguments:inSuperclass:"
		[| rcvr selector args superclass |
		arguments size
			caseOf: {
				[3] -> [
					rcvr := receiver.
					selector := arguments first.
					args := arguments second.
					superclass := arguments third].
				[4] -> ["mirror primitive"
					rcvr := arguments first.
					selector := arguments second.
					args := arguments third.
					superclass := arguments fourth] }
			otherwise: [^ self class primitiveFailTokenFor: #'bad number of arguments'].
		args isArray ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		((self objectClass: rcvr) includesBehavior: superclass) ifFalse:
			[^ self class primitiveFailTokenFor: #'bad argument'].
		^self send: selector to: rcvr with: args lookupIn: superclass].

	"Mutex>>primitiveEnterCriticalSectionOnBehalfOf:
	 Mutex>>primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf:"
	(primitiveIndex = 186 or: [primitiveIndex = 187]) ifTrue:
		[| effective |
		 effective := Processor activeProcess.
		 value := primitiveIndex = 186
					ifTrue: [receiver primitiveEnterCriticalSectionOnBehalfOf: effective]
					ifFalse: [receiver primitiveTestAndSetOwnershipOfCriticalSectionOnBehalfOf: effective].
		 ^(self isPrimFailToken: value)
			ifTrue: [value]
			ifFalse: [self push: value]].
	
	(primitiveIndex = 188 or: [primitiveIndex = 189]) ifTrue:
		[| n args methodArg thisReceiver |
		 primitiveIndex caseOf:
			{[188 "primitiveExecuteMethodArgsArray"] ->
				["Object>>withArgs:executeMethod:
				  CompiledMethod class>>receiver:withArguments:executeMethod:
				  VMMirror>>ifFail:object:with:executeMethod: et al"
				 ((n := arguments size) between: 2 and: 4) ifFalse:
					[^self class primitiveFailTokenFor: #'unsupported operation'].
				 ((self objectClass: (args := arguments at: n - 1)) == Array
				  and: [(self objectClass: (methodArg := arguments at: n)) includesBehavior: CompiledMethod]) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 thisReceiver := arguments at: n - 2 ifAbsent: [receiver]].
			 [189 "primitiveExecuteMethod"] ->
				["Object>>executeMethod:
				  Object>>with:...executeMethod:"
				 (arguments size > 0) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 ((self objectClass: (methodArg := arguments atLast: 1)) includesBehavior: CompiledMethod) ifFalse:
					[^self class primitiveFailTokenFor: #'bad argument'].
				 args := arguments allButLast.
				 thisReceiver := receiver]}.
		 methodArg numArgs = args size ifFalse:
			[^self class primitiveFailTokenFor: #'bad number of arguments'].
		 methodArg primitive > 0 ifTrue:
			[methodArg isQuick ifTrue:
				[^self push: (methodArg valueWithReceiver: thisReceiver arguments: args)].
			 ^self doPrimitive: methodArg primitive method: methodArg receiver: thisReceiver args: args].
		 ^self
			activateMethod: methodArg
			withArgs: args
			receiver: thisReceiver].

	primitiveIndex = 118 ifTrue: "[receiver:]tryPrimitive:withArgs:; avoid recursing in the VM"
		[(arguments size = 3
		  and: [(self objectClass: arguments second) == SmallInteger
		  and: [(self objectClass: arguments last) == Array]]) ifTrue:
			[^self doPrimitive: arguments second method: meth receiver: arguments first args: arguments last].
		 (arguments size = 2
		 and: [(self objectClass: arguments first) == SmallInteger
		 and: [(self objectClass: arguments last) == Array]]) ifFalse:
			[^self class primitiveFailTokenFor: -3].
		 ^self doPrimitive: arguments first method: meth receiver: receiver args: arguments last].

	value := primitiveIndex = 120 "FFI method"
				ifTrue: [(meth literalAt: 1) tryInvokeWithArguments: arguments]
				ifFalse:
					[primitiveIndex = 117 "named primitives"
						ifTrue: [
							"primDecl := meth literalAt: 1.
							moduleNameOrNil := primDecl at: 1.
							primitiveName := primDecl at: 2."
							(#(VectorEnginePlugin) statePointsTo: ((meth literalAt: 1) at: 1))
								ifTrue: [self class primitiveFailTokenFor: 1]
								ifFalse: [self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments].
							]
						ifFalse: "should use self receiver: receiver tryPrimitive: primitiveIndex withArgs: arguments but this is only in later VMs (and appears to be broken)"
							[receiver tryPrimitive: primitiveIndex withArgs: arguments]].

	^(self isPrimFailToken: value)
		ifTrue: [value]
		ifFalse: [self push: value]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7300-FailSimulatedPrimitivesForVectorEngine-JuanVuletich-2025Jul01-12h26m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7300] on 1 July 2025 at 4:49:08 pm'!
!WorldMorph methodsFor: 'update cycle' stamp: 'jmv 7/1/2025 16:44:24' prior: 17018832!
                 checkForNewScreenSize
	"Check whether the screen size has changed and if so take appropriate actions"

	| newScaleFactor e p needsNewUIProcessAndCanvas |

	"Linux and MacOS VMs continuously update #actualScreenSize while the user is resizing the OS window.
	Try to avoid reallocation of Display until the user is done with that.
	For that, wait until a real event happens inside Cuis. (This requires the user to move the mouse back into Cuis).
	Or use a timer, and do it no more often than every quarter a second, and only if the resize finishes/pauses for that time."
	DisplayScreen isDisplayExtentOk ifFalse: [
		Smalltalk platformName = 'Win32' ifFalse: [
			self valueOfProperty: #startForNewDisplayTimeout ifAbsentPut: [Time localMillisecondClock].
			self valueOfProperty: #newDisplayOldExtent ifAbsentPut: [DisplayScreen actualScreenSize].
			lastCycleHadAnyEvent ifFalse: [
				(self valueOfProperty: #newDisplayOldExtent) = DisplayScreen actualScreenSize ifFalse: [
					"If user still resizing, restart timer: wait until the user finishes resizing."
					self setProperty: #startForNewDisplayTimeout toValue: Time localMillisecondClock.
					self setProperty: #newDisplayOldExtent toValue: DisplayScreen actualScreenSize].
				Time localMillisecondClock - (self valueOfProperty: #startForNewDisplayTimeout) < 250 ifTrue: [
					^self ]].
			self removeProperty: #startForNewDisplayTimeout.
			self removeProperty: #newDisplayOldExtent ]].

	needsNewUIProcessAndCanvas := false.
	DisplayScreen isDisplayExtentOk ifFalse: [
		"''print. {DateAndTime now. 'Smalltalk Display:'. Display extent. 'os display:'. DisplayScreen actualScreenSize} print."
		"If host OS scale factor has changed, try to recover our previous Display extent"
		newScaleFactor := DisplayScreen hostOSScaleFactor.
		newScaleFactor = ScaleFactor ifFalse: [
			ScaleFactor := newScaleFactor.
			e := DisplayScreen hostOSWindowExtent ifNotNil: [ :ee |
				(ee * ScaleFactor - DisplayScreen actualScreenSize + Display extent) truncated ].
			p := DisplayScreen hostOSWindowPosition.
			e ifNotNil: [
				"{'New ScaleFactor'. ScaleFactor. 'Set os display to:'. e} print."
				DisplayScreen hostOSWindowExtent: e].
			p ifNotNil: [DisplayScreen hostOSWindowPosition: p].
		].
		"When moving the Cuis window, for instance, between a laptop screen with ScaleFactor=2.0 and an external screen with
		ScaleFactor=1.0, usually the #hostOSWindowExtent: already left us with isDisplayExtentOk, so asking again is in order."
		DisplayScreen isDisplayExtentOk ifFalse: [
			"This allocates new memory for Display and is critical."
			needsNewUIProcessAndCanvas := true.
			"This may help with memory fragmentation issues possibly making new display allocation fail."
			canvas unpinAndFreeMemory.
			DisplayScreen setupDisplay ]].
	(needsNewUIProcessAndCanvas or: [canvas isConsistentWithTarget not])
		ifTrue: [
			self whenUIinSafeState: [ Cursor defaultCursor activateCursor ].
			"The current canvas is not consistent with Display, and therefore can no longer be used. A new one is required.
			Freeeing the memory it uses may help with memory fragmentation issues possibly making new canvas allocation fail.
			(If there is not enough free memory for VectorCanvas and engine, use a BitBltCanvas, see #getMainCanvas)"
			canvas unpinAndFreeMemory.
			"Create a new UI process, including a new canvas consistent with updated Display."
			UISupervisor spawnNewMorphicProcessFor: self createNewCanvas: true.
			"Terminate the current process (the old UI process). This is needed because the old canvas can no longer be used:
			A canvas + vector engine inconsistent with Display will cause invalid memory accesses, crashing the system."
			Processor terminateActive.
			].! !
!HandMorph methodsFor: 'event handling' stamp: 'jmv 7/1/2025 16:27:55' prior: 16878383!
            processEventQueue
	"Process user input events from the local input devices.
	Answer true if any event was handled (but ignore MouseMove)"

	| evt evtBuf type hadAny mcs hadAnyMouseEvent hadAnyMouseMoveEvent |
	mcs := mouseClickState.
	hadAny := false.
	hadAnyMouseEvent := false.
	hadAnyMouseMoveEvent := false.
	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [
		type := evtBuf first.
		evt := self createEventFrom: evtBuf ofType: type.
		evt ifNotNil: [
			"Finally, handle it. But process only up to one mouseMove per cycle. Discard the rest."
			(evt isMouseMove and: [ hadAnyMouseMoveEvent ]) ifFalse: [
				self startEventDispatch: evt.
				(evt isMouse or: [ evt isKeyboard ]) ifTrue: [
					hadAny := true ].
				evt isMouse ifTrue: [
					hadAnyMouseEvent := true.
					evt isMouseMove ifTrue: [
						hadAnyMouseMoveEvent := true ]]]]].
	hadAnyMouseEvent ifFalse: [
		mcs 
			ifNotNil: [ 
				"No mouse events during this cycle. Make sure click states time out accordingly"
				mcs
					handleEvent: lastMouseEvent asMouseMove
					from: self ]].
	^hadAny! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7301-checkForNewScreenSize-tweaks-YourName-2025Jul01-16h48m-mv.001.cs.st----!

'From Cuis7.5 [latest update: #7279] on 25 June 2025 at 10:07:32 am'!
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 6/25/2025 10:02:13'!
                    undeclaredReferences
	"
	Smalltalk undeclaredReferences
	"
	| undeclaredReferences |
	
	undeclaredReferences := Dictionary new.
	self cleanOutUndeclared.
	Undeclared associationsDo: [ :undeclaredAssoc |
		undeclaredReferences
			at: undeclaredAssoc key
			put: (self allCallsOn: undeclaredAssoc) ].

	^undeclaredReferences! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'HAW 6/25/2025 10:00:33' prior: 16971633!
                            browseUndeclaredReferences
	"
	Smalltalk browseUndeclaredReferences
	"
	| undeclaredReferences |
	
	undeclaredReferences := self undeclaredReferences.
	undeclaredReferences ifEmpty: [
		 ^(PopUpMenu labels: ' OK ') startUpWithCaption: 'There are no Undeclared at all' ].
	
	undeclaredReferences keysAndValuesDo: [ :undeclared :references |
		self
			browseMessageList: references
			name: 'References to Undeclared: ', undeclared printString ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7302-browseUndeclaredReferencesDecoupling-HernanWilkinson-2025Jun25-09h23m-HAW.001.cs.st----!

'From Cuis7.5 [latest update: #7294] on 27 June 2025 at 2:25:24 pm'!

Smalltalk renameClassNamed: #LayoutSpec as: #LayoutSizeSpec!

!classRenamed: #LayoutSpec as: #LayoutSizeSpec stamp: 'Install-7303-LayoutSpec-renameAs-LayoutSizeSpec-2025Jun27-14h01m-jmv.001.cs.st 7/15/2025 11:02:09'!
Smalltalk renameClassNamed: #LayoutSpec as: #LayoutSizeSpec!
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 6/27/2025 14:24:58' prior: 16930554!
               layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec useAll.
	layoutSpec morph: self.

	^ layoutSpec ! !
!BoxMorph methodsFor: 'layout-properties' stamp: 'jmv 6/27/2025 14:24:58' prior: 16796867 overrides: 50338394!
                            layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec keepMorphExtent.
	layoutSpec morph: self.

	^ layoutSpec! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:58' prior: 16896534!
   addAdjusterAndMorph: aMorph fixedHeight: aNumber
	"Convenience method.
	Add others as necessary."
	self addAdjusterAndMorph: aMorph layoutSpec: (LayoutSizeSpec fixedHeight: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:57' prior: 16896552!
       addAdjusterAndMorph: aMorph proportionalHeight: aNumber
	"Convenience method.
	Add others as necessary."
	self addAdjusterAndMorph: aMorph layoutSpec: (LayoutSizeSpec proportionalHeight: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:57' prior: 16896561!
                         addAdjusterAndMorph: aMorph proportionalWidth: aNumber
	"Convenience method.
	Add others as necessary."
	self addAdjusterAndMorph: aMorph layoutSpec: (LayoutSizeSpec proportionalWidth: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:57' prior: 16896570!
                           addMorph: aMorph fixedHeight: aNumber
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: (LayoutSizeSpec fixedHeight: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:58' prior: 16896578!
                             addMorph: aMorph fixedWidth: aNumber
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: (LayoutSizeSpec fixedWidth: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:57' prior: 16896586!
                               addMorph: aMorph proportionalHeight: aNumber
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: (LayoutSizeSpec proportionalHeight: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:58' prior: 16896594!
               addMorph: aMorph proportionalWidth: aNumber
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: (LayoutSizeSpec proportionalWidth: aNumber)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:57' prior: 16896602!
                 addMorphKeepMorphHeight: aMorph
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: (LayoutSizeSpec new useMorphHeight)! !
!LayoutMorph methodsFor: 'convenience methods' stamp: 'jmv 6/27/2025 14:24:58' prior: 16896610!
     addMorphUseAll: aMorph
	"Convenience method.
	Add others as necessary."
	self addMorph: aMorph layoutSpec: LayoutSizeSpec useAll! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897126!
                           addAdjusterMorph
	"So the user can adjust layout"
	"twekear para ui grande..."

	| thickness |
	thickness := Theme current layoutAdjusterThickness.

	direction == #horizontal ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedWidth: thickness) ].

	direction == #vertical ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedHeight: thickness)]! !
!LayoutMorph methodsFor: 'layout in owner' stamp: 'jmv 6/27/2025 14:24:58' prior: 16897214 overrides: 50338406!
      layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec useAll.
	layoutSpec morph: self.

	^ layoutSpec ! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:58' prior: 16897274!
                example1
"
	self example1
"
| pane row |
pane := (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897340!
                example10
"
	self example10 openInWorld
"
| pane row |
pane := (LayoutMorph newColumn separation: 5)	name: #example10.
pane color: Color red.

row := LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
^ pane! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:58' prior: 16897407!
     example101VG
"
	self example101VG
"
| pane row |
pane := (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (Sample09Clock new name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 100); 
	addMorph: (Sample01Star new name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample03Smiley new name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (Sample03Smiley new name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color lightRed;
	addMorph: (Sample02Bezier new name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample02Bezier new  name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (Sample02Bezier new  name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897466!
        example11
"
	self example11
"
| pane row |
pane := (LayoutMorph newColumn separation: 5)	name: #example11.
pane color: Color red.

row := LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897534!
                               example13
	"
	self example13
	"
	| pane row innerRow |
pane := (LayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Color red.
	row := (LayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897581!
           example1b
"
Based on #example1, but using some ImageMorph instead of RectangleLikeMorph, so extent is not adjustable
	self example1b
"
| pane row |
pane := (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ImageMorph new name: #B);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ImageMorph new name: #G);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ImageMorph new name: #J);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897641!
      example2
	"
	self example2
	"
	| pane row |
	pane := (LayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Color red.
	row := (LayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8 offAxisEdgeWeight: #rightOrBottom);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 0.7 offAxisEdgeWeight: #center).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 200@180 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897672!
                    example20
"
	self example20
"
| column |

column := (LayoutMorph newColumn separation: 5) name: #Column.
column
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 30).
column position: 150@130 extent: 400@300.
column openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897695!
 example3
	"
	self example3
	"
	| pane row innerRow |
pane := (LayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Color red.
	row := (LayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897737!
                  example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane := LayoutMorph newRow separation: 5. "1"
pane addMorph: (LabelMorph contents: '1').

rect1 := ColoredBoxMorph new color: (Color lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Color lightGreen;
	position: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane := LayoutMorph newRow separation: 5. "2"
pane addMorph: (LabelMorph contents: '2').

rect1 := ColoredBoxMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane
	color: Color lightGreen;
	position: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane := LayoutMorph newRow separation: 5. "3"
pane addMorph: (LabelMorph contents: '3').

rect1 := ColoredBoxMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
rect2 := ColoredBoxMorph new color: (Color cyan);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	position: 520 @ 50 extent: 180 @ 100;
	openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897808!
   exampleEdgesColumn
	"Show 2 cases :1 useEdgeSpace true and 1 false"
	" self exampleEdgesColumn "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newColumn :: padding: (120 @ 40);  gap: 20.
	noEdge := self newColumn ::  padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 200; proportionalHeight: 0.8 minimum: 200.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 200; proportionalHeight: 0.5 minimum: 200.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/27/2025 14:24:57' prior: 16897843!
                  exampleEdgesRow
	"Show 2 cases: 1 useEdgeSpace true and 1 false"
	" self exampleEdgesRow "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newRow :: padding: (120 @ 40);  gap: 20.
	noEdge := self newRow :: padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 100; proportionalHeight: 0.8 minimum: 100.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 100; proportionalHeight: 0.5 minimum: 100.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 6/27/2025 14:24:57' prior: 16983113 overrides: 16896737!
          initialize
	super initialize.
	viewBox := LayoutMorph newRow color: self defaultColor.
	self
		addMorph: (clock := UpdatingLabelMorph initializedInstance)
		layoutSpec:  (LayoutSizeSpec morphWidthProportionalHeight: 0.5).
	self
		addMorph: viewBox 
		layoutSpec: (LayoutSizeSpec
			proportionalWidth: 1.0
			proportionalHeight: 1.0 
			offAxisEdgeWeight: #rightOrBottom).
	viewBox separation: self defaultHeight // 8.
	self setBalloonText: [ 
		'About this system:' bold, `String newLineString`,
		Smalltalk systemInformationString ].
	clock
		setProperty: #handlesMouseDown: toValue: true;
		setProperty: #'mouseButton1Down:localPosition:' 
		toValue: [ :evt : pos | | menu taskbarEdge point | 
			self runningWorld ifNotNil: [ :w |
				taskbarEdge := self positionInWorld y.
				menu := (Preferences at: #worldMenu) getMenuIn: w at: w activeHand.	
				menu hide.
				w addMorph: menu. ": Otherwise we do not have a proper extent"
				point := 0 @ (taskbarEdge - menu extentInWorld y).
				menu popUpAt: point allowKeyboard: false ] ]! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 6/27/2025 14:24:57' prior: 50332070!
                          addStayUpIcons
	| closeButton pinButton w buttonHW |
	(Preferences at: #optionalButtons) ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	buttonHW := Theme current titleBarButtonsExtent x.
	closeButton := PluggableButtonMorph model: self action: #delete.
	closeButton iconDrawSelector: #drawCloseIcon; noButtonShape.
	pinButton := PluggableButtonMorph model: self action: #stayUp.
	pinButton iconDrawSelector: #drawPushPinIcon; noButtonShape.
	w := (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + (buttonHW*2).
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: buttonHW * 12 // 10);
			color: `Color transparent`;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//10;
			addMorph: (closeButton layoutSpec: (LayoutSizeSpec fixedWidth: buttonHW fixedHeight: buttonHW));
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: pinButton fixedWidth: buttonHW;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//3).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 6/27/2025 14:24:57' prior: 16825667!
                        buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout updateReqButton |
	requirements := PluggableListMorph
		withModel: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
		
	deleteReqButton := (PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete')
							setBalloonText: 'Remove selected Feature requirement'.
	deleteReqButton color: self widgetsColor.
	updateReqButton := (PluggableButtonMorph 
							model: requirements model
							action: #updateSelectedRequirement 
							label: 'update')
							setBalloonText: 'Update requirement to current Feature revision'.
	updateReqButton color: self widgetsColor.
							
	buttonLayout := LayoutMorph newRow.
	buttonLayout 
		addMorph: deleteReqButton 
		layoutSpec: (LayoutSizeSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						offAxisEdgeWeight: #leftOrTop);
		color: self widgetsColor quiteWhiter;
		addMorph: updateReqButton 
		layoutSpec: (LayoutSizeSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						offAxisEdgeWeight: #leftOrTop);
		color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSizeSpec 
							proportionalWidth: 0.8
							proportionalHeight: 1.0 
							offAxisEdgeWeight: #leftOrTop);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSizeSpec 
							proportionalWidth: 0.2 
							proportionalHeight: 1.0 
							offAxisEdgeWeight: #rightOrBottom);
		color: `Color transparent`;
		yourself
		! !
!LayoutSizeSpec class methodsFor: 'instance creation' stamp: 'jmv 6/27/2025 14:24:57' prior: 16898301!
   fixedWidth: aNumber fixedHeight: otherNumber
	^ LayoutSizeSpec new
		fixedWidth: aNumber;
		fixedHeight: otherNumber! !
!LayoutSizeSpec class methodsFor: 'instance creation' stamp: 'jmv 6/27/2025 14:24:57' prior: 16898308!
 fixedWidth: aNumber fixedHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber
	^ LayoutSizeSpec new
		fixedWidth: aNumber;
		fixedHeight: otherNumber;
		offAxisEdgeWeight: aSymbolOrNumber! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7303-LayoutSpec-renameAs-LayoutSizeSpec-2025Jun27-14h01m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7294] on 27 June 2025 at 2:25:55 pm'!

Object subclass: #LayoutSpec
	instanceVariableNames: 'morph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutSpec category: #'Morphic-Layouts' stamp: 'Install-7304-LayoutSpec-create-JuanVuletich-2025Jun27-14h25m-jmv.001.cs.st 7/15/2025 11:02:09'!
Object subclass: #LayoutSpec
	instanceVariableNames: 'morph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7304-LayoutSpec-create-JuanVuletich-2025Jun27-14h25m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7294] on 27 June 2025 at 2:26:22 pm'!

LayoutSpec subclass: #LayoutSizeSpec
	instanceVariableNames: 'fixedWidth fixedHeight offAxisEdgeWeight proportionalWidth proportionalHeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutSizeSpec category: #'Morphic-Layouts' stamp: 'Install-7305-LayoutSizeSpec-subclassOf-LayoutSpec-2025Jun27-14h25m-jmv.001.cs.st 7/15/2025 11:02:10'!
LayoutSpec subclass: #LayoutSizeSpec
	instanceVariableNames: 'fixedWidth fixedHeight offAxisEdgeWeight proportionalWidth proportionalHeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7305-LayoutSizeSpec-subclassOf-LayoutSpec-2025Jun27-14h25m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7297] on 27 June 2025 at 2:34:19 pm'!
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 6/27/2025 14:33:50'!
      morph
	"For #showHalo"
	^ morph! !
!LayoutSpec methodsFor: 'accessing' stamp: 'jmv 6/27/2025 14:33:57'!
                        morph: aMorph
	morph := aMorph! !

LayoutSizeSpec removeSelector: #morph!

!methodRemoval: LayoutSizeSpec #morph stamp: 'Install-7306-LayoutSpec-morphAccessors-JuanVuletich-2025Jun27-14h32m-jmv.001.cs.st 7/15/2025 11:02:10'!
morph
	"For #showHalo"
	^ morph!

LayoutSizeSpec removeSelector: #morph:!

!methodRemoval: LayoutSizeSpec #morph: stamp: 'Install-7306-LayoutSpec-morphAccessors-JuanVuletich-2025Jun27-14h32m-jmv.001.cs.st 7/15/2025 11:02:10'!
morph: aMorph
	morph := aMorph!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7306-LayoutSpec-morphAccessors-JuanVuletich-2025Jun27-14h32m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7300] on 30 June 2025 at 10:19:15 am'!
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:18:45'!
   initializeColumn

	self initialize.

	gap := self defaultGap.
	axisEdgeWeight := 0.0.
	doAdoptWidgetsColor := false.
	self beColumn.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:18:34'!
             initializeRow

	self initialize.

	gap := self defaultGap.
	axisEdgeWeight := 0.0.
	doAdoptWidgetsColor := false.
	self beRow.! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 6/27/2025 15:16:07' prior: 16897265!
                          newColumn
	^self basicNew initializeColumn! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 6/27/2025 15:16:12' prior: 16897270!
              newRow
	^self basicNew initializeRow! !

LayoutMorph removeSelector: #initialize!

!methodRemoval: LayoutMorph #initialize stamp: 'Install-7307-LayoutMorph-Refactor-JuanVuletich-2025Jun30-10h15m-jmv.001.cs.st 7/15/2025 11:02:10'!
initialize
	super initialize.
	gap := self defaultGap.
	axisEdgeWeight := 0.0.
	doAdoptWidgetsColor := false.!

LayoutMorph removeSelector: #direction:!

!methodRemoval: LayoutMorph #direction: stamp: 'Install-7307-LayoutMorph-Refactor-JuanVuletich-2025Jun30-10h15m-jmv.001.cs.st 7/15/2025 11:02:10'!
direction: horizOrVert

	direction := horizOrVert!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7307-LayoutMorph-Refactor-JuanVuletich-2025Jun30-10h15m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7297] on 27 June 2025 at 2:51:16 pm'!

Object subclass: #Layout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #Layout category: #'Morphic-Layouts' stamp: 'Install-7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st 7/15/2025 11:02:10'!
Object subclass: #Layout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

Layout subclass: #FormLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #FormLayout category: #'Morphic-Layouts' stamp: 'Install-7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st 7/15/2025 11:02:10'!
Layout subclass: #FormLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!
!FormLayout commentStamp: '<historical>' prior: 0!
                    Inspired by https://archive.eclipse.org/eclipse/downloads/documentation/2.0/html/plugins/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormLayout.html!

Layout subclass: #LinearLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayout category: #'Morphic-Layouts' stamp: 'Install-7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st 7/15/2025 11:02:10'!
Layout subclass: #LinearLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

LinearLayout subclass: #ColumnLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #ColumnLayout category: #'Morphic-Layouts' stamp: 'Install-7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st 7/15/2025 11:02:10'!
LinearLayout subclass: #ColumnLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

LinearLayout subclass: #RowLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #RowLayout category: #'Morphic-Layouts' stamp: 'Install-7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st 7/15/2025 11:02:10'!
LinearLayout subclass: #RowLayout
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7308-LayoutHierarchy-JuanVuletich-2025Jun27-14h43m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7301] on 30 June 2025 at 10:32:15 am'!

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7309-CreateLayoutInLayoutMorphs-JuanVuletich-2025Jun30-10h24m-jmv.001.cs.st 7/15/2025 11:02:10'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

Layout subclass: #LinearLayout
	instanceVariableNames: 'gap axisEdgeWeight '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayout category: #'Morphic-Layouts' stamp: 'Install-7309-CreateLayoutInLayoutMorphs-JuanVuletich-2025Jun30-10h24m-jmv.001.cs.st 7/15/2025 11:02:10'!
Layout subclass: #LinearLayout
	instanceVariableNames: 'gap axisEdgeWeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!
!LinearLayout methodsFor: 'accessing' stamp: 'jmv 6/27/2025 15:05:35'!
         gap: aNumber axisEdgeWeight: aNumberOrNil
	gap := aNumber.
	axisEdgeWeight := aNumberOrNil.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:29:04' prior: 16896696!
      beColumn
	"Establish the major layout axis, with default edge weight" 
	direction := #vertical.
	axisEdgeWeight ifNil: [self axisEdgeWeight: #center].
	layout := ColumnLayout new.
	layout gap: gap axisEdgeWeight: axisEdgeWeight.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:29:09' prior: 16896704!
      beRow
	"Establish the major layout axis, with default edge weight" 
	direction := #horizontal.
	axisEdgeWeight ifNil: [self axisEdgeWeight: #rowLeft].
	layout := RowLayout new.
	layout gap: gap axisEdgeWeight: axisEdgeWeight.
	self layoutSubmorphs.! !

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7309-CreateLayoutInLayoutMorphs-JuanVuletich-2025Jun30-10h24m-jmv.001.cs.st 7/15/2025 11:02:10'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

Layout subclass: #LinearLayout
	instanceVariableNames: 'gap axisEdgeWeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayout category: #'Morphic-Layouts' stamp: 'Install-7309-CreateLayoutInLayoutMorphs-JuanVuletich-2025Jun30-10h24m-jmv.001.cs.st 7/15/2025 11:02:10'!
Layout subclass: #LinearLayout
	instanceVariableNames: 'gap axisEdgeWeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	LayoutMorph allSubInstancesDo: [ :lm | | l |
		l := lm isRow ifTrue: [ RowLayout new ] ifFalse: [ ColumnLayout new ].
		l gap: lm gap axisEdgeWeight: lm axisEdgeWeight.
		lm instVarNamed: 'layout' put: l ].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7309-CreateLayoutInLayoutMorphs-JuanVuletich-2025Jun30-10h24m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7302] on 30 June 2025 at 11:08:05 am'!
!LinearLayout methodsFor: 'accessing' stamp: 'jmv 6/30/2025 11:01:21'!
          axisEdgeWeight
	^axisEdgeWeight! !
!LinearLayout methodsFor: 'accessing' stamp: 'jmv 6/30/2025 10:55:12'!
                      axisEdgeWeight: aNumberOrNil
	axisEdgeWeight := aNumberOrNil.! !
!LinearLayout methodsFor: 'accessing' stamp: 'jmv 6/30/2025 11:05:20'!
                        gap
	^gap! !
!LinearLayout methodsFor: 'accessing' stamp: 'jmv 6/30/2025 10:46:07'!
            gap: aNumber
	gap := aNumber! !
!ColumnLayout methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:56:22' overrides: 16940323!
initialize
	gap := 0.
	axisEdgeWeight := 0.5. "#center"! !
!RowLayout methodsFor: 'initialization' stamp: 'jmv 6/30/2025 10:56:34' overrides: 16940323!
        initialize
	gap := 0.
	axisEdgeWeight := 0.0. "#rowLeft"! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 6/30/2025 11:04:39' prior: 16896332!
              axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the 	 	 LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	| edgeWeight |
	(aSymbolOrNumber is: #Number)
		ifTrue: [ (aSymbolOrNumber between: 0.0 and: 1.0)
			ifTrue: [edgeWeight := aSymbolOrNumber ] 
			ifFalse: [self error: 'axisEdgeWeight ', aSymbolOrNumber printString, ' is out of range 0.0 to 1.0']
		]
		ifFalse: [
			(self direction = #horizontal) 
				ifTrue: [ "Row"
					edgeWeight := aSymbolOrNumber
						caseOf: {
							[ #rowLeft ] -> [ 0.0 ].
							[ #center ] -> [ 0.5 ].
							[ #rowRight ] -> [ 1.0 ]
						}
						otherwise: [ self error: 'bad axisEdgeWeight for Row: ', aSymbolOrNumber printString ].
				]
				ifFalse: [ "vertical => Column"
					edgeWeight := aSymbolOrNumber
						caseOf: {
							[ #columnTop ] -> [ 0.0 ].
							[ #center ] -> [ 0.5 ].
							[ #columnBottom ] -> [ 1.0 ]
						}
						otherwise: [ self error: 'bad axisEdgeWeight for Column: ', aSymbolOrNumber printString ].
				]
		].
	layout axisEdgeWeight: edgeWeight.
	self layoutSubmorphs! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 6/30/2025 11:06:53' prior: 16896397!
gap: aNumber

	layout gap = aNumber ifFalse: [
		self adjustExtentFor: [
			layout gap: aNumber ]].
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 6/30/2025 11:06:05' prior: 16896659!
             minimumExtent: cachedValues
	"Answer size sufficient to frame my submorphs."
	
	| width height mle |
	width  := 0.
	height := 0.
	(self direction = #vertical)
		ifTrue: [ "Column"
			self submorphsToLayout do: [ :sm |
				mle := sm minimumLayoutExtent: cachedValues.
				"use maximum width across submorphs"
				width := width max: mle x.
				"sum up submorph heights, including separation between them"
				height := height + mle y + layout gap.
			].
			height := height - layout gap. "An extra gap was just added"
		]
		ifFalse: [ "Row"
			self submorphsToLayout do: [ :sm |
				mle := sm minimumLayoutExtent: cachedValues.
				"sum up submorphs width, include gap"
				width := width + mle x + layout gap.
				"use maximum height across submorph"
				height := height max: mle y.
			].
			width := width - layout gap. "An extra gap was just added"
		].
	^ (width @ height) + (2 * self interiorOrigin)! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 11:04:49' prior: 50339553!
                         beColumn
	"Establish the major layout axis, with default edge weight" 
	direction := #vertical.
	layout := ColumnLayout new.
	layout gap: self defaultGap.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 11:04:45' prior: 50339564!
                beRow
	"Establish the major layout axis, with default edge weight" 
	direction := #horizontal.
	layout := RowLayout new.
	layout gap: self defaultGap.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 11:06:24' prior: 50339384!
                    initializeColumn

	self initialize.

	doAdoptWidgetsColor := false.
	self beColumn.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 11:06:20' prior: 50339391!
              initializeRow

	self initialize.

	doAdoptWidgetsColor := false.
	self beRow.! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:05:29' prior: 16896892!
                            layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount widths widthToAllocate leftOver x cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * layout gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleSubmorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * layout axisEdgeWeight).

	visibleSubmorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + layout gap.
	].! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:05:36' prior: 16896935!
    layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount heights heightToAllocate leftOver y cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * layout gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleSubmorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * layout axisEdgeWeight).

	visibleSubmorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + layout gap.
	].! !

LayoutMorph removeSelector: #gap!

!methodRemoval: LayoutMorph #gap stamp: 'Install-7310-gap-axisEdgeWeight-toLayoutObject-2025Jun30-10h59m-jmv.002.cs.st 7/15/2025 11:02:10'!
gap
	^gap!

LayoutMorph removeSelector: #axisEdgeWeight!

!methodRemoval: LayoutMorph #axisEdgeWeight stamp: 'Install-7310-gap-axisEdgeWeight-toLayoutObject-2025Jun30-10h59m-jmv.002.cs.st 7/15/2025 11:02:10'!
axisEdgeWeight

	^ axisEdgeWeight ifNil: [
		direction == #horizontal
			ifTrue: [0.0]
			ifFalse: [0.5]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7310-gap-axisEdgeWeight-toLayoutObject-2025Jun30-10h59m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7303] on 30 June 2025 at 11:44:48 am'!
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:24:40'!
                           heightsFor: visibleSubs within: overallHeight minLayoutExtentCache: cache
	"Answer array of morphHeights for visibleSubs."
	"Preconditions: 
		ySepararations already subtracted from overallHeight.
		overallHeight is large enough to contain minimumLayoutHeights of visibleSubs."

	| numSubs scaleFactor heightToAllocate
	  sumOfPropMin sumOfPropDesired sumOfPropOriginallyDesired sumOfFixedMin
	  allocatedHeights propIndices desiredProps
	  maxOfMinAllocHeight |
	numSubs := visibleSubs size.
	sumOfFixedMin := 0.  "pixels"
	sumOfPropMin := 0.  "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	sumOfPropOriginallyDesired := 0. "Different from sumOfPropDesired if some #maximumLayoutHeight"
	allocatedHeights := Array new: numSubs.
	desiredProps := Array new: numSubs.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: numSubs do: [ :index | | sm layoutHeightMin |
		sm := visibleSubs at: index.
		layoutHeightMin := (sm minimumLayoutExtent: cache) y.
		allocatedHeights at: index put: layoutHeightMin.
		(sm isProportionalHeight)
			ifTrue:  [ | propDesired maxHeight |
				propDesired := sm layoutSpec privateProportionalHeight.
				sumOfPropOriginallyDesired := sumOfPropOriginallyDesired + propDesired.
				maxHeight := sm maximumLayoutHeight.
				(maxHeight notNil and: [ maxHeight < (propDesired * overallHeight)])
					ifTrue: [
						allocatedHeights at: index put: maxHeight.
						sumOfFixedMin := sumOfFixedMin + maxHeight ]
					ifFalse: [
						propIndices add: index.
						desiredProps at: index put: propDesired.
						sumOfPropDesired := sumOfPropDesired + propDesired.
						sumOfPropMin := sumOfPropMin + layoutHeightMin ]]
			ifFalse: [ "Allocate height for non-proportional-height morphs"
				sumOfFixedMin := sumOfFixedMin + layoutHeightMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallHeight - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedHeights ]. 
			
	"All fixed heights allocated; rest is for proportional + leftOver"
	heightToAllocate := (overallHeight - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional heights is more than 1.0,
	scale to make it all fit."
	sumOfPropOriginallyDesired > 0.999 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].

	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedHeights at: morphIndex 
			put:  ((allocatedHeights at: morphIndex) max:
				(heightToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding height is above max of minHeights
	 Keep the proportions over the minHeights at this allocation."
	maxOfMinAllocHeight := propIndices max: [ :morphIndex | 
		(visibleSubs at: morphIndex) allocHeightForFactor: scaleFactor minLayoutExtentCache: cache ].

	"Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(heightToAllocate <= maxOfMinAllocHeight) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ heightToAllocate := heightToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleSubs size.
		propIndices do: [ :morphIndex | | heightAtBalance | 
			heightAtBalance := maxOfMinAllocHeight * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: heightAtBalance "delta above min height"
			 	  	- (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) y)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex | 
				allocatedHeights at: morphIndex
					put: (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) y)
						+ (((heightToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedHeights! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:23:10'!
                            layoutMorphs: visibleSubmorphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| gapCount heights heightToAllocate leftOver y cache |

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleSubmorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * axisEdgeWeight).

	visibleSubmorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + gap.
	].! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:23:46'!
        offAxisWidthFor: aMorph within: availableWidth minLayoutExtentCache: cache
	"Answer width for a single morph -- offAxis calculation for a Column"

	^ (availableWidth * aMorph layoutSpec proportionalLayoutWidth)
						 	max: (aMorph minimumLayoutExtent: cache) x.
! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:24:03'!
                 offAxisXOffsetFor: aMorph within: availableWidth
	"Answer x offset for a single morph -- offAxis calculation for a Column"

	^ availableWidth * aMorph layoutSpec offAxisEdgeWeight. ! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:17:05'!
      layoutMorphs: visibleSubmorphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| gapCount widths widthToAllocate leftOver x cache |

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleSubmorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * axisEdgeWeight).

	visibleSubmorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + gap.
	].! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:19:33'!
               offAxisHeightFor: aMorph within: availableHeight minLayoutExtentCache: cache
	"Answer height for a single morph -- offAxis calculation for a Row"
	
	^(availableHeight * aMorph layoutSpec proportionalLayoutHeight)
							 max: (aMorph minimumLayoutExtent: cache) y.! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:19:58'!
                   offAxisYOffsetFor: aMorph within: availableHeight
	"Answer y offset for a single morph -- offAxis calculation for a Row"
	
	^ availableHeight * aMorph layoutSpec offAxisEdgeWeight! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:18:40'!
        widthsFor: visibleSubs within: overallWidth minLayoutExtentCache: cache
	"Answer array of morphWidths for visibleSubs."
	"Preconditions: 
		xSepararations already subtracted from overallWidth.
		overallWidth is large enough to contain minimumLayoutWidths of visibleSubs."
	
	| numSubs scaleFactor widthToAllocate
	  sumOfPropMin sumOfPropDesired sumOfFixedMin
	  allocatedWidths propIndices desiredProps
	  maxOfMinAllocWidth |
	numSubs := visibleSubs size.
	sumOfFixedMin := 0. "pixels"
	sumOfPropMin := 0. "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	allocatedWidths := Array new: numSubs.
	desiredProps := Array new: numSubs.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: numSubs do: [ :index | | sm layoutWidthMin |
		sm := visibleSubs at: index.
		layoutWidthMin := (sm minimumLayoutExtent: cache) x.
		allocatedWidths at: index put: layoutWidthMin.
		(sm isProportionalWidth)
			ifTrue:  [ | propDesired |
				propIndices add: index.
				propDesired := sm layoutSpec privateProportionalWidth.
				desiredProps at: index put: propDesired.
				sumOfPropDesired := sumOfPropDesired + propDesired.
				sumOfPropMin := sumOfPropMin + layoutWidthMin ]
			ifFalse: [ "Allocate width for non-proportional-width morphs"
				sumOfFixedMin := sumOfFixedMin + layoutWidthMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallWidth - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedWidths ]. 
			
	"All fixed widths allocated; rest is for proportional + leftOver"
	widthToAllocate := (overallWidth - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional widths is more than 1.0,
	scale to make it all fit."
	sumOfPropDesired > 1.0 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].
	
	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedWidths at: morphIndex 
			put:  ((allocatedWidths at: morphIndex) max:
				(widthToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding width is above max of minWidths
	 Keep the proportions over the minWidths at this allocation."
	maxOfMinAllocWidth := propIndices max: [ :morphIndex | 
		(visibleSubs at: morphIndex) allocWidthForFactor: scaleFactor minLayoutExtentCache: cache ].

     "Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(widthToAllocate <= maxOfMinAllocWidth) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ widthToAllocate := widthToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleSubs size.
		propIndices do: [ :morphIndex | | widthAtBalance | 
			widthAtBalance := maxOfMinAllocWidth * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: widthAtBalance "delta above min width"
					- (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) x)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex |
				allocatedWidths at: morphIndex
					put: (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) x) 
						+ (((widthToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedWidths! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/30/2025 11:39:09' prior: 50334562!
                      layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs |
	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self ].

	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order") ifEmpty: [
		self layoutNeeded: false.
		^self ].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.

	layout layoutMorphs: visibleSubmorphs in: self layoutBounds.
	self layoutNeeded: false.! !

LayoutMorph removeSelector: #widthsFor:within:minLayoutExtentCache:!

!methodRemoval: LayoutMorph #widthsFor:within:minLayoutExtentCache: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:10'!
widthsFor: visibleSubs within: overallWidth minLayoutExtentCache: cache
	"Answer array of morphWidths for visibleSubs."
	"Preconditions: 
		xSepararations already subtracted from overallWidth.
		overallWidth is large enough to contain minimumLayoutWidths of visibleSubs."
	
	| numSubs scaleFactor widthToAllocate
	  sumOfPropMin sumOfPropDesired sumOfFixedMin
	  allocatedWidths propIndices desiredProps
	  maxOfMinAllocWidth |
	numSubs := visibleSubs size.
	sumOfFixedMin := 0. "pixels"
	sumOfPropMin := 0. "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	allocatedWidths := Array new: numSubs.
	desiredProps := Array new: numSubs.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: numSubs do: [ :index | | sm layoutWidthMin |
		sm := visibleSubs at: index.
		layoutWidthMin := (sm minimumLayoutExtent: cache) x.
		allocatedWidths at: index put: layoutWidthMin.
		(sm isProportionalWidth)
			ifTrue:  [ | propDesired |
				propIndices add: index.
				propDesired := sm layoutSpec privateProportionalWidth.
				desiredProps at: index put: propDesired.
				sumOfPropDesired := sumOfPropDesired + propDesired.
				sumOfPropMin := sumOfPropMin + layoutWidthMin ]
			ifFalse: [ "Allocate width for non-proportional-width morphs"
				sumOfFixedMin := sumOfFixedMin + layoutWidthMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallWidth - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedWidths ]. 
			
	"All fixed widths allocated; rest is for proportional + leftOver"
	widthToAllocate := (overallWidth - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional widths is more than 1.0,
	scale to make it all fit."
	sumOfPropDesired > 1.0 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].
	
	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedWidths at: morphIndex 
			put:  ((allocatedWidths at: morphIndex) max:
				(widthToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding width is above max of minWidths
	 Keep the proportions over the minWidths at this allocation."
	maxOfMinAllocWidth := propIndices max: [ :morphIndex | 
		(visibleSubs at: morphIndex) allocWidthForFactor: scaleFactor minLayoutExtentCache: cache ].

     "Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(widthToAllocate <= maxOfMinAllocWidth) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ widthToAllocate := widthToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleSubs size.
		propIndices do: [ :morphIndex | | widthAtBalance | 
			widthAtBalance := maxOfMinAllocWidth * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: widthAtBalance "delta above min width"
					- (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) x)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex |
				allocatedWidths at: morphIndex
					put: (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) x) 
						+ (((widthToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedWidths!

LayoutMorph removeSelector: #offAxisYOffsetFor:within:!

!methodRemoval: LayoutMorph #offAxisYOffsetFor:within: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:10'!
offAxisYOffsetFor: aMorph within: availableHeight
	"Answer y offset for a single morph -- offAxis calculation for a Row"
	
	^ availableHeight * aMorph layoutSpec offAxisEdgeWeight!

LayoutMorph removeSelector: #offAxisWidthFor:within:minLayoutExtentCache:!

!methodRemoval: LayoutMorph #offAxisWidthFor:within:minLayoutExtentCache: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:10'!
offAxisWidthFor: aMorph within: availableWidth minLayoutExtentCache: cache
	"Answer width for a single morph -- offAxis calculation for a Column"

	^ (availableWidth * aMorph layoutSpec proportionalLayoutWidth)
						 	max: (aMorph minimumLayoutExtent: cache) x.
!

LayoutMorph removeSelector: #offAxisHeightFor:within:minLayoutExtentCache:!

!methodRemoval: LayoutMorph #offAxisHeightFor:within:minLayoutExtentCache: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:10'!
offAxisHeightFor: aMorph within: availableHeight minLayoutExtentCache: cache
	"Answer height for a single morph -- offAxis calculation for a Row"
	
	^(availableHeight * aMorph layoutSpec proportionalLayoutHeight)
							 max: (aMorph minimumLayoutExtent: cache) y.!

LayoutMorph removeSelector: #offAxisXOffsetFor:within:!

!methodRemoval: LayoutMorph #offAxisXOffsetFor:within: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:10'!
offAxisXOffsetFor: aMorph within: availableWidth
	"Answer x offset for a single morph -- offAxis calculation for a Column"

	^ availableWidth * aMorph layoutSpec offAxisEdgeWeight. !

LayoutMorph removeSelector: #layoutSubmorphsHorizontallyIn:!

!methodRemoval: LayoutMorph #layoutSubmorphsHorizontallyIn: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:10'!
layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount widths widthToAllocate leftOver x cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * layout gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleSubmorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * layout axisEdgeWeight).

	visibleSubmorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + layout gap.
	].!

LayoutMorph removeSelector: #layoutSubmorphsVerticallyIn:!

!methodRemoval: LayoutMorph #layoutSubmorphsVerticallyIn: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:10'!
layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount heights heightToAllocate leftOver y cache |
	"Preconditions: self isRow & morphExtent >= minimumLayoutExtent"
	(visibleSubmorphs := self submorphsToLayout reversed  "Display Order")
		ifEmpty: [ ^ self. "Nothing to layout, besides `sum` below, would fail" ].

	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * layout gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleSubmorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * layout axisEdgeWeight).

	visibleSubmorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + layout gap.
	].!

LayoutMorph removeSelector: #heightsFor:within:minLayoutExtentCache:!

!methodRemoval: LayoutMorph #heightsFor:within:minLayoutExtentCache: stamp: 'Install-7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st 7/15/2025 11:02:10'!
heightsFor: visibleSubs within: overallHeight minLayoutExtentCache: cache
	"Answer array of morphHeights for visibleSubs."
	"Preconditions: 
		ySepararations already subtracted from overallHeight.
		overallHeight is large enough to contain minimumLayoutHeights of visibleSubs."

	| numSubs scaleFactor heightToAllocate
	  sumOfPropMin sumOfPropDesired sumOfPropOriginallyDesired sumOfFixedMin
	  allocatedHeights propIndices desiredProps
	  maxOfMinAllocHeight |
	numSubs := visibleSubs size.
	sumOfFixedMin := 0.  "pixels"
	sumOfPropMin := 0.  "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	sumOfPropOriginallyDesired := 0. "Different from sumOfPropDesired if some #maximumLayoutHeight"
	allocatedHeights := Array new: numSubs.
	desiredProps := Array new: numSubs.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: numSubs do: [ :index | | sm layoutHeightMin |
		sm := visibleSubs at: index.
		layoutHeightMin := (sm minimumLayoutExtent: cache) y.
		allocatedHeights at: index put: layoutHeightMin.
		(sm isProportionalHeight)
			ifTrue:  [ | propDesired maxHeight |
				propDesired := sm layoutSpec privateProportionalHeight.
				sumOfPropOriginallyDesired := sumOfPropOriginallyDesired + propDesired.
				maxHeight := sm maximumLayoutHeight.
				(maxHeight notNil and: [ maxHeight < (propDesired * overallHeight)])
					ifTrue: [
						allocatedHeights at: index put: maxHeight.
						sumOfFixedMin := sumOfFixedMin + maxHeight ]
					ifFalse: [
						propIndices add: index.
						desiredProps at: index put: propDesired.
						sumOfPropDesired := sumOfPropDesired + propDesired.
						sumOfPropMin := sumOfPropMin + layoutHeightMin ]]
			ifFalse: [ "Allocate height for non-proportional-height morphs"
				sumOfFixedMin := sumOfFixedMin + layoutHeightMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallHeight - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedHeights ]. 
			
	"All fixed heights allocated; rest is for proportional + leftOver"
	heightToAllocate := (overallHeight - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional heights is more than 1.0,
	scale to make it all fit."
	sumOfPropOriginallyDesired > 0.999 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].

	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedHeights at: morphIndex 
			put:  ((allocatedHeights at: morphIndex) max:
				(heightToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding height is above max of minHeights
	 Keep the proportions over the minHeights at this allocation."
	maxOfMinAllocHeight := propIndices max: [ :morphIndex | 
		(visibleSubs at: morphIndex) allocHeightForFactor: scaleFactor minLayoutExtentCache: cache ].

	"Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(heightToAllocate <= maxOfMinAllocHeight) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ heightToAllocate := heightToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleSubs size.
		propIndices do: [ :morphIndex | | heightAtBalance | 
			heightAtBalance := maxOfMinAllocHeight * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: heightAtBalance "delta above min height"
			 	  	- (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) y)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex | 
				allocatedHeights at: morphIndex
					put: (((visibleSubs at: morphIndex) minimumLayoutExtent: cache) y)
						+ (((heightToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedHeights!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7311-Move-layoutAlgorithm-toLayoutObect-JuanVuletich-2025Jun30-11h28m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7303] on 30 June 2025 at 12:07:01 pm'!
!Layout methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:00:32'!
                       isColumn
	^false! !
!Layout methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:00:27'!
             isRow
	^false! !
!ColumnLayout methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:00:43' overrides: 50340624!
                      isColumn
	^true! !
!RowLayout methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:00:55' overrides: 50340627!
                       isRow
	^true! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 6/30/2025 12:03:02' prior: 50339656!
                          axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the 	 	 LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	| edgeWeight |
	(aSymbolOrNumber is: #Number)
		ifTrue: [ (aSymbolOrNumber between: 0.0 and: 1.0)
			ifTrue: [edgeWeight := aSymbolOrNumber ] 
			ifFalse: [self error: 'axisEdgeWeight ', aSymbolOrNumber printString, ' is out of range 0.0 to 1.0']
		]
		ifFalse: [
			layout isRow 
				ifTrue: [ "Row"
					edgeWeight := aSymbolOrNumber
						caseOf: {
							[ #rowLeft ] -> [ 0.0 ].
							[ #center ] -> [ 0.5 ].
							[ #rowRight ] -> [ 1.0 ]
						}
						otherwise: [ self error: 'bad axisEdgeWeight for Row: ', aSymbolOrNumber printString ].
				]
				ifFalse: [ "vertical => Column"
					edgeWeight := aSymbolOrNumber
						caseOf: {
							[ #columnTop ] -> [ 0.0 ].
							[ #center ] -> [ 0.5 ].
							[ #columnBottom ] -> [ 1.0 ]
						}
						otherwise: [ self error: 'bad axisEdgeWeight for Column: ', aSymbolOrNumber printString ].
				]
		].
	layout axisEdgeWeight: edgeWeight.
	self layoutSubmorphs! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 6/30/2025 12:03:46' prior: 16896408!
                  separation: aNumberOrPoint

	| g |
	self padding: aNumberOrPoint.
	g := aNumberOrPoint.
	g isPoint ifTrue: [
		g := layout isRow ifTrue: [ g x ] ifFalse: [ g y ]].
	self gap: g.! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 6/30/2025 12:02:43' prior: 16896417!
                        adjustBy: aLayoutAdjustMorph at: aGlobalPoint
	"See Class Comment of LayoutAdjustingMorph"

	| localPoint |
	localPoint := self internalizeFromWorld: aGlobalPoint.

	layout isRow ifTrue: [
		self adjustHorizontallyBy: aLayoutAdjustMorph at: localPoint ].

	layout isColumn ifTrue: [
		self adjustVerticallyBy: aLayoutAdjustMorph at: localPoint ].! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 6/30/2025 12:03:21' prior: 50339713!
             minimumExtent: cachedValues
	"Answer size sufficient to frame my submorphs."
	
	| width height mle |
	width  := 0.
	height := 0.
	layout isColumn
		ifTrue: [ "Column"
			self submorphsToLayout do: [ :sm |
				mle := sm minimumLayoutExtent: cachedValues.
				"use maximum width across submorphs"
				width := width max: mle x.
				"sum up submorph heights, including separation between them"
				height := height + mle y + layout gap.
			].
			height := height - layout gap. "An extra gap was just added"
		]
		ifFalse: [ "Row"
			self submorphsToLayout do: [ :sm |
				mle := sm minimumLayoutExtent: cachedValues.
				"sum up submorphs width, include gap"
				width := width + mle x + layout gap.
				"use maximum height across submorph"
				height := height max: mle y.
			].
			width := width - layout gap. "An extra gap was just added"
		].
	^ (width @ height) + (2 * self interiorOrigin)! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 12:04:10' prior: 50339745!
      beColumn
	"Establish the major layout axis, with default edge weight"
	layout := ColumnLayout new.
	layout gap: self defaultGap.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 6/30/2025 12:04:07' prior: 50339754!
          beRow
	"Establish the major layout axis, with default edge weight"
	layout := RowLayout new.
	layout gap: self defaultGap.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 6/30/2025 12:01:58' prior: 50338498!
          addAdjusterMorph
	"So the user can adjust layout"

	| thickness |
	thickness := Theme current layoutAdjusterThickness.

	layout isRow ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedWidth: thickness) ].

	layout isColumn ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedHeight: thickness)]! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:01:30' prior: 16897186!
                  isColumn

	^ layout isColumn! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 6/30/2025 12:01:22' prior: 16897190!
            isRow

	^ layout isRow! !
!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'jmv 6/30/2025 11:54:30' prior: 16896157!
       cursor
	^ layoutSpec fixedWidth = Theme current layoutAdjusterThickness
		ifTrue: [ Cursor cursorAt: #resizeLeftCursor ]
		ifFalse: [ Cursor cursorAt: #resizeTopCursor ].! !

LayoutMorph removeSelector: #direction!

!methodRemoval: LayoutMorph #direction stamp: 'Install-7312-LayoutMorph-cleanup-JuanVuletich-2025Jun30-11h44m-jmv.002.cs.st 7/15/2025 11:02:10'!
direction
	^direction!

LayoutMorph removeSelector: #desiredLayoutHeight!

!methodRemoval: LayoutMorph #desiredLayoutHeight stamp: 'Install-7312-LayoutMorph-cleanup-JuanVuletich-2025Jun30-11h44m-jmv.002.cs.st 7/15/2025 11:02:10'!
desiredLayoutHeight

	| fixed proportional |
	proportional := 0.
	fixed := 0.
	self submorphsToLayout do: [ :m | | ls |
		ls := m layoutSpec.
		ls isProportionalHeight ifTrue: [
			proportional := proportional max: ls fixedOrMinimumLayoutHeight / ls proportionalLayoutHeight ]
		ifFalse: [
			fixed := fixed + ls fixedOrMinimumLayoutHeight ]].
	^fixed + proportional!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7312-LayoutMorph-cleanup-JuanVuletich-2025Jun30-11h44m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7312] on 3 July 2025 at 1:06:25 pm'!
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 7/3/2025 10:49:34' prior: 50336954!
                     deferredUpdatingDisplay
	"Answer the instance to be used from most clients, including Morphic.
	If the platform supports #deferUpdates:
		Set Display to deferred upodating
		Answer will be Display itself.
	If the platform does NOT support #deferUpdates
		Answer a separate Form.
	Methods in this category provide convenient access."

	DeferredUpdatingDisplay ifNil: [
		 DeferredUpdatingDisplay := (Display deferUpdates: true)
			"Linux and Windows VM do support deferUpdates:, so Morphic Canvas target is Display.
			Mac VMs newer than July 2025 also do support it.
			For VMs that don't support deferUpdates:, use this aux Form as Morphic Canvas target."
			ifNil: [ Form extent: Display extent depth: Display depth ]].
	^DeferredUpdatingDisplay! !
!Transcript class methodsFor: 'private' stamp: 'jmv 7/3/2025 13:02:55' prior: 50337480!
                         displayEngine
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	"
	Transcript releaseClassCachedState
	"
	| deferredDisplay |
	deferredDisplay := DisplayScreen deferredUpdatingDisplay.
	(displayEngine isNil or: [ displayEngine class ~= BitBltCanvasEngine])
		ifTrue: [
			^ displayEngine := BitBltCanvasEngine toForm: deferredDisplay ].
	displayEngine destForm == deferredDisplay ifFalse: [
		displayEngine setDestForm: deferredDisplay ].
	^ displayEngine! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7313-deferredDisplay-tweaks-JuanVuletich-2025Jul03-13h01m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 2:56:12 pm'!
!ColumnLayout methodsFor: 'accessing' stamp: 'jmv 7/3/2025 14:55:32' overrides: 50339634!
     axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	| edgeWeight |
	(aSymbolOrNumber is: #Number)
		ifTrue: [ (aSymbolOrNumber between: 0.0 and: 1.0)
			ifTrue: [edgeWeight := aSymbolOrNumber ] 
			ifFalse: [self error: 'axisEdgeWeight ', aSymbolOrNumber printString, ' is out of range 0.0 to 1.0']
		]
		ifFalse: [
			"vertical => Column"
			edgeWeight := aSymbolOrNumber
				caseOf: {
					[ #columnTop ] -> [ 0.0 ].
					[ #center ] -> [ 0.5 ].
					[ #columnBottom ] -> [ 1.0 ]
				}
				otherwise: [ self error: 'bad axisEdgeWeight for Column: ', aSymbolOrNumber printString ].
		].
	super axisEdgeWeight: edgeWeight.! !
!RowLayout methodsFor: 'accessing' stamp: 'jmv 7/3/2025 14:54:50' overrides: 50339634!
               axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	| edgeWeight |
	(aSymbolOrNumber is: #Number)
		ifTrue: [ (aSymbolOrNumber between: 0.0 and: 1.0)
			ifTrue: [edgeWeight := aSymbolOrNumber ] 
			ifFalse: [self error: 'axisEdgeWeight ', aSymbolOrNumber printString, ' is out of range 0.0 to 1.0']
		]
		ifFalse: [
			"Row"
			edgeWeight := aSymbolOrNumber
				caseOf: {
					[ #rowLeft ] 	-> [ 0.0 ].
					[ #center ] 		-> [ 0.5 ].
					[ #rowRight ] 	-> [ 1.0 ]
				}
				otherwise: [ self error: 'bad axisEdgeWeight for Row: ', aSymbolOrNumber printString ].
		].
	super axisEdgeWeight: edgeWeight.! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/3/2025 14:53:45' prior: 50340639!
     axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	layout axisEdgeWeight: aSymbolOrNumber.
	self layoutSubmorphs! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7314-Layouts-refactor-JuanVuletich-2025Jul03-14h50m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:22:20 pm'!
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:21:04'!
                             adjustHorizontallyMorphAtLeft: l morphAtRight: r adjusterRefPos: adjusterRefPos at: localPoint
	| lCurrentWidth rCurrentWidth delta lNewWidth rNewWidth ls rs |

	lCurrentWidth := l extentInOwner x max: 1.	"avoid division by zero"
	rCurrentWidth := r extentInOwner x max: 1.	"avoid division by zero"
	delta := localPoint x - adjusterRefPos x.
	delta := delta max: l minimumShrinkWidth - lCurrentWidth.
	delta := delta min: rCurrentWidth - r minimumShrinkWidth.
	delta = 0 ifTrue: [ ^false ].
	rNewWidth := rCurrentWidth - delta.
	lNewWidth := lCurrentWidth + delta.
	ls := l layoutSpec.
	rs := r layoutSpec.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [ | leftNewProportion rightNewProportion toDistribute |	"If both proportional, update them"
			leftNewProportion := lNewWidth / (lNewWidth + rNewWidth).
			rightNewProportion := 1.0 - leftNewProportion.
			toDistribute := ls proportionalLayoutWidth + rs proportionalLayoutWidth.
			ls setProportionalWidth: leftNewProportion * toDistribute.
			rs setProportionalWidth: rightNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	^true! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:20:58'!
     adjustVerticallyMorphAbove: t morphBelow: b adjusterRefPos: adjusterRefPos at: localPoint
	| tCurrentHeight bCurrentHeight delta tNewHeight bNewHeight ts bs |

	tCurrentHeight := t extentInOwner y max: 1.	"avoid division by zero"
	bCurrentHeight := b extentInOwner y max: 1.	"avoid division by zero"
	delta := localPoint y - adjusterRefPos y.
	delta := delta max: t minimumShrinkHeight - tCurrentHeight.
	delta := delta min: bCurrentHeight - b minimumShrinkHeight.
	delta = 0 ifTrue: [ ^false ].
	tNewHeight := tCurrentHeight + delta.
	bNewHeight := bCurrentHeight - delta.
	ts := t layoutSpec.
	bs := b layoutSpec.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [ | bottomNewProportion toDistribute topNewProportion |	"If both proportional, update them"
			topNewProportion := tNewHeight / (tNewHeight + bNewHeight).
			bottomNewProportion := 1.0 - topNewProportion.
			toDistribute := ts proportionalLayoutHeight + bs proportionalLayoutHeight.
			ts setProportionalHeight: topNewProportion * toDistribute.
			bs setProportionalHeight: bottomNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	^true! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:20:03' prior: 16896431!
                              adjustHorizontallyBy: aLayoutAdjustMorph at: localPoint
	| i l r adjusterRefPos |

	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
		 self inform: 'LayoutAdjustingMorphs require morphs before and after'.
		^self  ].
	l := self submorphs at: i +1.
	r := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(self adjustHorizontallyMorphAtLeft: l morphAtRight: r adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:19:54' prior: 16896482!
                      adjustVerticallyBy: aLayoutAdjustMorph at: localPoint

	| i t b adjusterRefPos |
	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
			 self inform: 'LayoutAdjustingMorphs require morphs above and below'.
			^self ].
	t := self submorphs at: i +1.
	b := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(self adjustVerticallyMorphAbove: t morphBelow: b adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].! !

LayoutMorph removeSelector: #adjustHorizontallyBy2:at:!

LayoutMorph removeSelector: #adjustVerticallyBy2:at:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7315-Layouts-refactor-JuanVuletich-2025Jul03-14h56m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:29:45 pm'!
!ColumnLayout methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:23:49'!
                        adjustMorphBefore: t morphAfter: b adjusterRefPos: adjusterRefPos at: localPoint
	| tCurrentHeight bCurrentHeight delta tNewHeight bNewHeight ts bs |

	tCurrentHeight := t extentInOwner y max: 1.	"avoid division by zero"
	bCurrentHeight := b extentInOwner y max: 1.	"avoid division by zero"
	delta := localPoint y - adjusterRefPos y.
	delta := delta max: t minimumShrinkHeight - tCurrentHeight.
	delta := delta min: bCurrentHeight - b minimumShrinkHeight.
	delta = 0 ifTrue: [ ^false ].
	tNewHeight := tCurrentHeight + delta.
	bNewHeight := bCurrentHeight - delta.
	ts := t layoutSpec.
	bs := b layoutSpec.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [ | bottomNewProportion toDistribute topNewProportion |	"If both proportional, update them"
			topNewProportion := tNewHeight / (tNewHeight + bNewHeight).
			bottomNewProportion := 1.0 - topNewProportion.
			toDistribute := ts proportionalLayoutHeight + bs proportionalLayoutHeight.
			ts setProportionalHeight: topNewProportion * toDistribute.
			bs setProportionalHeight: bottomNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	^true! !
!RowLayout methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:25:01'!
                         adjustMorphBefore: l morphAfter: r adjusterRefPos: adjusterRefPos at: localPoint
	| lCurrentWidth rCurrentWidth delta lNewWidth rNewWidth ls rs |

	lCurrentWidth := l extentInOwner x max: 1.	"avoid division by zero"
	rCurrentWidth := r extentInOwner x max: 1.	"avoid division by zero"
	delta := localPoint x - adjusterRefPos x.
	delta := delta max: l minimumShrinkWidth - lCurrentWidth.
	delta := delta min: rCurrentWidth - r minimumShrinkWidth.
	delta = 0 ifTrue: [ ^false ].
	rNewWidth := rCurrentWidth - delta.
	lNewWidth := lCurrentWidth + delta.
	ls := l layoutSpec.
	rs := r layoutSpec.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [ | leftNewProportion rightNewProportion toDistribute |	"If both proportional, update them"
			leftNewProportion := lNewWidth / (lNewWidth + rNewWidth).
			rightNewProportion := 1.0 - leftNewProportion.
			toDistribute := ls proportionalLayoutWidth + rs proportionalLayoutWidth.
			ls setProportionalWidth: leftNewProportion * toDistribute.
			rs setProportionalWidth: rightNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	^true! !
!LayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/3/2025 15:28:46' prior: 50340698!
   adjustBy: aLayoutAdjustMorph at: aGlobalPoint
	"See Class Comment of LayoutAdjustingMorph"

	| localPoint  i before after adjusterRefPos |
	localPoint := self internalizeFromWorld: aGlobalPoint.
	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
		self inform: 'LayoutAdjustingMorphs require morphs before and after'.
		^self ].
	before := self submorphs at: i +1.
	after := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(layout adjustMorphBefore: before morphAfter: after adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].! !

LayoutMorph removeSelector: #adjustHorizontallyBy:at:!

!methodRemoval: LayoutMorph #adjustHorizontallyBy:at: stamp: 'Install-7316-Layouts-refactor-JuanVuletich-2025Jul03-15h22m-jmv.001.cs.st 7/15/2025 11:02:10'!
adjustHorizontallyBy: aLayoutAdjustMorph at: localPoint
	| i l r adjusterRefPos |

	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
		 self inform: 'LayoutAdjustingMorphs require morphs before and after'.
		^self  ].
	l := self submorphs at: i +1.
	r := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(self adjustHorizontallyMorphAtLeft: l morphAtRight: r adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].!

LayoutMorph removeSelector: #adjustHorizontallyMorphAtLeft:morphAtRight:adjusterRefPos:at:!

!methodRemoval: LayoutMorph #adjustHorizontallyMorphAtLeft:morphAtRight:adjusterRefPos:at: stamp: 'Install-7316-Layouts-refactor-JuanVuletich-2025Jul03-15h22m-jmv.001.cs.st 7/15/2025 11:02:10'!
adjustHorizontallyMorphAtLeft: l morphAtRight: r adjusterRefPos: adjusterRefPos at: localPoint
	| lCurrentWidth rCurrentWidth delta lNewWidth rNewWidth ls rs |

	lCurrentWidth := l extentInOwner x max: 1.	"avoid division by zero"
	rCurrentWidth := r extentInOwner x max: 1.	"avoid division by zero"
	delta := localPoint x - adjusterRefPos x.
	delta := delta max: l minimumShrinkWidth - lCurrentWidth.
	delta := delta min: rCurrentWidth - r minimumShrinkWidth.
	delta = 0 ifTrue: [ ^false ].
	rNewWidth := rCurrentWidth - delta.
	lNewWidth := lCurrentWidth + delta.
	ls := l layoutSpec.
	rs := r layoutSpec.
	(ls isProportionalWidth and: [ rs isProportionalWidth ])
		ifTrue: [ | leftNewProportion rightNewProportion toDistribute |	"If both proportional, update them"
			leftNewProportion := lNewWidth / (lNewWidth + rNewWidth).
			rightNewProportion := 1.0 - leftNewProportion.
			toDistribute := ls proportionalLayoutWidth + rs proportionalLayoutWidth.
			ls setProportionalWidth: leftNewProportion * toDistribute.
			rs setProportionalWidth: rightNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ls isProportionalWidth ifFalse: [
				ls fixedOrMorphWidth: lNewWidth ].
			rs isProportionalWidth ifFalse: [
				rs fixedOrMorphWidth: rNewWidth ]].
	^true!

LayoutMorph removeSelector: #adjustVerticallyBy:at:!

!methodRemoval: LayoutMorph #adjustVerticallyBy:at: stamp: 'Install-7316-Layouts-refactor-JuanVuletich-2025Jul03-15h22m-jmv.001.cs.st 7/15/2025 11:02:10'!
adjustVerticallyBy: aLayoutAdjustMorph at: localPoint

	| i t b adjusterRefPos |
	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
			 self inform: 'LayoutAdjustingMorphs require morphs above and below'.
			^self ].
	t := self submorphs at: i +1.
	b := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(self adjustVerticallyMorphAbove: t morphBelow: b adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].!

LayoutMorph removeSelector: #adjustVerticallyMorphAbove:morphBelow:adjusterRefPos:at:!

!methodRemoval: LayoutMorph #adjustVerticallyMorphAbove:morphBelow:adjusterRefPos:at: stamp: 'Install-7316-Layouts-refactor-JuanVuletich-2025Jul03-15h22m-jmv.001.cs.st 7/15/2025 11:02:10'!
adjustVerticallyMorphAbove: t morphBelow: b adjusterRefPos: adjusterRefPos at: localPoint
	| tCurrentHeight bCurrentHeight delta tNewHeight bNewHeight ts bs |

	tCurrentHeight := t extentInOwner y max: 1.	"avoid division by zero"
	bCurrentHeight := b extentInOwner y max: 1.	"avoid division by zero"
	delta := localPoint y - adjusterRefPos y.
	delta := delta max: t minimumShrinkHeight - tCurrentHeight.
	delta := delta min: bCurrentHeight - b minimumShrinkHeight.
	delta = 0 ifTrue: [ ^false ].
	tNewHeight := tCurrentHeight + delta.
	bNewHeight := bCurrentHeight - delta.
	ts := t layoutSpec.
	bs := b layoutSpec.
	(ts isProportionalHeight and: [ bs isProportionalHeight ])
		ifTrue: [ | bottomNewProportion toDistribute topNewProportion |	"If both proportional, update them"
			topNewProportion := tNewHeight / (tNewHeight + bNewHeight).
			bottomNewProportion := 1.0 - topNewProportion.
			toDistribute := ts proportionalLayoutHeight + bs proportionalLayoutHeight.
			ts setProportionalHeight: topNewProportion * toDistribute.
			bs setProportionalHeight: bottomNewProportion * toDistribute ]
		ifFalse: ["If at least one is fixed, update only the fixed"
			ts isProportionalHeight ifFalse: [
				ts fixedOrMorphHeight: tNewHeight ].
			bs isProportionalHeight ifFalse: [
				bs fixedOrMorphHeight: bNewHeight ]].
	^true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7316-Layouts-refactor-JuanVuletich-2025Jul03-15h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:37:48 pm'!
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/3/2025 15:37:29' prior: 50340712!
                    minimumExtent: cachedValues
	"Answer size sufficient to frame my submorphs."
	
	| width height mle |
	width  := 0.
	height := 0.
	layout isColumn
		ifTrue: [ "Column"
			submorphs do: [ :sm |
				sm visible ifTrue: [
					mle := sm minimumLayoutExtent: cachedValues.
					"use maximum width across submorphs"
					width := width max: mle x.
					"sum up submorph heights, including separation between them"
					height := height + mle y + layout gap.
				]
			].
			height := height - layout gap. "An extra gap was just added"
		]
		ifFalse: [ "Row"
			submorphs do: [ :sm |
				sm visible ifTrue: [
					mle := sm minimumLayoutExtent: cachedValues.
					"sum up submorphs width, include gap"
					width := width + mle x + layout gap.
					"use maximum height across submorph"
					height := height max: mle y.
				]
			].
			width := width - layout gap. "An extra gap was just added"
		].
	^ (width @ height) + (2 * self interiorOrigin)! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:36:28' prior: 50340208!
 layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self ].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.

	layout layoutMorphs: submorphs in: self layoutBounds.
	self layoutNeeded: false.! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:36:07' prior: 50340000!
                         layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount heights heightToAllocate leftOver y cache |

	visibleSubmorphs := (morphs select: [ :m | m visible ]) reversed. "Display Order"
	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleSubmorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * axisEdgeWeight).

	visibleSubmorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + gap.
	].! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:36:04' prior: 50340049!
  layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleSubmorphs gapCount widths widthToAllocate leftOver x cache |

	visibleSubmorphs := (morphs select: [ :m | m visible ]) reversed. "Display Order"
	gapCount := visibleSubmorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleSubmorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * axisEdgeWeight).

	visibleSubmorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + gap.
	].! !

LayoutMorph removeSelector: #submorphsToLayout!

!methodRemoval: LayoutMorph #submorphsToLayout stamp: 'Install-7317-Layouts-refactor-JuanVuletich-2025Jul03-15h29m-jmv.001.cs.st 7/15/2025 11:02:10'!
submorphsToLayout
	"Select those that will be layout"

	^submorphs select: [ :m | m visible ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7317-Layouts-refactor-JuanVuletich-2025Jul03-15h29m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:46:51 pm'!
!ColumnLayout methodsFor: 'services' stamp: 'jmv 7/3/2025 15:45:26'!
      minimumExtentFor: morphs cachedValues: cachedValues
	| width height mle |
	width  := 0.
	height := 0.
	morphs do: [ :sm |
		sm visible ifTrue: [
			mle := sm minimumLayoutExtent: cachedValues.
			"use maximum width across submorphs"
			width := width max: mle x.
			"sum up submorph heights, including separation between them"
			height := height + mle y + gap.
		]
	].
	height := height - gap. "An extra gap was just added"
	^width@height! !
!RowLayout methodsFor: 'services' stamp: 'jmv 7/3/2025 15:45:25'!
   minimumExtentFor: morphs cachedValues: cachedValues
	| width height mle |
	width  := 0.
	height := 0.
	morphs do: [ :sm |
		sm visible ifTrue: [
			mle := sm minimumLayoutExtent: cachedValues.
			"sum up submorphs width, include gap"
			width := width + mle x + gap.
			"use maximum height across submorph"
			height := height max: mle y.
		]
	].
	width := width - gap. "An extra gap was just added"
	^width@height! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/3/2025 15:46:32' prior: 16896653 overrides: 16796315!
                      minimumExtent
	"Answer size sufficient to frame my submorphs."
	
	^ (layout minimumExtentFor: submorphs cachedValues: IdentityDictionary new) + (2 * self interiorOrigin)! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:41:48' prior: 50339874!
heightsFor: visibleMorphs within: overallHeight minLayoutExtentCache: cache
	"Answer array of morphHeights for visibleSubs."
	"Preconditions: 
		ySepararations already subtracted from overallHeight.
		overallHeight is large enough to contain minimumLayoutHeights of visibleSubs."

	| n scaleFactor heightToAllocate
	  sumOfPropMin sumOfPropDesired sumOfPropOriginallyDesired sumOfFixedMin
	  allocatedHeights propIndices desiredProps
	  maxOfMinAllocHeight |
	n := visibleMorphs size.
	sumOfFixedMin := 0.  "pixels"
	sumOfPropMin := 0.  "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	sumOfPropOriginallyDesired := 0. "Different from sumOfPropDesired if some #maximumLayoutHeight"
	allocatedHeights := Array new: n.
	desiredProps := Array new: n.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: n do: [ :index | | sm layoutHeightMin |
		sm := visibleMorphs at: index.
		layoutHeightMin := (sm minimumLayoutExtent: cache) y.
		allocatedHeights at: index put: layoutHeightMin.
		(sm isProportionalHeight)
			ifTrue:  [ | propDesired maxHeight |
				propDesired := sm layoutSpec privateProportionalHeight.
				sumOfPropOriginallyDesired := sumOfPropOriginallyDesired + propDesired.
				maxHeight := sm maximumLayoutHeight.
				(maxHeight notNil and: [ maxHeight < (propDesired * overallHeight)])
					ifTrue: [
						allocatedHeights at: index put: maxHeight.
						sumOfFixedMin := sumOfFixedMin + maxHeight ]
					ifFalse: [
						propIndices add: index.
						desiredProps at: index put: propDesired.
						sumOfPropDesired := sumOfPropDesired + propDesired.
						sumOfPropMin := sumOfPropMin + layoutHeightMin ]]
			ifFalse: [ "Allocate height for non-proportional-height morphs"
				sumOfFixedMin := sumOfFixedMin + layoutHeightMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallHeight - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedHeights ]. 
			
	"All fixed heights allocated; rest is for proportional + leftOver"
	heightToAllocate := (overallHeight - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional heights is more than 1.0,
	scale to make it all fit."
	sumOfPropOriginallyDesired > 0.999 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].

	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedHeights at: morphIndex 
			put:  ((allocatedHeights at: morphIndex) max:
				(heightToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding height is above max of minHeights
	 Keep the proportions over the minHeights at this allocation."
	maxOfMinAllocHeight := propIndices max: [ :morphIndex | 
		(visibleMorphs at: morphIndex) allocHeightForFactor: scaleFactor minLayoutExtentCache: cache ].

	"Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(heightToAllocate <= maxOfMinAllocHeight) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ heightToAllocate := heightToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleMorphs size.
		propIndices do: [ :morphIndex | | heightAtBalance | 
			heightAtBalance := maxOfMinAllocHeight * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: heightAtBalance "delta above min height"
			 	  	- (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) y)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex | 
				allocatedHeights at: morphIndex
					put: (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) y)
						+ (((heightToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedHeights! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:40:22' prior: 50341429!
                             layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleMorphs gapCount heights heightToAllocate leftOver y cache |

	visibleMorphs := (morphs select: [ :m | m visible ]) reversed. "Display Order"
	gapCount := visibleMorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleMorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * axisEdgeWeight).

	visibleMorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + gap.
	].! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:40:56' prior: 50341462!
                 layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleMorphs gapCount widths widthToAllocate leftOver x cache |

	visibleMorphs := (morphs select: [ :m | m visible ]) reversed. "Display Order"
	gapCount := visibleMorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleMorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * axisEdgeWeight).

	visibleMorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + gap.
	].! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 7/3/2025 15:41:34' prior: 50340098!
                     widthsFor: visibleMorphs within: overallWidth minLayoutExtentCache: cache
	"Answer array of morphWidths for visibleSubs."
	"Preconditions: 
		xSepararations already subtracted from overallWidth.
		overallWidth is large enough to contain minimumLayoutWidths of visibleSubs."
	
	| n scaleFactor widthToAllocate
	  sumOfPropMin sumOfPropDesired sumOfFixedMin
	  allocatedWidths propIndices desiredProps
	  maxOfMinAllocWidth |
	n := visibleMorphs size.
	sumOfFixedMin := 0. "pixels"
	sumOfPropMin := 0. "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	allocatedWidths := Array new: n.
	desiredProps := Array new: n.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: n do: [ :index | | sm layoutWidthMin |
		sm := visibleMorphs at: index.
		layoutWidthMin := (sm minimumLayoutExtent: cache) x.
		allocatedWidths at: index put: layoutWidthMin.
		(sm isProportionalWidth)
			ifTrue:  [ | propDesired |
				propIndices add: index.
				propDesired := sm layoutSpec privateProportionalWidth.
				desiredProps at: index put: propDesired.
				sumOfPropDesired := sumOfPropDesired + propDesired.
				sumOfPropMin := sumOfPropMin + layoutWidthMin ]
			ifFalse: [ "Allocate width for non-proportional-width morphs"
				sumOfFixedMin := sumOfFixedMin + layoutWidthMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallWidth - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedWidths ]. 
			
	"All fixed widths allocated; rest is for proportional + leftOver"
	widthToAllocate := (overallWidth - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional widths is more than 1.0,
	scale to make it all fit."
	sumOfPropDesired > 1.0 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].
	
	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedWidths at: morphIndex 
			put:  ((allocatedWidths at: morphIndex) max:
				(widthToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding width is above max of minWidths
	 Keep the proportions over the minWidths at this allocation."
	maxOfMinAllocWidth := propIndices max: [ :morphIndex | 
		(visibleMorphs at: morphIndex) allocWidthForFactor: scaleFactor minLayoutExtentCache: cache ].

     "Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(widthToAllocate <= maxOfMinAllocWidth) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ widthToAllocate := widthToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleMorphs size.
		propIndices do: [ :morphIndex | | widthAtBalance | 
			widthAtBalance := maxOfMinAllocWidth * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: widthAtBalance "delta above min width"
					- (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) x)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex |
				allocatedWidths at: morphIndex
					put: (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) x) 
						+ (((widthToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedWidths! !

LayoutMorph removeSelector: #minimumExtent:!

!methodRemoval: LayoutMorph #minimumExtent: stamp: 'Install-7318-Layouts-refactor-JuanVuletich-2025Jul03-15h37m-jmv.001.cs.st 7/15/2025 11:02:10'!
minimumExtent: cachedValues
	"Answer size sufficient to frame my submorphs."
	
	| width height mle |
	width  := 0.
	height := 0.
	layout isColumn
		ifTrue: [ "Column"
			submorphs do: [ :sm |
				sm visible ifTrue: [
					mle := sm minimumLayoutExtent: cachedValues.
					"use maximum width across submorphs"
					width := width max: mle x.
					"sum up submorph heights, including separation between them"
					height := height + mle y + layout gap.
				]
			].
			height := height - layout gap. "An extra gap was just added"
		]
		ifFalse: [ "Row"
			submorphs do: [ :sm |
				sm visible ifTrue: [
					mle := sm minimumLayoutExtent: cachedValues.
					"sum up submorphs width, include gap"
					width := width + mle x + layout gap.
					"use maximum height across submorph"
					height := height max: mle y.
				]
			].
			width := width - layout gap. "An extra gap was just added"
		].
	^ (width @ height) + (2 * self interiorOrigin)!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7318-Layouts-refactor-JuanVuletich-2025Jul03-15h37m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:49:03 pm'!

LayoutMorph removeSelector: #isRow!

!methodRemoval: LayoutMorph #isRow stamp: 'Install-7319-Layouts-Cleanup-JuanVuletich-2025Jul03-15h46m-jmv.001.cs.st 7/15/2025 11:02:10'!
isRow

	^ layout isRow!

LayoutMorph removeSelector: #isColumn!

!methodRemoval: LayoutMorph #isColumn stamp: 'Install-7319-Layouts-Cleanup-JuanVuletich-2025Jul03-15h46m-jmv.001.cs.st 7/15/2025 11:02:10'!
isColumn

	^ layout isColumn!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7319-Layouts-Cleanup-JuanVuletich-2025Jul03-15h46m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7313] on 3 July 2025 at 3:57:45 pm'!
!Layout methodsFor: 'testing' stamp: 'jmv 7/3/2025 15:51:04'!
             isLinearLayout
	^false! !
!LinearLayout methodsFor: 'testing' stamp: 'jmv 7/3/2025 15:50:56' overrides: 50341915!
              isLinearLayout
	^true! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/3/2025 15:51:39' prior: 50340952!
                  axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }
	
	Ignored for other kinds of Layouts"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	layout isLinearLayout ifTrue: [
		layout axisEdgeWeight: aSymbolOrNumber.
		self layoutSubmorphs ].! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/3/2025 15:52:16' prior: 50339706!
  gap: aNumber
	"Only for Linear Layouts"
	layout isLinearLayout ifTrue: [
		layout gap = aNumber ifFalse: [
			self adjustExtentFor: [
				layout gap: aNumber ]].
		self layoutSubmorphs ].! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/3/2025 15:56:52' prior: 16896403 overrides: 16796238!
                        padding: numberOrPoint
	"Honored by all kinds of Layouts"

	super padding: numberOrPoint.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/3/2025 15:52:50' prior: 50340689!
                       separation: aNumberOrPoint
	"Only for Linear Layouts"

	| g |
	layout isLinearLayout ifTrue: [
		self padding: aNumberOrPoint.
		g := aNumberOrPoint.
		g isPoint ifTrue: [
			g := layout isRow ifTrue: [ g x ] ifFalse: [ g y ]].
		self gap: g ].! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/3/2025 15:54:54' prior: 16896721!
              defaultGap
	"Answer the default gap between submorphs for the receiver.
	Redefine this method for a different initial gap in your morphs.
	Only for Linear Layouts"

	^ 0! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7320-Layout-PrepareForAdditionalLayoutStyles-JuanVuletich-2025Jul03-15h49m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7320] on 4 July 2025 at 12:22:30 pm'!
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/4/2025 12:22:15' prior: 50339763!
                             initializeColumn

	layout := ColumnLayout new.
	layout gap: self defaultGap.
	doAdoptWidgetsColor := false.
	self initialize.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/4/2025 12:22:13' prior: 50339769!
     initializeRow

	layout := RowLayout new.
	layout gap: self defaultGap.
	doAdoptWidgetsColor := false.
	self initialize.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7321-LayoutMorph-fix-JuanVuletich-2025Jul04-12h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7320] on 4 July 2025 at 12:32:10 pm'!
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:27:44'!
               fixedExtent: aPoint
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedExtent: aPoint! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:27:57'!
                            fixedHeight: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedHeight: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:04'!
                          fixedWidth: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedWidth: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:12'!
                            fixedWidth: aNumber fixedHeight: otherNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedWidth: aNumber fixedHeight: otherNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:23'!
          fixedWidth: aNumber fixedHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedWidth: aNumber fixedHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:32'!
    fixedWidth: aNumber proportionalHeight: otherNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedWidth: aNumber proportionalHeight: otherNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:40'!
                            fixedWidth: aNumber proportionalHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec fixedWidth: aNumber proportionalHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:28:54'!
                      keepMorphExtent
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec keepMorphExtent! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:29:03'!
    morphHeightFixedWidth: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec morphHeightFixedWidth: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:29:24'!
      morphHeightProportionalWidth: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec morphHeightProportionalWidth: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:29:42'!
                        morphWidthFixedHeight: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec morphWidthFixedHeight: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:29:51'!
      morphWidthProportionalHeight: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec morphWidthProportionalHeight: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:05'!
                        proportionalHeight: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalHeight: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:16'!
            proportionalWidth: aNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalWidth: aNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:25'!
              proportionalWidth: aNumber fixedHeight: otherNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalWidth: aNumber fixedHeight: otherNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:33'!
                            proportionalWidth: aNumber fixedHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalWidth: aNumber fixedHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:40'!
                      proportionalWidth: aNumber proportionalHeight: otherNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalWidth: aNumber proportionalHeight: otherNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:48'!
              proportionalWidth: aNumber proportionalHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec proportionalWidth: aNumber proportionalHeight: otherNumber offAxisEdgeWeight: aSymbolOrNumber! !
!LayoutSpec class methodsFor: 'for LinearLayouts' stamp: 'jmv 7/4/2025 12:30:56'!
        useAll
	"Instance creation.
	To be used with LinearLayouts."
	^LayoutSizeSpec useAll! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7322-LayoutSpec-backCompatibility-JuanVuletich-2025Jul04-12h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7322] on 4 July 2025 at 3:22:02 pm'!
!Layout methodsFor: 'services' stamp: 'jmv 7/4/2025 14:56:57'!
                         minimumExtentFor: morphs cachedValues: cachedValues
	self subclassResponsibility ! !
!LayoutSpec methodsFor: 'private' stamp: 'jmv 7/4/2025 14:23:06'!
         updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LayoutMorph) ifTrue:
			[ owningLayout layoutSubmorphs ]].! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/4/2025 14:31:20' prior: 16930150!
                              allocHeightForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSpecs may specify propottional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minHeight
	so breakeven is when
	  amountToAlloc = minHeight / proportion * factor"
	| minHeight |
	minHeight := (self minimumLayoutExtent: cachedValues) y.
	^(self isProportionalHeight)
		ifFalse:  [ minHeight ]
		ifTrue: [ minHeight / (aFactor * self layoutSpec proportionalLayoutHeight) ]! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/4/2025 14:24:45' prior: 16930168!
          allocWidthForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSpecs may specify propottional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minWidth
	so breakeven is when
	  amountToAlloc = minWidth / proportion * factor"
	| minWidth |
	minWidth := (self minimumLayoutExtent: cachedValues) x.
	^(self isProportionalWidth)
		ifFalse:  [ minWidth ]
		ifTrue: [ minWidth / (aFactor * self layoutSpec proportionalLayoutWidth) ]! !
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 7/4/2025 14:25:25' prior: 50341552!
                    heightsFor: visibleMorphs within: overallHeight minLayoutExtentCache: cache
	"Answer array of morphHeights for visibleSubs."
	"Preconditions: 
		ySepararations already subtracted from overallHeight.
		overallHeight is large enough to contain minimumLayoutHeights of visibleSubs."

	| n scaleFactor heightToAllocate
	  sumOfPropMin sumOfPropDesired sumOfPropOriginallyDesired sumOfFixedMin
	  allocatedHeights propIndices desiredProps
	  maxOfMinAllocHeight |
	n := visibleMorphs size.
	sumOfFixedMin := 0.  "pixels"
	sumOfPropMin := 0.  "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	sumOfPropOriginallyDesired := 0. "Different from sumOfPropDesired if some #maximumLayoutHeight"
	allocatedHeights := Array new: n.
	desiredProps := Array new: n.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: n do: [ :index | | sm layoutHeightMin |
		sm := visibleMorphs at: index.
		layoutHeightMin := (sm minimumLayoutExtent: cache) y.
		allocatedHeights at: index put: layoutHeightMin.
		(sm isProportionalHeight)
			ifTrue:  [ | propDesired maxHeight |
				propDesired := sm layoutSpec proportionalLayoutHeight.
				sumOfPropOriginallyDesired := sumOfPropOriginallyDesired + propDesired.
				maxHeight := sm maximumLayoutHeight.
				(maxHeight notNil and: [ maxHeight < (propDesired * overallHeight)])
					ifTrue: [
						allocatedHeights at: index put: maxHeight.
						sumOfFixedMin := sumOfFixedMin + maxHeight ]
					ifFalse: [
						propIndices add: index.
						desiredProps at: index put: propDesired.
						sumOfPropDesired := sumOfPropDesired + propDesired.
						sumOfPropMin := sumOfPropMin + layoutHeightMin ]]
			ifFalse: [ "Allocate height for non-proportional-height morphs"
				sumOfFixedMin := sumOfFixedMin + layoutHeightMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallHeight - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedHeights ]. 
			
	"All fixed heights allocated; rest is for proportional + leftOver"
	heightToAllocate := (overallHeight - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional heights is more than 1.0,
	scale to make it all fit."
	sumOfPropOriginallyDesired > 0.999 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].

	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedHeights at: morphIndex 
			put:  ((allocatedHeights at: morphIndex) max:
				(heightToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding height is above max of minHeights
	 Keep the proportions over the minHeights at this allocation."
	maxOfMinAllocHeight := propIndices max: [ :morphIndex | 
		(visibleMorphs at: morphIndex) allocHeightForFactor: scaleFactor minLayoutExtentCache: cache ].

	"Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(heightToAllocate <= maxOfMinAllocHeight) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ heightToAllocate := heightToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleMorphs size.
		propIndices do: [ :morphIndex | | heightAtBalance | 
			heightAtBalance := maxOfMinAllocHeight * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: heightAtBalance "delta above min height"
			 	  	- (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) y)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex | 
				allocatedHeights at: morphIndex
					put: (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) y)
						+ (((heightToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedHeights! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 7/4/2025 14:32:17' prior: 50341744!
 widthsFor: visibleMorphs within: overallWidth minLayoutExtentCache: cache
	"Answer array of morphWidths for visibleSubs."
	"Preconditions: 
		xSepararations already subtracted from overallWidth.
		overallWidth is large enough to contain minimumLayoutWidths of visibleSubs."
	
	| n scaleFactor widthToAllocate
	  sumOfPropMin sumOfPropDesired sumOfFixedMin
	  allocatedWidths propIndices desiredProps
	  maxOfMinAllocWidth |
	n := visibleMorphs size.
	sumOfFixedMin := 0. "pixels"
	sumOfPropMin := 0. "pixels"
	sumOfPropDesired := 0. "sum of percentage fractions; may be more than 100%"
	allocatedWidths := Array new: n.
	desiredProps := Array new: n.
	propIndices := Set new. "keep set of proportional morph indices"
	1 to: n do: [ :index | | sm layoutWidthMin |
		sm := visibleMorphs at: index.
		layoutWidthMin := (sm minimumLayoutExtent: cache) x.
		allocatedWidths at: index put: layoutWidthMin.
		(sm isProportionalWidth)
			ifTrue:  [ | propDesired |
				propIndices add: index.
				propDesired := sm layoutSpec proportionalLayoutWidth.
				desiredProps at: index put: propDesired.
				sumOfPropDesired := sumOfPropDesired + propDesired.
				sumOfPropMin := sumOfPropMin + layoutWidthMin ]
			ifFalse: [ "Allocate width for non-proportional-width morphs"
				sumOfFixedMin := sumOfFixedMin + layoutWidthMin ]].

	((propIndices size = 0) "already finished"
	  or: [(overallWidth - (sumOfFixedMin + sumOfPropMin)) < 2]) "close enough"
		ifTrue: [ ^ allocatedWidths ]. 
			
	"All fixed widths allocated; rest is for proportional + leftOver"
	widthToAllocate := (overallWidth - sumOfFixedMin) max: 0.
	scaleFactor := 1.0.
	"If sum of requested proportional widths is more than 1.0,
	scale to make it all fit."
	sumOfPropDesired > 1.0 ifTrue: [
		scaleFactor := 1.0 / sumOfPropDesired ].
	
	"Do simple default scaling"
	propIndices do: [ :morphIndex |
		allocatedWidths at: morphIndex 
			put:  ((allocatedWidths at: morphIndex) max:
				(widthToAllocate 
					* scaleFactor 
						* (desiredProps at: morphIndex))) ].

	"Find the min alloc size at which adding width is above max of minWidths
	 Keep the proportions over the minWidths at this allocation."
	maxOfMinAllocWidth := propIndices max: [ :morphIndex | 
		(visibleMorphs at: morphIndex) allocWidthForFactor: scaleFactor minLayoutExtentCache: cache ].

     "Below the balance point, calculate proportions from belowBalanceDeltas,
	above, use desiredProps"
	(widthToAllocate <= maxOfMinAllocWidth) ifTrue: [ | belowBalanceDeltas sumOfDeltas | 
		(sumOfPropDesired < 1.0) "Trim off space to save"
			ifTrue: [ widthToAllocate := widthToAllocate * sumOfPropDesired ].
		belowBalanceDeltas := Array new: visibleMorphs size.
		propIndices do: [ :morphIndex | | widthAtBalance | 
			widthAtBalance := maxOfMinAllocWidth * scaleFactor * (desiredProps at: morphIndex).
			belowBalanceDeltas at: morphIndex
				put: widthAtBalance "delta above min width"
					- (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) x)].
		sumOfDeltas := belowBalanceDeltas sum: [ :b | b ifNil: [0]].
		(sumOfDeltas > propIndices size) ifTrue: [ "space desired < 100%"
			propIndices do: [ :morphIndex |
				allocatedWidths at: morphIndex
					put: (((visibleMorphs at: morphIndex) minimumLayoutExtent: cache) x) 
						+ (((widthToAllocate - sumOfPropMin ) max: 0.0)
							* (belowBalanceDeltas at: morphIndex) / sumOfDeltas)]]].
	
	^ allocatedWidths! !

LayoutSizeSpec removeSelector: #updateContainingLayout!

!methodRemoval: LayoutSizeSpec #updateContainingLayout stamp: 'Install-7323-Layout-Cleanup-JuanVuletich-2025Jul04-15h19m-jmv.001.cs.st 7/15/2025 11:02:10'!
updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LayoutMorph) ifTrue:
			[ owningLayout layoutSubmorphs ]].!

LayoutSizeSpec removeSelector: #proportionaLayoutlHeight!

!methodRemoval: LayoutSizeSpec #proportionaLayoutlHeight stamp: 'Install-7323-Layout-Cleanup-JuanVuletich-2025Jul04-15h19m-jmv.001.cs.st 7/15/2025 11:02:10'!
proportionaLayoutlHeight

	^ proportionalHeight ifNil: [ 0 ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7323-Layout-Cleanup-JuanVuletich-2025Jul04-15h19m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7322] on 4 July 2025 at 3:25:41 pm'!

LayoutSpec subclass: #LayoutEdgesSpec
	instanceVariableNames: 'topLeftEdgesWeight topLeftOffset bottomRightEdgesWeight bottomRightOffset'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutEdgesSpec category: #'Morphic-Layouts' stamp: 'Install-7324-FormLayout-JuanVuletich-2025Jul04-15h22m-jmv.001.cs.st 7/15/2025 11:02:10'!
LayoutSpec subclass: #LayoutEdgesSpec
	instanceVariableNames: 'topLeftEdgesWeight topLeftOffset bottomRightEdgesWeight bottomRightOffset'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!
!LayoutEdgesSpec commentStamp: '<historical>' prior: 0!
                       To be used with FormLayout.
Inspired by 
https://archive.eclipse.org/eclipse/downloads/documentation/2.0/html/plugins/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormData.html and
https://archive.eclipse.org/eclipse/downloads/documentation/2.0/html/plugins/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/layout/FormAttachment.html!
!Rectangle methodsFor: 'mathematical functions' stamp: 'jmv 6/24/2025 18:03:19'!
 interpolateAt: amountDone
	"Interpolate between the instance and end after the specified amount has been done (0 - 1)."

	^ self extent * amountDone + origin! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/4/2025 14:49:27'!
                     initializeForm

	layout := FormLayout new.
	doAdoptWidgetsColor := false.
	self initialize.! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/4/2025 14:50:02'!
              newForm
	^self basicNew initializeForm! !
!LayoutMorph class methodsFor: 'FormLayout examples' stamp: 'jmv 7/4/2025 15:08:42'!
 example1Form
"
	self example1Form
"
	| pane |
	pane := (LayoutMorph newForm separation: 5) name: #example1.
	pane 
		color: Color red;
		addMorph: (ColoredBoxMorph new color: (Color lightBlue); name: #A)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@20 brEdgesWeight: 0@0 offset: 100@40);
		addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 30@20 brEdgesWeight: 1@0 offset: -30@40);
		addMorph: (ColoredBoxMorph new color: (Color lightGreen); name: #C)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@60 brEdgesWeight: 0.5@0 offset: -10@140);
		addMorph: (ColoredBoxMorph new color: (Color green); name: #D)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 10@60 brEdgesWeight: 1@0 offset: -30@140);
		addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@160 brEdgesWeight: 1@1 offset: -30@ -30).
	pane position: 150@130 extent: 400@300.
	pane openInWorld! !
!FormLayout methodsFor: 'layout' stamp: 'jmv 7/4/2025 14:45:00'!
                           layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	morphs do: [ :eachMorph | | ls r |
		eachMorph visible ifTrue: [
			ls := eachMorph layoutSpec.
			r := (boundsForLayout interpolateAt: ls topLeftEdgesWeight) + ls topLeftOffset
				corner: 
					(boundsForLayout interpolateAt: ls bottomRightEdgesWeight) + ls bottomRightOffset.
			eachMorph fitInto: r ]]! !
!FormLayout methodsFor: 'services' stamp: 'jmv 7/4/2025 14:58:13' overrides: 50342176!
               minimumExtentFor: morphs cachedValues: cachedValues
	"Ojo!!"
	^100@100! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:35:06'!
             bottomRightEdgesWeight
	^bottomRightEdgesWeight! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:34:24'!
    bottomRightEdgesWeight: aPoint
	"Argument x and y must be in [0.0 .. 1.0]"
	bottomRightEdgesWeight := aPoint! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:35:16'!
       bottomRightOffset
	^bottomRightOffset! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:34:41'!
              bottomRightOffset: aPoint
	bottomRightOffset := aPoint! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:34:54'!
                             topLeftEdgesWeight
	^topLeftEdgesWeight! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:34:11'!
            topLeftEdgesWeight: aPoint
	"Argument x and y must be in [0.0 .. 1.0]"
	topLeftEdgesWeight := aPoint! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:35:00'!
               topLeftOffset
	^topLeftOffset! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 7/4/2025 14:34:34'!
                      topLeftOffset: aPoint
	topLeftOffset := aPoint! !
!LayoutEdgesSpec methodsFor: 'layout' stamp: 'jmv 7/4/2025 14:36:17'!
        minimumSpecExtent
	"We specify position, but not extent."

	^0@0! !
!LayoutEdgesSpec class methodsFor: 'instance creation' stamp: 'jmv 7/4/2025 14:53:37'!
     tlEdgesWeight: tlWeight offset: tlOffset brEdgesWeight: brWeight offset: brOffset

	^LayoutEdgesSpec new
		topLeftEdgesWeight: tlWeight;
		topLeftOffset: tlOffset;
		bottomRightEdgesWeight: brWeight;
		bottomRightOffset: brOffset! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7324-FormLayout-JuanVuletich-2025Jul04-15h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7324] on 4 July 2025 at 4:19:21 pm'!
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/4/2025 16:13:26'!
                    gap
	"Only for Linear Layouts"
	^layout isLinearLayout ifTrue: [
		layout gap ]! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 7/4/2025 16:14:16'!
          isColumn
	"Only makes sense for Linear Layouts"
	^layout isColumn! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 7/4/2025 16:14:11'!
                        isRow
	"Only makes sense for Linear Layouts"
	^layout isRow! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7325-Layout-Add3convenienceMethods-JuanVuletich-2025Jul04-16h13m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7324] on 4 July 2025 at 4:20:28 pm'!
!ColumnLayout methodsFor: 'initialization' stamp: 'jmv 7/4/2025 16:20:02' prior: 50339646 overrides: 16940323!
 initialize
	gap := 0.
	axisEdgeWeight := 0.0. "#columnTop"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7326-ColumnLayout-defaultAxisEdgeWeight-fix-JuanVuletich-2025Jul04-16h19m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7326] on 7 July 2025 at 8:52:48 am'!

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7327-Layout-RemoveUnusedIVars-JuanVuletich-2025Jul07-08h51m-jmv.001.cs.st 7/15/2025 11:02:10'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'direction gap axisEdgeWeight doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7327-Layout-RemoveUnusedIVars-JuanVuletich-2025Jul07-08h51m-jmv.001.cs.st 7/15/2025 11:02:10'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7327-Layout-RemoveUnusedIVars-JuanVuletich-2025Jul07-08h51m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7328] on 7 July 2025 at 10:19:06 am'!
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/7/2025 10:18:47'!
                             axisEdgeWeight
	"Only for Linear Layouts"
	^layout isLinearLayout ifTrue: [
		layout axisEdgeWeight ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7328-LayoutMorph-axisEdgeWeigh-JuanVuletich-2025Jul07-10h04m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7326] on 7 July 2025 at 9:37:40 am'!

Transcript class
	instanceVariableNames: 'entries firstIndex lastIndex accessSemaphore unfinishedEntry logToFile showOnDisplay lastDisplayPosition bounds logToStdout displayEngine backgroundColor dirtyRectOnDisplay lastDisplayFlush '!

!classDefinition: 'Transcript class' category: #'System-Support' stamp: 'Install-7329-TranscriptSpeedupForMacIntel-JuanVuletich-2025Jul07-08h52m-jmv.003.cs.st 7/15/2025 11:02:11'!
Transcript class
	instanceVariableNames: 'entries firstIndex lastIndex accessSemaphore unfinishedEntry logToFile showOnDisplay lastDisplayPosition bounds logToStdout displayEngine backgroundColor dirtyRectOnDisplay lastDisplayFlush'!
!Transcript class methodsFor: 'private' stamp: 'jmv 7/7/2025 09:37:30'!
                       dirtyScreenRect: someDamage
	"aRectangle needs updating on real OS Screen. This can be simply done by
	DisplayScreen forceDeferredToScreen: damage.
	The reason to do something more complicated is because #forceDeferredToScreen: may be expensive, especially on Mac Intel VMs as of July 2025, and especially if done at high frequency (i.e. with a time interval between calls below 25 milliseconds.
	"
	| now |
	now := Time localMillisecondClock.
	lastDisplayFlush ifNil: [ lastDisplayFlush := now ].

	"If enough time has elapsed since last push, just do it."
	now - lastDisplayFlush > 25 ifTrue: [
		dirtyRectOnDisplay := someDamage quickMerge: dirtyRectOnDisplay.
		DisplayScreen forceDeferredToScreen: dirtyRectOnDisplay.
		dirtyRectOnDisplay := nil.
		lastDisplayFlush := now.
		^self
		].

	dirtyRectOnDisplay
		ifNil: [
			"We don't have a previous dirty rect. If there has been some, it has already been pushed to Screen.
			Start a forked process to push it. Do it in a while. In the meantime, other calls to this process may
			add additional damage. It is also possible that some other call to this method ends up clearing the
			dirtyRectOnDisplay. Consider that too."
			dirtyRectOnDisplay := someDamage.
			[
				(Delay forMilliseconds: 50) wait.
				dirtyRectOnDisplay ifNotNil: [
					DisplayScreen forceDeferredToScreen: dirtyRectOnDisplay.
					dirtyRectOnDisplay := nil.
					lastDisplayFlush := Time localMillisecondClock ].
			] forkAt: Processor userInterruptPriority ]
		ifNotNil: [
			"We already have a forked process that will soon do the push. Wait for it. Merge damage."
			dirtyRectOnDisplay := someDamage quickMerge: dirtyRectOnDisplay.
			].! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 7/7/2025 09:35:27' prior: 50337422!
                            display
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayOnDisplay.
		self dirtyScreenRect: bounds ].
	"So any morph in front of us is repaired when Morphic cycles.
	This includes, for instance, the TranscriptWindow that shows our contents if showOnDisplay is false"
	UISupervisor whenUIinSafeState: [ self triggerEvent: #redrawTranscriptArea ].! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 7/7/2025 09:35:46' prior: 50337438!
                     displayUnfinishedEntry
	"See
		#display
		#displayUnfinishedEntry
		#displayEngine"
	showOnDisplay ifTrue: [
		self displayUnfinishedEntryOnDisplay ifNotNil: [ :damage |
			self dirtyScreenRect: damage ]]! !

Transcript class
	instanceVariableNames: 'entries firstIndex lastIndex accessSemaphore unfinishedEntry logToFile showOnDisplay lastDisplayPosition bounds logToStdout displayEngine backgroundColor dirtyRectOnDisplay lastDisplayFlush'!

!classDefinition: 'Transcript class' category: #'System-Support' stamp: 'Install-7329-TranscriptSpeedupForMacIntel-JuanVuletich-2025Jul07-08h52m-jmv.003.cs.st 7/15/2025 11:02:11'!
Transcript class
	instanceVariableNames: 'entries firstIndex lastIndex accessSemaphore unfinishedEntry logToFile showOnDisplay lastDisplayPosition bounds logToStdout displayEngine backgroundColor dirtyRectOnDisplay lastDisplayFlush'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7329-TranscriptSpeedupForMacIntel-JuanVuletich-2025Jul07-08h52m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7278] on 19 June 2025 at 10:13:46 am'!
!CompiledMethod class methodsFor: 'method encoding' stamp: 'jmv 6/19/2025 10:12:44'!
                               headerFlagForEncoderClass: anEncoderClass
	
	(anEncoderClass includesBehavior: PrimaryBytecodeSetEncoderClass) ifTrue: [^0].
	(anEncoderClass includesBehavior: SecondaryBytecodeSetEncoderClass) ifTrue: [^SmallInteger minVal].
	
	self error: 'The encoder is not one of the two installed bytecode sets'! !
!BytecodeEncoder methodsFor: 'method generation' stamp: 'jmv 6/19/2025 10:12:56' prior: 16802332!
              computeMethodHeaderForNumArgs: numArgs numTemps: numTemps numLits: numLits primitive: primitiveIndex
	numArgs > 15
		ifTrue: [^self error: 'Cannot compile -- too many arguments'].
	numTemps > 63
		ifTrue: [^self error: 'Cannot compile -- too many temporary variables'].	
	numLits > 65535
		ifTrue: [^self error: 'Cannot compile -- too many literals'].
	^(CompiledMethod headerFlagForEncoderClass: self class)
		+ (numArgs bitShift: 24)
		+ (numTemps bitShift: 18)
		"+ (largeBit bitShift: 17)" "largeBit gets filled in later"
		+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0])
		+ numLits! !
!CompiledMethod class methodsFor: 'instance creation' stamp: 'jmv 6/19/2025 10:13:30' prior: 16835903!
                             newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex
	"Answer an instance of me. The header is specified by the message 
	 arguments. The remaining parts are not as yet determined."
	| method pc |
"15 | 63 | 32767"
	nArgs > 15
		ifTrue: [^self error: 'Cannot compile -- too many arguments'].
	nTemps > 63
		ifTrue: [^self error: 'Cannot compile -- too many temporary variables'].	
	nLits > 32767
		ifTrue: [^self error: 'Cannot compile -- too many literals'].

	method := self
				createMethod: numberOfBytes
				trailer: trailer
				header:  (CompiledMethod headerFlagForEncoderClass: PreferredBytecodeSetEncoderClass)
						+ (nArgs bitShift: 24)
						+ (nTemps bitShift: 18)
						+ ((nTemps + stackSize) > SmallFrame ifTrue: [1 bitShift: 17] ifFalse: [0])
						+ nLits
						+ (primitiveIndex > 0 ifTrue: [1 bitShift: 16] ifFalse: [0]).
	primitiveIndex > 0 ifTrue: [
		pc := method initialPC.
		method
			at: pc + 0 put: method encoderClass callPrimitiveCode;
			at: pc + 1 put: (primitiveIndex bitAnd: 16rFF);
			at: pc + 2 put: (primitiveIndex bitShift: -8)].
	^method! !

CompiledMethod class removeSelector: #headerFlagForEncoder:!

!methodRemoval: CompiledMethod class #headerFlagForEncoder: stamp: 'Install-7330-headerFlagForEncoderClass-JuanVuletich-2025Jun19-10h12m-jmv.001.cs.st 7/15/2025 11:02:11'!
headerFlagForEncoder: anEncoder
	
	(anEncoder class includesBehavior: PrimaryBytecodeSetEncoderClass) ifTrue: [^0].
	(anEncoder class includesBehavior: SecondaryBytecodeSetEncoderClass) ifTrue: [^SmallInteger minVal].
	
	self error: 'The encoder is not one of the two installed bytecode sets'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7330-headerFlagForEncoderClass-JuanVuletich-2025Jun19-10h12m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7279] on 19 June 2025 at 2:46:56 pm'!
!SequenceableCollection methodsFor: '[mk] comparing' stamp: 'jmv 6/19/2025 10:48:21'!
     is: otherCollection subcollectionAt: index
	"Answer whether the receiver includes otherCollection as a subcollection at position index."

	| sequenceSize |
	index < 1 ifTrue: [ ^false ].
	sequenceSize := otherCollection size.
	sequenceSize = 0 ifTrue: [ ^true ].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	1 to: sequenceSize do: [ :i |
		(self at: index+i-1) = (otherCollection at: i) ifFalse: [ ^false ]].
	^true! !
!CharacterSequence methodsFor: 'comparing' stamp: 'jmv 6/19/2025 10:48:50' prior: 16813421!
                   is: subString substringAt: index
	"Answer whether the receiver includes aString as a subcollection at position index.
	The comparison is case-sensitive."

	^self is: subString subcollectionAt: index! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7331-is-subCollectionAt-JuanVuletich-2025Jun19-14h45m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7279] on 19 June 2025 at 2:48:05 pm'!
!EncoderForSistaV1 class methodsFor: 'bytecode decoding' stamp: 'jmv 6/19/2025 10:35:26'!
                     emptyClosurePattern
	"Answer the byte pattern for an empty closure. For instance (verbatim from the bytecode view):
		45 <FA 00 02> closureNumCopied: 0 numArgs: 0 bytes 48 to 49
		48 	<4F> pushConstant: nil
		49 	<5E> blockReturn"
	"ByteArray readHexFrom: 'FA00024F5E'"
	^ #[250 0 2 79 94]! !
!EncoderForV3PlusClosures class methodsFor: 'bytecode decoding' stamp: 'jmv 6/19/2025 10:35:30'!
                          emptyClosurePattern
	"Answer the byte pattern for an empty closure. For instance (verbatim from the bytecode view):
		33 <8F 00 00 02> closureNumCopied: 0 numArgs: 0 bytes 37 to 38
		37 	<73> pushConstant: nil
		38 	<7D> blockReturn"
	"ByteArray readHexFrom: '8F000002737D'"
	^ #[143 0 0 2 115 125]! !
!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 6/19/2025 10:51:33' prior: 16977216!
            browseMethodsWithEmptyClosures
	"
	Smalltalk browseMethodsWithEmptyClosures
	"
	| pattern1 pattern2 |
	pattern1 := CompiledMethod primaryBytecodeSetEncoderClass emptyClosurePattern.
	pattern2 := CompiledMethod secondaryBytecodeSetEncoderClass emptyClosurePattern.
	self
		browseAllSelect: [ :m | | s |
			s := InstructionStream on: m.
			s scanFor: [ :bytecode |
				(s method is: pattern1 subcollectionAt: s pc) or:
					[s method is: pattern2 subcollectionAt: s pc]]]
		name:  'Methods with empty closures'
		autoHighlight: '[]'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7332-SistaCompatibility-EmptyClosureDetection-2025Jun19-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7332] on 7 July 2025 at 11:23:30 am'!

IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments '
	classVariableNames: 'ChangesInitialFileSize EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore PreviousUserChangesName ShutDownList SourceFileVersionString SpecialSelectors StartUpList StartupStamp SystemAttributeCache '
	poolDictionaries: ''
	category: 'MinimalKernel-Support'!

!classDefinition: #SystemDictionary category: #'MinimalKernel-Support' stamp: 'Install-7333-SystemDictionary-cleanup-JuanVuletich-2025Jul07-11h22m-jmv.001.cs.st 7/15/2025 11:02:11'!
IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments'
	classVariableNames: 'ChangesInitialFileSize EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore PreviousUserChangesName ShutDownList SourceFileVersionString SpecialSelectors StartUpList StartupStamp SystemAttributeCache'
	poolDictionaries: ''
	category: 'MinimalKernel-Support'!
!SystemDictionary methodsFor: 'special objects' stamp: 'ul 3/21/2017 18:52' prior: 16977142!
                      specialSelectors
	"Return an array with flattened special selector - argument count pairs. VMMaker relies on this."
	
	^self specialObjectsArray at: 24! !

IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments'
	classVariableNames: 'ChangesInitialFileSize EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore PreviousUserChangesName ShutDownList SourceFileVersionString StartUpList StartupStamp SystemAttributeCache'
	poolDictionaries: ''
	category: 'MinimalKernel-Support'!

!classDefinition: #SystemDictionary category: #'MinimalKernel-Support' stamp: 'Install-7333-SystemDictionary-cleanup-JuanVuletich-2025Jul07-11h22m-jmv.001.cs.st 7/15/2025 11:02:11'!
IdentityDictionary subclass: #SystemDictionary
	instanceVariableNames: 'cachedClassNames cachedNonClassNames startUpScriptArguments startUpArguments'
	classVariableNames: 'ChangesInitialFileSize EndianCache LastImageName LastQuitLogPosition LowSpaceProcess LowSpaceSemaphore PreviousUserChangesName ShutDownList SourceFileVersionString StartUpList StartupStamp SystemAttributeCache'
	poolDictionaries: ''
	category: 'MinimalKernel-Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7333-SystemDictionary-cleanup-JuanVuletich-2025Jul07-11h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7332] on 7 July 2025 at 12:02:40 pm'!
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 7/7/2025 12:00:15' prior: 16825977!
                       annotationForSelector: aSelector ofClass: aClass
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	| method |
	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	method := aClass compiledMethodAt: aSelector ifAbsent: nil.
	^ String streamContents: [ :strm |
		(Preferences at: #methodAnnotations)
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp := self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						method notNil ifTrue: [
							strm
								print: method linesOfCode;
								nextPutAll: ' lines of code' ]].
					[#messageSendsCount] -> [
						method notNil ifTrue: [
							strm
								print: method messageSendsCount;
								nextPutAll: ' message sends' ]].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount := Smalltalk numberOfSendersOf: aSelector.
						sendersCount := sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount := Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount := implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp := VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						method notNil ifTrue: [
							(CodePackage packageOfMethod: method methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList := (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					[#closuresInfo] -> [
						strm nextPutAll: (aClass closuresInfoAt: aSelector)].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ].
		(method notNil and: [method hasBreakpoint]) ifTrue: [
			strm nextPutAll: self annotationSeparator.
			strm nextPutAll: '[Breakpoint]' ]
	].! !
!ChangeList methodsFor: 'viewing access' stamp: 'jmv 7/7/2025 12:00:26' prior: 16804989 overrides: 16825888!
                     annotation
	"Answer the string to be shown in an annotation pane.  Make plain that the annotation is associated with the current in-image version of the code, not of the selected disk-based version, and if the corresponding method is missing from the in-image version, mention that fact."

	| change count selectedCount ann1 ann2 |
	change := self currentChange.
	
	change isNil ifTrue: [
		count := listSelections size.
		selectedCount := listSelections count: [ :flag | flag ].
		^ 'Total items: ', count printString, ' - Selected items: ', selectedCount printString ].

	change changeType == #classDefinition ifTrue: [
		ann1 := change isMetaClassChange ifTrue: [ 'Metaclass' ] ifFalse: [ 'Class' ].
		ann2 := (Smalltalk includesKey: change changeClassName) ifTrue: [ ' already exists' ] ifFalse: [ ' not in system' ].
		^ann1, ann2 ].
	
	(self selectedMessageName isNil or: [self selectedClassOrMetaClass isNil])
		ifTrue: [^ ''].

	^ change methodSelector notNil
		ifFalse: [ super annotation]
		ifTrue: [
			(self isNewMethod: change)
				ifTrue: [
					String streamContents: [ :strm | | sel |
						sel := change methodSelector.
						strm
							nextPutAll: change changeClassName;
							nextPutAll: ' >> ';
							nextPutAll: sel;
							nextPutAll: ' is not present in the system. It has '.
							count := Smalltalk numberOfImplementorsOf: sel.
							count = 1
								ifTrue: [strm nextPutAll: '1 implementor']
								ifFalse: [count printOn: strm. strm nextPutAll: ' implementors' ].
							strm nextPutAll: ' and '.
							count := Smalltalk numberOfSendersOf: sel.
							count = 1
								ifTrue: [strm nextPutAll: '1 sender.']
								ifFalse: [count printOn: strm. strm nextPutAll: ' senders.' ].
						]
					]
				ifFalse: [
					'current version: ', super annotation]]! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/7/2025 11:59:25' prior: 16974125!
numberOfSendersOf: aSymbol
	"Answer the count of all the methods that call on aLiteral.
	[ (Smalltalk numberOfSendersOf: #open:label:) ] timeToRun
	[ (Smalltalk numberOfSendersOf: #==) ] timeToRun
	"
	| count |
	count := 0.
	self allBehaviorsDo: [ :class |
		class selectorsAndMethodsDo: [ :sel :method |
			(method hasLiteral: aSymbol)
				ifTrue: [ count := count + 1 ]]].
	^ count! !

SystemDictionary removeSelector: #numberOfDirectSendersOf:!

!methodRemoval: SystemDictionary #numberOfDirectSendersOf: stamp: 'Install-7334-Senders-Not-DirectSenders-JuanVuletich-2025Jul07-11h23m-jmv.001.cs.st 7/15/2025 11:02:11'!
numberOfDirectSendersOf: aSymbol
	"Answer the count of all the methods that call on aLiteral.
	[ (Smalltalk numberOfSendersOf: #open:label:) ] timeToRun
	[ (Smalltalk numberOfDirectSendersOf: #open:label:) ] timeToRun
	[ (Smalltalk numberOfSendersOf: #==) ] timeToRun
	[ (Smalltalk numberOfDirectSendersOf: #==) ] timeToRun
	"
	| count specialFlag specialByte |
	count := 0.
	specialFlag := self hasSpecialSelector: aSymbol ifTrueSetByte: [ :b | specialByte := b ].
	self allBehaviorsDo: [ :class |
		class selectorsAndMethodsDo: [ :sel :method |
			((method hasLiteral: aSymbol) or: [specialFlag and: [(method scanFor: specialByte)]])
				ifTrue: [ count := count + 1 ]]].
	^ count!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7334-Senders-Not-DirectSenders-JuanVuletich-2025Jul07-11h23m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7334] on 7 July 2025 at 1:15:33 pm'!
!PreferenceSet methodsFor: 'services' stamp: 'jmv 7/7/2025 13:15:10'!
                     removeUnused
	"
	Preferences removeUnused
	Preferences allPreferences keys select: [ :key | (Smalltalk numberOfSendersOf: key) = 0 ]
	"
	(self allPreferences keys select: [ :key | (Smalltalk numberOfSendersOf: key) = 0 ])
		do: [ :key | self removeKey: key ].! !
!Behavior methodsFor: 'testing method dictionary' stamp: 'jmv 7/7/2025 13:10:25' prior: 16789273!
                       whichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |

	who := self thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte.

	^self rejectSelectorsFrom: who thatReferenceTo: literal byte: specialByte! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 7/7/2025 13:11:01' prior: 16936525!
                           machineDefault
	^ #(
		#(drawKeyboardFocusIndicator true )
		#(balloonHelpEnabled true )
		#(biggerCursors false )
		#(browseWithPrettyPrint false )
		#(caseSensitiveFinds false )
		#(checkForSlips true )
		#(cmdDotEnabled true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(menuKeyboardControl true )
		#(optionalButtons true )
		#(extraDebuggerButtons true )
		#(subPixelRenderFonts true )
		#(cheapWindowReframe false )
		#(syntaxHighlightingAsYouType true )
		#(tapAndHoldEmulatesButton2 true )
		#(clickGrabsMorphs false )
		#(showAssignmentAsLeftArrow false )
		#(wantsMenuIcons true )
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 7/7/2025 13:11:06' prior: 16936548!
                         machineSlow
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
		(methodAnnotations #(timeStamp messageCategory packages changeSets) )
		(classAnnotations  #(instanceMethodsCount classMethodsCount) )
		(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount) )
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 7/7/2025 13:11:11' prior: 16936574!
                        machineSmalltalk80
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
	)! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 7/7/2025 13:11:19' prior: 16936628!
              prefProgramming
	^ #(
		#(atMinusDigitMeaning st80 #(st80 ansiSmalltalk disabled) )
		#(allowBlockArgumentAssignment false )
		#(allowNonBooleanReceiversOfBooleanMessages false )
		#(alternativeBrowseIt false )
		#(browseWithPrettyPrint false )
		#(debugHaloHandle true )
		#(debugLogTimestamp true )
		#(debugShowDamage false )
		#(decorateBrowserButtons true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(extraDebuggerButtons true )
		#(fullPrintItInWorkspaces false )
		#(highlightBlockNesting true )
		#(italicsInShout true)
		#(listClassesHierarchically true )
		#(logDebuggerStackToFile false )
		#(prettyPrintRectangularBlocks false )
		#(shiftClickShowsImplementors false )
		#(shoutInWorkspaces true )
		#(showAnnotations true )
		#(showLinesInHierarchyViews true )
		#(stylingWithEmphasisInWorkspaces false )
		#(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount "linesOfCode" messageSendsCount) )
		#(classAnnotations #(instanceMethodsCount classMethodsCount "linesOfCode" messageSendsCount) )
		#(messageCategoryAnnotations #(messagesCount messageSendsCount) )
		#(methodAnnotations #(timeStamp "linesOfCode" messageSendsCount messageCategory implementorsCount sendersCount  packages changeSets) )	
		#(syntaxHighlightingAsYouType true )
		#(showAssignmentAsLeftArrow false )
		#(usePreDebugWindow false)
		#(clearPackagePathsOnImageMove true)
	)! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

Preferences removeUnused!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7335-throughSenders-Preference-remove-JuanVuletich-2025Jul07-13h10m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7335] on 7 July 2025 at 2:19:40 pm'!
!MethodSet methodsFor: 'filtering' stamp: 'jmv 7/7/2025 13:33:18' prior: 16908878!
   filterToNotSendersOf
	"Filter the receiver's list down to only those items which do not send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol |
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) isNil or:
							[(aMethod hasLiteral: aSymbol) not]]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 7/7/2025 13:33:23' prior: 16908895!
                             filterToSendersOf
	"Filter the receiver's list down to only those items which send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol | 
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) notNil and:
							[aMethod hasLiteral: aSymbol]]]]! !
!Behavior methodsFor: 'testing method dictionary' stamp: 'jmv 7/7/2025 14:18:29' prior: 50343411!
                           whichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |
	who := Set new.
	self selectorsAndMethodsDo: [ :sel :method |
		(method hasLiteral: literal)
			ifTrue: [
				((literal isVariableBinding) not
					or: [method sendsToSuper not
					"N.B. (method indexOfLiteral: literal) < method numLiterals copes with looking for
					Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."
					or: [(method indexOfLiteral: literal) ~= 0]])
						ifTrue: [who add: sel]]].

	"For special selectors, look for the literal in the source code.
	Otherwise, for example, searching for senders of #== will include senders of #ifNil.
	Except for #at:put:, because it has two arguments and won't find it in the source code like that."
	^ (specialByte isNil or: [ literal = #at:put: ]) 
		ifTrue: [ who ]
		ifFalse: [ who select: [ :sel | ((self sourceCodeAt: sel) findString: literal) > 0]]! !
!CompiledMethod methodsFor: 'testing' stamp: 'jmv 7/7/2025 13:33:52' prior: 16835660!
                             sendsOrRefersTo: aSelector

	^ (self hasLiteral: aSelector) or: [ self sendsSelector: aSelector ]! !

AdditionalMethodState removeSelector: #hasLiteralThorough:!

!methodRemoval: AdditionalMethodState #hasLiteralThorough: stamp: 'Install-7336-no-thorough-literalSearch-JuanVuletich-2025Jul07-13h31m-jmv.002.cs.st 7/15/2025 11:02:12'!
hasLiteralThorough: literal
	"Answer true if any literal in these properties is literal,
	 even if embedded in array structure."
	| propertyOrPragma "<Association|Pragma>" |
	1 to: self basicSize do: [:i |
		propertyOrPragma := self basicAt: i.
		(propertyOrPragma isVariableBinding
			ifTrue: [propertyOrPragma key == literal
					or: [propertyOrPragma value == literal
					or: [propertyOrPragma value isArray
						and: [propertyOrPragma value hasLiteral: literal]]]]
			ifFalse: [propertyOrPragma hasLiteral: literal]) ifTrue:
			[^true]].
	^false!

CompiledMethod removeSelector: #hasLiteralThorough:!

!methodRemoval: CompiledMethod #hasLiteralThorough: stamp: 'Install-7336-no-thorough-literalSearch-JuanVuletich-2025Jul07-13h31m-jmv.002.cs.st 7/15/2025 11:02:12'!
hasLiteralThorough: literal
	"Answer true if any literal in this method is literal,
	even if embedded in array structure."

	| lit |
	
	self withPropertiesDo: [ :properties | (properties hasLiteralThorough: literal) ifTrue:[^true]].
	
	2 to: self numLiterals - 1 "exclude superclass + selector/properties"
	   do: [ :index |
		(((lit := self objectAt: index) literalEqual: literal)
		 or: [(lit isVariableBinding and: [lit key == literal])
		 or: [lit isArray and: [lit hasLiteral: literal]]]) ifTrue:
			[^ true]].
	^ false !

Behavior removeSelector: #rejectSelectorsFrom:thatReferenceTo:byte:!

!methodRemoval: Behavior #rejectSelectorsFrom:thatReferenceTo:byte: stamp: 'Install-7336-no-thorough-literalSearch-JuanVuletich-2025Jul07-13h31m-jmv.002.cs.st 7/15/2025 11:02:12'!
rejectSelectorsFrom: selectors thatReferenceTo: aLiteral byte: specialByte 

	"For special selectors, look for the literal in the source code.
	Otherwise, for example, searching for senders of #== will include senders of #ifNil.
	Except for #at:put:, because it has two arguments and won't find it in the source code like that."

	^ (specialByte isNil or: [ aLiteral = #at:put: ]) 
		ifTrue: [ selectors ]
		ifFalse: [ selectors select: [ :sel | ((self sourceCodeAt: sel) findString: aLiteral) > 0]]!

Behavior removeSelector: #thoroughWhichSelectorsReferTo:special:byte:!

!methodRemoval: Behavior #thoroughWhichSelectorsReferTo:special:byte: stamp: 'Install-7336-no-thorough-literalSearch-JuanVuletich-2025Jul07-13h31m-jmv.002.cs.st 7/15/2025 11:02:12'!
thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a 
	literal. Dives into the compact literal notation, making it slow but 
	thorough "

	| who |
	who := Set new.
	self selectorsAndMethodsDo: [ :sel :method |
		(method is: #CompiledMethod) ifTrue: [
			((method hasLiteralThorough: literal) or: [specialFlag and: [method scanFor: specialByte]])
				ifTrue: [
					((literal isVariableBinding) not
						or: [method sendsToSuper not
						"N.B. (method indexOfLiteral: literal) < method numLiterals copes with looking for
						Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."
						or: [(method indexOfLiteral: literal) ~= 0]])
							ifTrue: [who add: sel]]]].
	^ who.
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7336-no-thorough-literalSearch-JuanVuletich-2025Jul07-13h31m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7336] on 8 July 2025 at 11:34:54 am'!
!EphemeronIdentityDictionary methodsFor: 'finalization' stamp: 'jmv 7/8/2025 09:49:17' prior: 50334388!
                            finalizeEphemeron: anEphemeron

	"Remove the ephemeron from myself.  Note that no finalization of the ephemeron's key is done.
	 Here we are using ephemerons to clean up property tables."

	self removeKey: anEphemeron key ifAbsent: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7337-EphemeronIdentityDictionary-tweak-JuanVuletich-2025Jul08-11h34m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7336] on 8 July 2025 at 11:36:54 am'!
!Object methodsFor: 'events-removing' stamp: 'jmv 7/8/2025 11:32:33'!
                     removeAllActions
	"Empty our #actionMap.
	Use this method when done with some object holding dependents. Do not call #releaseActionMap.
	Actually, usually you don't need to call any of these. Our #actionMap is cleared autonatically when
	we are collected,	as ActionMaps is an EphemeronIdentityDictionary.
	"
	self removeActionsSatisfying: [ :any | true ]! !
!ActiveModel methodsFor: 'accessing' stamp: 'jmv 7/8/2025 11:31:12' overrides: 50343765!
 removeAllActions

    actionMap := nil! !
!Object methodsFor: 'events-removing' stamp: 'jmv 7/8/2025 11:27:36' prior: 16922306!
releaseActionMap
	"Modifying ActionMaps is kinda dangerous.
	It is an instance of EphemeronIdentityDictionary.
	Its integrity is protected by a Mutex, meaning that nested accesses from the same process could
	break it, leading to system crash if not done very carefully.
	As this is public protocol, and in any case EphemeronIdentityDictionary are automatically cleared
	when keys are collected, the risk is not worth it.
	"
	"ActiveModel releaseActionMapFor: self."
	self removeAllActions.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7338-Safer-releaseActionMap-JuanVuletich-2025Jul08-11h34m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7336] on 8 July 2025 at 11:38:56 am'!
!Object methodsFor: 'events-removing' stamp: 'jmv 7/8/2025 11:09:50' prior: 16922319!
                 removeActionsForEvent: anEventSelector

	| map |
	map := self actionMap.
	map ifNotNil: [
		map removeKey: anEventSelector asSymbol ifAbsent: nil.
		"No need. ActionMaps is an EphemeronIdentityDictionary. Keys are automatically removed when collectable.
		Besides, this is dangerous for instance, if called from an iteration of ActionMaps."
		"map isEmpty
			ifTrue: [ self releaseActionMap ]"
		]! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/8/2025 11:23:30' prior: 16914003!
                     clearDependencyAndEvents
"
Morph allSubInstancesDo: [ :m | m clearDependencyAndEvents ].
"
	SystemChangeNotifier uniqueInstance removeActionsWithReceiver: self.
	self removeAllActions.! !
!ProgressiveTestRunner methodsFor: 'evaluating - private' stamp: 'jmv 7/8/2025 11:27:48' prior: 16940283!
                          unregisterTestSuiteAction
	
	testSuite removeAllActions! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7339-DontCall-releaseActionMap-JuanVuletich-2025Jul08-11h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7336] on 8 July 2025 at 11:40:14 am'!
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/8/2025 09:33:40' prior: 16914017!
                             delete
	"Remove the receiver as a submorph of its owner and make its 
	new owner be nil."

	| aWorld |
	aWorld := self world ifNil: [ self runningWorld ].
	aWorld ifNotNil: [
		aWorld activeHand ifNotNil: [ :h | h
			releaseKeyboardFocus: self;
			releaseMouseFocus: self ]].
	self clearDependencyAndEvents.
	self allSubmorphsDo: [ :each |
		each clearDependencyAndEvents ].
	self privateDelete.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7340-Morph-tweak-JuanVuletich-2025Jul08-11h38m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7340] on 8 July 2025 at 2:29:39 pm'!
!Behavior methodsFor: 'testing method dictionary' stamp: 'jmv 7/7/2025 16:00:14'!
whichSelectorsReferExplicitlyTo: literal
	"Answer a set of selectors whose methods access the argument as a literal,
	and refer explicitly to in Source Code.
	Useful for finding senders of selectors.
	See #whichSelectorsReferTo:."

	| who |
	who := Set new.
	self selectorsAndMethodsDo: [ :sel :method |
		(method hasLiteralExplicitly: literal)
			ifTrue: [
				who add: sel]].
	^who
	"
	Rectangle whichSelectorsReferExplicitlyTo: #==.
	"! !
!Behavior methodsFor: 'methods' stamp: 'jmv 7/8/2025 14:28:23'!
      addMethodsTo: methodsReferencingLiteral thatReferExplicitlyTo: aLiteral
	
	| selectors |
	
	selectors := self whichSelectorsReferExplicitlyTo: aLiteral.
	selectors do: [ :sel | methodsReferencingLiteral add: (MethodReference class: self selector: sel) ]! !
!Behavior methodsFor: 'methods' stamp: 'jmv 7/8/2025 14:26:05'!
                               addMethodsTo: methodsReferencingLiteral thatReferTo: aLiteral

	(self whichSelectorsReferTo: aLiteral)
		do: [ :sel |
			methodsReferencingLiteral add: (MethodReference class: self selector: sel) ]! !
!Behavior methodsFor: 'methods' stamp: 'jmv 7/8/2025 14:28:51'!
                       addTo: aSet methodsThatReferInHierarchyTo: aSymbol
	
	self withAllSuperAndSubclassesDo: [ :class |
		class addMethodsTo: aSet thatReferExplicitlyTo: aSymbol ] 
		! !
!CompiledMethod methodsFor: 'testing' stamp: 'jmv 7/7/2025 15:45:36'!
                    hasLiteralExplicitly: aLiteral
	"Similar to #hasLiteral:
	But do not include methods that (for example) #hasLiteral: #==
	only because the Compiler implements #ifNil: that way.
	See #hasLiteral:.
	Useful for finding senders of selectors."

	| canBeSpecialLiteral |
	canBeSpecialLiteral := self encoderClass canBeSpecialLiteral: aLiteral.

	"If we don't hasLiteral: it, just answer false."
	(self
		hasLiteralSuchThat: [:lit | lit literalEqual: aLiteral]
		scanForSpecial: canBeSpecialLiteral)
			ifFalse: [ ^false ].

	"Any literal but these appears for sure in source code, so it appears explicitly."
	canBeSpecialLiteral
		ifFalse: [ ^true ].

	"#at:put: is the only special selector that can't be found with #findString:
	But, it is also not generated implicitly by the Compiler.
	So we know it is actually sent in source code anyway."
	aLiteral = #at:put: ifTrue: [
		^true ].

	"Other special selectors, like #== must be found in source code to be considered."
	^(self getSource findString: aLiteral) > 0! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 7/7/2025 15:57:33' prior: 50343557!
                        filterToNotSendersOf
	"Filter the receiver's list down to only those items which do not send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol |
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) isNil or:
							[(aMethod hasLiteralExplicitly: aSymbol) not]]]]! !
!MethodSet methodsFor: 'filtering' stamp: 'jmv 7/7/2025 15:57:37' prior: 50343575!
                   filterToSendersOf
	"Filter the receiver's list down to only those items which send a given selector."
	
	self request: 'Enter selector:' initialAnswer: '' verifying: [:aString| aString notEmpty] do: [:aString|
		Symbol hasInterned: aString withBlanksTrimmed ifTrue:
			[:aSymbol | 
				self filterFrom:
					[:aClass :aSelector | | aMethod |
						(aMethod := aClass compiledMethodAt: aSelector) notNil and:
							[aMethod hasLiteralExplicitly: aSymbol]]]]! !
!Behavior methodsFor: 'testing method dictionary' stamp: 'jmv 7/7/2025 16:00:05' prior: 16789260!
                 whichSelectorsReferTo: literal
	"Answer a set of selectors whose methods access the argument as a literal.
	Useful for finding references to literals.
	See #whichSelectorsReferExplicitlyTo:."

	| who |
	who := Set new.
	self selectorsAndMethodsDo: [ :sel :method |
		(method hasLiteral: literal)
			ifTrue: [
				who add: sel]].
	^who
	"
	Rectangle whichSelectorsReferTo: #==.
	"! !
!Behavior methodsFor: 'user interface' stamp: 'jmv 7/8/2025 14:28:57' prior: 16789402!
          allLocalCallsOn: aSymbol
	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."

	| aSet cls |
	
	aSet := Set new.
	cls := self theNonMetaClass.
	
	cls addTo: aSet methodsThatReferInHierarchyTo: aSymbol.
	cls class addTo: aSet methodsThatReferInHierarchyTo: aSymbol.
	
	^aSet! !
!CompiledMethod methodsFor: 'literals' stamp: 'eem 7/8/2024 15:15' prior: 16834524 overrides: 16923970!
                  hasLiteral: aLiteral
	"Overwrite this method to invoke the bytecode encoder scanner explicitly.
	 This might be removed if there would be a way to enumerate special literals in a compiled-code object.
	See #allLiteralsDo:.
	See #hasLiteralExplicitly:. Prefer this for finding senders of selectors."

	^ self
		hasLiteralSuchThat: [:lit | lit literalEqual: aLiteral]
		scanForSpecial: (self encoderClass canBeSpecialLiteral: aLiteral)! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/8/2025 14:28:34' prior: 16973369!
                allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."
	"Answer a Collection of all the methods that call on aLiteral."
	| aCollection |

	#(23 48 'fred' (new open:label:)) size.
	"Example above should find #open:label:, though it is deeply embedded here."

	aCollection := OrderedCollection new.
	self allBehaviorsDo: [ :class |
		class addMethodsTo: aCollection thatReferExplicitlyTo: aLiteral ].
	
	^ aCollection! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/7/2025 15:37:33' prior: 16973390!
                      allCallsOn: firstLiteral and: secondLiteral
	"Answer a SortedCollection of all the methods that call on both aLiteral
	and secondLiteral."

	| aCollection secondArray |
	aCollection := SortedCollection new.
	self allBehaviorsDo: [ :class |
		secondArray := class
			whichSelectorsReferExplicitlyTo: secondLiteral.
				((class whichSelectorsReferExplicitlyTo: firstLiteral ) select: [ :aSel |
			(secondArray includes: aSel)]) do: [ :sel |
				aCollection add: (MethodReference class: class selector: sel )]].
	^aCollection! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/8/2025 14:26:13' prior: 16973850!
                       allReferencesToLiteral: aLiteral
	| coll |
	coll := OrderedCollection new.
	self allBehaviorsDo: [ :eaClass |
		eaClass
			addMethodsTo: coll
			thatReferTo: aLiteral ]..
	^ coll.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/7/2025 16:37:36' prior: 16974035!
              isThereAReferenceTo: aLiteral
	"Answer a Collection of all the methods that call on aLiteral."
	"
	Smalltalk isThereAReferenceTo: #open:label:
	"

	#(23 48 'fred' (new open:label:)) size.
"Example above should find #open:label:, though it is deeply embedded here."

	self allBehaviorsDo: [ :class |
		class selectorsAndMethodsDo: [ :sel :method |
			(method hasLiteral: aLiteral)
				ifTrue: [ ^true ]]].
	^ false! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/7/2025 16:19:53' prior: 50343348!
    numberOfSendersOf: aSymbol
	"Answer the count of all the methods that call on aLiteral.
	Note: For some selectors, like #==, this method will give an incorrect answer, much larger than the correct one.
	The correct answer would require calling the more expensive #hasLiteralExplicitly: method.
	[ (Smalltalk numberOfSendersOf: #open:label:) ] timeToRun
	[ (Smalltalk numberOfSendersOf: #==) ] timeToRun
	"
	| count |
	count := 0.
	self allBehaviorsDo: [ :class |
		class selectorsAndMethodsDo: [ :sel :method |
			"
			(method hasLiteralExplicitly: aSymbol)
			"
			(method hasLiteral: aSymbol)
				ifTrue: [ count := count + 1 ]]].
	^ count! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 7/8/2025 14:26:22' prior: 16977031!
  browseViewReferencesFromNonViews
	"
	Smalltalk browseViewReferencesFromNonViews
	"
	| aLiteral aCollection |

	aCollection := OrderedCollection new.

	"Tweak to look just for pluggables or also for menus (or maybe for all morphs)"
"	PopUpMenu withAllSubclasses , MenuMorph withAllSubclasses , PluggableMorph withAllSubclasses do: [ :view |"
	PluggableMorph withAllSubclassesDo: [ :view |
"	MenuMorph withAllSubclassesDo: [ :view |"
		
		aLiteral := view name.
		
		"tweak to linclude refs to SysWindow subhierarchy or not"
		(view includesBehavior: SystemWindow) & false ifFalse: [
			self allBehaviorsDo: [ :class |
				((class includesBehavior: Morph) or: [ class includesBehavior: Morph class ]) ifFalse: [
					class addMethodsTo: aCollection thatReferTo: aLiteral ]]]].
	
	self
		browseMessageList: aCollection asSet
		name: 'References to Views from non-Views'.! !
!ChangeSelectorSendersStepWindow methodsFor: 'actions' stamp: 'jmv 7/7/2025 14:55:57' prior: 16807323!
                  askAndAddSenderOf: classOfSenderToAdd 
		
	| senderSelector senderToAdd |
	
	senderSelector := self request: 'Selector of sender of #', self oldSelector initialAnswer: '' orCancel: [^self ].
	senderToAdd := classOfSenderToAdd 
		compiledMethodAt: senderSelector asSymbol
		ifAbsent: [ ^self inform: classOfSenderToAdd doesNotImplement: senderSelector asSymbol].
		
	(senderToAdd sendsSelector: self oldSelector) ifFalse: [
		^self inform: senderToAdd classAndSelector, ' does not refer to #', self oldSelector ].
	
	self addToList: senderToAdd! !
!InlineMethodUsagesStepWindow methodsFor: 'actions' stamp: 'jmv 7/7/2025 14:55:54' prior: 16884940!
                         askAndAddAllUsagesInSenderOf: classOfSenderToAdd

	"Adds all usages of the selected sender to the usages to refactor"
	| senderSelector senderToAdd |

	senderSelector := self request: 'Selector of sender of #', self selectorToInline initialAnswer: '' orCancel: [^self ].
	senderToAdd := classOfSenderToAdd
		compiledMethodAt: senderSelector asSymbol
		ifAbsent: [ ^self inform: classOfSenderToAdd doesNotImplement: senderSelector asSymbol].

	(senderToAdd sendsSelector: self selectorToInline) ifFalse: [
		^self inform: senderToAdd classAndSelector, ' does not refer to #', self selectorToInline].

	(applier refactoringClass findReferencesToSelector: self selectorToInline in: senderToAdd asMethodReference)
		do: [:aMessageNodeReference | self addToList: aMessageNodeReference]! !
!ChangeSelector methodsFor: 'create new implementors - private' stamp: 'jmv 7/7/2025 14:55:40' prior: 16806248!
addToSendersIfOldSelectorIsSentIn: newImplementor
	
	(newImplementor sendsSelector: oldSelector) ifTrue: [
		senders add: newImplementor ].! !
!ChangeSelector class methodsFor: 'pre-conditions' stamp: 'jmv 7/7/2025 14:55:31' prior: 16806422!
              assertAllSenders: senders send: aSelector

	| invalidSenders |
	
	invalidSenders := senders reject: [ :aSender | aSender sendsSelector: aSelector ].
	invalidSenders notEmpty ifTrue: [ self signalInvalidSenders: invalidSenders of: aSelector ].! !

SystemDictionary removeSelector: #hasSpecialSelector:ifTrueSetByte:!

!methodRemoval: SystemDictionary #hasSpecialSelector:ifTrueSetByte: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:12'!
hasSpecialSelector: aLiteral ifTrueSetByte: aBlock
	1 to: self specialSelectorSize do:
		[:index | 
		(self specialSelectorAt: index) == aLiteral
			ifTrue: [aBlock value: index + 16rAF. ^true]].
	^false!

CompiledMethod removeSelector: #refersToLiteral:!

!methodRemoval: CompiledMethod #refersToLiteral: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:12'!
refersToLiteral:aLiteral

	^self hasLiteral: aLiteral.!

CompiledMethod removeSelector: #sendsOrRefersTo:!

!methodRemoval: CompiledMethod #sendsOrRefersTo: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:12'!
sendsOrRefersTo: aSelector

	^ (self hasLiteral: aSelector) or: [ self sendsSelector: aSelector ]!

Behavior removeSelector: #addMethodsTo:thatReferenceTo:!

Behavior removeSelector: #addTo:methodsThatReferenceInHierarchyTo:special:byte:!

!methodRemoval: Behavior #addTo:methodsThatReferenceInHierarchyTo:special:byte: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:12'!
addTo: aSet methodsThatReferenceInHierarchyTo: aSymbol special: special byte: byte.
	
	self withAllSuperAndSubclassesDo: [ :class |
		class addMethodsTo: aSet thatReferenceTo: aSymbol special: special byte: byte ] 
		!

Behavior removeSelector: #addTo:methodsThatReferenceInHierarchyTo:!

Behavior removeSelector: #addMethodsTo:thatReferenceTo:special:byte:!

!methodRemoval: Behavior #addMethodsTo:thatReferenceTo:special:byte: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:12'!
addMethodsTo: methodsReferencingLiteral thatReferenceTo: aLiteral special: specialFlag byte: specialByte
	
	| selectors |
	
	selectors := self whichSelectorsReferTo: aLiteral special: specialFlag byte: specialByte.
	selectors do: [ :sel | methodsReferencingLiteral add: (MethodReference class: self selector: sel) ]!

Behavior removeSelector: #addMethodsTo:thatReferenceExplicitlyTo:!

Behavior removeSelector: #whichSelectorsReferTo:special:byte:!

!methodRemoval: Behavior #whichSelectorsReferTo:special:byte: stamp: 'Install-7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st 7/15/2025 11:02:12'!
whichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |
	who := Set new.
	self selectorsAndMethodsDo: [ :sel :method |
		(method hasLiteral: literal)
			ifTrue: [
				((literal isVariableBinding) not
					or: [method sendsToSuper not
					"N.B. (method indexOfLiteral: literal) < method numLiterals copes with looking for
					Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."
					or: [(method indexOfLiteral: literal) ~= 0]])
						ifTrue: [who add: sel]]].

	"For special selectors, look for the literal in the source code.
	Otherwise, for example, searching for senders of #== will include senders of #ifNil.
	Except for #at:put:, because it has two arguments and won't find it in the source code like that."
	^ (specialByte isNil or: [ literal = #at:put: ]) 
		ifTrue: [ who ]
		ifFalse: [ who select: [ :sel | ((self sourceCodeAt: sel) findString: literal) > 0]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7341-hasLiteralCleanup-SistaCompatibility-JuanVuletich-2025Jul08-14h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7341] on 8 July 2025 at 2:57:54 pm'!
!ChangeSelector class methodsFor: 'pre-conditions' stamp: 'jmv 7/8/2025 14:52:43' prior: 50344204!
                           assertAllSenders: senders send: aSelector

	| invalidSenders |
	
	invalidSenders := senders reject: [ :aSender | aSender hasLiteral: aSelector ].
	invalidSenders notEmpty ifTrue: [ self signalInvalidSenders: invalidSenders of: aSelector ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7342-assertAllSenders-use-hasLiteral-JuanVuletich-2025Jul08-14h49m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7342] on 10 July 2025 at 1:38:35 pm'!
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 7/10/2025 09:39:35' overrides: 16848941!
                               at: key ifAbsentPut: aBlock
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."

	^mutex critical: [ super at: key ifAbsentPut: aBlock ]! !
!Dictionary methodsFor: 'accessing' stamp: 'jmv 7/10/2025 09:43:22' prior: 16848941!
                at: key ifAbsentPut: aBlock
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."

	| index assoc newObject |
	index := self findElementOrNil: key.
	assoc := array at: index.
	assoc ifNotNil: [
		^assoc value ].
	newObject := aBlock value.
	self atNewIndex: index put: (self associationClass key: key value: newObject).
	^ newObject! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7343-atifAbsentPut-JuanVuletich-2025Jul10-13h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7342] on 10 July 2025 at 1:30:09 pm'!
!Dictionary methodsFor: 'accessing' stamp: 'jmv 7/10/2025 10:31:25'!
                            at: key ifAbsentOrNilPut: aBlock
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."

	| index assoc newObject |
	index := self findElementOrNil: key.
	assoc := array at: index.
	assoc ifNotNil: [
		assoc value ifNil: [ assoc value: aBlock value ].
		^assoc value ].
	newObject := aBlock value.
	self atNewIndex: index put: (self associationClass key: key value: newObject).
	^ newObject! !
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'jmv 7/10/2025 10:28:32' overrides: 50344389!
                at: key ifAbsentOrNilPut: aBlock
	"Return the value at the given key.
	If key is not included in the receiver store the result
	of evaluating aBlock as new value."

	^mutex critical: [ super at: key ifAbsentOrNilPut: aBlock ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7344-atifAbsentOrNilPut-JuanVuletich-2025Jul10-13h28m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7343] on 10 July 2025 at 2:10:48 pm'!
!EphemeronIdentityDictionary methodsFor: 'access protected protocol' stamp: 'eem 12/18/2024 11:39:36' prior: 16860084 overrides: 16849155!
         removeKey: key ifAbsent: aBlock
	"Public protocol: Protect against the EphemeronFinalizationProcess modifying us.
	Note: Usually removing from our instances is done automatically when the key is collected.
	This method usually doesn't need to be called by users of this class."

	^mutex critical: [super removeKey: key ifAbsent: aBlock]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7345-EphemeronDictTweak-JuanVuletich-2025Jul10-14h10m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7345] on 11 July 2025 at 9:55:23 am'!
!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'jmv 7/11/2025 09:29:27'!
                classDefinitionChangedFrom: oldClass to: newClass oldClassDefinition: oldClassDefinition

	self
		triggerEvent: #classDefinitionChanged
		withArguments: { oldClass . newClass . oldClassDefinition }! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/11/2025 09:43:21' prior: 16816659!
                         class: oldClass instanceVariableNames: instVarString unsafe: unsafe
	"This is the basic initialization message to change the definition of
	an existing Metaclass"
	| instVars newClass needNew copyOfOldClass oldClassDefinition |
	instVars := Scanner new scanFieldNames: instVarString.
	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].
		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].
	"See if we need a new subclass or not"
	needNew := self needsSubclassOf: oldClass superclass type: oldClass typeOfClass instanceVariables: instVars from: oldClass.
	needNew ifNil:[^nil]. "some error"
	needNew ifFalse:[^oldClass]. "no new class needed"

	"Create the new class"
	oldClassDefinition := oldClass definition.
	copyOfOldClass := oldClass copy.
	newClass := self 
		newSubclassOf: oldClass superclass 
		type: oldClass typeOfClass
		instanceVariables: instVars
		from: oldClass.

	"Please see comment at this method. Also see other senders."
	newClass := self recompileSingleRecursion: false from: oldClass to: newClass.
	newClass isNil ifTrue: [ ^nil ].

	self doneCompiling: newClass.
	SystemChangeNotifier uniqueInstance
		classDefinitionChangedFrom: copyOfOldClass to: newClass oldClassDefinition: oldClassDefinition.
	^newClass! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/11/2025 09:43:14' prior: 16816727!
         name: className subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe
	"Define a new class.
	If unsafe is true do not run any validation checks.
	This facility is provided to implement important system changes."
	
	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory behaviorClasses oldClassDefinition |
	
	instVars := Scanner new scanFieldNames: instVarString.
	classVars := (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].

	"Validate the proposed name"
	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].
	oldClass := Smalltalk at: className ifAbsent: nil.
	oldClass isBehavior 
		ifFalse:[oldClass := nil]. "Already checked in #validateClassName:"
	oldClassDefinition := oldClass ifNotNil: [ oldClass definition ].
	copyOfOldClass := oldClass copy.

	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].
		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].

	"See if we need a new subclass"
	needNew := self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.
	needNew ifNil: [^nil]. "some error"

	(needNew and:[unsafe not]) ifTrue:[
		"Make sure we don't redefine any dangerous classes"
		(self tooDangerousClasses includes: oldClass name) ifTrue:[
			self error: oldClass name, ' cannot be changed'.
		].
		"Check if the receiver should not be redefined"
		(oldClass notNil and:[oldClass shouldNotBeRedefined]) ifTrue:[
			self notify: oldClass name asText allBold, 
						' should not be redefined!! \Proceed to store over it.' withNewLines]].

	needNew ifTrue:[
		"Create the new class"
		newClass := self 
			newSubclassOf: newSuper 
			type: type 
			instanceVariables: instVars
			from: oldClass.
		newClass ifNil: [ ^nil]. "Some error"
		newClass setName: className.
	] ifFalse:[
		"Reuse the old class"
		newClass := oldClass.
	].

	"Install the class variables and pool dictionaries... "
	force := (newClass declareClassVarString: classVarString) | (newClass declareSharedPoolString: poolString).

	"... classify ..."
	organization := Smalltalk organization.
	newCategory := (category isNil or: [ category isEmpty ])
		ifFalse: [category withBlanksTrimmed]
		ifTrue: [organization class defaultClassCategory].
	oldClass ifNotNil: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].
	organization classify: newClass name under: newCategory.

	"... recompile ..."
	(oldClass notNil and: [oldClass includesBehavior: Behavior])
		ifTrue: [
			"This is only true for Behavior, ClassDescription, Class and Metaclass. Special treatment."
			unsafe ifFalse: [
				behaviorClasses := (oldClass withAllSubclasses select: [ :c | c isMeta not ]) asArray.
				(Processor anyReceiverInStackInstanceOfClassIn: behaviorClasses) ifTrue: [
					self error: oldClass name,' has some subInstance running some CompiledMethod.'.
					^nil ]].
			"Please see comment at this method"
			newClass := self recompileSingleRecursion: force from: oldClass to: newClass ]
		ifFalse: [
			"Other classes"
			newClass := self recompile: force from: oldClass to: newClass mutate: false ].
	newClass isNil ifTrue: [ ^nil ].

	"... export if not yet done ..."
	(Smalltalk at: newClass name ifAbsent: nil) == newClass ifFalse:[
		[Smalltalk at: newClass name put: newClass]
			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].
		Smalltalk flushClassNameCache.
	].

	self doneCompiling: newClass.
	
	"... notify interested clients ..."
	oldClass ifNil: [
		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.
		^ newClass].
	SystemChangeNotifier uniqueInstance
		classDefinitionChangedFrom: copyOfOldClass to: newClass oldClassDefinition: oldClassDefinition.
	newCategory ~= oldCategory 
		ifTrue: [SystemChangeNotifier uniqueInstance classRecategorized: newClass from: oldCategory to: newCategory ].
	^newClass! !
!ClassBuilder methodsFor: 'private' stamp: 'jmv 7/11/2025 09:43:04' prior: 16817201!
                 recordClass: oldClass replacedBy: newClass
	"Keep the changes up to date when we're moving instVars around"

	(instVarMap includesKey: oldClass name) ifTrue:[
		SystemChangeNotifier uniqueInstance
			classDefinitionChangedFrom: oldClass
			to: newClass
			oldClassDefinition: oldClass definition.
	].! !
!Class methodsFor: 'class variables' stamp: 'jmv 7/11/2025 09:42:53' prior: 16815557!
                          addClassVarName: aString
	"Add the argument, aString, as a class variable of the receiver.
	Signal an error if the first character of aString is not capitalized,
	or if it is already a variable named in the class."
	| symbol oldState oldDefinition |
	oldDefinition := self definition.
	oldState := self copy.
	aString first isLowercase
		ifTrue: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].
	symbol := aString asSymbol.
	self withAllSubclasses do: 
		[:subclass | 
		(subclass bindingOf: symbol) ifNotNil:[
			^ self error: aString 
				, ' is already used as a variable name in class ' 
				, subclass name]].
	classPool ifNil: [classPool := Dictionary new].
	(classPool includesKey: symbol) ifFalse: [
		"Pick up any refs in Undeclared"
		classPool declare: symbol from: Undeclared.
		SystemChangeNotifier uniqueInstance
			classDefinitionChangedFrom: oldState
			to: self
			oldClassDefinition: oldDefinition ].! !

SystemChangeNotifier removeSelector: #classDefinitionChangedFrom:to:!

!methodRemoval: SystemChangeNotifier #classDefinitionChangedFrom:to: stamp: 'Install-7346-classDefinitionChanged-provide-oldClass-definition-JuanVuletich-2025Jul11-09h54m-jmv.001.cs.st 7/15/2025 11:02:12'!
classDefinitionChangedFrom: oldClass to: newClass

	self
		triggerEvent: #classDefinitionChanged
		withArguments: { oldClass . newClass }!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7346-classDefinitionChanged-provide-oldClass-definition-JuanVuletich-2025Jul11-09h54m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7346] on 11 July 2025 at 5:00:08 pm'!

Refactoring subclass: #RenameInstanceVariable
	instanceVariableNames: 'oldVariable renamedReferences methodsAndRangesToChange newVariable classToRefactor originalClassToRefactor originalClassDefinition '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameInstanceVariable category: #'Tools-Refactoring' stamp: 'Install-7347-classDefinitionChanged-use-oldClassDefinition-p1-JuanVuletich-2025Jul11-16h52m-jmv.002.cs.st 7/15/2025 11:02:12'!
Refactoring subclass: #RenameInstanceVariable
	instanceVariableNames: 'oldVariable renamedReferences methodsAndRangesToChange newVariable classToRefactor originalClassToRefactor originalClassDefinition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!
!Inspector methodsFor: 'private' stamp: 'jmv 7/11/2025 16:48:11'!
      classDefinitionChangedFrom: oldClass to: newClass oldClassDefinition: oldClassDefinition

	self objectClass = newClass ifTrue: [self changed: #fieldList]! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 7/11/2025 16:39:58'!
                          noteChangeClass: class from: oldClass oldClassDefinition: oldClassDefinition
	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."

	class wantsChangeSetLogging ifFalse: [^ self].
	class isMeta 
		ifFalse: [self atClass: class add: #change]	"normal"
		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 
			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass
				is not recorded, even though it was added.  A further change is
				really just part of the original add."
			ifFalse: [self atClass: class add: #change]].
	self addCoherency: class name.
	(self changeRecorderFor: class) notePriorClassDefinition: oldClassDefinition.
	self noteClassStructure: oldClass.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'system change notifications' stamp: 'jmv 7/11/2025 16:40:32'!
                classDefinitionChangedFrom: oldClass to: newClass oldClassDefinition: oldClassDefinition

	(newClass hasChangedComparedTo: oldClass) ifTrue: [ 
		self noteChangeClass: newClass from: oldClass oldClassDefinition: oldClassDefinition ]! !
!ChangeSet class methodsFor: 'system change notifications' stamp: 'jmv 7/11/2025 16:41:58'!
                        classDefinitionChangedFrom: oldClass to: newClass oldClassDefinition: oldClassDefinition
	"In case the class is moved from one package to another, both change sets should be affected.
	But there's no need to do it here, as #classRecategorized:from:to: is also called."

	| packageOrNil |
	
	newClass wantsChangeSetLogging ifFalse: [ ^self ].
	
	packageOrNil := CodePackage packageOfClass: newClass ifNone: nil.
	(self changeSetForPackage: packageOrNil) ifNotNil: [ :changeSet |
		changeSet classDefinitionChangedFrom: oldClass to: newClass oldClassDefinition: oldClassDefinition ].
	packageOrNil ifNotNil: [
		packageOrNil hasUnsavedChanges: true ]! !
!ClassChangeRecord methodsFor: 'definition' stamp: 'jmv 7/11/2025 16:38:29'!
       notePriorClassDefinition: oldClassDefinition

	oldClassDefinition ifNil: [^ self].
	priorDefinition ifNil: [priorDefinition := oldClassDefinition]! !
!Inspector methodsFor: 'initialization' stamp: 'jmv 7/11/2025 16:56:40' prior: 16888662!
                 initializeEvents

	SystemChangeNotifier uniqueInstance
		when: #classDefinitionChanged send: #classDefinitionChangedFrom:to:oldClassDefinition: to: self! !
!RenameInstanceVariable methodsFor: 'applying - private' stamp: 'jmv 7/11/2025 16:45:42' prior: 16947922!
                          logChange
		
	Smalltalk
		logChange: classToRefactor definition 
		preamble: classToRefactor definitionPreamble.
		
	ChangeSet
		classDefinitionChangedFrom: originalClassToRefactor
		to: classToRefactor
		oldClassDefinition: originalClassDefinition.! !
!RenameInstanceVariable methodsFor: 'applying' stamp: 'jmv 7/11/2025 16:45:12' prior: 16947985 overrides: 16944602!
               apply

	originalClassDefinition := classToRefactor definition.
	originalClassToRefactor := classToRefactor copy.
	
	self 
		lookForMethodsReferencingOldVariable;
		changeInstanceVariableName;
		logChange;
		renameReferencesToOldVariable.
		
	^renamedReferences 
		! !

Refactoring subclass: #RenameInstanceVariable
	instanceVariableNames: 'oldVariable renamedReferences methodsAndRangesToChange newVariable classToRefactor originalClassToRefactor originalClassDefinition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

!classDefinition: #RenameInstanceVariable category: #'Tools-Refactoring' stamp: 'Install-7347-classDefinitionChanged-use-oldClassDefinition-p1-JuanVuletich-2025Jul11-16h52m-jmv.002.cs.st 7/15/2025 11:02:12'!
Refactoring subclass: #RenameInstanceVariable
	instanceVariableNames: 'oldVariable renamedReferences methodsAndRangesToChange newVariable classToRefactor originalClassToRefactor originalClassDefinition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Refactoring'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Inspector allSubInstancesDo: [ :i | i initializeEvents ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7347-classDefinitionChanged-use-oldClassDefinition-p1-JuanVuletich-2025Jul11-16h52m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7347] on 11 July 2025 at 5:16:26 pm'!
!ChangeSet class methodsFor: 'class initialization' stamp: 'jmv 7/11/2025 17:15:40' prior: 16809023 overrides: 16924243!
 initialize
	"
	ChangeSet initialize
	"
	AllChangeSets := OrderedCollection new.

	"Avoid double registration"
	SystemChangeNotifier uniqueInstance removeActionsWithReceiver: self.
	SystemChangeNotifier uniqueInstance
		when: #classAdded send: #classAdded:inCategory: to: self;
		when: #classCommented send: #classCommented: to: self;
		when: #classDefinitionChanged send: #classDefinitionChangedFrom:to:oldClassDefinition: to: self;
		when: #classRecategorized send: #classRecategorized:from:to: to: self;
		when: #classRemoved send: #classRemoved:fromCategory: to: self;
		when: #aboutToRenameClass send: #aboutToRenameClass:from:to:inCategory: to: self;
		when: #classReorganized send: #classReorganized: to: self;
		when: #methodAddedInProtocolTimeStamp send: #methodAdded:selector:inProtocol:class:methodTimeStamp:requestor: to: self;
		when: #methodChanged send: #methodChangedFrom:to:selector:inClass:requestor: to: self;
		when: #methodRemoved send: #methodRemoved:selector:inProtocol:class: to: self;
		when: #selectorRecategorized send: #selectorRecategorized:from:to:inClass: to: self.! !

ClassChangeRecord removeSelector: #notePriorDefinition:!

!methodRemoval: ClassChangeRecord #notePriorDefinition: stamp: 'Install-7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st 7/15/2025 11:02:12'!
notePriorDefinition: oldClass

	oldClass ifNil: [^ self].
	priorDefinition ifNil: [priorDefinition := oldClass definition]!

ChangeSet class removeSelector: #classDefinitionChangedFrom:to:!

!methodRemoval: ChangeSet class #classDefinitionChangedFrom:to: stamp: 'Install-7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st 7/15/2025 11:02:12'!
classDefinitionChangedFrom: oldClass to: newClass
	"In case the class is moved from one package to another, both change sets should be affected.
	But there's no need to do it here, as #classRecategorized:from:to: is also called."

	| packageOrNil |
	
	newClass wantsChangeSetLogging ifFalse: [ ^self ].
	
	packageOrNil := CodePackage packageOfClass: newClass ifNone: nil.
	(self changeSetForPackage: packageOrNil) ifNotNil: [ :changeSet |
		changeSet classDefinitionChangedFrom: oldClass to: newClass ].
	packageOrNil ifNotNil: [
		packageOrNil hasUnsavedChanges: true ]!

ChangeSet removeSelector: #classDefinitionChangedFrom:to:!

!methodRemoval: ChangeSet #classDefinitionChangedFrom:to: stamp: 'Install-7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st 7/15/2025 11:02:12'!
classDefinitionChangedFrom: oldClass to: newClass

	(newClass hasChangedComparedTo: oldClass) ifTrue: [ 
		self noteChangeClass: newClass from: oldClass ]!

ChangeSet removeSelector: #noteChangeClass:from:!

!methodRemoval: ChangeSet #noteChangeClass:from: stamp: 'Install-7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st 7/15/2025 11:02:12'!
noteChangeClass: class from: oldClass
	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."

	class wantsChangeSetLogging ifFalse: [^ self].
	class isMeta 
		ifFalse: [self atClass: class add: #change]	"normal"
		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 
			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass
				is not recorded, even though it was added.  A further change is
				really just part of the original add."
			ifFalse: [self atClass: class add: #change]].
	self addCoherency: class name.
	(self changeRecorderFor: class) notePriorDefinition: oldClass.
	self noteClassStructure: oldClass.
	self hasUnsavedChanges: true!

Inspector removeSelector: #classDefinitionChangedFrom:to:!

!methodRemoval: Inspector #classDefinitionChangedFrom:to: stamp: 'Install-7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st 7/15/2025 11:02:12'!
classDefinitionChangedFrom: oldClass to: newClass

	self objectClass = newClass ifTrue: [self changed: #fieldList]!

ChangeSet initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7348-classDefinitionChanged-use-oldClassDefinition-p2-JuanVuletich-2025Jul11-17h08m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7349] on 14 July 2025 at 10:55:42 am'!
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/14/2025 10:40:17' prior: 50344458!
    class: oldClass instanceVariableNames: instVarString unsafe: unsafe
	"This is the basic initialization message to change the definition of
	an existing Metaclass"
	| instVars newClass needNew copyOfOldClass oldClassDefinition |
	instVars := Scanner new scanFieldNames: instVarString.
	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].
		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].
	"See if we need a new subclass or not"
	needNew := self needsSubclassOf: oldClass superclass type: oldClass typeOfClass instanceVariables: instVars from: oldClass.
	needNew ifNil:[^nil]. "some error"
	needNew ifFalse:[^oldClass]. "no new class needed"

	"Create the new class. Include all methods from oldClass recompiled for it."
	oldClassDefinition := oldClass definition.
	copyOfOldClass := oldClass copy.
	newClass := self 
		newSubclassOf: oldClass superclass 
		type: oldClass typeOfClass
		instanceVariables: instVars
		from: oldClass.

	"Please see comment at this method. Also see other senders."
	newClass := self recompileSingleRecursion: false from: oldClass to: newClass.
	newClass isNil ifTrue: [ ^nil ].

	self doneCompiling: newClass.
	SystemChangeNotifier uniqueInstance
		classDefinitionChangedFrom: copyOfOldClass to: newClass oldClassDefinition: oldClassDefinition.
	^newClass! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/14/2025 10:39:06' prior: 50344507!
                   name: className subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe
	"Define a new class.
	If unsafe is true do not run any validation checks.
	This facility is provided to implement important system changes."
	
	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory behaviorClasses oldClassDefinition |
	
	instVars := Scanner new scanFieldNames: instVarString.
	classVars := (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].

	"Validate the proposed name"
	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].
	oldClass := Smalltalk at: className ifAbsent: nil.
	oldClass isBehavior 
		ifFalse:[oldClass := nil]. "Already checked in #validateClassName:"
	oldClassDefinition := oldClass ifNotNil: [ oldClass definition ].
	copyOfOldClass := oldClass copy.

	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].
		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].

	"See if we need a new subclass"
	needNew := self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.
	needNew ifNil: [^nil]. "some error"

	(needNew and:[unsafe not]) ifTrue:[
		"Make sure we don't redefine any dangerous classes"
		(self tooDangerousClasses includes: oldClass name) ifTrue:[
			self error: oldClass name, ' cannot be changed'.
		].
		"Check if the receiver should not be redefined"
		(oldClass notNil and:[oldClass shouldNotBeRedefined]) ifTrue:[
			self notify: oldClass name asText allBold, 
						' should not be redefined!! \Proceed to store over it.' withNewLines]].

	needNew ifTrue:[
		"Create the new class. Include all methods from oldClass recompiled for it."
		newClass := self 
			newSubclassOf: newSuper 
			type: type 
			instanceVariables: instVars
			from: oldClass.
		newClass ifNil: [ ^nil]. "Some error"
		newClass setName: className.
	] ifFalse:[
		"Reuse the old class"
		newClass := oldClass.
	].

	"Install the class variables and pool dictionaries... "
	force := (newClass declareClassVarString: classVarString) | (newClass declareSharedPoolString: poolString).

	"... classify ..."
	organization := Smalltalk organization.
	newCategory := (category isNil or: [ category isEmpty ])
		ifFalse: [category withBlanksTrimmed]
		ifTrue: [organization class defaultClassCategory].
	oldClass ifNotNil: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].
	organization classify: newClass name under: newCategory.

	"... recompile ..."
	(oldClass notNil and: [oldClass includesBehavior: Behavior])
		ifTrue: [
			"This is only true for Behavior, ClassDescription, Class and Metaclass. Special treatment."
			unsafe ifFalse: [
				behaviorClasses := (oldClass withAllSubclasses select: [ :c | c isMeta not ]) asArray.
				(Processor anyReceiverInStackInstanceOfClassIn: behaviorClasses) ifTrue: [
					self error: oldClass name,' has some subInstance running some CompiledMethod.'.
					^nil ]].
			"Please see comment at this method"
			newClass := self recompileSingleRecursion: force from: oldClass to: newClass ]
		ifFalse: [
			"Other classes"
			newClass := self recompile: force from: oldClass to: newClass mutate: false ].
	newClass isNil ifTrue: [ ^nil ].

	"... export if not yet done ..."
	(Smalltalk at: newClass name ifAbsent: nil) == newClass ifFalse:[
		[Smalltalk at: newClass name put: newClass]
			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].
		Smalltalk flushClassNameCache.
	].

	self doneCompiling: newClass.
	
	"... notify interested clients ..."
	oldClass ifNil: [
		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.
		^ newClass].
	SystemChangeNotifier uniqueInstance
		classDefinitionChangedFrom: copyOfOldClass to: newClass oldClassDefinition: oldClassDefinition.
	newCategory ~= oldCategory 
		ifTrue: [SystemChangeNotifier uniqueInstance classRecategorized: newClass from: oldCategory to: newCategory ].
	^newClass! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/14/2025 10:53:40' prior: 16816886!
                  recompile: force from: oldClass to: newClass mutate: forceMutation
	"Do the necessary recompilation after changing oldClass to newClass.
	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass
	and all its subclasses. If forceMutation is true force a mutation even
	if oldClass and newClass are the same."

	| compilationSuccess compilationErrorDescription |
	oldClass
		ifNil: [^ newClass].

	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[
		^newClass].

	currentClassIndex := 0.
	maxClassIndex := oldClass withAllSubclasses size.

	(oldClass == newClass and:[forceMutation not]) ifTrue:[
		"Recompile from newClass without mutating"
		self informUserDuring:[
			newClass withAllSubclassesDo: [ :cl |
				self showProgressFor: cl.
				cl compileAll]].
		^newClass].

	"Recompile oldClass and subclasses to newClass and subclasses.
	Recompile all the methods in the newly created classes."
	self informUserDuring: [
		compilationSuccess := true.
		[self createHierarchy: oldClass to: newClass] on: Error do: [ :exception |
			"If compilation failed, don't continue!!"
			compilationErrorDescription := exception printString.
			compilationSuccess := false ].
	].

	compilationSuccess ifFalse: [
		oldClass superclass removeSubclass: newClass.
		Smalltalk garbageCollect.
		Error signal: compilationErrorDescription, '. Please see Transcript.'.
		^ nil ].

	(newClass canUpdateFrom: oldClass) ifFalse: [
		MethodInCallStackToBecomeInvalid signal ifFalse: [
			oldClass superclass removeSubclass: newClass.
			Smalltalk garbageCollect.
			'Class reshaping aborted.' print.
			Error signal: oldClass name, 
				' has some subInstance running a CompiledMethod that would become invalid. Please see Transcript.'.
			^nil ]].

	"Make newClass thake the place of oldClass in the system: update instances and references.
	Do it for the whole hierarchy."
	self informUserDuring: [
		self mutateInstances: oldClass to: newClass.
	].
	^oldClass "now mutated to newClass"! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 7/14/2025 10:43:45' prior: 16816946!
           recompileSingleRecursion: force from: oldClass to: newClass
	"Based on #recompile:from:to:mutate:
	Older behavior of that method (before January 2022) did a single BFS on the hierarchy tree,
	creating new classes when traveling downwards, and migrating instances before returning upwards.
	This was changed to build the entire hierarchy, then validate with #canUpdateFrom: and only keep
	the new classes, and migrate instances if #canUpdateFrom: answered true.
	This breaks when recompiling the instance side of the Behavior hierarchy (Behavior, ClassDescription,
	Class and Metaclass).
	This method, appropriate for these classes does a single recursion, i.e. the pre-2022 behavior.
	It uses a more restrictive check for existing instances: It will not allow recompilation if any instance is
	executing any method, regardless of it being affected by the reshaping of the class or not. For this
	reason, for other classes, we prefer the more careful check done by #canUpdateFrom:
	
	See senders."

	(newClass == oldClass and: [force not]) ifTrue:[
		^newClass].

	currentClassIndex := 0.
	maxClassIndex := oldClass withAllSubclasses size.

	(oldClass == newClass) ifTrue: [
		"Recompile from newClass without mutating"
		self informUserDuring: [
			newClass withAllSubclassesDo: [ :cl |
				self showProgressFor: cl.
				cl compileAll ]].
		^newClass].

	"Recompile oldClass and subclasses to newClass and subclasses.
	Recompile all the methods in the newly created classes."
	self informUserDuring: [
		self mutate: oldClass to: newClass.
	].
	^oldClass "now mutated to newClass"! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'jmv 7/14/2025 10:51:45' prior: 16817510!
                    createHierarchy: oldClass to: newClass
	"Create a new class hierarchy from the old class and subclasses into newClass and subclasses.
	Recompile all the methods in the newly created classes."

	self showProgressFor: oldClass.
	"Convert the subclasses"
	oldClass subclasses do:[:oldSubclass| | newSubclass |
		"create new class. recompile all methods for it."
		newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
		self createHierarchy: oldSubclass to: newSubclass.
	].
	"And any obsolete ones"
	oldClass obsoleteSubclasses do:[:oldSubclass| | newSubclass |
		oldSubclass ifNotNil:[
			"create new class. recompile all methods for it."
			newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
			self createHierarchy: oldSubclass to: newSubclass.
		].
	].
	^newClass! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'eem 6/11/2008 16:47' prior: 16817536!
             mutate: oldClass to: newClass
	"Mutate the old class and subclasses into newClass and subclasses.
	Recompile all the methods in the newly created classes."

	self showProgressFor: oldClass.
	"Convert the subclasses"
	oldClass subclasses do:[:oldSubclass| | newSubclass |
		"create new class. recompile all methods for it."
		newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
		self mutate: oldSubclass to: newSubclass.
	].
	"And any obsolete ones"
	oldClass obsoleteSubclasses do:[:oldSubclass| | newSubclass |
		oldSubclass ifNotNil:[
			"create new class. recompile all methods for it."
			newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
			self mutate: oldSubclass to: newSubclass.
		].
	].
	"New class creation with all new methods is done.
	Make newClass thake the place of oldClass in the system: update instances and references."
	self update: oldClass to: newClass.
	^newClass! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'jmv 7/14/2025 10:54:49' prior: 50333961!
            mutateInstances: oldClass to: newClass
	"Make newClass thake the place of oldClass in the system: update instances and references.
	Do this for the whole sub hierarchy."

	self showProgressFor: oldClass.
	"Convert the subclasses"
	oldClass subclasses do: [ :oldSubclass | | newSubclass |
		newSubclass := newClass subclasses detect: [ :c | c name = oldSubclass name ]. 
		self mutateInstances: oldSubclass to: newSubclass.
	].
	"And any obsolete ones"
	oldClass obsoleteSubclasses do: [ :oldSubclass | | newSubclass |
		oldSubclass ifNotNil: [
			newSubclass := newClass subclasses detect: [ :c | c name = oldSubclass name ] ifNone: nil.
			newSubclass ifNotNil: [
				self mutateInstances: oldSubclass to: newSubclass ].
		].
	].
	"Make newClass thake the place of oldClass in the system: update instances and references."
	self update: oldClass to: newClass.
	^newClass! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7349-ClassBuilder-comments-JuanVuletich-2025Jul14-10h24m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7349] on 14 July 2025 at 11:24:46 am'!
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 7/14/2025 11:23:58' prior: 50344745!
                 noteChangeClass: class from: oldClass oldClassDefinition: oldClassDefinition
	"Remember that a class definition has been changed.  Record the original structure, so that a conversion method can be built."

	class wantsChangeSetLogging ifFalse: [^ self].
	class isMeta 
		ifFalse: [self atClass: class add: #change]	"normal"
		ifTrue: [((self classChangeAt: class theNonMetaClass name) includes: #add) 
			ifTrue: [self atClass: class add: #add] 	"When a class is defined, the metaclass
				is not recorded, even though it was added.  A further change is
				really just part of the original add."
			ifFalse: [self atClass: class add: #change]].
	self addCoherency: class name.
	(self changeRecorderFor: class) notePriorClassDefinition: oldClassDefinition.
	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'change logging' stamp: 'jmv 7/14/2025 11:24:07' prior: 50334984!
                 noteRenameClass: class as: newName 
	"Include indication that a class has been renamed."

	| recorder |
	(recorder := self changeRecorderFor: class)
		noteChangeType: #rename;
		noteNewName: newName asSymbol.
		
	"store under new name (metaclass too)"
	changeRecords at: newName put: recorder.
	changeRecords removeKey: class name.

	recorder := changeRecords at: class class name ifAbsent: nil.
	recorder ifNotNil: [
		changeRecords at: (newName, ' class') put: recorder.
		changeRecords removeKey: class class name.
		recorder noteNewName: newName , ' class' ].

	self hasUnsavedChanges: true! !
!ChangeSet methodsFor: 'moving changes' stamp: 'jmv 7/14/2025 11:23:19' prior: 16808272!
                 removeClassChanges: classOrClassName
	"Remove all memory of changes associated with this class"
	| cname |
	cname := classOrClassName isString
		ifTrue: [ classOrClassName ]
		ifFalse: [ classOrClassName name ].

	changeRecords removeKey: cname ifAbsent: nil.! !

ChangeSet removeSelector: #askAddedInstVars:!

!methodRemoval: ChangeSet #askAddedInstVars: stamp: 'Install-7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st 7/15/2025 11:02:12'!
askAddedInstVars: classList
	| pairList pairClasses index pls |
	"Ask the author whether these newly added inst vars need to be non-nil"

	pairList := OrderedCollection new.
	pairClasses := OrderedCollection new.
	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."
	classList do: [ :cls |
		| newStruct oldStruct |
		newStruct := (cls allInstVarNames).
		oldStruct := (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.
		newStruct do: [ :instVarName |
			(oldStruct includes: instVarName) ifFalse: [
				pairList add: cls name, ' ', instVarName.
				pairClasses add: cls]]].

	pairList isEmpty ifTrue: [^ #()].
	[
		index := PopUpMenu withCaption: 'These instance variables were added.
When an old project comes in, newly added 
instance variables will have the value nil.
Click on items to remove them from the list.
Click on any for which nil is an OK value.'
			chooseFrom: pairList, #('all of these need a non-nil value'
						'all of these are OK with a nil value').
		(index <= (pls := pairList size)) & (index > 0) ifTrue: [
			pairList removeAt: index.
			pairClasses removeAt: index].
		index = (pls + 2) ifTrue: ["all are OK" ^ #()].
		pairList isEmpty | (index = (pls + 1)) "all need conversion, exit"] whileFalse.

	^ pairClasses asSet asArray	"non redundant"!

ChangeSet removeSelector: #askRemovedInstVars:!

!methodRemoval: ChangeSet #askRemovedInstVars: stamp: 'Install-7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st 7/15/2025 11:02:12'!
askRemovedInstVars: classList
	| pairList pairClasses index pls |
	"Ask the author whether these newly removed inst vars need to have their info saved"

	pairList := OrderedCollection new.
	pairClasses := OrderedCollection new.
	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."
	classList do: [ :cls |
		| newStruct oldStruct |
		newStruct := (cls allInstVarNames).
		oldStruct := (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.
		oldStruct do: [:instVarName |
			(newStruct includes: instVarName) ifFalse: [
				pairList add: cls name, ' ', instVarName.
				pairClasses add: cls]]].

	pairList isEmpty ifTrue: [^ #()].
	[
		index := PopUpMenu withCaption: 'These instance variables were removed.
When an old project comes in, instance variables 
that have been removed will lose their contents.
Click on items to remove them from the list.
Click on any whose value is unimportant and need not be saved.'
			chooseFrom: pairList, #('all of these need a conversion method'
						'all of these have old values that can be erased').
		(index <= (pls := pairList size)) & (index > 0) ifTrue: [
			pairList removeAt: index.
			pairClasses removeAt: index].
		index = (pls + 2) ifTrue: ["all are OK" ^ #()].
		pairList isEmpty | (index = (pls + 1))  "all need conversion, exit"] whileFalse.

	^ pairClasses asSet asArray	"non redundant"!

ChangeSet removeSelector: #askRenames:addTo:using:!

!methodRemoval: ChangeSet #askRenames:addTo:using: stamp: 'Install-7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st 7/15/2025 11:02:12'!
askRenames: renamed addTo: msgSet using: smart
	| list |
	"Go through the renamed classes.  Ask the user if it could be in a project.  Add a method in SmartRefStream, and a conversion method in the new class."

	list := OrderedCollection new.
	renamed do: [ :cls | | rec |
		rec := changeRecords at: cls name.
		rec priorName ifNotNil: [
			| ans |
			ans := PopUpMenu withCaption: 'You renamed class ', rec priorName, 
				' to be ', rec thisName,
				'.\Could an instance of ', rec priorName, 
				' be in a project on someone''s disk?'
			chooseFrom: #('Yes, write code to convert those instances'
				'No, no instances are in projects').
			ans = 1 ifTrue: [
				| oldStruct newStruct  |
				oldStruct := structures at: rec priorName ifAbsent: nil.
				newStruct := (Array with: cls classVersion), (cls allInstVarNames).
				oldStruct ifNotNil: [
					smart writeConversionMethodIn: cls fromInstVars: oldStruct 
							to: newStruct renamedFrom: rec priorName.
					smart writeClassRename: cls name was: rec priorName.
					list add: cls name, ' convertToCurrentVersion:refStream:']]
			ifFalse: [structures removeKey: rec priorName ifAbsent: nil]]].
	list isEmpty ifTrue: [^ msgSet].
	msgSet messageList ifNil: [msgSet initializeMessageList: list]
		ifNotNil: [list do: [:item | msgSet addMethodReference: item]].
	^ msgSet!

ChangeSet removeSelector: #noteClassForgotten:!

!methodRemoval: ChangeSet #noteClassForgotten: stamp: 'Install-7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st 7/15/2025 11:02:12'!
noteClassForgotten: className
	"Remove from structures if class is not a superclass of some other one we are remembering"

	self hasUnsavedChanges: true.	"set the flag in any case"
	structures ifNil: [^ self].
	Smalltalk at: className ifPresent: [:cls |
		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [
			^ self]]].  "No delete"
	structures removeKey: className ifAbsent: nil!

ChangeSet removeSelector: #noteClassStructure:!

!methodRemoval: ChangeSet #noteClassStructure: stamp: 'Install-7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st 7/15/2025 11:02:12'!
noteClassStructure: aClass
	"Save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp)."

	| clsName |
	aClass ifNil: [^ self].
	structures ifNil: [structures := Dictionary new.
				superclasses := Dictionary new].
	clsName := (aClass name asLowercase beginsWith: 'anobsolete') 
		ifTrue: [(aClass name copyFrom: 11 to: aClass name size) asSymbol]
		ifFalse: [aClass name].
	(structures includesKey: clsName) ifFalse: [
		structures at: clsName put: 
			((Array with: aClass classVersion), (aClass allInstVarNames)).
		superclasses at: clsName put: aClass superclass name].
	"up the superclass chain"
	aClass superclass ifNotNil: [self noteClassStructure: aClass superclass].
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7350-Cleanup-JuanVuletich-2025Jul14-11h21m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7350] on 14 July 2025 at 12:05:16 pm'!
!EphemeronFinalizationProcess class methodsFor: 'accessing' stamp: 'jmv 7/14/2025 11:57:38'!
 mournAllPending
	"See #finalizationProcess.
	This additional implementation is only to be called one last time before snapshot / quit.
	Warning: Unlike #finalizationProcess, this run is not protected against failure in #mourn.
		Failure in #mourn will halt snapshot / quit"

	self primitiveFetchMourner ifNotNil: [ :firstMourner |
		self mournLoopWith: firstMourner ].! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 7/14/2025 11:42:57' prior: 16974753!
         quit
	"Just quit. No questions asked. No validations done.
	Smalltalk quit.
	"

	(SourceFiles at: 2) ifNotNil: [ :changes |
		ChangesInitialFileSize ifNotNil: [ changes truncate: ChangesInitialFileSize ]].
	"These could be moved to some #shutDown"
	self stopLowSpaceWatcher.
	ProcessorScheduler stopBackgroundProcess.

	self processShutDownList: true.
	self closeSourceFiles.

	"Be sure all unreferenced objects are finalized as approriate.
	Do this as close to the quit / snapshot primitive as possible."
	self garbageCollect.
	EphemeronFinalizationProcess ensureFinalizationComplete.
	EphemeronFinalizationProcess stopFinalizationProcess.

	"Do image save & quit as apropriate"
	self quitPrimitive.! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 7/14/2025 11:59:58' prior: 16975119!
                             snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
	"This is the main method for image save and / or quit.
	See senders."
	"WARNING: Current process will be killed. UI Process will be restarted"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic
	checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
	| activeProc |
	"If it is just about quitting, do it the simpler way."
	save not & quit ifTrue: [
		self quit.
		"Execution doesn't reach this point"
		^self.
	].
	self logSnapshot: save andQuit: quit.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each |
			each isInWorld ifTrue: [ each delete.]].
		UISupervisor ui tearDownDesktop.
		Transcript logToFile: false ].
	"These could be moved to some #shutDown"
	self stopLowSpaceWatcher.
	ProcessorScheduler stopBackgroundProcess.
	"Be sure all unreferenced objects are finalized as approriate.
	Do this again later, as close to the snapshot / quit primitive as possible."
	self garbageCollect.
	EphemeronFinalizationProcess ensureFinalizationComplete.
	EphemeronFinalizationProcess stopFinalizationProcess.
	activeProc := Processor activeProcess.
[
	| isARealStartup guiRootObject guiRootObjectClass userBaseDirectory |
	"Stuff needed to relaunch UI on startup"
	guiRootObjectClass := UISupervisor ui class.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	guiRootObject := clearAllStateFlag ifFalse: [ UISupervisor ui ].

	UISupervisor stopUIProcess.
	activeProc isTerminated ifFalse: [ activeProc terminate ].
	guiRootObject ifNotNil: [ guiRootObject releaseCachedState ].
	clearAllStateFlag ifTrue: [
		Processor processesDo: [ :p |
			(p name = 'Formerly: Morphic UI') ifTrue: [ p terminate ]]].
	MorphicCanvas allSubInstancesDo: [ :c |
		c nilState ].
	self processShutDownList: quit.

	"Clean Globals"
	userBaseDirectory := DirectoryEntry userBaseDirectory.
	self at: #Sensor put: nil.
	self closeSourceFiles.
	self at: #SourceFiles put: nil.
	self allClassesDo: [ :cls |
		cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [
		self allClassesDo: [ :cls |
			cls releaseClassState ]].
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [
		Transcript clear.
		"Enable this call to actually see the image clean report."
		false ifTrue: [self printStuffToCleanOnImageSave]].
	(Cursor cursorAt: #writeCursor) activateCursor.
	"The snapshot primitive will run a GC, but any detected Ephemeron will not be finalized, and the finalization
	queue will be cleared by the VM both in running and snapshotted image. This means they will never be finalized.
	To avoid that, just before snapshot, do a GC.
	We also need to do #mournAllPending because TheFinalizationProcess has been already stopped. "
	self garbageCollect.
	EphemeronFinalizationProcess mournAllPending.
	"Do image save & quit as apropriate"
	isARealStartup := false.
	save ifTrue: [
		"The snapshot primitive answers false if it was just called to do the snapshot.
		But image startup is resumed by returning (again) from the primitive, but this time answering true.
		nil means saving image failed"
		isARealStartup := embeddedFlag
			ifTrue: [ self snapshotEmbeddedPrimitive ]
			ifFalse: [ self snapshotPrimitive ]].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ]. "Don't quit on nil (image save failed)"

	isARealStartup == true ifFalse: [ 									"Keep current #userBaseDirectory unless a real startup"
		DirectoryEntry setUserBaseDirectory: userBaseDirectory ].

	"If starting from absolute scratch, this would be a good time to recreate Global names"
	self at: #Sensor put: nil.
	self at: #SourceFiles put: (Array new: 2).
	self logStartupDebugAid: 'To #openSourceFiles'.
	self openSourceFiles.
	"Here, startup begins!! (isARealStartup might be nil)"
	self logStartupDebugAid: 'To #initClassCachedState'.
	self allClassesDo: [ :cls | cls initClassCachedState ].
	self logStartupDebugAid: 'To #doStartUp:'.
	self doStartUp: isARealStartup == true.
	self logStartupDebugAid: 'To #spawnNewMorphicProcessFor: ', guiRootObject printString.
	UISupervisor spawnNewMorphicProcessFor: (guiRootObject ifNil: [ guiRootObject := guiRootObjectClass newWorld ]).
	isARealStartup == true
		ifTrue: [
			self logStartupDebugAid: 'To #checkIfAlreadyRunningOrStoppedNoExit'.
			self checkIfAlreadyRunningOrStoppedNoExit.
			"Some command line arguments need to be processed before starting the UI"
			self processCommandLineArguments: true.
			self assureStartupStampLogged ].
	clearAllStateFlag ifTrue: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #recreateDefaultDesktop'.
			guiRootObject recreateDefaultDesktop; restoreDisplay ]]
	ifFalse: [
		UISupervisor whenUIinSafeState: [
			self logStartupDebugAid: 'To #restoreDisplay'.
			guiRootObject restoreDisplay ]].
	"It is needed to do this at least once on MacVMs, where it may not be needed later.
	For instance #forceToScreen: is usually not called in #displayWorldOn: if running on Mac."
	Display forceToScreen.
	isARealStartup == true
		ifTrue: [
			"If system is coming up (VM and image just started)"
			UISupervisor whenUIinSafeState: [
				self logStartupDebugAid: 'To #readAndApplyUserPrefs'.
				self readAndApplyUserPrefs.
				self logStartupDebugAid: 'To #processCommandLineArguments'.
				"Some command line arguments need to be processed after the UI is up, and in the UI process"
				self processCommandLineArguments: false.
				self logStartupDebugAid: 'To #launchApp'.
				AppLauncher launchApp ]]
		ifFalse: [
			"If we are just saving the image"
			UISupervisor whenUIinSafeState: [
				self logStartupDebugAid: 'To #readAndApplyUserPrefs'.
				self readAndApplyUserPrefs ]].
	"Now it's time to raise an error"
	isARealStartup ifNil: [ self logStartupError: 'Failed to write image file (disk full?)' ]
]
	forkAt: Processor timingPriority - 1
	named: 'Startup process'.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7351-RunFinalizationBeforeSnapshotOrQuit-JuanVuletich-2025Jul14-11h42m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7351] on 14 July 2025 at 4:46:31 pm'!
!BytecodeEncoder class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 15:50:34'!
        instVarReadScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var."
	self subclassResponsibility! !
!BytecodeEncoder class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:13:10'!
                     instVarWriteScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var."
	self subclassResponsibility! !
!BytecodeEncoder class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:33:01'!
                    pushReceiverScanBlock
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for push receiver bytecode."
	self subclassResponsibility! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:11:58' overrides: 50345963!
           instVarReadScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var.
	See #genPushInstVar:
	See #genPushInstVarLong:"

	"	0-15	0000 i i i i 				Push Receiver Variable #iiii
	*	224		11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A * 256)"

	^[:b|
		(b < 16)
		or: [b = 226 ]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:27:00' overrides: 50345972!
                    instVarWriteScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var.
	See #genStoreInstVar:
	See #genStoreInstVarLong:
	See #genStorePopInstVar:
	See #genStorePopInstVarLong:"

	"	200-207	11001 iii					Pop and Store Receiver Variable #iii
	*	224			11100000	aaaaaaaa	Extend A (Ext A = Ext A prev * 256 + Ext A)
	*	240			11110000	iiiiiiii		Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)
	*	243			11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"
	| extension |
	extension := 0.
	^[:b|
		(b >= 200 and: [b < 208])
		or: [b = 240 or: [b = 243]]]! !
!EncoderForSistaV1 class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:32:57' overrides: 50345981!
pushReceiverScanBlock
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for push receiver bytecode."

	^[ :bc | bc = 76]! !
!EncoderForV3PlusClosures class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:11:13' overrides: 50345963!
             instVarReadScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var.
	See #genPushInstVar:
	See #genPushInstVarLong:"

	^[:b|
		(b < 16)
		or: [(b = 16r80 and: [scanner followingByte <= 16r3F])
		or:  [(b = 16r84 and: [scanner followingByte = 16r40])]]]! !
!EncoderForV3PlusClosures class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:24:18' overrides: 50345972!
                             instVarWriteScanBlockUsing: scanner
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for reads of any inst var.
	See #genStoreInstVar:
	See #genStoreInstVarLong:
	See #genStorePopInstVar:
	See #genStorePopInstVarLong:"

	^[:b|
		(b between: 16r60 and: 16r60 + 7)
		or: [(b = 16r81 and: [scanner followingByte <= 16r3F])
		or: [(b = 16r82 and: [scanner followingByte <= 16r3F])
		or: [(b = 16r84 and: [scanner followingByte = 160])
		or: [(b = 16r84 and: [scanner followingByte = 192])]]]]]! !
!EncoderForV3PlusClosures class methodsFor: 'compiled method support' stamp: 'jmv 7/14/2025 16:32:34' overrides: 50345981!
                           pushReceiverScanBlock
	"Answer a block argument for InstructionStream>>scanFor: that answers true
	 for push receiver bytecode."

	^[ :bc | bc = 112]! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 7/14/2025 16:35:05'!
  pushesSelf
	"Answer whether the receiver pushes self to send a message or pass as argument."
	| myMethod scanner end |
	myMethod := self method.
	scanner := InstructionStream new method: myMethod pc: startpc.
	end := self endpc.
	scanner scanFor: [ :byte |
		((myMethod encoderClass pushReceiverScanBlock)
			value: byte)
				or: [scanner pc > end]].
	^scanner pc <= end! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 7/14/2025 16:29:06'!
     readsReceiverIvar
	"Answer whether the receiver reads an instance variable of 'self'."
	| myMethod scanner end |
	myMethod := self method.
	scanner := InstructionStream new method: myMethod pc: startpc.
	end := self endpc.
	scanner scanFor: [ :byte |
		((myMethod encoderClass instVarReadScanBlockUsing: scanner)
			value: byte)
				or: [scanner pc > end]].
	^scanner pc <= end! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 7/14/2025 16:29:23'!
                              writesReceiverIvar
	"Answer whether the receiver writes an instance variable of 'self'."
	| myMethod scanner end |
	myMethod := self method.
	scanner := InstructionStream new method: myMethod pc: startpc.
	end := self endpc.
	scanner scanFor: [ :byte |
		((myMethod encoderClass instVarWriteScanBlockUsing: scanner)
			value: byte)
				or: [scanner pc > end]].
	^scanner pc <= end! !
!BlockClosure methodsFor: 'testing' stamp: 'jmv 7/14/2025 16:44:44' prior: 16794118!
           isCleanClosure
	"A clean closure is one that doesn't really need the home context because:
		- It doesn't send messages to self or super
		- It doesn't use self in any way
		- It doesn't access any instance variable
		- It doesn't access any outer temp
		- It doesn't do ^ return (Non local return, return from method to caller)
	Therefore it doesn't close over a lexical scope, and in this sense they are trivial.
	They can also be called 'context free' or 'simple' block.
	"

	| recreated source |
	source := self decompile decompileString.

	"This catches any acess to outer context!!"
	recreated := [ Compiler evaluate: source. ] on: UndeclaredVariableWarning do: [ :ex | ex return].
	recreated isNil ifTrue: [^false].
	
	recreated hasNonLocalReturn ifTrue: [ ^false ].
	recreated sendsToSuper ifTrue: [ ^false ].
	recreated pushesSelf ifTrue: [ ^false ].
	recreated readsReceiverIvar ifTrue: [ ^false ].
	recreated writesReceiverIvar ifTrue: [ ^false ].

	"Ok."
	^true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7352-SistaCompatibility-isCleanClosure-JuanVuletich-2025Jul14-16h42m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7351] on 14 July 2025 at 4:59:03 pm'!
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 7/14/2025 16:57:14' prior: 50343145!
 annotationForSelector: aSelector ofClass: aClass
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	| method |
	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	method := aClass compiledMethodAt: aSelector ifAbsent: nil.
	^ String streamContents: [ :strm |
		(Preferences at: #methodAnnotations)
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp := self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						method notNil ifTrue: [
							strm
								print: method linesOfCode;
								nextPutAll: ' lines of code' ]].
					[#messageSendsCount] -> [
						method notNil ifTrue: [
							strm
								print: method messageSendsCount;
								nextPutAll: ' message sends' ]].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount := Smalltalk numberOfSendersOf: aSelector.
						sendersCount := sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount := Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount := implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp := VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						method notNil ifTrue: [
							(CodePackage packageOfMethod: method methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList := (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ].
		(method notNil and: [method hasBreakpoint]) ifTrue: [
			strm nextPutAll: self annotationSeparator.
			strm nextPutAll: '[Breakpoint]' ]
	].! !

PseudoClass removeSelector: #closuresInfoAt:!

!methodRemoval: PseudoClass #closuresInfoAt: stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
closuresInfoAt: selector
	^''!

SystemDictionary removeSelector: #eliotsClosureMeasurements2!

!methodRemoval: SystemDictionary #eliotsClosureMeasurements2 stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
eliotsClosureMeasurements2
	"
	Smalltalk eliotsClosureMeasurements2
	"
	| numMethods numMethodsWithClosure numMethodsWithIndirectTemps anyClosureDoesNonLocalReturnCount anyClosureUsesSelfCount bothCount onlyCleanBlocksCount anyClosureHasCopiedCount |

	numMethods := numMethodsWithClosure := numMethodsWithIndirectTemps :=
	anyClosureDoesNonLocalReturnCount := anyClosureUsesSelfCount := bothCount := onlyCleanBlocksCount := 0.
	anyClosureHasCopiedCount := 0.
	self allSelect: [ :m | 
		self eliotsClosureMeasurementsOn: m over: [ :closuresCount :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
			numMethods := numMethods + 1.
			closuresCount > 0 ifTrue: [ numMethodsWithClosure := numMethodsWithClosure + 1 ].
			hasIndirectTemps ifTrue: [ numMethodsWithIndirectTemps := numMethodsWithIndirectTemps + 1].
			anyClosureDoesNonLocalReturn ifTrue: [ anyClosureDoesNonLocalReturnCount := anyClosureDoesNonLocalReturnCount + 1].
			anyClosureUsesSelf ifTrue: [ anyClosureUsesSelfCount := anyClosureUsesSelfCount + 1].
			(anyClosureDoesNonLocalReturn and: [anyClosureUsesSelf]) ifTrue: [ bothCount := bothCount + 1].
			closuresCount > 0 ifTrue: [
				(anyClosureDoesNonLocalReturn or: [anyClosureUsesSelf or: [anyClosureHasCopied]]) ifFalse: [
					onlyCleanBlocksCount := onlyCleanBlocksCount + 1]].
			anyClosureHasCopied ifTrue: [ anyClosureHasCopiedCount := anyClosureHasCopiedCount + 1 ].
			false.
		]
	].
	^{
		{'Methods'. numMethods}. {'MethodsWithClosure'. numMethodsWithClosure}. 
		{'WithClosuresAccessingOuterTemps'. anyClosureHasCopiedCount}.
		{'WithClosuresWritingOuterTemps'. numMethodsWithIndirectTemps}.
		{'WithNonLocalReturnsInClosures'. anyClosureDoesNonLocalReturnCount}. 
		{'WithReferencesToSelfInClosures'. anyClosureUsesSelfCount}. 
		{'BothAbove'. bothCount}.
		{'WithOnlyCleanClosures'. onlyCleanBlocksCount}.
	}!

SystemDictionary removeSelector: #eliotsClosureMeasurements!

!methodRemoval: SystemDictionary #eliotsClosureMeasurements stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
eliotsClosureMeasurements
	"
	Smalltalk eliotsClosureMeasurements
	From http://www.mirandabanda.org/cogblog/2008/11/14/mechanised-modifications-and-miscellaneous-measurements/
	by Eliot Miranda
	"
      | numMethods numMethodsWithClosure numMethodsWithIndirectTemps
         numClosures numClosuresWithCopiedValues numCopiedValuesForClosure
         numRemoteTemps numScopesWithRemoteTemps
         nonLocalReturnsInClosure closureUsesSelfs nonLocalReturnAndUsesSelfs numClean |

        numMethods := numMethodsWithClosure := numMethodsWithIndirectTemps :=
        numClosures := numClosuresWithCopiedValues := numCopiedValuesForClosure :=
        numRemoteTemps := numScopesWithRemoteTemps :=
        nonLocalReturnsInClosure := closureUsesSelfs := nonLocalReturnAndUsesSelfs := numClean := 0.
        self allSelect: [ :m |
                 | s hasClosure hasIndirectTemps blkPc blkSz doesNonLocalReturn usesSelf hasCopied sel |
                 sel := false.
                 hasClosure := hasIndirectTemps := false.
                 s := InstructionStream on: m.
                 s scanFor:
                          [:b|
                          b = 143 "closure creation" ifTrue:
                                   [hasClosure := true.
                                   numClosures := numClosures + 1.
                                   s followingByte >= 16 ifTrue:
                                            [numClosuresWithCopiedValues := numClosuresWithCopiedValues + 1.
                                             numCopiedValuesForClosure := numCopiedValuesForClosure + (s followingByte >> 4)]].
                          (b = 138 "indirect temp vector creation"
                           and: [s followingByte <= 127]) ifTrue:
                                   [hasIndirectTemps := true.
                                    numScopesWithRemoteTemps := numScopesWithRemoteTemps + 1.
                                    numRemoteTemps := numRemoteTemps + s followingByte].
                          false].
                 numMethods := numMethods + 1.
                 hasClosure ifTrue:
                          [numMethodsWithClosure := numMethodsWithClosure + 1.
                           s pc: m initialPC; scanFor: [:b| b = 143].

"jmv-This looks like the correct place to do this"
                           hasCopied := s followingByte >= 16.

                           blkSz := s interpretNextInstructionFor: BlockStartLocator new.
                           blkPc := s pc.
                           doesNonLocalReturn := usesSelf := false.

"jmv-Doing this here looks like a bug. See the other comment"
                           hasCopied := s followingByte >= 16.

"jmv-Another bug. This only considers the first closure (and any nested closure in it), but not later ones"

                           s scanFor:
                                   [:b|
                                   s pc >= (blkPc + blkSz)
                                            ifTrue: [true]
                                            ifFalse:
                                                     [doesNonLocalReturn := doesNonLocalReturn or: [s willReturn and: [s willBlockReturn not]].
                                                      usesSelf := usesSelf or: [b = 112 "pushSelf"
                                                                                                  or: [b < 16 "pushInstVar"
                                                                                                  or: [(b = 128 and: [s followingByte <= 63]) "pushInstVar"
                                                                                                  or: [(b between: 96 and: 96 + 7) "storePopInstVar"
                                                                                                  or: [(b = 130 and: [s followingByte <= 63]) "storePopInstVar"
                                                                                                  or: [(b = 129 and: [s followingByte <= 63]) "storeInstVar"
                                                                                                  or: [b = 132 and: [s followingByte = 160]]]]]]]].
                                                     false]].
                           doesNonLocalReturn ifTrue:
                                   [nonLocalReturnsInClosure := nonLocalReturnsInClosure + 1].
                           usesSelf ifTrue:
                                   [closureUsesSelfs := closureUsesSelfs + 1].
                           (doesNonLocalReturn and: [usesSelf]) ifTrue:
                                   [nonLocalReturnAndUsesSelfs := nonLocalReturnAndUsesSelfs + 1].
                           (doesNonLocalReturn or: [usesSelf or: [hasCopied]]) ifFalse:
                                   [numClean := numClean + 1]].
                 hasIndirectTemps ifTrue: [numMethodsWithIndirectTemps := numMethodsWithIndirectTemps + 1].
                 sel].
^        { {'Methods'. numMethods}. {'MethodsWithClosure'. numMethodsWithClosure}. {'MethodsWithIndirectTemps'. numMethodsWithIndirectTemps}.
         {'Closures'. numClosures}. {'CopiedValuesForClosures'. numCopiedValuesForClosure}. {'ClosuresWithCopiedValues'. numClosuresWithCopiedValues}.
         {'RemoteTemps'. numRemoteTemps}. {'ScopesWithRemoteTemps'. numScopesWithRemoteTemps}.
         {'MethodsWithNonLocalReturnsInClosures'. nonLocalReturnsInClosure}. {'MethodsWithReferencesToSelfInClosures'. closureUsesSelfs}. {'Both'. nonLocalReturnAndUsesSelfs}.
         {'MethodsWithOnlyCleanClosures'. numClean} }!

SystemDictionary removeSelector: #browseMethodsWithOnlyCleanClosures!

!methodRemoval: SystemDictionary #browseMethodsWithOnlyCleanClosures stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
browseMethodsWithOnlyCleanClosures
	"
	Smalltalk browseMethodsWithOnlyCleanClosures
	"
	self
		browseMessageList: (
			self allSelect: [ :m | 
				self eliotsClosureMeasurementsOn: m over: [ :closuresCount
						:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
					closuresCount > 0 and: [
						(anyClosureHasCopied or: [ anyClosureDoesNonLocalReturn or: [ anyClosureUsesSelf ]]) not ].
				]
			])
		name: 'Methods with only Clean Closures'!

SystemDictionary removeSelector: #browseMethodsWithClosuresThatOnlyReadOuterTemps!

!methodRemoval: SystemDictionary #browseMethodsWithClosuresThatOnlyReadOuterTemps stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
browseMethodsWithClosuresThatOnlyReadOuterTemps
	"
	Smalltalk browseMethodsWithClosuresThatOnlyReadOuterTemps
	"

	self
		browseMessageList: (self allSelect: [ :m | 
			self eliotsClosureMeasurementsOn: m over: [ :closuresCount
					:hasIndirectTemps :anyClosureHasCopiedValues :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				anyClosureHasCopiedValues & hasIndirectTemps not].
			])
		name: 'Closures that read but not write to outer temps'!

SystemDictionary removeSelector: #browseMethodsWithClosuresThatAccessOuterTemps!

!methodRemoval: SystemDictionary #browseMethodsWithClosuresThatAccessOuterTemps stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
browseMethodsWithClosuresThatAccessOuterTemps
	"
	Smalltalk browseMethodsWithClosuresThatAccessOuterTemps
	"

	self
		browseMessageList: (self allSelect: [ :m | 
			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 
					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				anyClosureHasCopied ].
			])
		name: 'Closures that read or write to outer temps'!

SystemDictionary removeSelector: #eliotsClosureMeasurements2On:!

!methodRemoval: SystemDictionary #eliotsClosureMeasurements2On: stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
eliotsClosureMeasurements2On: aMethod
	"
	A Couple of Clean Closures
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01Argument
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01LocalTemp
	
	Closures reading and writing to outer temps
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTemp
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempWithAssignment

	Closure doing an method return
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01UpArrowReturn

	Closures sending messages to self & super
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01SelfSend
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01SuperSend

	A couple of non-closures, i.e. blocks that are optimized by the compiler and a closure is never created
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempOptimized
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempOptimizedWithAssignment
	
	A remote temp whose declaration can not be moved inside the block
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempCantBeMovedInside
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempAssignedTwice
	A remote temp whose declaration can be moved inside the block
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01RemoteTempCanBeMovedInside
	A not-so remote temp. The declaration was moved inside the block, making it a clean block
	Smalltalk eliotsClosureMeasurements2On: PlayingWithClosures class >> #exp01LocalTemp
	"
	| numMethods numMethodsWithClosure numMethodsWithIndirectTemps anyClosureDoesNonLocalReturnCount anyClosureUsesSelfCount bothCount onlyCleanBlocksCount anyClosureHasCopiedCount |

	numMethods := numMethodsWithClosure := numMethodsWithIndirectTemps :=
	anyClosureDoesNonLocalReturnCount := anyClosureUsesSelfCount := bothCount := onlyCleanBlocksCount := 0.
	anyClosureHasCopiedCount := 0.
	self eliotsClosureMeasurementsOn: aMethod over: [ :closuresCount :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
		numMethods := numMethods + 1.
		closuresCount > 0 ifTrue: [ numMethodsWithClosure := numMethodsWithClosure + 1 ].
		hasIndirectTemps ifTrue: [ numMethodsWithIndirectTemps := numMethodsWithIndirectTemps + 1].
		anyClosureDoesNonLocalReturn ifTrue: [ anyClosureDoesNonLocalReturnCount := anyClosureDoesNonLocalReturnCount + 1].
		anyClosureUsesSelf ifTrue: [ anyClosureUsesSelfCount := anyClosureUsesSelfCount + 1].
		(anyClosureDoesNonLocalReturn and: [anyClosureUsesSelf]) ifTrue: [ bothCount := bothCount + 1].
		closuresCount > 0 ifTrue: [
			(anyClosureDoesNonLocalReturn or: [anyClosureUsesSelf or: [anyClosureHasCopied]]) ifFalse: [
				onlyCleanBlocksCount := onlyCleanBlocksCount + 1]].
		anyClosureHasCopied ifTrue: [ anyClosureHasCopiedCount := anyClosureHasCopiedCount + 1 ].
	].
	^{
		{'Methods'. numMethods}. {'MethodsWithClosure'. numMethodsWithClosure}. 
		{'WithClosuresAccessingOuterTemps'. anyClosureHasCopiedCount}.
		{'WithClosuresWritingOuterTemps'. numMethodsWithIndirectTemps}.
		{'WithNonLocalReturnsInClosures'. anyClosureDoesNonLocalReturnCount}. 
		{'WithReferencesToSelfInClosures'. anyClosureUsesSelfCount}. 
		{'BothAbove'. bothCount}.
		{'WithOnlyCleanClosures'. onlyCleanBlocksCount}.
	}!

SystemDictionary removeSelector: #closuresInfoStringForClass:selector:!

!methodRemoval: SystemDictionary #closuresInfoStringForClass:selector: stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
closuresInfoStringForClass: aClass selector: aSelector
	"
	Smalltalk closuresInfoStringFor: PlayingWithClosures class >> #exp01Argument
	"
	| answer all someDo noneDoes method |
	method := aClass compiledMethodAt: aSelector ifAbsent: [ ^'' ].
	self eliotsClosureMeasurementsOn: method over: [ 
				:closuresCount :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
			
		closuresCount > 0
			ifFalse: [ answer := 'No real (non-optimized) Closures' ]
			ifTrue: [
				closuresCount = 1
					ifTrue: [
						answer := '1 Closure: '.
						all := ''.
						someDo := 'does'. 
						noneDoes := 'does not' ]
					ifFalse: [
						answer := closuresCount printString, ' Closures: '.
						all := 'all '.
						someDo := 'some do'. 
						noneDoes := 'none does' ].
				(anyClosureHasCopied or: [ anyClosureDoesNonLocalReturn or: [ anyClosureUsesSelf ]])
					ifFalse: [ answer := answer, all, 'clean' ]
					ifTrue: [
						answer := answer, (anyClosureHasCopied
							ifTrue: [
								hasIndirectTemps
									ifTrue: [ someDo, ' write (and maybe ', someDo, ' read)' ]
									ifFalse: [ someDo, ' read (but ', noneDoes, ' write)' ] ]
							ifFalse: [ noneDoes, ' access' ]), ' outer temps; '.
						answer := answer, (anyClosureDoesNonLocalReturn
							ifTrue: [ someDo ]
							ifFalse: [ noneDoes ]), ' ^return; '.
						answer := answer, (anyClosureUsesSelf
							ifTrue: [ someDo ]
							ifFalse: [ noneDoes ]), ' use self'
					].
			]
		].
		^answer!

SystemDictionary removeSelector: #browseMethodsWithMoreThanOneClosure!

!methodRemoval: SystemDictionary #browseMethodsWithMoreThanOneClosure stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
browseMethodsWithMoreThanOneClosure
	"
	Smalltalk browseMethodsWithMoreThanOneClosure
	"

	self
		browseMessageList: (self allSelect: [ :m | 
			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 
					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				closuresCount > 1 ].
			])
		name: 'Methods with more than one Closure'!

SystemDictionary removeSelector: #eliotsClosureMeasurementsOn:over:!

!methodRemoval: SystemDictionary #eliotsClosureMeasurementsOn:over: stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
eliotsClosureMeasurementsOn: m over: aFiveArgBlock
	"
	See senders.
	Or try something like:
		Smalltalk
			eliotsClosureMeasurementsOn: FileList >> #defaultContents
			over: [ :closuresCount :hasCopiedValuesForClosure :hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				(Array with: closuresCount with: hasCopiedValuesForClosure with: hasIndirectTemps with: anyClosureHasCopied with: anyClosureDoesNonLocalReturn with: anyClosureUsesSelf)]

	From http://www.mirandabanda.org/cogblog/2008/11/14/mechanised-modifications-and-miscellaneous-measurements/
	by Eliot Miranda
	
	Note: This could perhaps be refactored to use the newer #embeddedBlockClosures and testing methods on the closures themselves.
	"
	| s nextScanStart thisClosureHasCopied closuresCount hasIndirectTemps blkPc blkSz anyClosureHasCopied anyClosureDoesNonLocalReturn anyClosureUsesSelf analyzedClosures |
	closuresCount := 0.
	hasIndirectTemps := false.
	anyClosureHasCopied :=  anyClosureDoesNonLocalReturn := anyClosureUsesSelf := false.
	s := InstructionStream on: m.
	s scanFor: [ :b |
		b = 16r8F "16r8F = 143 closure creation" ifTrue: [
			closuresCount := closuresCount + 1].
		(b = 16r8A "16r8A = 138indirect temp vector creation" and: [ s followingByte <= 127]) ifTrue: [
				hasIndirectTemps := true].
		false].
	nextScanStart := m initialPC.
	analyzedClosures := 0.
	[ analyzedClosures < closuresCount ] whileTrue: [
		s pc: nextScanStart; scanFor: [ :b | b = 16r8F ].	"16r8F = 143 Search for first closure"
		analyzedClosures := analyzedClosures + 1.
		thisClosureHasCopied := s followingByte >= 16r10.
		anyClosureHasCopied := anyClosureHasCopied | thisClosureHasCopied.
		blkSz := s interpretNextInstructionFor: BlockStartLocator new.		"Findout size of first closure"
		blkPc := s pc.
		s scanFor: [ :b |
			s pc >= (blkPc + blkSz)
				ifTrue: [
					nextScanStart := s pc.
					true]
				ifFalse: [
					b = 16r8F ifTrue: [			
						thisClosureHasCopied := s followingByte >= 16r10.
						anyClosureHasCopied := anyClosureHasCopied | thisClosureHasCopied.
						analyzedClosures := analyzedClosures + 1 ].
					anyClosureDoesNonLocalReturn := anyClosureDoesNonLocalReturn or: [s willReturn and: [s willBlockReturn not]].
					anyClosureUsesSelf := anyClosureUsesSelf or: [b = 16r70 "pushSelf"
										or: [b < 16r10 "pushInstVar"
										or: [(b = 16r80 and: [s followingByte <= 16r3F]) "pushInstVar"
										or: [(b between: 16r60 and: 16r60 + 7) "storePopInstVar"
										or: [(b = 16r82 and: [s followingByte <= 63]) "storePopInstVar"
										or: [(b = 16r81 and: [s followingByte <= 63]) "storeInstVar"
										or: [b = 16r84 and: [s followingByte = 160]]]]]]]].
					false]]].
	^aFiveArgBlock valueWithArguments: (Array
			with: closuresCount
			with: hasIndirectTemps
			with: anyClosureHasCopied
			with: anyClosureDoesNonLocalReturn
			with: anyClosureUsesSelf)!

SystemDictionary removeSelector: #browseMethodsWithClosuresThatWriteOuterTemps!

!methodRemoval: SystemDictionary #browseMethodsWithClosuresThatWriteOuterTemps stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
browseMethodsWithClosuresThatWriteOuterTemps
	"
	Smalltalk browseMethodsWithClosuresThatWriteOuterTemps
	"

	self
		browseMessageList: (self allSelect: [ :m | 
			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 
					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				hasIndirectTemps ].
			])
		name: ' Closures that write to outer temps'!

SystemDictionary removeSelector: #browseMethodsWithClosuresThatWriteOuterTempsButCleanOtherwise!

!methodRemoval: SystemDictionary #browseMethodsWithClosuresThatWriteOuterTempsButCleanOtherwise stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
browseMethodsWithClosuresThatWriteOuterTempsButCleanOtherwise
	"
	Smalltalk browseMethodsWithClosuresThatWriteOuterTempsButCleanOtherwise
	"

	self
		browseMessageList: (self allSelect: [ :m | 
			self eliotsClosureMeasurementsOn: m over: [ :closuresCount 
					:hasIndirectTemps :anyClosureHasCopied :anyClosureDoesNonLocalReturn :anyClosureUsesSelf |
				hasIndirectTemps and: [  anyClosureDoesNonLocalReturn not and: [ anyClosureUsesSelf not ] ] ].
			])
		name: ' Closures that write to outer temps, but clean otherwise'!

Behavior removeSelector: #closuresInfoAt:!

!methodRemoval: Behavior #closuresInfoAt: stamp: 'Install-7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st 7/15/2025 11:02:12'!
closuresInfoAt: selector
	^Smalltalk closuresInfoStringForClass: self selector: selector!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7353-Cleanup-JuanVuletich-2025Jul14-16h46m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7353] on 15 July 2025 at 10:14:27 am'!
!BytecodeEncoder methodsFor: 'testing' stamp: 'jmv 7/15/2025 10:10:03'!
                            hasLocalNamed: aName

	^ scopeTable includesKey: aName ! !

EncoderForV3PlusClosures removeSelector: #hasLocalNamed:!

!methodRemoval: EncoderForV3PlusClosures #hasLocalNamed: stamp: 'Install-7354-hasLocalNamed-moveUp-JuanVuletich-2025Jul15-10h14m-jmv.001.cs.st 7/15/2025 11:02:12'!
hasLocalNamed: aName

	^ scopeTable includesKey: aName !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7354-hasLocalNamed-moveUp-JuanVuletich-2025Jul15-10h14m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7353] on 15 July 2025 at 10:15:30 am'!
!WorldMorph methodsFor: 'initialization' stamp: 'jmv 7/15/2025 09:11:32'!
                        initSortBlocks

	stepList := Heap sortBlock: self stepListSortBlock.
	alarms := Heap sortBlock: self alarmSortBlock.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7355-World-initSortBlocks-JuanVuletich-2025Jul15-10h14m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7353] on 15 July 2025 at 10:14:53 am'!
!CompiledMethod class methodsFor: 'preferences' stamp: 'jmv 7/15/2025 09:50:34'!
             useSistaBytecodes
	"
	CompiledMethod useSistaBytecodes.

		| nPrimary nSecondary |
		nPrimary := nSecondary := 0.
		self allSubInstancesDo:
			[:cm|
			cm header >= 0
				ifTrue: [nPrimary := nPrimary + 1]
				ifFalse: [nSecondary := nSecondary + 1]].
		{nPrimary. nSecondary} print
	"
	self preferredBytecodeSetEncoderClass: EncoderForSistaV1.
	Compiler recompileAll.
	ProcessorScheduler startUp.
	Delay startTimerEventLoop.
	EphemeronFinalizationProcess restartFinalizationProcess.
	Sensor installInterruptWatcher.
	Sensor installEventTickler.
	UISupervisor ui ifNotNil: [ :w |
		[
			w showTaskbar.
			UISupervisor newUIProcess.
			Smalltalk garbageCollect ] fork.
		w
			initSortBlocks;
			hideTaskbar ].
	PreferenceSet installMiscPreferences.
	Smalltalk garbageCollect.! !
!CompiledMethod class methodsFor: 'preferences' stamp: 'jmv 7/15/2025 09:55:43'!
     useV3Bytecodes
	"
	CompiledMethod useV3Bytecodes.

		| nPrimary nSecondary |
		nPrimary := nSecondary := 0.
		self allSubInstancesDo:
			[:cm|
			cm header >= 0
				ifTrue: [nPrimary := nPrimary + 1]
				ifFalse: [nSecondary := nSecondary + 1]].
		{nPrimary. nSecondary} print
	"
	self preferredBytecodeSetEncoderClass: EncoderForV3PlusClosures.
	Compiler recompileAll.
	ProcessorScheduler startUp.
	Delay startTimerEventLoop.
	EphemeronFinalizationProcess restartFinalizationProcess.
	Sensor installInterruptWatcher.
	Sensor installEventTickler.
	UISupervisor ui ifNotNil: [ :w |
		[
			w showTaskbar.
			UISupervisor newUIProcess.
			Smalltalk garbageCollect ] fork.
		w
			initSortBlocks;
			hideTaskbar ].
	PreferenceSet installMiscPreferences.
	Smalltalk garbageCollect.! !
!CompiledMethod class methodsFor: 'preferences' stamp: 'jmv 7/15/2025 08:49:52' prior: 16836417!
                    preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass
	"Set the class that determines the bytecode set used to compile methods with.

		| nPrimary nSecondary |
		nPrimary := nSecondary := 0.
		self allSubInstancesDo:
			[:cm|
			cm header >= 0
				ifTrue: [nPrimary := nPrimary + 1]
				ifFalse: [nSecondary := nSecondary + 1]].
		{nPrimary. nSecondary} print
	"
	| nPrimary nSecondary |
	self assert: (aBytecodeEncoderSubclass includesBehavior: BytecodeEncoder).
	(aBytecodeEncoderSubclass == PrimaryBytecodeSetEncoderClass
	 or: [aBytecodeEncoderSubclass == SecondaryBytecodeSetEncoderClass]) ifTrue:
		[PreferredBytecodeSetEncoderClass := aBytecodeEncoderSubclass.
		 ^self].
	nPrimary := nSecondary := 0.
	self allSubInstancesDo:
		[:cm|
		 cm header >= 0
			ifTrue: [nPrimary := nPrimary + 1]
			ifFalse: [nSecondary := nSecondary + 1]].
	nPrimary = 0 ifTrue:
		[self installPrimaryBytecodeSet: aBytecodeEncoderSubclass.
		 ^self preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass].
	nSecondary = 0 ifTrue:
		[self installSecondaryBytecodeSet: aBytecodeEncoderSubclass.
		 ^self preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass].
	self error: 'Cannot set preferred bytecode set.  Both of the current sets appear to be in use.'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7356-BytecodeSet-selection-JuanVuletich-2025Jul15-10h14m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7353] on 15 July 2025 at 10:16:29 am'!

Object subclass: #MethodChangeRecord
	instanceVariableNames: 'changeType currentMethod infoFromRemoval stamp '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!classDefinition: #MethodChangeRecord category: #'Tools-Changes' stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:12'!
Object subclass: #MethodChangeRecord
	instanceVariableNames: 'changeType currentMethod infoFromRemoval stamp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!
!MethodChangeRecord commentStamp: '<historical>' prior: 16905461!
    MethodChangeRecords are used to record method changes.  Here is a simple summary of the relationship between the changeType symbol and the recording of prior state

					|	prior == nil			|	prior not nil	
	---------	|----------------------------	|--------------------
			add		|	add					|	change
	---------	|----------------------------	|--------------------
			remove	|	addedThenRemoved	|	remove

Structure:
changeType		symbol -- as summarized above
currentMethod	method
				This is the current version of the method.
				It can be used to assert this change upon entry to a layer. 
infoFromRemoval -- an array of size 2.
				The first element is the source index of the last version of the method.
				The second element is the category in which it was defined, so it
				can be put back there if re-accepted from a version browser.

Note that the above states each have an associated revoke action:
	add --> remove
	change --> change back
	remove --> add back
	addedThenRemoved --> no change
However all of these are accomplished trivially by restoring the original method dictionary.!
!ClassChangeRecord methodsFor: 'method changes' stamp: 'jmv 7/15/2025 09:02:59' prior: 16818384!
noteNewMethod: newMethod selector: selector priorMethod: methodOrNil

	| methodChange |
	methodChange := self findOrMakeMethodChangeAt: selector priorMethod: methodOrNil.
	methodOrNil
		ifNil: [ methodChange noteChangeType: #add ]
		ifNotNil: [ methodChange noteChangeType: #change ].
! !

MethodChangeRecord removeSelector: #storeDataOn:!

!methodRemoval: MethodChangeRecord #storeDataOn: stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:12'!
storeDataOn: aDataStream
	| oldMethod |
	oldMethod := currentMethod.
	currentMethod := nil.
	super storeDataOn: aDataStream.
	currentMethod := oldMethod.
!

MethodChangeRecord removeSelector: #currentMethod!

!methodRemoval: MethodChangeRecord #currentMethod stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:12'!
currentMethod

	^ currentMethod!

MethodChangeRecord removeSelector: #noteNewMethod:!

!methodRemoval: MethodChangeRecord #noteNewMethod: stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:12'!
noteNewMethod: newMethod

	currentMethod := newMethod!

ClassChangeRecord removeSelector: #compileAll:from:!

!methodRemoval: ClassChangeRecord #compileAll:from: stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:12'!
compileAll: newClass from: oldClass
	"Something about this class has changed.  Locally retained methods must be recompiled.
	NOTE:  You might think that if this changeSet is in force, then we can just note
	the new methods but a lower change set may override and be in force which
	would mean that only the overriding copies go recompiled.  Just do it."

	methodChanges associationsDo:
		[:assn | | sel changeType changeRecord newMethod |
		sel := assn key.
		changeRecord := assn value.
		changeType := changeRecord changeType.
		(changeType == #add or: [changeType == #change]) ifTrue:
			[newMethod := newClass
				recompileNonResidentMethod: changeRecord currentMethod
				atSelector: sel from: oldClass.
			changeRecord noteNewMethod: newMethod]]!

Object subclass: #MethodChangeRecord
	instanceVariableNames: 'changeType infoFromRemoval stamp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!classDefinition: #MethodChangeRecord category: #'Tools-Changes' stamp: 'Install-7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st 7/15/2025 11:02:12'!
Object subclass: #MethodChangeRecord
	instanceVariableNames: 'changeType infoFromRemoval stamp'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7357-MethodChangeRecord-cleanup-JuanVuletich-2025Jul15-10h15m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7357] on 15 July 2025 at 10:47:33 am'!
!SerializableBlockClosure methodsFor: 'initialization' stamp: 'jmv 7/15/2025 10:41:23' prior: 16957120!
                      onBlockClosure: aBlockClosure

	| both blockNode methodNode indirectTempNames sortedOuterTemps ownNames usedOuterNames sortedUsedOuterNames |
	aBlockClosure hasNonLocalReturn ifTrue: [
		self error: 'Can not serialize closures with non-local returns.' ].
	aBlockClosure sendsToSuper ifTrue: [
		self error: 'Can not currently serialize closures with super sends.' ].
'tota!!' print.
	both := SerializableClosureDecompiler new  decompileBlockAndMethod: aBlockClosure.
	blockNode := both first.
	methodNode := both second.

	indirectTempNames := methodNode temporaries
		detect: [ :node | node isIndirectTempVector ]
		ifFound: [ :node | node remoteTemps collect: [ :n | n name ]]
		ifNone: [#()].
	sortedOuterTemps := OrderedCollection new.
	aBlockClosure outerContextsDo: [ :c | c closure ifNotNil: [ :cc |
		| ccn |
		ccn := cc decompile.
		sortedOuterTemps addAll: ccn arguments; addAll: ccn temporaries ]].
	sortedOuterTemps addAll: methodNode temporaries; addAll: methodNode arguments.

	ownNames := ((blockNode arguments, blockNode temporaries)
		collect: [ :node | node name ]) asSet.
	usedOuterNames := Set new.
	blockNode nodesDo: [ :node | node isTemp ifTrue: [
		(ownNames includes: node name) | (indirectTempNames includes: node name) ifFalse: [
			usedOuterNames add: node name]]].

	sortedUsedOuterNames := sortedOuterTemps select: [ :node |
		usedOuterNames includes: node name ]. "sort them"
	sortedUsedOuterNames := sortedUsedOuterNames collect: [ :node | node name ].

	blockNode nodesDo: [ :node | node isTemp ifTrue: [ 
		node isRemote
			ifTrue: [node capturedIndex: (indirectTempNames indexOf: node name) ]
			ifFalse: [
				(sortedUsedOuterNames includes: node name)
					ifTrue: [node capturedIndex: (sortedUsedOuterNames indexOf: node name)]]]].

	theSelf := aBlockClosure receiver.
	capturedValues := aBlockClosure capturedValues.
	sourceCode := blockNode decompileString.! !

SystemDictionary removeSelector: #unusedBlocks!

!methodRemoval: SystemDictionary #unusedBlocks stamp: 'Install-7358-unusedBlocks-remove-JuanVuletich-2025Jul15-10h41m-jmv.001.cs.st 7/15/2025 11:02:12'!
unusedBlocks
	"Answer all methods that contain a block that is not used (not
	 sent a message, returned, passed as an argument, or assigned)."
	"Smalltalk unusedBlocks"
	"Smalltalk
		browseMessageList: Smalltalk unusedBlocks
		name: 'unused blocks'"
	^self allSelect:
		[:m| | is |
		is := InstructionStream on: m.
		is scanFor: [:b| b = 143 and: [(m at: is thirdByte * 256 + is fourthByte + is pc + 4) = 135]]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7358-unusedBlocks-remove-JuanVuletich-2025Jul15-10h41m-jmv.001.cs.st----!

----QUIT----(15 July 2025 11:02:19) Cuis7.5-7358.image priorSource: 197!

----STARTUP---- (22 July 2025 09:51:47) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.5-7358.image!


'From Cuis7.5 [latest update: #7358] on 15 July 2025 at 2:23:13 pm'!
!BoxMorph methodsFor: 'layout' stamp: 'jmv 7/15/2025 13:23:51' overrides: 16930414!
 minimumLayoutExtent: cachedValues
	"I combine information from a Morph and its optional LayoutSpec.
	Answer is expressed in owner's coordinates."
	| minExtent |

	^cachedValues at: self ifAbsentPut: [
		minExtent :=  self externalizeDistance: self minimumExtent.
		layoutSpec
			ifNil: [ minExtent ] 
			ifNotNil: [ :ls | minExtent max: ls minimumSpecExtent ]]! !
!PlacedMorph methodsFor: 'layout' stamp: 'jmv 7/15/2025 13:25:05' prior: 16930414 overrides: 16913180!
             minimumLayoutExtent: cachedValues
	"I combine information from a Morph and its optional LayoutSpec.
	Answer is expressed in owner's coordinates."
	| minExtent |

	^cachedValues at: self ifAbsentPut: [
		minExtent :=  self minimumExtent.
		layoutSpec
			ifNil: [ minExtent ] 
			ifNotNil: [ :ls | minExtent max: ls minimumSpecExtent ]]! !

Morph removeSelector: #minimumLayoutExtent:!

!methodRemoval: Morph #minimumLayoutExtent: stamp: 'Install-7359-minimumLayoutExtent-fix-JuanVuletich-2025Jul15-14h20m-jmv.001.cs.st 7/22/2025 09:51:47'!
minimumLayoutExtent: cachedValues
	"I combine information from a Morph and its optional LayoutSpec.
	Answer is expressed in owner's coordinates."

	^cachedValues at: self ifAbsentPut: [
		self externalizeDistance: self minimumExtent ].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7359-minimumLayoutExtent-fix-JuanVuletich-2025Jul15-14h20m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7359] on 17 July 2025 at 9:29:54 am'!
!InstructionClient methodsFor: 'instruction decoding' stamp: 'jmv 7/16/2025 11:36:04'!
                     doNop
	"Do Nothing Operation bytecode."
! !
!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'jmv 7/16/2025 11:36:44' overrides: 50347412!
        doNop
	"Print the Do Nothing Operation bytecode."
	self print: 'nop'! !
!Decompiler methodsFor: 'instruction decoding' stamp: 'jmv 7/16/2025 16:38:06'!
        doNop
	"No action needed"! !
!ContextPart methodsFor: 'instruction decoding' stamp: 'jmv 7/16/2025 16:43:49'!
                  doNop
	"Simulates the action of a 'No Operation' bytecode."! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:46:14' prior: 16855748!
                           genPushInstVar: instVarIndex
	"0-15 		0000iiii 					Push Receiver Variable #iiii
	 226		11100010	i i i i i i i i	Push Receiver Variable #iiiiiiii (+ Extend A * 256)"

	(instVarIndex < 0 or: [instVarIndex > 15]) ifTrue:
		[^self genPushInstVarLong: instVarIndex].

	 stream nextPut: 0 + instVarIndex.
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	The strategy for the Sista V1 Bytecode Set is to add a NOP (do nothing)
	byte to use two bytes in any case.
	This is good up to 255 instance variables: Use of #genUnsignedSingleExtendA: requires
	a more expensive approach."
	self genNop.! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 10:21:12' prior: 16856152!
                            genStoreInstVar: instVarIndex
	"243		11110011	iiiiiiii		Store Receiver Variable #iiiiiii (+ Extend A * 256)"

	self genStoreInstVarLong: instVarIndex.! !
!EncoderForSistaV1 methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:46:25' prior: 16856190!
genStorePopInstVar: instVarIndex
	"200-207	11001 iii				Pop and Store Receiver Variable #iii
	 240		11110000	iiiiiiii	Pop and Store Receiver Variable #iiiiiii (+ Extend A * 256)"

	(instVarIndex < 0 or: [instVarIndex > 7]) ifTrue:
		[^self genStorePopInstVarLong: instVarIndex].

	stream nextPut: 200 + instVarIndex.
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	The strategy for the Sista V1 Bytecode Set is to add a NOP (do nothing)
	byte to use two bytes in any case.
	This is good up to 255 instance variables: Use of #genUnsignedSingleExtendA: requires
	a more expensive approach."
	self genNop.! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:38:57' prior: 16857509!
    genPushInstVar: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	"
	true ifTrue: [
		^self genPushInstVarAllowForIvarsRemapping: instVarIndex ].

	"See BlueBook page 596"
	instVarIndex >= 0 ifTrue:
		[instVarIndex < 16 ifTrue:
			["0-15 	0000iiii 	Push Receiver Variable #iiii"
			 stream nextPut: 0 + instVarIndex.
			 ^self].
		instVarIndex < 64 ifTrue:
			["128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"
			 stream
				nextPut: 128;
				nextPut: instVarIndex.
			 ^self]].
	self genPushInstVarLong: instVarIndex.! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:40:51' prior: 16857533!
      genPushInstVarAllowForIvarsRemapping: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	The strategy for the V3 Bytecode Set is as follows:
		- never use the single byte bytecodes in [0..15] and [96..103]
		- Use 2 byte bytecodes 128, 129, 130 for ivar accesses up to 9 (even if they can handle up to 63)
		- Use 3 byte bytecode 132 for all ivar accesses, if ivar index >= 10
	This means that the first 10 ivars can be shifted by adding up to 54 ivars in superclasses, and
	other ivars can be shifted by adding any number of ivars in superclasses (up to the 255 ivars limit).
	This is needed for binding class shape modifying DynamicCuisLibraries, or 
	DynamicCuisLibraries built with a different class shape than the image loading them.
	The reason for using 128, 129 and 130 bytecodes for the first ivars is because the VM uses bytecode 132
	with small ivar index to indicate an access to ivars of MethodContext or ContextPart that require a more
	expensive processing. Using 128, 129 or 130 avoids this extra cost.
	This applies both to Spur Interpreter and Cog jitter.
	In the VMMaker package see #isReadMediatedContextInstVarIndex: and #isWriteMediatedContextInstVarIndex:
	The space cost of the use of these longer bytecodes is very small: about 34kb in the official Cuis image, or
	2 bytes per CompiledMethod in average.
	"

	"See BlueBook page 596"
	(instVarIndex >= 0 and: [instVarIndex < 10]) ifTrue: [
		"128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"
		 stream
			nextPut: 128;
			nextPut: instVarIndex.
		 ^self ].
	self genPushInstVarLong: instVarIndex.! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:39:16' prior: 16857938!
            genStoreInstVar: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	"
	true ifTrue: [
		^self genStoreInstVarAllowForIvarsRemapping: instVarIndex ].

	"See BlueBook page 596"
	(instVarIndex >= 0 and: [instVarIndex < 64]) ifTrue: 
		["129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"
		 stream
			nextPut: 129;
			nextPut: instVarIndex.
		 ^self].
	self genStoreInstVarLong: instVarIndex! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:40:57' prior: 16857958!
                    genStoreInstVarAllowForIvarsRemapping: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	The strategy for the V3 Bytecode Set is as follows:
		- never use the single byte bytecodes in [0..15] and [96..103]
		- Use 2 byte bytecodes 128, 129, 130 for ivar accesses up to 9 (even if they can handle up to 63)
		- Use 3 byte bytecode 132 for all ivar accesses, if ivar index >= 10
	This means that the first 10 ivars can be shifted by adding up to 54 ivars in superclasses, and
	other ivars can be shifted by adding any number of ivars in superclasses (up to the 255 ivars limit).
	This is needed for binding class shape modifying DynamicCuisLibraries, or 
	DynamicCuisLibraries built with a different class shape than the image loading them.
	The reason for using 128, 129 and 130 bytecodes for the first ivars is because the VM uses bytecode 132
	with small ivar index to indicate an access to ivars of MethodContext or ContextPart that require a more
	expensive processing. Using 128, 129 or 130 avoids this extra cost.
	This applies both to Spur Interpreter and Cog jitter.
	In the VMMaker package see #isReadMediatedContextInstVarIndex: and #isWriteMediatedContextInstVarIndex:
	The space cost of the use of these longer bytecodes is very small: about 34kb in the official Cuis image, or
	2 bytes per CompiledMethod in average.
	"

	"See BlueBook page 596"
	(instVarIndex >= 0 and: [instVarIndex < 10]) ifTrue: [
		"129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"
		 stream
			nextPut: 129;
			nextPut: instVarIndex.
		 ^self ].
	self genStoreInstVarLong: instVarIndex.! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:39:22' prior: 16858062!
                  genStorePopInstVar: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	"
	true ifTrue: [
		^self genStorePopInstVarAllowForIvarsRemapping: instVarIndex ].

	"See BlueBook page 596"
	instVarIndex >= 0 ifTrue:
		[instVarIndex < 8 ifTrue:
			["96-103 	01100iii 	Pop and Store Receiver Variable #iii"
			 stream nextPut: 96 + instVarIndex.
			 ^self].
		instVarIndex < 64 ifTrue:
			["130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"
			 stream
				nextPut: 130;
				nextPut: instVarIndex.
			 ^self]].
	self genStorePopInstVarLong: instVarIndex! !
!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'jmv 7/16/2025 11:41:01' prior: 16858087!
                 genStorePopInstVarAllowForIvarsRemapping: instVarIndex
	"Cuis Specific.
	In order of allowing the quick remapping of instance variables, leave some 'slack'.
	See
		#displaceInstVarAccessesIn:starting:by:doIt:
		#remapInstVarAccessesIn:asPer:doIt:
	The strategy for the V3 Bytecode Set is as follows:
		- never use the single byte bytecodes in [0..15] and [96..103]
		- Use 2 byte bytecodes 128, 129, 130 for ivar accesses up to 9 (even if they can handle up to 63)
		- Use 3 byte bytecode 132 for all ivar accesses, if ivar index >= 10
	This means that the first 10 ivars can be shifted by adding up to 54 ivars in superclasses, and
	other ivars can be shifted by adding any number of ivars in superclasses (up to the 255 ivars limit).
	This is needed for binding class shape modifying DynamicCuisLibraries, or 
	DynamicCuisLibraries built with a different class shape than the image loading them.
	The reason for using 128, 129 and 130 bytecodes for the first ivars is because the VM uses bytecode 132
	with small ivar index to indicate an access to ivars of MethodContext or ContextPart that require a more
	expensive processing. Using 128, 129 or 130 avoids this extra cost.
	This applies both to Spur Interpreter and Cog jitter.
	In the VMMaker package see #isReadMediatedContextInstVarIndex: and #isWriteMediatedContextInstVarIndex:
	The space cost of the use of these longer bytecodes is very small: about 34kb in the official Cuis image, or
	2 bytes per CompiledMethod in average.
	"

	"See BlueBook page 596"
	(instVarIndex >= 0 and: [instVarIndex < 10]) ifTrue: [
		"130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"
		 stream
			nextPut: 130;
			nextPut: instVarIndex.
		 ^self ].
	self genStorePopInstVarLong: instVarIndex.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7360-Sista-ShortIvarAccesses-PadWithNOP-JuanVuletich-2025Jul17-09h27m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7360] on 17 July 2025 at 9:49:14 am'!
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/17/2025 09:20:52'!
         displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvarToDisplace. Displace them by delta.
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"This initial implementation can not handle inst var indexes greater than 255.
	See #genPushInstVar: #genStoreInstVar: #genStorePopInstVar:"

	| pc end bytecode followingByte oldIvar newIvar bytecodeSize |

	"Just in case..."
	delta = 0 ifTrue: [ ^true ].
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				| primitiveCode |
				newIvar := oldIvar+delta.
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(aCompiledMethodOrMethodSpec at: pc+1) = 16r5F ifFalse: [
							aBoolean ifTrue: [self error: 'NOP padding missing'].
							^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(aCompiledMethodOrMethodSpec at: pc+1) = 16r5F ifFalse: [
							aBoolean ifTrue: [self error: 'NOP padding missing'].
							^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 > end ifTrue: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			followingByte := aCompiledMethodOrMethodSpec at: pc+1.
			oldIvar := followingByte+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 256 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1.
					(bytecode = 226 and: [ newIvar <= 16 ])
						ifTrue: [ "Shorten to 1 byte format + NOP #genPushInstVar:"
							aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
							aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					(bytecode = 240 and: [ newIvar <= 8 ])
						ifTrue: [ "Shorten to 1 byte format + NOP #genStorePopInstVar:"
							aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
							aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/17/2025 09:21:37'!
         remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Similar to #displaceInstVarAccessesIn:starting:by:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive"
	
	"This initial implementation can not handle inst var indexes greater than 255.
	See #genPushInstVar: #genStoreInstVar: #genStorePopInstVar:"

	| pc end bytecode followingByte oldIvar bytecodeSize |

	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(aCompiledMethodOrMethodSpec at: pc+1) = 16r5F ifFalse: [
							aBoolean ifTrue: [self error: 'NOP padding missing'].
							^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(aCompiledMethodOrMethodSpec at: pc+1) = 16r5F ifFalse: [
							aBoolean ifTrue: [self error: 'NOP padding missing'].
							^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 > end ifTrue: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			followingByte := aCompiledMethodOrMethodSpec at: pc+1.
			oldIvar := followingByte+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 256 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1.
					(bytecode = 226 and: [ newIvar <= 16 ])
						ifTrue: [ "Shorten to 1 byte format + NOP #genPushInstVar:"
							aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
							aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					(bytecode = 240 and: [ newIvar <= 8 ])
						ifTrue: [ "Shorten to 1 byte format + NOP #genStorePopInstVar:"
							aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
							aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForV3PlusClosures class methodsFor: 'services' stamp: 'jmv 7/16/2025 16:35:49'!
         displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvarToDisplace. Displace them by delta.
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."

	| pc end bytecode followingByte thirdByte oldIvar newIvar bytecodeSize |
	"Just in case..."
	delta = 0 ifTrue: [ ^true ].
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ]	.

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				| primitiveCode |
				newIvar := oldIvar+delta.
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode + 1 ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		oldIvar >= firstIvarToDisplace ifTrue: [
			aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
			^false ]	.
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			followingByte+1 >= firstIvarToDisplace ifTrue: [
				followingByte+delta < 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: followingByte+delta ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			thirdByte+1 >= firstIvarToDisplace ifTrue: [
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: thirdByte+delta ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 							"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForV3PlusClosures class methodsFor: 'services' stamp: 'jmv 7/16/2025 16:23:11'!
                        remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Similar to #displaceInstVarAccessesIn:starting:by:doIt:
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive"

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ]	.

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			aDictionary at: aCompiledMethodOrMethodSpec returnField+1 ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode + 1 ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			newIvar = oldIvar ifFalse: [
				aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
				^false ]	].
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			aDictionary at: followingByte+1 ifPresent: [ :newIvar |
				newIvar <= 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			aDictionary at: thirdByte+1 ifPresent: [ :newIvar |
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: newIvar-1 ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 							"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true! !

CompiledMethod class removeSelector: #displaceInstVarAccessesIn:starting:by:doIt:!

!methodRemoval: CompiledMethod class #displaceInstVarAccessesIn:starting:by:doIt: stamp: 'Install-7361-MoveIvarRemapServicesToBytecodeEncoder-AddSista-2025Jul17-09h46m-jmv.cs.st 7/22/2025 09:51:47'!
displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvar. Displace them by delta.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders.
	"

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	"Just in case..."
	delta = 0 ifTrue: [ ^true ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				| primitiveCode |
				primitiveCode := oldIvar+delta-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true 	].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		oldIvar >= firstIvarToDisplace ifTrue: [
			aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
			^false ]	.
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			followingByte+1 >= firstIvarToDisplace ifTrue: [
				followingByte+delta < 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: followingByte+delta ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			thirdByte+1 >= firstIvarToDisplace ifTrue: [
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: thirdByte+delta ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 						"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true!

CompiledMethod class removeSelector: #remapInstVarAccessesIn:asPer:doIt:!

!methodRemoval: CompiledMethod class #remapInstVarAccessesIn:asPer:doIt: stamp: 'Install-7361-MoveIvarRemapServicesToBytecodeEncoder-AddSista-2025Jul17-09h46m-jmv.cs.st 7/22/2025 09:51:47'!
remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBollean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive"

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			aDictionary at: aCompiledMethodOrMethodSpec returnField+1 ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true 	].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			newIvar = oldIvar ifFalse: [
				aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
				^false ]	].
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			aDictionary at: followingByte+1 ifPresent: [ :newIvar |
				newIvar <= 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			aDictionary at: thirdByte+1 ifPresent: [ :newIvar |
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: newIvar-1 ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 						"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7361-MoveIvarRemapServicesToBytecodeEncoder-AddSista-2025Jul17-09h46m-jmv.cs.st----!

'From Cuis7.5 [latest update: #7361] on 17 July 2025 at 2:13:00 pm'!
!TTFontDescription methodsFor: 'conversion' stamp: 'jmv 7/17/2025 14:10:15' prior: 16981420!
                          formGlyphForUtf8Byte1: aByte1 byte2: aByte2OrNil byte3: aByte3OrNil byte4: aByte4OrNil pixelSize: pixelSize
	"Needed only for BitBltCanvasEngine"
	| byte1 byte2OrNil byte3OrNil byte4OrNil utf8ByteArray toPixelsScale formWidth formHeight leftPixelOffset topPixelOffset horizontalStrokesAtPixelCenter xtraRoom form canvas advanceWidth boundsLeft boundsRight boundsBottom boundsTop i deltaXToCenter |

	byte1 := aByte1.
	byte2OrNil := aByte2OrNil.
	byte3OrNil := aByte3OrNil.
	byte4OrNil := aByte4OrNil.
	i := contourDataIndexesByUtf8 at: byte1 + 1.
	utf8ByteArray := ByteArray with: byte1.
	byte2OrNil notNil ifTrue: [
		i := contourDataIndexesByUtf8 at: i negated + byte2OrNil + 1.
		utf8ByteArray := ByteArray with: byte1 with: byte2OrNil.
		byte3OrNil notNil ifTrue: [
			i := contourDataIndexesByUtf8 at: i negated + byte3OrNil + 1.
			utf8ByteArray := ByteArray with: byte1 with: byte2OrNil with: byte3OrNil.
			byte4OrNil notNil ifTrue: [
				i := contourDataIndexesByUtf8 at: i negated + byte4OrNil + 1.
				utf8ByteArray := ByteArray with: byte1 with: byte2OrNil with: byte3OrNil with: byte4OrNil ]]].

	"If glyph not found, take first glyph 'theUnknownGlyph'"
	i = 0 ifTrue: [ i := 1 ].

	advanceWidth := contourDataForUtf8 at: i. i := i + 1.
	boundsLeft := contourDataForUtf8 at: i. i := i + 1.
	boundsRight := contourDataForUtf8 at: i. i := i + 1.
	boundsBottom := contourDataForUtf8 at: i. i := i + 1.
	boundsTop := contourDataForUtf8 at: i. i := i + 1.

	horizontalStrokesAtPixelCenter := 0.5 * 0.
	toPixelsScale := 0.0 + pixelSize / self letterMTopSideBearing.

	"If positive, pixels we save at the left. if negative, xtra pix needed"
		xtraRoom := 0.4 "+1".
	leftPixelOffset := (boundsLeft * toPixelsScale - xtraRoom) "floor".
		xtraRoom := 1.8 "+2".
	formWidth := ((boundsRight - boundsLeft) * toPixelsScale + xtraRoom) ceiling.

	"Usually positive. Needed pixels above the baseline"
		xtraRoom := 0.0 "+1".
	topPixelOffset := (boundsTop * toPixelsScale + xtraRoom) ceiling.
		xtraRoom := 1.7 "+2".
	formHeight := ((boundsTop - boundsBottom) * toPixelsScale + xtraRoom) ceiling.
	
	form := Form extent: formWidth@formHeight depth: 32.
	form fillColor: Color white.
"form fillColor: (Color gray: 0.95)."
	canvas := VectorCanvas onFormWithSubPixelAntiAliasing: form.
	canvas 
		engine
			drawUtf8String: utf8ByteArray
			fromByte: 1
			toByte: utf8ByteArray size
			at: leftPixelOffset negated@(topPixelOffset - horizontalStrokesAtPixelCenter)
			trueTypeFont: self
			color: Color black
			scale: 1.0 * pixelSize
			preventMirroring: true.
"
f2 := form copy.
f2 fill: (form boundingBox insetBy: 1) fillColor: (f2 colorAt: 0@0).
(f2 tallyPixelValues count: [ :v | v > 0 ]) > 1 ifTrue: [
	Tota ifNil: [ Tota := OrderedCollection new ].
	Tota add: form.
	Tota2 ifNil: [ Tota2 := OrderedCollection new ].
	Tota2 add: utf8ByteArray.
].
"

	"TrueType doesn't speciy how to position diacritics wrt base character glyph.
	Horizontally center diacriticals wrt base glyph.
	See
	basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
	Apparently OpenType can do better than TrueType, as it includes the GPOS table."
	deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.51)) * toPixelsScale.
	byte1 = 204 ifTrue: [
		byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.43)) * toPixelsScale ].
		byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.65)) * toPixelsScale ]].

	"DoubleWidth code points that combine above previous and following characters.
	Codepoints between 16r035C and 16r0363.
	Example: o͢o
	Don't center them"
	(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
		deltaXToCenter := 0 ].
	
	^(FormGlyph
		form: form
		leftOffset: leftPixelOffset
		topOffset: topPixelOffset
		advanceWidth: (advanceWidth * toPixelsScale))
			deltaXToCenter: deltaXToCenter.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
FontFamily releaseClassCachedState.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7362-CachedFontTweaks-JuanVuletich-2025Jul17-12h59m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7362] on 19 July 2025 at 11:44:29 am'!
!TTFontDescription methodsFor: 'conversion' stamp: 'jmv 7/19/2025 11:42:12' prior: 50348517!
       formGlyphForUtf8Byte1: aByte1 byte2: aByte2OrNil byte3: aByte3OrNil byte4: aByte4OrNil pixelSize: pixelSize
	"Needed only for BitBltCanvasEngine"
	| byte1 byte2OrNil byte3OrNil byte4OrNil utf8ByteArray toPixelsScale formWidth formHeight leftPixelOffset topPixelOffset form canvas advanceWidth boundsLeft boundsRight boundsBottom boundsTop i deltaXToCenter xtraRoom usedRect |

	byte1 := aByte1.
	byte2OrNil := aByte2OrNil.
	byte3OrNil := aByte3OrNil.
	byte4OrNil := aByte4OrNil.
	i := contourDataIndexesByUtf8 at: byte1 + 1.
	utf8ByteArray := ByteArray with: byte1.
	byte2OrNil notNil ifTrue: [
		i := contourDataIndexesByUtf8 at: i negated + byte2OrNil + 1.
		utf8ByteArray := ByteArray with: byte1 with: byte2OrNil.
		byte3OrNil notNil ifTrue: [
			i := contourDataIndexesByUtf8 at: i negated + byte3OrNil + 1.
			utf8ByteArray := ByteArray with: byte1 with: byte2OrNil with: byte3OrNil.
			byte4OrNil notNil ifTrue: [
				i := contourDataIndexesByUtf8 at: i negated + byte4OrNil + 1.
				utf8ByteArray := ByteArray with: byte1 with: byte2OrNil with: byte3OrNil with: byte4OrNil ]]].

	"If glyph not found, take first glyph 'theUnknownGlyph'"
	i = 0 ifTrue: [ i := 1 ].

	advanceWidth := contourDataForUtf8 at: i. i := i + 1.
	boundsLeft := contourDataForUtf8 at: i. i := i + 1.
	boundsRight := contourDataForUtf8 at: i. i := i + 1.
	boundsBottom := contourDataForUtf8 at: i. i := i + 1.
	boundsTop := contourDataForUtf8 at: i. i := i + 1.

	toPixelsScale := 0.0 + pixelSize / self letterMTopSideBearing.

	"If positive, pixels we save at the left. if negative, xtra pix needed.
	Be sure to leave extra room so there's no risk of missing pixels."
	leftPixelOffset := (boundsLeft * toPixelsScale) rounded.
	formWidth := ((boundsRight - boundsLeft) * toPixelsScale) ceiling.
	xtraRoom := formWidth * 2 //10 + 3.
	leftPixelOffset := leftPixelOffset - xtraRoom.
	formWidth := formWidth + xtraRoom + xtraRoom.

	"Usually positive. Needed pixels above the baseline.
	Be sure to leave extra room so there's no risk of missing pixels."
	topPixelOffset := (boundsTop * toPixelsScale) ceiling.
	formHeight := ((boundsTop - boundsBottom) * toPixelsScale) ceiling.
	xtraRoom := formHeight * 2 //10 + 3.
	topPixelOffset := topPixelOffset + xtraRoom.
	formHeight := formHeight + xtraRoom + xtraRoom.
	
	"Draw our glyph."
	form := Form extent: formWidth@formHeight depth: 32.
	form fillColor: Color white.
"form fillColor: (Color r: 01.0 g: 0.9 b: 0.9)." "Debug aid"
	canvas := VectorCanvas onFormWithSubPixelAntiAliasing: form.
	canvas 
		engine
			drawUtf8String: utf8ByteArray
			fromByte: 1
			toByte: utf8ByteArray size
			at: leftPixelOffset negated@topPixelOffset
			trueTypeFont: self
			color: Color black
			scale: 1.0 * pixelSize
			preventMirroring: true.

	"Now only take the pixels that are actually needed."
	usedRect := form boundingBox intersect: canvas engine morphBoundsAfterDraw.
	"usedRect := usedRect outsetBy: 1." "Debug aid"
	form := form copy: usedRect.
	leftPixelOffset := leftPixelOffset + usedRect left.
	topPixelOffset := topPixelOffset - usedRect top.

"Debug Aid"
"
f2 := form copy.
f2 fill: (form boundingBox insetBy: 1) fillColor: (f2 colorAt: 0@0).
(f2 tallyPixelValues count: [ :v | v > 0 ]) > 1 ifTrue: [
	Tota ifNil: [ Tota := OrderedCollection new ].
	Tota add: form.
	Tota2 ifNil: [ Tota2 := OrderedCollection new ].
	Tota2 add: utf8ByteArray.
].
"

	"TrueType doesn't speciy how to position diacritics wrt base character glyph.
	Horizontally center diacriticals wrt base glyph.
	See
	basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
	Apparently OpenType can do better than TrueType, as it includes the GPOS table."
	deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.51)) * toPixelsScale.
	byte1 = 204 ifTrue: [
		byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.43)) * toPixelsScale ].
		byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.65)) * toPixelsScale ]].

	"DoubleWidth code points that combine above previous and following characters.
	Codepoints between 16r035C and 16r0363.
	Example: o͢o
	Don't center them"
	(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
		deltaXToCenter := 0 ].
	
	^(FormGlyph
		form: form
		leftOffset: leftPixelOffset
		topOffset: topPixelOffset
		advanceWidth: (advanceWidth * toPixelsScale))
			deltaXToCenter: deltaXToCenter.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
FontFamily releaseClassCachedState.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7363-CachedGlyphsTweaks-JuanVuletich-2025Jul18-21h17m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7363] on 21 July 2025 at 12:09:47 pm'!
!TTFontDescription methodsFor: 'accessing' stamp: 'jmv 7/21/2025 11:47:00'!
     contourDataIndexForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil
	"Answer the position in contourDataForUtf8 for requested UTF-8 encoded code point.
	Answer 0 if we don't include it.
	Entries in contourDataIndexesByUtf8 may be:
		> 1: actual index in countourData for this CodePoint
		= 1: No contourData for this CodePoint. Use the UnknownGlyph, stored at position 1. (If byte1 > 0)
		< 0: Another UTF-8 byte is needed.
		= 0: No contourData for this CodePoint. Use the UnknownGlyph, stored at position 1."

	| i |
	i := contourDataIndexesByUtf8 at: byte1 + 1.
	byte2OrNil notNil ifTrue: [
		i < 0 ifFalse: [ ^0 ].
		i := contourDataIndexesByUtf8 at: i negated + byte2OrNil + 1.
		byte3OrNil notNil ifTrue: [
			i < 0 ifFalse: [ ^0 ].
			i := contourDataIndexesByUtf8 at: i negated + byte3OrNil + 1.
			byte4OrNil notNil ifTrue: [
				i < 0 ifFalse: [ ^0 ].
				i := contourDataIndexesByUtf8 at: i negated + byte4OrNil + 1 ]]].
	
	^i! !
!TTFontDescription methodsFor: 'accessing' stamp: 'jmv 7/21/2025 11:48:07'!
                 includesContourDataForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil
	"Answer true if we include a glyph definition for the requested UTF-8 encoded code point.
	Answer false if we don't include it.
	See comment at #contourDataIndexForUtf8Byte1:byte2:byte3:byte4:"

	"The unknown glyph is indeed included.
	See #appendGlyphDataTo:glyphsArray:indexes:base:bar:unknown:scaleArrowGlyphs:"
	byte1 = 1 ifTrue: [
		^true ].

	"But any other glyph redirected to it is not included."
	^(self contourDataIndexForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil) > 1! !
!TrueTypeFont methodsFor: 'glyph access' stamp: 'jmv 7/21/2025 12:05:02' prior: 16999741!
         glyphAtUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil
	"Needed only for BitBltCanvasEngine"

	| lastArray lastIndex |
	
	"Avoid creating multiple cached instances for the unknown glyph. Just keep one!!"
	(ttFontDescription includesContourDataForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil)
		 ifFalse: [
			^self glyphAtUtf8Byte1: 1 byte2: nil byte3: nil byte4: nil ].
	lastArray := glyphFormsByUtf8 .
	lastIndex := byte1 + 1.
	byte2OrNil notNil ifTrue: [
		(lastArray at: lastIndex) ifNil: [ lastArray at: lastIndex put: (Array new: 64) ].
		lastArray := lastArray at: lastIndex.
		lastIndex := (byte2OrNil bitAnd: 63) + 1.
		byte3OrNil notNil ifTrue: [
			(lastArray at: lastIndex) ifNil: [ lastArray at: lastIndex put: (Array new: 64) ].
			lastArray := lastArray at: lastIndex.
			lastIndex := (byte3OrNil bitAnd: 63) + 1.
			byte4OrNil notNil ifTrue: [
				(lastArray at: lastIndex) ifNil: [ lastArray at: lastIndex put: (Array new: 64) ].
				lastArray := lastArray at: lastIndex.
				lastIndex := (byte4OrNil bitAnd: 63) + 1 ]]].
	^ (lastArray at: lastIndex) ifNil: [
		| formGlyph |
		formGlyph := (ttFontDescription
				formGlyphForUtf8Byte1: byte1 byte2: byte2OrNil
				byte3: byte3OrNil byte4: byte4OrNil
				pixelSize: pointSize)
			ifNotNil: [ :theGlyph |
				self isUnderlined ifTrue: [
					self makeUnderlinedGlyph: theGlyph ].
				self isStruckThrough ifTrue: [
					self makeStruckThroughGlyph: theGlyph ].
				theGlyph].
		lastArray at: lastIndex put: formGlyph.
		formGlyph ]! !
!TTFontDescription methodsFor: 'private-initialization' stamp: 'jmv 7/21/2025 12:08:11' prior: 16981267!
         appendGlyphDataTo: stream glyphsArray: glyphsArray indexes: indexes base: baseIndex bar: aProgressBarOrNil unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs

		glyphsArray withIndexDo: [ :glyphOrArrayOrNumberNil :index |
			aProgressBarOrNil ifNotNil: [ :bar | bar value: index ].
			glyphOrArrayOrNumberNil ifNotNil: [
				glyphOrArrayOrNumberNil == theUnknownGlyph
					ifTrue: [ indexes at: baseIndex + index put: 1 ] "Set to unknownGlyph. UnknownGlyph is index 1."
					ifFalse: [
						glyphOrArrayOrNumberNil isArray
							ifTrue: [
								| nextBaseIndex |
								nextBaseIndex := indexes size - 128.
								indexes addAll: (IntegerArray new: 64).
								indexes at: baseIndex + index put: nextBaseIndex negated.
								self appendGlyphDataTo: stream glyphsArray: glyphOrArrayOrNumberNil indexes: indexes
									base: nextBaseIndex bar: nil unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs ]
							ifFalse: [
								glyphOrArrayOrNumberNil isNumber
									ifTrue: [ | glyph tx |
										glyph := arrowGlyphs at: glyphOrArrayOrNumberNil.
										tx := AffineTransformation withScale: letterMTopSideBearing asFloat / arrowGlyphs second topSideBearing * 0.7.
										indexes at: baseIndex + index put: stream position+1.
										glyph addGlyphDataTo: stream tx: tx
										]
									ifFalse: [
										indexes at: baseIndex + index put: stream position+1.
										glyphOrArrayOrNumberNil addGlyphDataTo: stream tx: nil ]]]]].! !
!TTFontDescription methodsFor: 'conversion' stamp: 'jmv 7/21/2025 11:55:48' prior: 50348660!
    formGlyphForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil pixelSize: pixelSize
	"Needed only for BitBltCanvasEngine"

	| utf8ByteArray toPixelsScale formWidth formHeight leftPixelOffset topPixelOffset form canvas advanceWidth boundsLeft boundsRight boundsBottom boundsTop i deltaXToCenter xtraRoom usedRect |

	"Get the position in contourData for our glyph definition."
	i := self contourDataIndexForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil.
	
	advanceWidth := contourDataForUtf8 at: i. i := i + 1.
	boundsLeft := contourDataForUtf8 at: i. i := i + 1.
	boundsRight := contourDataForUtf8 at: i. i := i + 1.
	boundsBottom := contourDataForUtf8 at: i. i := i + 1.
	boundsTop := contourDataForUtf8 at: i. i := i + 1.

	toPixelsScale := 0.0 + pixelSize / self letterMTopSideBearing.

	"If positive, pixels we save at the left. if negative, xtra pix needed.
	Be sure to leave extra room so there's no risk of missing pixels."
	leftPixelOffset := (boundsLeft * toPixelsScale) rounded.
	formWidth := ((boundsRight - boundsLeft) * toPixelsScale) ceiling.
	xtraRoom := formWidth * 2 //10 + 3.
	leftPixelOffset := leftPixelOffset - xtraRoom.
	formWidth := formWidth + xtraRoom + xtraRoom.

	"Usually positive. Needed pixels above the baseline.
	Be sure to leave extra room so there's no risk of missing pixels."
	topPixelOffset := (boundsTop * toPixelsScale) ceiling.
	formHeight := ((boundsTop - boundsBottom) * toPixelsScale) ceiling.
	xtraRoom := formHeight * 2 //10 + 3.
	topPixelOffset := topPixelOffset + xtraRoom.
	formHeight := formHeight + xtraRoom + xtraRoom.
	
	"Draw our glyph."
	utf8ByteArray := { byte1. byte2OrNil. byte3OrNil. byte4OrNil} select: [ :b | b notNil ] :: asByteArray.
	form := Form extent: formWidth@formHeight depth: 32.
	form fillColor: Color white.
"form fillColor: (Color r: 01.0 g: 0.9 b: 0.9)." "Debug aid"
	canvas := VectorCanvas onFormWithSubPixelAntiAliasing: form.
	canvas 
		engine
			drawUtf8String: utf8ByteArray
			fromByte: 1
			toByte: utf8ByteArray size
			at: leftPixelOffset negated@topPixelOffset
			trueTypeFont: self
			color: Color black
			scale: 1.0 * pixelSize
			preventMirroring: true.

	"Now only take the pixels that are actually needed."
	usedRect := form boundingBox intersect: canvas engine morphBoundsAfterDraw.
	"usedRect := usedRect outsetBy: 1." "Debug aid"
	form := form copy: usedRect.
	leftPixelOffset := leftPixelOffset + usedRect left.
	topPixelOffset := topPixelOffset - usedRect top.

"Debug Aid"
"
f2 := form copy.
f2 fill: (form boundingBox insetBy: 1) fillColor: (f2 colorAt: 0@0).
(f2 tallyPixelValues count: [ :v | v > 0 ]) > 1 ifTrue: [
	Tota ifNil: [ Tota := OrderedCollection new ].
	Tota add: form.
	Tota2 ifNil: [ Tota2 := OrderedCollection new ].
	Tota2 add: utf8ByteArray.
].
"

	"TrueType doesn't speciy how to position diacritics wrt base character glyph.
	Horizontally center diacriticals wrt base glyph.
	See
	basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
	Apparently OpenType can do better than TrueType, as it includes the GPOS table."
	deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.51)) * toPixelsScale.
	byte1 = 204 ifTrue: [
		byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.43)) * toPixelsScale ].
		byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
			deltaXToCenter := (advanceWidth - (boundsRight+boundsLeft * 0.65)) * toPixelsScale ]].

	"DoubleWidth code points that combine above previous and following characters.
	Codepoints between 16r035C and 16r0363.
	Example: o͢o
	Don't center them"
	(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
		deltaXToCenter := 0 ].
	
	^(FormGlyph
		form: form
		leftOffset: leftPixelOffset
		topOffset: topPixelOffset
		advanceWidth: (advanceWidth * toPixelsScale))
			deltaXToCenter: deltaXToCenter.! !
!TTFontDescription methodsFor: 'glyph properties' stamp: 'jmv 7/21/2025 11:21:27' prior: 16981549!
          widthOfUtf8Byte1: byte1 b2: byte2OrNil b3: byte3OrNil b4: byte4OrNil

	| i advanceWidth |
	
	i := self contourDataIndexForUtf8Byte1: byte1 byte2: byte2OrNil byte3: byte3OrNil byte4: byte4OrNil.
	
	"If glyph not found, take first glyph 'theUnknownGlyph'"
	i = 0 ifTrue: [ i := 1 ].
	advanceWidth := contourDataForUtf8 at: i.
	^ advanceWidth / letterMTopSideBearing.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
FontFamily releaseClassCachedState.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7364-CachedFonts-MemoryOptimization-JuanVuletich-2025Jul21-12h06m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7364] on 21 July 2025 at 4:26:35 pm'!
!TTFontDescription methodsFor: 'private-initialization' stamp: 'jmv 7/21/2025 16:00:49' prior: 50348926!
                        appendGlyphDataTo: stream glyphsArray: glyphsArray indexes: indexes base: baseIndex bar: aProgressBarOrNil unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs

		glyphsArray withIndexDo: [ :glyphOrArrayOrNumberNil :index |
			aProgressBarOrNil ifNotNil: [ :bar | bar value: index ].
			glyphOrArrayOrNumberNil ifNotNil: [
				glyphOrArrayOrNumberNil == theUnknownGlyph
					ifTrue: [ indexes at: baseIndex + index put: 1 ] "Set to unknownGlyph. UnknownGlyph is index 1."
					ifFalse: [
						glyphOrArrayOrNumberNil isArray
							ifTrue: [
								| nextBaseIndex |
								nextBaseIndex := indexes size - 128.
								"Any incomplete array sequence will point at 1. VectorEngine will show (Character codePoint: 500001)
								as four invalid glyphs and not just one. Real solution is for VectorEngine to skip ignored bytes."
								indexes addAll: ((IntegerArray new: 64) atAllPut: 1).
								indexes at: baseIndex + index put: nextBaseIndex negated.
								self appendGlyphDataTo: stream glyphsArray: glyphOrArrayOrNumberNil indexes: indexes
									base: nextBaseIndex bar: nil unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs ]
							ifFalse: [
								glyphOrArrayOrNumberNil isNumber
									ifTrue: [ | glyph tx |
										glyph := arrowGlyphs at: glyphOrArrayOrNumberNil.
										tx := AffineTransformation withScale: letterMTopSideBearing asFloat / arrowGlyphs second topSideBearing * 0.7.
										indexes at: baseIndex + index put: stream position+1.
										glyph addGlyphDataTo: stream tx: tx
										]
									ifFalse: [
										indexes at: baseIndex + index put: stream position+1.
										glyphOrArrayOrNumberNil addGlyphDataTo: stream tx: nil ]]]]].! !
!TTFontDescription methodsFor: 'private-initialization' stamp: 'jmv 7/21/2025 16:01:10' prior: 16981322!
                  glyphsByUtf8Bytes: glyphsByUTF8 unknownGlyph: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs

	| mGlyph |
	
	mGlyph := glyphsByUTF8 at: $M asciiValue + 1.
	letterMTopSideBearing := (mGlyph ifNil: [theUnknownGlyph]) topSideBearing.

	"Any incomplete array sequence will point at 1. VectorEngine will show (Character codePoint: 500001)
	as four invalid glyphs and not just one. Real solution is for VectorEngine to skip ignored bytes."
	contourDataIndexesByUtf8 := ((IntegerArray new: 256) atAllPut: 1) as: OrderedCollection.
	contourDataForUtf8 := Float32Array streamContents: [ :stream |
		theUnknownGlyph addGlyphDataTo: stream tx: nil.		"First data is for unknownGlyph"	
		self fullName, ' - Processing glyph data' 
			displayProgressAt: 100@100
			from: 1 
			to: glyphsByUTF8 size 
			during: [ :bar |
				self appendGlyphDataTo: stream glyphsArray: glyphsByUTF8 indexes: contourDataIndexesByUtf8
					base: 0 bar: bar unknown: theUnknownGlyph scaleArrowGlyphs: arrowGlyphs ]].
	contourDataIndexesByUtf8 := contourDataIndexesByUtf8 as: IntegerArray.
	"Any incomplete array sequence will point at 1. VectorEngine will show (Character codePoint: 500001)
	as four invalid glyphs and not just one. Real solution is for VectorEngine to skip ignored bytes."
	contourDataIndexesByLatin1 := (IntegerArray new: 256)  atAllPut: 1.
	0 to: 255 do: [ :cp | | i |
		Character
			evaluateOnce: [ :byte1 :byte2OrNil :byte3OrNil :byte4OrNil |
				i := contourDataIndexesByUtf8 at: byte1 + 1.
				(byte2OrNil notNil and: [ i < 0 ]) ifTrue: [
					i := contourDataIndexesByUtf8 at: i negated + byte2OrNil + 1 ].
				contourDataIndexesByLatin1 at: cp+1 put: i ]
			withUtf8BytesOf: cp ].! !
!TTFontDescription class methodsFor: 'instance creation' stamp: 'jmv 7/21/2025 16:03:24' prior: 16981605!
            readTrueTypeFontsIn: aDirectoryEntry
	"
	TTFontDescription readTrueTypeFontsIn: DirectoryEntry trueTypeFontsDirectory
	"
	| read |
	read := OrderedDictionary new.
	aDirectoryEntry
		allFilesDo: [ :file | | ttf |
			ttf := TTFontReader readTTFFrom: file binaryContents.
			ttf folderName: file parent name.
			self add: ttf to: read ]
		matches: [ :file | '*.ttf' match: file name ].
	aDirectoryEntry
		allFilesDo: [ :file | | ttc |
			ttc := TTFontReader readTTCFrom: file binaryContents.
			ttc do: [ :eachTtf |
				eachTtf folderName: file parent name.
				self add: eachTtf to: read ]]
		matches: [ :file | '*.ttc' match: file name ].
	Descriptions ifNil: [ Descriptions := Dictionary new ].
	read keysAndValuesDo: [ :familyName :emphasisDict |
		emphasisDict keysAndValuesDo: [ :emphasis :ttf |
			(Descriptions at: familyName ifAbsentPut: [ Dictionary new]) at: emphasis put: ttf ]].
	^read keys.! !
!TTFontDescription class methodsFor: 'class initialization' stamp: 'jmv 7/21/2025 16:17:15' prior: 16981643 overrides: 16924243!
                      initialize
	"
	TTFontDescription initialize.
	FontFamily releaseClassCachedState.
	TrueTypeFontFamily readAllTrueTypeFontsIn: DirectoryEntry trueTypeFontsDirectory / 'DejaVu' / 'DejaVuSans'.
	"
	Descriptions := nil.! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 7/21/2025 14:45:21' prior: 17008696!
                contourDataIndexForUtf32: codePoint contourDataIndexes: contourDataIndexes
	"contourDataIndexes is designed to be directly accessible via UTF-8 bytes of a CodePoint.
	This allows for a compact and efficient packing of TrueType contour data.
	In order to be used for a plain Code Point (as expressed in UTF-32), the UTF-8 bytes of
	the code point need to be extracted and used to access contourDataIndexes."

	| i utf8Byte1 utf8Byte2 utf8Byte3 utf8Byte4 |
	codePoint <= 16r7F
		ifTrue: [
			utf8Byte1 := codePoint.
			i := contourDataIndexes at: utf8Byte1 + 1 ]
		ifFalse: [
			codePoint <= 16r7FF
				ifTrue: [
					utf8Byte1 := (codePoint bitShift: -6) bitOr: 2r11000000.
					utf8Byte2 := (codePoint bitAnd: 2r00111111) bitOr: 2r10000000.
					i := contourDataIndexes at: utf8Byte1 + 1.
					i < 0 ifFalse: [ ^0 ].
					i := contourDataIndexes at: i negated + utf8Byte2 + 1 ]
				ifFalse: [
					codePoint <= 16rFFFF
						ifTrue: [
							utf8Byte1 := (codePoint bitShift: -12) bitOr: 2r11100000.
							utf8Byte2 := ((codePoint bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
							utf8Byte3 := (codePoint bitAnd: 2r00111111) bitOr: 2r10000000.
							i := contourDataIndexes at: utf8Byte1 + 1.
							i < 0 ifFalse: [ ^0 ].
							i := contourDataIndexes at: i negated + utf8Byte2 + 1.
							i < 0 ifFalse: [ ^0 ].
							i := contourDataIndexes at: i negated + utf8Byte3 + 1 ]
						ifFalse: [
							utf8Byte1 := (codePoint bitShift: -18) bitOr: 2r11110000.
							utf8Byte2 := ((codePoint bitShift: -12) bitAnd: 2r00111111) bitOr: 2r10000000.
							utf8Byte3 := ((codePoint bitShift: -6) bitAnd: 2r00111111) bitOr: 2r10000000.
							utf8Byte4 := (codePoint bitAnd: 2r00111111) bitOr: 2r10000000.
							i := contourDataIndexes at: utf8Byte1 + 1.
							i < 0 ifFalse: [ ^0 ].
							i := contourDataIndexes at: i negated + utf8Byte2 + 1.
							i < 0 ifFalse: [ ^0 ].
							i := contourDataIndexes at: i negated + utf8Byte3 + 1.
							i < 0 ifFalse: [ ^0 ].
							i := contourDataIndexes at: i negated + utf8Byte4 + 1 ]]].
	^i! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 7/21/2025 16:24:51' prior: 17008755!
         displayByteString: aString from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours |
	nextGlyphX := destX.
	startIndex to: stopIndex do: [ :charIndex | | latin1Code i |
		latin1Code := (aString at: charIndex) codePoint.
		i := contourDataIndexes at: latin1Code + 1.
		i < 1 ifTrue: [ i := 1 ].
		advanceWidth := contourData at: i. i := i + 1.
		boundsLeft := contourData at: i. i := i + 1.
		boundsRight := contourData at: i. i := i + 1.
		boundsBottom := contourData at: i. i := i + 1.
		boundsTop := contourData at: i. i := i + 1.
		numContours := (contourData at: i) asInteger. i := i + 1.
		self glyphContours: numContours atx: nextGlyphX y: destY scalex: sx y: sy contourData: contourData i: i.
		nextGlyphX := nextGlyphX + (advanceWidth * sx) ].
	^nextGlyphX! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 7/21/2025 16:25:00' prior: 17008787!
        displayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours deltaXToCenter deltaXForDiacriticalMark deltaYForDiacriticalMark deltaXForBaseGlyph baseBoundsTop |
	nextGlyphX := destX.
	startIndex to: stopIndex do: [ :utf32Index | | utf32 i |
		utf32 := aWordArray at: utf32Index.
		
		"$i followed by a Combining Diacritical Mark is replaced by CodePoint 16r131 Dotless i
		This should also be done for VectorEngineWithPlugin"
		(utf32 = 16r69 and: [ utf32Index < stopIndex ] and: [
			(aWordArray at: utf32Index+1) between: 16r300 and: 16r36F ])
				ifTrue: [ utf32 := 16r131 ].
		i :=  self contourDataIndexForUtf32: utf32 contourDataIndexes: contourDataIndexes.
		advanceWidth := contourData at: i. i := i + 1.
		boundsLeft := contourData at: i. i := i + 1.
		boundsRight := contourData at: i. i := i + 1.
		boundsBottom := contourData at: i. i := i + 1.
		boundsTop := contourData at: i. i := i + 1.
		numContours := (contourData at: i) asInteger. i := i + 1.
		
		"TrueType doesn't speciy how to position diacritics wrt base character glyph.
		Horizontally center diacriticals wrt base glyph.
		See
			basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
			formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
			displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
		This should also be done for VectorEngineWithPlugin
		Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
		deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
		utf32 = 16r300 ifTrue: [	"Combining Grave Accent"
			deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
		utf32 = 16r301 ifTrue: [ 	"Combining Acute Accent"
			deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ].
		"DoubleWidth code points that combine above previous and following characters.
		Codepoints between 16r035C and 16r0363.
		Example: o͢o
		Don't center them"
		(utf32 between: 16r035C and: 16r0363) ifTrue: [
			deltaXToCenter := 0.0 ].
				
		deltaXForDiacriticalMark := 0.0.
		deltaYForDiacriticalMark := 0.
		advanceWidth = 0.0
			ifFalse: [ "Regular glyph"
				deltaXForBaseGlyph := deltaXToCenter.
				baseBoundsTop := boundsTop ]
			ifTrue: [ "Diacritical mark"
				deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
					ifFalse: [
						deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
						baseBoundsTop > boundsBottom ifTrue: [
							deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
		
		self
			glyphContours: numContours
			atx: nextGlyphX + deltaXForDiacriticalMark y: destY + deltaYForDiacriticalMark
			scalex: sx y: sy
			contourData: contourData i: i.
		
		nextGlyphX := nextGlyphX + (advanceWidth * sx) ].
	^nextGlyphX! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 7/21/2025 16:25:08' prior: 17008883!
 displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX byte1 byte2OrNil baseIndex advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours deltaXToCenter deltaXForDiacriticalMark deltaYForDiacriticalMark deltaXForBaseGlyph baseBoundsTop |
	nextGlyphX := destX.
	byte1 := nil.
	byte2OrNil := nil.
	baseIndex := 0.
	byteStartIndex to: byteStopIndex do: [ :byteIndex | | byte i |
		byte := aByteArray at: byteIndex.
		byte1 isNil ifTrue: [byte1 := byte ] ifFalse: [ byte2OrNil isNil ifTrue: [ byte2OrNil := byte ]].
		i := contourDataIndexes at: baseIndex + byte + 1.
		
		"$i followed by a Combining Diacritical Mark is replaced by CodePoint 305 Dotless i, UTF-8 #[196 177]
		(UnicodeString fromUtf8Bytes: #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32
			105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ]) edit
		This should also be done for VectorEngineWithPlugin"
		(byte1 = 105 and: [ byteIndex < (byteStopIndex-1) ] and: [
			(aByteArray at: byteIndex+1) = 204 or: [ (aByteArray at: byteIndex+1) = 205 and: [ (aByteArray at: byteIndex+2) < 176 ]]])
				ifTrue: [
					i := contourDataIndexes at: 196 + 1.
					i := contourDataIndexes at: i negated + 177 + 1 ].
		
		i < 0
			ifTrue: [ baseIndex := i negated ]
			ifFalse: [
				advanceWidth := contourData at: i. i := i + 1.
				boundsLeft := contourData at: i. i := i + 1.
				boundsRight := contourData at: i. i := i + 1.
				boundsBottom := contourData at: i. i := i + 1.
				boundsTop := contourData at: i. i := i + 1.
				numContours := (contourData at: i) asInteger. i := i + 1.
				"TrueType doesn't speciy how to position diacritics wrt base character glyph.
				Horizontally center diacriticals wrt base glyph.
				See
					basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
					formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
					displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
				This should also be done for VectorEngineWithPlugin
				Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
				deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
				byte1 = 204 ifTrue: [
					byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
						deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
					byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
						deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ]].
				"DoubleWidth code points that combine above previous and following characters.
				Codepoints between 16r035C and 16r0363.
				Example: o͢o
				Don't center them"
				(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
					deltaXToCenter := 0.0 ].
				
				deltaXForDiacriticalMark := 0.0.
				deltaYForDiacriticalMark := 0.
				advanceWidth = 0.0
					ifFalse: [ "Regular glyph"
						deltaXForBaseGlyph := deltaXToCenter.
						baseBoundsTop := boundsTop ]
					ifTrue: [ "Diacritical mark"
						deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
							ifFalse: [
								deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
								baseBoundsTop > boundsBottom ifTrue: [
									deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
				
				self
					glyphContours: numContours
					atx: nextGlyphX + deltaXForDiacriticalMark y: destY + deltaYForDiacriticalMark
					scalex: sx y: sy
					contourData: contourData i: i.
				
				nextGlyphX := nextGlyphX + (advanceWidth * sx).
				baseIndex := 0.
				byte1 := nil.
				byte2OrNil := nil ]].
	^nextGlyphX! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 7/21/2025 16:24:46' prior: 17009015!
               glyphContours: numContours atx: nextGlyphX y: nextGlyphY scalex: sx y: sy contourData: contourData i: contourDataIndex

		| i contourStart numBeziers ttMoveToX ttMoveToY x y |
		i := contourDataIndex.
		numContours timesRepeat: [
			numBeziers := (contourData at: i) asInteger. i := i + 1.
			ttMoveToX := contourData at: i. i := i + 1.
			ttMoveToY := contourData at: i. i := i + 1.
			x := ttMoveToX * sx + nextGlyphX.
			y := ttMoveToY * sy + nextGlyphY.
			contourStart := x@y.
			self moveTo: contourStart.
			numBeziers timesRepeat: [ | cx cy ttControlX ttControlY ttEndX ttEndY |
				ttEndX := contourData at: i. i := i + 1.
				ttEndY := contourData at: i. i := i + 1.
				ttControlX := contourData at: i. i := i + 1.
				ttControlY := contourData at: i. i := i + 1.
				cx := ttControlX * sx + x.
				cy := ttControlY * sy + y.
				x := ttEndX * sx + x.
				y := ttEndY * sy + y.
				self quadraticBezierTo: x@y control: cx@cy ].
			self lineTo: contourStart ].! !

TTFontDescription initialize.
	FontFamily releaseClassCachedState.
	TrueTypeFontFamily readAllTrueTypeFontsIn: DirectoryEntry trueTypeFontsDirectory / 'DejaVu' / 'DejaVuSans'.
	PreferenceSet setDefaultFont: FontFamily defaultFamilyName.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7365-TrueType-display-fix-JuanVuletich-2025Jul21-16h22m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7364] on 21 July 2025 at 6:41:39 pm'!
!EquivalentNodesFinder methodsFor: 'visiting' stamp: 'HAW 7/21/2025 18:33:05' prior: 50332300 overrides: 16927072!
       visitBlockNode: blockNode

	| blockStatements |

	self addToEquivalentsIfOneStatementEquivalentTo: blockNode.

	super visitBlockNode: blockNode.
	
	nodesToLookForSize > 1 ifTrue: [ 
		blockStatements := blockNode statements copy. 
		"I need to add temp declaration to statements becuase user could have selected the temp declaration
		See 
		- ExtractMethodFinderTest>>test22FindsTemporaryWhenSelectingDefinitionInInnerClosure
		- ExtractMethodFinderTest>>test22_1_FindsTemporaryWhenSelectingDefinitionInInnerClosure - Hernan"
		blockNode declaresAnyVariable ifTrue: [ blockStatements addFirst: blockNode temporariesDeclaration ].
		self addEquivalentNodesOf: blockStatements ]
		! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7366-ExtractMethodInnerBlocksFix-HernanWilkinson-2025Jul21-17h30m-HAW.001.cs.st----!

----QUIT----(22 July 2025 09:51:51) Cuis7.5-7366.image priorSource: 502486!

----STARTUP---- (23 July 2025 14:33:01) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.5-7366.image!


'From Cuis7.5 [latest update: #7366] on 23 July 2025 at 2:24:18 pm'!
!VectorEngineWithPlugin methodsFor: 'private' stamp: 'jmv 7/23/2025 14:23:44' prior: 17013627 overrides: 17009057!
                             pvtStrokeWidth: aNumber hop: aFloat

	strokeWidth := aNumber.
	hop := aFloat.
	"Set AntiAliasingWidth in the plugin, as #primStrokeWidth:hop: needs it."
	self
		primAntiAliasingWidth: antiAliasingWidth asFloat
		subPixelDelta: self subPixelDelta asFloat.
	"This call in the plugin uses AntiAliasingWith."
	self primStrokeWidth: strokeWidth hop: hop.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7367-VectorEngineWithPlugin-fix-JuanVuletich-2025Jul23-13h47m-jmv.001.cs.st----!

----QUIT----(23 July 2025 14:33:06) Cuis7.5-7367.image priorSource: 577048!

----STARTUP---- (27 July 2025 12:43:42) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.5-7367.image!


'From Cuis7.5 [latest update: #7367] on 24 July 2025 at 11:00:14 am'!
!CodeFileBrowser methodsFor: 'diffs' stamp: 'jmv 7/24/2025 10:59:57' prior: 16823291!
        methodDiffFor: aString selector: selector
	"Answer the diff between the current copy of the given class/selector/meta for the string provided"
	| theClass base |
	base := ''.
	theClass := self pvtBaseClassOrMetaclass.
	theClass ifNotNil: [
		(theClass includesSelector: selector) ifTrue: [
			base := theClass sourceCodeAt: selector ]].
	^ DifferenceFinder
		displayPatchFrom: base
		to: aString
		tryWords: self shouldDiffWords
		prettyPrintedIn:
			(self showingAnyKindOfPrettyDiffs ifTrue: [ theClass ]).! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 7/24/2025 11:00:00' prior: 16804483!
         compareToCurrentVersion
	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"

	| base class baseString caseString differDesc diffWords |
	listIndex = 0
		ifTrue: [^ self].
	base := changeList at: listIndex.
	((class := base changeClass) notNil
			and: [class includesSelector: base methodSelector])
		ifTrue: [
			baseString := base string.
			caseString := (class sourceCodeAt: base methodSelector) asPlainString.
			baseString = caseString
				ifTrue: [^ self inform: 'Exact Match'].
			diffWords := self shouldDiffWords.
			differDesc := diffWords
				ifTrue: [ 'Words']
				ifFalse: [ 'Lines'].
			(TextModel
				withText: (
					(DifferenceFinder
						displayPatchFrom: baseString to: caseString
						tryWords: diffWords
						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))
							font: (Preferences at: #standardCodeFont)))
				openLabel: 'Comparison to Current Version: ', differDesc, 
					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]
		ifFalse: [self flash]! !
!VersionsBrowser methodsFor: 'menu' stamp: 'jmv 7/24/2025 11:00:03' prior: 17014290!
        compareToOtherVersion
	"Prompt the user for a reference version, then spawn a window 
	showing the diffs between the older and the newer of the current 
	version and the reference version as text."

	| base case baseString caseString differDesc diffWords targetChanges labels label1 |
	base := changeList at: listIndex ifAbsent: [ ^self ].
	label1 := list at: listIndex.

	labels := list reject: [ :any | any = label1 ].
	targetChanges := changeList reject: [ :any | any = base ].
	case := ((SelectionMenu
				labels: labels
				selections: targetChanges) startUpMenu) ifNil: [ ^self ].
	
	"compare earlier -> later"
	"change1 timeStamp < change2 timeStamp
		ifFalse: [ | temp | temp := change1. change1 := change2. change2 := temp ]."

	baseString := base string.
	caseString := case string.
	baseString = caseString
		ifTrue: [^ self inform: 'Exact Match'].

	diffWords := self shouldDiffWords.
	differDesc := diffWords
		ifTrue: [ 'Words']
		ifFalse: [ 'Lines'].

	(TextModel new
		contents: (DifferenceFinder
			displayPatchFrom: baseString to: caseString
			tryWords: diffWords
			prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [classOfMethod])))
		openLabel: 
			(('Comparison from {1} to {2}: ', differDesc, 
				(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])) 
					format: { base stamp. case stamp })! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7368-VersionDiffingTweaks-JuanVuletich-2025Jul24-10h59m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7367] on 24 July 2025 at 9:54:25 am'!
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 7/24/2025 09:53:36' prior: 16932405 overrides: 16932763!
                    mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row := (localEventPosition y < 0 and: [ scrollBar scrollValue > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: `0@0`) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ self vLeftoverScrollRange > 0 and: [ scrollBar scrollValue < 1.0 ]])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [
					self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff := (self listSelectionAt: row) not.
		dragStartRow := row ].

	"Set meaning for subsequent dragging of selection"
	oldIndex := self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal := self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self setSelectionIndex: row ]
		ifFalse: [ self setSelectionIndex: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	dragStartRow ifNotNil: [
		(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
			self listSelectionAt: r put: dragOnOrOff ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7369-clickNdragScrollFix-JuanVuletich-2025Jul24-09h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7370] on 24 July 2025 at 12:11:57 pm'!
!FormGlyph methodsFor: 'initialization' stamp: 'jmv 7/24/2025 11:33:12'!
             form: aForm leftOffsetBy: aNumber.
	form := aForm.
	leftOffset := leftOffset + aNumber! !
!TrueTypeFont methodsFor: 'synthetic derivatives' stamp: 'jmv 7/24/2025 11:57:10' prior: 16999845!
   makeStruckThroughGlyph: aFormGlyph
	| oldForm form d |
	"Please keep consistent with
	#drawOnVectorEngine:from:to:at:font:color:
	#drawOnVectorEngine:from:to:at:font:color:borderWidth:borderColor:
	Similar to: #makeUnderlinedGlyph:"

	form := aFormGlyph form.
	form width = 0 ifTrue: [ ^self ].
	d := (self descent / 4) ceiling.
	true ifTrue: [
		oldForm := form.
		form := Form extent: oldForm width+2 @ oldForm height depth: oldForm depth.
		form fillWhite.
		form copyBits: oldForm boundingBox from: oldForm at: `1@0` clippingBox: form boundingBox rule: Form over.
		aFormGlyph form: form leftOffsetBy: -1].
	form fillBlack: (0 @ (aFormGlyph topOffset - self descent) floor extent: form width @ d).
	"For testing it:
	FontFamily releaseClassCachedState
	"! !
!TrueTypeFont methodsFor: 'synthetic derivatives' stamp: 'jmv 7/24/2025 12:10:23' prior: 16999855!
   makeUnderlinedGlyph: aFormGlyph
	| height y oldForm form d |
	"Please keep consistent with
	#drawOnVectorEngine:from:to:at:font:color:
	#drawOnVectorEngine:from:to:at:font:color:borderWidth:borderColor:
	Similar to #makeStruckThroughGlyph:"

	form := aFormGlyph form.
	form width = 0 ifTrue: [ ^self ].
	d := (self descent / 4) ceiling.
	y := aFormGlyph topOffset + d.
	height := aFormGlyph topOffset + (2*d).
	true "height > form height" ifTrue: [
		oldForm := form.
		form := Form extent: oldForm width+2 @ height depth: oldForm depth.
		form fillWhite.
		form copyBits: oldForm boundingBox from: oldForm at: `1@0` clippingBox: form boundingBox rule: Form over.
		aFormGlyph form: form leftOffsetBy: -1 ].
	form fillBlack: (0 @ y extent: form width @ d).
	"For testing it:
	FontFamily releaseClassCachedState
	"! !
!TTFontReader methodsFor: 'processing' stamp: 'jmv 7/24/2025 11:41:40' prior: 16981684!
                       mapAndStoreGlyphsUsing: characterMap
	"
	https://developer.apple.com/fonts/TrueType-Reference-Manual/RM07/appendixB.html
	"
	| glyphsByUTF8 unknownGlyph nullGlyph spaceGlyph mapSize preferredCodePoint arrowGlyphIndexes leftArrowGlyph upArrowGlyph rightArrowGlyph downArrowGlyph carriageReturnGlyph leftArrowGlyphCodePoint upArrowGlyphCodePoint rightArrowGlyphCodePoint downArrowGlyphCodePoint carriageReturnGlyphCodePoint |
	unknownGlyph := glyphs first.
	nullGlyph := glyphs second.
	mapSize := characterMap size.
	glyphsByUTF8 := Array new: 256.
	leftArrowGlyphCodePoint := self class smalltalkAssignmentArrowGlyphCodePoint.
	upArrowGlyphCodePoint := self class smalltalkReturnArrowGlyphCodePoint.
	rightArrowGlyphCodePoint := 8594.
	downArrowGlyphCodePoint := 8595.
	carriageReturnGlyphCodePoint := 8617.
	
	"Store Unicode arrow glyphs for future use if appropriate,"
	(FallbackArrowGlyphs isNil or: [fontDescription name = 'DejaVuSans']) ifTrue: [
		mapSize > 8617 ifTrue: [								"Usually true. Just in case."
			arrowGlyphIndexes := {leftArrowGlyphCodePoint. upArrowGlyphCodePoint. rightArrowGlyphCodePoint. downArrowGlyphCodePoint. carriageReturnGlyphCodePoint}
					collect: [ :codePoint | (characterMap at: codePoint+1)+1 ].
				(arrowGlyphIndexes allSatisfy: [ :i | i > 1 ]) ifTrue: [
					FallbackArrowGlyphs := arrowGlyphIndexes collect: [ :i | glyphs at: i ]]]].
	"Take arrow glyphs if present, or use fallbacks if not."
	leftArrowGlyph := upArrowGlyph := rightArrowGlyph := downArrowGlyph := carriageReturnGlyph := unknownGlyph.
	mapSize > downArrowGlyphCodePoint ifTrue: [
		leftArrowGlyph := glyphs at: (characterMap at: leftArrowGlyphCodePoint+1)+1.
		upArrowGlyph := glyphs at: (characterMap at: upArrowGlyphCodePoint+1)+1.
		rightArrowGlyph := glyphs at: (characterMap at: rightArrowGlyphCodePoint+1)+1.
		downArrowGlyph := glyphs at: (characterMap at: downArrowGlyphCodePoint+1)+1 ].
	leftArrowGlyph == unknownGlyph ifTrue: [ leftArrowGlyph := FallbackArrowGlyphs at: 1 ].
	upArrowGlyph == unknownGlyph ifTrue: [ upArrowGlyph := FallbackArrowGlyphs at: 2 ].
	rightArrowGlyph == unknownGlyph ifTrue: [ rightArrowGlyph := FallbackArrowGlyphs at: 3 ].
	downArrowGlyph == unknownGlyph ifTrue: [ downArrowGlyph := FallbackArrowGlyphs at: 4 ].
	mapSize > carriageReturnGlyphCodePoint ifTrue: [
		carriageReturnGlyph := glyphs at: (characterMap at: carriageReturnGlyphCodePoint+1)+1 ].
	carriageReturnGlyph == unknownGlyph ifTrue: [ carriageReturnGlyph := FallbackArrowGlyphs at: 5 ].

	0 to: mapSize - 1 do: [ :codePoint | | g array prevByte|

		preferredCodePoint := codePoint.
		(codePoint == $- codePoint and: [mapSize > 16r2212]) ifTrue: [ preferredCodePoint := 16r2212 ]. "WIDE MINUS"
		(codePoint == $* codePoint and: [mapSize > 16r2217]) ifTrue: [ preferredCodePoint := 16r2217 ]. "CENTERED ASTERISK"
		g := glyphs at: (characterMap at: preferredCodePoint+1)+1 ifAbsent: [ unknownGlyph ].
		g == unknownGlyph ifTrue: [
			g := glyphs at: (characterMap at: codePoint+1)+1 ifAbsent: [ unknownGlyph ]].

		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ].
					].
				prevByte := byte.
				]
			withUtf8BytesOf: codePoint.
			array at: prevByte+1 put: g.
		codePoint = 32 ifTrue: [
			spaceGlyph := g ].

		].

	"Synthetic Unicode zero width space glyph. Add others as needed."
	{ Character zeroWidthSpace } do: [ :codePoint | | g array prevByte|
		g := TTGlyph new.					"Suitable as zero width space"
		array := glyphsByUTF8.
		prevByte := nil.
		Character
			evaluate: [ :byte |
				prevByte notNil ifTrue: [
					array := (array at: prevByte+1) ifNil: [ array at: prevByte+1 put: (Array new: 256) ]].
				prevByte := byte ]
			withUtf8BytesOf: codePoint codePoint.
			array at: prevByte+1 put: g ].

	Character separators do: [ :s |
		s codePoint < 256 ifTrue: [
			glyphsByUTF8 at: s codePoint +1 put: spaceGlyph ]].
	1 to: 4 do: [ :i | glyphsByUTF8 at: 28+i put: i ].
	glyphsByUTF8 at: 13 +1 put: carriageReturnGlyph.
	fontDescription
		glyphsByUtf8Bytes: glyphsByUTF8
		unknownGlyph: unknownGlyph scaleArrowGlyphs: {leftArrowGlyph. rightArrowGlyph. upArrowGlyph. downArrowGlyph. carriageReturnGlyph}! !
!UnicodeString methodsFor: 'dispatch' stamp: 'jmv 7/24/2025 12:06:50' prior: 17003231!
                    drawOnVectorEngine: engine from: startIndex to: stopIndex at: aPoint font: aTrueTypeFont color: color

	| byteStartIndex byteStopIndex p answer d |
	byteStartIndex := self byteIndexAt: startIndex.
	byteStopIndex := (self byteIndexAt: stopIndex+1)-1.
	"Please keep consistent with #basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:"
	p := aTrueTypeFont isSuperscript
		ifTrue: [ aPoint x  @ (aPoint y - (aTrueTypeFont ascent*0.55)) ]
		ifFalse: [
			aTrueTypeFont isSubscript
				ifTrue: [aPoint x @ (aPoint y + (aTrueTypeFont ascent*0.3))]
				ifFalse: [ aPoint ]].
	answer := engine
		drawUtf8String: bytes
		fromByte: byteStartIndex toByte: byteStopIndex
		at: p
		trueTypeFont: aTrueTypeFont fontDescription
		color: color
		scale: aTrueTypeFont pointSize
		preventMirroring: true.
	"Please keep consistent with #makeUnderlinedGlyph:"
	aTrueTypeFont isUnderlined ifTrue: [
		d := aTrueTypeFont descent *0.7.
		engine strokeWidth: (aTrueTypeFont descent / 4) color: color do: [
			engine moveTo: p + (0@d); lineTo: answer + (0@d) ]].
	"Please keep consistent with #makeStruckThroughGlyph: and #drawOnVectorEngine:from:to:at:font:color:borderWidth:borderColor:"
	aTrueTypeFont isStruckThrough ifTrue: [
		d := aTrueTypeFont ascent * 0.25.
		engine strokeWidth: (aTrueTypeFont descent / 4) color: color do: [
			engine moveTo: p - (0@d); lineTo: answer - (0@d) ]].
	^answer! !
!UnicodeString methodsFor: 'dispatch' stamp: 'jmv 7/24/2025 12:07:04' prior: 17003273!
        drawOnVectorEngine: engine from: startIndex to: stopIndex at: aPoint font: aTrueTypeFont color: color borderWidth: sw borderColor: sc

	| byteStartIndex byteStopIndex p answer d |
	byteStartIndex := self byteIndexAt: startIndex.
	byteStopIndex := (self byteIndexAt: stopIndex+1)-1.
	"Please keep consistent with #basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:"
	p := aTrueTypeFont isSuperscript
		ifTrue: [ aPoint x  @ (aPoint y - (aTrueTypeFont ascent*0.55)) ]
		ifFalse: [
			aTrueTypeFont isSubscript
				ifTrue: [aPoint x @ (aPoint y + (aTrueTypeFont ascent*0.3))]
				ifFalse: [ aPoint ]].
	answer := engine
		drawUtf8String: bytes
		fromByte: byteStartIndex toByte: byteStopIndex
		at: p
		trueTypeFont: aTrueTypeFont fontDescription
		color: color
		strokeWidth: sw strokeColor: sc
		scale: aTrueTypeFont pointSize
		preventMirroring: true.
	"Please keep consistent with #makeUnderlinedGlyph: and #drawOnVectorEngine:from:to:at:font:color:"
	aTrueTypeFont isUnderlined ifTrue: [
		d := aTrueTypeFont descent *0.7.
		engine strokeWidth: (aTrueTypeFont descent / 4) color: color do: [
			engine moveTo: p + (0@d); lineTo: answer + (0@d) ]].
	"Please keep consistent with #makeStruckThroughGlyph:"
	aTrueTypeFont isStruckThrough ifTrue: [
		d := aTrueTypeFont ascent * 0.25.
		engine strokeWidth: (aTrueTypeFont descent / 4) color: color do: [
			engine moveTo: p - (0@d); lineTo: answer - (0@d) ]].
	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7370-Underline-StruckThrough-tweaks-JuanVuletich-2025Jul24-11h19m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7370] on 25 July 2025 at 9:28:35 am'!

Smalltalk renameClassNamed: #LayoutMorph as: #LinearLayoutMorph!

!classRenamed: #LayoutMorph as: #LinearLayoutMorph stamp: 'Install-7371-Rename-LayoutMorph-as-LinearLayoutMorph-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st 7/27/2025 12:43:42'!
Smalltalk renameClassNamed: #LayoutMorph as: #LinearLayoutMorph!
!Dialog methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:28:21' prior: 16848639!
                               beColumn
	layoutMorph
		ifNotNil: [ layoutMorph beColumn ]
		ifNil: [
			layoutMorph := LinearLayoutMorph newColumn.
			self addMorphFront: layoutMorph ]! !
!FindInSourceDialog methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:28:20' prior: 16869092 overrides: 16848620!
             buildWidgets

	| buttonRow titleMorph |
	titleMorph := (LabelMorph contents: 'Find in source code' fontSize: 16 emphasis: 1).
	titleMorph layoutSpec offAxisEdgeWeight: 0.
	searchField := EntryFieldMorph new.
	searchField
		crAction: [ self ok ];
		escAction: [ self cancel ].
	searchField layoutSpec offAxisEdgeWeight: 0.
	initialSearchString ifNotNil: [ searchField contents: initialSearchString ].
	scopeList := PluggableListMorph
		withModel: self
		listGetter: #scopesList
		indexGetter: #scopeIndex
		indexSetter: #scopeIndex:.
	scopeList 
		doubleClickSelector: #ok.
	buttonRow := LinearLayoutMorph newRow.
	buttonRow
		addMorph: (PluggableButtonMorph model: self action: #ok label: 'Ok');
		addMorph: (PluggableButtonMorph model: self action: #cancel label: 'Cancel').
	layoutMorph
		gap: 14;
		addMorphKeepMorphHeight: titleMorph;
		addMorphKeepMorphHeight: searchField;
		addMorphUseAll: scopeList;
		addMorphKeepMorphHeight: buttonRow.

	self morphExtent: self minimumExtent * (2@1.5).! !
!SampleModalDialog methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:28:21' prior: 16952761 overrides: 16848620!
    buildWidgets
	"
	This is a sample implementation. Actual subclasses should reimplement #buildWidgets (without calling super!!).
	self openModal
	"

	| typeRow buttonRow |
	typeRow := LinearLayoutMorph newRow.
	typeRow
		addMorph: (LabelMorph contents: 'Type');
		addMorph: (LabelMorph contents: 'So what');
		addMorph: (LabelMorph contents: 'And then').
	buttonRow := LinearLayoutMorph newRow.
	buttonRow
		padding: 10;
		gap: 20;
		addMorph: (PluggableButtonMorph model: self action: #ok label: 'Ok');
		addMorph: (PluggableButtonMorph model: self action: #cancel label: 'Cancel').
	layoutMorph
		addMorph: 
			((LabelMorph contents: 'This is a title for this Dialog' fontSize: 25)
				borderWidth: 2; borderColor: color lighter;
				padding: 20);
		addMorph: Sample01Star new;
		addMorph: typeRow;
		addMorph: buttonRow.

	"self ensureMinimumExtent."
	"To make the star somehow larger"
	self morphExtent: self minimumExtent + (0@200).! !
!LinearLayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 09:28:22' prior: 16897181 overrides: 16796324!
      is: aSymbol
	^ aSymbol == #LinearLayoutMorph or: [ super is: aSymbol ]! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:20' prior: 50338526!
        example1
"
	self example1
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:20' prior: 50338594!
     example10
"
	self example10 openInWorld
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example10.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
^ pane! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 50338663!
                          example101VG
"
	self example101VG
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (Sample09Clock new name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 100); 
	addMorph: (Sample01Star new name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample03Smiley new name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (Sample03Smiley new name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color lightRed;
	addMorph: (Sample02Bezier new name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample02Bezier new  name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (Sample02Bezier new  name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 50338724!
                             example11
"
	self example11
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example11.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:20' prior: 50338795!
                    example13
	"
	self example13
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:22' prior: 50338843!
      example1b
"
Based on #example1, but using some ImageMorph instead of RectangleLikeMorph, so extent is not adjustable
	self example1b
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ImageMorph new name: #B);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ImageMorph new name: #G);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ImageMorph new name: #J);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 50338905!
                           example2
	"
	self example2
	"
	| pane row |
	pane := (LinearLayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8 offAxisEdgeWeight: #rightOrBottom);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 0.7 offAxisEdgeWeight: #center).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 200@180 extent: 400@300.
	pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:22' prior: 50338937!
                     example20
"
	self example20
"
| column |

column := (LinearLayoutMorph newColumn separation: 5) name: #Column.
column
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 30).
column position: 150@130 extent: 400@300.
column openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 50338960!
        example3
	"
	self example3
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:22' prior: 50339003!
             example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane := LinearLayoutMorph newRow separation: 5. "1"
pane addMorph: (LabelMorph contents: '1').

rect1 := ColoredBoxMorph new color: (Color lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Color lightGreen;
	position: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane := LinearLayoutMorph newRow separation: 5. "2"
pane addMorph: (LabelMorph contents: '2').

rect1 := ColoredBoxMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane
	color: Color lightGreen;
	position: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane := LinearLayoutMorph newRow separation: 5. "3"
pane addMorph: (LabelMorph contents: '3').

rect1 := ColoredBoxMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
rect2 := ColoredBoxMorph new color: (Color cyan);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	position: 520 @ 50 extent: 180 @ 100;
	openInWorld! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:20' prior: 16897788!
                              example7
	"
	Useful example contributed by Ken Dickey
	self example7
	"
	"============================================"
	| c colorHexValue colorName r w |
	w := SystemWindow new.
	r := LinearLayoutMorph newRow separation: 30 @ 10.
	c := LinearLayoutMorph newColumn separation: 20 @ 10.
	colorHexValue := LabelMorph contents:  'F97306'.
	colorName := LabelMorph contents: 'cornSilk'.

	r addMorph: colorHexValue.
	r addMorph: colorName.
	c addMorph: ColoredBoxMorph new.
	c addMorph: r.
	w addMorph: c .
	w openInWorld.
	"============================================"! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 16897878!
                        iconsExample
	"
	LayoutMorph iconsExample
	"
	| lm ilm counter |
	lm := LinearLayoutMorph newColumn.
	ilm := LinearLayoutMorph newRow.
	counter := 1.
	Theme methodsDo: [ :method | | sel | 
		(sel := method selector) numArgs = 0 ifTrue: [
			(sel endsWith: 'Icon') ifTrue: [ | mayBeForm |
				mayBeForm := Theme current perform: sel.
				(mayBeForm isKindOf: Form) ifTrue: [ | imageMorph |
					counter \\ 10 = 0 ifTrue: [
						lm addMorph: ilm.
						ilm := LinearLayoutMorph newRow ].
					counter := counter + 1.
					ilm addMorph: (imageMorph := ImageMorph newWith: (mayBeForm magnifyBy: 2)).
					imageMorph 
						setBalloonText: 'Copy ''', sel storeString bold, ''' to the Clipboard';
						setProperty: #'handlesMouseDown:' toValue: true;
						setProperty: #mouseButton1Down:localPosition:  toValue: [ :event :pos |
							Clipboard storeObject: sel storeString ] ] ] ] ].
	lm 
		setProperty: #taskbarButtonIcon toValue: Theme current imageIcon;
		setBalloonText: 'Drag me here!!'.
	lm openInWorld
! !
!LinearLayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:28:21' prior: 16897912!
                               launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random := Random new.
	b1 := PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 := PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 := PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 := PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons := {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: `Color lightRed` ].
	row := LinearLayoutMorph newRow
		 color: `Color red`;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!LinearLayoutMorph class methodsFor: 'FormLayout examples' stamp: 'jmv 7/25/2025 09:28:20' prior: 50342538!
            example1Form
"
	self example1Form
"
	| pane |
	pane := (LinearLayoutMorph newForm separation: 5) name: #example1.
	pane 
		color: Color red;
		addMorph: (ColoredBoxMorph new color: (Color lightBlue); name: #A)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@20 brEdgesWeight: 0@0 offset: 100@40);
		addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 30@20 brEdgesWeight: 1@0 offset: -30@40);
		addMorph: (ColoredBoxMorph new color: (Color lightGreen); name: #C)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@60 brEdgesWeight: 0.5@0 offset: -10@140);
		addMorph: (ColoredBoxMorph new color: (Color green); name: #D)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 10@60 brEdgesWeight: 1@0 offset: -30@140);
		addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@160 brEdgesWeight: 1@1 offset: -30@ -30).
	pane position: 150@130 extent: 400@300.
	pane openInWorld! !
!StringRequestMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:28:22' prior: 16969289!
                    addTextPane
	"Add a text pane and two buttons."
	
	| controlsContainer |
	textMorph := (TextModelMorph
		textProvider: self
		textGetter: #response
		textSetter: #response:
		selectionGetter: #selectionInterval) emptyTextDisplayMessage: 'Enter response'.
	self
		valueOfProperty: #emptyTextDisplayMessage
		ifPresentDo: [ :msg |
			textMorph emptyTextDisplayMessage: msg ].
	textMorph
		hasUnacceptedEdits: true;
		acceptOnCR: true;
		escAction: [ self cancel ].
	(controlsContainer := LinearLayoutMorph newRow)
		addMorphUseAll: textMorph;
		addMorph: 
			((PluggableButtonMorph model: textMorph scroller action: #acceptContents)
				setBalloonText: 'OK' bold, ' (accept input)';
				icon: Theme current acceptIcon);
		addMorph:
			((PluggableButtonMorph model: self action: #cancel)
				setBalloonText: 'Cancel' bold, '  (discard input)';
				icon: Theme current cancelIcon).
	self addMorphUseAll: controlsContainer! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:28:21' prior: 50339127 overrides: 16796268!
                       initialize
	super initialize.
	viewBox := LinearLayoutMorph newRow color: self defaultColor.
	self
		addMorph: (clock := UpdatingLabelMorph initializedInstance)
		layoutSpec:  (LayoutSizeSpec morphWidthProportionalHeight: 0.5).
	self
		addMorph: viewBox 
		layoutSpec: (LayoutSizeSpec
			proportionalWidth: 1.0
			proportionalHeight: 1.0 
			offAxisEdgeWeight: #rightOrBottom).
	viewBox separation: self defaultHeight // 8.
	self setBalloonText: [ 
		'About this system:' bold, `String newLineString`,
		Smalltalk systemInformationString ].
	clock
		setProperty: #handlesMouseDown: toValue: true;
		setProperty: #'mouseButton1Down:localPosition:' 
		toValue: [ :evt : pos | | menu taskbarEdge point | 
			self runningWorld ifNotNil: [ :w |
				taskbarEdge := self positionInWorld y.
				menu := (Preferences at: #worldMenu) getMenuIn: w at: w activeHand.	
				menu hide.
				w addMorph: menu. ": Otherwise we do not have a proper extent"
				point := 0 @ (taskbarEdge - menu extentInWorld y).
				menu popUpAt: point allowKeyboard: false ] ]! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 7/25/2025 09:28:21' prior: 50339163!
                    addStayUpIcons
	| closeButton pinButton w buttonHW |
	(Preferences at: #optionalButtons) ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	buttonHW := Theme current titleBarButtonsExtent x.
	closeButton := PluggableButtonMorph model: self action: #delete.
	closeButton iconDrawSelector: #drawCloseIcon; noButtonShape.
	pinButton := PluggableButtonMorph model: self action: #stayUp.
	pinButton iconDrawSelector: #drawPushPinIcon; noButtonShape.
	w := (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + (buttonHW*2).
	self addMorphFront: 
		(LinearLayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: buttonHW * 12 // 10);
			color: `Color transparent`;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//10;
			addMorph: (closeButton layoutSpec: (LayoutSizeSpec fixedWidth: buttonHW fixedHeight: buttonHW));
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: pinButton fixedWidth: buttonHW;
			addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedWidth: buttonHW//3).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 7/25/2025 09:28:21' prior: 16901259!
      removeStayUpBox
	| box |
	submorphs isEmpty ifTrue: [^self].
	(submorphs first is: #LinearLayoutMorph) ifFalse: [^self].
	box := submorphs first submorphs second.
	(box is: #PluggableButtonMorph) 
		ifTrue: [ box hide ]! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 7/25/2025 09:28:20' prior: 16931312!
                              example
	"
	PluggableButtonMorph example openInWorld
	"

	| s1 s2 s3 b1 b2 b3 row |
	s1 := Switch new.
	s2 := Switch new turnOn.
	s3 := Switch new.
	s1 onAction: [s3 turnOn].
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 := (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 := (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 := (PluggableButtonMorph model: s3 stateGetter: nil action: #switch) 
		enableSelector: #isOn;
		label: 'S3'.
	b1 color: `Color lightRed`.
	b2 color: `Color lightRed`.
	b3 color: `Color lightRed`.
	row := LinearLayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: `120@35`.
	^ row! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:28:21' prior: 16979990!
                       beColumn
	layoutMorph
		ifNotNil: [ layoutMorph beColumn ]
		ifNil: [
			layoutMorph := LinearLayoutMorph newColumn.
			self addMorphFront: layoutMorph ]! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:28:21' prior: 16979997!
               beRow
	layoutMorph
		ifNotNil: [ layoutMorph beRow ]
		ifNil: [
			layoutMorph := LinearLayoutMorph newRow.
			self addMorphFront: layoutMorph ]! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16825559!
         buildButtonPane

	| saveButton createButton deleteButton browseChangesButton browseButton addReqButton buttonRow |
	saveButton := PluggableButtonMorph 
							model: model 
							action: #save 
							label: 'save'.
	createButton := PluggableButtonMorph 
							model: self 
							action: #createPackage 
							label: 'new'.
	deleteButton := PluggableButtonMorph 
							model: self 
							action: #deletePackage 
							label: 'delete/merge'.
	browseChangesButton := PluggableButtonMorph 
							model: self 
							action: #browseChanges 
							label: 'changes'.
	browseButton := PluggableButtonMorph 
							model: self 
							action: #browse 
							label: 'browse'.
	addReqButton := PluggableButtonMorph 
							model: self 
							action: #addRequirement 
							label: 'add requirement'.
	buttonRow := LinearLayoutMorph newRow.
	buttonRow
		doAdoptWidgetsColor;
		color: self widgetsColor quiteWhiter;
		addMorph: saveButton proportionalWidth: 0.6;
		addMorph: createButton proportionalWidth: 0.6;
		addMorph: deleteButton proportionalWidth: 0.6;
		addMorph: browseChangesButton proportionalWidth: 0.6;
		addMorph: browseButton proportionalWidth: 0.6;
		addMorph: addReqButton proportionalWidth: 0.6.
	buttonRow submorphsDo: [ :button | button  color: self widgetsColor ].
	^ buttonRow ! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16825603!
      buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| names fileNames namesPane fileNamesPane 
	upperRow  description summary labelBackground |
	labelBackground := Theme current background.
	
	names := PluggableListMorph
		withModel: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	namesPane := LinearLayoutMorph newColumn
		color: labelBackground;
		addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: ' Package Name');
		addMorphUseAll: names.

	fileNames := PluggableListMorph
		withModel: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames alwaysHideVerticalScrollbar.
	fileNamesPane := LinearLayoutMorph newColumn
		color: labelBackground;
		addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: ' File Name');
		addMorphUseAll: fileNames.

	upperRow := LinearLayoutMorph newRow.
	upperRow
		addMorph: namesPane proportionalWidth: 0.4;
		addAdjusterAndMorph: fileNamesPane proportionalWidth: 0.6.
		
	description := (TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:) emptyTextDisplayMessage: 'Please enter a description for this package'.

	summary := (TextModelMorph
		textProvider: model
		textGetter: #summary) emptyTextDisplayMessage: 'Package summary (No package selected?)'.
	
	names scrollSiblings: {fileNames}.
	fileNames scrollSiblings: {names}.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.6;
		addAdjusterAndMorph: self buildButtonPane fixedHeight: Theme current buttonPaneHeight;
		addAdjusterAndMorph: summary fixedHeight: 60;
		addAdjusterAndMorph: description proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildRequirementsPane proportionalHeight: 0.15.
	self setLabel: 'Installed Packages'! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 50339218!
         buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout updateReqButton |
	requirements := PluggableListMorph
		withModel: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
		
	deleteReqButton := (PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete')
							setBalloonText: 'Remove selected Feature requirement'.
	deleteReqButton color: self widgetsColor.
	updateReqButton := (PluggableButtonMorph 
							model: requirements model
							action: #updateSelectedRequirement 
							label: 'update')
							setBalloonText: 'Update requirement to current Feature revision'.
	updateReqButton color: self widgetsColor.
							
	buttonLayout := LinearLayoutMorph newRow.
	buttonLayout 
		addMorph: deleteReqButton 
		layoutSpec: (LayoutSizeSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						offAxisEdgeWeight: #leftOrTop);
		color: self widgetsColor quiteWhiter;
		addMorph: updateReqButton 
		layoutSpec: (LayoutSizeSpec 
						proportionalWidth: 1.0 
						proportionalHeight: 1.0
						offAxisEdgeWeight: #leftOrTop);
		color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LinearLayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSizeSpec 
							proportionalWidth: 0.8
							proportionalHeight: 1.0 
							offAxisEdgeWeight: #leftOrTop);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSizeSpec 
							proportionalWidth: 0.2 
							proportionalHeight: 1.0 
							offAxisEdgeWeight: #rightOrBottom);
		color: `Color transparent`;
		yourself
		! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16827067!
      buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons := LinearLayoutMorph newColumn.
	(Preferences at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations := LinearLayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16827154!
          optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons := OrderedCollection new.
	widths := OrderedCollection new.
	buttonColor := self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button := PluggableButtonMorph
			model: self
			action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		tuple size > 3 ifTrue: [ button setBalloonText: tuple fourth ].
		tuple size > 4 ifTrue: [ button secondaryActionSelector: tuple fifth ].
		buttons add: button ].
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row
		addMorphs: buttons
		widthProportionalTo: widths.
	^ row.! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16800012 overrides: 50351308!
                               buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations code comment separator |
	code := self buildMorphicCodePane.
	comment := self buildMorphicCommentPane.
	separator := LayoutAdjustingMorph new.
	comment separator: separator code: code.
	codeAndButtons := LinearLayoutMorph newColumn.
	(Preferences at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: code proportionalHeight: 0.5;
		addMorph: separator fixedHeight: Theme current layoutAdjusterThickness;
		addMorph: comment proportionalHeight: 0.5.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations := LinearLayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16800045!
              buildMorphicClassColumnWith: classList
	| column |
	column := LinearLayoutMorph newColumn.
	column
		addMorphUseAll: classList;
		addAdjusterAndMorph: self buildMorphicSwitches fixedHeight: Theme current buttonPaneHeight.
	^column! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16800099!
                           buildMorphicSwitches

	| instanceSwitch commentSwitch classSwitch row buttonColor |
	
	instanceSwitch := self createInstanceButton.
	commentSwitch := self createCommentButton.
	classSwitch := self createClassButton.
	
	row := LinearLayoutMorph newRow.
	row
		doAdoptWidgetsColor;
		addMorph: instanceSwitch proportionalWidth: 0.45;
		addMorph: commentSwitch proportionalWidth: 0.22;
		addMorph: classSwitch proportionalWidth: 0.33.
	buttonColor := self buttonColor.
	row color: buttonColor.

	{ 
		instanceSwitch.
		commentSwitch.
		classSwitch} do: [:m |  m color: buttonColor ].
		
	^row! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16800132!
                    buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList systemCatList classList |

	systemCatList := self buildMorphicSystemCategoryList.
	classList := self buildMorphicClassList.
	messageCatList := self buildMorphicMessageCatList.
	messageList := self buildMorphicMessageList.
	
	classList allowItemDrag: true.
	systemCatList 
		acceptDropsFrom: classList 
		performing: #categorizeUnderCategory:class:.
		
	messageList allowItemDrag: true.
	messageCatList
		acceptDropsFrom: messageList
		performing: #categorizeUnderCategoryAt:selector:.
	
	upperPanes := LinearLayoutMorph newRow.
	upperPanes
		addMorph: systemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: (self buildMorphicClassColumnWith: classList) proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16800169!
                buildNoSysCatMorphicWindow
	"A Browser without the class categories list"

	| mySingletonList upperPanes messageCatList messageList classColumn classList |
	mySingletonList := (PluggableListMorph
				withModel: model
				listGetter: #systemCategorySingleton
				indexGetter: #indexIsOne
				indexSetter: #indexIsOne:)
					menuNshortcutsKey: #systemCatSingletonMenuSpec.
	mySingletonList hideScrollBarsIndefinitely.

	classList := self buildMorphicClassList.
	classColumn := self buildMorphicClassColumnWith: classList.
	messageCatList := self buildMorphicMessageCatList.
	messageList := self buildMorphicMessageList.
	
	upperPanes := LinearLayoutMorph newRow.
	upperPanes
		addMorph: classColumn proportionalWidth: 0.3;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	messageList allowItemDrag: true.
	messageCatList
		acceptDropsFrom: messageList
		performing: #categorizeUnderCategoryAt:selector:.

	self layoutMorph
		addMorph: mySingletonList fixedHeight: (Preferences at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16823800 overrides: 50351427!
    buildMorphicWindow
	"Create a pluggable version of all the views for a Browser, using Morphic widgets."

	| sysCatList msgCatList upperPanes clsLayout clsList msgList |
	model systemCategoryList ifNotEmpty: [ 
		model setSelectedSystemCategory: model systemCategoryList first ].
	sysCatList := (PluggableListMorph
			withModel: model 
			listGetter: #systemCategorySingleton
			indexGetter: #indexIsOne 
			indexSetter: #indexIsOne:)
				menuNshortcutsKey: #codeFileListMenuSpec.
	sysCatList hideScrollBarsIndefinitely.
	
	msgCatList := (PluggableListMorph
			withModel: model 
			listGetter: #messageCategoryList
			indexGetter: #messageCategoryListIndex 
			indexSetter: #messageCategoryListIndex:)
				menuNshortcutsKey: #messageCatListMenuSpec.

	clsList := self buildMorphicClassList.
	clsLayout := self buildMorphicClassColumnWith: clsList.
	msgList := self buildMorphicMessageList.

	upperPanes := LinearLayoutMorph newRow.
	upperPanes
		addMorph: clsLayout proportionalWidth: 0.3;
		addAdjusterAndMorph: msgCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: msgList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: sysCatList fixedHeight: (Preferences at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.
	model changed: #editSelection! !
!ChangeListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16805660 overrides: 50351333!
                 optionalButtonRow
	"Answer a row of buttons to occur in a tool pane"

	| row buttons widths buttonColor |
	buttons := OrderedCollection new.
	widths := OrderedCollection new.
	buttonColor := self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button := PluggableButtonMorph 
					model: model
					action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		buttons add: button.
		button setBalloonText: tuple fourth].
	buttons add: self lineDiffButton.
	widths add: 14.
	buttons add: self wordDiffButton.
	widths add: 16.
	model wantsPrettyDiffOption ifTrue: [
		buttons add:  self prettyLineDiffButton.
		widths add: 21.
		buttons add:  self prettyWordDiffButton.
		widths add: 23 ].
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16810217!
                    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| changeSetList classList changeSetListPane classListPane
	  messageList upperPanes labelBackground |
	labelBackground := Theme current background.
	model myChangeSet ifNil: [
		"Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	changeSetList := (PluggableListMorphByItem
				withModel: model
				listGetter: #changeSetList
				indexGetter: #currentChangeSetName
				indexSetter: #showChangeSetNamed:)
					menuNshortcutsKey: #changeSetListMenuSpec;
					autoDeselect: false.
	changeSetListPane := LinearLayoutMorph newColumn
		color: labelBackground;
		addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: 'Change Set name');
		addMorphUseAll: changeSetList.

	classList := (PluggableListMorphByItem
				withModel: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:)
					menuNshortcutsKey: #classListMenuSpec.
	classListPane := LinearLayoutMorph newColumn
		color: labelBackground;
		addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: 'Classes');
		addMorphUseAll: classList.

	upperPanes := LinearLayoutMorph newRow.
	upperPanes
		addMorph: changeSetListPane proportionalWidth: 0.6;
		addAdjusterAndMorph: classListPane proportionalWidth: 0.4.
	
	messageList := (PluggableListMorphByItem
				withModel: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:)
					menuNshortcutsKey: #messageListMenuSpec.
	messageList := LinearLayoutMorph newColumn
		color: labelBackground;
		addMorph: (ColoredBoxMorph new color: `Color transparent`) fixedHeight: 4;
		addMorphKeepMorphHeight: (LabelMorph new contents: 'Methods');
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55.

	self setLabel: model labelString! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16845911 overrides: 50351308!
                buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations twoRowsOfButtons h |
	twoRowsOfButtons := LinearLayoutMorph newColumn.
	h := self defaultButtonPaneHeight.
	(Preferences at: #optionalButtons) ifTrue: [
		h := self defaultButtonPaneHeight * 2.
		twoRowsOfButtons
			addMorph: self optionalButtonRow proportionalHeight: 1.0;
			addAdjusterMorph ].
	twoRowsOfButtons
		addMorph: self customButtonRow proportionalHeight: 1.0.
	codeAndButtons := LinearLayoutMorph newColumn.
	codeAndButtons
		addMorph: twoRowsOfButtons fixedHeight: h;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations := LinearLayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16845944!
                       buildMorphicWindow
	"Open a full morphic debugger with the given label"

	| bottomMorph |
	bottomMorph := LinearLayoutMorph newRow.
	bottomMorph
		addMorph: self receiverInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: self receiverInspectorText proportionalWidth: 0.3;
		addAdjusterAndMorph: self contextVariableInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: self contextVariableInspectorText proportionalWidth: 0.3.

	self layoutMorph
		addMorph: self stackList proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55;
		addAdjusterAndMorph: bottomMorph proportionalHeight: 0.2.! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16845999!
   customButtonRow
	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"

	| button buttons row buttonColor |
	
	buttons := OrderedCollection new.
	buttonColor := self buttonColor.
	"button with target = self"
	button := PluggableButtonMorph 
		model: self
		action: #proceed.
	button color: buttonColor.
	button label: 'Proceed'.
	button setBalloonText: 'close the debugger and proceed.'.
	buttons add: button.
	"buttons with model target"
	self customButtonSpecs do: [ :tuple |
		button := PluggableButtonMorph 
					model: self
					action: tuple second.
		button color: buttonColor.
		button label: tuple first.
		tuple size > 2 ifTrue: [button setBalloonText: tuple third].
		buttons add: button].

	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons.
	^row! !
!MethodSetWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:19' prior: 16909092 overrides: 50351308!
            buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons := LinearLayoutMorph newColumn.
	(Preferences at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(Preferences at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations := LinearLayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!MessageNamesWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16902078 overrides: 16909129!
              buildMorphicWindow
	"Answer a morphic window with the given initial search string, nil if none"
	"MessageNames open"
	| selectorListView firstRow searchButton secondRow |
	textMorph := (TextModelMorph
		textProvider: model
		textGetter: #searchString
		textSetter: #searchString:
		selectionGetter: #contentsSelection)
		setBalloonText: 'See MessageNames class comment for search string options';
		emptyTextDisplayMessage: 'Type here, then hit Search'.
	textMorph askBeforeDiscardingEdits: false.
	textMorph acceptOnCR: true.
	textMorph hideScrollBarsIndefinitely.
	searchButton := PluggableButtonMorph new
		model: textMorph innerTextMorph;
		label: 'Search';
		action: #acceptContents.
	searchButton setBalloonText: 'Type some letters into the pane at right, and then press this Search button (or hit RETURN) and all method selectors that match what you typed will appear in the list pane below.  Click on any one of them, and all the implementors of that selector will be shown in the right-hand pane, and you can view and edit their code without leaving this tool.'.
	firstRow := LinearLayoutMorph newRow.
	firstRow color: self windowColor.
	firstRow
		doAdoptWidgetsColor;
		
			addMorph: searchButton
			proportionalWidth: 0.25;
		
			addMorph: textMorph
			proportionalWidth: 0.75.
	selectorListView := (PluggableListMorph
		withModel: model
		listGetter: #selectorList
		indexGetter: #selectorListIndex
		indexSetter: #selectorListIndex:)
			menuNshortcutsKey: #selectorListMenuSpec.
	secondRow := LinearLayoutMorph newRow.
	secondRow
		
			addMorph: selectorListView
			proportionalWidth: 0.5;
		
			addAdjusterAndMorph: self buildMorphicMessageList
			proportionalWidth: 0.5.
	self layoutMorph
		
			addMorph: firstRow
			fixedHeight: self defaultButtonPaneHeight + 4;
		
			addAdjusterAndMorph: secondRow
			proportionalHeight: 0.5;
		
			addAdjusterAndMorph: self buildLowerPanes
			proportionalHeight: 0.5.
	model changed: #editSelection! !
!ProtocolBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16940867 overrides: 16909129!
      buildMorphicWindow
	"Answer a morphic window that can display the receiver with a class hierarchy"
	| topRow |

	topRow := LinearLayoutMorph newRow.
	topRow 
		addMorph: self buildSelectiveClassList proportionalWidth: 0.25;
		addAdjusterMorph;
		addMorph: self buildCategoriesList proportionalWidth: 0.25;
		addAdjusterMorph;
		addMorph: self buildMorphicMessageList proportionalWidth: 0.5.
	self layoutMorph
		addMorph: topRow proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.8.
	model changed: #editSelection! !
!ChangeSelectorWizardStepWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:22' prior: 16807478 overrides: 50351757!
                    buildLowerPanes

	| codeAndButtons  |
	
	codeAndButtons := LinearLayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	
	^codeAndButtons ! !
!ChangeSelectorWizardStepWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:22' prior: 16807490!
                           buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.
	
	^row
	
	! !
!ExtractMethodReplacementsWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:22' prior: 16864168 overrides: 50351757!
          buildLowerPanes

	| codeAndButtons  |
	
	codeAndButtons := LinearLayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	
	^codeAndButtons ! !
!ExtractMethodReplacementsWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16864180!
                          buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.
	
	^row
	
	! !
!InlineMethodWizardStepWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16885109 overrides: 50351757!
             buildLowerPanes

	| codeAndButtons  |

	codeAndButtons := LinearLayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.

	^codeAndButtons ! !
!InlineMethodWizardStepWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16885121!
                               buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.

	^row

	! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:21' prior: 16985466 overrides: 50351757!
                           buildLowerPanes

	| codeAndButtons  |

	codeAndButtons := LinearLayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	
	^codeAndButtons ! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16985477!
          buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.
	
	^row
	
	! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16936010!
               buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons := OrderedCollection new.
	triads := OrderedCollection withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton := PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row := LinearLayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: `Color transparent`.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16868175!
      buildMorphicWindow
	| middleRow upperRow |
	upperRow := LinearLayoutMorph newRow.
	upperRow
		addMorph: self morphicPatternPane proportionalWidth: 0.3;
		addAdjusterAndMorph: self optionalButtonRow proportionalWidth: 0.7.
	middleRow := LinearLayoutMorph newRow.
	middleRow
		addMorph: self morphicDirectoryTreePane proportionalWidth: 0.3;
		addAdjusterAndMorph: self morphicFileListPane proportionalWidth: 0.7.
	self layoutMorph
		addMorph: upperRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterAndMorph: middleRow proportionalHeight: 0.4;
		addAdjusterAndMorph: self morphicFileContentsPane proportionalHeight: 0.6.
	self setLabel: model directory pathName.
	model postOpen! !
!FileListWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16868249!
                   optionalButtonRow
	"Answer the button row associated with a file list"

	| row buttonColor |
	row := LinearLayoutMorph newRow.
	buttonColor := self buttonColor.
	row setProperty: #buttonRow toValue: true.  "Used for dynamic retrieval later on"
	row doAdoptWidgetsColor.
	row color: buttonColor.
	self updateButtonRow: row.
	^row! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:22' prior: 16889122!
                       buildMorphicWindow
	" Inspector openOn: SystemOrganization "
	| contentsText list upperRow evaluatorText |

	"Build widgets. We'll assemble them below."
	list := self buildList.
	contentsText := self buildContentsText.
	evaluatorText := self buildEvaluatorText.
	
	"Upper row has two widgets, side by side: the list of variables at the left side, and the variable contents pane at the right side."
	upperRow := LinearLayoutMorph newRow.
	upperRow
		addMorph: list proportionalWidth: 0.3;
		addAdjusterAndMorph: contentsText proportionalWidth: 0.7.
	"Inspector Window has two rows: At the top, the one we just bult. Below it, the evaluation pane."
	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.7;
		addAdjusterAndMorph: evaluatorText proportionalHeight: 0.3.
	"Set label"
	self setLabel: model displayLabel! !
!ProcessBrowserWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:22' prior: 16939021!
      buildMorphicWindow
	"Create a pluggable version of me, answer a window"
	| aTextMorph list1 list2 upperRow |
	list1 := (PluggableListMorph
				withModel: model
				listGetter: #processNameList
				indexGetter: #processListIndex
				indexSetter: #processListIndex:)
					menuNshortcutsKey: #processListMenuSpec.
	list2 := (PluggableListMorph
				withModel: model
				listGetter: #stackNameList
				indexGetter: #stackListIndex
				indexSetter: #stackListIndex:)
					menuNshortcutsKey: #stackMenuSpec.
	upperRow := LinearLayoutMorph newRow.
	upperRow
		addMorph: list1 proportionalWidth: 0.5;
		addAdjusterAndMorph: list2 proportionalWidth: 0.5.
	aTextMorph := (TextModelMorph
				textProvider: model
				textGetter: #selectedMethod) emptyTextDisplayMessage: 'Method source (not selected?)'.
	aTextMorph askBeforeDiscardingEdits: false.
	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.5;
		addAdjusterAndMorph: aTextMorph proportionalHeight: 0.5.
	self setLabel: 'Process Browser'! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16986004!
                              buildLowerPanes
	| failuresList errorsList column |
	progress := ProgressMorph label: '' subLabel: ''.
	self buildPassFailText.
	self buildDetailsText.
	failuresList := self buildFailuresList.
	errorsList := self buildErrorsList.
	column := LinearLayoutMorph newColumn.
	column
		addMorph: progress fixedHeight: 50;
		addMorph: passFailText fixedHeight: 26;
		addMorph: detailsText fixedHeight: 52;
		addMorph: failuresList proportionalHeight: 0.6;
		addAdjusterAndMorph: errorsList proportionalHeight: 0.6.
	^ column! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 7/25/2025 09:28:20' prior: 16986109!
                         buildUpperControls
	| refreshButton filterButton stopButton runOneButton runButton runProfiledButton buttonsRow theTestsList column |

	runOneButton := self buildRunOneButton.
	runButton := self buildRunButton.
	runProfiledButton := self buildRunProfiledButton.	

	refreshButton := self buildRefreshButton.
	filterButton := self buildFilterButton.
	stopButton := self buildStopButton.

	theTestsList := (PluggableListMorphOfMany
				withModel: model
				listGetter: #tests
				primarySelectionGetter: #selectedSuite
				primarySelectionSetter: #selectedSuite:
				listSelectionGetter: #listSelectionAt:
				listSelectionSetter: #listSelectionAt:put:)
					menuNshortcutsKey: #listMenuSpec.
	theTestsList autoDeselect: false.
	theTestsList color: self textBackgroundColor.

	buttonsRow := LinearLayoutMorph newRow.
	buttonsRow doAdoptWidgetsColor.
	buttonsRow color: self buttonColor.
	buttonsRow
		addMorphs: {runButton. runOneButton. runProfiledButton};
		addMorphs: {refreshButton. filterButton. stopButton}.

	column := LinearLayoutMorph newColumn.
	column
		addMorph: theTestsList proportionalHeight: 1;
		addMorph: buttonsRow fixedHeight: self defaultButtonPaneHeight.

	^ column! !
!LayoutSpec methodsFor: 'private' stamp: 'jmv 7/25/2025 09:28:21' prior: 50342181!
         updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LinearLayoutMorph) ifTrue:
			[ owningLayout layoutSubmorphs ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7371-Rename-LayoutMorph-as-LinearLayoutMorph-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7370] on 25 July 2025 at 9:28:53 am'!

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7372-Add-LayoutMorph-asSuperclass-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st 7/27/2025 12:43:42'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7372-Add-LayoutMorph-asSuperclass-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st 7/27/2025 12:43:43'!
LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7372-Add-LayoutMorph-asSuperclass-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st 7/27/2025 12:43:43'!
LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7372-Add-LayoutMorph-asSuperclass-JuanVuletich-2025Jul25-09h28m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 9:41:55 am'!

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'adoptsWidgetsColor layoutObject '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7373-LayoutMorph-moveIvarsToSuperclass-p1-JuanVuletich-2025Jul25-09h34m-jmv.001.cs.st 7/27/2025 12:43:43'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'adoptsWidgetsColor layoutObject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:36:17'!
                        doAdoptWidgetsColor
	adoptsWidgetsColor := true.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:39:00' overrides: 16796268!
             initialize
	super initialize.
	adoptsWidgetsColor := false.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:40:21' prior: 50340743!
beColumn
	"Establish the major layout axis, with default edge weight"
	layout := ColumnLayout new.
	layout gap: self defaultGap.
	layoutObject := layout.
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:40:17' prior: 50340751!
           beRow
	"Establish the major layout axis, with default edge weight"
	layout := RowLayout new.
	layout gap: self defaultGap.
	layoutObject := layout.
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:36:25' prior: 16896728 overrides: 50352238!
                             doAdoptWidgetsColor
	super doAdoptWidgetsColor.
	doAdoptWidgetsColor := true! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:39:57' prior: 50341993!
               initializeColumn

	layout := ColumnLayout new.
	layout gap: self defaultGap.
	layoutObject := layout.
	doAdoptWidgetsColor := false.
	self initialize.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:40:10' prior: 50342528!
     initializeForm

	layout := FormLayout new.
	layoutObject := layout.
	doAdoptWidgetsColor := false.
	self initialize.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:40:06' prior: 50342000!
       initializeRow

	layout := RowLayout new.
	layout gap: self defaultGap.
	layoutObject := layout.
	doAdoptWidgetsColor := false.
	self initialize.! !

BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'adoptsWidgetsColor layoutObject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7373-LayoutMorph-moveIvarsToSuperclass-p1-JuanVuletich-2025Jul25-09h34m-jmv.001.cs.st 7/27/2025 12:43:43'!
BorderedBoxMorph subclass: #LayoutMorph
	instanceVariableNames: 'adoptsWidgetsColor layoutObject'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
LayoutMorph allSubInstancesDo: [ :m |
	m instVarNamed: 'adoptsWidgetsColor' put: (m instVarNamed: 'doAdoptWidgetsColor').
	m instVarNamed: 'layoutObject' put: (m instVarNamed: 'layout') ].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7373-LayoutMorph-moveIvarsToSuperclass-p1-JuanVuletich-2025Jul25-09h34m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 9:47:28 am'!
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:46:17' prior: 16896317 overrides: 16910416!
                         adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	adoptsWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: color) ]
		ifFalse: [ self color: `Color transparent` ]! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:45:18' prior: 50342731!
                           axisEdgeWeight
	"Only for Linear Layouts"
	^layoutObject isLinearLayout ifTrue: [
		layoutObject axisEdgeWeight ]! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:45:23' prior: 50341923!
               axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }
	
	Ignored for other kinds of Layouts"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	layoutObject isLinearLayout ifTrue: [
		layoutObject axisEdgeWeight: aSymbolOrNumber.
		self layoutSubmorphs ].! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:45:28' prior: 50342654!
               gap
	"Only for Linear Layouts"
	^layoutObject isLinearLayout ifTrue: [
		layoutObject gap ]! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:45:36' prior: 50341948!
     gap: aNumber
	"Only for Linear Layouts"
	layoutObject isLinearLayout ifTrue: [
		layoutObject gap = aNumber ifFalse: [
			self adjustExtentFor: [
				layoutObject gap: aNumber ]].
		self layoutSubmorphs ].! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:43:31' prior: 50341965!
                   separation: aNumberOrPoint
	"Only for Linear Layouts"

	| g |
	layoutObject isLinearLayout ifTrue: [
		self padding: aNumberOrPoint.
		g := aNumberOrPoint.
		g isPoint ifTrue: [
			g := layoutObject isRow ifTrue: [ g x ] ifFalse: [ g y ]].
		self gap: g ].! !
!LinearLayoutMorph methodsFor: 'adjust' stamp: 'jmv 7/25/2025 09:45:12' prior: 50341207!
   adjustBy: aLayoutAdjustMorph at: aGlobalPoint
	"See Class Comment of LayoutAdjustingMorph"

	| localPoint  i before after adjusterRefPos |
	localPoint := self internalizeFromWorld: aGlobalPoint.
	i := submorphs indexOf: aLayoutAdjustMorph.
	((i = 1) or: [i = self submorphs size]) ifTrue: [
		self inform: 'LayoutAdjustingMorphs require morphs before and after'.
		^self ].
	before := self submorphs at: i +1.
	after := self submorphs at: i - 1.
	adjusterRefPos := aLayoutAdjustMorph referencePositionInOwner.
	(layoutObject adjustMorphBefore: before morphAfter: after adjusterRefPos: adjusterRefPos at: localPoint)
		ifTrue: [
			self layoutSubmorphs ].! !
!LinearLayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 09:43:35' prior: 50341544 overrides: 16796315!
                               minimumExtent
	"Answer size sufficient to frame my submorphs."
	
	^ (layoutObject minimumExtentFor: submorphs cachedValues: IdentityDictionary new) + (2 * self interiorOrigin)! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:43:24' prior: 50352248!
            beColumn
	"Establish the major layout axis, with default edge weight"
	layoutObject := ColumnLayout new.
	layoutObject gap: self defaultGap.
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:43:18' prior: 50352257!
                        beRow
	"Establish the major layout axis, with default edge weight"
	layoutObject := RowLayout new.
	layoutObject gap: self defaultGap.
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:46:38' prior: 50352273!
                              initializeColumn

	layoutObject := ColumnLayout new.
	layoutObject gap: self defaultGap.
	self initialize.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:46:47' prior: 50352281!
                 initializeForm

	layoutObject := FormLayout new.
	self initialize.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:46:50' prior: 50352288!
                         initializeRow

	layoutObject := RowLayout new.
	layoutObject gap: self defaultGap.
	self initialize.! !
!LinearLayoutMorph methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:43:44' prior: 50341416!
                               layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self ].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.

	layoutObject layoutMorphs: submorphs in: self layoutBounds.
	self layoutNeeded: false.! !
!LinearLayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 09:45:06' prior: 50340759!
                               addAdjusterMorph
	"So the user can adjust layout"

	| thickness |
	thickness := Theme current layoutAdjusterThickness.

	layoutObject isRow ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedWidth: thickness) ].

	layoutObject isColumn ifTrue: [
		self
			addMorph: LayoutAdjustingMorph new
			layoutSpec: (LayoutSizeSpec fixedHeight: thickness)]! !
!LinearLayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 09:45:40' prior: 50342659!
isColumn
	"Only makes sense for Linear Layouts"
	^layoutObject isColumn! !
!LinearLayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 09:45:43' prior: 50342664!
                           isRow
	"Only makes sense for Linear Layouts"
	^layoutObject isRow! !

LinearLayoutMorph removeSelector: #doAdoptWidgetsColor!

!methodRemoval: LinearLayoutMorph #doAdoptWidgetsColor stamp: 'Install-7374-LayoutMorph-moveIvarsToSuperclass-p2-JuanVuletich-2025Jul25-09h41m-jmv.001.cs.st 7/27/2025 12:43:43'!
doAdoptWidgetsColor
	super doAdoptWidgetsColor.
	doAdoptWidgetsColor := true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7374-LayoutMorph-moveIvarsToSuperclass-p2-JuanVuletich-2025Jul25-09h41m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 9:47:48 am'!

LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7375-LayoutMorph-moveIvarsToSuperclass-p3-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:43:43'!
LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: 'doAdoptWidgetsColor layout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #LinearLayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7375-LayoutMorph-moveIvarsToSuperclass-p3-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:43:43'!
LayoutMorph subclass: #LinearLayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7375-LayoutMorph-moveIvarsToSuperclass-p3-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 9:54:58 am'!
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 09:48:16' overrides: 16910416!
  adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	adoptsWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: color) ]
		ifFalse: [ self color: `Color transparent` ]! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 09:52:40' overrides: 16796315!
                              minimumExtent
	"Ojo!!"
	^100@100! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:50:41'!
                         layoutBounds
	"Return the bounds for laying out children of the receiver"

	^ self interiorOrigin extent: self interiorExtent ! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 7/25/2025 09:50:22'!
                           layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self ].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.

	layoutObject layoutMorphs: submorphs in: self layoutBounds.
	self layoutNeeded: false.! !
!LinearLayout methodsFor: 'services' stamp: 'jmv 7/25/2025 09:53:25' overrides: 50342176!
            minimumExtentFor: morphs cachedValues: cachedValues
	self subclassResponsibility ! !

FormLayout removeSelector: #minimumExtentFor:cachedValues:!

!methodRemoval: FormLayout #minimumExtentFor:cachedValues: stamp: 'Install-7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:43:43'!
minimumExtentFor: morphs cachedValues: cachedValues
	"Ojo!!"
	^100@100!

Layout removeSelector: #minimumExtentFor:cachedValues:!

!methodRemoval: Layout #minimumExtentFor:cachedValues: stamp: 'Install-7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:43:43'!
minimumExtentFor: morphs cachedValues: cachedValues
	self subclassResponsibility !

LinearLayoutMorph removeSelector: #adoptWidgetsColor:!

!methodRemoval: LinearLayoutMorph #adoptWidgetsColor: stamp: 'Install-7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:43:43'!
adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	adoptsWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: color) ]
		ifFalse: [ self color: `Color transparent` ]!

LinearLayoutMorph removeSelector: #layoutSubmorphs!

!methodRemoval: LinearLayoutMorph #layoutSubmorphs stamp: 'Install-7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:43:43'!
layoutSubmorphs
	"Compute a new layout based on the given layout bounds."

	submorphs isEmpty ifTrue: [
		self layoutNeeded: false.
		^self ].

	"Invariant: morphExtent >=  minimumLayoutExtent"
	self adjustExtentFor: nil.

	layoutObject layoutMorphs: submorphs in: self layoutBounds.
	self layoutNeeded: false.!

LinearLayoutMorph removeSelector: #layoutBounds!

!methodRemoval: LinearLayoutMorph #layoutBounds stamp: 'Install-7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st 7/27/2025 12:43:43'!
layoutBounds
	"Return the bounds for laying out children of the receiver"

	^ self interiorOrigin extent: self interiorExtent !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7376-LayoutMorph-pushToSuperclass-JuanVuletich-2025Jul25-09h47m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 10:01:19 am'!

LayoutMorph subclass: #FormLayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!

!classDefinition: #FormLayoutMorph category: #'Morphic-Layouts' stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
LayoutMorph subclass: #FormLayoutMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Layouts'!
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 09:56:26' overrides: 16914787!
                  initializedInstance

	^LinearLayoutMorph newRow! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 09:57:23' overrides: 16787643!
     new

	^self error: 'Use LayoutMorph #newRow, #newColumn or #newForm'.! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 09:58:04'!
   newColumn
	^LinearLayoutMorph basicNew initializeColumn! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 09:56:48'!
                 newForm
	^FormLayoutMorph basicNew initializeForm! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 09:58:09'!
                       newRow
	^LinearLayoutMorph basicNew initializeRow! !
!LayoutMorph class methodsFor: 'new-morph participation' stamp: 'jmv 7/25/2025 09:58:18' overrides: 16796976!
                             categoryInNewMorphMenu
	^ 'Layouts'! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
 example1
"
	self example1
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
                           example10
"
	self example10 openInWorld
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example10.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
^ pane! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
                example101VG
"
	self example101VG
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (Sample09Clock new name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 100); 
	addMorph: (Sample01Star new name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample03Smiley new name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (Sample03Smiley new name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color lightRed;
	addMorph: (Sample02Bezier new name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample02Bezier new  name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (Sample02Bezier new  name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
                   example11
"
	self example11
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example11.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
          example13
	"
	self example13
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
                            example1b
"
Based on #example1, but using some ImageMorph instead of RectangleLikeMorph, so extent is not adjustable
	self example1b
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ImageMorph new name: #B);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ImageMorph new name: #G);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ImageMorph new name: #J);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
                 example2
	"
	self example2
	"
	| pane row |
	pane := (LinearLayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8 offAxisEdgeWeight: #rightOrBottom);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 0.7 offAxisEdgeWeight: #center).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 200@180 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:38'!
           example20
"
	self example20
"
| column |

column := (LinearLayoutMorph newColumn separation: 5) name: #Column.
column
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 30).
column position: 150@130 extent: 400@300.
column openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
                              example3
	"
	self example3
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
   example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane := LinearLayoutMorph newRow separation: 5. "1"
pane addMorph: (LabelMorph contents: '1').

rect1 := ColoredBoxMorph new color: (Color lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Color lightGreen;
	position: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane := LinearLayoutMorph newRow separation: 5. "2"
pane addMorph: (LabelMorph contents: '2').

rect1 := ColoredBoxMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane
	color: Color lightGreen;
	position: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane := LinearLayoutMorph newRow separation: 5. "3"
pane addMorph: (LabelMorph contents: '3').

rect1 := ColoredBoxMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
rect2 := ColoredBoxMorph new color: (Color cyan);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	position: 520 @ 50 extent: 180 @ 100;
	openInWorld! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
                    example7
	"
	Useful example contributed by Ken Dickey
	self example7
	"
	"============================================"
	| c colorHexValue colorName r w |
	w := SystemWindow new.
	r := LinearLayoutMorph newRow separation: 30 @ 10.
	c := LinearLayoutMorph newColumn separation: 20 @ 10.
	colorHexValue := LabelMorph contents:  'F97306'.
	colorName := LabelMorph contents: 'cornSilk'.

	r addMorph: colorHexValue.
	r addMorph: colorName.
	c addMorph: ColoredBoxMorph new.
	c addMorph: r.
	w addMorph: c .
	w openInWorld.
	"============================================"! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
              exampleEdgesColumn
	"Show 2 cases :1 useEdgeSpace true and 1 false"
	" self exampleEdgesColumn "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newColumn :: padding: (120 @ 40);  gap: 20.
	noEdge := self newColumn ::  padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 200; proportionalHeight: 0.8 minimum: 200.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 200; proportionalHeight: 0.5 minimum: 200.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
                     exampleEdgesRow
	"Show 2 cases: 1 useEdgeSpace true and 1 false"
	" self exampleEdgesRow "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newRow :: padding: (120 @ 40);  gap: 20.
	noEdge := self newRow :: padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 100; proportionalHeight: 0.8 minimum: 100.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 100; proportionalHeight: 0.5 minimum: 100.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
  iconsExample
	"
	LayoutMorph iconsExample
	"
	| lm ilm counter |
	lm := LinearLayoutMorph newColumn.
	ilm := LinearLayoutMorph newRow.
	counter := 1.
	Theme methodsDo: [ :method | | sel | 
		(sel := method selector) numArgs = 0 ifTrue: [
			(sel endsWith: 'Icon') ifTrue: [ | mayBeForm |
				mayBeForm := Theme current perform: sel.
				(mayBeForm isKindOf: Form) ifTrue: [ | imageMorph |
					counter \\ 10 = 0 ifTrue: [
						lm addMorph: ilm.
						ilm := LinearLayoutMorph newRow ].
					counter := counter + 1.
					ilm addMorph: (imageMorph := ImageMorph newWith: (mayBeForm magnifyBy: 2)).
					imageMorph 
						setBalloonText: 'Copy ''', sel storeString bold, ''' to the Clipboard';
						setProperty: #'handlesMouseDown:' toValue: true;
						setProperty: #mouseButton1Down:localPosition:  toValue: [ :event :pos |
							Clipboard storeObject: sel storeString ] ] ] ] ].
	lm 
		setProperty: #taskbarButtonIcon toValue: Theme current imageIcon;
		setBalloonText: 'Drag me here!!'.
	lm openInWorld
! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 09:58:39'!
                     launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random := Random new.
	b1 := PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 := PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 := PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 := PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons := {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: `Color lightRed` ].
	row := LinearLayoutMorph newRow
		 color: `Color red`;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!LayoutMorph class methodsFor: 'FormLayout examples' stamp: 'jmv 7/25/2025 09:59:06'!
  example1Form
"
	self example1Form
"
	| pane |
	pane := (FormLayoutMorph newForm separation: 5) name: #example1.
	pane 
		color: Color red;
		addMorph: (ColoredBoxMorph new color: (Color lightBlue); name: #A)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@20 brEdgesWeight: 0@0 offset: 100@40);
		addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 30@20 brEdgesWeight: 1@0 offset: -30@40);
		addMorph: (ColoredBoxMorph new color: (Color lightGreen); name: #C)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@60 brEdgesWeight: 0.5@0 offset: -10@140);
		addMorph: (ColoredBoxMorph new color: (Color green); name: #D)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 10@60 brEdgesWeight: 1@0 offset: -30@140);
		addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@160 brEdgesWeight: 1@1 offset: -30@ -30).
	pane position: 150@130 extent: 400@300.
	pane openInWorld! !
!FormLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 09:55:25'!
         initializeForm

	layoutObject := FormLayout new.
	self initialize.! !

LinearLayoutMorph class removeSelector: #example13!

!methodRemoval: LinearLayoutMorph class #example13 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example13
	"
	self example13
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSizeSpec fixedWidth: 5); 
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld!

LinearLayoutMorph class removeSelector: #newRow!

!methodRemoval: LinearLayoutMorph class #newRow stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
newRow
	^self basicNew initializeRow!

LinearLayoutMorph class removeSelector: #newForm!

!methodRemoval: LinearLayoutMorph class #newForm stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
newForm
	^self basicNew initializeForm!

LinearLayoutMorph class removeSelector: #example1b!

!methodRemoval: LinearLayoutMorph class #example1b stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example1b
"
Based on #example1, but using some ImageMorph instead of RectangleLikeMorph, so extent is not adjustable
	self example1b
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ImageMorph new name: #B);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ImageMorph new name: #G);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ImageMorph new name: #J);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld!

LinearLayoutMorph class removeSelector: #exampleEdgesRow!

!methodRemoval: LinearLayoutMorph class #exampleEdgesRow stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
exampleEdgesRow
	"Show 2 cases: 1 useEdgeSpace true and 1 false"
	" self exampleEdgesRow "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newRow :: padding: (120 @ 40);  gap: 20.
	noEdge := self newRow :: padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 100; proportionalHeight: 0.8 minimum: 100.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 100; proportionalHeight: 0.5 minimum: 100.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.!

LinearLayoutMorph class removeSelector: #example11!

!methodRemoval: LinearLayoutMorph class #example11 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example11
"
	self example11
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example11.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld!

LinearLayoutMorph class removeSelector: #exampleEdgesColumn!

!methodRemoval: LinearLayoutMorph class #exampleEdgesColumn stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
exampleEdgesColumn
	"Show 2 cases :1 useEdgeSpace true and 1 false"
	" self exampleEdgesColumn "
	| withEdge noEdge upSpec downSpec |
	withEdge := self newColumn :: padding: (120 @ 40);  gap: 20.
	noEdge := self newColumn ::  padding: (0 @ 0);  gap: 20.
	upSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 0.
	upSpec proportionalWidth: 0.8 minimum: 200; proportionalHeight: 0.8 minimum: 200.
	downSpec := LayoutSizeSpec keepMorphExtent :: offAxisEdgeWeight: 1.
	downSpec proportionalWidth: 0.5 minimum: 200; proportionalHeight: 0.5 minimum: 200.
	
	withEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	noEdge addMorph: (ColoredBoxMorph new :: color: Color blue;  layoutSpec: upSpec).
	withEdge addMorph: (LabelMorph new :: contents: 'WITH Padding').
	noEdge addMorph: (LabelMorph new :: contents: 'withOUT Padding').
	withEdge addMorph: (ColoredBoxMorph new :: layoutSpec: downSpec).
	noEdge addMorph: (ColoredBoxMorph new ::  layoutSpec: downSpec).
	
	withEdge openInWorld.
	noEdge openInWorld.!

LinearLayoutMorph class removeSelector: #example1!

!methodRemoval: LinearLayoutMorph class #example1 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example1
"
	self example1
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld!

LinearLayoutMorph class removeSelector: #example1Form!

!methodRemoval: LinearLayoutMorph class #example1Form stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example1Form
"
	self example1Form
"
	| pane |
	pane := (LinearLayoutMorph newForm separation: 5) name: #example1.
	pane 
		color: Color red;
		addMorph: (ColoredBoxMorph new color: (Color lightBlue); name: #A)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@20 brEdgesWeight: 0@0 offset: 100@40);
		addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 30@20 brEdgesWeight: 1@0 offset: -30@40);
		addMorph: (ColoredBoxMorph new color: (Color lightGreen); name: #C)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@60 brEdgesWeight: 0.5@0 offset: -10@140);
		addMorph: (ColoredBoxMorph new color: (Color green); name: #D)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 10@60 brEdgesWeight: 1@0 offset: -30@140);
		addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@160 brEdgesWeight: 1@1 offset: -30@ -30).
	pane position: 150@130 extent: 400@300.
	pane openInWorld!

LinearLayoutMorph class removeSelector: #launcherExample!

!methodRemoval: LinearLayoutMorph class #launcherExample stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random := Random new.
	b1 := PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 := PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 := PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 := PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons := {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: `Color lightRed` ].
	row := LinearLayoutMorph newRow
		 color: `Color red`;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld!

LinearLayoutMorph class removeSelector: #example101VG!

!methodRemoval: LinearLayoutMorph class #example101VG stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example101VG
"
	self example101VG
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (Sample09Clock new name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 100); 
	addMorph: (Sample01Star new name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample03Smiley new name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (Sample03Smiley new name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color lightRed;
	addMorph: (Sample02Bezier new name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample02Bezier new  name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (Sample02Bezier new  name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 400@300.
pane openInWorld!

LinearLayoutMorph class removeSelector: #example20!

!methodRemoval: LinearLayoutMorph class #example20 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example20
"
	self example20
"
| column |

column := (LinearLayoutMorph newColumn separation: 5) name: #Column.
column
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 30).
column position: 150@130 extent: 400@300.
column openInWorld!

LinearLayoutMorph class removeSelector: #iconsExample!

!methodRemoval: LinearLayoutMorph class #iconsExample stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
iconsExample
	"
	LayoutMorph iconsExample
	"
	| lm ilm counter |
	lm := LinearLayoutMorph newColumn.
	ilm := LinearLayoutMorph newRow.
	counter := 1.
	Theme methodsDo: [ :method | | sel | 
		(sel := method selector) numArgs = 0 ifTrue: [
			(sel endsWith: 'Icon') ifTrue: [ | mayBeForm |
				mayBeForm := Theme current perform: sel.
				(mayBeForm isKindOf: Form) ifTrue: [ | imageMorph |
					counter \\ 10 = 0 ifTrue: [
						lm addMorph: ilm.
						ilm := LinearLayoutMorph newRow ].
					counter := counter + 1.
					ilm addMorph: (imageMorph := ImageMorph newWith: (mayBeForm magnifyBy: 2)).
					imageMorph 
						setBalloonText: 'Copy ''', sel storeString bold, ''' to the Clipboard';
						setProperty: #'handlesMouseDown:' toValue: true;
						setProperty: #mouseButton1Down:localPosition:  toValue: [ :event :pos |
							Clipboard storeObject: sel storeString ] ] ] ] ].
	lm 
		setProperty: #taskbarButtonIcon toValue: Theme current imageIcon;
		setBalloonText: 'Drag me here!!'.
	lm openInWorld
!

LinearLayoutMorph class removeSelector: #new!

!methodRemoval: LinearLayoutMorph class #new stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
new

	^self error: 'Use LayoutMorph newRow or LayoutMorph newColumn'.!

LinearLayoutMorph class removeSelector: #example6!

!methodRemoval: LinearLayoutMorph class #example6 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane := LinearLayoutMorph newRow separation: 5. "1"
pane addMorph: (LabelMorph contents: '1').

rect1 := ColoredBoxMorph new color: (Color lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Color lightGreen;
	position: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane := LinearLayoutMorph newRow separation: 5. "2"
pane addMorph: (LabelMorph contents: '2').

rect1 := ColoredBoxMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect1.
rect2 := ColoredBoxMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane
	color: Color lightGreen;
	position: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane := LinearLayoutMorph newRow separation: 5. "3"
pane addMorph: (LabelMorph contents: '3').

rect1 := ColoredBoxMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
rect2 := ColoredBoxMorph new color: (Color cyan);
	layoutSpec: (LayoutSizeSpec  fixedWidth: 20 fixedHeight: 30 offAxisEdgeWeight: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	position: 520 @ 50 extent: 180 @ 100;
	openInWorld!

LinearLayoutMorph class removeSelector: #categoryInNewMorphMenu!

!methodRemoval: LinearLayoutMorph class #categoryInNewMorphMenu stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
categoryInNewMorphMenu
	^ 'Layouts'!

LinearLayoutMorph class removeSelector: #example10!

!methodRemoval: LinearLayoutMorph class #example10 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example10
"
	self example10 openInWorld
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example10.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
^ pane!

LinearLayoutMorph class removeSelector: #example7!

!methodRemoval: LinearLayoutMorph class #example7 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example7
	"
	Useful example contributed by Ken Dickey
	self example7
	"
	"============================================"
	| c colorHexValue colorName r w |
	w := SystemWindow new.
	r := LinearLayoutMorph newRow separation: 30 @ 10.
	c := LinearLayoutMorph newColumn separation: 20 @ 10.
	colorHexValue := LabelMorph contents:  'F97306'.
	colorName := LabelMorph contents: 'cornSilk'.

	r addMorph: colorHexValue.
	r addMorph: colorName.
	c addMorph: ColoredBoxMorph new.
	c addMorph: r.
	w addMorph: c .
	w openInWorld.
	"============================================"!

LinearLayoutMorph class removeSelector: #initializedInstance!

!methodRemoval: LinearLayoutMorph class #initializedInstance stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
initializedInstance

	^self newRow!

LinearLayoutMorph class removeSelector: #newColumn!

!methodRemoval: LinearLayoutMorph class #newColumn stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
newColumn
	^self basicNew initializeColumn!

LinearLayoutMorph class removeSelector: #example3!

!methodRemoval: LinearLayoutMorph class #example3 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example3
	"
	self example3
	"
	| pane row innerRow |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	innerRow := (LinearLayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (ColoredBoxMorph new name: #Box1)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Box2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (ColoredBoxMorph new name: #Bar)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 30 offAxisEdgeWeight: #center);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.5 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 250@130 extent: 400@300.
	pane openInWorld!

LinearLayoutMorph class removeSelector: #example2!

!methodRemoval: LinearLayoutMorph class #example2 stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
example2
	"
	self example2
	"
	| pane row |
	pane := (LinearLayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Color red.
	row := (LinearLayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8 offAxisEdgeWeight: #rightOrBottom);
		addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8 fixedHeight: 40 offAxisEdgeWeight: #leftOrTop);
		addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 0.7 offAxisEdgeWeight: #center).
	pane addMorph: row layoutSpec: (LayoutSizeSpec proportionalHeight: 0.9).
	pane position: 200@180 extent: 400@300.
	pane openInWorld!

LinearLayoutMorph removeSelector: #initializeForm!

!methodRemoval: LinearLayoutMorph #initializeForm stamp: 'Install-7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st 7/27/2025 12:43:43'!
initializeForm

	layoutObject := FormLayout new.
	self initialize.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7377-LayoutMorph-pushToSuperclass-FormLayoutMorph-JuanVuletich-2025Jul25-09h54m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 10:09:54 am'!
!FormLayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 10:03:33' overrides: 50352243!
                        initialize

	super initialize.
	layoutObject := FormLayout new.! !
!LinearLayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:02:00' overrides: 50352708!
               newColumn
	^self basicNew initializeColumn! !
!LinearLayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:02:11' overrides: 50352718!
    newRow
	^self basicNew initializeRow! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:02:53' prior: 50352698 overrides: 16914787!
initializedInstance
	^LinearLayoutMorph newRow! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:02:21' prior: 50352708!
          newColumn
	^LinearLayoutMorph newColumn! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:01:35' prior: 50352713!
                 newForm
	^FormLayoutMorph new! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 7/25/2025 10:02:27' prior: 50352718!
                           newRow
	^LinearLayoutMorph newRow! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:08:10' prior: 50352346!
                               axisEdgeWeight
	"Only for Linear Layouts"
	^layoutObject axisEdgeWeight! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:08:27' prior: 50352353!
                         axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }
	
	Ignored for other kinds of Layouts"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	layoutObject axisEdgeWeight: aSymbolOrNumber.
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:08:39' prior: 50352379!
                          gap
	"Only for Linear Layouts"
	^layoutObject gap! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:08:49' prior: 50352385!
               gap: aNumber
	"Only for Linear Layouts"
	layoutObject gap = aNumber ifFalse: [
		self adjustExtentFor: [
			layoutObject gap: aNumber ]].
	self layoutSubmorphs.! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:08:57' prior: 50352395!
separation: aNumberOrPoint
	"Only for Linear Layouts"

	| g |
	self padding: aNumberOrPoint.
	g := aNumberOrPoint.
	g isPoint ifTrue: [
		g := layoutObject isRow ifTrue: [ g x ] ifFalse: [ g y ]].
	self gap: g.! !

LinearLayout removeSelector: #isLinearLayout!

!methodRemoval: LinearLayout #isLinearLayout stamp: 'Install-7378-LayoutMorph-moveMethodsAroundHierarchy-JuanVuletich-2025Jul25-10h01m-jmv.001.cs.st 7/27/2025 12:43:43'!
isLinearLayout
	^true!

Layout removeSelector: #isLinearLayout!

!methodRemoval: Layout #isLinearLayout stamp: 'Install-7378-LayoutMorph-moveMethodsAroundHierarchy-JuanVuletich-2025Jul25-10h01m-jmv.001.cs.st 7/27/2025 12:43:43'!
isLinearLayout
	^false!

FormLayoutMorph class removeSelector: #new!

FormLayoutMorph removeSelector: #initializeForm!

!methodRemoval: FormLayoutMorph #initializeForm stamp: 'Install-7378-LayoutMorph-moveMethodsAroundHierarchy-JuanVuletich-2025Jul25-10h01m-jmv.001.cs.st 7/27/2025 12:43:43'!
initializeForm

	layoutObject := FormLayout new.
	self initialize.!

LayoutMorph class removeSelector: #new!

!methodRemoval: LayoutMorph class #new stamp: 'Install-7378-LayoutMorph-moveMethodsAroundHierarchy-JuanVuletich-2025Jul25-10h01m-jmv.001.cs.st 7/27/2025 12:43:43'!
new

	^self error: 'Use LayoutMorph #newRow, #newColumn or #newForm'.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7378-LayoutMorph-moveMethodsAroundHierarchy-JuanVuletich-2025Jul25-10h01m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 10:32:00 am'!
!LinearLayoutMorph commentStamp: 'jmv 7/25/2025 10:14:16' prior: 16896260!
      A row or column of Morphs, does layout by placing them along either a horizontal axis or a vertical axis.

Submorphs might specify a LayoutSpec. If some don't, then, for a column, the column width is taken as the width, and any morph height is kept. Same for rows: submorph width would be maintained, and submorph height would be made equal to row height.

Notes:
  - Contained submorphs may have fixed or minimum sizes.
  - We can specify fixed separation.
  - We can offset to left or right.
  - Contained submorphs can, via LayoutSizeSpecs, ask for a proportion of
    the space which is left over after the minimum extent.

  One subtlety with the proportional layouts is that the sum of
  proportions may add up to more than 100%.

  We want to allocate fairly.

  Say we have 2 submorphs which ask for 80% and 50%.

  They should be normalized to get 80/130 and 50/130 of the excess space.

Instance Variables:
  direction - either #horizontal (row) or #vertical (column).
  gap - Empty space between Morphs:
	gap for both x and y axes or a point: (xGap @ yGap)
  axisEdgeWeight  - Along the Major or Layout Axis, subMorphs may be attracted 
	toward one side (0.0) or the other (1.0).  
	See comment in method #axisEdgeWeight:
  doAdoptWidgetsColor - see method #adoptWidgetsColor:
  useEdgeSpace - When true, x and y separation are kept between submorphs and the
	edge of our extent, othersize no space is kept between submorphs 
	and our outer edge.

!
!LayoutSizeSpec commentStamp: 'jmv 7/25/2025 10:15:05' prior: 16897948!
   LayoutSizeSpecs are the basis for the LinearLayout mechanism. Any Morph can be given a LayoutSizeSpecs, but in order to honor it, its owner must be a LinearLayout.

A LayoutSpec specifies how a morph wants to be layed out. In particular, a LayoutSizeSpec It can specify either a fixed width or a fraction of some available owner width. Same goes for height. If a fraction is specified, a minimum extent is also possible.


Alternatives:
	- proportionalWidth notNil, fixedWidth notNil	->		Use fraction of available space, take fixedWidth as minimum desired width
	- proportionalWidth isNil, fixedWidth isNil		->		Use current morph width
	- proportionalWidth isNil, fixedWidth notNil	->		Use fixedWidth
	- proportionalWidth notNil, fixedWidth isNil	->		NOT VALID

Same goes for proportionalHeight and fixedHeight
!
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:12:04' overrides: 16913987!
                         addMorphFrontFromWorldPosition: aMorph

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	self addMorphFront: aMorph.
	self layoutSubmorphs.
! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:25:51' overrides: 16796227!
                       borderWidth: anInteger

	super borderWidth: anInteger.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 7/25/2025 10:26:00' overrides: 16796238!
                     padding: numberOrPoint
	"Honored by all kinds of Layouts"

	super padding: numberOrPoint.
	self layoutSubmorphs.! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 10:22:13' overrides: 16796251!
             defaultBorderWidth
	"answer the default border width for the receiver"
	^ 0! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 10:22:17' overrides: 16796256!
                  defaultColor
	^ Theme current defaultWindowColor! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 10:22:21'!
 defaultGap
	"Answer the default gap between submorphs for the receiver.
	Redefine this method for a different initial gap in your morphs.
	Only for Linear Layouts"

	^ 0! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 7/25/2025 10:22:28'!
        doClipSubmorphs
	self setProperty: #doClipSubmorphs toValue: true.! !
!LayoutMorph methodsFor: 'drawing' stamp: 'jmv 7/25/2025 10:18:14' overrides: 16796275!
  drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."

	aCanvas
		fillRectangle: self localBounds
		color: color
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor.! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 7/25/2025 10:21:30' overrides: 16913170!
                    layoutSubmorphsIfNeeded
	"Recompute the layout if necessary."

	self isLayoutNeeded ifTrue: [
		self layoutSubmorphs ].! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 10:23:03' overrides: 16796596!
            extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	self layoutNeeded: true.! !
!LayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 10:24:35' overrides: 16913216!
                            someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	self layoutNeeded: true.! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 10:11:13'!
  addMorph: aMorph layoutSpec: aLayoutSpec
	"Add a submorph, at the bottom or right, with aLayoutSpec"

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec: aLayoutSpec.
	self addMorphFront: aMorph.! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 10:11:49' overrides: 16913949!
                         addMorphBack: aMorph
	"Add a submorph, at the top or left, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	super addMorphBack: aMorph.! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 10:11:13' overrides: 16913968!
                               addMorphFront: aMorph
	"Add a submorph, at the bottom or right, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	super addMorphFront: aMorph! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 10:21:22' overrides: 16914094!
                          removedMorph: aMorph
	"One of my submorphs has been removed."

	super removedMorph: aMorph.
	self layoutSubmorphs! !
!LayoutMorph methodsFor: 'private' stamp: 'jmv 7/25/2025 10:12:09' overrides: 16914517!
                   privateAddAllMorphs: aCollection atIndex: index

	aCollection do: [ :m |
		m isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
		m layoutSpec ].
	^ super privateAddAllMorphs: aCollection atIndex: index.! !
!LayoutMorph methodsFor: 'private' stamp: 'jmv 7/25/2025 10:12:13' overrides: 16914561!
                         privateAddMorph: aMorph atIndex: index position: aPoint

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	^ super privateAddMorph: aMorph atIndex: index position: aPoint.! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 10:20:23' overrides: 16796324!
                           is: aSymbol
	^ aSymbol == #LayoutMorph or: [ super is: aSymbol ]! !
!LayoutMorph methodsFor: 'geometry testing' stamp: 'jmv 7/25/2025 10:18:45' overrides: 16912677!
                           clipsSubmorphs
	"LayoutMorphs usually not do not clip submorphs.
	A special case is Transcript. It doesn't include a ScrollPane (that usually does clipping).
	Note: for this to work, we can't be transparent, as transparent morphs can't clip submorphs.
		Senders may also call #doAdoptWidgetsColor.
	There may be other similar cases in the future."

	^self hasProperty: #doClipSubmorphs.! !
!LayoutMorph methodsFor: 'layout in owner' stamp: 'jmv 7/25/2025 10:19:11' overrides: 50338406!
                          layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec useAll.
	layoutSpec morph: self.

	^ layoutSpec ! !
!FormLayoutMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 10:24:13' overrides: 50352585!
              minimumExtent
	"Ojo!!"
	^100@100! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 10:13:48' prior: 50342190!
       allocHeightForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSizeSpecs (to be used in LinearLayoutMorphs) may specify
	proportional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minHeight
	so breakeven is when
	  amountToAlloc = minHeight / proportion * factor"
	| minHeight |
	minHeight := (self minimumLayoutExtent: cachedValues) y.
	^(self isProportionalHeight)
		ifFalse:  [ minHeight ]
		ifTrue: [ minHeight / (aFactor * self layoutSpec proportionalLayoutHeight) ]! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 10:14:04' prior: 50342208!
 allocWidthForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSizeSpecs (to be used in LinearLayoutMorphs) may specify
	proportional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minWidth
	so breakeven is when
	  amountToAlloc = minWidth / proportion * factor"
	| minWidth |
	minWidth := (self minimumLayoutExtent: cachedValues) x.
	^(self isProportionalWidth)
		ifFalse:  [ minWidth ]
		ifTrue: [ minWidth / (aFactor * self layoutSpec proportionalLayoutWidth) ]! !
!LayoutMorph class methodsFor: 'LinearLayout examples' stamp: 'jmv 7/25/2025 10:30:30' prior: 50352867!
                       example101VG
"
	self example101VG
"
| pane row |
pane := (LinearLayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row := LinearLayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (Sample09Clock new name: #A)
		layoutSpec: (LayoutSizeSpec fixedWidth: 100); 
	addMorph: (Sample01Star new name: #B)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample03Smiley new name: #C)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (ColoredBoxMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.15);
	addMorph: (Sample03Smiley new name: #E)
		layoutSpec: (LayoutSizeSpec fixedWidth: 200 fixedHeight: 200).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color lightRed;
	addMorph: (Sample02Bezier new name: #F)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.8);
	addMorph: (Sample02Bezier new  name: #G)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.4);
	addMorph: (Sample02Bezier new  name: #H)
		layoutSpec: (LayoutSizeSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSizeSpec useAll.

row := (LinearLayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (ColoredBoxMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSizeSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (ColoredBoxMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSizeSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (ColoredBoxMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSizeSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSizeSpec fixedHeight: 60).
pane position: 150@130 extent: 800@600.
pane openInWorld! !
!LayoutMorph class methodsFor: 'FormLayout examples' stamp: 'jmv 7/25/2025 10:31:38' prior: 50353415!
     example1Form
"
	self example1Form
"
	| pane |
	pane := (FormLayoutMorph newForm padding: 5) name: #example1.
	pane 
		color: Color red;
		addMorph: (ColoredBoxMorph new color: (Color lightBlue); name: #A)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@20 brEdgesWeight: 0@0 offset: 100@40);
		addMorph: (ColoredBoxMorph new color: (Color blue); name: #B)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 30@20 brEdgesWeight: 1@0 offset: -30@40);
		addMorph: (ColoredBoxMorph new color: (Color lightGreen); name: #C)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@60 brEdgesWeight: 0.5@0 offset: -10@140);
		addMorph: (ColoredBoxMorph new color: (Color green); name: #D)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0.5@0 offset: 10@60 brEdgesWeight: 1@0 offset: -30@140);
		addMorph: (ColoredBoxMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
			layoutSpec: (LayoutEdgesSpec tlEdgesWeight: 0@0 offset: 30@160 brEdgesWeight: 1@1 offset: -30@ -30).
	pane position: 150@130 extent: 400@300.
	pane openInWorld! !
!MenuMorph methodsFor: 'menu' stamp: 'jmv 7/25/2025 10:20:30' prior: 50351079!
            removeStayUpBox
	| box |
	submorphs isEmpty ifTrue: [^self].
	(submorphs first is: #LayoutMorph) ifFalse: [^self].
	box := submorphs first submorphs second.
	(box is: #PluggableButtonMorph) 
		ifTrue: [ box hide ]! !
!LayoutSpec methodsFor: 'private' stamp: 'jmv 7/25/2025 10:20:25' prior: 50352150!
                    updateContainingLayout
	| owningLayout |
	morph ifNotNil: [
		owningLayout := morph owner.
		(owningLayout is: #LayoutMorph) ifTrue:
			[ owningLayout layoutSubmorphs ]].! !

LinearLayoutMorph removeSelector: #defaultColor!

!methodRemoval: LinearLayoutMorph #defaultColor stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
defaultColor
	^ Theme current defaultWindowColor!

LinearLayoutMorph removeSelector: #clipsSubmorphs!

!methodRemoval: LinearLayoutMorph #clipsSubmorphs stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
clipsSubmorphs
	"LayoutMorphs usually not do not clip submorphs.
	A special case is Transcript. It doesn't include a ScrollPane (that usually does clipping).
	Note: for this to work, we can't be transparent, as transparent morphs can't clip submorphs.
		Senders may also call #doAdoptWidgetsColor.
	There may be other similar cases in the future."

	^self hasProperty: #doClipSubmorphs.!

LinearLayoutMorph removeSelector: #layoutSpec!

!methodRemoval: LinearLayoutMorph #layoutSpec stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec useAll.
	layoutSpec morph: self.

	^ layoutSpec !

LinearLayoutMorph removeSelector: #padding:!

!methodRemoval: LinearLayoutMorph #padding: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
padding: numberOrPoint
	"Honored by all kinds of Layouts"

	super padding: numberOrPoint.
	self layoutSubmorphs.!

LinearLayoutMorph removeSelector: #defaultGap!

!methodRemoval: LinearLayoutMorph #defaultGap stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
defaultGap
	"Answer the default gap between submorphs for the receiver.
	Redefine this method for a different initial gap in your morphs.
	Only for Linear Layouts"

	^ 0!

LinearLayoutMorph removeSelector: #drawOn:!

!methodRemoval: LinearLayoutMorph #drawOn: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."

	aCanvas
		fillRectangle: self localBounds
		color: color
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor.!

LinearLayoutMorph removeSelector: #addMorphFrontFromWorldPosition:!

!methodRemoval: LinearLayoutMorph #addMorphFrontFromWorldPosition: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
addMorphFrontFromWorldPosition: aMorph

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	self addMorphFront: aMorph.
	self layoutSubmorphs.
!

LinearLayoutMorph removeSelector: #privateAddAllMorphs:atIndex:!

!methodRemoval: LinearLayoutMorph #privateAddAllMorphs:atIndex: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
privateAddAllMorphs: aCollection atIndex: index

	aCollection do: [ :m |
		m isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
		m layoutSpec ].
	^ super privateAddAllMorphs: aCollection atIndex: index.!

LinearLayoutMorph removeSelector: #is:!

!methodRemoval: LinearLayoutMorph #is: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
is: aSymbol
	^ aSymbol == #LinearLayoutMorph or: [ super is: aSymbol ]!

LinearLayoutMorph removeSelector: #doClipSubmorphs!

!methodRemoval: LinearLayoutMorph #doClipSubmorphs stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
doClipSubmorphs
	self setProperty: #doClipSubmorphs toValue: true.!

LinearLayoutMorph removeSelector: #layoutSubmorphsIfNeeded!

!methodRemoval: LinearLayoutMorph #layoutSubmorphsIfNeeded stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
layoutSubmorphsIfNeeded
	"Recompute the layout if necessary."

	self isLayoutNeeded ifTrue: [
		self layoutSubmorphs ].!

LinearLayoutMorph removeSelector: #addMorph:layoutSpec:!

!methodRemoval: LinearLayoutMorph #addMorph:layoutSpec: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
addMorph: aMorph layoutSpec: aLayoutSpec
	"Add a submorph, at the bottom or right, with aLayoutSpec"

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec: aLayoutSpec.
	self addMorphFront: aMorph.!

LinearLayoutMorph removeSelector: #someSubmorphPositionOrExtentChanged!

!methodRemoval: LinearLayoutMorph #someSubmorphPositionOrExtentChanged stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
someSubmorphPositionOrExtentChanged
	"Some submorph changed position or extent.
	Must layout submorphs again."

	self layoutNeeded: true.!

LinearLayoutMorph removeSelector: #addMorphBack:!

!methodRemoval: LinearLayoutMorph #addMorphBack: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
addMorphBack: aMorph
	"Add a submorph, at the top or left, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	super addMorphBack: aMorph.!

LinearLayoutMorph removeSelector: #privateAddMorph:atIndex:position:!

!methodRemoval: LinearLayoutMorph #privateAddMorph:atIndex:position: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
privateAddMorph: aMorph atIndex: index position: aPoint

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	^ super privateAddMorph: aMorph atIndex: index position: aPoint.!

LinearLayoutMorph removeSelector: #addMorphFront:!

!methodRemoval: LinearLayoutMorph #addMorphFront: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
addMorphFront: aMorph
	"Add a submorph, at the bottom or right, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec.
	super addMorphFront: aMorph!

LinearLayoutMorph removeSelector: #extentChanged:!

!methodRemoval: LinearLayoutMorph #extentChanged: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	self layoutNeeded: true.!

LinearLayoutMorph removeSelector: #defaultBorderWidth!

!methodRemoval: LinearLayoutMorph #defaultBorderWidth stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
defaultBorderWidth
	"answer the default border width for the receiver"
	^ 0!

LinearLayoutMorph removeSelector: #borderWidth:!

!methodRemoval: LinearLayoutMorph #borderWidth: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
borderWidth: anInteger

	super borderWidth: anInteger.
	self layoutSubmorphs.!

LinearLayoutMorph removeSelector: #removedMorph:!

!methodRemoval: LinearLayoutMorph #removedMorph: stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
removedMorph: aMorph
	"One of my submorphs has been removed."

	super removedMorph: aMorph.
	self layoutSubmorphs!

LayoutMorph removeSelector: #minimumExtent!

!methodRemoval: LayoutMorph #minimumExtent stamp: 'Install-7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st 7/27/2025 12:43:43'!
minimumExtent
	"Ojo!!"
	^100@100!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7379-LayoutMorph-MoreMethodShuffling-JuanVuletich-2025Jul25-10h09m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7372] on 25 July 2025 at 11:30:30 am'!
!FormLayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:26:14' overrides: 50354605!
                      addMorph: aMorph layoutSpec: aLayoutSpec
	"Add a submorph, with aLayoutSpec"
	
	aLayoutSpec isLayoutEdgesSpec ifFalse: [ self error: 'Only LayoutEdgesSpec can be used in FormLayoutMorphs' ].
	super addMorph: aMorph layoutSpec: aLayoutSpec! !
!LinearLayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:26:40' overrides: 50354605!
   addMorph: aMorph layoutSpec: aLayoutSpec
	"Add a submorph, at the bottom or right, with aLayoutSpec"
	
	aLayoutSpec isLayoutSizeSpec ifFalse: [ self error: 'Only LayoutSizeSpec can be used in LinearLayoutMorphs' ].
	super addMorph: aMorph layoutSpec: aLayoutSpec! !
!Layout methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:17:52'!
                       isFormLayout
	^false! !
!Layout methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:17:47'!
         isLinearLayout
	^false! !
!FormLayout methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:18:55' overrides: 50355150!
               isFormLayout
	^true! !
!LinearLayout methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:19:07' overrides: 50355153!
                isLinearLayout
	^true! !
!LayoutSpec methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:25:43'!
    isLayoutEdgesSpec
	^false! !
!LayoutSpec methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:24:59'!
isLayoutSizeSpec
	^false! !
!LayoutEdgesSpec methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:25:34' overrides: 50355164!
        isLayoutEdgesSpec
	^true! !
!LayoutSizeSpec methodsFor: 'testing' stamp: 'jmv 7/25/2025 11:27:27' overrides: 50355167!
         isLayoutSizeSpec
	^true! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:29:53' prior: 50354605!
    addMorph: aMorph layoutSpec: aLayoutSpec
	"Add a submorph, with aLayoutSpec.
	Subclasses validate that aLayoutSpec is appropriate for them before calling super."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph layoutSpec: aLayoutSpec.
	self addMorphFront: aMorph.! !

LayoutSizeSpec removeSelector: #isLinearLayoutSpec!

LayoutSpec removeSelector: #isLinearLayoutSpec!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7380-ValidateLayoutSpecClass-JuanVuletich-2025Jul25-10h32m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7380] on 25 July 2025 at 12:34:00 pm'!
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 11:56:30'!
assureLayoutSpecForOwner: toBeOwner
	"If we haven't been set a layout spec yet, or we carry one that can no longe be used,
	set a default one for our new context."

	(toBeOwner isLayoutSpecOk: layoutSpec ) ifFalse: [
		layoutSpec := nil ].

	layoutSpec ifNil: [
		layoutSpec := toBeOwner defaultLayoutSpecFor: self.
		layoutSpec morph: self ].! !
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 12:01:06'!
                       defaultLayoutEdgesSpec
	"Layout specific. Return a default layout spec describing where the
	receiver should appear in a FormLayout.
	Not really useful in practice, just _some_  default."

	^LayoutEdgesSpec
		tlEdgesWeight: 0.5@0.5 offset: -100 @ -10
		brEdgesWeight: 0.5@0.5 offset: 100 @ 10! !
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 11:51:03'!
          defaultLayoutSizeSpec
	"Layout specific. Return a default layout spec describing where the
	receiver should appear in a LinearLayout."

	^LayoutSizeSpec useAll! !
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 12:30:26'!
               useDefaultLayoutSizeSpec
	"Set our default for LinearLayout. Answer it for convenience."

	self layoutSpec: self defaultLayoutSizeSpec.
	^layoutSpec! !
!BoxMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 11:51:06' overrides: 50355228!
         defaultLayoutSizeSpec
	"Layout specific. Return a default layout spec describing where the
	receiver should appear in a LinearLayout."

	^LayoutSizeSpec keepMorphExtent! !
!LayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 12:00:29'!
                isLayoutSpecOk: aLayoutSpecOrNil
	"Answer whether the argument can work with us."
	
	^self subclassResponsibility! !
!LayoutMorph methodsFor: 'layout in owner' stamp: 'jmv 7/25/2025 11:51:09' overrides: 50355244!
           defaultLayoutSizeSpec
	"Layout specific. Return a default layout spec describing where the
	receiver should appear in a LinearLayout."

	^LayoutSizeSpec useAll! !
!LayoutMorph methodsFor: 'aux' stamp: 'jmv 7/25/2025 11:55:30'!
                             defaultLayoutSpecFor: aMorph
	^self subclassResponsibility! !
!FormLayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 12:00:46' overrides: 50355252!
      isLayoutSpecOk: aLayoutSpecOrNil
	"Answer whether the argument can work with us."
	
	^aLayoutSpecOrNil notNil and: [aLayoutSpecOrNil isLayoutEdgesSpec]! !
!FormLayoutMorph methodsFor: 'aux' stamp: 'jmv 7/25/2025 11:55:46' overrides: 50355267!
             defaultLayoutSpecFor: aMorph
	^aMorph defaultLayoutEdgesSpec! !
!LinearLayoutMorph methodsFor: 'testing' stamp: 'jmv 7/25/2025 12:00:51' overrides: 50355252!
  isLayoutSpecOk: aLayoutSpecOrNil
	"Answer whether the argument can work with us."
	
	^aLayoutSpecOrNil notNil and: [aLayoutSpecOrNil isLayoutSizeSpec]! !
!LinearLayoutMorph methodsFor: 'aux' stamp: 'jmv 7/25/2025 12:09:56' overrides: 50355267!
            defaultLayoutSpecFor: aMorph
	^aMorph defaultLayoutSizeSpec! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 12:32:52' prior: 50354707!
            allocHeightForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSizeSpecs (to be used in LinearLayoutMorphs) may specify
	proportional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minHeight
	so breakeven is when
	  amountToAlloc = minHeight / proportion * factor"
	| minHeight |
	minHeight := (self minimumLayoutExtent: cachedValues) y.
	^(self isProportionalHeight)
		ifFalse:  [ minHeight ]
		ifTrue: [ minHeight / (aFactor * layoutSpec proportionalLayoutHeight) ]! !
!PlacedMorph methodsFor: 'geometry' stamp: 'jmv 7/25/2025 12:32:56' prior: 50354726!
      allocWidthForFactor: aFactor minLayoutExtentCache: cachedValues

	"Morphs with LayoutSizeSpecs (to be used in LinearLayoutMorphs) may specify
	proportional layouts and minimum extents
	  amountToAlloc * proportion * factor >= minWidth
	so breakeven is when
	  amountToAlloc = minWidth / proportion * factor"
	| minWidth |
	minWidth := (self minimumLayoutExtent: cachedValues) x.
	^(self isProportionalWidth)
		ifFalse:  [ minWidth ]
		ifTrue: [ minWidth / (aFactor * layoutSpec proportionalLayoutWidth) ]! !
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 12:32:15' prior: 50338394!
      layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in an owning layout.
	If asked before setting it, and before adding us to some owner,
	just answer nil."

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	owner notNil ifTrue: [
		self assureLayoutSpecForOwner: owner ].
	^ layoutSpec.! !
!PlacedMorph methodsFor: 'layout-properties' stamp: 'jmv 7/25/2025 12:25:56' prior: 16930564!
                            layoutSpec: aLayoutSpec
	"Layout specific. Set the layout spec describing where the receiver should appear in a proportional layout"
	layoutSpec == aLayoutSpec ifTrue: [ ^self ].
	aLayoutSpec morph: self.
	layoutSpec := aLayoutSpec.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ]! !
!FindInSourceDialog methodsFor: 'initialization' stamp: 'jmv 7/25/2025 12:30:39' prior: 50350219 overrides: 16848620!
                               buildWidgets

	| buttonRow titleMorph |
	titleMorph := (LabelMorph contents: 'Find in source code' fontSize: 16 emphasis: 1).
	titleMorph useDefaultLayoutSizeSpec offAxisEdgeWeight: 0.
	searchField := EntryFieldMorph new.
	searchField
		crAction: [ self ok ];
		escAction: [ self cancel ].
	searchField useDefaultLayoutSizeSpec offAxisEdgeWeight: 0.
	initialSearchString ifNotNil: [ searchField contents: initialSearchString ].
	scopeList := PluggableListMorph
		withModel: self
		listGetter: #scopesList
		indexGetter: #scopeIndex
		indexSetter: #scopeIndex:.
	scopeList 
		doubleClickSelector: #ok.
	buttonRow := LinearLayoutMorph newRow.
	buttonRow
		addMorph: (PluggableButtonMorph model: self action: #ok label: 'Ok');
		addMorph: (PluggableButtonMorph model: self action: #cancel label: 'Cancel').
	layoutMorph
		gap: 14;
		addMorphKeepMorphHeight: titleMorph;
		addMorphKeepMorphHeight: searchField;
		addMorphUseAll: scopeList;
		addMorphKeepMorphHeight: buttonRow.

	self morphExtent: self minimumExtent * (2@1.5).! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:58:36' prior: 50354617 overrides: 16913949!
        addMorphBack: aMorph
	"Add a submorph, at the top or left, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph assureLayoutSpecForOwner: self.
	super addMorphBack: aMorph.! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:58:40' prior: 50354629 overrides: 16913968!
                           addMorphFront: aMorph
	"Add a submorph, at the bottom or right, with a default LayoutSpec if none was provided."

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph assureLayoutSpecForOwner: self.
	super addMorphFront: aMorph! !
!LayoutMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 7/25/2025 11:58:45' prior: 50354526 overrides: 16913987!
                      addMorphFrontFromWorldPosition: aMorph

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph assureLayoutSpecForOwner: self.
	self addMorphFront: aMorph.
	self layoutSubmorphs.
! !
!LayoutMorph methodsFor: 'private' stamp: 'jmv 7/25/2025 11:58:02' prior: 50354648 overrides: 16914517!
                     privateAddAllMorphs: aCollection atIndex: index

	aCollection do: [ :m |
		m isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
		m assureLayoutSpecForOwner: self ].
	^ super privateAddAllMorphs: aCollection atIndex: index.! !
!LayoutMorph methodsFor: 'private' stamp: 'jmv 7/25/2025 11:58:52' prior: 50354659 overrides: 16914561!
                     privateAddMorph: aMorph atIndex: index position: aPoint

	aMorph isPlacedMorph ifFalse: [ self error: 'Only PlacedMorphs can be used in Layouts' ].
	aMorph assureLayoutSpecForOwner: self.
	^ super privateAddMorph: aMorph atIndex: index position: aPoint.! !

LayoutMorph removeSelector: #layoutSpec!

!methodRemoval: LayoutMorph #layoutSpec stamp: 'Install-7381-PickLayoutSpecClass-JuanVuletich-2025Jul25-12h06m-jmv.002.cs.st 7/27/2025 12:43:43'!
layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec useAll.
	layoutSpec morph: self.

	^ layoutSpec !

BoxMorph removeSelector: #layoutSpec!

!methodRemoval: BoxMorph #layoutSpec stamp: 'Install-7381-PickLayoutSpecClass-JuanVuletich-2025Jul25-12h06m-jmv.002.cs.st 7/27/2025 12:43:43'!
layoutSpec
	"Layout specific. Return the layout spec describing where the
	receiver should appear in a proportional layout"

	layoutSpec ifNotNil: [ :ls | ^ ls ].
	layoutSpec := LayoutSizeSpec keepMorphExtent.
	layoutSpec morph: self.

	^ layoutSpec!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7381-PickLayoutSpecClass-JuanVuletich-2025Jul25-12h06m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7381] on 25 July 2025 at 3:19:13 pm'!
!ExtractMethodReplacementsWindow methodsFor: 'as yet unclassified' stamp: 'jmv 7/25/2025 15:17:32' prior: 16864250 overrides: 16909166!
             createCodePaneMorph

	^super createCodePaneMorph
		disableEditing;
		yourself! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7382-ExtractMethodReplacementsWindow-fix-JuanVuletich-2025Jul25-15h13m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7370] on 25 July 2025 at 3:21:37 pm'!
!Debugger methodsFor: 'context stack menu' stamp: 'HAW 7/25/2025 15:21:09' prior: 16844552!
                           runToCursorAt: aPositionToStop

	| runToCursorContext |
	
	runToCursorContext := self selectedContext home.
	self assert: runToCursorContext mapsPcTo: aPositionToStop.
	
	[ (self pcRange includes: aPositionToStop) 
		ifTrue: [ self stepIntoBlock ]
		ifFalse: [ self doStep ].
	self isPcAt: aPositionToStop in: runToCursorContext ] whileFalse! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7383-RunToCursorImprovement-HernanWilkinson-2025Jul25-15h21m-HAW.001.cs.st----!

'From Cuis7.5 [latest update: #7370] on 27 July 2025 at 12:27:25 pm'!
!WorldMorph methodsFor: 'interaction loop' stamp: 'jmv 7/27/2025 12:26:17' prior: 17018488!
                            mainLoop

	[
		self displayWorldOn: canvas.
		[
			"Here canvas and waitDelay are passed as arguments.
			This is because when debugging Morphic, a new UI process,
			these ivars are updated, but in the debugger process we still want the original ones."
			self doOneCycleOn: canvas delay: waitDelay.
			UISupervisor isUIProcessRunning ]
				whileTrue: []
	] on: Error, Halt do: [ :ex |
		"Handle a drawing error"
		(ex signalerContext findContextSuchThat: [ :context |
				#(drawOn: postDrawOn: fullDraw:) statePointsTo: context selector ])
			ifNotNil: [ :context |
				context selector = #fullDraw:
					ifTrue: [ (context at: 1) drawingFails ]
					ifFalse: [ context receiver drawingFails ].
				"Install the old error handler, so we can re-raise the error.
				This means, open a Debugger.
				This will also create a new Morphic process. if the user closes the debugger."
				ex receiver error: ex description.
				"Create a new UI process, if the user proceeds in the debugger.
				This is to use a new, clean Canvas."
				UISupervisor newUIProcess ]
			ifNil: [
				"Debugging aid: Uncomment. Set Transcript to log to StdOut and File.
				Be ready to need to kill Cuis from the OS."
				"'-----' print.
				{Time now. Processor activeProcess. ex} print.
				thisContext printStack: 50.
				[UISupervisor newUIProcess] fork."
				ex return ]
	].! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 7/27/2025 12:22:02' prior: 16915565!
                             fullDraw: aMorph
	"Draw the full Morphic structure on us"
	aMorph visible ifFalse: [^ self].

	"We are already set with a proper transformation from aMorph owner's coordinates to those of our target form."
	self into: aMorph.

	currentMorph isKnownFailing ifTrue: [
		self canvasToUse drawCurrentAsError.
		self outOfMorph.
		^ self].

	currentMorph layoutSubmorphsIfNeeded.

	(currentMorph isOwnedByHand and: [
			(Preferences at: #cheapWindowReframe) and: [currentMorph is: #SystemWindow]]) ifTrue: [
		self canvasToUse drawCurrentAsOutline ifTrue: [
			self outOfMorph.
			^ self]].

	"Draw current Morph and submorphs"	
	self canvasToUse drawCurrentAndSubmorphs.

	self outOfMorph.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7384-FurtherProtectMorphicAgainstCodeErrors-JuanVuletich-2025Jul27-12h20m-jmv.001.cs.st----!

----QUIT----(27 July 2025 12:43:51) Cuis7.5-7384.image priorSource: 577993!

----STARTUP---- (29 August 2025 15:07:08) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.5-7384.image!


'From Cuis7.5 [latest update: #7384] on 27 July 2025 at 12:51:39 pm'!
!WorldMorph methodsFor: 'interaction loop' stamp: 'jmv 7/27/2025 12:51:24' prior: 50355532!
    mainLoop

	[
		self displayWorldOn: canvas.
		[
			"Here canvas and waitDelay are passed as arguments.
			This is because when debugging Morphic, a new UI process,
			these ivars are updated, but in the debugger process we still want the original ones."
			self doOneCycleOn: canvas delay: waitDelay.
			UISupervisor isUIProcessRunning ]
				whileTrue: []
	] on: Error, Halt do: [ :ex |
		"Handle a drawing error"
		(ex signalerContext findContextSuchThat: [ :context |
				#(drawOn: postDrawOn: fullDraw:) statePointsTo: context selector ])
			ifNotNil: [ :context |
				context selector = #fullDraw:
					ifTrue: [ (context at: 1) drawingFails ]
					ifFalse: [ context receiver drawingFails ].
				"Install the old error handler, so we can re-raise the error.
				This means, open a Debugger.
				This will also create a new Morphic process. if the user closes the debugger."
				ex receiver error: ex description.
				"Create a new UI process, if the user proceeds in the debugger.
				This is to use a new, clean Canvas."
				UISupervisor newUIProcess ]
			ifNil: [
				"Debugging aid: Uncomment. Set Transcript to log to StdOut and File.
				Be ready to need to kill Cuis from the OS."
				"'-----' print.
				{Time now. Processor activeProcess. ex} print.
				thisContext printStack: 50.
				[UISupervisor newUIProcess] fork."
				"ex return"
				ex pass ]
	].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7385-tweak-JuanVuletich-2025Jul27-12h51m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7385] on 28 July 2025 at 12:33:49 pm'!
!MessageNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47' prior: 16902791!
                         printWithClosureAnalysisWhileOn: aStream indent: level

	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.
	(arguments isEmpty not
	 and: [arguments first isJust: NodeNil]) ifTrue:
			[selector := SelectorNode new
							key:
									(selector key == #whileTrue:
										ifTrue: [#whileTrue]
										ifFalse: [#whileFalse])
							code: #macro.
			arguments := #()].
	self printWithClosureAnalysisKeywords: selector key arguments: arguments
		on: aStream indent: level! !
!Rectangle methodsFor: 'rectangle functions' stamp: 'jmv 1/24/2011 15:55' prior: 16944160!
               rectanglesAt: y
	(y+1) > self bottom ifTrue: [^ #()].
	^ Array with: (origin x @ y corner: corner x @ (y+1))! !
!HierarchyBrowser methodsFor: 'initialization' stamp: 'di 4/26/2000 20:20' prior: 16880641 overrides: 16799510!
systemCategorySingleton

	| cls |
	cls := self selectedClass.
	^ cls ifNil: [#()]
		ifNotNil: [Array with: cls category]! !
!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 09:54' prior: 17015874!
              arguments
	^arguments ifNil: [ #() ]
! !
!RunArray class methodsFor: 'instance creation' stamp: 'ST-80 5/31/1983 9:10:35' prior: 16949273 overrides: 16787643!
 new
	^self runs: #() values: #()! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 2/5/2024 18:11:09' prior: 16974200!
 unimplemented
	"Answer an Array of each message that is sent by an expression in a method but is not implemented by any object in the system."

	| all unimplemented entry |
	all := IdentitySet new.
	self allBehaviorsDo: [ :cl | cl selectorsDo: [ :aSelector | all add: aSelector]].

	unimplemented := IdentityDictionary new.
	self allBehaviorsDo: [:cl |
		 cl selectorsDo: [:sel |
			(cl compiledMethodAt: sel) messages do: [ :m |
				(all includes: m) ifFalse: [
					entry := unimplemented at: m ifAbsent: [#()].
					entry := entry copyWith: (cl name, '>', sel).
					unimplemented at: m put: entry]]]].

	"remove some clutter from the result:"
	#(doPrimitive: primitiveFail success:) do: [ :sel |
		unimplemented removeKey: sel ifAbsent: nil].

	^ unimplemented! !
!ReferenceStream methodsFor: 'statistics' stamp: 'jmv 2/6/2024 09:32:24' prior: 16945791!
      statisticsOfRefs
	"Analyze the information in references, the objects being written out"

	| parents n kids nm ownerBags tallies owners objParent normalReferences |
	normalReferences := self references.	"Exclude unrealized weaks"
	parents := IdentityDictionary newWithRoomForMoreThan: normalReferences size * 2.
	n := 0.
	'Finding Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:
		[ :parent | barBlock value: (n := n+1).
		kids := parent class isFixed
			ifTrue: [(1 to: parent class instSize) collect: [:i | parent instVarAt: i]]
			ifFalse: [parent class isBits ifTrue: [#()]
					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt: i]]].
		(kids select: [:x | normalReferences includesKey: x])
			do: [:child | parents at: child put: parent]]].
	ownerBags := Dictionary new.
	tallies := Bag new.
	n := 0.
	'Tallying Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:  "For each class of obj, tally a bag of owner classes"
		[ :obj | barBlock value: (n := n+1).
		nm := obj class name.
		tallies add: nm.
		owners := ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].
		(objParent := parents at: obj ifAbsent: nil) ifNotNil: [
			owners add: objParent class name]]].
	^ String streamContents: [ :strm | 
		tallies sortedCounts do: [ :assn |
			n := assn key.  nm := assn value.
			owners := ownerBags at: nm.
			strm newLine; nextPutAll: nm; space; print: n.
			owners size > 0 ifTrue: [
				strm newLine; tab; print: owners sortedCounts]]]! !
!ContextPart methodsFor: 'system simulation' stamp: 'sqr 6/26/2019 09:59:16' prior: 16838986!
                             runSimulated: aBlock contextAtEachStep: block2
	"Simulate the execution of the argument, aBlock, until it ends. aBlock 
	MUST NOT contain an '^'. Evaluate block2 with the current context 
	prior to each instruction executed. Answer the simulated value of aBlock."
	| current |
	aBlock hasNonLocalReturn
		ifTrue: [self error: 'simulation of blocks with ^ can run loose'].
	current := aBlock asContext.
	current pushArgs: #() from: self.
	[current == self]
		whileFalse:
			[block2 value: current.
			current := current step].
	^self pop! !
!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 9/25/2011 15:46' prior: 16988626!
      rectanglesAt: y
	(y+1) > extentForComposing y ifTrue: [^ #()].
	^ Array with: (0 @ y corner: extentForComposing x @ (y+1))! !
!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'jmv 12/14/2015 23:34' prior: 16861814!
                             clearExternalObjects
	"Clear the array of objects that have been registered for use in non-Smalltalk code."

	self accessProtect critical: [Smalltalk specialObjectsArray at: 39 put: #()].
! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'hlsf 6/24/2022 09:42:07' prior: 16934579!
                              startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean
	"This menu is too big to fit comfortably on the screen.
	Break it up into smaller chunks, and manage the relative indices.
	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"

"
(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; newLine]. s skipBack])
		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'.
"
	| nLines nLinesPer allLabels from to subset subLines index |
	allLabels := labelString lines.
	nLines := allLabels size.
	lineArray ifNil: [lineArray := #()].
	nLinesPer := segmentHeight // (Preferences at: #standardMenuFont) lineSpacing - 5.
	from := 1.
	[ true ] whileTrue: [
		to := (from + nLinesPer) min: nLines.
		subset := (allLabels copyFrom: from to: to) asOrderedCollection.
		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])
			before: subset first.
		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].
		subLines := (Array with: 1) , subLines.
		index := (PopUpMenu labels: subset printStringWithNewline lines: subLines)
					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.
		index = 1
			ifTrue: [from := to + 1.
					from > nLines ifTrue: [ from := 1 ]]
			ifFalse: [index = 0 ifTrue: [^ 0].
					^ from + index - 2]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7386-AvoidCreatingEmptyArrays-JuanVuletich-2025Jul28-12h33m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7386] on 28 July 2025 at 2:45:18 pm'!
!StringRequestMorph methodsFor: 'private' stamp: 'jmv 7/28/2025 14:31:28'!
         ok
	textMorph scroller acceptContents! !
!StringRequestMorph methodsFor: 'initialization' stamp: 'jmv 7/28/2025 14:31:41' prior: 50350956!
                     addTextPane
	"Add a text pane and two buttons."
	
	| controlsContainer |
	textMorph := (TextModelMorph
		textProvider: self
		textGetter: #response
		textSetter: #response:
		selectionGetter: #selectionInterval) emptyTextDisplayMessage: 'Enter response'.
	self
		valueOfProperty: #emptyTextDisplayMessage
		ifPresentDo: [ :msg |
			textMorph emptyTextDisplayMessage: msg ].
	textMorph
		hasUnacceptedEdits: false;
		acceptOnCR: true;
		escAction: [ self cancel ].
	(controlsContainer := LinearLayoutMorph newRow)
		addMorphUseAll: textMorph;
		addMorph: 
			((PluggableButtonMorph model: self action: #ok)
				setBalloonText: 'OK' bold, ' (accept input)';
				icon: Theme current acceptIcon);
		addMorph:
			((PluggableButtonMorph model: self action: #cancel)
				setBalloonText: 'Cancel' bold, '  (discard input)';
				icon: Theme current cancelIcon).
	self addMorphUseAll: controlsContainer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7387-StringRequestMorph-tweaks-JuanVuletich-2025Jul28-14h44m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7385] on 28 July 2025 at 12:36:44 pm'!
!MessageSend methodsFor: 'private' stamp: 'jmv 7/28/2025 11:01:22' prior: 16904548!
                             collectArguments: anArgArray
	"Arguments set when builing the receiver (i.e. set when registering for an event)
	take precedence over anArgArray (i.e. set when triggering the event).
	If you want to use arguments set at trigger event time, set to an empty array, or set individual elements to nil."

	| staticArgs answer |
	staticArgs := self arguments.
	answer := Array new: selector numArgs.
	1 to: answer size do: [ :i | | each |
		each := staticArgs at: i ifAbsent: nil.
		each isNil ifTrue: [
			each := anArgArray at: i ifAbsent: nil ].
		answer at: i put: each ].
	^answer! !
!MessageSend class methodsFor: 'instance creation' stamp: 'jmv 7/28/2025 11:10:37' prior: 16904597!
                     receiver: anObject selector: aSymbol arguments: anArray
	"Note: Arguments set here will take preceence over those set when doing #valueWithArguments: and #triggerEvent:withArguments:. If you want them to take precedence, pass here #() or individual nil elements in anArray. See #collectArguments:"

	^ self new
		receiver: anObject;
		selector: aSymbol;
		arguments: anArray! !
!WeakMessageSend methodsFor: 'private' stamp: 'jmv 7/28/2025 11:01:41' prior: 17015966!
              collectArguments: anArgArray
	"Arguments set when builing the receiver (i.e. set when registering for an event)
	take precedence over anArgArray (i.e. set when triggering the event).
	If you want to use arguments set at trigger event time, set to an empty array, or set individual elements to nil."

	| staticArgs answer |
	staticArgs := self arguments.
	answer := Array new: selector numArgs.
	1 to: answer size do: [ :i | | each |
		each := staticArgs at: i ifAbsent: nil.
		each isNil ifTrue: [
			each := anArgArray at: i ifAbsent: nil ].
		answer at: i put: each ].
	^answer! !
!WeakMessageSend class methodsFor: 'instance creation' stamp: 'jmv 7/28/2025 11:11:17' prior: 17016060!
                 receiver: anObject selector: aSymbol arguments: anArray
	"Note: Arguments set here will take preceence over those set when doing #valueWithArguments: and #triggerEvent:withArguments:. If you want them to take precedence, pass here #() or individual nil elements in anArray. See #collectArguments:"

	^ self new
		receiver: anObject;
		selector: aSymbol;
		arguments: anArray! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7388-ArgsFromSendCreation-overFromEvaluationTIme-JuanVuletich-2025Jul28-12h33m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7388] on 31 July 2025 at 2:40:18 pm'!
!StringRequestMorph methodsFor: 'initialization' stamp: 'jmv 7/31/2025 14:39:59' prior: 50355893!
    addTextPane
	"Add a text pane and two buttons."
	
	| controlsContainer |
	textMorph := (TextModelMorph
		textProvider: self
		textGetter: #response
		textSetter: #response:
		selectionGetter: #selectionInterval) emptyTextDisplayMessage: 'Enter response'.
	self
		valueOfProperty: #emptyTextDisplayMessage
		ifPresentDo: [ :msg |
			textMorph emptyTextDisplayMessage: msg ].
	textMorph
		hasUnacceptedEdits: true; "Allow accepting initial contents"
		acceptOnCR: true;
		escAction: [ self cancel ].
	(controlsContainer := LinearLayoutMorph newRow)
		addMorphUseAll: textMorph;
		addMorph: 
			((PluggableButtonMorph model: self action: #ok)
				setBalloonText: 'OK' bold, ' (accept input)';
				icon: Theme current acceptIcon);
		addMorph:
			((PluggableButtonMorph model: self action: #cancel)
				setBalloonText: 'Cancel' bold, '  (discard input)';
				icon: Theme current cancelIcon).
	self addMorphUseAll: controlsContainer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7389-StringRequestMorph-tweaks-JuanVuletich-2025Jul31-14h39m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7388] on 29 July 2025 at 4:38:24 pm'!
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/24/2025 10:58:36' prior: 50347759!
               displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvarToDisplace. Displace them by delta.
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"To handle inst var indexes > 255 the following is necessary:
		- Two byte ivar access opcodes, #[226 240 243], need to be prepended by a (possibly zero) extendA bytecode
		- 1 byte ivar access opcodes, [0..15],[200..207], need to also be followed by NOT bytecode 0x5F
	These conditions can be fullfilled by calling #withLongInstVarAccessBytecodes: . See senders and implementors."

	| pc end oldExtendA bytecode oldIvar newIvar bytecodeSize |

	"Just in case..."
	delta = 0 ifTrue: [ ^true ].
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				| primitiveCode |
				newIvar := oldIvar+delta.
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	oldExtendA := nil.
	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256  ]]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format. Also handle extA (four byte format)"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldIvar := (aCompiledMethodOrMethodSpec at: pc+1) + 1.
			oldExtendA ifNotNil: [ oldIvar := oldExtendA * 256 + oldIvar ].
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format with possible oldExtendA"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
					oldExtendA notNil ifTrue: [
						aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ].
					"Shorten to 1 byte format + NOP #genPushInstVar:"
					(bytecode = 226 and: [ newIvar <= 16 ]) ifTrue: [
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					"Shorten to 1 byte format + NOP #genStorePopInstVar:"
					(bytecode = 240 and: [ newIvar <= 8 ]) ifTrue: [ 
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"#genUnsignedSingleExtendA:"
		oldExtendA := nil.
		bytecode = 224 ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldExtendA := aCompiledMethodOrMethodSpec at: pc+1 ].

		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/24/2025 10:53:17' prior: 50347911!
                            remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #displaceInstVarAccessesIn:starting:by:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"To handle inst var indexes > 255 the following is necessary:
		- Two byte ivar access opcodes, #[226 240 243], need to be prepended by a (possibly zero) extendA bytecode
		- 1 byte ivar access opcodes, [0..15],[200..207], need to also be followed by NOT bytecode 0x5F
	These conditions can be fullfilled by calling #withLongInstVarAccessBytecodes: . See senders and implementors."

	| pc end oldExtendA bytecode oldIvar bytecodeSize |

	"Just in case..."
	aDictionary isEmpty ifTrue: [ ^true ].

	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	oldExtendA := nil.
	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format. Also handle extA (four byte format)"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldIvar := (aCompiledMethodOrMethodSpec at: pc+1) + 1.
			oldExtendA ifNotNil: [ oldIvar := oldExtendA * 256 + oldIvar ].
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format with possible oldExtendA"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
					oldExtendA notNil ifTrue: [
						aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ].
					"Shorten to 1 byte format + NOP #genPushInstVar:"
					(bytecode = 226 and: [ newIvar <= 16 ]) ifTrue: [
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					"Shorten to 1 byte format + NOP #genStorePopInstVar:"
					(bytecode = 240 and: [ newIvar <= 8 ]) ifTrue: [
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"#genUnsignedSingleExtendA:"
		oldExtendA := nil.
		bytecode = 224 ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldExtendA := aCompiledMethodOrMethodSpec at: pc+1 ].

		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForV3PlusClosures class methodsFor: 'services' stamp: 'jmv 7/29/2025 15:49:19' prior: 50348054!
                 displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvarToDisplace. Displace them by delta.
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"This method can not handle remapping of 1-byte ivar access bytecodes: [0..15], [96..103]
	This method can not convert two byte bytecodes #[128 129 130] to or from three byte 132 + #[64 160 192].
	However the Sista Bytecode version of this method can.
	It is therefore recommended to use the Sista Bytecode Set."

	| pc end bytecode followingByte thirdByte oldIvar newIvar bytecodeSize |
	"Just in case..."
	delta = 0 ifTrue: [ ^true ].
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ]	.

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				| primitiveCode |
				newIvar := oldIvar+delta.
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode + 1 ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		oldIvar >= firstIvarToDisplace ifTrue: [
			aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
			^false ]	.
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			followingByte+1 >= firstIvarToDisplace ifTrue: [
				followingByte+delta < 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: followingByte+delta ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			thirdByte+1 >= firstIvarToDisplace ifTrue: [
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: thirdByte+delta ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 							"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForV3PlusClosures class methodsFor: 'services' stamp: 'jmv 7/29/2025 15:49:24' prior: 50348172!
            remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Similar to #displaceInstVarAccessesIn:starting:by:doIt:
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive"
	
	"This method can not handle remapping of 1-byte ivar access bytecodes: [0..15], [96..103]
	This method can not convert two byte bytecodes #[128 129 130] to or from three byte 132 + #[64 160 192].
	However the Sista Bytecode version of this method can.
	It is therefore recommended to use the Sista Bytecode Set."

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ]	.

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			aDictionary at: aCompiledMethodOrMethodSpec returnField+1 ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode + 1 ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			newIvar = oldIvar ifFalse: [
				aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
				^false ]	].
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			aDictionary at: followingByte+1 ifPresent: [ :newIvar |
				newIvar <= 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			aDictionary at: thirdByte+1 ifPresent: [ :newIvar |
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: newIvar-1 ]]].

		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 							"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		pc := pc + bytecodeSize ].

	^true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7390-InstVarRemap-UseExtAifPresent-JuanVuletich-2025Jul29-16h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7389] on 29 July 2025 at 3:21:03 pm'!
!CompiledMethod methodsFor: 'initialization' stamp: 'jmv 7/23/2025 10:51:29'!
              copyWithBytecodes: bytecodes
	"Assume bytecodes are regular bytecodes, even if we are a primitive method."

	| header copy |
	header := self header.
	"Take dawn the primitive flag if present."
	(header anyMask: 65536) ifTrue: [
		header := header - 65536 ].
	copy := CompiledMethod newMethod: bytecodes size+4 header: header.
	1 to: self numLiterals do: [:i | copy literalAt: i put: (self literalAt: i)].
	bytecodes withIndexDo: [ :byte :i |
		copy at: i+self initialPC-1 put: (bytecodes at: i) ].
	^ copy! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7391-CompiledMethod-copyWithBytecodes-JuanVuletich-2025Jul29-15h20m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7390] on 31 July 2025 at 10:16:54 am'!
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/30/2025 16:14:42'!
                            withLongInstVarAccessBytecodes: aCompiledMethodOrMethodSpec
	"Answer a CompiledMethod or MethodSpec that is functionally equivalent to the argument.
	But:
		- All instance variable accessing code are 'padded' to 4 bytes (see below).
		- All jump / branch bytecodes are 'padded' to 4 bytes (see below) AND corrected to jump to the correct place.

	This is to enable #remapInstVarAccessesIn:asPer:doIt: and #displaceInstVarAccessesIn:starting:by:doIt:
	to work on methods using short bytecodes that prevent the modification of the involved instance variable
	instance variable indexes in place.

	In the answer:
	- Short (1 byte) instance variable access bytecodes [0..15],[200..207] are kept unmodified, but followed by a NOP bytecode
	- Short (1 byte) jump / branch bytecodes [176..199] are converted to the the corresponding two byte format: #[237 238 239]
	- All the ivar access, jump and branch bytecodes are prepended with a (likely zero) extA or extB extension bytecode
		This includes  [0..15],[200..207], #[226 240 243], [176..199], #[237 238 239].
		Any extA or extB previously present is kept unmodified and not duplicated.
	- The result is larger than the argument #bytecodes. All jump / branch bytecodes are corrected to jump to the correct
		spot in the new, longer bytecodes sequence.

	Note 1: This is somewhat expensive and not especially optimized. It is expected to be needed in a very small percentage of
		methods: Only those that remap instance variables in the set of the first 256 ones to/from variables beyond index 255.
	Note 2: The result is not space optimal. In many cases the extA / extB will not actually be needed. Computing the optimum
		bytecode sequence is even more expensive. Besides this usually won't give a performance improvement, as both
		forms would be jitted to the same machine code by Cog."

	| bytecodesAndPadInfo newBytecodes |

	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		"No conversion possible."
		^nil ].

	"Quick return. Convert into a regular method."
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		| bytes |
		bytes := #[224 0 226 0 92] copy. "#genUnsignedSingleExtendA:, #genPushInstVarLong:, #genReturnTop"
		bytes at: 4 put: aCompiledMethodOrMethodSpec returnField.
		^aCompiledMethodOrMethodSpec copyWithBytecodes: bytes ].

	bytecodesAndPadInfo := aCompiledMethodOrMethodSpec bytecodes asArray.
	self withLongInstVarAccessConversion01On: bytecodesAndPadInfo.
	self withLongInstVarAccessConversion02On: bytecodesAndPadInfo.
	newBytecodes := self withLongInstVarAccessConversion03On: bytecodesAndPadInfo.
	^aCompiledMethodOrMethodSpec copyWithBytecodes: newBytecodes! !
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/29/2025 16:00:34'!
withLongInstVarAccessConversion01On: bytecodesAndPadInfo
	"Extract ivar accesses and jumps into aux arrays"

	| pc end hadExtendA oldExtendBByte bytecode bytecodeSize oldSize newBytes newExtendB oldDistance sizeDelta |
	
	hadExtendA := false.
	oldExtendBByte := nil.
	pc := 1.
	end := bytecodesAndPadInfo size.
	[pc <= end] whileTrue: [
		bytecode := bytecodesAndPadInfo at: pc.
		
		"#genPushInstVar: #genStorePopInstVar: Short 1 byte format."
		"Add a trailing NOP if not already there. Prepend with a zero extA if not already there."
		(bytecode < 16 or: [(bytecode between: 200 and: 207)]) ifTrue: [
			oldSize := (pc+1 <= end and: [bytecodesAndPadInfo at: pc+1]) = 16r5F
				ifTrue: [2] "Already had a trailing NOP"
				ifFalse: [1]. "Didn't have it."
			newBytes := {bytecode. 16r5F}. "Will indeed have a trailing NOP"
			hadExtendA ifFalse: [
				newBytes := #[224 0], newBytes]. "Will add a zero extA if it didn't have one already"
			bytecodesAndPadInfo at: pc put: { #ivarAccess. oldSize. newBytes size-oldSize. newBytes} ].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Regular 2 byte format."
		"Prepend with a zero extA if not already there."
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				^false].
			newBytes := {bytecode. bytecodesAndPadInfo at: pc+1}.
			hadExtendA ifFalse: [
				newBytes := #[224 0], newBytes]. "Add a zero extA before our bytecode if there wasn't one already there."
			bytecodesAndPadInfo at: pc put: ( { #ivarAccess. 2. newBytes size-2. newBytes}) ].
		
		"#genJump:, #genBranchPopTrue:, #genBranchPopFalse:, short 1 byte format. Also handle possible extB (four byte format)"
		"Convert to 2 byte format. Prepend with a zero extB if not already present (there shouldn't be one)."
		(bytecode between: 176 and: 199) ifTrue: [
			newExtendB := oldExtendBByte ifNil: [{225. 0}] ifNotNil: [nil]. 	"Add extB if not already there. Second byte for jump distance to be set later."
			newBytes := {bytecode >> 3 + 215. 0}. 						"Compute two byte bytecode (237, 238, 239). Second byte to be set later."
			sizeDelta := (oldExtendBByte ifNil: [2] ifNotNil: [0]) + 2-1. 		"extB size + newBytes size - oldSize"
			oldDistance := (bytecode bitAnd: 7) + 1.						"Extract jump distance from 1-byte bytecode"
			"Ignore very unlikely oldExtendB, for oldDistance. Assume zero. (It doesn't make sense to actually use it for 3 bit jumps!!)"
			bytecodesAndPadInfo at: pc put: ( {#branch. 1. sizeDelta. oldDistance. newExtendB. newBytes }) ].
		
		"#genJump:, #genBranchPopTrue:, #genBranchPopFalse:, Two byte format. Also handle possible extB (four byte format)"
		(#[237 238 239] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				^false].
			newExtendB := oldExtendBByte ifNil: [{225. 0}] ifNotNil: [nil]. 	"Add extB if not already there. Second byte for jump distance to be set later."
			newBytes := {bytecode. 0}. 									"Second byte for jump distance will be set later."
			sizeDelta := (oldExtendBByte ifNil: [2] ifNotNil: [0]) + 2-2. 		"extB size + newBytes size - oldSize"
			"Compute oldDistance. Include possible extB byte."
			oldDistance := bytecodesAndPadInfo at: pc+1.
			oldExtendBByte notNil ifTrue: [
				(bytecode = 237 and: [oldExtendBByte > 127]) ifTrue: [oldExtendBByte := oldExtendBByte-256].
				oldDistance := oldExtendBByte * 256 + oldDistance ].
			bytecodesAndPadInfo at: pc put: ( {#branch. 2. sizeDelta. oldDistance. newExtendB. newBytes }) ].
		
		"#genUnsignedSingleExtendA: and genUnsignedSingleExtendB: Will be taken into account for next bytecode."
		hadExtendA := bytecode = 224.
		oldExtendBByte := nil.
		(bytecode = 225 and: [pc+1 <= end]) ifTrue: [
			oldExtendBByte := bytecodesAndPadInfo at: pc+1 ].
		
		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/29/2025 16:03:20'!
            withLongInstVarAccessConversion02On: bytecodesAndPadInfo
	"Correct #branch (branch and jump bytecodes) with correct jump distance."

	| newDistance oldDistance |
	1 to: bytecodesAndPadInfo size do: [ :i | | entry |
		entry := bytecodesAndPadInfo at: i.
		(entry isArray and: [entry first = #branch]) ifTrue: [ | newDistanceHigh newDistanceLow |
			oldDistance := entry fourth.
			newDistance := oldDistance.
			i+entry second to: i+entry second+oldDistance-oldDistance sign by: oldDistance sign do: [ :j | | eachJumpedOver |
				eachJumpedOver := bytecodesAndPadInfo at: j.
				eachJumpedOver isArray ifTrue: [ newDistance := newDistance + eachJumpedOver third ]].
			"See #genUnsignedSingleExtendB: and #genSignedSingleExtendB:"
			newDistanceHigh := newDistance >> 8. newDistanceHigh < 0 ifTrue: [newDistanceHigh := newDistanceHigh + 256].
			newDistanceLow := newDistance bitAnd: 255.
			entry fifth "High byte goes to existing extB if there was one. Or to a new one otherwise."
				ifNil: [ bytecodesAndPadInfo at: i-1 put: newDistanceHigh ]
				ifNotNil: [ :extB | extB at: 2 put: newDistanceHigh ].
			entry sixth at: 2 put: newDistanceLow ]].! !
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/29/2025 16:03:48'!
              withLongInstVarAccessConversion03On: bytecodesAndPadInfo
	"Write the updated bytecode sequence using the already calculated bytecodes."
	
	^ByteArray streamContents: [ :strm | | i |
		i := 1.
		[ i <= bytecodesAndPadInfo size ] whileTrue: [ | entry |
			entry := bytecodesAndPadInfo at: i.
			entry isArray
				ifTrue: [
					entry first == #ivarAccess ifTrue: [
						strm nextPutAll: entry fourth ].
					entry first == #branch ifTrue: [
						entry fifth ifNotNil: [ :extB | strm nextPutAll: extB ].
						strm nextPutAll: entry sixth ].
					i := i + entry second ]
				ifFalse: [
					strm nextPut: entry.
					i := i + 1 ]]].! !
!EncoderForV3PlusClosures class methodsFor: 'services' stamp: 'jmv 7/30/2025 15:24:12'!
             withLongInstVarAccessBytecodes: aCompiledMethodOrMethodSpec
	"This method is provided for compatibility with EncoderForSistaV1.
	However, the desired result can not be produced for the V3 Bytecode Set.
	The reason is the need for a space padding NOP bytecode, missing in V3.
	Answer nil: no conversion possible."

	^nil! !
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/30/2025 16:36:30' prior: 50356054!
                            displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvarToDisplace. Displace them by delta.
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"To handle inst var indexes > 255 the following is necessary:
		- Two byte ivar access opcodes, #[226 240 243], need to be prepended by a (possibly zero) extendA bytecode
		- 1 byte ivar access opcodes, [0..15],[200..207], need to also be followed by NOT bytecode 0x5F
	These conditions can be fullfilled by calling #withLongInstVarAccessBytecodes: . See senders and implementors."

	| pc end oldExtendA bytecode oldIvar newIvar bytecodeSize |

	"Just in case..."
	delta = 0 ifTrue: [ ^true ].
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		oldIvar := aCompiledMethodOrMethodSpec returnField+1.
		oldIvar >= firstIvarToDisplace ifTrue: [
			| primitiveCode |
			newIvar := oldIvar+delta.
			newIvar > 256 ifTrue: [
				aBoolean ifTrue: [self error: 'Can not convert a quick return instance variable into the long form.'].
				^false].
			aBoolean ifTrue: [
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	oldExtendA := nil.
	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256  ]]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format. Also handle extA (four byte format)"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldIvar := (aCompiledMethodOrMethodSpec at: pc+1) + 1.
			oldExtendA ifNotNil: [ oldIvar := oldExtendA * 256 + oldIvar ].
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format with possible oldExtendA"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
					oldExtendA notNil ifTrue: [
						aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ].
					"Shorten to 1 byte format + NOP #genPushInstVar:"
					(bytecode = 226 and: [ newIvar <= 16 ]) ifTrue: [
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					"Shorten to 1 byte format + NOP #genStorePopInstVar:"
					(bytecode = 240 and: [ newIvar <= 8 ]) ifTrue: [ 
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"#genUnsignedSingleExtendA:"
		oldExtendA := nil.
		bytecode = 224 ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldExtendA := aCompiledMethodOrMethodSpec at: pc+1 ].

		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/30/2025 16:36:42' prior: 50356247!
            remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #displaceInstVarAccessesIn:starting:by:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"To handle inst var indexes > 255 the following is necessary:
		- Two byte ivar access opcodes, #[226 240 243], need to be prepended by a (possibly zero) extendA bytecode
		- 1 byte ivar access opcodes, [0..15],[200..207], need to also be followed by NOT bytecode 0x5F
	These conditions can be fullfilled by calling #withLongInstVarAccessBytecodes: . See senders and implementors."

	| pc end oldExtendA bytecode oldIvar bytecodeSize |

	"Just in case..."
	aDictionary isEmpty ifTrue: [ ^true ].

	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		oldIvar := aCompiledMethodOrMethodSpec returnField+1.
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			| primitiveCode |
			newIvar > 256 ifTrue: [
				aBoolean ifTrue: [self error: 'Can not convert a quick return instance variable into the long form.'].
				^false].
			aBoolean ifTrue: [
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	oldExtendA := nil.
	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format. Also handle extA (four byte format)"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldIvar := (aCompiledMethodOrMethodSpec at: pc+1) + 1.
			oldExtendA ifNotNil: [ oldIvar := oldExtendA * 256 + oldIvar ].
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format with possible oldExtendA"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
					oldExtendA notNil ifTrue: [
						aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ].
					"Shorten to 1 byte format + NOP #genPushInstVar:"
					(bytecode = 226 and: [ newIvar <= 16 ]) ifTrue: [
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					"Shorten to 1 byte format + NOP #genStorePopInstVar:"
					(bytecode = 240 and: [ newIvar <= 8 ]) ifTrue: [
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"#genUnsignedSingleExtendA:"
		oldExtendA := nil.
		bytecode = 224 ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldExtendA := aCompiledMethodOrMethodSpec at: pc+1 ].

		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		pc := pc + bytecodeSize ].

	^true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7392-InstVarRemap-AddExtAIfNeeded-JuanVuletich-2025Jul31-10h12m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7391] on 31 July 2025 at 12:21:49 pm'!
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/31/2025 11:57:18' prior: 50357008!
                     displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvarToDisplace. Displace them by delta.
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"To handle inst var indexes > 255 the following is necessary:
		- Two byte ivar access opcodes, #[226 240 243], need to be prepended by a (possibly zero) extendA bytecode
		- 1 byte ivar access opcodes, [0..15],[200..207], need to also be followed by NOT bytecode 0x5F
	These conditions can be fullfilled by calling #withLongInstVarAccessBytecodes: . See senders and implementors."

	| pc end oldExtendA bytecode oldIvar newIvar bytecodeSize |

	"Just in case..."
	delta = 0 ifTrue: [ ^true ].
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		oldIvar := aCompiledMethodOrMethodSpec returnField+1.
		oldIvar >= firstIvarToDisplace ifTrue: [
			| primitiveCode |
			newIvar := oldIvar+delta.
			newIvar > 256 ifTrue: [
				aBoolean ifTrue: [self error: 'Can not convert a quick return instance variable into the long form.'].
				^false].
			aBoolean ifTrue: [
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	oldExtendA := nil.
	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							bytecodeSize := 2.
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256  ]]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							bytecodeSize := 2.
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format. Also handle extA (four byte format)"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldIvar := (aCompiledMethodOrMethodSpec at: pc+1) + 1.
			oldExtendA ifNotNil: [ oldIvar := oldExtendA * 256 + oldIvar ].
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format with possible oldExtendA"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
					oldExtendA notNil ifTrue: [
						aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ].
					"Shorten to 1 byte format + NOP #genPushInstVar:"
					(bytecode = 226 and: [ newIvar <= 16 ]) ifTrue: [
						bytecodeSize := 1.	"Hasn't any effect, but hopefully makes more sense to reader."
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					"Shorten to 1 byte format + NOP #genStorePopInstVar:"
					(bytecode = 240 and: [ newIvar <= 8 ]) ifTrue: [ 
						bytecodeSize := 1.	"Hasn't any effect, but hopefully makes more sense to reader."
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"#genUnsignedSingleExtendA:"
		oldExtendA := nil.
		bytecode = 224 ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldExtendA := aCompiledMethodOrMethodSpec at: pc+1 ].

		pc := pc + bytecodeSize ].

	^true! !
!EncoderForSistaV1 class methodsFor: 'services' stamp: 'jmv 7/31/2025 11:56:39' prior: 50357205!
     remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #displaceInstVarAccessesIn:starting:by:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"To handle inst var indexes > 255 the following is necessary:
		- Two byte ivar access opcodes, #[226 240 243], need to be prepended by a (possibly zero) extendA bytecode
		- 1 byte ivar access opcodes, [0..15],[200..207], need to also be followed by NOT bytecode 0x5F
	These conditions can be fullfilled by calling #withLongInstVarAccessBytecodes: . See senders and implementors."

	| pc end oldExtendA bytecode oldIvar bytecodeSize |

	"Just in case..."
	aDictionary isEmpty ifTrue: [ ^true ].

	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		oldIvar := aCompiledMethodOrMethodSpec returnField+1.
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			| primitiveCode |
			newIvar > 256 ifTrue: [
				aBoolean ifTrue: [self error: 'Can not convert a quick return instance variable into the long form.'].
				^false].
			aBoolean ifTrue: [
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	oldExtendA := nil.
	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							bytecodeSize := 2.
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							bytecodeSize := 2.
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format. Also handle extA (four byte format)"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldIvar := (aCompiledMethodOrMethodSpec at: pc+1) + 1.
			oldExtendA ifNotNil: [ oldIvar := oldExtendA * 256 + oldIvar ].
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format with possible oldExtendA"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
					oldExtendA notNil ifTrue: [
						aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ].
					"Shorten to 1 byte format + NOP #genPushInstVar:"
					(bytecode = 226 and: [ newIvar <= 16 ]) ifTrue: [
						bytecodeSize := 1.	"Hasn't any effect, but hopefully makes more sense to reader."
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					"Shorten to 1 byte format + NOP #genStorePopInstVar:"
					(bytecode = 240 and: [ newIvar <= 8 ]) ifTrue: [
						bytecodeSize := 1.	"Hasn't any effect, but hopefully makes more sense to reader."
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"#genUnsignedSingleExtendA:"
		oldExtendA := nil.
		bytecode = 224 ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldExtendA := aCompiledMethodOrMethodSpec at: pc+1 ].

		pc := pc + bytecodeSize ].

	^true! !
!EncoderForV3PlusClosures class methodsFor: 'services' stamp: 'jmv 7/31/2025 11:52:12' prior: 50356437!
                         displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvarToDisplace. Displace them by delta.
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"This method can not handle remapping of 1-byte ivar access bytecodes: [0..15], [96..103]
	This method can not convert two byte bytecodes #[128 129 130] to or from three byte 132 + #[64 160 192].
	However the Sista Bytecode version of this method can.
	It is therefore recommended to use the Sista Bytecode Set."

	| pc end bytecode followingByte thirdByte oldIvar newIvar bytecodeSize |
	"Just in case..."
	delta = 0 ifTrue: [ ^true ].
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ]	.

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				| primitiveCode |
				newIvar := oldIvar+delta.
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 							"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode + 1 ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		oldIvar >= firstIvarToDisplace ifTrue: [
			aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
			^false ]	.
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			followingByte+1 >= firstIvarToDisplace ifTrue: [
				followingByte+delta < 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: followingByte+delta ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			thirdByte+1 >= firstIvarToDisplace ifTrue: [
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: thirdByte+delta ]]].

		pc := pc + bytecodeSize ].

	^true! !
!EncoderForV3PlusClosures class methodsFor: 'services' stamp: 'jmv 7/31/2025 11:52:49' prior: 50356565!
         remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Similar to #displaceInstVarAccessesIn:starting:by:doIt:
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive"
	
	"This method can not handle remapping of 1-byte ivar access bytecodes: [0..15], [96..103]
	This method can not convert two byte bytecodes #[128 129 130] to or from three byte 132 + #[64 160 192].
	However the Sista Bytecode version of this method can.
	It is therefore recommended to use the Sista Bytecode Set."

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ]	.

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			aDictionary at: aCompiledMethodOrMethodSpec returnField+1 ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 							"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode + 1 ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			newIvar = oldIvar ifFalse: [
				aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
				^false ]	].
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			aDictionary at: followingByte+1 ifPresent: [ :newIvar |
				newIvar <= 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			aDictionary at: thirdByte+1 ifPresent: [ :newIvar |
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: newIvar-1 ]]].

		pc := pc + bytecodeSize ].

	^true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7393-InstVarRemap-Bugfix-JuanVuletich-2025Jul31-12h20m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7389] on 31 July 2025 at 3:49:04 pm'!
!LayoutAdjustingMorph methodsFor: 'accessing' stamp: 'HAW 7/31/2025 15:44:18' prior: 50340782!
    cursor

	^self localBounds isTall 
		ifTrue: [ Cursor cursorAt: #resizeLeftCursor ]
		ifFalse: [ Cursor cursorAt: #resizeTopCursor ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7394-LayoutAdjustingMorph_cursor_dependsOnBounds-HernanWilkinson-2025Jul30-18h09m-HAW.001.cs.st----!

'From Cuis7.5 [latest update: #7394] on 2 August 2025 at 4:47:03 pm'!
!LayoutSizeSpec methodsFor: 'accessing' stamp: 'jmv 8/2/2025 16:44:33'!
           proportionalHeight
	^proportionalHeight! !
!LayoutSizeSpec methodsFor: 'accessing' stamp: 'jmv 8/2/2025 16:44:27'!
             proportionalWidth
	^proportionalWidth! !
!LayoutSizeSpec methodsFor: 'private' stamp: 'jmv 8/2/2025 16:46:33' prior: 16898262!
 privateProportionalHeight
	"deprecated
	Please use #proportionalHeight"

	^ proportionalHeight! !
!LayoutSizeSpec methodsFor: 'private' stamp: 'jmv 8/2/2025 16:46:24' prior: 16898266!
        privateProportionalWidth
	"deprecated
	Please use #proportionalWidth"

	^ proportionalWidth ! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7395-LayoutSizeSpec-getters-JuanVuletich-2025Aug02-16h44m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7395] on 3 August 2025 at 4:40:02 pm'!
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 8/3/2025 16:38:51' prior: 50354536 overrides: 16796227!
           borderWidth: anInteger

	super borderWidth: anInteger.
	self layoutNeeded: true.! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 8/3/2025 16:38:47' prior: 50354542 overrides: 16796238!
   padding: numberOrPoint
	"Honored by all kinds of Layouts"

	super padding: numberOrPoint.
	self layoutNeeded: true.! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 8/3/2025 16:39:02' prior: 50354360!
              axisEdgeWeight: aSymbolOrNumber
	"Along the Major or Layout Axis, subMorphs may be attracted toward one side (0.0) or the other (1.0).  This is the LayoutMorph's axisEdgeWeight.  A numeric value is between 0.0 and 1.0

	If a Row, one can specify this weight symbolically as
	  { #rowLeft (0.0), #center (0.5), #rowRight (1.0)}

	If a Column, one can specify the weight symbolically as:
	  { #columnTop (0.0), #center (0.5), #columnBottom (1.0) }
	
	Ignored for other kinds of Layouts"
"	
	self axisEdgeWeight: #rowLeft.	-- axis must be horizontal 
	self axisEdgeWeight: #columnTop.	-- axis must be vertical
"
	layoutObject axisEdgeWeight: aSymbolOrNumber.
	self layoutNeeded: true.! !
!LinearLayoutMorph methodsFor: 'accessing' stamp: 'jmv 8/3/2025 16:38:57' prior: 50354390!
                        gap: aNumber
	"Only for Linear Layouts"
	layoutObject gap = aNumber ifFalse: [
		self adjustExtentFor: [
			layoutObject gap: aNumber ]].
	self layoutNeeded: true.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 8/3/2025 16:39:17' prior: 50352440!
                         beColumn
	"Establish the major layout axis, with default edge weight"
	layoutObject := ColumnLayout new.
	layoutObject gap: self defaultGap.
	self layoutNeeded: true.! !
!LinearLayoutMorph methodsFor: 'initialization' stamp: 'jmv 8/3/2025 16:39:20' prior: 50352449!
                      beRow
	"Establish the major layout axis, with default edge weight"
	layoutObject := RowLayout new.
	layoutObject gap: self defaultGap.
	self layoutNeeded: true.! !
!LayoutSpec methodsFor: 'private' stamp: 'jmv 8/3/2025 16:38:28' prior: 50354854!
          updateContainingLayout
	| owningLayoutMorph |
	morph ifNotNil: [
		owningLayoutMorph := morph owner.
		(owningLayoutMorph is: #LayoutMorph) ifTrue:
			[ owningLayoutMorph layoutNeeded: true ]].! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 8/3/2025 16:32:50' prior: 50342599!
  bottomRightEdgesWeight: aPoint
	"Argument x and y must be in [0.0 .. 1.0]"
	bottomRightEdgesWeight := aPoint.
	self updateContainingLayout.! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 8/3/2025 16:33:00' prior: 50342609!
                        bottomRightOffset: aPoint
	bottomRightOffset := aPoint.
	self updateContainingLayout.! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 8/3/2025 16:32:33' prior: 50342618!
              topLeftEdgesWeight: aPoint
	"Argument x and y must be in [0.0 .. 1.0]"
	topLeftEdgesWeight := aPoint.
	self updateContainingLayout.! !
!LayoutEdgesSpec methodsFor: 'accessing' stamp: 'jmv 8/3/2025 16:32:42' prior: 50342628!
topLeftOffset: aPoint
	topLeftOffset := aPoint.
	self updateContainingLayout.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7396-LayoutUpdatingTweaks-JuanVuletich-2025Aug03-16h30m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7396] on 5 August 2025 at 9:50:26 am'!
!SerializableBlockClosure methodsFor: 'initialization' stamp: 'jmv 9/26/2019 19:34:11' prior: 50347267!
                             onBlockClosure: aBlockClosure

	| both blockNode methodNode indirectTempNames sortedOuterTemps ownNames usedOuterNames sortedUsedOuterNames |
	aBlockClosure hasNonLocalReturn ifTrue: [
		self error: 'Can not serialize closures with non-local returns.' ].
	aBlockClosure sendsToSuper ifTrue: [
		self error: 'Can not currently serialize closures with super sends.' ].
	both := SerializableClosureDecompiler new  decompileBlockAndMethod: aBlockClosure.
	blockNode := both first.
	methodNode := both second.

	indirectTempNames := methodNode temporaries
		detect: [ :node | node isIndirectTempVector ]
		ifFound: [ :node | node remoteTemps collect: [ :n | n name ]]
		ifNone: [#()].
	sortedOuterTemps := OrderedCollection new.
	aBlockClosure outerContextsDo: [ :c | c closure ifNotNil: [ :cc |
		| ccn |
		ccn := cc decompile.
		sortedOuterTemps addAll: ccn arguments; addAll: ccn temporaries ]].
	sortedOuterTemps addAll: methodNode temporaries; addAll: methodNode arguments.

	ownNames := ((blockNode arguments, blockNode temporaries)
		collect: [ :node | node name ]) asSet.
	usedOuterNames := Set new.
	blockNode nodesDo: [ :node | node isTemp ifTrue: [
		(ownNames includes: node name) | (indirectTempNames includes: node name) ifFalse: [
			usedOuterNames add: node name]]].

	sortedUsedOuterNames := sortedOuterTemps select: [ :node |
		usedOuterNames includes: node name ]. "sort them"
	sortedUsedOuterNames := sortedUsedOuterNames collect: [ :node | node name ].

	blockNode nodesDo: [ :node | node isTemp ifTrue: [ 
		node isRemote
			ifTrue: [node capturedIndex: (indirectTempNames indexOf: node name) ]
			ifFalse: [
				(sortedUsedOuterNames includes: node name)
					ifTrue: [node capturedIndex: (sortedUsedOuterNames indexOf: node name)]]]].

	theSelf := aBlockClosure receiver.
	capturedValues := aBlockClosure capturedValues.
	sourceCode := blockNode decompileString.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7397-Tweak-JuanVuletich-2025Aug05-09h02m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7397] on 5 August 2025 at 11:51:25 am'!
!CompiledMethod methodsFor: 'testing' stamp: 'jmv 8/5/2025 11:50:33' prior: 16835525!
                 isGetterOf: anInstVarName at: anInstVarIndex
	
	| scanner instruction |
	
	"Quick return. (Short form)."
	(self selector = anInstVarName 
		and: [ self isReturnField 
		and: [ self returnField + 1 = anInstVarIndex ]])
			ifTrue: [ ^true ].
	
	"Long Form"
	self isQuick ifTrue: [ ^false ].
	self selector = anInstVarName ifFalse: [ ^false ].
	scanner := InstructionStream on: self.
	instruction := scanner nextInstruction.
	(instruction selector == #pushReceiverVariable:
	 and: [instruction argument = (anInstVarIndex - 1)]) ifFalse:
		[^false].
	^scanner nextInstruction selector == #methodReturnTop! !
!CompiledMethod methodsFor: 'testing' stamp: 'jmv 8/5/2025 11:41:41' prior: 16835596!
              isSetterOf: anInstVarName at: anInstVarIndex
	"Check if the receiver is a setter of the give inst var located at instVarIndex.
	 Only look at the bytecode to avoid soiurce code parsing issues."
	| scanner instruction |
	
	self isQuick ifTrue: [ ^false ].
	self selector = (anInstVarName, ':') ifFalse: [ ^false ].
	scanner := InstructionStream on: self.
	instruction := scanner nextInstruction.
	(instruction selector == #pushTemporaryVariable:
	 and: [instruction argument = 0]) ifFalse:
		[^false].
	instruction := scanner nextInstruction.
	(instruction selector == #popIntoReceiverVariable:
	 and: [instruction argument = (anInstVarIndex - 1)]) ifFalse:
		[^false].
	scanner peekInstruction selector == #doNop ifTrue: [
		scanner nextInstruction ].
	^scanner nextInstruction selector == #methodReturnReceiver! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7398-CompiledMethod-isGetterOf-isSetterOf-LongSistaForms-JuanVuletich-2025Aug05-11h39m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7398] on 10 August 2025 at 4:09:45 pm'!
!ColumnLayout methodsFor: 'layout' stamp: 'jmv 8/10/2025 16:09:31' prior: 50341678!
                   layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleMorphs gapCount heights heightToAllocate leftOver y cache |

	visibleMorphs := (morphs select: [ :m | m visible ]) reversed. "Display Order"
	visibleMorphs isEmpty ifTrue: [ ^self ].
	gapCount := visibleMorphs size - 1. "gap between each contained Morph"
	heightToAllocate := boundsForLayout height - (gapCount * gap).
	cache := IdentityDictionary new.
	heights := self heightsFor: visibleMorphs within: heightToAllocate minLayoutExtentCache: cache.
	leftOver := heightToAllocate - heights sum.
	y := boundsForLayout top + (leftOver * axisEdgeWeight).

	visibleMorphs with: heights do: [ :sm :smHeight |
		| width x |
		width := self offAxisWidthFor: sm within: boundsForLayout width minLayoutExtentCache: cache.
		x := self offAxisXOffsetFor: sm within: boundsForLayout width - width.
		sm fitInto: (boundsForLayout left + x @ y extent: width @ smHeight).
		y := y + smHeight + gap.
	].! !
!RowLayout methodsFor: 'layout' stamp: 'jmv 8/10/2025 16:09:35' prior: 50341711!
      layoutMorphs: morphs in: boundsForLayout
	"Compute a new layout based on the given layout bounds."

	| visibleMorphs gapCount widths widthToAllocate leftOver x cache |

	visibleMorphs := (morphs select: [ :m | m visible ]) reversed. "Display Order"
	visibleMorphs isEmpty ifTrue: [ ^self ].
	gapCount := visibleMorphs size - 1. "gap between each contained Morph"
	widthToAllocate := boundsForLayout width - (gapCount * gap).
	cache := IdentityDictionary new.
	widths := self widthsFor: visibleMorphs within: widthToAllocate minLayoutExtentCache: cache.
	leftOver := widthToAllocate - widths sum.
	x := boundsForLayout left + (leftOver * axisEdgeWeight).

	visibleMorphs with: widths do: [ :sm :smWidth |
		| height y |
		height := self offAxisHeightFor: sm within: boundsForLayout height minLayoutExtentCache: cache.
		y := self offAxisYOffsetFor: sm within: boundsForLayout height - height.
		sm fitInto: (x @ (boundsForLayout top + y) extent: smWidth @ height).
		x := x + smWidth + gap.
	].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7399-LayoutFix-JuanVuletich-2025Aug10-16h08m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7399] on 11 August 2025 at 2:58:38 pm'!
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 8/11/2025 14:56:49'!
                    visibleRowIntervalForCanvas: aCanvas
	"return the interval visible rows in aCanvas's clip rectangle"
	| tx clipRect rows |
	tx := aCanvas currentTransformation.
	clipRect := aCanvas clipRect.
	rows := clipRect corners collect: [ :corner |
		self rowAtLocation: (tx internalizePosition: corner) ].
	^rows min to: rows max.! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 8/11/2025 14:56:07' prior: 16886558 overrides: 16833122!
                drawOn: aCanvas

	listItems isEmpty ifTrue: [ ^self ].
 
	self drawHighlightOn: aCanvas.
	self drawSelectionOn: aCanvas.

	(self visibleRowIntervalForCanvas: aCanvas)
		do: [ :row |
			(owner itemSelectedAmongMultiple:  row) ifTrue: [
				self drawBackgroundForMulti: row on: aCanvas. ].
			self draw: (self item: row) displayStringOrText atRow: row on: aCanvas ]! !

InnerListMorph removeSelector: #bottomVisibleRowForCanvas:!

!methodRemoval: InnerListMorph #bottomVisibleRowForCanvas: stamp: 'Install-7400-rotatedListFix-JuanVuletich-2025Aug11-14h58m-jmv.001.cs.st 8/29/2025 15:07:08'!
bottomVisibleRowForCanvas: aCanvas
	"return the bottom visible row in aCanvas's clip rectangle"
	| tx clipRect |
	tx := aCanvas currentTransformation.
	clipRect := aCanvas clipRect.
	^ (self rowAtLocation: (tx internalizePosition: clipRect bottomLeft))
		max: (self rowAtLocation: (tx internalizePosition: clipRect bottomRight))!

InnerListMorph removeSelector: #topVisibleRowForCanvas:!

!methodRemoval: InnerListMorph #topVisibleRowForCanvas: stamp: 'Install-7400-rotatedListFix-JuanVuletich-2025Aug11-14h58m-jmv.001.cs.st 8/29/2025 15:07:08'!
topVisibleRowForCanvas: aCanvas
	"return the top visible row in aCanvas's clip rectangle"
	| tx clipRect |
	tx := aCanvas currentTransformation.
	clipRect := aCanvas clipRect.
	^ (self rowAtLocation: (tx internalizePosition: clipRect topLeft))
		min: (self rowAtLocation: (tx internalizePosition: clipRect topRight))!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7400-rotatedListFix-JuanVuletich-2025Aug11-14h58m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7400] on 11 August 2025 at 6:10:55 pm'!
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 8/11/2025 18:05:54' prior: 16936676!
                 prefSystem
	^ #(
		#(allowNonLocalReturnsInExceptionHandlers true )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges true )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(warnAndOfferLastUserChanges true )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #cuis #(cuis roots) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(useUserPrefsFile true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
		#(saveReleaseOptionsInWorldMenu false)
		#(useAllwaysOffScreenDisplay false)
	)! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
	Preferences
		name: #useAllwaysOffScreenDisplay
		category: #system
		value: false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7401-add-useAllwaysOffScreenDisplay-preference-JuanVuletich-2025Aug11-18h05m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7400] on 11 August 2025 at 6:10:55 pm'!
!DisplayScreen methodsFor: 'other' stamp: 'jmv 8/11/2025 18:09:36' prior: 16851044!
                    deferUpdates: aBoolean
	"Set the deferUpdates flag in the virtual machine. When this flag is true, BitBlt operations on the Display are not automatically propagated to the screen.  To actually make them visible, call #forceToScreen: .
	If this underlying platform does not support deferred updates, this primitive will fail. Answer  nil if it fails.
	Most platforms do support this functionality. You can turn it off for playing with Display directly."

	"Enable this to act as if the VM didn't support defer updates, even when it does.
	This may help eliminate possible flickering."
	"
	Preferences
		name: #useAllwaysOffScreenDisplay
		category: #system
		value: false
	"
	(Preferences at: #useAllwaysOffScreenDisplay)
		ifTrue: [ ^nil ].

	"Note: If we disable VM defer updates (with this &false), but answer notNil, the the Morphic workaround is not used,
	and you get a lot of flicking."
	"As of as August 2024, the Mac VM (intel) doesn't support deferred updates and uses this auxiliar Form as target.
	Both Linux and Windows VM do support it, so Morphic Canvas target is Display."
	^self primitiveDeferUpdates: aBoolean "& false"! !
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 8/11/2025 18:10:24' prior: 50336934!
      forceDeferredToScreen: updateRect
	"Force the given rectangular section of the Display to be copied to the host screen. Make it visible to user."

	DeferredUpdatingDisplay ifNil:
		[ ^self ].
	DisplayScreen isDisplayExtentOk ifFalse:
		[ ^self ].
	DeferredUpdatingDisplay == Display
		ifTrue:
			[Display forceToScreen: updateRect ]
		ifFalse:
			[
			(BitBlt toForm: Display)
				sourceForm: DeferredUpdatingDisplay;
				combinationRule: Form over;
				sourceRect: updateRect;
				destOrigin: updateRect topLeft;
				copyBits.
			(Preferences at: #useAllwaysOffScreenDisplay)
				ifTrue:
					[Display forceToScreen: updateRect ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7402-use-useAllwaysOffScreenDisplay-preference-JuanVuletich-2025Aug11-18h05m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7402] on 12 August 2025 at 11:01:01 am'!
!Encoder methodsFor: 'private' stamp: 'jmv 8/12/2025 10:48:26'!
   warnAboutShadowed: aVariableNode evenIfDuringFileIn: aBoolean

	| msg transcriptMsg |
	msg := 'There already exists ', aVariableNode descriptiveString withArticle, '. Please use a different name.'.
	requestor addWarning: msg.
	transcriptMsg := msg, ' (In definition of: ', class name.
	selector
		ifNotNil: [
			transcriptMsg := transcriptMsg, '>>', selector printString ].
	(transcriptMsg, ')') print.
	
	aBoolean
		ifTrue: [self notify: msg]
		ifFalse: [
			InMidstOfFileinNotification signal ifFalse: [
					requestor interactive
						ifTrue: [
							self notify: msg ]
						ifFalse: [
							(RecompilationFailure class: class messageText: msg) signal ]]]! !
!VariableNode methodsFor: 'printing' stamp: 'jmv 8/12/2025 10:03:12'!
descriptiveString

	^self class name, ' named: ', name printString! !
!InstanceVariableNode methodsFor: 'printing' stamp: 'jmv 8/12/2025 10:02:45' overrides: 50358640!
                        descriptiveString

	^'Instance Variable named: ', name printString! !
!TempVariableNode methodsFor: 'printing' stamp: 'jmv 8/12/2025 10:12:07' overrides: 50358640!
                            descriptiveString
	self isMethodArg
		ifTrue: [ ^'Method Argument named: ', name printString ].
	self isBlockArg
		ifTrue: [ ^'Block Argument named: ', name printString ].
	^'Temporary Variable named: ', name printString! !
!Encoder methodsFor: 'temps' stamp: 'jmv 8/12/2025 10:59:18' prior: 16854010!
                  autoBind: name 
	"Declare a block argument as a temp if not already declared."
	| node |
	node := scopeTable 
			at: name
			ifAbsent: 
				[(self lookupInPools: name ifFound: [:assoc | assoc])
					ifTrue: [self warnAboutShadowed: name evenIfDuringFileIn: false].
				^ (self reallyBind: name) nowHasDef nowHasRef scope: 1].
	node isTemp
		ifTrue: [node scope >= 0 ifTrue:
					[^self warnAboutShadowed: node evenIfDuringFileIn: true].
				node nowHasDef nowHasRef scope: 1]
		ifFalse: [^self warnAboutShadowed: node evenIfDuringFileIn: true].
	^node! !
!Encoder methodsFor: 'temps' stamp: 'jmv 8/12/2025 10:57:45' prior: 16854086!
       bindBlockTemp: name 
	"Declare a temporary block variable; complain if it's not a field or class variable."

	| node |
	node := scopeTable at: name ifAbsent: [^self reallyBind: name].
	node isTemp
		ifTrue: [
			node scope >= 0 ifTrue: [^self warnAboutShadowed: node evenIfDuringFileIn: true].
			node scope: 0]
		ifFalse: [^self warnAboutShadowed: node evenIfDuringFileIn: true].
	^node
! !
!Encoder methodsFor: 'temps' stamp: 'jmv 8/12/2025 10:58:47' prior: 16854138!
          bindTemp: name 
	"Declare a temporary; error not if a field or class variable."
	scopeTable at: name ifPresent:[:node|
		"When non-interactive raise the error only if its a duplicate"
		node isTemp
			ifTrue:[^self warnAboutShadowed: node evenIfDuringFileIn: true]
			ifFalse:[self warnAboutShadowed: name evenIfDuringFileIn: false]].
	^self reallyBind: name! !
!BytecodeEncoder methodsFor: 'temps' stamp: 'jmv 8/12/2025 11:00:22' prior: 16801903 overrides: 50358697!
            bindTemp: name
	"Declare a temporary; error not if a field or class variable or out-of-scope temp."

	scopeTable
		at: name
		ifPresent: [ :node |
			"When non-interactive raise the error only if it is a duplicate"
			node isTemp
				ifTrue: [ node scope >= 0 ifTrue: [
						^self warnAboutShadowed: node evenIfDuringFileIn: true ]]
				ifFalse: [ 
					self warnAboutShadowed: node evenIfDuringFileIn: false]].
	^ self reallyBind: name.! !

Encoder removeSelector: #warnAboutShadowed:!

!methodRemoval: Encoder #warnAboutShadowed: stamp: 'Install-7403-BetterShadowedVariableErrors-JuanVuletich-2025Aug12-10h54m-jmv.003.cs.st 8/29/2025 15:07:08'!
warnAboutShadowed: name

	| msg transcriptMsg |
	
	msg := 'There already exists a variable named ', name, ' '.
	requestor addWarning: msg.
	
	transcriptMsg := msg, ' (', class className, '>>', selector printString,')'. 
	Transcript newLine; show: transcriptMsg.
	
	InMidstOfFileinNotification signal
		ifFalse: [
			requestor interactive
				ifTrue: [
					self notify: msg]
				ifFalse: [
					(RecompilationFailure
						class: class
						messageText: msg, String newLineString, 'Please use a different name') signal ]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7403-BetterShadowedVariableErrors-JuanVuletich-2025Aug12-10h54m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7403] on 12 August 2025 at 2:36:11 pm'!
!Parser methodsFor: 'expression types' stamp: 'jmv 8/12/2025 13:00:30'!
                 addArgumentNames: argNames argRanges: argRanges toArguments: arguments isDoIt: aBoolean

	| prevMarkRecover |
	prevMarkRecover := prevMark.
	argNames with: argRanges do: [ :argName :range |
		(argName = Encoder doItInContextName and: [ aBoolean ])
			ifTrue: [ arguments addLast: (encoder addMultiRange: range for: (encoder lookupVariable: argName ifAbsent: [ self shouldNotHappen ]))]
			ifFalse: [
				"This is done so #notify: is shown at the right position."
				prevMark := range first.
				arguments addLast: (encoder bindArg: argName range: range)]].
	prevMark := prevMarkRecover! !
!Parser methodsFor: 'expression types' stamp: 'jmv 8/12/2025 13:02:02'!
          addKeywordPatternPartTo: selector keywordRanges: keywordRanges argumentNames: argNames argRanges: argRanges

	self advanceWithRangeDo: [ :keywordAsString :range |
		selector nextPutAll: keywordAsString.
		keywordRanges add: range ].

	self argumentNameWithRangeDo: [ :argName :range |
		argNames addLast: argName.
		argRanges addLast: range ].! !
!Parser methodsFor: 'as yet unclassified' stamp: 'jmv 8/12/2025 13:07:52'!
                          selector: aSymbol
	encoder == self ifFalse: [
		encoder selector: aSymbol ].
	self properties selector: aSymbol.! !
!Parser methodsFor: 'expression types' stamp: 'jmv 8/12/2025 13:08:14' prior: 16927958!
                    binaryPattern

	^ self advanceWithRangeDo: [ :selectorAsString :selectorRange | | selectorsymbol arguments |
		selectorsymbol := selectorAsString asSymbol.
		self selector: selectorsymbol.
		self argumentNameWithRangeDo: [ :argumentName :argumentRange |
		arguments := Array with: (encoder bindArg: argumentName range: argumentRange).
		{selectorsymbol. arguments. 2. {selectorRange}}]]! !
!Parser methodsFor: 'expression types' stamp: 'jmv 8/12/2025 13:08:09' prior: 16928134!
  keywordPattern

	| keywordRanges selector selectorsymbol argNames argRanges arguments |
	
	selector := source collectionSpecies writeStream.
	keywordRanges := OrderedCollection new.
	argNames := OrderedCollection new.
	argRanges := OrderedCollection new.
	arguments := OrderedCollection new.
	
	"[hereType == #keyword] whileTrue:[ 
		self addKeywordPatternPartTo: selector keywordRanges: keywordRanges arguments: arguments ]."
	
	[hereType == #keyword] whileTrue:[ 
		self addKeywordPatternPartTo: selector keywordRanges: keywordRanges  argumentNames: argNames argRanges: argRanges ].
	
	selectorsymbol := selector contents asSymbol.
	self selector: selectorsymbol.
	
	self addArgumentNames: argNames argRanges: argRanges toArguments: arguments isDoIt: selector contents = self class doItInSelector.
		
	^ {selectorsymbol. arguments. 3. keywordRanges}! !
!Parser methodsFor: 'expression types' stamp: 'jmv 8/12/2025 13:08:19' prior: 16928458!
                 unaryPattern

	^ self advanceWithRangeDo: [ :sel :range | | selectorsymbol |
		selectorsymbol := sel asSymbol.
		self selector: selectorsymbol.
		{selectorsymbol. {}. 1. {range}} ]! !
!Parser methodsFor: 'expression types' stamp: 'jmv 8/12/2025 13:09:39' prior: 16928243!
                method: noPattern context: ctxt
	" pattern [ | temporaries ] block => MethodNode."

	| sap block primitives tempsDeclarationNode messageComment methodNode |
	
	sap := self pattern: noPattern inContext: ctxt.
	"sap={selector, arguments, precedence}"
	(sap at: 2) do: [:argNode | argNode beMethodArg].
	
	noPattern ifFalse: [self pragmaSequence].
	tempsDeclarationNode := self temporaries.
	messageComment := currentComment.
	currentComment := nil.
	noPattern ifFalse: [self pragmaSequence].
	primitives := self pragmaPrimitives.
	
	self statements: #() innerBlock: noPattern.
	block := parseNode.
	noPattern 
		ifTrue: [block returnLast]
		ifFalse: [block returnSelfIfNoOther: encoder].
	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].
	
	methodNode := self newMethodNode comment: messageComment.
	methodNode
		selector: (sap at: 1)
		arguments: (sap at: 2)
		precedence: (sap at: 3)
		temporariesDeclaration: tempsDeclarationNode
		block: block
		encoder: encoder
		primitive: primitives
		properties: properties
		selectorKeywordsRanges: (sap at: 4).
		
	self interactive ifTrue: [ self performInteractiveChecks: methodNode ].
	
	^methodNode! !
!Encoder methodsFor: 'private' stamp: 'jmv 8/12/2025 13:12:59' prior: 50358617!
         warnAboutShadowed: aVariableNode evenIfDuringFileIn: aBoolean

	| line1 line2 line3 msg |
	line1 := 'During the definition of: ', class name.
	selector ifNotNil: [ line1 := line1, '>>', selector printString. ].
	line2 := ' a clashing ', aVariableNode descriptiveString, ' was found.'.
	line3 := ' Please use a different name.'.
	msg := line1, line2, line3.
	
	msg print.
	requestor addWarning: msg.

	aBoolean
		ifTrue: [self notify: line2]
		ifFalse: [
			InMidstOfFileinNotification signal ifFalse: [
					requestor interactive
						ifTrue: [
							self notify: line2 ]
						ifFalse: [
							msg := line1, String newLineString, line2, String newLineString, line3.
							(RecompilationFailure class: class messageText: msg) signal ]]].! !

Parser removeSelector: #addKeywordPatternPartTo:keywordRanges:arguments:!

!methodRemoval: Parser #addKeywordPatternPartTo:keywordRanges:arguments: stamp: 'Install-7404-Parser-set-selector-evenIfParsingFails-JuanVuletich-2025Aug12-14h28m-jmv.001.cs.st 8/29/2025 15:07:08'!
addKeywordPatternPartTo: selector keywordRanges: keywordRanges arguments: arguments

	self advanceWithRangeDo: [ :keywordAsString :range |
		selector nextPutAll: keywordAsString.
		keywordRanges add: range ].

	self argumentNameWithRangeDo: [ :argName :range |
		"I have to reference Encoder and not enconder becuase in some cases encoder is a parser!!!! - Hernan"
		(argName = Encoder doItInContextName and: [  selector contents = self class doItInSelector ])
			ifTrue: [ arguments addLast: (encoder addMultiRange: range for: (encoder lookupVariable: argName ifAbsent: [ self shouldNotHappen ]))]
			ifFalse: [ arguments addLast: (encoder bindArg: argName range: range)]]
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7404-Parser-set-selector-evenIfParsingFails-JuanVuletich-2025Aug12-14h28m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7404] on 12 August 2025 at 3:21:02 pm'!

PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor buttonStyle '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #PluggableButtonMorph category: #'Morphic-Widgets' stamp: 'Install-7405-better-ButtonStyle-HilaireFernandes-2025Aug12-15h09m-hlsf.001.cs.st 8/29/2025 15:07:08'!
PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor buttonStyle'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'hlsf 8/12/2025 17:51:07'!
                buttonStyle
	^ buttonStyle ! !
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'hlsf 8/12/2025 17:53:39'!
                 buttonStyle: aSymbol
" 
	#none 			Draw only the icon and or label, with no button shape
	#theme 		Honor theme
	#round 			Draw as round button
	#rectangular 	Draw as classic 3d border rectangular button
"

	buttonStyle := aSymbol ! !
!PluggableButtonMorph methodsFor: 'testing' stamp: 'hlsf 8/12/2025 18:03:16'!
         isRound
	^ buttonStyle == #round 
	or: [ buttonStyle == #theme and: [Theme current roundButtons] ]
! !
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'hlsf 8/12/2025 17:53:39' prior: 50331823!
                         noButtonShape
	""
	self buttonStyle: #none.
	self redrawNeeded.! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'hlsf 8/12/2025 18:02:59' prior: 16930870 overrides: 16796275!
           drawOn: aCanvas
	buttonStyle == #none ifFalse: [
		self isRound 
			ifTrue:  [ self drawRoundLookOn: aCanvas ]
			ifFalse: [ self draw3DLookOn: aCanvas ]].

	aCanvas drawButtonIconFromCurrentMorph.! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'hlsf 8/12/2025 17:53:39' prior: 16931098 overrides: 16932597!
                              initialize
	"initialize the state of the receiver"
	super initialize.

	self buttonStyle: #theme.	
	model := nil.
	enableSelector := nil.
	stateSelector := nil.
	stateArgument := nil.
	actionSelector := nil.
	actionArgument := nil.
	isPressed := false.
	mouseIsOver := false.
	mouseOverColor := nil.
	actWhen := #buttonUp.
	extent :=  `20 @ 15`! !
!ScrollBar methodsFor: 'initialization' stamp: 'hlsf 8/12/2025 17:53:52' prior: 16954210!
          updateDownButton: aPluggableButtonMorph
	"Update the argument as a downButton."

	aPluggableButtonMorph
		iconDrawSelector: #drawDownIcon;
		action: #scrollDown;
		buttonStyle: #rectangular;
		redrawNeeded! !
!ScrollBar methodsFor: 'initialization' stamp: 'hlsf 8/12/2025 17:54:02' prior: 16954219!
                     updateLeftButton: aPluggableButtonMorph
	"Update the argument as a leftButton."

	aPluggableButtonMorph
		iconDrawSelector: #drawLeftIcon;
		action: #scrollUp;
		buttonStyle: #rectangular;
		redrawNeeded! !
!ScrollBar methodsFor: 'initialization' stamp: 'hlsf 8/12/2025 17:54:09' prior: 16954228!
                       updateRightButton: aPluggableButtonMorph
	"Update the argument as a rightButton."

	aPluggableButtonMorph
		iconDrawSelector: #drawRightIcon;
		action: #scrollDown;
		buttonStyle: #rectangular;
		redrawNeeded! !
!ScrollBar methodsFor: 'initialization' stamp: 'hlsf 8/12/2025 17:54:16' prior: 16954237!
                  updateUpButton: aPluggableButtonMorph
	"Update the argument as an upButton."

	aPluggableButtonMorph
		iconDrawSelector: #drawUpIcon;
		action: #scrollUp;
		buttonStyle: #rectangular;
		redrawNeeded! !

PluggableButtonMorph removeSelector: #roundButtonStyle:!

!methodRemoval: PluggableButtonMorph #roundButtonStyle: stamp: 'Install-7405-better-ButtonStyle-HilaireFernandes-2025Aug12-15h09m-hlsf.001.cs.st 8/29/2025 15:07:08'!
roundButtonStyle: aBooleanOrNil
	roundButtonStyle := aBooleanOrNil!

PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor buttonStyle'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #PluggableButtonMorph category: #'Morphic-Widgets' stamp: 'Install-7405-better-ButtonStyle-HilaireFernandes-2025Aug12-15h09m-hlsf.001.cs.st 8/29/2025 15:07:08'!
PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor buttonStyle'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
PluggableButtonMorph allSubInstancesDo: [:aButton |
	| roundButtonStyle newStyle |
	roundButtonStyle := aButton instVarNamed: 'roundButtonStyle'.
	roundButtonStyle == nil ifTrue: [newStyle := #theme].
	roundButtonStyle == true ifTrue: [newStyle := #round].
	roundButtonStyle == false ifTrue: [newStyle := #rectangular].
	aButton buttonStyle: newStyle.
	aButton redrawNeeded]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7405-better-ButtonStyle-HilaireFernandes-2025Aug12-15h09m-hlsf.001.cs.st----!

'From Cuis7.5 [latest update: #7404] on 12 August 2025 at 3:21:45 pm'!

PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen buttonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #PluggableButtonMorph category: #'Morphic-Widgets' stamp: 'Install-7406-ButtonStyle-coda-HilaireFernandes-2025Aug12-15h21m-hlsf.001.cs.st 8/29/2025 15:07:08'!
PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen buttonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7406-ButtonStyle-coda-HilaireFernandes-2025Aug12-15h21m-hlsf.001.cs.st----!

'From Cuis7.5 [latest update: #7404] on 12 August 2025 at 3:22:39 pm'!
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'hlsf 8/12/2025 18:05:33' prior: 16930726!
      icon: aForm
	icon := aForm.
	magnifiedIcon := nil.
	self isRound ifTrue: [self morphExtent: icon extent + 5].
	self redrawNeeded.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7407-ButtonWithIcon-size-HilaireFernandes-2025Aug12-15h21m-hlsf.001.cs.st----!

'From Cuis7.5 [latest update: #7399] on 10 August 2025 at 4:28:19 pm'!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 8/10/2025 16:24:22' prior: 16833582!
                   encoderClass
	"Answer the encoder class that encoded the bytecodes in this method.
	 The sign flag bit is used by the VM to select a bytecode set.  This formulation
	 may seem odd but this has to be fast, so no property probe unless needed."

	^self header >= 0
		ifTrue: 
			[ EncoderForV3PlusClosures ]
		ifFalse:
			[ EncoderForSistaV1 ]! !
!CompiledMethod class methodsFor: 'class initialization' stamp: 'jmv 8/10/2025 16:26:55' prior: 16835837 overrides: 16924243!
          initialize    "CompiledMethod initialize"
	"Initialize class variables specifying the size of the temporary frame
	needed to run instances of me."

	SmallFrame := 16.	"Context range for temps+stack"
	LargeFrame := 56.
	PreferredBytecodeSetEncoderClass ifNil:
		[PreferredBytecodeSetEncoderClass := EncoderForV3PlusClosures]! !
!CompiledMethod class methodsFor: 'method encoding' stamp: 'jmv 8/10/2025 16:24:28' prior: 50342875!
                    headerFlagForEncoderClass: anEncoderClass
	
	(anEncoderClass includesBehavior: EncoderForV3PlusClosures) ifTrue: [^0].
	(anEncoderClass includesBehavior: EncoderForSistaV1) ifTrue: [^SmallInteger minVal].
	
	self error: 'The encoder is not one of the two installed bytecode sets'! !
!CompiledMethod class methodsFor: 'preferences' stamp: 'jmv 8/10/2025 16:27:45' prior: 50347069!
    preferredBytecodeSetEncoderClass: aBytecodeEncoderSubclass
	"Set the class that determines the bytecode set used to compile methods with.

		| nPrimary nSecondary |
		nPrimary := nSecondary := 0.
		self allSubInstancesDo:
			[:cm|
			cm header >= 0
				ifTrue: [nPrimary := nPrimary + 1]
				ifFalse: [nSecondary := nSecondary + 1]].
		{nPrimary. nSecondary} print
	"
	self assert: (aBytecodeEncoderSubclass includesBehavior: BytecodeEncoder).
	(aBytecodeEncoderSubclass == EncoderForV3PlusClosures
	 or: [aBytecodeEncoderSubclass == EncoderForSistaV1]) ifTrue:
		[PreferredBytecodeSetEncoderClass := aBytecodeEncoderSubclass.
		 ^self].
	self error: 'Cannot set preferred bytecode set.  Both of the current sets appear to be in use.'! !
!SystemDictionary methodsFor: 'Closure measurements' stamp: 'jmv 8/10/2025 16:25:32' prior: 50343034!
                        browseMethodsWithEmptyClosures
	"
	Smalltalk browseMethodsWithEmptyClosures
	"
	| pattern1 pattern2 |
	pattern1 := EncoderForV3PlusClosures emptyClosurePattern.
	pattern2 := EncoderForSistaV1 emptyClosurePattern.
	self
		browseAllSelect: [ :m | | s |
			s := InstructionStream on: m.
			s scanFor: [ :bytecode |
				(s method is: pattern1 subcollectionAt: s pc) or:
					[s method is: pattern2 subcollectionAt: s pc]]]
		name:  'Methods with empty closures'
		autoHighlight: '[]'! !

CompiledMethod class removeSelector: #installSecondaryBytecodeSet:!

!methodRemoval: CompiledMethod class #installSecondaryBytecodeSet: stamp: 'Install-7408-V3AndSistaEncodersAreHardcodedInTheVM-Simplify-JuanVuletich-2025Aug10-16h21m-jmv.001.cs.st 8/29/2025 15:07:08'!
installSecondaryBytecodeSet: aBytecodeEncoderSubclass
	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:
		[^self].
	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:
		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].
	(self allSubInstances
			detect: [:m| m header < 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]
			ifNone: nil) ifNotNil:
		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].
	SecondaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass!

CompiledMethod class removeSelector: #primaryBytecodeSetEncoderClass!

!methodRemoval: CompiledMethod class #primaryBytecodeSetEncoderClass stamp: 'Install-7408-V3AndSistaEncodersAreHardcodedInTheVM-Simplify-JuanVuletich-2025Aug10-16h21m-jmv.001.cs.st 8/29/2025 15:07:08'!
primaryBytecodeSetEncoderClass
	^PrimaryBytecodeSetEncoderClass!

CompiledMethod class removeSelector: #secondaryBytecodeSetEncoderClass!

!methodRemoval: CompiledMethod class #secondaryBytecodeSetEncoderClass stamp: 'Install-7408-V3AndSistaEncodersAreHardcodedInTheVM-Simplify-JuanVuletich-2025Aug10-16h21m-jmv.001.cs.st 8/29/2025 15:07:08'!
secondaryBytecodeSetEncoderClass
	^SecondaryBytecodeSetEncoderClass!

CompiledMethod class removeSelector: #installPrimaryBytecodeSet:!

!methodRemoval: CompiledMethod class #installPrimaryBytecodeSet: stamp: 'Install-7408-V3AndSistaEncodersAreHardcodedInTheVM-Simplify-JuanVuletich-2025Aug10-16h21m-jmv.001.cs.st 8/29/2025 15:07:09'!
installPrimaryBytecodeSet: aBytecodeEncoderSubclass
	PrimaryBytecodeSetEncoderClass == aBytecodeEncoderSubclass ifTrue:
		[^self].
	(aBytecodeEncoderSubclass inheritsFrom: BytecodeEncoder) ifFalse:
		[self error: 'A bytecode set encoder is expected to be a subclass of BytecodeEncoder'].
	(self allSubInstances
			detect: [:m| m header >= 0 and: [m encoderClass ~~ aBytecodeEncoderSubclass]]
			ifNone: nil) ifNotNil:
		[Warning signal: 'There are existing CompiledMethods with a different encoderClass.'].
	PrimaryBytecodeSetEncoderClass := aBytecodeEncoderSubclass!

ByteArray variableByteSubclass: #CompiledMethod
	instanceVariableNames: ''
	classVariableNames: 'LargeFrame PreferredBytecodeSetEncoderClass SmallFrame'
	poolDictionaries: ''
	category: 'MinimalKernel-Methods'!

!classDefinition: #CompiledMethod category: #'MinimalKernel-Methods' stamp: 'Install-7408-V3AndSistaEncodersAreHardcodedInTheVM-Simplify-JuanVuletich-2025Aug10-16h21m-jmv.001.cs.st 8/29/2025 15:07:09'!
ByteArray variableByteSubclass: #CompiledMethod
	instanceVariableNames: ''
	classVariableNames: 'LargeFrame PreferredBytecodeSetEncoderClass SmallFrame'
	poolDictionaries: ''
	category: 'MinimalKernel-Methods'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7408-V3AndSistaEncodersAreHardcodedInTheVM-Simplify-JuanVuletich-2025Aug10-16h21m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7408] on 13 August 2025 at 10:28:31 am'!
!Parser class methodsFor: 'parsing' stamp: 'jmv 8/13/2025 10:20:19' prior: 16929350!
                       parse: sourceCode class: aClass noPattern: aBoolean

	^(self new
		parse: sourceCode class: aClass noPattern: aBoolean)
			sourceText: sourceCode;
			yourself! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7409-Cleanup-JuanVuletich-2025Aug13-10h27m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7398] on 5 August 2025 at 4:11:46 pm'!
!CompiledMethod class methodsFor: 'method encoding' stamp: 'dtl 5/6/2022 19:03'!
                byteCodeSetsKnownToTheVM
	"Answer the encoder names for the bytecode sets reported to be supported
	by the virtual machine. Informational, failure indicates only that the VM does
	not support the primitive query."

	"CompiledMethod byteCodeSetsKnownToTheVM"

	<primitive: 'primitiveBytecodeSetsAvailable'>
	^ self primitiveFailed! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7410-byteCodeSetsKnownToTheVM-JuanVuletich-2025Aug05-16h00m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7399] on 5 August 2025 at 4:44:36 pm'!
!CompiledMethod methodsFor: 'initialization' stamp: 'jmv 8/5/2025 16:36:42' prior: 50356693!
        copyWithBytecodes: bytecodes
	"Assume bytecodes are regular bytecodes, even if we ourselves are a primitive method.
	The new bytecodes are in the same bytecode set as the current ones.
	This means the header word remains the same."

	| copy |
	copy := CompiledMethod newMethod: bytecodes size+4 header: self header.
	1 to: self numLiterals do: [:i | copy literalAt: i put: (self literalAt: i)].
	bytecodes withIndexDo: [ :byte :i |
		copy at: i+self initialPC-1 put: (bytecodes at: i) ].
	^ copy! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7411-copyWithBytecodes-assumeSameBytecodeSet-JuanVuletich-2025Aug05-16h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7411] on 13 August 2025 at 11:41:22 am'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7412-MinimalKernel-tweaks-JuanVuletich-2025Aug13-11h31m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7412] on 13 August 2025 at 6:03:46 pm'!
!UniFileStream class methodsFor: 'error handling' stamp: 'jmv 8/13/2025 16:40:08' prior: 17002027!
readOnlyFileDoesNotExistUserHandling: fullFileName

	| dir files choices selection newName fileName |
	dir := fullFileName asFullFileEntry parent.
	files := dir fileNames.
	fileName := fullFileName asFullFileEntry name.
	choices := fileName correctAgainst: files.
	choices add: 'Choose another name'.
	choices add: 'Cancel'.
	selection := (PopUpMenu labelArray: choices lines: (Array with: 5) )
		startUpWithCaption: fullFileName asFullFileEntry name, '
does not exist.'.
	selection = 0 ifTrue: ["esc, click outside" ^ nil ].
	selection = choices size ifTrue: ["cancel" ^ nil ].
	selection < (choices size - 1) ifTrue: [
		newName := (dir pathName , '/', (choices at: selection))].
	selection = (choices size - 1) ifTrue: [
		newName := self request: 'Enter a new file name' initialAnswer: fileName.
		"If Cancel was pressed, no file should be opened - Hernan"
		newName isEmpty ifTrue: [ ^nil ]].
	newName = '' ifFalse: [^ FileIOAccessor default privateReadOnlyFile: newName asFileEntry ].
	^ self error: 'Could not open a file'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7413-MissingFileMenuFix-JuanVuletich-2025Aug13-18h03m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7414] on 13 August 2025 at 6:31:12 pm'!
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 8/13/2025 18:28:43' prior: 17007071 overrides: 16914967!
            image: srcForm at: aPoint
	"Workaround using WarpBlt until properly implemented in VectorEngine.
	 (WarpBlt might not give desired result, i.e. a properly filtered and resampled image)

	In the general case, use WarpBlt to apply currentTransformation.
	Prior to that, set morphIds for affected pixels, and update bounds in engine.
	This is expensive!!

	If No scaling and no rotation, use BitBlt instead (way faster). This is useful, for instance, for halo handles.
	We expect to replace them with vector graphics icons, anyway."

	"We need to compute bounds. While we are at it, set morphID for affected pixels."
	self fillRectangle: (srcForm boundingBox translatedBy: aPoint) color: `Color gray alpha: 0.01`.
	currentTransformation isPureTranslation
		ifTrue: [
			| p bitBlt |
			p := (currentTransformation transform: aPoint) roundedHAFZ.
			bitBlt := BitBltCanvasEngine toForm: form.
			bitBlt
				sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				sourceX: 0; sourceY: 0;
				destX: p x destY: p y width: srcForm width height: srcForm height;
				copyBits ]
		ifFalse: [
			| bb cellSize dstBox srcBox srcQuad |
			cellSize := 4.
			srcBox := srcForm boundingBox.
			srcBox := srcBox origin extent: srcBox extent - 1.
			dstBox := currentTransformation externalBoundingRectOf: srcBox.
			srcQuad := dstBox corners collect: [ :pt | (currentTransformation inverseTransform: pt) floor ].
			dstBox := srcBox translatedBy: aPoint.
			dstBox := ((currentTransformation externalBoundingRectOf: dstBox))
				encompassingIntegerRectangle.
			bb := WarpBlt toForm: form.
			bb
				sourceForm: srcForm; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				cellSize: cellSize;
				copyQuad: srcQuad toRect: dstBox ].! !
!VectorCanvas methodsFor: 'drawing - MorphicCanvas protocol' stamp: 'jmv 8/13/2025 18:29:23' prior: 17007134!
          image: srcForm at: aPoint sourceRect: sourceRect
	"Workaround using WarpBlt until properly implemented in VectorEngine.
	 (WarpBlt might not give desired result, i.e. a properly filtered and resampled image)

	In the general case, use WarpBlt to apply currentTransformation.
	Prior to that, set morphIds for affected pixels, and update bounds in engine.
	This is expensive!!

	If No scaling and no rotation, use BitBlt instead (way faster). This is useful, for instance, for halo handles.
	We expect to replace them with vector graphics icons, anyway."

	"We need to compute bounds. While we are at it, set morphID for affected pixels."
	self fillRectangle: (sourceRect translatedBy: aPoint) color: `Color gray alpha: 0.01`.
	currentTransformation isPureTranslation
		ifTrue: [
			| p bitBlt |
			p := (currentTransformation transform: aPoint) roundedHAFZ.
			bitBlt := BitBltCanvasEngine toForm: form.
			bitBlt
				sourceForm: srcForm; fillColor: nil; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				sourceX: sourceRect left; sourceY: sourceRect top;
				destX: p x destY: p y width: sourceRect width height: sourceRect height;
				copyBits ]
		ifFalse: [
			| bb cellSize dstBox srcBox srcQuad |
			cellSize := 4.
			srcBox := sourceRect.
			srcBox := srcBox origin extent: srcBox extent - 1.
			dstBox := currentTransformation externalBoundingRectOf: srcBox.
			srcQuad := dstBox corners collect: [ :pt | (currentTransformation inverseTransform: pt) floor ].
			dstBox := srcBox translatedBy: aPoint.
			dstBox := ((currentTransformation externalBoundingRectOf: dstBox))
				encompassingIntegerRectangle.
			bb := WarpBlt toForm: form.
			bb
				sourceForm: srcForm; combinationRule: Form blend;
				colorMap: (srcForm colormapIfNeededFor: form);
				clipRect: clipRect;
				cellSize: cellSize;
				copyQuad: srcQuad toRect: dstBox ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7414-RotatedImageDisplayTweaks-JuanVuletich-2025Aug13-18h20m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7412] on 13 August 2025 at 6:09:25 pm'!
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'HAW 8/13/2025 17:58:26' prior: 16930816!
     draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol := self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c := color.
	(self mouseIsOver or: [ self isPressed ]) ifTrue: [
		c := mouseOverColor ifNil: [ c lighter ]].
	c := self enableColorWith: c.
	aCanvas
		fillRectangle: self localBounds
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: (borderColor ifNil: [ c ]).

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'testing' stamp: 'HAW 8/13/2025 17:58:39' prior: 16931233!
       isPressed
	^isPressed or: [ self getState ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7415-PluggableButtonMorphUsesOr-HernanWilkinson-2025Aug13-17h16m-HAW.001.cs.st----!

'From Cuis7.5 [latest update: #7415] on 14 August 2025 at 9:54:09 am'!
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 8/14/2025 09:44:26' prior: 16978240!
    displayCommandLineUsageOn: aStream
	"Display command line usage on standard out."

	[ aStream
		nextPutAll: 'Command line options:'; newLine;
		nextPutAll: '  -h Display this help message and quit'; newLine;
		nextPutAll: '  -v Display the system information, containing the version and quit'; newLine;
		nextPutAll: '  -q Just quit'; newLine;
		nextPutAll: '  -e Do not ignore exceptions during startup, but open a Debugger'; newLine;
		nextPutAll: '  -u Install available updates from CoreUpdates directory'; newLine;
		nextPutAll: '  -r <feature> Require <feature>. Find and install a Cuis package file supplying it.'; newLine;
		nextPutAll: '  -d <code> Evaluate code. <code> must be a Smalltalk expression in double quotes. (No comments allowed)'; newLine;
		nextPutAll: '  -s <scriptFile> The file must contain a valid Smalltalk expression. Compile and evaluate it.'; newLine;
		nextPutAll: '  -l <codeFile> File in Smalltalk code. The file must be a valid ChangeSet file.'; newLine;
		nextPutAll: '  -ud <directory> Set User Directory to be <directory>'; newLine;
		nextPutAll: '  -udIsBase Set User Directory to be Cuis Base directory'; newLine;
		nextPutAll: '  -- end of options; stop processing options'; newLine;
		newLine;
		nextPutAll: 'Arguments for scripts, code files, packages (and <code>):'; newLine;
		nextPutAll: '  are available in ''Smalltalk startUpScriptArguments'''; newLine;
		newLine;
		nextPutAll: 'Multiple options:'; newLine;
		nextPutAll: '  any option can be passed multiple times'; newLine;
		flush ]
	on: UnhandledError
	do: [ :exception | exception return ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7416-CommandLineHelpTweaks-JuanVuletich-2025Aug14-09h24m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7416] on 18 August 2025 at 3:41:15 pm'!
!DisplayScreen methodsFor: 'other' stamp: 'jmv 8/18/2025 15:41:08' prior: 50358548!
  deferUpdates: aBoolean
	"Set the deferUpdates flag in the virtual machine. When this flag is true, BitBlt operations on the Display are not automatically propagated to the screen.  To actually make them visible, call #forceToScreen: .
	If this underlying platform does not support deferred updates, this primitive will fail. Answer  nil if it fails.
	Most platforms do support this functionality. You can turn it off for playing with Display directly."

	"Enable this to act as if the VM didn't support defer updates, even when it does.
	This may help eliminate possible flickering:
	Preferences
		name: #useAllwaysOffScreenDisplay
		category: #system
		value: false
	"
	"(Preferences at: #useAllwaysOffScreenDisplay)"
	"Just always do it on MacOS. The VM says the feature is supported as on Linux and Windows, but there is (sometimes)
	heavy flickering."
	Smalltalk platformName = 'Mac OS'
		ifTrue: [ ^nil ].

	"Note: If we disable VM defer updates (with this `& false` below), but answer notNil, the the Morphic workaround is not used.
	Then:
	- on Mac VMs you get a terrible slowdown, because each Display write requires an expensive thread switch in the VM.
	- On Linux and Windows you get a lot of flicking.
	(Note: Mac VMs older than July 2025 #primitiveDeferUpdates: would answer nil, as the primitive always failed)"
	"Both Linux and Windows VM do support display deferred updates, so Morphic Canvas target is Display."
	^self primitiveDeferUpdates: aBoolean "& false"! !
!DisplayScreen class methodsFor: 'deferred updating' stamp: 'jmv 8/18/2025 15:21:35' prior: 50358587!
                 forceDeferredToScreen: updateRect
	"Force the given rectangular section of the Display to be copied to the host screen. Make it visible to user."

	DeferredUpdatingDisplay ifNil:
		[ ^self ].
	DisplayScreen isDisplayExtentOk ifFalse:
		[ ^self ].
	DeferredUpdatingDisplay == Display
		ifTrue:
			[Display forceToScreen: updateRect ]
		ifFalse:
			[
			(BitBlt toForm: Display)
				sourceForm: DeferredUpdatingDisplay;
				combinationRule: Form over;
				sourceRect: updateRect;
				destOrigin: updateRect topLeft;
				copyBits.
			"In Pre-July 2025 Mac VMs this step wasn't necessary
			Just blitting the off-Display on the actual Display made it visible.
			On newer VMs this step is also needed.
			It is also needed on Linux and Windows VMs if a separate
			DeferredUpdatingDisplay is used."
			Display forceToScreen: updateRect ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7417-AvoidHeavyFlickingOnMacOS-JuanVuletich-2025Aug18-15h24m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7417] on 18 August 2025 at 3:52:16 pm'!
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 8/18/2025 15:50:45' prior: 50358493!
             prefSystem
	^ #(
		#(allowNonLocalReturnsInExceptionHandlers true )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges true )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(warnAndOfferLastUserChanges true )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #cuis #(cuis roots) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(useUserPrefsFile true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
		#(saveReleaseOptionsInWorldMenu false)
	)! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Preferences removeKey: #useAllwaysOffScreenDisplay!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7418-remove-useAllwaysOffScreenDisplay-preference-JuanVuletich-2025Aug18-15h50m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7419] on 19 August 2025 at 8:27:39 am'!
!Sample10PythagorasTree methodsFor: 'as yet unclassified' stamp: 'jmv 8/19/2025 08:27:27' prior: 16952657!
 drawTreeOn: aCanvas p1: p1 p2: p2 depth: depth

	| dx dy p3 p4 p5 color |
	
	depth = depthLimit ifTrue: [ ^ self].
	
	color := self color.
	colors ifNotNil: [
		color := colors at: (depth mod: colors size) + 1].
	
	dx := p2 x - (p1 x).
	dy := p1 y - (p2 y).
	
	p3 := (p2 x - dy) @ (p2 y - dx).
	p4 := (p1 x - dy) @ (p1 y - dx).
	p5 := (p4 x + (angle * (dx - dy))) @ (p4 y - (angle * (dx + dy))).
	
	aCanvas fillColor: color do: [
		aCanvas moveTo: p1;
			lineTo: p2;
			lineTo: p3;
			lineTo: p4;
			lineTo: p1].
	
	"Enable to also draw triangles. Disable for a 'true' Pythagoras tree."
	true ifTrue: [
		aCanvas fillColor: color do: [
			aCanvas moveTo:  p3;
				lineTo: p4;
				lineTo: p5;
				lineTo: p3]].
	
	self drawTreeOn: aCanvas p1: p4 p2: p5 depth: depth + 1.
	self drawTreeOn: aCanvas p1: p5 p2: p3 depth: depth + 1.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7419-PythagorasTree-tweaks-JuanVuletich-2025Aug19-08h26m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7419] on 19 August 2025 at 9:38:19 am'!
!AffineTransformation methodsFor: 'private' stamp: 'jmv 8/19/2025 08:48:23'!
        replaceFrom: start to: stop with: replacement startingAt: repStart 
	"This destructively replaces elements from start to stop in the receiver
	starting at index, repStart, in the collection, replacement.  Answer the
	receiver.  No range checks are performed - this may be primitively implemented."

	| index repOff |
	repOff := repStart - start.
	index := start - 1.
	[(index := index + 1) <= stop]
		whileTrue: [self at: index put: (replacement at: repOff + index)]! !
!AffineTransformation class methodsFor: 'instance creation' stamp: 'jmv 8/19/2025 09:37:55'!
             from: aNumericArray
	"For example:
	
	AffineTransformation from:
		#[ 	  0.85 	0.04 	0.00
			-0.04 	0.85 	1.60 ].
	"
	^self newFromStream: aNumericArray readStream! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7420-AffineTransformation-Convenience-JuanVuletich-2025Aug19-09h37m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7419] on 19 August 2025 at 9:40:57 am'!
!HaloMorph methodsFor: 'drawing' stamp: 'jmv 8/19/2025 09:40:45' prior: 16876992!
                drawCoordinateSystemOn: aCanvas

	| x0 x1 y0 y1 c stepX stepY haloTargetTx prevTx font strokeWidth tickLength stepXDecimals stepYDecimals |
	haloTargetTx := MorphicTranslation identity.
	target allOwnersReverseDo: [ :o | haloTargetTx := haloTargetTx composedWith: o location ].
	haloTargetTx := haloTargetTx composedWith: target location.

	target knowsOwnLocalBounds
		ifTrue: [ | r |
			r := target localBounds.
			x0 := r left.
			x1 := r right.
			y0 := r top.
			y1 := r bottom ]
		ifFalse: [
			x0 := x1 := y0 := y1 := 0.
			target displayFullBounds corners collect: [ :pt | | p |
				p := haloTargetTx inverseTransform: pt.
				x0 := x0 min: p x.
				x1 := x1 max: p x.
				y0 := y0 min: p y.
				y1 := y1 max: p y.]].

	font := FontFamily defaultFamilyPointSize: ((FontFamily defaultPointSize * 1.5 / haloTargetTx scale) rounded max: 0.1).
	stepX := (font pointSize * 9) round4perMagnitudeOrder asFloat.
	stepXDecimals := stepX log rounded negated + 1.
	stepY := (font pointSize * 5) round4perMagnitudeOrder asFloat.
	stepYDecimals := stepY log rounded negated + 1.
	strokeWidth := 3/ haloTargetTx scale.
	tickLength := 5 / haloTargetTx scale.

	prevTx := aCanvas currentTransformation.
	aCanvas geometryTransformation: haloTargetTx.

	c := `Color black alpha: 0.4`.
	aCanvas line: x0@0 to: x1@0 width: strokeWidth color: c.
	aCanvas line: 0@y0 to: 0@y1 width: strokeWidth color: c.

	(x0 truncateTo: stepX) to: x1 by: stepX do: [ :x |
		aCanvas line: x @ tickLength negated to: x @ tickLength width: strokeWidth color: c.
		aCanvas drawString: (x printStringFractionDigits: stepXDecimals) atWaistCenter: x @ (tickLength*4) negated font: font color: c ].
	  aCanvas drawString: 'x' atCenterX: x1 - (tickLength*3) @ 0 font: font color: c.

	(y0 truncateTo: stepY) to: y1 by: stepY do: [ :y |
		aCanvas line: tickLength negated @ y to: tickLength @ y width: strokeWidth color: c.
		aCanvas drawString: (y printStringFractionDigits: stepYDecimals), ' ' atWaistRight: tickLength negated @ y font: font color: c ].
	  aCanvas drawString: 'y' atWaist: tickLength @ (y1 - (tickLength*4)) font: font color: c.

	aCanvas geometryTransformation: prevTx.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7421-Halos-tweak-JuanVuletich-2025Aug19-09h38m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7419] on 19 August 2025 at 9:43:02 am'!

PlacedMorph subclass: #Sample11BarnsleyFern
	instanceVariableNames: 't1 p1 t2 p2 t3 p3 t4 p4'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Examples'!

!classDefinition: #Sample11BarnsleyFern category: #'Morphic-Examples' stamp: 'Install-7422-BarnsleyFern-MorphicDemo-JuanVuletich-2025Aug19-09h40m-jmv.001.cs.st 8/29/2025 15:07:09'!
PlacedMorph subclass: #Sample11BarnsleyFern
	instanceVariableNames: 't1 p1 t2 p2 t3 p3 t4 p4'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Examples'!
!Sample11BarnsleyFern commentStamp: '<historical>' prior: 0!
         A Barnsley Fern.

See https://youtu.be/rkEnRrlHEZM?si=1SNqV1nz4iAeX-PS
See https://en.wikipedia.org/wiki/Barnsley_fern

Sample11BarnsleyFern new openInWorld

Thanks Leandro Caniglia for the suggestion!!!
!Sample11BarnsleyFern methodsFor: 'initialization' stamp: 'jmv 8/19/2025 09:07:24' overrides: 16930386!
            initialize
	"See https://en.wikipedia.org/wiki/Barnsley_fern "
	super initialize.
	
	"Stem"
	t1 := AffineTransformation from:
		#[ 	0.00 	0.00 	0.00
			0.00 	0.16 	0.00 ].
	p1 := 0.01.
	
	"Successively smaller leaflets"
	t2 := AffineTransformation from:
		#[ 	0.85 	0.04 	0.00
			-0.04 	0.85 	1.60 ].
	p2 := 0.85.
	
	"Largest left-hand leaflet"
	t3 := AffineTransformation from:
		#[ 	0.20 	-0.26 	0.00
			0.23 	0.22 	1.60 ].
	p3 := 0.07.
	
	"Largest right-hand leaflet "
	t4 := AffineTransformation from:
		#[ 	-0.15 	0.28 	0.00
			0.26 	0.24 	0.44 ].
	p4 := 0.07.! !
!Sample11BarnsleyFern methodsFor: 'drawing' stamp: 'jmv 8/19/2025 09:22:50' overrides: 16910893!
      drawOn: aCanvas
	| p c |
	c := Color lightGreen alpha: 0.5.
	p := 0@0.
	40000 timesRepeat: [
		aCanvas strokeWidth: 1.2 color: c do: [
			aCanvas moveTo: p*40; lineTo: p*40.
			p := self pickTransformation transform: p ]]! !
!Sample11BarnsleyFern methodsFor: 'drawing' stamp: 'jmv 8/19/2025 09:30:41'!
                  pickTransformation
	| r |
	r := Random next.
	
	r <= p1 ifTrue: [ ^t1 ].
	r := r - p1.
	
	r <= p2 ifTrue: [ ^t2 ].
	r := r - p2.
	
	r <= p3 ifTrue: [ ^t3 ].
	r := r - p3.
	
	r <= p4 ifTrue: [ ^t4 ].
	r := r - p4.
	
	self error: [ 'Probabilities do not add up to 1.0' ].! !
!Sample11BarnsleyFern methodsFor: 'drawing' stamp: 'jmv 8/19/2025 09:20:31' overrides: 16930484!
              yAxisPointsUp
	"Follow the standard math convention, making increasing y values move upwards."

	^true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7422-BarnsleyFern-MorphicDemo-JuanVuletich-2025Aug19-09h40m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7422] on 19 August 2025 at 9:55:18 am'!
!CharacterSequence methodsFor: 'copying' stamp: 'len 8/19/2025 09:55:11' prior: 16813155!
             appendToText: aText

	^self asText appendToText: aText! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7423-Text-fix-LucianoEstebanNotarfrancesco-2025Aug19-09h54m-len.001.cs.st----!

'From Cuis7.5 [latest update: #7423] on 19 August 2025 at 12:32:39 pm'!

PlacedMorph subclass: #Sample11BarnsleyFern
	instanceVariableNames: 't1 p1 t2 p2 t3 p3 t4 p4 probabilities affineTransformations '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Examples'!

!classDefinition: #Sample11BarnsleyFern category: #'Morphic-Examples' stamp: 'Install-7424-withProbabilities-pickFrom-JuanVuletich-2025Aug19-12h22m-jmv.001.cs.st 8/29/2025 15:07:09'!
PlacedMorph subclass: #Sample11BarnsleyFern
	instanceVariableNames: 't1 p1 t2 p2 t3 p3 t4 p4 probabilities affineTransformations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Examples'!
!Random class methodsFor: 'services' stamp: 'jmv 8/19/2025 12:23:10'!
                        withProbabilities: probabilities pickFrom: elements
	"probabilities and elements must be of same size.
	probabilities sum = 1.0"

	| r |
	r := self next.
	probabilities with: elements do: [ :p :e |
		r <= p ifTrue: [ ^e ].
		r := r - p ].
	
	self error: [ 'Probabilities do not add up to 1.0' ].! !
!Sample11BarnsleyFern methodsFor: 'initialization' stamp: 'jmv 8/19/2025 12:30:47' prior: 50360029 overrides: 16930386!
                             initialize
	"See https://en.wikipedia.org/wiki/Barnsley_fern "
	super initialize.
	
	probabilities := #[ 0.01 0.85 0.07 0.07 ].
	affineTransformations := {
		"Stem"
		AffineTransformation from:
			#[ 	0.00 	0.00 	0.00
				0.00 	0.16 	0.00 ].
		"Successively smaller leaflets"
		AffineTransformation from:
			#[ 	0.85 	0.04 	0.00
				-0.04 	0.85 	1.60 ].
		"Largest left-hand leaflet"
		AffineTransformation from:
			#[ 	0.20 	-0.26 	0.00
				0.23 	0.22 	1.60 ].
		"Largest right-hand leaflet "
		AffineTransformation from:
			#[ 	-0.15 	0.28 	0.00
				0.26 	0.24 	0.44 ] }.! !
!Sample11BarnsleyFern methodsFor: 'drawing' stamp: 'jmv 8/19/2025 12:30:28' prior: 50360050 overrides: 16910893!
              drawOn: aCanvas
	| tx p c |
	c := Color lightGreen alpha: 0.5.
	p := 0@0.
	40000 timesRepeat: [
		aCanvas strokeWidth: 1.2 color: c do: [
			aCanvas moveTo: p*40; lineTo: p*40.
			tx := Random withProbabilities: probabilities pickFrom: affineTransformations.
			p := tx transform: p ]]! !

Sample11BarnsleyFern removeSelector: #pickTransformation!

!methodRemoval: Sample11BarnsleyFern #pickTransformation stamp: 'Install-7424-withProbabilities-pickFrom-JuanVuletich-2025Aug19-12h22m-jmv.001.cs.st 8/29/2025 15:07:09'!
pickTransformation
	| r |
	r := Random next.
	
	r <= p1 ifTrue: [ ^t1 ].
	r := r - p1.
	
	r <= p2 ifTrue: [ ^t2 ].
	r := r - p2.
	
	r <= p3 ifTrue: [ ^t3 ].
	r := r - p3.
	
	r <= p4 ifTrue: [ ^t4 ].
	r := r - p4.
	
	self error: [ 'Probabilities do not add up to 1.0' ].!

PlacedMorph subclass: #Sample11BarnsleyFern
	instanceVariableNames: 'probabilities affineTransformations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Examples'!

!classDefinition: #Sample11BarnsleyFern category: #'Morphic-Examples' stamp: 'Install-7424-withProbabilities-pickFrom-JuanVuletich-2025Aug19-12h22m-jmv.001.cs.st 8/29/2025 15:07:09'!
PlacedMorph subclass: #Sample11BarnsleyFern
	instanceVariableNames: 'probabilities affineTransformations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Examples'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7424-withProbabilities-pickFrom-JuanVuletich-2025Aug19-12h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7424] on 19 August 2025 at 3:00:33 pm'!
!DifferenceFinder class methodsFor: 'compatibility' stamp: 'jmv 8/19/2025 14:59:30' prior: 16849783!
             wordsDisplayPatchFrom: srcStringOrText to: dstStringOrText

	| finder answer src1 dst1 changedCount dstString srcString |
	srcString := srcStringOrText asPlainString.
	dstString := dstStringOrText asPlainString.
	srcString class == dstString class ifFalse: [
		^self wordsDisplayPatchFrom: srcString asUnicodeString to: dstString asUnicodeString ].

	finder := self base: srcString case: dstString.
	finder compareLines; compute.
	answer := srcString class new asText.
	src1 := srcString class writeStream.
	dst1 := srcString class writeStream.
	changedCount := 0.
	finder differences sort first do: [:item :condition |
		condition caseOf: {
			[ #unchanged ] -> [
				changedCount > 0 ifTrue: [
					"If the sequence of changed lines is large, comparing words gets too slow and less useful"
					changedCount > 30 ifTrue: [
						^nil ].
					"Compare the just ended sequence of changed lines"
					finder base: src1 contents case: dst1 contents.
					finder compareWords; compute: true.
					finder differences ifNil: [ ^nil ].
					answer := answer append:  finder differences anyOne asText.
					src1 resetToStart.
					dst1 resetToStart.
					changedCount := 0.
				].
				"This line hasn't changed. Just add it to the result in plain text."
				answer := answer append: item ].
			[ #removed ] -> [
				"A removed line belongs in the source"
				src1 nextPutAll: item.
				changedCount := changedCount + 1 ].
			[ #inserted ] -> [
				"An added line belongs in the destination"
				dst1 nextPutAll: item.
				changedCount := changedCount + 1  ].
			}.
		].
	"If the sequence of changed lines is large, comparing words gets too slow and less useful"
	changedCount > 30 ifTrue: [
		^nil ].
	finder base: src1 contents case: dst1 contents.
	finder compareWords; compute: true.
	finder differences ifNil: [ ^nil ].
	answer := answer append: finder differences anyOne asText.

	^answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7425-DifferenceFinder-fix-JuanVuletich-2025Aug19-14h55m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7418] on 18 August 2025 at 5:54:32 pm'!
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 8/18/2025 16:58:57'!
       printOn: aStream includeOffset: aBoolean
	"Print as per ISO 8601 section 5.4.2
	Prints either:
		'YYYY-MM-DDThh:mm:ss.sZ' (for positive years, UTC, i.e. zero offset)
		'YYYY-MM-DDThh:mm:ss.s+OO:oo' (for positive years, positive offset)
		'YYYY-MM-DDThh:mm:ss.s-OO:oo' (for positive years, negative offset)
		'-YYYY-MM-DDThh:mm:ss.s+OO:oo' (for negative years, offset as above)
	Does not include the offset at all if aBoolean == false.
	"

	self printYMDOn: aStream.
	aStream nextPut: $T.
	self printHMSOn: aStream.
	self nanoSecond ~= 0 ifTrue:
		[ | z ps |
		ps := self nanoSecond printString padded: #left to: 9 with: $0.
		z := ps findLast: [ :c | c codePoint > `$0 codePoint` ].
		(z > 0) ifTrue: [aStream nextPut: $.].
		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ].
	aBoolean ifTrue: [
		self isUTC
			ifTrue: [ aStream nextPut: $Z]
			ifFalse: [
				aStream
					nextPut: (offset positive ifTrue: [$+] ifFalse: [$-]);
					nextPutAll: (offset hours abs printString padded: #left to: 2 with: $0);
					nextPut: $:;
					nextPutAll: (offset minutes abs printString padded: #left to: 2 with: $0).
				"Note: We should check the ISO to see if the seconds part is supported by the standard
				(Usually not an issue. UTC Offsets are multiple of 15 minutes.)"
				offset seconds = 0 ifFalse: [
					aStream
						nextPut: $:;
						nextPutAll: (offset seconds abs truncated printString) ]]].! !
!DateAndTime methodsFor: 'testing' stamp: 'jmv 8/18/2025 16:36:23'!
  isUTC
	^offset isZero! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 8/18/2025 16:57:59' prior: 16843291 overrides: 16922929!
                       printOn: aStream
	"Print as per ISO 8601 section 5.4.2
	Prints either:
		'YYYY-MM-DDThh:mm:ss.sZ' (for positive years, UTC, i.e. zero offset)
		'YYYY-MM-DDThh:mm:ss.s+OO:oo' (for positive years, positive offset)
		'YYYY-MM-DDThh:mm:ss.s-OO:oo' (for positive years, negative offset)
		'-YYYY-MM-DDThh:mm:ss.s+OO:oo' (for negative years, offset as above)
	"

	^self printOn: aStream includeOffset: true! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 8/18/2025 16:44:58' prior: 16843347!
                printWithMsOn: aStream
	"Print with millisecond resolution, no offset."

	| ps |
	self printYMDOn: aStream.
	aStream nextPut: $T.
	self printHMSOn: aStream.
	ps := (self nanoSecond // 1000000) printString padded: #left to: 3 with: $0.
	aStream nextPut: $..
	aStream nextPutAll: ps! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 8/18/2025 16:43:33' prior: 16843360!
        printYMDOn: aStream
	"Print just the year, month, and day on aStream.
	
	Print just YYYY-MM-DD part.
	If the year is negative, prints out '-YYYY-MM-DD'."

	| year month day |
	self dayMonthYearDo: [ :d :m :y | year := y. month := m. day := d ].
	year negative
		ifTrue: [ aStream nextPut: $- ].
	aStream
		nextPutAll: (year abs printString padded: #left to: 4 with: $0);
		nextPut: $-;
		nextPutAll: (month printString padded: #left to: 2 with: $0);
		nextPut: $-;
		nextPutAll: (day printString padded: #left to: 2 with: $0)
! !
!DateAndTime methodsFor: 'public protocol' stamp: 'jmv 8/18/2025 16:47:52' prior: 16843530!
                  filenamishPrintOn: aStream
	"
	See also #dateTimeSuffix
	String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ] '2025Aug18-16h46m' .
	"
	
	| year month day monthName |
	self dayMonthYearDo: [ :d :m :y | year := y. month := m. day := d ].
	year negative
		ifTrue: [ aStream nextPut: $- ].
	monthName := Month nameOfMonth: month.
	aStream
		nextPutAll: (year abs printString padded: #left to: 4 with: $0);
		nextPutAll: (monthName copyFrom: 1 to: 3);
		nextPutAll: (day printString padded: #left to: 2 with: $0);
		nextPut: $-;
		nextPutAll: (self hour printString padded: #left to: 2 with: $0);
		nextPut: $h;
		nextPutAll: (self minute printString padded: #left to: 2 with: $0);
		nextPut: $m! !
!DateAndTime methodsFor: 'public protocol' stamp: 'jmv 8/18/2025 16:55:50' prior: 16843574!
                        printWithoutOffsetOn: aStream
	"Print as per ISO 8601 section 5.4.2
	Prints either:
		'YYYY-MM-DDThh:mm:ss.s' (for positive years)
		'-YYYY-MM-DDThh:mm:ss.s' (for negative years)
	"

	^self printOn: aStream includeOffset: false! !
!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 8/18/2025 17:54:18' prior: 16843808 overrides: 16924020!
   readFrom: aStream

	| offset date time ch |

	date := Date readFrom: aStream.
	[aStream peek isDigit]
		whileFalse: [aStream next].
	time := Time readFrom: aStream.
	aStream atEnd
		ifTrue: [ offset := self localOffset ]
		ifFalse: [
			ch := aStream next.
			ch = $Z
				ifTrue: [ offset := Duration zero]
				ifFalse: [
					ch == $+ ifTrue: [ch := Character space].
					"Assume that offset is defined as (+/-)hh:mm
					Add (zero days): as prefix and :(0 seconds) as suffix."
					offset := Duration fromString: (String with: ch), '0:', aStream upToEnd, ':0' ]].
		
	^ self
		year: date yearNumber
		month: date monthIndex
		day: date dayOfMonth
		hour: time hour
		minute: time minute
		second: time second
		nanoSecond: time nanoSecond
		offset: offset


	"
		DateAndTime readFrom: ' 2002-05-16T17:20:45.1Z' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.1+00:00' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.1+02:00' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.1-03:00' readStream
		DateAndTime readFrom: '-1199-01-05T20:33:14.321-05:00' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.02+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.003+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0004+01:01' readStream
  		DateAndTime readFrom: ' 2002-05-16T17:20:45.00005' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000006+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000007+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.00000008-01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000000009+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000000001+01:01' readStream

 		DateAndTime readFrom: ' 2002-05-16T17:20' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45+01:57' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45-02:34' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45+00:00' readStream
		DateAndTime readFrom: ' 1997-04-26T01:02:03+01:02:3' readStream
 	"! !
!Duration class methodsFor: 'squeak protocol' stamp: 'jmv 5/22/2022 20:21:16' prior: 16852580!
 fromString: aString
	"
	Extended to accept non-ANSI formats, such as:
		Duration fromString: '1:50:00'
		Duration fromString: '5:30.5'
		Duration fromString: '1:6:50:00'
		Duration fromString: '3.5h'
		Duration fromString: '2.5min'
		Duration fromString: '1.5s'
		Duration fromString: '200s'
		Duration fromString: '200ms'
	"
	| colons s |

	"If aString includes at least one $:, complete ANSI format"
	colons := aString occurrencesOf: $:.
	colons > 0 ifTrue: [
		s := aString.
		[colons < 3] whileTrue: [
			s := '00:', s.
			colons := colons + 1 ].
		^ self readFrom: s readStream ].

	"'3.5h' means 3.5 hours"
	(aString endsWith: 'h') ifTrue: [
		^self hours: aString asNumber ].

	"'3.5min' means 3.5 minutes"
	(aString endsWith: 'min') ifTrue: [
		^self minutes: aString asNumber ].

	"'3ms' means 3 milliseconds"
	(aString endsWith: 'ms') ifTrue: [
		^self milliSeconds: aString asNumber ].

	"'3.5s' means 3.5 seconds"
	(aString endsWith: 's') ifTrue: [
		^self seconds: aString asNumber ].
	
	^nil! !
!Time class methodsFor: 'smalltalk-80' stamp: 'jmv 8/18/2025 17:08:35' prior: 16996702 overrides: 16924020!
   readFrom: aStream
	"Read a Time from the stream in the form:
		<hour>:<minute>:<second> <am/pm>

	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"

	| hour minute second nanos ampm |
	hour := Integer readFrom: aStream.
	minute := 0.
	second := 0.
	nanos := 0.
	(aStream peekFor: $:) 
		ifTrue: [
			minute := Integer readFrom: aStream.
			(aStream peekFor: $:) ifTrue: [
				second := Integer readFrom: aStream.
				(aStream peekFor: $.)
					ifTrue: [ | nanosStart scale |
						nanosStart := aStream position.
						nanos := Integer readFrom: aStream.
						"As if there were trailing zeros to fill 9 positions"
						scale := 10 raisedToInteger: nanosStart + 9 - aStream position.
						nanos := nanos * scale ]]].
	aStream skipSeparators.
	(aStream atEnd not and: ['ap' includes: aStream peek]) ifTrue: [
		ampm := aStream next asLowercase.
		(ampm == $p and: [hour < 12]) ifTrue: [hour := hour + 12].
			(ampm == $a and: [hour = 12]) ifTrue: [hour := 0].
		(aStream peekFor: $m) ifFalse: [aStream peekFor: $M ]].
	^ self 
		hour: hour 
		minute: minute 
		second: second 
		nanoSecond: nanos.

	"
	Time readFrom: '2:23:09 pm' readStream
	Time readFrom: '2:23:09.0 pm' readStream
	Time readFrom: '2:23:09.123402 pm' readStream
	Time readFrom: '2:23:09.00123402 pm' readStream
	Time readFrom: '2:23:09.001234020 pm' readStream
	Time readFrom: '2:23:09.000123402 pm' readStream
	"! !
!Utilities class methodsFor: 'identification' stamp: 'jmv 8/18/2025 16:47:43' prior: 17005320!
                            dateTimeSuffix
	"Answer a string which indicates the date and time, intended for use in building fileout filenames, etc.
	See also #filenamishPrintOn:.

	Utilities dateTimeSuffix
	"
	| n |
	n := DateAndTime now.
	^ String streamContents: [ :strm |
		n printYMDOn: strm.
		strm nextPut: $_.
		n printHMSOn: strm separator: $. ]! !

DateAndTime removeSelector: #printYMDOn:withLeadingSpace:!

!methodRemoval: DateAndTime #printYMDOn:withLeadingSpace: stamp: 'Install-7426-Stricter-ISO8601-TimeStamp-printing-JuanVuletich-2025Aug18-16h36m-jmv.001.cs.st 8/29/2025 15:07:09'!
printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo
	"Print just the year, month, and day on aStream.

	If printLeadingSpaceToo is true, then print as:
		' YYYY-MM-DD' (if the year is positive) or '-YYYY-MM-DD' (if the year is negative)
	otherwise print as:
		'YYYY-MM-DD' or '-YYYY-MM-DD' "

	| year month day |
	self dayMonthYearDo: [ :d :m :y | year := y. month := m. day := d ].
	year negative
		ifTrue: [ aStream nextPut: $- ]
		ifFalse: [ printLeadingSpaceToo ifTrue: [ aStream space ]].
	aStream
		nextPutAll: (year abs printString padded: #left to: 4 with: $0);
		nextPut: $-;
		nextPutAll: (month printString padded: #left to: 2 with: $0);
		nextPut: $-;
		nextPutAll: (day printString padded: #left to: 2 with: $0)
!

DateAndTime removeSelector: #printOn:withLeadingSpace:includeOffset:!

!methodRemoval: DateAndTime #printOn:withLeadingSpace:includeOffset: stamp: 'Install-7426-Stricter-ISO8601-TimeStamp-printing-JuanVuletich-2025Aug18-16h36m-jmv.001.cs.st 8/29/2025 15:07:09'!
printOn: aStream withLeadingSpace: printLeadingSpaceToo includeOffset: aBoolean
	"Print as per ISO 8601 section 5.4.2
	If printLeadingSpaceToo is false, prints either:
		'YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)
	If printLeadingSpaceToo is true, prints either:
		' YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)
	"

	self printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo.
	aStream nextPut: $T.
	self printHMSOn: aStream.
	self nanoSecond ~= 0 ifTrue:
		[ | z ps |
		ps := self nanoSecond printString padded: #left to: 9 with: $0.
		z := ps findLast: [ :c | c codePoint > `$0 codePoint` ].
		(z > 0) ifTrue: [aStream nextPut: $.].
		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ].
	aBoolean ifTrue: [
		aStream
			nextPut: (offset positive ifTrue: [$+] ifFalse: [$-]);
			nextPutAll: (offset hours abs printString padded: #left to: 2 with: $0);
			nextPut: $:;
			nextPutAll: (offset minutes abs printString padded: #left to: 2 with: $0).
		"Note: We should check the ISO to see if the seconds part is supported by the standard
		(usually not an issue. offsets usually don't include seconds)"
		offset seconds = 0 ifFalse: [
			aStream
				nextPut: $:;
				nextPutAll: (offset seconds abs truncated printString) ]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7426-Stricter-ISO8601-TimeStamp-printing-JuanVuletich-2025Aug18-16h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7426] on 19 August 2025 at 3:32:37 pm'!
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 8/19/2025 15:31:49' prior: 16973148!
                        logError: errMsg inContext: aContext to: baseFilename
	"Log the error message and a stack trace to the given file.
	Smalltalk logError: 'test error message' inContext: thisContext to: 'testErr'
	"

	| localFilename file |
	localFilename := (Preferences at: #debugLogTimestamp)
		ifTrue: [ baseFilename, '-',
				(String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]),
				'.log' ]
		ifFalse: [ baseFilename, '.log' ].
	file := DirectoryEntry logsDirectory // localFilename.
	[
		file forceWriteStreamDo: [ :stream |
	 	 	stream nextPutAll: errMsg; newLine.
			aContext errorReportOn: stream ]
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"
	[
 	 	StdIOWriteStream stdout newLine; nextPutAll: errMsg.
		StdIOWriteStream stdout newLine; nextPutAll: 'See '; nextPutAll: file pathName.
		StdIOWriteStream stdout newLine.
		aContext shortErrorReportOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout flush
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"! !
!DateAndTime methodsFor: 'public protocol' stamp: 'jmv 8/19/2025 15:31:03' prior: 50360374!
   filenamishPrintOn: aStream
	"
	String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ] '2025Aug18-16h46m' .
	"
	
	| year month day monthName |
	self dayMonthYearDo: [ :d :m :y | year := y. month := m. day := d ].
	year negative
		ifTrue: [ aStream nextPut: $- ].
	monthName := Month nameOfMonth: month.
	aStream
		nextPutAll: (year abs printString padded: #left to: 4 with: $0);
		nextPutAll: (monthName copyFrom: 1 to: 3);
		nextPutAll: (day printString padded: #left to: 2 with: $0);
		nextPut: $-;
		nextPutAll: (self hour printString padded: #left to: 2 with: $0);
		nextPut: $h;
		nextPutAll: (self minute printString padded: #left to: 2 with: $0);
		nextPut: $m! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 8/19/2025 15:21:16' prior: 50359803!
                 prefSystem
	^ #(
		#(allowNonLocalReturnsInExceptionHandlers true )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges true )
		#(caseSensitiveFinds false )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(warnAndOfferLastUserChanges true )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #cuis #(cuis roots) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(useUserPrefsFile true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
		#(saveReleaseOptionsInWorldMenu false)
	)! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 8/19/2025 15:27:12' prior: 16808474!
        fileOut
	"File out the receiver, to a file whose name is a function of the  
	change-set name and a unique numeric tag."

	| folder slips nameToUse |
	folder := DirectoryEntry savedChangeSetsDirectory.
	nameToUse := self name.
	nameToUse := nameToUse copyReplaceAll: 'AuthorName' with: Utilities authorName asUnaccented asCamelCase.
	nameToUse := folder nextNameFor: nameToUse coda: '-', Utilities authorInitials extension: 'cs.st'.

	folder // nameToUse writeStreamDo: [ :fileStream |
		fileStream ifNotNil: [
			fileStream timeStamp.
			self fileOutPreambleOn: fileStream.
			self fileOutOn: fileStream.
			self fileOutPostscriptOn: fileStream ]].

	self hasUnsavedChanges: false.
	(Preferences at: #checkForSlips) 		ifFalse: [^ self].
	slips := self checkForSlips.
	(slips notEmpty
			and: [(PopUpMenu withCaption: 'Methods in this fileOut have halts
or references to the Transcript
or other ''slips'' in them.
Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')
					= 2])
		ifTrue: [ Smalltalk browseMessageList: slips name: 'Possible slips in ' , name ].! !

Utilities class removeSelector: #dateTimeSuffix!

!methodRemoval: Utilities class #dateTimeSuffix stamp: 'Install-7427-Cleanup-JuanVuletich-2025Aug19-15h21m-jmv.055.cs.st 8/29/2025 15:07:09'!
dateTimeSuffix
	"Answer a string which indicates the date and time, intended for use in building fileout filenames, etc.
	See also #filenamishPrintOn:.

	Utilities dateTimeSuffix
	"
	| n |
	n := DateAndTime now.
	^ String streamContents: [ :strm |
		n printYMDOn: strm.
		strm nextPut: $_.
		n printHMSOn: strm separator: $. ]!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Preferences removeKey: #changeSetVersionNumbers!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7427-Cleanup-JuanVuletich-2025Aug19-15h21m-jmv.055.cs.st----!

'From Cuis7.5 [latest update: #7427] on 19 August 2025 at 9:15:21 pm'!
!Parser methodsFor: 'expression types' stamp: 'jmv 8/19/2025 21:13:41' prior: 16928099!
  doitPatternInContext: context

	self selector: self class doItSelector.
	^context
		ifNil: [{self class doItSelector. {}. 1. nil }]
		ifNotNil: [{self class doItInSelector. {encoder encodeVariable: Encoder doItInContextName}. 3. nil}]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7428-FixFor7404-JuanVuletich-2025Aug19-21h14m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7428] on 20 August 2025 at 2:39:24 pm'!
!Morph methodsFor: 'submorphs-menus' stamp: 'NPM 8/20/2025 14:33:49' prior: 16914109!
                           addItemTo: topMenu fromSpec: itemSpec submenus: submenusDictionary
	"
	See coment at Morph >> #getMenu
	"
	| submenuId menu label target selector arguments iconSymbol helpText menuItem |
	label := itemSpec second.
	label ifNil: [ ^self ]. "Only a keyboard shortcut, not a real menu item."
	submenuId := itemSpec first // 1000.
	menu := submenuId = 0 ifTrue: [ topMenu ] ifFalse: [ submenusDictionary at: submenuId ifAbsent: [^self]].
	target := itemSpec fourth
		ifNotNil: [ :targetOrGetter |
			targetOrGetter isSymbol
				ifTrue: [ 	self perform: targetOrGetter ]
				ifFalse: [ targetOrGetter ]]
		ifNil: [ self ].
	selector := itemSpec fifth.
	arguments := (selector isNil or: [ selector numArgs = 0 ])
		ifTrue: [#()]
		ifFalse: [itemSpec size >= 8 ifTrue: [ {itemSpec eighth} ] ifFalse: [ {self} ]].
	menuItem := label isSymbol
		ifTrue: [ menu addUpdating: label target: target action: selector argumentList: arguments ]
		ifFalse: [ menu add: label target: target action: selector argumentList: arguments ].
	iconSymbol := itemSpec size >= 6 ifTrue: [ itemSpec sixth ].
	iconSymbol ifNotNil: [ menuItem setIcon: iconSymbol ].
	helpText := itemSpec size >= 7 ifTrue: [ itemSpec seventh ].
	helpText ifNotNil: [ menuItem setBalloonText: helpText ].
	
	selector
		 ifNil: [
			menuItem isEnabled: false ]
		ifNotNil: [
			| enabledSelector |
			enabledSelector := itemSpec size >= 9 ifTrue: [ itemSpec ninth ].
			enabledSelector ifNotNil: [ 
				menuItem isEnabled: (target perform: enabledSelector) ]].
! !
!Morph methodsFor: 'submorphs-menus' stamp: 'NPM 8/20/2025 14:32:23' prior: 16914218!
getMenu
	"Answer the right-click (contextual) menu."
	"Spec for the menu and shortcut keys.
	Each entry is
		#(itemId 			'menu item label'    shortcut    receiverGetter    selector     iconOrNil(optional)    'helpText(optional)'    selectorArgument(optional))
		- itemId is a number (integer or float). It specifies the position of the item in the menu, and is also an id, allowing for overrides and deletions.
		- label is a string or symbol. Symbol means self updating menu entry. nil means just keyboard shortcut, no menu entry.
		- shortcut is a Character or nil
		- receiverGetter sent to the widget to get the actual receiver for selector.
			Typically #window, #model or #editor. If nil, receiver is the widget itself.
		- selector is #aSymbol. Usually no arguments, or one single argument in 8th entry. 
			If a Number (multiple of 1000), indicates a subMenu. ItemsIds must be in range. See BrowserWindow>>#classListMenuSpec.
			If nil, the menu entry is created but disabled. The keyboard shortcut is disabled too.
		- icon may be nil. It is also optional (but must be there if there is help text)
		- help text is optional
		- selectorArgument is optional. If selector takes an argument, and selectorArgument is not provided, the argument is self.
	- enabledSelector is an optional symbol. The result of sending it to target will be used to enable or disable the menu item.
	Entries of size 1 mean 'remove menu item'.
	Entries of size 2 are separators.
	An entry of size 3 (usually with key 0 and at the first position), if present, tells a menu title, whether to #addStayUpIcons.
	"

	| menuNshortcutsSpecs itemSpec menu submenus |
	menuNshortcutsSpecs := self allMenuNshortcutsSpecs.
	menuNshortcutsSpecs ifEmpty: [ ^nil ].
	menu := MenuMorph new.
	submenus := nil.
	menuNshortcutsSpecs keys sorted do: [ :key |
		itemSpec := menuNshortcutsSpecs at: key.
		itemSpec size =1 ifTrue: [
				"Do nothing. This is a marker for removing a previously provided entry" ]
			ifFalse: [ itemSpec size = 2 ifTrue: [
				itemSpec second first == $X ifFalse: [ "Compatibility. Also a marker for removing previous entries."
					self addLineTo: menu fromSpec: itemSpec submenus: submenus ]]
			ifFalse: [ itemSpec size = 3 ifTrue: [
				self addTitleTo: menu fromSpec: itemSpec ]
			ifFalse: [ itemSpec fifth isNumber ifTrue: [
				submenus ifNil: [submenus := Dictionary new ].
				self addSubmenuTo: menu fromSpec: itemSpec submenus: submenus ]
			ifFalse: [
				self addItemTo: menu fromSpec: itemSpec submenus: submenus ]]]]].
	^ menu! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7429-DinamicallyEnableOrDisableMenuEntries-NicolasPapagnaMaldonado-2025Aug20-14h32m-NPM.001.cs.st----!

'From Cuis7.5 [latest update: #7429] on 20 August 2025 at 3:28:57 pm'!
!FormLayoutMorph methodsFor: 'testing' stamp: 'JEC 8/20/2025 12:16:51' overrides: 50354670!
                  is: aSymbol
	^ aSymbol == #FormLayoutMorph or: [ super is: aSymbol ]! !
!LinearLayoutMorph methodsFor: 'testing' stamp: 'JEC 8/20/2025 12:17:00' overrides: 50354670!
                          is: aSymbol
	^ aSymbol == #LinearLayoutMorph or: [ super is: aSymbol ]! !
!SystemWindow methodsFor: 'layout' stamp: 'JEC 8/20/2025 12:15:57'!
                  beForm

	self useFormLayout! !
!SystemWindow methodsFor: 'layout' stamp: 'JEC 8/20/2025 15:19:15'!
                             useFormLayout

	(layoutMorph is: #FormLayoutMorph) ifFalse: [
		self useLayoutMorph:  LayoutMorph newForm ].! !
!SystemWindow methodsFor: 'layout' stamp: 'JEC 8/20/2025 12:17:55'!
            useLayoutMorph: aNewLayout

	self validateLayoutMorphCanBeChanged.

	aNewLayout adoptWidgetsColor: self windowColor.
	
	layoutMorph
		ifNil: [ self addMorphFront: aNewLayout ]
		ifNotNil: [ self replaceSubmorph: layoutMorph by: aNewLayout ].
		
	layoutMorph :=  aNewLayout.
	
	"We need this so that the layout is within the interiorExtent"
	self extentChanged: self morphExtent.
	
	^ layoutMorph! !
!SystemWindow methodsFor: 'layout' stamp: 'JEC 8/20/2025 15:19:11'!
             useLinearLayout

	(layoutMorph is: #LinearLayoutMorph) ifFalse: [
		self useLayoutMorph:  LayoutMorph newColumn ].! !
!SystemWindow methodsFor: 'layout' stamp: 'JEC 8/20/2025 15:16:13'!
      validateLayoutMorphCanBeChanged

	(layoutMorph notNil and: [ layoutMorph hasSubmorphs ])
		ifTrue: [ self error: 'Cannot replace a LayoutMorph containing submorphs' ]! !
!SystemWindow methodsFor: 'layout' stamp: 'JEC 8/20/2025 15:26:32' prior: 50351116!
  beColumn
	
	self useLinearLayout.
	layoutMorph beColumn.! !
!SystemWindow methodsFor: 'layout' stamp: 'JEC 8/20/2025 15:26:47' prior: 50351124!
                beRow
	
	self useLinearLayout.
	layoutMorph beRow.! !

SystemWindow removeSelector: #replacingLayoutMorphWithSubmorphsErrorMessage!

SystemWindow removeSelector: #errorOnReplacingLayoutMorphWithSubmorphs!

SystemWindow removeSelector: #createLayout:unless:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7430-FormLayouts-convenience-JoelEstebanCamera-2025Aug20-15h23m-JEC.001.cs.st----!

'From Cuis7.5 [latest update: #7428] on 22 August 2025 at 9:23:22 am'!
!SmalltalkCompleter methodsFor: 'message entries - private' stamp: 'HAW 8/22/2025 09:22:04' prior: 16960232!
                              computeMessageEntriesFor: allSource in: contextClass and: specificModel
	
	| id rangeType |

	canShowSelectorDocumentation := true.
	id := allSource copyFrom: currentRange start to: currentRange end.
	rangeType := currentRange rangeType.

	rangeType == #globalVar
		ifTrue: [ ^self computeMessageEntriesForClass: (Smalltalk at: id asSymbol) class ].
	rangeType == #self
		ifTrue: [ ^self computeMessageEntriesForClass: contextClass ].
	(rangeType == #super and: [ contextClass notNil ])
		ifTrue: [ ^self computeMessageEntriesForClass: contextClass superclass ].
	rangeType == #true 
		ifTrue: [ ^self computeMessageEntriesForClass: True ].
	rangeType == #false
		ifTrue: [ ^self computeMessageEntriesForClass: False ].
	rangeType == #nil
		ifTrue: [ ^self computeMessageEntriesForClass: UndefinedObject ].
	rangeType == #character
		ifTrue: [ ^self computeMessageEntriesForClass: Character ].
	rangeType == #number
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #string
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #symbol
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #stringSymbol
		ifTrue: [ ^self computeMessageEntriesForClass: (self classOfLiteral: id in: contextClass) ].
	rangeType == #instVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofInstVarNamed: id ].
	rangeType == #methodArg
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id ].
	rangeType == #tempVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofTempVarNamed: id ].
	rangeType == #blockArg
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockArgNamed: id ].
	rangeType == #blockTempVar
		ifTrue: [ ^specificModel computeMessageEntriesIn: self ofBlockTempVarNamed: id ].
	rangeType == #workspaceVar
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (specificModel classOfWorkspaceVarNamed: id) ].
	rangeType == #thisContext
		ifTrue: [ ^self computeMessageEntriesForClass: (specificModel classOfThisContext) ]. 
	rangeType == #classVar
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	rangeType == #poolConstant
		ifTrue: [ ^self computeMessageEntriesForClassOrNil: (self classOfLocalBindingNamed: id in: contextClass) ].
	(rangeType beginsWith: #blockEnd)
		ifTrue: [ ^self computeMessageEntriesForClass: BlockClosure ].
	rangeType == #arrayEnd
		ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	(rangeType beginsWith: #rightBrace)
		ifTrue: [ ^self computeMessageEntriesForClass: Array ].
	rangeType == #unary
		ifTrue: [ ^self computeEntriesOfUnaryMessageReturnNamed: id ].
	(rangeType beginsWith: #rightParenthesis)
		ifTrue: [ ^self computeMessageEntriesOfEnclosedExpressionReturn].
	rangeType == #cascadeSeparator
		ifTrue: [ ^self computeMessageEntriesOfCascadeReceiver]. 

	self computeMessageEntriesForUnknowClass.	
	! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7431-fixAutocompleForSuperWhenNil-HernanWilkinson-2025Aug22-09h15m-HAW.001.cs.st----!

'From Cuis7.5 [latest update: #7431] on 23 August 2025 at 11:12:49 am'!
!Morph methodsFor: 'drawing' stamp: 'jmv 8/23/2025 11:09:35' prior: 16910929!
          imageForm: extentOrNil depth: depth

	| answerExtent answer auxCanvas bounds |
	self ensureMinimumExtent.

	self requiresVectorCanvas ifTrue: [	
		^ self imageFormVG: extentOrNil depth: depth ].

	bounds := self fullBoundsInOwner.
	answerExtent := bounds extent.
	extentOrNil ifNotNil: [ answerExtent := answerExtent min: extentOrNil * 4 ].
	auxCanvas := MorphicCanvas depth: depth over: (bounds origin extent: answerExtent ceiling).
	[auxCanvas fullDraw: self] on: Error do: [ auxCanvas canvasToUse drawCurrentAsOutline ].
	answer := auxCanvas form.
	"answer divideByAlpha."
	"answer makeAllPixelsOpaque."
	answer fixAlpha.
	extentOrNil ifNotNil: [ answer := answer magnifyTo: extentOrNil ].
	^answer! !
!Morph methodsFor: 'drawing' stamp: 'jmv 8/23/2025 11:12:27' prior: 16910951!
                 imageFormVG: extentOrNil depth: depth
	"Draw using a VectorCanvas
	Scale as needed. Draw unrotated."

	| prevNotVisibleFlag bounds extent fauxLocation answer auxCanvas |
	"Position and scale us in order to fill required extent, but disregard any rotation.
	Do it without triggering any invalidation at all."
	prevNotVisibleFlag := self privateFlagAt: 3.
	[
		bounds := self findFullBoundsInOwner.
		extentOrNil
			ifNotNil: [ | scale |
				extent := extentOrNil.
				scale := extent x asFloat / bounds width min: extent y asFloat / bounds height.
				fauxLocation := AffineTransformation withScale: scale position: bounds origin negated +1 * scale ]
			ifNil: [
				extent := bounds extent.
				fauxLocation := MorphicTranslation withTranslation: bounds origin negated ].
		answer := Form extent: extent depth: 32.
		auxCanvas := VectorCanvas onForm: answer.
		auxCanvas engine enableTargetTranslucency.
		auxCanvas geometryTransformation: fauxLocation.
		depth = 32 ifFalse: [
			"Only 32 bpp can hold translucent anti aliasing over transparent background"
			answer fillColor: Color veryLightGray ].
		self privateFlagAt: 3 put: false.
		[auxCanvas fullDraw: self] on: Error do: [ auxCanvas canvasToUse drawCurrentAsOutline ].
	] ensure: [
		self privateFlagAt: 3 put: prevNotVisibleFlag ].
	^answer asFormOfDepth: depth.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7432-imageForm-depth-fix-JuanVuletich-2025Aug23-10h49m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7428] on 20 August 2025 at 12:28:06 pm'!

ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior isTest overrides '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!classDefinition: #ChangeRecord category: #'Tools-Changes' stamp: 'Install-7433-ChangeRecord-remove-isTest-ivar-JuanVuletich-2025Aug20-12h22m-jmv.001.cs.st 8/29/2025 15:07:09'!
ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior isTest overrides'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeList methodsFor: 'scanning' stamp: 'jmv 8/20/2025 12:27:11' prior: 16804188!
                          classDefinitionRecordFrom: tokens
	
	| classDefinition isMeta itemPosition className record fullClassName category stamp |
	
	itemPosition := file position.
	fullClassName := tokens second.
	isMeta := fullClassName includesSubString: ' class'.
	className := isMeta ifTrue: [fullClassName substrings first] ifFalse: [fullClassName].
	category := CompiledMethod classCategoryFrom: tokens.
	stamp := CompiledMethod stampFrom: tokens.
	classDefinition := file nextChunk.
	
	record := ChangeRecord new 
		file: file 
		position: itemPosition 
		type: #classDefinition 
		class: className asSymbol 
		category: category 
		meta: isMeta 
		stamp: stamp.
	
	^record
! !
!ChangeRecord methodsFor: 'initialization' stamp: 'jmv 8/20/2025 12:27:18' prior: 16806123!
              file: aFile position: aPosition type: aType

	file := aFile.
	position := aPosition.
	type := aType.
"
file closed ifFalse: [
	'' print.
	file print.
	self print.
	thisContext printStack: 10 ]
"! !

ChangeRecord removeSelector: #isTestClassChange!

!methodRemoval: ChangeRecord #isTestClassChange stamp: 'Install-7433-ChangeRecord-remove-isTest-ivar-JuanVuletich-2025Aug20-12h22m-jmv.001.cs.st 8/29/2025 15:07:09'!
isTestClassChange

	^ isTest!

ChangeRecord removeSelector: #markAsTest:!

!methodRemoval: ChangeRecord #markAsTest: stamp: 'Install-7433-ChangeRecord-remove-isTest-ivar-JuanVuletich-2025Aug20-12h22m-jmv.001.cs.st 8/29/2025 15:07:09'!
markAsTest: aBoolean

	isTest := aBoolean !

ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior overrides'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!classDefinition: #ChangeRecord category: #'Tools-Changes' stamp: 'Install-7433-ChangeRecord-remove-isTest-ivar-JuanVuletich-2025Aug20-12h22m-jmv.001.cs.st 8/29/2025 15:07:09'!
ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior overrides'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7433-ChangeRecord-remove-isTest-ivar-JuanVuletich-2025Aug20-12h22m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7431] on 20 August 2025 at 4:50:26 pm'!

ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior overrides '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!classDefinition: #ChangeRecord category: #'Tools-Changes' stamp: 'Install-7434-ChangeRecord-remove-overrides-ivar-JuanVuletich-2025Aug20-16h46m-jmv.001.cs.st 8/29/2025 15:07:09'!
ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior overrides'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeList methodsFor: 'scanning' stamp: 'jmv 8/20/2025 16:47:35'!
                          scanCategory: category class: class meta: meta stamp: stamp prior: aPriorMethod

	| itemPosition method |

	[
		itemPosition := file position.
		method := file nextChunk.
		method notEmpty ] whileTrue: [ "done when double terminators"
			self
				addItem: (ChangeRecord new 
					file: file 
					position: itemPosition 
					type: #method
					class: class 
					category: category 
					meta: meta 
					stamp: stamp
					prior: aPriorMethod)
				text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])
					, (((Smalltalk at: class ifAbsent: [Object class]) parserClass selectorFrom: method) ifNil: [''])
					, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]! !
!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 8/20/2025 16:49:06'!
                             putSource: sourceStr fromParseNode: methodNode class: class category: catName
	withStamp: changeStamp inFile: fileIndex priorMethod: priorMethod

	^ self putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: [ :file |
			class
				printCategoryChunk: catName
				on: file
				withStamp: changeStamp
				priorMethod: priorMethod.
			file newLine ]! !
!ChangeList methodsFor: 'scanning' stamp: 'jmv 8/20/2025 16:48:04' prior: 16804365!
                     scanMethodDefinition: tokens

	| stamp className priorMethod |
	
	className := tokens first.
	stamp := CompiledMethod stampFrom: tokens.
	priorMethod := CompiledMethod priorReferenceFrom: tokens.
	
	tokens second == #methodsFor: ifTrue: [
		^ self scanCategory: tokens third class: className meta: false stamp: stamp prior: priorMethod ].

	tokens third == #methodsFor: ifTrue: [
		^ self scanCategory: tokens fourth class: className meta: true stamp: stamp prior: priorMethod ].
	
	self error: 'Unsupported method definition' 
! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/20/2025 16:48:47' prior: 16820102!
                printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod
	"Print a method category preamble.  This must have a category name.
	It may have an author/date stamp, and it may have a prior source link.
	If it has a prior source link, it MUST have a stamp, even if it is empty."

"The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."

	aFileStream newLine; nextPut: $!!.
	aFileStream nextChunkPut: (String streamContents: [ :strm |
		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.
		(changeStamp notNil and: [
			changeStamp notEmpty or: [priorMethod notNil]]) ifTrue: [
			strm nextPutAll: ' stamp: '; print: changeStamp].
		priorMethod notNil ifTrue: [
			strm nextPutAll: ' prior: '; print: priorMethod sourcePointer].
		]).
! !
!ClassDescription methodsFor: 'private' stamp: 'jmv 8/20/2025 16:49:19' prior: 16820861!
              logMethodSource: code forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor
	| priorMethodOrNil |

	priorMethodOrNil := self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: nil.

	aCompiledMethodWithNode method
		putSource: code
		fromParseNode: aCompiledMethodWithNode node
		class: self 
		category: category 
		withStamp: changeStamp 
		inFile: 2 
		priorMethod: priorMethodOrNil.! !

ChangeRecord removeSelector: #file:position:type:class:category:meta:stamp:prior:overrides:!

!methodRemoval: ChangeRecord #file:position:type:class:category:meta:stamp:prior:overrides: stamp: 'Install-7434-ChangeRecord-remove-overrides-ivar-JuanVuletich-2025Aug20-16h46m-jmv.001.cs.st 8/29/2025 15:07:09'!
file: aFile position: aPosition type: aType class: aClassName category: aClassCategory meta: isMeta stamp: aStamp prior: aPrior overrides: anOverridenMethod

	self file: aFile position: aPosition type: aType.
	class := aClassName.
	category := aClassCategory.
	meta := isMeta.
	stamp := aStamp.
	prior := aPrior.
	overrides := anOverridenMethod.!

ChangeRecord removeSelector: #overridesASuperclassMethod!

!methodRemoval: ChangeRecord #overridesASuperclassMethod stamp: 'Install-7434-ChangeRecord-remove-overrides-ivar-JuanVuletich-2025Aug20-16h46m-jmv.001.cs.st 8/29/2025 15:07:09'!
overridesASuperclassMethod
	^ overrides notNil !

CompiledMethod class removeSelector: #overridenMethodReferenceFrom:!

!methodRemoval: CompiledMethod class #overridenMethodReferenceFrom: stamp: 'Install-7434-ChangeRecord-remove-overrides-ivar-JuanVuletich-2025Aug20-16h46m-jmv.001.cs.st 8/29/2025 15:07:09'!
overridenMethodReferenceFrom: tokens

	^ self field: #overrides: from: tokens ifAbsentOrNil: nil!

CompiledMethod removeSelector: #putSource:fromParseNode:class:category:withStamp:inFile:priorMethod:overridesMethod:!

!methodRemoval: CompiledMethod #putSource:fromParseNode:class:category:withStamp:inFile:priorMethod:overridesMethod: stamp: 'Install-7434-ChangeRecord-remove-overrides-ivar-JuanVuletich-2025Aug20-16h46m-jmv.001.cs.st 8/29/2025 15:07:09'!
putSource: sourceStr fromParseNode: methodNode class: class category: catName
	withStamp: changeStamp inFile: fileIndex priorMethod: priorMethod overridesMethod: overridenMethod

	^ self putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: [ :file |
			class
				printCategoryChunk: catName
				on: file
				withStamp: changeStamp
				priorMethod: priorMethod
				overridesMethod: overridenMethod.
			file newLine ]!

ClassDescription removeSelector: #printCategoryChunk:on:withStamp:priorMethod:overridesMethod:!

!methodRemoval: ClassDescription #printCategoryChunk:on:withStamp:priorMethod:overridesMethod: stamp: 'Install-7434-ChangeRecord-remove-overrides-ivar-JuanVuletich-2025Aug20-16h46m-jmv.001.cs.st 8/29/2025 15:07:09'!
printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod overridesMethod: overridenMethod
	"Print a method category preamble.  This must have a category name.
	It may have an author/date stamp, and it may have a prior source link.
	If it has a prior source link, it MUST have a stamp, even if it is empty."

"The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."

	aFileStream newLine; nextPut: $!!.
	aFileStream nextChunkPut: (String streamContents: [ :strm |
		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.
		(changeStamp notNil and: [
			changeStamp notEmpty or: [priorMethod notNil]]) ifTrue: [
			strm nextPutAll: ' stamp: '; print: changeStamp].
		priorMethod notNil ifTrue: [
			strm nextPutAll: ' prior: '; print: priorMethod sourcePointer].
		overridenMethod notNil ifTrue: [
			strm nextPutAll: ' overrides: '; print: overridenMethod sourcePointer]
		]).
!

ChangeList removeSelector: #scanCategory:class:meta:stamp:prior:overrides:!

!methodRemoval: ChangeList #scanCategory:class:meta:stamp:prior:overrides: stamp: 'Install-7434-ChangeRecord-remove-overrides-ivar-JuanVuletich-2025Aug20-16h46m-jmv.001.cs.st 8/29/2025 15:07:09'!
scanCategory: category class: class meta: meta stamp: stamp prior: aPriorMethod overrides: anOverridenMethod

	| itemPosition method |

	[
		itemPosition := file position.
		method := file nextChunk.
		method notEmpty ] whileTrue: [ "done when double terminators"
			self
				addItem: (ChangeRecord new 
					file: file 
					position: itemPosition 
					type: #method
					class: class 
					category: category 
					meta: meta 
					stamp: stamp
					prior: aPriorMethod
					overrides: anOverridenMethod)
				text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])
					, (((Smalltalk at: class ifAbsent: [Object class]) parserClass selectorFrom: method) ifNil: [''])
					, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]!

ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!classDefinition: #ChangeRecord category: #'Tools-Changes' stamp: 'Install-7434-ChangeRecord-remove-overrides-ivar-JuanVuletich-2025Aug20-16h46m-jmv.001.cs.st 8/29/2025 15:07:09'!
ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7434-ChangeRecord-remove-overrides-ivar-JuanVuletich-2025Aug20-16h46m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7431] on 20 August 2025 at 5:00:40 pm'!
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/20/2025 16:59:58' prior: 16820038!
                             methodsFor: categoryName stamp: changeStamp 
	^ self methodsFor: categoryName stamp: changeStamp prior: 0! !

Utilities class removeSelector: #fixStamp:!

!methodRemoval: Utilities class #fixStamp: stamp: 'Install-7435-Remove-Utilities-fixStamp-JuanVuletich-2025Aug20-16h50m-jmv.001.cs.st 8/29/2025 15:07:09'!
fixStamp: changeStamp 
	| parts |
	parts := changeStamp findTokens: ' '.
	(parts size > 0 and: [parts last first isLetter]) ifTrue:
		["Put initials first in all time stamps..."
		^ String streamContents:
				[:s | s nextPutAll: parts last.
				parts allButLast do: [:p | s space; nextPutAll: p]]].
	^ changeStamp!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7435-Remove-Utilities-fixStamp-JuanVuletich-2025Aug20-16h50m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7433] on 21 August 2025 at 6:03:41 pm'!

ClassDescription removeSelector: #printCategoryChunk:on:!

!methodRemoval: ClassDescription #printCategoryChunk:on: stamp: 'Install-7436-Behavior-removeUnusedMethods-JuanVuletich-2025Aug21-17h57m-jmv.001.cs.st 8/29/2025 15:07:09'!
printCategoryChunk: categoryName on: aFileStream
	^ self printCategoryChunk: categoryName withStamp: '' on: aFileStream!

ClassDescription removeSelector: #printCategoryChunk:withStamp:on:!

!methodRemoval: ClassDescription #printCategoryChunk:withStamp:on: stamp: 'Install-7436-Behavior-removeUnusedMethods-JuanVuletich-2025Aug21-17h57m-jmv.001.cs.st 8/29/2025 15:07:09'!
printCategoryChunk: categoryName withStamp: changeStamp on: aFileStream
	^ self printCategoryChunk: categoryName on: aFileStream withStamp: changeStamp
		priorMethod: nil!

ClassDescription removeSelector: #commentFollows!

!methodRemoval: ClassDescription #commentFollows stamp: 'Install-7436-Behavior-removeUnusedMethods-JuanVuletich-2025Aug21-17h57m-jmv.001.cs.st 8/29/2025 15:07:09'!
commentFollows 
	"Answer a ClassCommentReader who will scan in the comment."

	^ ClassCommentReader new setClass: self category: #Comment

	"False commentFollows inspect"!

ClassDescription removeSelector: #methodsFor:priorSource:inFile:!

!methodRemoval: ClassDescription #methodsFor:priorSource:inFile: stamp: 'Install-7436-Behavior-removeUnusedMethods-JuanVuletich-2025Aug21-17h57m-jmv.001.cs.st 8/29/2025 15:07:09'!
methodsFor: aString priorSource: sourcePosition inFile: fileIndex
	"Prior source pointer ignored when filing in."
	^ self methodsFor: aString!

Behavior removeSelector: #printSubclassesOn:level:!

!methodRemoval: Behavior #printSubclassesOn:level: stamp: 'Install-7436-Behavior-removeUnusedMethods-JuanVuletich-2025Aug21-17h57m-jmv.001.cs.st 8/29/2025 15:07:09'!
printSubclassesOn: aStream level: level
	"As part of the algorithm for printing a description of the receiver, print the
	subclass on the file stream, aStream, indenting level times."
	| subclassNames |
	aStream newLineTab: level.
	aStream nextPutAll: self name.
	aStream
		 space;
		 print: self instVarNames.
	self == Class ifTrue: [
		aStream
			 newLineTab: level + 1;
			 nextPutAll: '[ ... all the Metaclasses ... ]'.
		^ self ].
	subclassNames := self subclasses asArray sort: [ :c1 :c2 |
		c1 name <= c2 name ].
	"Print subclasses in alphabetical order"
	subclassNames do: [ :subclass |
		subclass
			printSubclassesOn: aStream
			level: level + 1 ].!

Behavior removeSelector: #recompileNonResidentMethod:atSelector:from:!

!methodRemoval: Behavior #recompileNonResidentMethod:atSelector:from: stamp: 'Install-7436-Behavior-removeUnusedMethods-JuanVuletich-2025Aug21-17h57m-jmv.001.cs.st 8/29/2025 15:07:09'!
recompileNonResidentMethod: method atSelector: selector from: oldClass
	"Recompile the method supplied in the context of this class."

	| trailer methodNode |
	trailer := method trailer.
	methodNode := self compilerClass new
			compile: (method getSourceFor: selector in: oldClass)
			in: self
			notifying: nil
			ifFail: ["We're in deep doo-doo if this fails (syntax error).
				Presumably the user will correct something and proceed,
				thus installing the result in this methodDict.  We must
				retrieve that new method, and restore the original (or remove)
				and then return the method we retrieved."
				^ self error: 'see comment'].
	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].
	^ methodNode generate: trailer
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7436-Behavior-removeUnusedMethods-JuanVuletich-2025Aug21-17h57m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7433] on 21 August 2025 at 10:31:43 am'!
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/21/2025 10:28:29' prior: 16820287!
                     reformatMethodAt: selector 
	| newCodeString method | 
	newCodeString := (self compilerClass new)
		format: (self sourceCodeAt: selector)
		in: self
		notifying: nil.
	method := self compiledMethodAt: selector.
	method
		putSource: newCodeString
		fromParseNode: nil
		class: self
		category: (self organization categoryOfElement: selector)
		withStamp: Utilities changeStamp
		inFile: 2 priorMethod: method! !

CompiledMethod removeSelector: #putSource:fromParseNode:class:category:inFile:priorMethod:!

!methodRemoval: CompiledMethod #putSource:fromParseNode:class:category:inFile:priorMethod: stamp: 'Install-7437-ClassDescription-SmallCleanup-JuanVuletich-2025Aug21-10h26m-jmv.001.cs.st 8/29/2025 15:07:09'!
putSource: sourceStr fromParseNode: methodNode class: class category: catName
	inFile: fileIndex priorMethod: priorMethod

	^ self putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: [ :file |
		class printCategoryChunk: catName on: file priorMethod: priorMethod.
		file newLine ]!

ClassDescription removeSelector: #printCategoryChunk:on:priorMethod:!

!methodRemoval: ClassDescription #printCategoryChunk:on:priorMethod: stamp: 'Install-7437-ClassDescription-SmallCleanup-JuanVuletich-2025Aug21-10h26m-jmv.001.cs.st 8/29/2025 15:07:09'!
printCategoryChunk: category on: aFileStream priorMethod: priorMethod
	^ self printCategoryChunk: category on: aFileStream
		withStamp: Utilities changeStamp priorMethod: priorMethod!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7437-ClassDescription-SmallCleanup-JuanVuletich-2025Aug21-10h26m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7437] on 25 August 2025 at 4:46:01 pm'!

ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior libraryName '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!classDefinition: #ChangeRecord category: #'Tools-Changes' stamp: 'Install-7438-Changes-ChangeRecord-read-library-keyword-JuanVuletich-2025Aug25-16h41m-jmv.001.cs.st 8/29/2025 15:07:09'!
ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior libraryName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!
!ChangeList methodsFor: 'scanning' stamp: 'jmv 8/21/2025 12:22:12'!
                          scanCategory: category class: class meta: meta stamp: stamp prior: priorVersionPosition libraryName: aStringOrNil

	| itemPosition method |

	[
		itemPosition := file position.
		method := file nextChunk.
		method notEmpty ] whileTrue: [ "done when double terminators"
			self
				addItem: (ChangeRecord new
					file: file 
					position: itemPosition 
					type: #method
					class: class 
					category: category 
					meta: meta 
					stamp: stamp
					prior: priorVersionPosition
					libraryName: aStringOrNil)
				text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])
					, (((Smalltalk at: class ifAbsent: [Object class]) parserClass selectorFrom: method) ifNil: [''])
					, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]! !
!CompiledMethod class methodsFor: 'source code management aux' stamp: 'jmv 8/21/2025 10:39:48'!
           libraryNameFrom: tokens

	^ self field: #library: from: tokens ifAbsentOrNil: nil! !
!ChangeRecord methodsFor: 'initialization' stamp: 'jmv 8/21/2025 10:41:43'!
                               file: aFile position: aPosition type: aType class: aClassName category: aClassCategory meta: isMeta stamp: aStamp prior: aPrior libraryName: aString

	self file: aFile position: aPosition type: aType.
	class := aClassName.
	category := aClassCategory.
	meta := isMeta.
	stamp := aStamp.
	prior := aPrior.
	libraryName := aString.! !
!ChangeList methodsFor: 'scanning' stamp: 'jmv 8/21/2025 10:45:22' prior: 50361397!
                               scanMethodDefinition: tokens

	| stamp className priorVersionPosition libraryName |
	
	className := tokens first.
	stamp := CompiledMethod stampFrom: tokens.
	priorVersionPosition := CompiledMethod priorReferenceFrom: tokens.
	libraryName := CompiledMethod libraryNameFrom: tokens.
	
	tokens second == #methodsFor: ifTrue: [
		^ self scanCategory: tokens third class: className meta: false stamp: stamp prior: priorVersionPosition libraryName: libraryName ].

	tokens third == #methodsFor: ifTrue: [
		^ self scanCategory: tokens fourth class: className meta: true stamp: stamp prior: priorVersionPosition libraryName: libraryName ].
	
	self error: 'Unsupported method definition' 
! !
!ChangeList methodsFor: 'scanning' stamp: 'jmv 8/25/2025 16:44:00' prior: 16804424!
                              scanSpecificChangeRecordType
	"Scan anything that involves more than one chunk"

	| itemPosition item tokens firstToken secondToken |

	itemPosition := file position.
	item := file nextChunk.

	(self itemIsRecognized: item) ifFalse: [
		"Maybe a preamble, but not one we recognize; bail out with the preamble trick"
		^ self scanAndIgnore: item in: itemPosition ].

	tokens := Scanner new scanTokens: item.
	tokens size >= 2 ifTrue: [
		firstToken := tokens first.
		secondToken := tokens second.

		firstToken == #classDefinition:
			ifTrue: [ ^ self scanClassDefinition: tokens ].
		(firstToken == #classRemoval: or: [ firstToken == #classMoveToSomePackage: ])
			ifTrue: [ ^ self scanClassRemoval: tokens ].
		(firstToken == #methodRemoval: or: [ firstToken == #methodMoveToSomePackage: ])
			ifTrue: [ ^ self scanMethodRemoval: tokens ].
		(secondToken == #methodsFor: or: [ 
			tokens size > 2 and: [ tokens third == #methodsFor: ] ])
			ifTrue: [ ^ self scanMethodDefinition: tokens ].
		secondToken == #commentStamp:
			ifTrue: [ ^ self scanClassComment: tokens ].
		firstToken == #provides:
			ifTrue: [ ^ self scanFeatureProvision: tokens ].
		firstToken == #requires:
			ifTrue: [ ^ self scanFeatureRequirement: tokens ].
		firstToken == #classRenamed:
			ifTrue: [ ^ self scanClassRenamed: tokens ].
		]! !
!ChangeRecord methodsFor: 'initialization' stamp: 'jmv 8/21/2025 10:42:59' prior: 16806133!
                              file: aFile position: aPosition type: aType class: aClassName category: aClassCategory meta: isMeta stamp: aStamp

	self 
		file: aFile 
		position: aPosition 
		type: aType 
		class: aClassName 
		category: aClassCategory 
		meta: isMeta 
		stamp: aStamp 
		prior: nil
		libraryName: nil.
! !

ChangeRecord removeSelector: #file:position:type:class:category:meta:stamp:prior:!

!methodRemoval: ChangeRecord #file:position:type:class:category:meta:stamp:prior: stamp: 'Install-7438-Changes-ChangeRecord-read-library-keyword-JuanVuletich-2025Aug25-16h41m-jmv.001.cs.st 8/29/2025 15:07:09'!
file: aFile position: aPosition type: aType class: aClassName category: aClassCategory meta: isMeta stamp: aStamp prior: aPrior

	self file: aFile position: aPosition type: aType.
	class := aClassName.
	category := aClassCategory.
	meta := isMeta.
	stamp := aStamp.
	prior := aPrior.!

ChangeList removeSelector: #scanCategory:class:meta:stamp:prior:!

!methodRemoval: ChangeList #scanCategory:class:meta:stamp:prior: stamp: 'Install-7438-Changes-ChangeRecord-read-library-keyword-JuanVuletich-2025Aug25-16h41m-jmv.001.cs.st 8/29/2025 15:07:09'!
scanCategory: category class: class meta: meta stamp: stamp prior: aPriorMethod

	| itemPosition method |

	[
		itemPosition := file position.
		method := file nextChunk.
		method notEmpty ] whileTrue: [ "done when double terminators"
			self
				addItem: (ChangeRecord new 
					file: file 
					position: itemPosition 
					type: #method
					class: class 
					category: category 
					meta: meta 
					stamp: stamp
					prior: aPriorMethod)
				text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])
					, (((Smalltalk at: class ifAbsent: [Object class]) parserClass selectorFrom: method) ifNil: [''])
					, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]!

ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior libraryName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

!classDefinition: #ChangeRecord category: #'Tools-Changes' stamp: 'Install-7438-Changes-ChangeRecord-read-library-keyword-JuanVuletich-2025Aug25-16h41m-jmv.001.cs.st 8/29/2025 15:07:09'!
ChangeListElement subclass: #ChangeRecord
	instanceVariableNames: 'file position type class category meta stamp prior libraryName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Changes'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7438-Changes-ChangeRecord-read-library-keyword-JuanVuletich-2025Aug25-16h41m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7437] on 25 August 2025 at 4:47:57 pm'!
!ChangeList methodsFor: 'scanning' stamp: 'jmv 8/21/2025 12:48:00' prior: 50361856!
                           scanCategory: category class: class meta: meta stamp: stamp prior: priorVersionPosition libraryName: aStringOrNil
	"Read methods following a method category preamble in a chunk file.
	See #methods, #methodsFor:*, scanCategory:*"

	| itemPosition method |
	[
		itemPosition := file position.
		method := file nextChunk.
		method notEmpty ] whileTrue: [ "done when double terminators"
			self
				addItem: (ChangeRecord new
					file: file 
					position: itemPosition 
					type: #method
					class: class 
					category: category 
					meta: meta 
					stamp: stamp
					prior: priorVersionPosition
					libraryName: aStringOrNil)
				text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])
					, (((Smalltalk at: class ifAbsent: [Object class]) parserClass selectorFrom: method) ifNil: [''])
					, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])].! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/21/2025 12:46:43' prior: 16820009!
                            methods
	"May appear in method preambles in chunk files. Therefore may be called during #fileIn.
	See #methods, #methodsFor:*, scanCategory:*
	Answer a ClassCategoryReader for compiling messages that are not classified.
	Some chunk files may not include class category in the class declarations."

	^ ClassCategoryReader new setClass: self category: ClassOrganizer defaultMethodCategory.! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/21/2025 12:46:47' prior: 16820020!
                             methodsFor: categoryName
	"May appear in method preambles in chunk files. Therefore may be called during #fileIn.
	See #methods, #methodsFor:*, scanCategory:*
	Answer a ClassCategoryReader for compiling the messages in the category, categoryName, of the receiver."

	^ ClassCategoryReader new setClass: self category: categoryName asSymbol

	"(False methodsFor: 'logical operations') inspect"! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/21/2025 12:47:00' prior: 50361635!
                        methodsFor: categoryName stamp: changeStamp
	"May appear in method preambles in chunk files. Therefore may be called during #fileIn.
	See #methods, #methodsFor:*, scanCategory:*"

	^ self methodsFor: categoryName stamp: changeStamp prior: 0! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/21/2025 12:47:02' prior: 16820045!
                methodsFor: categoryName stamp: changeStamp prior: indexAndOffset
	"May appear in method preambles in chunk files. Therefore may be called during #fileIn.
	See #methods, #methodsFor:*, scanCategory:*
	Prior source link ignored when filing in."
	
	^ ClassCategoryReader new setClass: self
				category: categoryName asSymbol
				changeStamp: changeStamp

"Most importantly, return the new ClassCategoryReader, so a fileIn will let it seize control.  So method will be placed in the proper category.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7439-FileIn-MethodPreambleReadingDocumentation-JuanVuletich-2025Aug25-16h46m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7439] on 26 August 2025 at 3:16:24 pm'!
!ClassDescription methodsFor: 'compiling' stamp: 'jmv 8/21/2025 15:33:19'!
                     compile: code classified: category withStamp: changeStamp libraryName: aStringOrNil notifying: requestor logSource: logSource
	
	| methodAndNode selector isExistingMethod updatedCode |	
	methodAndNode := self basicCompile: code notifying: requestor 
							trailer: self defaultMethodTrailer ifFail: [^nil].
	selector := methodAndNode selector.
	isExistingMethod := self includesSelector: selector.
	isExistingMethod
		ifTrue: [
			(self theNonMetaClass isOkToChangeMethod: selector isMeta: self isMeta)
				ifFalse: [self error: 'Method modification not allowed']]
		ifFalse: [
			(self theNonMetaClass isOkToAddMethod: selector isMeta: self isMeta)
				ifFalse: [self error: 'Method addition not allowed']].
	logSource ifTrue: [
		"Re-fetching source code may be needed if, for example, some variable declaration was corrected during compilation."
		updatedCode := CodeProvider normalizeCodeForSaving: (requestor ifNil: [code] ifNotNil: [requestor text]) in: self.
		self logMethodSource: updatedCode forMethodWithNode: methodAndNode 
			inCategory: category withStamp: changeStamp libraryName: aStringOrNil
			notifying: requestor.
	].
	self addAndClassifySelector: selector withMethod: methodAndNode 
		method inProtocol: category methodTimeStamp: changeStamp notifying: requestor.
	^ methodAndNode selector! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/26/2025 15:09:02'!
                 printCategoryChunk: category on: aFileStream withStamp: changeStamp libraryName: aStringOrNil priorMethod: priorMethod
	"Print a method category preamble.  This must have a category name.
	It may have an author/date stamp, and it may have a prior source link.
	If it has a prior source link, it MUST have a stamp, even if it is empty."

"The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."

	aFileStream newLine; nextPut: $!!.
	aFileStream nextChunkPut: (String streamContents: [ :strm |
		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.
		aStringOrNil ifNotNil: [
			strm nextPutAll: ' library: '; print: aStringOrNil ].
		(changeStamp notNil and: [
			changeStamp notEmpty or: [priorMethod notNil]]) ifTrue: [
			strm nextPutAll: ' stamp: '; print: changeStamp].
		priorMethod notNil ifTrue: [
			strm nextPutAll: ' prior: '; print: priorMethod sourcePointer].
		]).! !
!ClassDescription methodsFor: 'private' stamp: 'jmv 8/25/2025 17:18:31'!
                 logMethodSource: code forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp libraryName: aStringOrNil notifying: requestor
	| priorMethodOrNil |

	priorMethodOrNil := self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: nil.

	aCompiledMethodWithNode method
		putSource: code
		fromParseNode: aCompiledMethodWithNode node
		class: self
		category: category
		withStamp: changeStamp
		libraryName: aStringOrNil
		inFile: 2
		priorMethod: priorMethodOrNil.! !
!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 8/25/2025 17:04:27'!
                  putSource: sourceStr fromParseNode: methodNode class: class category: catName
	withStamp: changeStamp libraryName: aStringOrNil inFile: fileIndex priorMethod: priorMethod

	^ self putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: [ :file |
			class
				printCategoryChunk: catName
				on: file
				withStamp: changeStamp
				libraryName: aStringOrNil
				priorMethod: priorMethod.
			file newLine ]! !
!ClassDescription methodsFor: 'compiling' stamp: 'jmv 8/26/2025 15:12:30' prior: 16819431!
                      compile: text classified: category withStamp: changeStamp notifying: requestor

	^ self compile: text classified: category withStamp: changeStamp libraryName: nil notifying: requestor logSource: self acceptsLoggingOfCompilation! !
!ClassDescription methodsFor: 'compiling' stamp: 'jmv 8/26/2025 15:12:41' prior: 16819506!
                              compileSilently: code classified: category notifying: requestor
	"Compile the code and classify the resulting method in the given category, leaving no trail in the system log, nor in any change set, nor in the 'recent submissions' list. This should only be used when you know for sure that the compilation will succeed."

	^ SystemChangeNotifier uniqueInstance 
		doSilently: [self compile: code classified: category withStamp: nil libraryName: nil notifying: requestor logSource: false].! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/26/2025 15:10:35' prior: 50361781!
                        reformatMethodAt: selector
	| newCodeString method | 
	newCodeString := self compilerClass new
		format: (self sourceCodeAt: selector)
		in: self
		notifying: nil.
	method := self compiledMethodAt: selector.
	method
		putSource: newCodeString
		fromParseNode: nil
		class: self
		category: (self organization categoryOfElement: selector)
		withStamp: Utilities changeStamp
		libraryName: nil
		inFile: 2
		priorMethod: method.! !

CompiledMethod removeSelector: #putSource:fromParseNode:class:category:withStamp:inFile:priorMethod:!

!methodRemoval: CompiledMethod #putSource:fromParseNode:class:category:withStamp:inFile:priorMethod: stamp: 'Install-7440-MethodPreamble-write-library-ifProvided-JuanVuletich-2025Aug26-15h07m-jmv.001.cs.st 8/29/2025 15:07:09'!
putSource: sourceStr fromParseNode: methodNode class: class category: catName
	withStamp: changeStamp inFile: fileIndex priorMethod: priorMethod

	^ self putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: [ :file |
			class
				printCategoryChunk: catName
				on: file
				withStamp: changeStamp
				priorMethod: priorMethod.
			file newLine ]!

ClassDescription removeSelector: #compile:classified:withStamp:notifying:logSource:!

!methodRemoval: ClassDescription #compile:classified:withStamp:notifying:logSource: stamp: 'Install-7440-MethodPreamble-write-library-ifProvided-JuanVuletich-2025Aug26-15h07m-jmv.001.cs.st 8/29/2025 15:07:09'!
compile: code classified: category withStamp: changeStamp notifying: requestor logSource: logSource
	
	| methodAndNode selector isExistingMethod updatedCode |	
	methodAndNode := self basicCompile: code notifying: requestor 
							trailer: self defaultMethodTrailer ifFail: [^nil].
	selector := methodAndNode selector.
	isExistingMethod := self includesSelector: selector.
	isExistingMethod
		ifTrue: [
			(self theNonMetaClass isOkToChangeMethod: selector isMeta: self isMeta)
				ifFalse: [self error: 'Method modification not allowed']]
		ifFalse: [
			(self theNonMetaClass isOkToAddMethod: selector isMeta: self isMeta)
				ifFalse: [self error: 'Method addition not allowed']].
	logSource ifTrue: [
		"Re-fetching source code may be needed if, for example, some variable declaration was corrected during compilation."
		updatedCode := CodeProvider normalizeCodeForSaving: (requestor ifNil: [code] ifNotNil: [requestor text]) in: self.
		self logMethodSource: updatedCode forMethodWithNode: methodAndNode 
			inCategory: category withStamp: changeStamp notifying: requestor.
	].
	self addAndClassifySelector: selector withMethod: methodAndNode 
		method inProtocol: category methodTimeStamp: changeStamp notifying: requestor.
	^ methodAndNode selector!

ClassDescription removeSelector: #printCategoryChunk:on:withStamp:priorMethod:!

!methodRemoval: ClassDescription #printCategoryChunk:on:withStamp:priorMethod: stamp: 'Install-7440-MethodPreamble-write-library-ifProvided-JuanVuletich-2025Aug26-15h07m-jmv.001.cs.st 8/29/2025 15:07:09'!
printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod
	"Print a method category preamble.  This must have a category name.
	It may have an author/date stamp, and it may have a prior source link.
	If it has a prior source link, it MUST have a stamp, even if it is empty."

"The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."

	aFileStream newLine; nextPut: $!!.
	aFileStream nextChunkPut: (String streamContents: [ :strm |
		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.
		(changeStamp notNil and: [
			changeStamp notEmpty or: [priorMethod notNil]]) ifTrue: [
			strm nextPutAll: ' stamp: '; print: changeStamp].
		priorMethod notNil ifTrue: [
			strm nextPutAll: ' prior: '; print: priorMethod sourcePointer].
		]).
!

ClassDescription removeSelector: #logMethodSource:forMethodWithNode:inCategory:withStamp:notifying:!

!methodRemoval: ClassDescription #logMethodSource:forMethodWithNode:inCategory:withStamp:notifying: stamp: 'Install-7440-MethodPreamble-write-library-ifProvided-JuanVuletich-2025Aug26-15h07m-jmv.001.cs.st 8/29/2025 15:07:09'!
logMethodSource: code forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor
	| priorMethodOrNil |

	priorMethodOrNil := self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: nil.

	aCompiledMethodWithNode method
		putSource: code
		fromParseNode: aCompiledMethodWithNode node
		class: self 
		category: category 
		withStamp: changeStamp 
		inFile: 2 
		priorMethod: priorMethodOrNil.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7440-MethodPreamble-write-library-ifProvided-JuanVuletich-2025Aug26-15h07m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7440] on 26 August 2025 at 3:29:58 pm'!

Object subclass: #ClassCategoryReader
	instanceVariableNames: 'class category changeStamp libraryName '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Classes'!

!classDefinition: #ClassCategoryReader category: #'Kernel-Classes' stamp: 'Install-7441-FileIn-readAndApply-library-keyword-JuanVuletich-2025Aug26-15h26m-jmv.001.cs.st 8/29/2025 15:07:09'!
Object subclass: #ClassCategoryReader
	instanceVariableNames: 'class category changeStamp libraryName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Classes'!
!ClassCategoryReader methodsFor: 'private' stamp: 'jmv 8/21/2025 15:10:58'!
              setClass: aClass category: aCategory changeStamp: aString libraryName: aStringOrNil

	class := aClass.
	category := aCategory.
	changeStamp := aString.
	libraryName := aStringOrNil.! !
!ClassDescription methodsFor: 'compiling' stamp: 'jmv 8/21/2025 15:05:51'!
                            compile: text classified: category withStamp: changeStamp libraryName: aStringOrNil notifying: requestor
	^ self compile: text classified: category withStamp: changeStamp libraryName: aStringOrNil notifying: requestor logSource: self acceptsLoggingOfCompilation! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/21/2025 12:46:52'!
           methodsFor: categoryName library: libraryName stamp: changeStamp
	"May appear in method preambles in chunk files. Therefore may be called during #fileIn.
	See #methods, #methodsFor:*, scanCategory:*"

	^ self methodsFor: categoryName library: libraryName stamp: changeStamp prior: 0! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/25/2025 16:51:26'!
                      methodsFor: categoryName library: libraryName stamp: changeStamp prior: indexAndOffset
	"May appear in method preambles in chunk files. Therefore may be called during #fileIn.
	See #methods, #methodsFor:*, scanCategory:*
	Prior source link ignored when filing in."

	^ ClassCategoryReader new
			setClass: self
			category: categoryName asSymbol
			changeStamp: changeStamp
			libraryName: libraryName

"Most importantly, return the new ClassCategoryReader, so a fileIn will let it seize control.  So method will be placed in the proper category.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"! !
!ClassCategoryReader methodsFor: 'fileIn/Out' stamp: 'jmv 8/21/2025 15:12:14' prior: 16818021!
                scanFrom: aStream
	"File in methods from the stream, aStream.
	Convert line endings to Cuis convention."
	| methodSource |
	[
		methodSource := aStream nextChunk withCuisLineEndings.
		methodSource size > 0 ] whileTrue: [
			class
				compile: methodSource
				classified: category
				withStamp: changeStamp
				libraryName: libraryName
				notifying: nil ]! !
!ChangeRecord methodsFor: 'initialization' stamp: 'jmv 8/21/2025 15:06:36' prior: 16806170!
                          fileIn
	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it."
	| s |
	type == #method ifTrue: [
		self changeClass ifNotNil: [ :methodClass |
			methodClass
				compile: self text
				classified: category
				withStamp: stamp
				libraryName: libraryName
				notifying: nil ]].
	self isDoIt ifTrue: [
		((s := self string) beginsWith: '----') ifFalse: [ Compiler evaluate: s ]].
	type == #classDefinition ifTrue: [ Compiler evaluate: self string ].
	type == #classComment ifTrue: [
		(Smalltalk at: class)
			comment: self text
			stamp: stamp ]! !

Object subclass: #ClassCategoryReader
	instanceVariableNames: 'class category changeStamp libraryName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Classes'!

!classDefinition: #ClassCategoryReader category: #'Kernel-Classes' stamp: 'Install-7441-FileIn-readAndApply-library-keyword-JuanVuletich-2025Aug26-15h26m-jmv.001.cs.st 8/29/2025 15:07:09'!
Object subclass: #ClassCategoryReader
	instanceVariableNames: 'class category changeStamp libraryName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Kernel-Classes'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7441-FileIn-readAndApply-library-keyword-JuanVuletich-2025Aug26-15h26m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7441] on 26 August 2025 at 5:47:06 pm'!
!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'jmv 8/26/2025 17:40:50'!
                              addAndClassifySelector: selector withMethod: compiledMethod inCategory: category methodTimeStamp: aTimeStampString notifying: requestor
	| priorMethodOrNil priorCategoryOrNil |
	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: nil.
	priorCategoryOrNil := self whichCategoryIncludesSelector: selector.
	self addSelectorSilently: selector withMethod: compiledMethod.
	SystemChangeNotifier uniqueInstance doSilently: [self organization classify: selector under: category].
	priorMethodOrNil
		ifNil: [
			SystemChangeNotifier uniqueInstance 
				methodAdded: compiledMethod
				selector: selector
				inProtocol: category
				class: self
				methodTimeStamp: aTimeStampString
				requestor: requestor ]
		ifNotNil: [
			SystemChangeNotifier uniqueInstance 
				methodChangedFrom: priorMethodOrNil 
				to: compiledMethod 
				selector: selector 
				inClass: self 
				requestor: requestor.
			category = priorCategoryOrNil ifFalse: [
				SystemChangeNotifier uniqueInstance
					selectorRecategorized: selector
					from: priorCategoryOrNil
					to: category
					inClass: self ]].! !
!ChangeList methodsFor: 'scanning' stamp: 'jmv 8/26/2025 17:31:03' prior: 50361264!
    classDefinitionRecordFrom: tokens
	| classDefinition isMeta itemPosition className record fullClassName category stamp |
	
	itemPosition := file position.
	fullClassName := tokens second.
	isMeta := fullClassName includesSubString: ' class'.
	className := isMeta ifTrue: [fullClassName substrings first] ifFalse: [fullClassName].
	category := CompiledMethod classCategoryFrom: tokens.
	stamp := CompiledMethod stampFrom: tokens.
	classDefinition := file nextChunk.
	
	record := ChangeRecord new
		file: file
		position: itemPosition
		type: #classDefinition
		class: className asSymbol
		category: category
		meta: isMeta
		stamp: stamp.
	
	^record
! !
!VersionsBrowser methodsFor: 'init & update' stamp: 'jmv 8/26/2025 17:28:58' prior: 17014211!
                     scanVersionsOf: method class: class meta: meta category: category selector: selector
	| position stamp priorMethodRef prevPos prevFileIndex libraryName preamble tokens sourceFilesCopy |
	selectorOfMethod := selector.
	currentCompiledMethod := method.
	classOfMethod := meta ifTrue: [class class] ifFalse: [class].
	changeList := OrderedCollection new.
	list := OrderedCollection new.
	addedChangeRecord ifNotNil: [ :change |
		self addItem: change text: ('{1} (in {2})' format: { change stamp. change fileName }) ].
	listIndex := 0.
	position := method filePosition.
	sourceFilesCopy := SourceFiles collect:
		[:x | x ifNotNil: [ x name asFullFileEntry readStream ]].
	method fileIndex = 0 ifTrue: [^ nil].
	file := sourceFilesCopy at: method fileIndex.
	[position notNil & file notNil] whileTrue: [
		"Skip back filler"
		file position: position.
		file backChunk.
		"Get preamble"
		preamble := file backChunk.
		"Preamble is likely a linked method preamble, if we're in
			a changes file (not the sources file).  Try to parse it
			for prior source position and file index"
		prevFileIndex := nil.
		prevPos := nil.
		stamp := ''.
		(preamble includesSubString: 'methodsFor:')
			ifTrue: [
				tokens := Scanner new scanTokens: preamble.
				stamp := CompiledMethod stampFrom: tokens.
				priorMethodRef := CompiledMethod priorReferenceFrom: tokens.
				priorMethodRef ifNotNil: [
					prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: priorMethodRef.
					prevPos := sourceFilesCopy filePositionFromSourcePointer: priorMethodRef ].
				libraryName := CompiledMethod libraryNameFrom: tokens ].
 		self addItem:
				(ChangeRecord new
					file: file position: position type: #method
					class: class name category: category meta: meta stamp: stamp 
					prior: priorMethodRef libraryName: libraryName)
			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.
		position := prevPos.
		prevPos notNil ifTrue: [
			file := sourceFilesCopy at: prevFileIndex]].
	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].
	self clearSelections! !
!Behavior methodsFor: 'compiling' stamp: 'jmv 8/26/2025 16:41:14' prior: 16788097!
        compile: code notifying: requestor 
	"Compile the argument, code, as source code in the context of the 
	receiver and install the result in the receiver's method dictionary. The 
	second argument, requestor, is to be notified if an error occurs. The 
	argument code is either a string or an object that converts to a string or 
	a PositionableStream. This method also saves the source code."
	
	| methodAndNode sel compiled updatedCode |
	methodAndNode := self
		basicCompile: code
		notifying: requestor
		trailer: self defaultMethodTrailer
		ifFail: [^nil].
	sel := methodAndNode selector.
	compiled := methodAndNode method.
	(self includesSelector: sel) ifTrue: [
		((self compiledMethodAt: sel) propertyValueAt: #libraryName) ifNotNil: [ :libName |
			compiled propertyValueAt: #libraryName put: libName ]].
	"Re-fetching source code may be needed if, for example, some variable declaration was corrected during compilation."
	updatedCode := CodeProvider normalizeCodeForSaving: (requestor ifNil: [code] ifNotNil: [requestor text]) in: self.
	compiled putSource: updatedCode fromParseNode: methodAndNode node inFile: 2
			withPreamble: [ :f | f newLine; nextPut: $!!; nextChunkPut: 'Behavior method'; newLine].
	self addSelectorSilently: sel withMethod: compiled.
	^ methodAndNode selector! !
!Behavior methodsFor: 'compiling' stamp: 'jmv 8/26/2025 16:36:58' prior: 16788196!
                            recompile: selector from: oldClass
	"Compile the method associated with selector in the receiver's method dictionary."
	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"
	| method trailer methodNode compiled |
	method := oldClass compiledMethodAt: selector.
	trailer := method trailer.
	methodNode := self compilerClass new
				compile: (oldClass sourceCodeAt: selector)
				in: self
				notifying: nil
				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"
	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].
	compiled := methodNode generate: trailer.
	(method propertyValueAt: #libraryName) ifNotNil: [ :libName |
		compiled propertyValueAt: #libraryName put: libName ].
	self addSelectorSilently: selector withMethod: compiled.
! !
!ClassDescription methodsFor: 'compiling' stamp: 'jmv 8/26/2025 17:32:13' prior: 50362163!
        compile: code classified: category withStamp: changeStamp libraryName: aStringOrNil notifying: requestor logSource: logSource
	
	| methodAndNode selector newMethod isExistingMethod updatedCode libName |
	methodAndNode := self basicCompile: code notifying: requestor 
							trailer: self defaultMethodTrailer ifFail: [^nil].
	selector := methodAndNode selector.
	newMethod := methodAndNode method.
	libName := aStringOrNil.
	isExistingMethod := self includesSelector: selector.
	isExistingMethod
		ifTrue: [
			(self theNonMetaClass isOkToChangeMethod: selector isMeta: self isMeta)
				ifFalse: [self error: 'Method modification not allowed'].
			"If libraryName is provided, it takes precedence. If not, assume it doesn't change."
			libName isNil ifTrue: [ libName := (self compiledMethodAt: selector) propertyValueAt: #libraryName ]]
		ifFalse: [
			(self theNonMetaClass isOkToAddMethod: selector isMeta: self isMeta)
				ifFalse: [self error: 'Method addition not allowed']].
	libName ifNotNil: [ newMethod propertyValueAt: #libraryName put: libName ].
	logSource ifTrue: [
		"Re-fetching source code may be needed if, for example, some variable declaration was corrected during compilation."
		updatedCode := CodeProvider normalizeCodeForSaving: (requestor ifNil: [code] ifNotNil: [requestor text]) in: self.
		self logMethodSource: updatedCode forMethodWithNode: methodAndNode 
			inCategory: category withStamp: changeStamp libraryName: libName
			notifying: requestor.
	].
	self addAndClassifySelector: selector withMethod: newMethod
		inCategory: category methodTimeStamp: changeStamp notifying: requestor.
	^ selector! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/26/2025 16:01:40' prior: 50362309!
   reformatMethodAt: selector
	| newCodeString method | 
	newCodeString := self compilerClass new
		format: (self sourceCodeAt: selector)
		in: self
		notifying: nil.
	method := self compiledMethodAt: selector.
	method
		putSource: newCodeString
		fromParseNode: nil
		class: self
		category: (self organization categoryOfElement: selector)
		withStamp: Utilities changeStamp
		libraryName: (method propertyValueAt: #libraryName)
		inFile: 2
		priorMethod: method.! !
!Decompiler class methodsFor: 'testing' stamp: 'jmv 8/26/2025 16:35:37' prior: 16847666!
                      recompileAllTest
	"[Decompiler recompileAllTest]"
	"decompile every method and compile it back; if the decompiler is correct then the system should keep running.  :)"
	
	Smalltalk allBehaviorsDo: [ :behavior |
		Utilities informUser: (behavior printString) during: [
			behavior selectors do: [ :sel |
				| existingMethod decompiled ast compiled |
				decompiled := Decompiler new decompile: sel in: behavior.
				ast := Compiler new compile: decompiled in: behavior notifying: nil ifFail: [ self error: 'failed' ].
				existingMethod := behavior compiledMethodAt: sel.
				compiled := ast generate: existingMethod trailer.
				(existingMethod propertyValueAt: #libraryName) ifNotNil: [ :libName |
					compiled propertyValueAt: #libraryName put: libName ].
				behavior addSelectorSilently: sel withMethod: compiled. ] ] ]! !

ClassDescription removeSelector: #addAndClassifySelector:withMethod:inProtocol:methodTimeStamp:notifying:!

!methodRemoval: ClassDescription #addAndClassifySelector:withMethod:inProtocol:methodTimeStamp:notifying: stamp: 'Install-7442-Set-libraryName-JuanVuletich-2025Aug26-17h39m-jmv.001.cs.st 8/29/2025 15:07:09'!
addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category methodTimeStamp: aTimeStampString notifying: requestor
	| priorMethodOrNil priorProtocolOrNil |
	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: nil.
	priorProtocolOrNil := self whichCategoryIncludesSelector: selector.
	self addSelectorSilently: selector withMethod: compiledMethod.
	SystemChangeNotifier uniqueInstance doSilently: [self organization classify: selector under: category].
	priorMethodOrNil
		ifNil: [
			SystemChangeNotifier uniqueInstance 
				methodAdded: compiledMethod
				selector: selector
				inProtocol: category
				class: self
				methodTimeStamp: aTimeStampString
				requestor: requestor ]
		ifNotNil: [
			SystemChangeNotifier uniqueInstance 
				methodChangedFrom: priorMethodOrNil 
				to: compiledMethod 
				selector: selector 
				inClass: self 
				requestor: requestor.
			category = priorProtocolOrNil ifFalse: [
				SystemChangeNotifier uniqueInstance
					selectorRecategorized: selector
					from: priorProtocolOrNil
					to: category
					inClass: self ]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7442-Set-libraryName-JuanVuletich-2025Aug26-17h39m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7442] on 27 August 2025 at 10:15:01 am'!
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/27/2025 09:58:55' prior: 16820157!
                               printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex
	"Copy the source code for the method associated with selector onto the fileStream.
	If moveSource true, then also set the source code pointer of the method."

	| compiledMethod oldPos newPos sourceFile endPos methodCode codeStyler |
	compiledMethod := self methodDict at: selector ifAbsent: [
		outStream nextPutAll: selector; newLine.
		outStream tab; nextPutAll: '** ERROR  -  THIS METHOD IS MISSING ** '; newLine; newLine.
		outStream nextPutAll: '  '.
		^ outStream].

	doPreamble ifTrue: [
		self
			printCategoryChunk: (self organization categoryOfElement: selector)
			on: outStream
			withStamp: compiledMethod timeStamp
			libraryName: (compiledMethod propertyValueAt: #libraryName)
			priorMethod: nil.
		outStream newLine ].

	((compiledMethod fileIndex = 0
		or: [(SourceFiles at: compiledMethod fileIndex) == nil])
		or: [(oldPos := compiledMethod filePosition) = 0])
			ifTrue: [
				"The source code is not accessible.  We must decompile..."
				outStream nextChunkPut: compiledMethod decompileString]
			ifFalse: [
				sourceFile := SourceFiles at: compiledMethod fileIndex.
				sourceFile position: oldPos.
				"Copy the method chunk"
				fileIndex = 0 ifFalse: [
					outStream padTo: SourceFiles pointerScaleForWriting put: $  ].
				newPos := outStream position.
				"Copy method chunk"
				methodCode := sourceFile nextChunk.
				(methodCode isEmpty or: [ methodCode isSeparators ]) ifTrue: [
					"This is very unlikely, but possible source file is corrupted."
					methodCode := compiledMethod decompileString ].
				"Convert method code to use ANSI assignments"
				(Preferences at: #fileOutANSIassignment) ifTrue: [
					codeStyler := SHTextStylerST80 new.
					codeStyler classOrMetaClass: compiledMethod methodClass.
					codeStyler instVarNamed: 'formattedText' put: methodCode asText.
					codeStyler getReady.
					codeStyler parseText.
					codeStyler replaceStringForRangesWithType: #assignment with: ':=' offset: 0.
					methodCode := codeStyler convertedAndStyledText string ].
				outStream nextChunkPut: methodCode.
				moveSource ifTrue: [    "Set the new method source pointer"
					endPos := outStream position.
					compiledMethod checkOKToAdd: endPos - newPos at: newPos in: compiledMethod fileIndex.
					compiledMethod setSourcePosition: newPos inFile: fileIndex]].
	doPreamble ifTrue: [ outStream nextChunkPut: ' ' ].
	outStream newLine.! !

PositionableStream removeSelector: #copyPreamble:oldPreamble:!

!methodRemoval: PositionableStream #copyPreamble:oldPreamble: stamp: 'Install-7443-MethodFileout-preambleWrite-writeLibraryName-JuanVuletich-2025Aug27-10h12m-jmv.001.cs.st 8/29/2025 15:07:09'!
copyPreamble: preamble oldPreamble: oldPreamble
	"Look for a changeStamp for this method.
	Write a method preamble, with that stamp if found."
	| terminator stamp i |
	terminator := $!!.

	"Look back to find stamp in old preamble, such as...
	Polygon methodsFor: 'private' stamp: 'di 6/25/97 21:42' prior: 34957598!! "
	stamp := String new.
	(i := oldPreamble 
		findLastOccurrenceOfString: 'stamp:'
		startingAt: 1) > 0 ifTrue: 
		[ stamp := (oldPreamble 
			copyFrom: i + 8
			to: oldPreamble size) copyUpTo: $' ].

	"Write the new preamble, with old stamp if any."
	self
		newLine;
		nextPut: terminator.
	self nextChunkPut: (String streamContents: 
			[ :strm | 
			strm nextPutAll: preamble.
			stamp size > 0 ifTrue: 
				[ strm
					nextPutAll: ' stamp: ';
					print: stamp ] ]).
	self newLine!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7443-MethodFileout-preambleWrite-writeLibraryName-JuanVuletich-2025Aug27-10h12m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7443] on 27 August 2025 at 11:09:29 am'!
!ChangeList methodsFor: 'scanning' stamp: 'jmv 8/27/2025 10:54:18' prior: 50362060!
      scanCategory: category class: class meta: meta stamp: stamp prior: priorVersionPosition libraryName: libNameOrNil
	"Read methods following a method category preamble in a chunk file.
	See #methods, #methodsFor:*, scanCategory:*"

	| itemPosition method |
	[
		itemPosition := file position.
		method := file nextChunk.
		method notEmpty ] whileTrue: [ "done when double terminators"
			self
				addItem: (ChangeRecord new
					file: file 
					position: itemPosition 
					type: #method
					class: class 
					category: category 
					meta: meta 
					stamp: stamp
					prior: priorVersionPosition
					libraryName: libNameOrNil)
				text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])
					, (((Smalltalk at: class ifAbsent: [Object class]) parserClass selectorFrom: method) ifNil: [''])
					, (libNameOrNil ifNil: [''] ifNotNil: [' - library[', libNameOrNil, ']'])
					, (stamp isEmpty ifTrue: [''] ifFalse: [' - ' , stamp])].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7444-ChangesList-show-libraryName-JuanVuletich-2025Aug27-11h09m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7443] on 27 August 2025 at 11:09:55 am'!
!ChangeRecord methodsFor: 'accessing' stamp: 'jmv 8/27/2025 11:07:10' prior: 16806047!
                             fileOutOn: aFileStream
	"File the receiver out on the given file stream"

	type == #method
		ifTrue: [
			self changeClass printCategoryChunk: category on: aFileStream
				withStamp: stamp libraryName: libraryName priorMethod: nil.
			aFileStream newLine ].

	type == #preamble ifTrue: [ aFileStream nextPut: $!! ].

	type == #classComment
		ifTrue: [
			aFileStream nextPut: $!!.
			aFileStream nextChunkPut: class asString, ' commentStamp: ', stamp storeString.
			aFileStream newLine ].
		
	type == #classDefinition ifTrue: [
		aFileStream nextPut: $!!.
		aFileStream nextChunkPut: 
			'classDefinition: ', 
			(self isMetaClassChange ifTrue: [self changeClassName, ' class'] ifFalse: [self changeClassName]) printString,
			' category: ', self category printString.
		aFileStream newLine ].

	aFileStream nextChunkPut: self string.
	
	type == #method ifTrue: [ aFileStream nextChunkPut: ' '; newLine ].
	type == #classComment ifTrue: [ aFileStream newLine ].
	aFileStream newLine.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7445-ChangesList-fileOut-libraryName-JuanVuletich-2025Aug27-11h09m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7450] on 27 August 2025 at 11:54:31 am'!
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 8/27/2025 11:49:06' prior: 50346169!
                     annotationForSelector: aSelector ofClass: aClass
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	| method |
	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	method := aClass compiledMethodAt: aSelector ifAbsent: nil.
	^ String streamContents: [ :strm |
		(Preferences at: #methodAnnotations)
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp := self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						method notNil ifTrue: [
							strm
								print: method linesOfCode;
								nextPutAll: ' lines of code' ]].
					[#messageSendsCount] -> [
						method notNil ifTrue: [
							strm
								print: method messageSendsCount;
								nextPutAll: ' message sends' ]].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount := Smalltalk numberOfSendersOf: aSelector.
						sendersCount := sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount := Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount := implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp := VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						method notNil ifTrue: [
							(CodePackage packageOfMethod: method methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#library] -> [
						method notNil ifTrue: [
							(method propertyValueAt: #libraryName)
								ifNil: [ strm nextPutAll: 'in no library' ]
								ifNotNil: [ :libraryName |
									strm nextPutAll: 'in library '; nextPutAll: libraryName ]]].
					[#changeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList := ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList := (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ].
		(method notNil and: [method hasBreakpoint]) ifTrue: [
			strm nextPutAll: self annotationSeparator.
			strm nextPutAll: '[Breakpoint]' ]
	].! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 8/27/2025 11:52:49' prior: 16827091!
  buildMorphicAnnotationsPane

	| aTextMorph |
	aTextMorph := (TextModelMorph
		textProvider: model
		textGetter: #annotation) emptyTextDisplayMessage: 'Class or method annotation'.
	aTextMorph disableEditing.
	model when: #annotationChanged send: #refetch to: aTextMorph model.
	model when: #decorateButtons send: #decorateButtons to: self.
	aTextMorph
		askBeforeDiscardingEdits: false;
		hideScrollBarsIndefinitely.
	^aTextMorph! !
!PreferenceSet class methodsFor: 'sys data' stamp: 'jmv 8/27/2025 11:47:48' prior: 50343493!
                  prefProgramming
	^ #(
		#(atMinusDigitMeaning st80 #(st80 ansiSmalltalk disabled) )
		#(allowBlockArgumentAssignment false )
		#(allowNonBooleanReceiversOfBooleanMessages false )
		#(alternativeBrowseIt false )
		#(browseWithPrettyPrint false )
		#(debugHaloHandle true )
		#(debugLogTimestamp true )
		#(debugShowDamage false )
		#(decorateBrowserButtons true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(extraDebuggerButtons true )
		#(fullPrintItInWorkspaces false )
		#(highlightBlockNesting true )
		#(italicsInShout true)
		#(listClassesHierarchically true )
		#(logDebuggerStackToFile false )
		#(prettyPrintRectangularBlocks false )
		#(shiftClickShowsImplementors false )
		#(shoutInWorkspaces true )
		#(showAnnotations true )
		#(showLinesInHierarchyViews true )
		#(stylingWithEmphasisInWorkspaces false )
		#(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount "linesOfCode" messageSendsCount) )
		#(classAnnotations #(instanceMethodsCount classMethodsCount "linesOfCode" messageSendsCount) )
		#(messageCategoryAnnotations #(messagesCount messageSendsCount) )
		#(methodAnnotations #(timeStamp "linesOfCode" messageSendsCount messageCategory implementorsCount sendersCount packages library changeSets) )	
		#(syntaxHighlightingAsYouType true )
		#(showAssignmentAsLeftArrow false )
		#(usePreDebugWindow false)
		#(clearPackagePathsOnImageMove true)
	)! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Preferences at: #methodAnnotations put: #(timeStamp "linesOfCode" messageSendsCount messageCategory implementorsCount sendersCount packages library changeSets)!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7446-MethodAnnotations-show-library-JuanVuletich-2025Aug27-11h12m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7447] on 27 August 2025 at 10:43:09 am'!
!FileList methodsFor: 'user interface support' stamp: 'jmv 8/27/2025 10:34:18'!
                       doItContext
	^ nil! !
!FileList methodsFor: 'user interface support' stamp: 'jmv 8/27/2025 10:32:36'!
                          doItReceiver
	^ nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7447-AllowCodeEvaluationInFileList-JuanVuletich-2025Aug27-10h40m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7444] on 27 August 2025 at 10:25:03 am'!

MethodChangeRecord removeSelector: #performOn:!

!methodRemoval: MethodChangeRecord #performOn: stamp: 'Install-7448-MethodChangeRecord-cleanup-JuanVuletich-2025Aug27-10h18m-jmv.001.cs.st 8/29/2025 15:07:09'!
performOn: aCodeFile

	 ^aCodeFile perform: (self changeType copyWith: $:) asSymbol with: self !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7448-MethodChangeRecord-cleanup-JuanVuletich-2025Aug27-10h18m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7443] on 27 August 2025 at 10:39:29 am'!

MethodReference removeSelector: #updateReferencesTo:toBe:!

!methodRemoval: MethodReference #updateReferencesTo:toBe: stamp: 'Install-7449-Cleanup-JuanVuletich-2025Aug27-10h39m-jmv.001.cs.st 8/29/2025 15:07:09'!
updateReferencesTo: oldClassName toBe: newClassName

	| src ts cm |
	src := self actualClass sourceCodeAt: methodSymbol.
	src := src copyReplaceAll: oldClassName with: newClassName.
	cm := self actualClass compiledMethodAt: methodSymbol.
	ts := cm timeStamp.
	ts = '' ifTrue: [ts := nil].
	self actualClass 
		compile: src
		classified: ClassOrganizer defaultMethodCategory
		withStamp: ts 
		notifying: nil.

	^true
!

SystemDictionary removeSelector: #renameAndUpdateReferences:as:!

!methodRemoval: SystemDictionary #renameAndUpdateReferences:as: stamp: 'Install-7449-Cleanup-JuanVuletich-2025Aug27-10h39m-jmv.001.cs.st 8/29/2025 15:07:09'!
renameAndUpdateReferences: oldName as: newName
	"Dangerous. Simple search and replace could break stuff.
	Use only to generate change sets to later checked with care
	
OldMorph withAllSubclasses do: [ :c |
	n := c name.
	(n beginsWith: 'Old') ifTrue: [
		Smalltalk renameAndUpdateReferences: n as: (n copyFrom: 4 to: n size) asSymbol ]]

OldBorderStyle withAllSubclasses do: [ :c |
	n := c name.
	(n beginsWith: 'Old') ifTrue: [
		Smalltalk renameAndUpdateReferences: n as: (n copyFrom: 4 to: n size) asSymbol ]]

#(#OldKeyboardBuffer #OldLayoutCell #OldLayoutFrame #OldLayoutPolicy #OldLayoutProperties #OldMorphExtension #OldMouseClickState #OldProportionalLayout #OldTableLayout #OldTableLayoutProperties #OldTextAnchor #OldTextComposer #OldTextContainer #OldTextLine #OldTheWorldMenu #OldWorldState #OldWorldTest) do: [ :n |
	Smalltalk renameAndUpdateReferences: n as: (n copyFrom: 4 to: n size) asSymbol ]
	"

	self renameClassNamed: oldName as: newName.
	(self allCallsOn: (self associationAt: newName)) do: [ :methodRef |
		methodRef updateReferencesTo: oldName toBe: newName ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7449-Cleanup-JuanVuletich-2025Aug27-10h39m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7444] on 27 August 2025 at 10:27:15 am'!
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/27/2025 10:26:42' prior: 50362207!
                             printCategoryChunk: category on: aFileStream withStamp: changeStamp libraryName: aStringOrNil priorMethod: priorMethod
	"Print a method category preamble.  This must have a category name.
	It may have an author/date stamp, and it may have a prior source link.
	If it has a prior source link, it MUST have a stamp, even if it is empty.
	It may also have a libraryName."

	aFileStream newLine; nextPut: $!!.
	aFileStream nextChunkPut: (String streamContents: [ :strm |
		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.
		aStringOrNil ifNotNil: [
			strm nextPutAll: ' library: '; print: aStringOrNil ].
		(changeStamp notNil and: [
			changeStamp notEmpty or: [priorMethod notNil]]) ifTrue: [
			strm nextPutAll: ' stamp: '; print: changeStamp].
		priorMethod notNil ifTrue: [
			strm nextPutAll: ' prior: '; print: priorMethod sourcePointer].
		]).! !
!CompiledMethod methodsFor: 'source code management' stamp: 'jmv 8/27/2025 09:42:21' prior: 16835197!
    getPreamble
	| file preamble |
	self fileIndex = 0 ifTrue: [^ String new].  "no source pointer for this method"
	file := SourceFiles at: self fileIndex.
	file ifNil: [^ ''].  "sources file not available"
	"file does not exist happens in secure mode"
	[
		file name asFullFileEntry readStreamDo: [ :stream | | p |
			preamble := ''.
			p := 0 max: self filePosition.
			p < stream size ifTrue: [
				"It appears that on Linux systems, immediately after adding a
				new method, the OS file cache may not be updated, so contents
				may still not be accessible. Protect against that."
				stream position: p.
				"Skip back blank space."
				stream backChunk.
				"Find and answer preamble chunk."
				preamble := stream backChunk ]]
	] on: FileDoesNotExistException do: [ :ex | preamble := '' ].
	^ preamble! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7450-Cleanup-JuanVuletich-2025Aug27-10h25m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7450] on 27 August 2025 at 12:02:33 pm'!
!TemporaryVariableDeclarationRemover methodsFor: 'source text generation' stamp: 'jmv 8/27/2025 10:17:43' prior: 16984248!
                            sourceTextWithoutTemporaryDeclarationLineInBlockNode: aBlockNode
	
	| sourceTextUpToEndTemps endTempsMark startTempsMark |
	endTempsMark := aBlockNode tempsMark.
	sourceTextUpToEndTemps := methodNode sourceText copyFrom: 1 to: endTempsMark - 1.
	startTempsMark := sourceTextUpToEndTemps findLast: [ :c | c = $| ].
	^self sourceTextWithoutTemporaryDeclarationLineFrom: startTempsMark to: endTempsMark! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7451-Cleanup-JuanVuletich-2025Aug27-12h02m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7450] on 27 August 2025 at 12:04:24 pm'!
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'HAW 10/26/2019 12:44:32' prior: 16808539!
                        fileOutClassInitializationsOf: classList on: stream

	classList do: [ :aClass |
		self fileOutPSFor: aClass on: stream ]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'HAW 10/26/2019 12:42:26' prior: 16808643!
              fileOutMethodsChangesOf: stream on: classList

	classList do: [ :aClass | self fileOutMethodChangesFor: aClass on: stream ]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'HAW 10/26/2019 12:45:35' prior: 16808657!
           fileOutMovedClassesOn: stream

	self sortedMovedClassesToOtherPackage do: [ :aMovedClassRecord |
		self fileOutMovedClassRecord: aMovedClassRecord on: stream ]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'HAW 10/26/2019 12:43:33' prior: 16808739!
       fileOutRemovedAndMovedMethodsOf: classList on: stream

	classList reverseDo: [ :aClass |
		self fileOutMethodRemovalsFor: aClass on: stream.
		self fileOutMethodMovedToOtherPackagesFor: aClass on: stream ]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'HAW 10/26/2019 12:45:13' prior: 16808756!
                         fileOutRemovedClassesOn: stream

	self sortedRemovedClassRecords do: [ :aRemovedClassRecord | 
		self fileOutRemovedClassRecord: aRemovedClassRecord on: stream ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7452-Cleanup-JuanVuletich-2025Aug27-12h02m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7452] on 28 August 2025 at 1:19:51 pm'!
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 8/28/2025 13:16:26' prior: 50363498!
 printCategoryChunk: category on: aFileStream withStamp: changeStamp libraryName: aStringOrNil priorMethod: priorMethod
	"Print a method category preamble.  This must have a category name.
	It may have an author/date stamp, and it may have a prior source link.
	Always include a stamp, even if it is empty.
	It may also have a libraryName."

	aFileStream newLine; nextPut: $!!.
	aFileStream nextChunkPut: (String streamContents: [ :strm |
		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.
		aStringOrNil ifNotNil: [
			strm nextPutAll: ' library: '; print: aStringOrNil ].
		strm nextPutAll: ' stamp: '; print: (changeStamp ifNil: ['']).
		priorMethod notNil ifTrue: [
			strm nextPutAll: ' prior: '; print: priorMethod sourcePointer].
		]).! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7453-AlwaysInclude-stamp-onFileOuts-JuanVuletich-2025Aug28-13h19m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7453] on 28 August 2025 at 1:32:23 pm'!
!Behavior methodsFor: 'accessing method dictionary' stamp: 'jmv 8/28/2025 13:31:06' prior: 16788662!
                           recoverFromMDFaultWithTrace
	"Only used for ClassDescription."! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7454-Tweak-JuanVuletich-2025Aug28-13h32m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7452] on 28 August 2025 at 11:45:22 am'!
!ProtoObject methodsFor: 'testing' library: #MinimalKernel01 stamp: 'md 11/24/1999 19:26' prior: 16940329!
                      isNil
	"Coerces nil to true and everything else to false."

	^false! !
!ProtoObject methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 8/27/2009 13:23' prior: 16940334!
              notNil
	"Coerces nil to false and everything else to true."

	^true! !
!ProtoObject methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'md 11/24/1999 19:27' prior: 16940339!
            == anObject 
	"Primitive. Answer whether the receiver and the argument are the same 
	object (have the same object pointer). Do not redefine the message == in 
	any other class!! Essential. No Lookup. Do not override in any subclass. 
	See Object documentation whatIsAPrimitive."

	<primitive: 110>
	self primitiveFailed! !
!ProtoObject methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'md 11/24/1999 19:27' prior: 16940352!
               ~~ anObject
	"Answer whether the receiver and the argument are not the same object 
	(do not have the same object pointer)."

	self == anObject
		ifTrue: [^ false]
		ifFalse: [^ true]! !
!ProtoObject methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 1/4/2024 16:19:39' prior: 16940361!
                      identityHash
	"Answer a SmallInteger whose value is related to the receiver's identity.
	This method must not be overridden, except by immediate classes such as
	SmallInteger, Character and SmallFloat64.
	Primitive. Fails if the receiver is a SmallInteger. Essential.
	See Object documentation whatIsAPrimitive.

	Do not override."

	<primitive: 75>
	self primitiveFailed! !
!ProtoObject methodsFor: 'system primitives' library: #MinimalKernel01 stamp: 'jmv 4/29/2025 16:17:57' prior: 16940463!
                 become: otherObject 
	"Primitive. Swap the object pointers of the receiver and the argument.
	All variables in the entire system that used to point to the 
	receiver now point to the argument, and vice-versa.
	Fails if either object is a SmallInteger.
	This implementation is appropriate for minimal bootstrapped images.
	Regular images will automatically use the implementation in Object (if present)."

	{ self } elementsExchangeIdentityWith: { otherObject }! !
!ProtoObject methodsFor: 'system primitives' library: #MinimalKernel01 stamp: 'jmv 5/29/2025 09:15:37' prior: 16940481!
                        nextInstance
	"Answer the next instance after the receiver in the enumeration of all instances of this class.
	Fails if all instances have been enumerated.
	See Object>>#someInstance.

	#someInstance and #nextInstance are meant to be used together starting with #someInstance,
	and following with #nextInstance until nil.

	Warning: Until all the instances are iterated and nil is answered, the VM holds a strong reference
	to the last one retrieved, preventing collecting and finalization.
	Best practice is to always iterate until nil.

	Essential. See Object documentation whatIsAPrimitive."

	<primitive: 78>
	^nil! !
!ProtoObject methodsFor: 'initialization' library: #MinimalKernel01 stamp: 'md 11/18/2003 10:33' prior: 16940323!
initialize
	"Subclasses should redefine this method to perform initializations on instance creation"! !
!ProtoObject methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 5/15/2025 14:19:33' prior: 16940376!
         printOn: aStream
	"Append to the argument, aStream, a sequence of characters that  
	identifies the receiver.
	"
	self class isMeta
		ifFalse: [ aStream nextPutAll: 'an instance of ' ]
		ifTrue: [ aStream nextPutAll: 'class ' ].
	self class theNonMetaClass printNameOn: aStream.! !
!ProtoObject methodsFor: 'error handling' library: #MinimalKernel01 stamp: 'jmv 5/19/2025 18:24:23' prior: 16940388!
                 doesNotUnderstand: aMessage
	"
	Note: Subclasses of ProtoObject will redefine this message.
	This implementation will only be used when the Exception based one at Object is missing.
	This may happen in minimal bootstrapped images.
	"
	| exception context count |

	"Use the MEssageNotUnderstood exception if present"
	exception := Exception deepSubclassNamed: 'MessageNotUnderstood'.
	exception notNil ifTrue:
		[ ^ exception new 
			message: aMessage;
			receiver: self;
			signal ].

	"Or do the best we can in a bare bones system"
	StdIOWriteStream stdout flush.
	StdIOWriteStream stdout newLine;
		nextPutAll: 'Message not understood.'; newLine;
		nextPutAll: 'Receiver: '.
	self printOn: StdIOWriteStream stdout.
	StdIOWriteStream stdout
		nextPutAll: ' selector: #';
		nextPutAll: aMessage selector; newLine;
		nextPutAll: '------ Call Stack: '; newLine;
		flush.

	context := thisContext sender.
	count := 0.
	[context notNil and: [ count < 10 ]] whileTrue: [
		context printOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout newLine.
		context := context sender.
		count := count + 1 ].

	StdIOWriteStream stdout newLine;
		nextPutAll: 'Will exit now.';
		newLine;
		flush.

	Smalltalk quitPrimitive: 127.! !
!ProtoObject methodsFor: 'error handling' library: #MinimalKernel01 stamp: 'jmv 4/29/2025 16:46:57' prior: 16940429!
      error: aString 
	"
	Note: Subclasses of ProtoObject will redefine this message.
	This implementation will only be used when the Exception based one at Object is missing.
	This may happen in minimal bootstrapped images.
	"

	| context count |
	StdIOWriteStream stdout newLine;
		nextPutAll: 'Error: ';
		nextPutAll: aString; newLine;
		nextPutAll: '------ Call Stack: '; newLine;
		flush.

	context := thisContext sender.
	count := 0.
	[context notNil and: [ count < 10 ]] whileTrue: [
		context printOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout newLine.
		context := context sender.
		count := count + 1 ].

	StdIOWriteStream stdout newLine;
		nextPutAll: 'Will exit Cuis now.';
		newLine;
		flush.
	Smalltalk quitPrimitive: 128.! !
!ProtoObject methodsFor: 'error handling' library: #MinimalKernel01 stamp: 'jmv 4/29/2025 16:50:28' prior: 16940455!
    warning: aString
	"May be redefined."
	"
	7  warning: 'El totón!!'
	"
	StdIOWriteStream stdout
		nextPutAll: 'Warning: ';
		nextPutAll: aString; newLine;
		flush.! !
!Object methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'yo 6/29/2004 11:39' prior: 16921227!
                  at: index 
	"Primitive. Assumes receiver is indexable. Answer the value of an 
	indexable element in the receiver. Fail if the argument index is not an 
	Integer or is out of bounds. Essential. See Object documentation 
	whatIsAPrimitive."

	<primitive: 60>
	index isInteger ifTrue:
		[self class isVariable
			ifTrue: [self errorSubscriptBounds: index]
			ifFalse: [self errorNotIndexable]].
	index isNumber
		ifTrue: [^self at: index asInteger]
		ifFalse: [self errorNonIntegerIndex]! !
!Object methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'yo 6/29/2004 13:08' prior: 16921245!
                at: index put: value 
	"Primitive. Assumes receiver is indexable. Store the argument value in 
	the indexable element of the receiver indicated by index. Fail if the 
	index is not an Integer or is out of bounds. Or fail if the value is not of 
	the right type for this kind of collection. Answer the value that was 
	stored. Essential. See Object documentation whatIsAPrimitive."

	<primitive: 61>
	index isInteger ifTrue:
		[self class isVariable
			ifTrue: [(index >= 1 and: [index <= self size])
					ifTrue: [self errorImproperStore]
					ifFalse: [self errorSubscriptBounds: index]]
			ifFalse: [self errorNotIndexable]].
	index isNumber
		ifTrue: [^self at: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]! !
!Object methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16921271!
                basicAt: index 
	"Primitive. Assumes receiver is indexable. Answer the value of an 
	indexable element in the receiver. Fail if the argument index is not an 
	Integer or is out of bounds. Essential. Do not override in a subclass. See 
	Object documentation whatIsAPrimitive."

	<primitive: 60>
	index isInteger ifTrue: [self errorSubscriptBounds: index].
	index isNumber
		ifTrue: [^self basicAt: index asInteger]
		ifFalse: [self errorNonIntegerIndex]! !
!Object methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16921288!
       basicAt: index put: value 
	"Primitive. Assumes receiver is indexable. Store the second argument 
	value in the indexable element of the receiver indicated by index. Fail 
	if the index is not an Integer or is out of bounds. Or fail if the value is 
	not of the right type for this kind of collection. Answer the value that 
	was stored. Essential. Do not override in a subclass. See Object 
	documentation whatIsAPrimitive."

	<primitive: 61>
	index isInteger
		ifTrue: [(index >= 1 and: [index <= self size])
					ifTrue: [self errorImproperStore]
					ifFalse: [self errorSubscriptBounds: index]].
	index isNumber
		ifTrue: [^self basicAt: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]! !
!Object methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16921313!
      basicSize
	"Primitive. Answer the number of indexable variables in the receiver. 
	This value is the same as the largest legal subscript. Essential. Do not 
	override in any subclass. See Object documentation whatIsAPrimitive."

	<primitive: 62>
	"The number of indexable fields of fixed-length objects is 0"
	^0	! !
!Object methodsFor: 'class membership' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16921332!
           class
	"Primitive. Answer the object which is the receiver's class. Essential. See 
	Object documentation whatIsAPrimitive."

	<primitive: 111>
	self primitiveFailed! !
!Object methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16921340!
           = anObject 
	"Answer true if the receiver and the argument represent the same object 
	and false otherwise. If = is redefined in any subclass, consider also
	redefining the message hash."

	^self == anObject! !
!Object methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16921349!
 ~= anObject 
	"Answer true if the receiver and the argument do not represent the same 
	object and false otherwise."

	^self = anObject == false! !
!Object methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'Squeak1.2 6/29/1997 10:40:55' prior: 16921357!
                           hash
	"Answer a SmallInteger whose value is related to the receiver's identity.
	May be overridden, and should be overridden in any classes that define = "

	^ self identityHash! !
!Object methodsFor: 'copying' library: #MinimalKernel01 stamp: 'ajh 8/18/2001 21:25' prior: 16921506!
     copy
	"Answer another instance just like the receiver. Subclasses typically override postCopy; they typically do not override shallowCopy."

	^self shallowCopy postCopy! !
!Object methodsFor: 'copying' library: #MinimalKernel01 stamp: 'jmv 9/7/2022 09:58:22' prior: 16921514!
            postCopy
	"self is a shallow copy, subclasses should copy fields as necessary to complete the full copy.
	Also clear any ivars that should be initialized lazyly."

	^ self! !
!Object methodsFor: 'copying' library: #MinimalKernel01 stamp: 'jm 11/14/97 11:08' prior: 16921522!
             shallowCopy
	"Answer a copy of the receiver which shares the receiver's instance variables."
	| class newObject index |
	<primitive: 148>
	class := self class.
	class isVariable
		ifTrue: 
			[index := self basicSize.
			newObject := class basicNew: index.
			[index > 0]
				whileTrue: 
					[newObject basicAt: index put: (self basicAt: index).
					index := index - 1]]
		ifFalse: [newObject := class basicNew].
	index := class instSize.
	[index > 0]
		whileTrue: 
			[newObject instVarAt: index put: (self instVarAt: index).
			index := index - 1].
	^ newObject! !
!Object methodsFor: 'error handling' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16921498!
                      shouldNotImplement
	"Announce that although the receiver inherits this message, it
	should not implement it."

	self error: 'This message is not appropriate for this object'! !
!Object methodsFor: 'evaluating' library: #MinimalKernel01 stamp: 'reThink 3/12/2001 18:14' prior: 16921365!
  value

	^self! !
!Object methodsFor: 'message handling' library: #MinimalKernel01 stamp: 'di 3/26/1999 07:52' prior: 16921368!
 perform: aSymbol 
	"Send the unary selector, aSymbol, to the receiver.
	Fail if the number of arguments expected by the selector is not zero.
	Primitive. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 83>
	^ self perform: aSymbol withArguments: (Array new: 0)! !
!Object methodsFor: 'message handling' library: #MinimalKernel01 stamp: 'di 3/26/1999 07:52' prior: 16921380!
                      perform: aSymbol with: anObject 
	"Send the selector, aSymbol, to the receiver with anObject as its argument.
	Fail if the number of arguments expected by the selector is not one.
	Primitive. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 83>
	^ self perform: aSymbol withArguments: (Array with: anObject)! !
!Object methodsFor: 'system primitives' library: #MinimalKernel01 stamp: 'jmv 12/31/1969 21:17:51' prior: 16921474!
  instVarAt: index put: anObject
	"Primitive. Store a value into a fixed variable in an object. The numbering of the
	 variables corresponds to the named instance variables, followed by the indexed
	 instance variables. Fail if the index is not an Integer or is not the index of a fixed
	 variable. Essential. See Object documentation whatIsAPrimitive."

	<primitive: 174 error: ec>
	"The classic InterpreterVMs don't support primitives 173 and 174.
	See http://forum.world.st/Some-test-where-Spur-more-slow-than-Cog-td4867810.html#a4867888
	Use primitives 73 and 74 in such case."
	Smalltalk isRunningCog ifFalse: [
		^ self instVarAtPrim74: index put: anObject ].
	self primitiveFailed! !
!Object methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 6/29/2015 14:57' prior: 16921393!
         is: aSymbol
	"A means for cleanly replacing isXXX like methods.
	Please use judiciously!!
	aSymbol is ussually a class name (starting with uppercase) or a protocolo conformance question (starting with lowercase), such as #hasTextSelector, #hasTextProvider, etc.
	
	A few comments:
	
		- Good for kernel tests
		- Good for tests defined in the same package as the receiver
		- Overwriting this method in a different package is a bad idea. It will surely conflict with other package. Use the traditional isXXX in such cases
		
		- In any case, asking these kinds of questions is a sign of poor design. If possible, avoid the question altogether, using, for example, double dispatching.
		
		- if a class happens to answer true for several Symbols, consider implementing it like:
			^#(symbol1 symbol2 symbol3) statePointsTo: aSymbol
		"
	
	"Enable this to log improper calls to the Transcript..."
	"
	aSymbol class == Symbol ifFalse: [ thisContext sender sender print. aSymbol print ].
	"
	^false! !
!Object methodsFor: 'testing' library: #MinimalKernel01 stamp: 'ar 7/9/1999 18:18' prior: 16921427!
                      isBehavior
	"Return true if the receiver is a behavior.
	Note: Do not override in any class except behavior."
	^false! !
!Object methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 6/6/2022 10:20:29' prior: 16921433!
                               isByteString
	"Overridden to return true in String, natch"
	^ false! !
!Object methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 1/9/2024 12:18:01' prior: 16921438!
                 isCharacter
	"Overridden to return true in Character."
	^ false! !
!Object methodsFor: 'testing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16921443!
              isInteger
	"Overridden to return true in Integer."

	^ false! !
!Object methodsFor: 'testing' library: #MinimalKernel01 stamp: 'rhi 8/12/2003 09:52' prior: 16921448!
                          isInterval

	^ false! !
!Object methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 1/3/2010 22:35' prior: 16921451!
   isMethodProperties
	^false! !
!Object methodsFor: 'testing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16921455!
                   isNumber
	"Overridden to return true in Number, natch"
	^ false! !
!Object methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 12/7/2022 09:09:02' prior: 16921460!
                    isString
	"Overridden to return true in String, UnicodeString."
	^ false! !
!Object methodsFor: 'testing' library: #MinimalKernel01 stamp: 'md 4/30/2003 15:30' prior: 16921465!
               isSymbol
	^ false ! !
!Object methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 12/7/2022 09:16:18' prior: 16921468!
 isUnicodeString
	"Overridden to return true in UnicodeString, natch"
	^ false! !
!Object methodsFor: 'associating' library: #MinimalKernel01 stamp: 'HAW 9/9/2019 08:57:04' prior: 16921326!
   -> anObject
	"Answer an Association between self and anObject"

	^Association key: self value: anObject! !
!Behavior methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'HAW 3/4/2019 15:19:06' prior: 16787203!
         definesInstanceVariableNamed: anInstanceVariableName

	^self instVarNames includes: anInstanceVariableName! !
!Behavior methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16787209!
    format
	"Answer an Integer that encodes the kinds and numbers of variables of instances
	of the receiver."

	^format! !
!Behavior methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 1/4/2024 15:26:02' prior: 16787215!
                            instSize
	"Answer the number of named instance variables
	(as opposed to indexed variables) of the receiver.
	Class format is
		<5 bits inst spec><16 bits inst size>"

	^ format bitAnd: 16rFFFF! !
!Behavior methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'eem 2/18/2020 19:37' prior: 16787224!
                 instSpec
	"Answer the instance specification part of the format that defines what kind of object
	 an instance of the receiver is.  The formats are
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (Context BlockClosure AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable	(DoubleWordArray et al)
		10-11	= 32-bit indexable	(WordArray et al)			(includes one odd bit, unused in 32-bit instances)
		12-15	= 16-bit indexable	(DoubleByteArray et al)		(includes two odd bits, one unused in 32-bit instances)
		16-23	= 8-bit indexable	(ByteArray et al)			(includes three odd bits, one unused in 32-bit instances)
		24-31	= compiled code	(CompiledCode et al)		(includes three odd bits, one unused in 32-bit instances)

	 Note that in the VM instances also have a 5 bit format field that relates to their class's format.
	 Formats 11, 13-15, 17-23 & 25-31 are unused in classes but used in instances to define the
	 number of elements missing up to the slot size.  For example, a 2-byte ByteString instance
	 has format 18 in 32 bits, since its size is one 32-bit slot - 2 bytes ((18 bitAnd: 3) = 2), and
	 22 in 64 bits, since its size is one 64-bit slot - 6 bytes ((22 bitAnd: 7) = 6).
	 Formats 24-31 are for compiled code which is a combination of pointers and bytes.  The number of pointers is
	 determined by literal count field of the method header, which is the first field of the object and must be a SmallInteger. 
	 The literal count field occupies the least significant 15 bits of the method header, allowing up to 32,767 pointer fields,
	 not including the header."
	^(format bitShift: -16) bitAnd: 16r1F! !
!Behavior methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 2/28/2010 22:50' prior: 16787289!
                     instVarNames
	"Answer an Array of the instance variable names. Behaviors must make 
	up fake local instance variable names because Behaviors have instance 
	variables for the purpose of compiling methods, but these are not named 
	instance variables."

	| mySize superSize |
	mySize := self instSize.
	superSize := 
		superclass
			ifNil: [0]
			ifNotNil: [superclass instSize].
	mySize = superSize ifTrue: [^#()].	
	^(superSize + 1 to: mySize) collect: [:i | 'inst' , i printString]! !
!Behavior methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'rca 7/26/2000 16:53' prior: 16787307!
               name
	"Answer a String that is the name of the receiver."
	^'a subclass of ', superclass name! !
!Behavior methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'HAW 6/28/2020 10:57:39' prior: 16787313!
                  theNonMetaClass

	self subclassResponsibility ! !
!Behavior methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 1/4/2024 15:32:35' prior: 16787317!
  typeOfClass
	"Answer a symbol uniquely describing the type of the receiver. c.f. kindOfSubclass, instSpec"
	^(#(normal
		normal
		variable
		variable
		weak
		ephemeron
		nil
		immediate
		nil
		longs
		words				nil
		shorts				nil nil nil
		bytes				nil nil nil nil nil nil nil
		compiledMethod	nil nil nil nil nil nil nil)
			at: self instSpec + 1) ifNil:
				[self error: 'invalid class type']! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'ar 7/9/1999 18:18' prior: 16787332!
          isBehavior
	"Return true if the receiver is a behavior"
	^true! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 1/4/2024 15:28:45' prior: 16787337!
                    isBits
	"Answer whether the receiver contains just bits (not pointers).
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec >= 7! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 7/5/2024 15:06:58' prior: 16787365!
         isBytes
	"Answer whether the receiver's instances have indexed 8-bit integer slots.
	If true, #isBits is also true.
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec >= 16! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'eem 12/1/2014 11:46' prior: 16787394!
                              isCompiledMethodClass
	"Answer whether the receiver has compiled method instances that mix pointers and bytes."
	^self instSpec >= 24! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 7/5/2024 15:07:05' prior: 16787401!
             isDoubleBytes
	"Answer whether the receiver's instances have indexed 16-bit integer slots.
	If true, #isBits is also true.
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec = 12! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 7/5/2024 15:07:09' prior: 16787431!
                      isDoubleWords
	"Answer whether the receiver's instances have indexed 64-bit integer slots.
	If true, #isBits is also true.
	 The class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec = 9! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'eem 3/3/2014 17:23' prior: 16787461!
                        isEphemeronClass
	"Answer whether the receiver has ephemeral instance variables.  The garbage collector will
	 fire (queue for finalization) any ephemeron whose first instance variable is not referenced
	 other than from the transitive closure of references from ephemerons. Hence referring to
	 an object from the first inst var of an ephemeron will cause the ephemeron to fire when
	 the rest of the system does not refer to the object and that object is ready to be collected.
	 Since references from the remaining inst vars of an ephemeron will not prevent the ephemeron
	 from firing, ephemerons may act as the associations in weak dictionaries such that the value
	 (e.g. properties attached to the key) will not prevent firing when the key is no longer referenced
	 other than from ephemerons.  Ephemerons can therefore be used to implement instance-based
	 pre-mortem finalization."
	^self instSpec = 5! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16787492!
  isFixed
	"Answer whether the receiver does not have a variable (indexable) part."

	^self isVariable not! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'eem 3/3/2014 17:23' prior: 16787498!
             isImmediateClass
	"Answer whether the receiver has immediate instances.  Immediate instances
	 store their value in their object pointer, not in an object body.  Hence immediates
	 take no space and are immutable.  The immediates are distinguished by tag bits
	 in the pointer. They include SmallIntegers and Characters.  Hence in the 32-bit
	 system SmallIntegers are 31-bit signed integers and Characters are 30-bit
	 unsigned character codes."
	^self instSpec = 7! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'ab 3/12/2003 17:44' prior: 16787515!
   isMeta
	^ false! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16787518!
 isPointers
	"Answer whether the receiver contains just pointers (not bits)."

	^self isBits not! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 1/4/2024 16:57:28' prior: 16787524!
                   isVariable
	"Answer whether the receiver has indexable variables.
	 Class format is
		<5 bits inst spec><16 bits inst size>
	 where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"
	| instSpec |
	instSpec := self instSpec.
	(instSpec between: 2 and: 4) ifTrue: [ ^true ].
	^instSpec >= 9! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'ar 3/21/98 02:36' prior: 16787554!
  isWeak
	"Answer whether the receiver has contains weak references."
	^ self instSpec = 4! !
!Behavior methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 7/5/2024 15:07:13' prior: 16787560!
                          isWords
	"Answer whether the receiver's instances have indexed 32-bit integer slots.
	If true, #isBits is also true.
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable
		24-31	= compiled methods (CompiledMethod)"

	^ self instSpec = 10! !
!Behavior methodsFor: 'printing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16787590!
                         printOn: aStream 
	aStream nextPutAll: 'a descendent of '.
	superclass printOn: aStream! !
!Behavior methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'eem 8/13/2014 06:32' prior: 16787596!
                   basicNew
	"Primitive. Answer an instance of the receiver (which is a class) with no 
	 indexable variables. Fail if the class is indexable. Essential. See Object 
	 documentation whatIsAPrimitive.
	
	 If the primitive fails because space is low then the scavenger will run
	 before the method is activated.  Check that space was low and retry
	 via handleFailingBasicNew if so."

	<primitive: 70 error: ec>
	ec == #'insufficient object memory' ifTrue:
		[^self handleFailingBasicNew].
	self isVariable ifTrue: [^self basicNew: 0].
	self primitiveFailed! !
!Behavior methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'topa 10/7/2015 20:41' prior: 16787616!
 basicNew: sizeRequested
	"Primitive. Answer an instance of this class with the number of indexable
	 variables specified by the argument, sizeRequested.  Fail if this class is not
	 indexable or if the argument is not a positive Integer, or if there is not
	 enough memory available. Essential. See Object documentation whatIsAPrimitive.
	
	 If the primitive fails because space is low then the scavenger will run before the
	 method is activated.  Check args and retry via handleFailingBasicNew: if they're OK."

	<primitive: 71 error: ec>
	(ec == #'insufficient object memory' or: [ec == #'bad argument']) ifTrue:
		[^self handleFailingBasicNew: sizeRequested].
	self isVariable ifFalse:
		[self error: self printString, ' cannot have variable sized instances'].
	self primitiveFailed! !
!Behavior methodsFor: 'instance creation' library: #MinimalKernel01 stamp: '' prior: 16787643!
           new
	"Answer a new initialized instance of the receiver (which is a class) with no indexable variables. Fail if the class is indexable."

	^ self basicNew initialize
! !
!Behavior methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'sd 5/20/2004 11:20' prior: 16787651!
     new: sizeRequested 
	"Answer an initialized instance of this class with the number of indexable
	variables specified by the argument, sizeRequested."

	^ (self basicNew: sizeRequested) initialize  ! !
!Behavior methodsFor: 'enumerating' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16787700!
  allSubclassesDo: aBlock 
	"Evaluate the argument, aBlock, for each of the receiver's subclasses."

	self subclassesDo: 
		[:cl | 
		aBlock value: cl.
		cl allSubclassesDo: aBlock]! !
!Behavior methodsFor: 'class hierarchy' library: #MinimalKernel01 stamp: 'jmv 5/19/2025 18:21:34' prior: 16787660!
                      deepSubclassNamed: aName
	"Or nil"
	self allSubclassesDo: [ :cls | cls name = aName ifTrue: [ ^cls ]].
	^nil.! !
!Behavior methodsFor: 'class hierarchy' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16787667!
                      superclass
	"Answer the receiver's superclass, a Class."

	^superclass! !
!Behavior methodsFor: 'instances' library: #MinimalKernel01 stamp: 'eem 3/10/2014 19:04' prior: 16787672!
            allInstancesOrNil
	"Answer all instances of the receiver, or nil if the primitive
	 fails, which it may be due to being out of memory."
	<primitive: 177>
	^nil! !
!Behavior methodsFor: 'instances' library: #MinimalKernel01 stamp: 'jmv 5/29/2025 09:15:16' prior: 16787680!
                someInstance
	"Answer the first instance of this receiver.
	Fails if there are none.
	See Object>>#nextInstance.

	#someInstance and #nextInstance are meant to be used together starting with #someInstance,
	and following with #nextInstance until nil.

	Warning: Until all the instances are iterated and nil is answered, the VM holds a strong reference
	to the last one retrieved, preventing collecting and finalization.
	Best practice is to always iterate until nil.

	Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 77>
	^nil! !
!Behavior methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 1/4/2024 16:08:35' prior: 16787708!
            identityHash
	"Answer a SmallInteger whose value is related to the receiver's identity.
	 Behavior implements identityHash to allow the VM to use an object representation which
	 does not include a direct reference to an object's class in an object.  If the VM is using
	 this implementation then classes are held in a class table and instances contain the index
	 of their class in the table.  A class's class table index is its identityHash so that an instance
	 can be created without searching the table for a class's index.  The VM uses this primitive
	 to enter the class into the class table, assigning its identityHash with an as yet unused
	 class table index. If this primitive fails it means that the class table is full.
	 There are 22 bits of classTable index and 22 bits of identityHash per object.

	 Primitive. Essential. Do not override. See Object documentation whatIsAPrimitive."

	<primitive: 175>
	self primitiveFailed.! !
!Behavior methodsFor: 'constants' library: #MinimalKernel01 stamp: 'eem 2/27/2025 10:21:52' prior: 16787740!
   maxInstSize
	"Answer the maximum number of named instance variables
	 (as opposed to indexed variables) of the receiver.
	 The class format is
		<5 bits inst spec><16 bits inst size>"
	^16rFFFF! !
!ClassDescription methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 3/1/2010 11:14' prior: 16818979!
          instVarNames
	"Answer an Array of the receiver's instance variable names."

	^instanceVariables ifNil: [ #() ]! !
!ClassDescription methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 3/23/2011 18:11' prior: 16818985!
                            theMetaClass
	"Sent to a class or metaclass, always return the metaclass"

	^self class! !
!ClassDescription methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16818991!
          theNonMetaClass
	"Sent to a class or metaclass, always return the class"

	^self! !
!ClassDescription methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 9/4/2023 18:58:11' prior: 16818997!
                         printNameOn: aStream
	aStream nextPutAll: 'a subclass of '.
	superclass notNil
		ifTrue: [ superclass printNameOn: aStream ]
		ifFalse: [ aStream nextPutAll: 'nil' ]! !
!ClassDescription methodsFor: 'printing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16819005!
  printOn: aStream 
	aStream nextPutAll: self name! !
!Class methodsFor: 'class variables' library: #MinimalKernel01 stamp: 'jmv 3/1/2010 11:09' prior: 16815330!
classPool
	"Answer the dictionary of class variables."

	^classPool
		ifNil: [Dictionary new]! !
!Class methodsFor: 'pool variables' library: #MinimalKernel01 stamp: 'jmv 9/13/2023 18:06:41' prior: 16815336!
                sharedPools
	"Answer a Set of the pool dictionaries declared in the receiver."

	^sharedPools ifNil: [#()]! !
!Class methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 3/1/2010 11:09' prior: 16815311!
            name
	"Answer the name of the receiver."

	^name ifNil: [super name]! !
!Class methodsFor: 'accesing class hierarchy' library: #MinimalKernel01 stamp: 'jmv 2/28/2010 23:16' prior: 16815316!
  subclassesDo: aBlock 
	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."
	subclasses
		ifNotNil: [subclasses do: aBlock]! !
!Class methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 9/4/2023 18:51:34' prior: 16815324!
                            printNameOn: aStream
	name notNil
		ifTrue: [ aStream nextPutAll: name ]
		ifFalse: [ super printNameOn: aStream ]! !
!Metaclass methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 10/24/2023 10:07:27' prior: 16904956!
                           allClassInstVarNames
	"Similar to #allInstVarNames, but don't include class instance variables used by the system itself,
	only those defined as class side #instanceVariableNames: "

	^(superclass notNil and: [ superclass isMeta ])
		ifTrue: [superclass allClassInstVarNames , self instVarNames]
		ifFalse: [self instVarNames copy]	"Guarantee a copy is answered."! !
!Metaclass methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 3/1/2010 11:39' prior: 16904970!
       name
	"Answer a String that is the name of the receiver, either 'Metaclass' or 
	the name of the receiver's class followed by ' class'."

	^thisClass
		ifNil: [ 'a Metaclass']
		ifNotNil: [ thisClass name , ' class']! !
!Metaclass methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 3/23/2011 18:12' prior: 16904980!
                         theMetaClass
	"Sent to a class or metaclass, always return the metaclass"

	^self! !
!Metaclass methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16904986!
                       theNonMetaClass
	"Sent to a class or metaclass, always return the class"

	^thisClass! !
!Metaclass methodsFor: 'class hierarchy' library: #MinimalKernel01 stamp: 'ar 7/9/1999 14:11' prior: 16904995!
                        subclassesDo: aBlock
	"Evaluate aBlock for each of the receiver's immediate subclasses."
	thisClass subclassesDo:[:aSubclass|
		"The following test is for Class class which has to exclude
		the Metaclasses being subclasses of Class."
		aSubclass isMeta ifFalse:[aBlock value: aSubclass class]].! !
!Metaclass methodsFor: 'testing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16904992!
         isMeta
	^ true! !
!Metaclass methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 9/4/2023 19:05:02' prior: 16905007!
  printNameOn: aStream
	thisClass notNil
		ifTrue: [
			thisClass printNameOn: aStream.
			aStream nextPutAll: ' class']
		ifFalse: [ aStream nextPutAll: 'a Metaclass']! !
!Metaclass methodsFor: 'class variables' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16905015!
 classPool
	"Answer the dictionary of class variables."

	^thisClass classPool! !
!Collection methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16828012!
                               size
	"Answer how many elements the receiver contains."

	| tally |
	tally := 0.
	self do: [:each | tally := tally + 1].
	^tally! !
!Collection methodsFor: 'enumerating' library: #MinimalKernel01 stamp: 'sma 4/30/2000 11:17' prior: 16828019!
              allSatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns false for any element return false.
	Otherwise return true."

	self do: [:each | (aBlock value: each) ifFalse: [^ false]].
	^ true! !
!Collection methodsFor: 'enumerating' library: #MinimalKernel01 stamp: 'di 11/21/1999 20:14' prior: 16828029!
                 anySatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns true for any element return true.
	Otherwise return false"

	self do:[:item | (aBlock value: item) ifTrue: [^ true]].
	^ false! !
!Collection methodsFor: 'enumerating' library: #MinimalKernel01 stamp: 'len 5/1/2022 13:25:40' prior: 16828039!
                   count: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument.  Return the number that answered true."
	| count |
	count := 0.
	self do: [:each| (aBlock value: each) ifTrue: [count := count + 1]].
	^ count! !
!Collection methodsFor: 'enumerating' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16828049!
      reject: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Collect into a new collection like the receiver, only those elements for which
	aBlock evaluates to false.  Answer the new collection."

	^self select: [:element | (aBlock value: element) == false]! !
!Collection methodsFor: 'enumerating' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16828061!
           select: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument. 
	Collect into a new collection like the receiver, only those elements for which
	aBlock evaluates to true.  Answer the new collection."

	| newCollection |
	newCollection := self species new.
	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].
	^newCollection! !
!Collection methodsFor: 'private' library: #MinimalKernel01 stamp: 'jmv 6/11/2019 12:08:53' prior: 16828121!
                           species
	"Answer the preferred class for reconstructing the receiver.  For example, 
	collections create new collections whenever enumeration messages such as 
	collect: or select: are invoked.  The new kind of collection is determined by 
	the species of the original collection.  Species and class are not always the 
	same.  For example, the species of Interval is Array."
	"Redefined here just for reference. See inheritance.
	#collect: avoids using #species in String, when there are non-Character objects
	#select: and #copy avoid using it in SortedCollection"

	^ self class! !
!Collection methodsFor: 'testing' library: #MinimalKernel01 stamp: 'sma 5/12/2000 14:07' prior: 16828075!
             includes: anObject 
	"Answer whether anObject is one of the receiver's elements."

	^ self anySatisfy: [:each | each = anObject]! !
!Collection methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jpb 8/2/2019 23:59:42' prior: 16828082!
                is: aSymbol
	"Note: Senders might prefer #isCollection for perfomance reasons. Still, Cuis tries to keep isXXX testing selectors to a minimum."
	^#Collection = aSymbol or: [ super is: aSymbol ]! !
!Collection methodsFor: 'testing' library: #MinimalKernel01 stamp: 'di 11/6/1998 09:16' prior: 16828091!
                  isSequenceable
	^ false! !
!Collection methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 8/9/2016 09:35:07' prior: 16828095!
                       = other
	"Default implementation. Usually redefined in subclasses."

	^self == other! !
!Collection methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/12/2019 18:08:54' prior: 16828101!
                         emptyCollectionHash
	^self species hash! !
!Collection methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/12/2019 18:09:13' prior: 16828105!
      hash
	"A default hash function for any collection.  Note that this method is insensitive to contents when the size is greater than 10, so critical applications that compare many large collections of the same length will want to refine this behavior."

	| hash |
	hash := self emptyCollectionHash.
	self size <= 10 ifTrue: [
		self do: [ :elem | hash := hash bitXor: elem hash]].
	^ hash bitXor: self size hash
! !
!SequenceableCollection methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16955030!
      indexOf: anElement 
	"Answer the index of anElement within the receiver.  If the receiver does
	not contain anElement, answer 0."

	^self indexOf: anElement ifAbsent: [0]! !
!SequenceableCollection methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ls 8/18/1998 00:36' prior: 16955039!
                           indexOf: anElement ifAbsent: exceptionBlock
	"Answer the index of anElement within the receiver. If the receiver does 
	not contain anElement, answer the result of evaluating the argument, 
	exceptionBlock."
	^self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock! !
!SequenceableCollection methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ul 9/12/2010 04:34' prior: 16955051!
                     indexOf: anElement startingAt: start
	"Answer the index of the first occurence of anElement after start
	within the receiver. If the receiver does not contain anElement, 
	answer 0."

	^self indexOf: anElement startingAt: start ifAbsent: 0! !
!SequenceableCollection methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'Squeak1.1 9/23/1996 20:34:59' prior: 16955062!
            indexOf: anElement startingAt: start ifAbsent: exceptionBlock
	"Answer the index of anElement within the receiver. If the receiver does 
	not contain anElement, answer the result of evaluating the argument, 
	exceptionBlock."
	start to: self size do:
		[:i | (self at: i) = anElement ifTrue: [^ i]].
	^ exceptionBlock value! !
!SequenceableCollection methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16955075!
                             replaceFrom: start to: stop with: replacement 
	"This destructively replaces elements from start to stop in the receiver.  
	Answer the receiver itself.
	Use copyReplaceFrom:to:with: for insertion/deletion which may alter the 
	size of the result."

	replacement size = (stop - start + 1)
		ifFalse: [self error: 'Size of replacement doesnt match'].
	^self replaceFrom: start to: stop with: replacement startingAt: 1! !
!SequenceableCollection methodsFor: 'converting' library: #MinimalKernel01 stamp: 'jmv 3/7/2015 22:28' prior: 16955153!
    asByteArray
	"Answer a ByteArray whose elements are the elements of the receiver.
	Optimized implementation."

	^ ByteArray withAll: self! !
!SequenceableCollection methodsFor: 'copying' library: #MinimalKernel01 stamp: 'di 1/16/98 16:40' prior: 16955160!
, otherCollection 
	"Concatenate two Strings or Collections."
	
	^ self copyReplaceFrom: self size + 1
		  to: self size
		  with: otherCollection
"
#(2 4 6 8) , #(who do we appreciate)
((2989 printStringBase: 16) copyFrom: 4 to: 6) , ' boy!!'
"! !
!SequenceableCollection methodsFor: 'copying' library: #MinimalKernel01 stamp: 'jmv 2/7/2024 16:13:49' prior: 16955171!
               copyBlank: requestedSize
	"Answer an instance like me, of size n, but without content.
	All elements may be nil, zero or some other default value if needed."

	^self species new: requestedSize! !
!SequenceableCollection methodsFor: 'copying' library: #MinimalKernel01 stamp: 'jmv 2/7/2024 16:14:06' prior: 16955180!
    copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize |
	newSize := stop - start + 1 max: 0.
	^(self copyBlank: newSize)
		replaceFrom: 1
		to: newSize
		with: self
		startingAt: start! !
!SequenceableCollection methodsFor: 'copying' library: #MinimalKernel01 stamp: 'jmv 2/7/2024 16:14:40' prior: 16955192!
          copyReplaceFrom: start to: stop with: replacementCollection 
	"Answer a copy of the receiver satisfying the following conditions: 
	+ stop is less than start, then this is an insertion; stop should be exactly start-1, 
	+ start = 1 means insert before the first character,
	+ start = size+1 means append after last character. 
	+ Otherwise, this is a replacement; start and stop have to be within the receiver's bounds."

	| newSequenceableCollection newSize endReplacement |
	newSize := self size - (stop - start + 1) + replacementCollection size.
	endReplacement := start - 1 + replacementCollection size.
	newSequenceableCollection := self copyBlank: newSize.
	start > 1 ifTrue:[
		newSequenceableCollection
			replaceFrom: 1
			to: start - 1
			with: self
			startingAt: 1].
	start <= endReplacement ifTrue:[
		newSequenceableCollection
			replaceFrom: start
			to: endReplacement
			with: replacementCollection
			startingAt: 1].
	endReplacement < newSize ifTrue:[
		newSequenceableCollection
			replaceFrom: endReplacement + 1
			to: newSize
			with: self
			startingAt: stop + 1].
	^newSequenceableCollection! !
!SequenceableCollection methodsFor: 'copying' library: #MinimalKernel01 stamp: 'jmv 2/7/2024 16:15:40' prior: 16955230!
         grownTo: newSize

	| grownCollection |
	grownCollection := self copyBlank: newSize.
	grownCollection replaceFrom: 1 to: self size with: self startingAt: 1.
	^grownCollection! !
!SequenceableCollection methodsFor: 'enumerating' library: #MinimalKernel01 stamp: 'jmv 9/16/2014 09:32' prior: 16955239!
                     do: aBlock 
	"Refer to the comment in Collection >> #do:
	Note: Subclasses need to redefine either #do: or #size (or both!!).
	"
	1 to: self size do: [ :index |
		aBlock value: (self at: index) ]! !
!SequenceableCollection methodsFor: 'enumerating' library: #MinimalKernel01 stamp: 'jmv 2/19/2015 10:50' prior: 16955248!
                               select: aBlock 
	"Refer to the comment in Collection>>select: ."
	^self species streamContents: [ :strm |
		1 to: self size do: [ :index |
			(aBlock value: (self at: index))
				ifTrue: [ strm nextPut: (self at: index) ]]]! !
!SequenceableCollection methodsFor: 'testing' library: #MinimalKernel01 stamp: 'sma 5/12/2000 14:08' prior: 16955258!
       includes: anObject
	"Answer whether anObject is one of the receiver's elements."

	^ (self indexOf: anObject) ~= 0! !
!SequenceableCollection methodsFor: 'testing' library: #MinimalKernel01 stamp: 'di 11/6/1998 09:35' prior: 16955265!
                     isSequenceable
	^ true! !
!SequenceableCollection methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 2/19/2015 20:36' prior: 16955091!
              = otherCollection 
	"Answer true if the receiver is equivalent to the otherCollection.
	First test for identity, then rule out different species and sizes of
	collections. As a last resort, examine each element of the receiver
	and the otherCollection."

	self == otherCollection ifTrue: [^ true].
	self species == otherCollection species ifFalse: [^ false].
	"#( 1 2 3) = (1 to: 3) -> false"
	otherCollection isInterval ifTrue: [ ^false ].
	^ self hasEqualElements: otherCollection! !
!SequenceableCollection methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 12/27/2018 18:20:09' prior: 16955109!
                              hasEqualElements: otherCollection
	"Answer whether the receiver's size is the same as otherCollection's
	size, and each of the receiver's elements equal the corresponding 
	element of otherCollection.
	This should probably replace the current definition of #= ."

	| size |
	otherCollection isSequenceable ifFalse: [^ false].
	(size := self size) = otherCollection size ifFalse: [^ false].
	1 to: size do:
		[:index |
		(self at: index) = (otherCollection at: index) ifFalse: [^ false]].
	^ true! !
!SequenceableCollection methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/11/2019 16:08:53' prior: 16955128!
                  hash
	"Subclasses might use other methods.
	However #hashQuick is suggested for very large collections."
	^ self hashQuick! !
!SequenceableCollection methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/14/2022 14:50:31' prior: 16955135!
       hashQuick
	^self hashQuick: self species hash! !
!SequenceableCollection methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/14/2022 14:50:11' prior: 16955140!
                    hashQuick: initialHash
	| hash size step |

	size := self size.
	hash := (initialHash + size hash) hashMultiply.
	step := size < 64 ifTrue: [1] ifFalse: [size//64].
	1 to: size by: step do: [ :i | | elem |
		elem := self at: i.
		elem == self ifFalse: [
			hash := (hash + elem hash) hashMultiply]].
	^hash! !
!SequenceableCollection methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/19/2025 10:48:21' prior: 50342974!
               is: otherCollection subcollectionAt: index
	"Answer whether the receiver includes otherCollection as a subcollection at position index."

	| sequenceSize |
	index < 1 ifTrue: [ ^false ].
	sequenceSize := otherCollection size.
	sequenceSize = 0 ifTrue: [ ^true ].
	self size - index + 1 < sequenceSize ifTrue: [ ^false ].
	1 to: sequenceSize do: [ :i |
		(self at: index+i-1) = (otherCollection at: i) ifFalse: [ ^false ]].
	^true! !
!SequenceableCollection methodsFor: 'stream creation' library: #MinimalKernel01 stamp: 'jmv 8/5/2022 11:41:43' prior: 16955269!
               asStreamResult
	"See senders.
	Also see #thatCanHoldCodePoints"
	^self! !
!SequenceableCollection methodsFor: 'stream creation' library: #MinimalKernel01 stamp: 'sma 5/12/2000 12:51' prior: 16955275!
                        readStream
	^ ReadStream on: self! !
!SequenceableCollection methodsFor: 'stream creation' library: #MinimalKernel01 stamp: 'jmv 7/7/2022 10:37:44' prior: 16955280!
                           thatCanBeModified
	"By default, SequenceableCollections can handle #at:put:"

	^self! !
!SequenceableCollection methodsFor: 'stream creation' library: #MinimalKernel01 stamp: 'sma 5/12/2000 12:52' prior: 16955286!
          writeStream
	^ WriteStream on: self! !
!SequenceableCollection class methodsFor: 'stream creation' library: #MinimalKernel01 stamp: 'jmv 1/18/2011 14:06' prior: 16956972!
                     streamContents: blockWithArg
	^self streamContents: blockWithArg estimatedSize: 100! !
!SequenceableCollection class methodsFor: 'stream creation' library: #MinimalKernel01 stamp: 'jmv 2/7/2024 16:30:56' prior: 16956978!
   streamContents: blockWithArg estimatedSize: estimatedSize

	^self streamContents: blockWithArg on: (self new: estimatedSize)! !
!SequenceableCollection class methodsFor: 'stream creation' library: #MinimalKernel01 stamp: 'jmv 2/7/2024 16:28:16' prior: 16956986!
                          streamContents: blockWithArg on: aCollection

	| stream originalContents |
	
	stream := aCollection writeStream.
	blockWithArg value: stream.
	originalContents := stream originalContents.
	
	^stream position = originalContents size
		ifTrue: [ originalContents asStreamResult ]
		ifFalse: [ stream contents ]! !
!ArrayedCollection methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16783619!
                 size
	"Answer the number of indexable fields in the receiver. This value is the 
	same as the largest legal subscript. Primitive is specified here to override 
	SequenceableCollection size. Essential. See Object documentation 
	whatIsAPrimitive. "

	<primitive: 62>
	^self basicSize! !
!ArrayedCollection class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 9/29/2019 12:52:40' prior: 16784004!
                              new
	"Answer a new instance of me, with size = 0, unles a specific size is used."

	^self new: self numElements! !
!ArrayedCollection class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 2/5/2024 17:43:28' prior: 16784011!
          new: sizeRequested
	"Answer an initialized instance of this class with the number of indexable
	variables specified by the argument, sizeRequested."

	^ (self basicNew: sizeRequested) initialize  ! !
!ArrayedCollection class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 9/29/2019 12:47:53' prior: 16784021!
                    numElements
	"Some subclasses create instances of a specific size, and a non-zero number"
	^0! !
!ArrayedCollection class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 3/7/2015 23:10' prior: 16784027!
                               withAll: aSequenceableCollection
	"Create a new collection containing all the elements from aSequenceableCollection."

	^ (self new: aSequenceableCollection size)
		replaceFrom: 1
		to: aSequenceableCollection size
		with: aSequenceableCollection! !
!ArrayedCollection class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 5/12/2025 12:09:36' prior: 16784038!
  withAll: aSequenceableCollection with: finalElement
	"Create a new collection containing all the elements from aSequenceableCollection."

	| answer |
	answer := (self new: aSequenceableCollection size + 1)
		replaceFrom: 1
		to: aSequenceableCollection size
		with: aSequenceableCollection.
	answer at: answer size put: finalElement.
	^answer! !
!Array methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 4/9/2016 19:32' prior: 16782860!
  is: aSymbol
	^ aSymbol == #Array or: [ super is: aSymbol ]! !
!Array methodsFor: 'system prinitives' library: #MinimalKernel01 stamp: 'len 5/15/2019 16:43:02' prior: 16782778!
                elementsExchangeIdentityWith: otherArray
	"This primitive performs a bulk mutation, causing all pointers to the elements of the
	 receiver to be replaced by pointers to the corresponding elements of otherArray.
	 At the same time, all pointers to the elements of otherArray are replaced by
	 pointers to the corresponding elements of this array.  The identityHashes remain
	 with the pointers rather than with the objects so that objects in hashed structures
	 should still be properly indexed after the mutation.

	Warning. This is a dangerous operation and it could lead to a crash if some object in receiver or argument is receiver of a method currently in execution. See #anyReceiverInStackIn: See senders for examples."

	<primitive: 128 error: ec>
	ec == #'bad receiver' ifTrue:
		[^self error: 'receiver must be of class Array'].
	ec == #'bad argument' ifTrue:
		[^self error: (otherArray class == Array
						ifTrue: ['arg must be of class Array']
						ifFalse: ['receiver and argument must have the same size'])].
	ec == #'inappropriate operation' ifTrue:
		[^self error: 'can''t become immediates such as SmallIntegers or Characters'].
	ec == #'no modification' ifTrue:
		[^self error: 'can''t become immutable objects'].
	ec == #'object is pinned' ifTrue:
		[^self error: 'can''t become pinned objects'].
	ec == #'insufficient object memory' ifTrue:
		[| maxRequired |
		 "In Spur, two-way become may involve making each pair of objects into a forwarder into a copy of the other.
		 So if become fails with #'insufficient object memory', garbage collect, and if necessary, grow memory."
		 maxRequired := (self sum: [:obj | obj class byteSizeOfInstanceOfSize: obj basicSize] ifEmpty: [0])
						+ (otherArray sum: [:obj | obj class byteSizeOfInstanceOfSize: obj basicSize] ifEmpty: [0]).
		 (Smalltalk garbageCollectMost < maxRequired
		  and: [Smalltalk garbageCollect < maxRequired]) ifTrue:
			[Smalltalk growMemoryByAtLeast: maxRequired].
		 ^self elementsExchangeIdentityWith: otherArray].
	self primitiveFailed! !
!Array methodsFor: 'system prinitives' library: #MinimalKernel01 stamp: 'jmv 1/13/2017 09:57:31' prior: 16782844!
                              replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!ByteArray methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 9/11/2023 17:58:16' prior: 16801464!
                     indexOf: anInteger startingAt: start ifAbsent: aBlock

	| ans |
	(anInteger isInteger and: [
		anInteger >= 0 and: [
		anInteger <= 255 ] ]) ifFalse: [ ^0 ].
	ans := ByteArray indexOfByte: anInteger inBytes: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ ans ]! !
!ByteArray methodsFor: 'converting' library: #MinimalKernel01 stamp: 'ar 11/2/1998 00:51' prior: 16801476!
                  asByteArray
	^self! !
!ByteArray methodsFor: 'converting' library: #MinimalKernel01 stamp: 'Squeak1.2 6/29/1997 10:40:55' prior: 16801480!
                     asString
	"Convert to a String with Characters for each byte.
	Fast code uses primitive that avoids character conversion"

	^ (String new: self size) replaceFrom: 1 to: self size with: self! !
!ByteArray methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 5/26/2022 16:04:32' prior: 16801489!
                   is: aSymbol
	^#ByteArray = aSymbol or: [ super is: aSymbol ]! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 16:40:25' prior: 16800870!
      bitAt: bitIndex
	"Answer the bit (0 or 1) at a bit index.
	This way, the receiver behaves as a BitArray.
	Note: There is no error raised if you access the possible extra bits at the end if size is not multiple of 8."
	| bitPosition index |
	index := bitIndex - 1 // 8 + 1.
	bitPosition := bitIndex - 1 \\ 8 + 1.
	^ self bitAt: index bitPosition: bitPosition! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 16:40:44' prior: 16800884!
                             bitAt: bitIndex put: aBit
	"Set the bit (0 or 1) at a bit index. This way, the receiver behaves as a BitArray
	Note: There is no error raised if you access the possible extra bits at the end if size is not multiple of 8.
	#[1 0 0 ] bitAt: 1
	#[0 1  0 ] bitAt: 9
	#[0 0 128 ] bitAt: 24
	"
	| bitPosition index |
	index := bitIndex - 1 // 8 + 1.
	bitPosition := bitIndex - 1 \\ 8 + 1.
	self bitAt: index bitPosition: bitPosition put: aBit! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 5/17/2019 08:51:43' prior: 16800901!
             bitBooleanAt: bitIndex
	"Consider the bit at bitIndex as a Boolean value.
	0 -> false
	1 -> true"
	^ (self bitAt: bitIndex) = 1! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 5/17/2019 08:52:49' prior: 16800908!
  bitBooleanAt: bitIndex put: aBoolean
	"Consider the bit at bitIndex as a Boolean value.
	0 -> false
	1 -> true"
	self bitAt: bitIndex put: (aBoolean ifTrue: [1] ifFalse: [0])! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:27:44' prior: 16800917!
                    float32At: index bigEndian: bool 
	"Return a 32 bit float starting from the given byte index.
	We answer an instance of Float, i.e. 64 bits, but holding the 32 bit Float."
	| w |
	w := self uint32At: index bigEndian: bool.
	^ Float fromIEEE32Bit: w! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:28:17' prior: 16800928!
          float32At: index put: value bigEndian: bool 
	"Store a 32 bit float starting from the given byte index.
	Round value to a 32bit Float, and store it."
	| w |
	w := value asIEEE32BitWord.
	self uint32At: index put: w bigEndian: bool.
	^ value! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:27:48' prior: 16800939!
                  float64At: index bigEndian: bool 
	"Return a 64 bit float starting from the given byte index"
	| w1 w2 dbl |
	w1 := self uint32At: index bigEndian: bool.
	w2 := self uint32At: index + 4 bigEndian: bool.
	dbl := Float new. 
	bool
		ifTrue: [
			dbl basicAt: 1 put: w1.
			dbl basicAt: 2 put: w2]
		ifFalse: [
			dbl basicAt: 1 put: w2.
			dbl basicAt: 2 put: w1].
	^ dbl! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:28:21' prior: 16800954!
                 float64At: index put: value bigEndian: bool 
	"Store a 64 bit float starting from the given byte index"
	| w1 w2 |
	bool
		ifTrue: [w1 := value basicAt: 1.
			w2 := value basicAt: 2]
		ifFalse: [w1 := value basicAt: 2.
			w2 := value basicAt: 1]. 
	self uint32At: index put: w1 bigEndian: bool.
	self uint32At: index + 4 put: w2 bigEndian: bool.
	^ value! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'ul 9/6/2015 23:16' prior: 16800968!
    int16At: index bigEndian: bigEndian
	"Return a 16-bit signed integer quantity starting from the given byte index"

	| result |
	result := bigEndian
		ifFalse: [ ((self at: index + 1) bitShift: 8) + (self at: index) ]
		ifTrue: [ ((self at: index) bitShift: 8) + (self at: index + 1) ].
	result < 16r8000 ifTrue: [ ^result ].
	^result - 16r10000! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'ul 9/6/2015 23:16' prior: 16800982!
              int16At: index put: value bigEndian: bigEndian
	"Store a 16-bit signed integer quantity starting from the given byte index"
	
	| unsignedValue |
	(unsignedValue := value) < 0 ifTrue: [
		unsignedValue := unsignedValue + 16r10000 ].
	bigEndian ifFalse: [
		self 
			at: index + 1 put: (unsignedValue bitShift: -8);
			at: index put: (unsignedValue bitAnd: 16rFF).
		^value ].
	self
		at: index put: (unsignedValue bitShift: -8);
		at: index + 1 put: (unsignedValue bitAnd: 16rFF).
	^value! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'ul 9/9/2015 20:28' prior: 16801000!
                               int32At: index bigEndian: bigEndian
	"Return a 32-bit integer quantity starting from the given byte index.
	Answer an instance of SmallInteger or LargePositiveInteger as required.
	Avoid allocation of extra LargePositiveIntegers"
	
	| byte result |
	bigEndian ifFalse: [
		(byte := self at: index + 3) <= 16r7F ifTrue: [ "Is the result non-negative?"
			byte <= 16r3F ifTrue: [
				^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index) ].
			^(LargePositiveInteger new: 4)
				replaceFrom: 1
					to: 4
					with: self
					startingAt: index;
				normalize ].
		"Negative"
		byte >= 16rC0 ifTrue: [
			^-1 - (((((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitXor: 16rFFFFFF) bitShift: 8) + ((self at: index) bitXor: 16rFF)) ].
		(result := LargeNegativeInteger new: 4)
			digitAt: 4 put: ((self at: index + 3) bitXor: 16rFF);
			digitAt: 3 put: ((self at: index + 2) bitXor: 16rFF);
			digitAt: 2 put: ((self at: index + 1) bitXor: 16rFF).
		(byte := ((self at: index) bitXor: 16rFF) + 1) <= 16rFF ifTrue: [
			^result
				digitAt: 1 put: byte;
				normalize ].
		^result
			digitAt: 1 put: 16rFF;
			- 1 "It's tempting to do the subtraction in a loop to avoid the LargeInteger creation, but it's actually slower than this." ].
	(byte := self at: index) <= 16r7F ifTrue: [ "Is the result non-negative?"
		byte <= 16r3F ifTrue: [
			^(((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3) ].
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 3);
			digitAt: 2 put: (self at: index + 2);
			digitAt: 3 put: (self at: index + 1);
			digitAt: 4 put: byte;
			normalize ].
	"Negative"
	16rC0 <= byte ifTrue: [
		^-1 - (((((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitXor: 16rFFFFFF) bitShift: 8) + ((self at: index + 3) bitXor: 16rFF)) ].
	(result := LargeNegativeInteger new: 4)
		digitAt: 4 put: (byte bitXor: 16rFF);
		digitAt: 3 put: ((self at: index + 1) bitXor: 16rFF);
		digitAt: 2 put: ((self at: index + 2) bitXor: 16rFF).
	(byte := ((self at: index + 3) bitXor: 16rFF) + 1) <= 16rFF ifTrue: [
		^result
			digitAt: 1 put: byte;
			normalize ].
	^result 
		digitAt: 1 put: 16rFF;
		- 1 "It's tempting to do the subtraction in a loop to avoid the LargeInteger creation, but it's actually slower than this."! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'ul 9/6/2015 17:13' prior: 16801079!
                   int32At: index put: value bigEndian: bigEndian
	"Store a 32-bit signed integer quantity starting from the given byte index"
	
	| v v2 |
	value isLarge ifTrue: [
		bigEndian ifFalse: [
			value positive ifTrue: [
				self 
					replaceFrom: index
					to: index + 3
					with: value
					startingAt: 1.
				^value ].
			v := 0.
			[ v <= 3 and: [ (v2 := ((value digitAt: v + 1) bitXor: 16rFF) + 1) = 16r100 ] ] whileTrue: [
				self at: index + v put: 0.
				v := v + 1 ].
			self at: index + v put: v2.
			v := v + 1.
			[ v <= 3 ] whileTrue: [
				self at: index + v put: ((value digitAt: (v := v + 1)) bitXor: 16rFF) ].
			^value ].
		value positive ifTrue: [
			self
				at: index put: (value digitAt: 4);
				at: index + 1 put: (value digitAt: 3);
				at: index + 2 put: (value digitAt: 2);
				at: index + 3 put: (value digitAt: 1).
			^value ].
		v := 3.
		[ 0 <= v and: [ (v2 := ((value digitAt: 4 - v) bitXor: 16rFF) + 1) = 16r100 ] ] whileTrue: [
			self at: index + v put: 0.
			v := v - 1 ].
		self at: index + v put: v2.
		[ 0 <= (v := v - 1) ] whileTrue: [
			self at: index + v put: ((value digitAt: 4 - v) bitXor: 16rFF) ].
		^value ].
	v := value bitShift: -24.
	0 <= (v := (v bitAnd: 16r7F) - (v bitAnd: 16r80)) ifFalse: [
		v := v + 16r100 ].
	bigEndian ifFalse: [
		self 
			at: index put: (value bitAnd: 16rFF);
			at: index + 1 put: ((value bitShift: -8) bitAnd: 16rFF);
			at: index + 2 put: ((value bitShift: -16) bitAnd: 16rFF);
			at: index + 3 put: v.
		^value ].
	self
		at: index put: v;
		at: index + 1 put: ((value bitShift: -16) bitAnd: 16rFF);
		at: index + 2 put: ((value bitShift: -8) bitAnd: 16rFF);
		at: index + 3 put: (value bitAnd: 16rFF).
	^value! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:27:16' prior: 16801135!
            int64At: index bigEndian: bigEndian
	"Return a 64-bit signed integer quantity starting from the given byte index."

	| value |
	value := self uint64At: index bigEndian: bigEndian.
	value digitLength < 8 ifTrue: [ ^value ].
	(value digitAt: 8) < 16r80 ifTrue: [ ^value ].
	^value - 16r10000000000000000! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:27:27' prior: 16801148!
                     int64At: index put: value bigEndian: bigEndian
	"Store a 64-bit signed integer quantity starting from the given byte index."
	
	^self
		uint64At: index
		put: (value negative
			ifFalse: [ value ]
			ifTrue: [ value + 16r10000000000000000 ])
		bigEndian: bigEndian! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 6/5/2024 10:00:06' prior: 16801160!
                          int8At: index bigEndian: dummyArgument
	"Return a 8-bit signed integer quantity from the given byte index.
	Endiannes is irrelevant for 8 bit quantities. dummyArgument is included for consistency,
	and because #int8At: is implemented in FFI package."

	| result |
	result := self at: index.
	result < 16r80 ifTrue: [ ^result ].
	^result - 16r100! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 6/5/2024 10:00:50' prior: 16801174!
         int8At: index put: value bigEndian: dummyArgument
	"Store a 8-bit signed integer quantity at the given byte index
	Endiannes is irrelevant for 8 bit quantities. dummyArgument is included for consistency,
	and because #int8At: is implemented in FFI package."

	| unsignedValue |
	(unsignedValue := value) < 0 ifTrue: [
		unsignedValue := unsignedValue + 16r100 ].
	self at: index put: unsignedValue.
	^value! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'ul 9/3/2015 01:33' prior: 16801190!
                uint16At: index bigEndian: bigEndian
	"Return a 16-bit unsigned integer quantity starting from the given byte index"

	bigEndian ifFalse: [ ^((self at: index + 1) bitShift: 8) + (self at: index) ].
	^((self at: index) bitShift: 8) + (self at: index + 1)
	! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'ul 9/3/2015 15:29' prior: 16801201!
       uint16At: index put: value bigEndian: bigEndian
	"Store a 16-bit unsigned integer quantity starting from the given byte index"
	
	bigEndian ifFalse: [
		self 
			at: index + 1 put: (value bitShift: -8);
			at: index put: (value bitAnd: 16rFF).
		^value ].
	self
		at: index put: (value bitShift: -8);
		at: index+1 put: (value bitAnd: 16rFF).
	^value! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'eem 2/22/2016 09:20' prior: 16801215!
      uint32At: index bigEndian: bigEndian
	"Return a 32-bit unsigned integer quantity starting from the given byte index.
	Answer an instance of SmallInteger or LargePositiveInteger as required.
	Avoid allocation of extra LargePositiveIntegers"
	| byte |
	bigEndian ifTrue:
		[((byte := self at: index) <= 16r3F
		 or: [SmallInteger maxVal >  1073741823]) ifTrue:
			[^(((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3)].
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 3);
			digitAt: 2 put: (self at: index + 2);
			digitAt: 3 put: (self at: index + 1);
			digitAt: 4 put: byte;
			normalize].
	((byte := self at: index + 3) <= 16r3F
	 or: [SmallInteger maxVal >  1073741823]) ifTrue:
		[^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index)].
	^(LargePositiveInteger new: 4)
		replaceFrom: 1 to: 4 with: self startingAt: index;
		normalize! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'ul 9/3/2015 01:33' prior: 16801249!
               uint32At: index put: value bigEndian: bigEndian
	"Store a 32-bit unsigned integer quantity starting from the given byte index"
	
	value isLarge
		ifTrue: [
			bigEndian ifFalse: [
				self
					replaceFrom: index
					to: index + 3
					with: value
					startingAt: 1.
				^value ].
			self
				at: index put: (value digitAt: 4);
				at: index + 1 put: (value digitAt: 3);
				at: index + 2 put: (value digitAt: 2);
				at: index +3 put: (value digitAt: 1) ]
		ifFalse: [
			bigEndian ifFalse: [
				self 
					at: index put: (value bitAnd: 16rFF);
					at: index + 1 put: ((value bitShift: -8) bitAnd: 16rFF);
					at: index + 2 put: ((value bitShift: -16) bitAnd: 16rFF);
					at: index + 3 put: (value bitShift: -24).
				^value ].
			self 
				at: index put: (value bitShift: -24);
				at: index + 1 put: ((value bitShift: -16) bitAnd: 16rFF);
				at: index + 2 put: ((value bitShift: -8) bitAnd: 16rFF);
				at: index + 3 put: (value bitAnd: 16rFF) ].
	^value! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'eem 2/22/2016 09:36' prior: 16801282!
uint64At: index bigEndian: bigEndian
	"Return a 64-bit unsigned integer quantity starting from the given byte index.
	Answer an instance of SmallInteger or LargePositiveInteger as required.
	Avoid allocation of extra LargePositiveIntegers"

	| byte |
	SmallInteger maxVal >  1073741823 ifTrue:
		[bigEndian
			ifTrue: "64-bit SmallIntegers have a 3 bit tag and a sign bit, so the most positive value has 16rF as its top byte."
				[(byte := self at: index) <= 16rF ifTrue:
					[^((((((((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3)) bitShift: 8)
						+ (self at: index + 4) bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 7)]]
			ifFalse:
				[(byte := self at: index + 7) <= 16rF ifTrue:
					[^((((((((byte bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 4)) bitShift: 8)
						+ (self at: index + 3) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index)]]].
	bigEndian ifFalse: [
		(byte := self at: index + 7) = 0 ifFalse: [
			^(LargePositiveInteger new: 8)
				replaceFrom: 1 to: 8 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 6) = 0 ifFalse: [
			^(LargePositiveInteger new: 7)
				replaceFrom: 1 to: 7 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 5) = 0 ifFalse: [
			^(LargePositiveInteger new: 6)
				replaceFrom: 1 to: 6 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 4) = 0 ifFalse: [
			^(LargePositiveInteger new: 5)
				replaceFrom: 1 to: 5 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 3) <= 16r3F ifFalse: [
			^(LargePositiveInteger new: 4)
				replaceFrom: 1 to: 4 with: self startingAt: index;
				normalize ].
		^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index) ].
	(byte := self at: index) = 0 ifFalse: [
		^(LargePositiveInteger new: 8)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: (self at: index + 2);
			digitAt: 7 put: (self at: index + 1);
			digitAt: 8 put: byte;
			normalize ].
	(byte := self at: index + 1) = 0 ifFalse: [	
		^(LargePositiveInteger new: 7)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: (self at: index + 2);
			digitAt: 7 put: byte;
			normalize ].
	(byte := self at: index + 2) = 0 ifFalse: [	
		^(LargePositiveInteger new: 6)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: byte;
			normalize ].
	(byte := self at: index + 3) = 0 ifFalse: [	
		^(LargePositiveInteger new: 5)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: byte;
			normalize ].		
	(byte := self at: index + 4) <= 16r3F ifFalse: [
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: byte;
			normalize ].
	^(((byte bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 7)! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'ul 9/9/2015 20:18' prior: 16801402!
       uint64At: index put: value bigEndian: bigEndian
	"Store a 64-bit unsigned integer quantity starting from the given byte index"
	
	| i j |
	value isLarge ifTrue: [
		i := value digitLength.
		bigEndian ifFalse: [
			self
				replaceFrom: index
					to: index + i - 1
					with: value 
					startingAt: 1;
				replaceFrom: index + i
					to: index + 7
					with: #[0 0 0 0 0 0 0 0]
					startingAt: 1.
			^value ].
		j := index + 8.
		i <= 7 ifTrue: [
			self
				replaceFrom: index
				to: j - i - 1
				with: #[0 0 0 0 0 0 0 0]
				startingAt: 1 ].
		[ 1 <= i ] whileTrue: [
			self at: j - i put: (value digitAt: i).
			i := i - 1 ].
		^value ].
	bigEndian ifFalse: [
		j := index - 1.
		i := value.
		[ 1 <= i ] whileTrue: [
			self at: (j := j + 1) put: (i bitAnd: 16rFF).
			i := i bitShift: -8 ].
		self replaceFrom: j + 1
			to: index + 7
			with: #[0 0 0 0 0 0 0 0]
			startingAt: 1.
		^value ].
	j := index + 8.
	i := value.
	[ 1 <= i ] whileTrue: [
		self at: (j := j - 1) put: (i bitAnd: 16rFF).
		i := i bitShift: -8 ].
	self replaceFrom: index
		to: j - 1
		with: #[0 0 0 0 0 0 0 0]
		startingAt: 1.
	^value! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 6/5/2024 10:00:58' prior: 16801440!
   uint8At: index bigEndian: dummyArgument
	"Return a 8-bit unsigned integer quantity from the given byte index.
	Endiannes is irrelevant for 8 bit quantities. dummyArgument is included for consistency,
	and because #int8At: is implemented in FFI package."

	^self at: index! !
!ByteArray methodsFor: 'access - Numeric Types' library: #MinimalKernel01 stamp: 'jmv 6/5/2024 10:01:02' prior: 16801452!
                   uint8At: index put: value bigEndian: dummyArgument
	"Store a 8-bit unsigned integer quantity at the given byte index.
	Endiannes is irrelevant for 8 bit quantities. dummyArgument is included for consistency,
	and because #int8At: is implemented in FFI package."

	^self at: index put: value! !
!ByteArray methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/26/2022 15:06:03' prior: 16801494!
            = another
	"Make good use of String primitives"

	self == another ifTrue: [ ^ true ].
	self species == another species ifFalse: [^ false].
	^String is: self equalTo: another ! !
!ByteArray methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/14/2022 14:52:04' prior: 16801502!
hash
	"#hash is implemented, because #= is implemented"
	self size > ByteArray minSizeForHashQuick ifTrue: [
		^ self hashQuick: ByteArray hash ].
	^self class
		hashBytes: self
		startingWith: ByteArray hash! !
!ByteArray methodsFor: 'system primitives' library: #MinimalKernel01 stamp: 'jmv 1/13/2017 09:57:38' prior: 16801512!
                      replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!ByteArray class methodsFor: 'byte based hash' library: #MinimalKernel01 stamp: 'jmv 6/27/2022 15:45:37' prior: 16801683!
         hashBytes: aByteArray startingWith: speciesHash
	"Answer the hash of a byte-indexed collection,
	using speciesHash as the initial value.
	See SmallInteger>>hashMultiply.

	The primitive should be renamed at a
	suitable point in the future"

	| byteArraySize hash low |
	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>

	byteArraySize := aByteArray size.
	hash := speciesHash bitAnd: 16rFFFFFFF.
	1 to: byteArraySize do: [ :pos |
		hash := hash + (aByteArray basicAt: pos).
		"Begin hashMultiply"
		low := hash bitAnd: 16383.
		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.
	].
	^ hash! !
!ByteArray class methodsFor: 'byte based hash' library: #MinimalKernel01 stamp: 'jmv 6/14/2022 14:45:55' prior: 16801707!
                             minSizeForHashQuick
	"Answer the size above which we prefer using the #hashQuick method"

	^256! !
!ByteArray class methodsFor: 'services' library: #MinimalKernel01 stamp: 'jmv 1/6/2024 15:50:15' prior: 16801713!
           findFirstInBytes: aByteArrayOrByteString inSet: aByteSetByteArray startingAt: start
	| i stringSize |
	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>

	aByteSetByteArray size ~= 256 ifTrue: [ ^0 ].

	i := start.
	stringSize := aByteArrayOrByteString size.
	[ i <= stringSize and: [ (aByteSetByteArray at: (aByteArrayOrByteString basicAt: i) +1) = 0 ] ] whileTrue: [ 
		i := i + 1 ].

	i > stringSize ifTrue: [ ^0 ].
	^i! !
!ByteArray class methodsFor: 'services' library: #MinimalKernel01 stamp: 'jmv 9/11/2023 17:57:34' prior: 16801730!
             indexOfByte: anInteger inBytes: aByteArrayOrByteString startingAt: start

	| stringSize |
	<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>

	start > 0 ifFalse: [ ^ 0 ].
	stringSize := aByteArrayOrByteString size.
	start to: stringSize do: [:pos |
		(aByteArrayOrByteString basicAt: pos) = anInteger ifTrue: [^ pos]].
	^ 0
! !
!CompiledMethod methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'eem 11/29/2008 11:38' prior: 16833275!
              methodClass
	"answer the class that I am installed in"
	^(self literalAt: self numLiterals) value.! !
!CompiledMethod methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 1/4/2024 15:38:13' prior: 16833281!
        numLiterals
	"Answer the number of literals used by the receiver."

	^ self header bitAnd: 16r7FFF! !
!CompiledMethod methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'HAW 1/7/2019 15:49:22' prior: 16833287!
        selector
	"Answer a method's selector.  This is either the penultimate literal,
	 or, if the method has any properties or pragmas, the selector of
	 the MethodProperties stored in the penultimate literal."
	
	^self 
		withPropertiesDo: [ :properties | properties selector ] 
		ifSelector: [ :selector | selector ]
! !
!CompiledMethod methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 7/4/2023 16:00:46' prior: 16833300!
                withPropertiesDo: withBlock ifSelector: notBlock
	"Evaluate withBlock with our AdditionalMethodState,
	or evaluate notBlock with our selector
		(if we don't hold any Pragmas or properties in an AdditionalMethodState)"

	| penultimalLiteral |
	penultimalLiteral := self penultimateLiteral.
	^penultimalLiteral isMethodProperties 
		ifTrue: [ withBlock value: penultimalLiteral ]
		ifFalse: [ notBlock value: penultimalLiteral ]! !
!CompiledMethod methodsFor: 'converting' library: #MinimalKernel01 stamp: 'ul 12/8/2010 03:24' prior: 16833361!
  asString

	^self printString! !
!CompiledMethod methodsFor: 'literals' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16833316!
             header
	"Answer the word containing the information about the form of the
	receiver and the form of the context needed to run the receiver."

	^self objectAt: 1! !
!CompiledMethod methodsFor: 'literals' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16833324!
         literalAt: index 
	"Answer the literal indexed by the argument."

	^self objectAt: index + 1! !
!CompiledMethod methodsFor: 'literals' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16833330!
             objectAt: index 
	"Answer with the method header (if index=1) or a literal (if index >1) from the 
	receiver.  Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 68>
	self primitiveFailed! !
!CompiledMethod methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 5/14/2025 10:40:39' prior: 16833340!
                            printClassAndSelectorOn: aStream

	aStream
		print: self methodClass;
		nextPutAll: '>>'.
	self selector storeOn: aStream! !
!CompiledMethod methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 5/14/2025 10:35:47' prior: 16833347!
                 printOn: aStream
	"Overrides method inherited from the byte arrayed collection."

	aStream nextPut: $(.
	self printClassAndSelectorOn: aStream.
	aStream space; nextPut: $"; nextPut: $a; space.
	aStream nextPutAll: self class name.
	aStream nextPut: $:; print: self size.
	aStream nextPut: $(; print: self identityHash; nextPut: $); nextPut: $"; nextPut: $)! !
!CompiledMethod methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 12/2/2010 08:38' prior: 16833365!
          is: aSymbol
	^ aSymbol == #CompiledMethod or: [ super is: aSymbol ]! !
!CompiledMethod methodsFor: 'private' library: #MinimalKernel01 stamp: 'eem 11/29/2008 11:10' prior: 16833370!
          penultimateLiteral
	"Answer the penultimate literal of the receiver, which holds either
	 the receiver's selector or its properties (which will hold the selector)."
	| pIndex |
	^(pIndex := self numLiterals - 1) > 0 
		ifTrue: [self literalAt: pIndex]
		ifFalse: [nil]! !
!Semaphore methodsFor: 'communication' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16954697!
                             signal
	"Send a signal through the receiver. If one or more processes have been 
	suspended trying to receive a signal, allow the first one to proceed. If no 
	process is waiting, remember the excess signal. Essential. See Object documentation 
	whatIsAPrimitive. "

	<primitive: 85>
	self primitiveFailed

	"self isEmpty    
		ifTrue: [excessSignals := excessSignals+1]    
		ifFalse: [Processor resume: self removeFirstLink]"! !
!Semaphore methodsFor: 'communication' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16954713!
                              wait
	"The active Process must receive a signal through the receiver before 
	proceeding.  If no signal has been sent, the active Process will be suspended
	until one is sent.  Essential.  See  
	Object whatIsAPrimitive."

	<primitive: 86>
	self primitiveFailed

	"excessSignals>0  
		ifTrue: [excessSignals := excessSignals-1]  
		ifFalse: [self addLastLink: Processor activeProcess suspend]"! !
!Semaphore methodsFor: 'mutual exclusion' library: #MinimalKernel01 stamp: 'jmv 2/23/2010 14:27' prior: 16954728!
 critical: mutuallyExcludedBlock
	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in
	the process of running the critical: message. If the receiver is, evaluate
	mutuallyExcludedBlock after the other critical: message is finished."
	
	| caught |
	"We need to catch eventual interruptions very carefully. 
	The naive approach of just doing, e.g.,:
		self wait.
		aBlock ensure:[self signal].
	will fail if the active process gets terminated while in the wait.
	However, the equally naive:
		[self wait.
		aBlock value] ensure:[self signal].
	will fail too, since the active process may get interrupted while
	entering the ensured block and leave the semaphore signaled twice.
	To avoid both problems we make use of the fact that interrupts only
	occur on sends (or backward jumps) and use an assignment (bytecode)
	right before we go into the wait primitive (which is not a real send and
	therefore not interruptable either)."

	caught := false.
	^[
		caught := true.
		self wait.
		mutuallyExcludedBlock value
	] ensure: [ caught ifTrue: [self signal] ]
! !
!Semaphore methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'sma 4/22/2000 18:48' prior: 16954764!
                              = anObject
	^ self == anObject! !
!Semaphore methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'sma 4/22/2000 18:48' prior: 16954768!
                   hash
	^ self identityHash! !
!Semaphore methodsFor: 'initialize-release' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16954772!
           initSignals
	"Consume any excess signals the receiver may have accumulated."

	excessSignals := 0! !
!Semaphore methodsFor: 'private' library: #MinimalKernel01 stamp: 'jmv 6/11/2019 12:31:53' prior: 16954778!
               species
	"So we are never equal an Array"

	^ self class! !
!Semaphore class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16954902!
       forMutualExclusion
	"Answer a new instance of me that contains a single signal.  
	This new instance can now be used for mutual exclusion (see the 
	critical: message to Semaphore)."

	^self new signal! !
!Semaphore class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16954912!
                      new
	"Answer a new instance of Semaphore that contains no signals."

	^self basicNew initSignals! !
!CharacterSequence methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 6/11/2022 19:15:43' prior: 16812768!
      indexOf: aCharacter

	^self indexOf: aCharacter startingAt: 1! !
!CharacterSequence methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16812773!
        string
	"Answer the receiver itself.  This is for compatibility with other text classes."
	^self! !
!CharacterSequence methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 7/25/2024 10:38:14' prior: 16812779!
      = another
	"Note: Behavior the same for String, Symbol, UnicodeString, UnicodeSymbol and Text,
	both as receiver and as argument, if they hold same Characters."

	self subclassResponsibility! !
!CharacterSequence methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 7/25/2024 10:36:22' prior: 16812788!
        hash
	"#hash is implemented, because #= is implemented.
	Note: #hash must be the same for String, Symbol, UnicodeString, UnicodeSymbol and Text
	if they hold same Characters."

	self subclassResponsibility! !
!CharacterSequence methodsFor: 'printing' library: #MinimalKernel01 stamp: 'sma 6/1/2000 09:48' prior: 16812797!
                              printOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."

	self storeOn: aStream! !
!CharacterSequence methodsFor: 'printing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16812803!
                               storeOn: aStream 
	"Print inside string quotes, doubling inbedded quotes."
	| x |
	aStream nextPut: $'.
	1 to: self size do:
		[:i |
		aStream nextPut: (x := self at: i).
		x == $' ifTrue: [aStream nextPut: x]].
	aStream nextPut: $'! !
!CharacterSequence methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 6/6/2022 10:54:40' prior: 16812813!
 isString
	^ true! !
!CharacterSequence class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 9/29/2019 12:52:40' prior: 16815214!
        new
	"Answer a new instance of me, with size = 0, unles a specific size is used."

	^self new: self numElements! !
!CharacterSequence class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 9/29/2019 12:47:53' prior: 16815221!
         numElements
	"Some subclasses create instances of a specific size, and a non-zero number"
	^0! !
!String methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 1/8/2024 12:18:20' prior: 16967803!
                     at: index 
	"Primitive. Answer the Character stored in the field of the receiver
	indexed by the argument. Fail if the index argument is not an Integer or
	is out of bounds. Essential. See Object documentation whatIsAPrimitive."

	<primitive: 63>
	^Character codePoint: (super at: index)! !
!String methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 1/9/2024 12:12:34' prior: 16967815!
                   at: index put: aCharacter 
	"Primitive. Store the Character in the field of the receiver indicated by
	the index. Fail if the index is not an Integer or is out of bounds, or if
	the argument is not a Character. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 64>
	aCharacter isCharacter
		ifTrue: [	
			aCharacter codePoint > 255 ifTrue: [
				self error: 'String only store Latin-1 Characters'].
			index isInteger
				ifTrue: [self errorSubscriptBounds: index]
				ifFalse: [self errorNonIntegerIndex]]
		ifFalse: [self error: 'Strings only store Characters']! !
!String methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 1/8/2024 09:21:57' prior: 16967836!
           indexOf: aCharacter startingAt: start ifAbsent: aBlock
	| ans |
	aCharacter isCharacter ifFalse: [ ^ aBlock value ].
	"String can only hold ASCII + Latin1"
	aCharacter codePoint >255 ifTrue: [ ^ aBlock value ].
	ans := ByteArray indexOfByte: aCharacter codePoint inBytes: self startingAt: start.
	^ans = 0
		ifTrue: [ aBlock value ]
		ifFalse: [ ans ]! !
!String methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 1/13/2017 09:58:04' prior: 16967850!
                  replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!String methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16967867!
                       size
	"Answer the number of indexable fields in the receiver. This value is the 
	same as the largest legal subscript. Primitive is specified here to override 
	SequenceableCollection size. Essential. See Object documentation 
	whatIsAPrimitive. "

	<primitive: 62>
	^self basicSize! !
!String methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 12/7/2022 09:07:39' prior: 16967879!
                       = aString
	"Answer whether the receiver sorts equally as aString.
	This means same characters in same order.
	Argument could be instance of String, Symbol, Text, UnicodeString, UnicodeSymbol."

	"Any object is equal to itself"
	self == aString ifTrue: [ ^ true ].

	"If argument is not a kind of String or Symbol, maybe it is a Text?"
	aString isString ifFalse: [
		(aString is: #Text) ifTrue: [ ^ self = aString string ].
		^ false].

	self size = aString size ifFalse: [
		^false ].

	self hash = aString hash ifFalse: [
		^false ].

	"Let them handle us"
	aString isByteString ifFalse: [
		^aString = self ].

	^String is: self equalTo: aString.! !
!String methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 12/7/2022 09:07:58' prior: 16967902!
         hash
	"#hash is implemented, because #= is implemented.
	Note: #hash must be the same for String, Symbol, UnicodeString, UnicodeSymbol and Text
	if they hold same Characters."

	self size >  ByteArray minSizeForHashQuick ifTrue: [
		^ self hashQuick: String hash ].
	^ByteArray
		hashBytes: self
		startingWith: String hash! !
!String methodsFor: 'copying' library: #MinimalKernel01 stamp: 'KenD 9/4/2016 16:50:54' prior: 16967915!
                , aStringOrText
	^ aStringOrText appendToString: self! !
!String methodsFor: 'copying' library: #MinimalKernel01 stamp: 'KenD 9/4/2016 16:21:53' prior: 16967919!
                              appendToString: aString

	| stringSize |
	stringSize := aString size.
	^ aString copyReplaceFrom: stringSize + 1
		 	    to: stringSize
		   	    with: self! !
!String methodsFor: 'copying' library: #MinimalKernel01 stamp: 'jmv 4/16/2023 17:37:20' prior: 16967927!
                       copyReplaceFrom: start to: stop with: replacementCollection 
	"Answer a copy of the receiver satisfying the following conditions: 
	+ stop is less than start, then this is an insertion; stop should be exactly start-1, 
	+ start = 1 means insert before the first character,
	+ start = size+1 means append after last character. 
	+ Otherwise, this is a replacement; start and stop have to be within the receiver's bounds."

	| rep |
	rep := replacementCollection string.
	rep isUnicodeString ifTrue: [
		^self asUnicodeString copyReplaceFrom: start to: stop with: rep  ].
	^super copyReplaceFrom: start to: stop with: rep.! !
!String methodsFor: 'converting' library: #MinimalKernel01 stamp: 'jmv 8/8/2024 17:11:12' prior: 16967949!
     asUtf8Bytes
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin-1 (ISO 8859-1)
	Answer a ByteArray with a valid UTF-8 sequence."

	"Fast lane."
	self isAscii ifTrue: [ ^self asByteArray ].

	"Need to do UTF-8 encoding."
	^ByteArray streamContents: [ :outStream |
		self do: [ :c |
			Character
				evaluate: [ :byte | outStream nextPut: byte ]
				withUtf8BytesOf: c codePoint ]].! !
!String methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jpb 8/3/2019 00:01:22' prior: 16967964!
  is: aSymbol
	"Note: Senders might prefer #isString for perfomance reasons. Still, Cuis tries to keep isXXX testing selectors to a minimum."
	^#String = aSymbol or: [ super is: aSymbol]! !
!String methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 6/9/2022 15:01:48' prior: 16967972!
                            isAscii
	"Return true when I am pure 7-bit ASCII.
	This means, for example, that my bytes are also my UTF-8 representation."

	^ String isAscii: self! !
!String methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 6/6/2022 10:21:36' prior: 16967979!
                               isByteString
	^ true! !
!String class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 2/4/2024 21:05:06' prior: 16968556!
                new: sizeRequested 
	"Answer an initialized instance of this class with the number of indexable
	variables specified by the argument, sizeRequested."

	^ (self basicNew: sizeRequested) initialize  ! !
!String class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16968565!
                             with: aCharacter 
	"Answer a new instance of me, containing only aCharacter.
	String with: $a
	String with: $á
	String with: Character euro
	"

	| newCollection |
	newCollection := self new: 1.
	newCollection at: 1 put: aCharacter.
	^newCollection! !
!String class methodsFor: 'services' library: #MinimalKernel01 stamp: 'jmv 6/27/2022 15:40:39' prior: 16968576!
                    compare: string1 with: string2 collated: order
	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."

	| len1 len2 c1 c2 |
	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>

	len1 := string1 size.
	len2 := string2 size.
	1 to: (len1 min: len2) do:
		[:i |
		c1 := order at: (string1 basicAt: i) + 1.
		c2 := order at: (string2 basicAt: i) + 1.
		c1 = c2 ifFalse: 
			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].
	len1 = len2 ifTrue: [^ 2].
	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].
! !
!String class methodsFor: 'services' library: #MinimalKernel01 stamp: 'jmv 7/7/2024 15:41:39' prior: 16968597!
                         is: aStringOrByteArray equalTo: another
	"Take advantage of String primitive for comparing, for example, ByteArrays"

	^ (self compare: aStringOrByteArray with: another collated: self caseSensitiveOrder) = 2! !
!String class methodsFor: 'services' library: #MinimalKernel01 stamp: 'jmv 1/6/2024 15:50:03' prior: 16968606!
                              isAscii: aStringOrByteArray
	"Return true if all bytes in argument are less than 128.
	This means it is a pure 7-bit ASCII.
	Valid both for instances of String (possibly with accented latin letters or other Character)
	and for utf-8 encoded ByteArrays.
	In these cases, the bytes represent the same ascii string both as String and as Utf8.
	See also #nextUtf8BytesAndCodePointInto:into:, #ascii and #nonAscii"

	| nonAsciiBytesSetBA |
	nonAsciiBytesSetBA := `(ByteArray new: 128), ((ByteArray new: 128) + 1)`.
	^ (ByteArray
		findFirstInBytes: aStringOrByteArray
		inSet: nonAsciiBytesSetBA
		startingAt: 1)
			= 0.! !
!String class methodsFor: 'static state' library: #MinimalKernel01 stamp: 'jmv 7/25/2024 15:53:47' prior: 16968628!
 caseSensitiveOrder
	^`String basicCaseSensitiveOrder`.! !
!Symbol methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16969800!
                          at: anInteger put: anObject 
	"you can not modify the receiver."

	self errorNoModification! !
!Symbol methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16969806!
                     replaceFrom: start to: stop with: replacement startingAt: repStart 
	self errorNoModification! !
!Symbol methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 4/30/2025 12:51:16' prior: 16969824!
                     storeOn: aStream 

	aStream nextPut: $#.
	(Symbol isLiteralSymbol: self)
		ifTrue: [aStream nextPutAll: self]
		ifFalse: [super storeOn: aStream]! !
!Symbol methodsFor: 'testing' library: #MinimalKernel01 stamp: 'md 4/30/2003 15:31' prior: 16969821!
      isSymbol
	^ true ! !
!Symbol methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/3/2022 10:34:38' prior: 16969812!
 = another

	"Use == between two symbols..."
	self == another ifTrue: [
		^ true].  "Was == "
	another isSymbol ifTrue: [
		^ false].  "Was not ==, therefore can't be = "

	"Otherwise use string =..."
	^ super = another! !
!Symbol methodsFor: 'copying' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16969831!
                        shallowCopy
	"Answer with me, because Symbols are unique."! !
!Symbol methodsFor: 'private' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16969836!
                        species
	^String! !
!Symbol class methodsFor: 'services' library: #MinimalKernel01 stamp: 'jmv 4/30/2025 12:51:07' prior: 16970044!
                            isLiteralSymbol: aSymbol 
	"Test whether a symbol can be stored as # followed by its characters.  
	Symbols created internally with asSymbol may not have this property, 
	e.g. '3' asSymbol."
	| char |
	aSymbol size = 0 ifTrue: [^ false].
	aSymbol = ':' ifTrue: [ ^true ].
	aSymbol = '|' ifTrue: [ ^true ].
	(aSymbol allSatisfy: [ :c | Character binarySelectorCharacters includes: c ])
		ifTrue: [ ^true ].
	char := aSymbol at: 1.
	(char isLetter or: [ char = $_ ]) ifTrue: [
		(aSymbol allSatisfy: [ :c |
			c isLetter or: [ c = $_ or: [ c isDigit or: [ c = $: ]]]])
				ifTrue: [ ^true ]].		
	^false! !
!SystemDictionary methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 9/3/2012 18:04' prior: 16971048!
                    printOn: aStream
	self == Smalltalk
		ifTrue: [ aStream nextPutAll: 'Smalltalk' ]
		ifFalse: [ super printOn: aStream ]! !
!SystemDictionary methodsFor: 'snapshot and quit' library: #MinimalKernel01 stamp: 'jmv 3/27/2015 17:52' prior: 16971036!
           quitPrimitive: exitCode
	"Primitive. Exit with exitCode to another operating system on the host machine, if one exists.
	All state changes in the object space since the last snapshot are lost.
	Ignore exitCode if it's not supported by the VM."

	<primitive: 113>
	self quitPrimitive! !
!SystemDictionary methodsFor: 'vm parameters' library: #MinimalKernel01 stamp: 'jmv 4/25/2024 11:26:11' prior: 16970750!
         vmParameterAt: parameterIndex
	"parameterIndex is a positive integer corresponding to one of the VM's internal parameter/metric registers.
	 Answer with the current value of that register.  Primitive fails if parameterIndex is invalid or has no corresponding register.
	Answer nil if the VM doesn't provide the register, and the primitive fails.
	
	Also see #getVMParameters and #vmParameterAt:put: These 3 methods call the 
	same primitive, whose behavior depends on argument count:
		0 args:	return an Array of VM parameter values;
  		1 arg:	return the indicated VM parameter;
  		2 args:	set the VM indicated parameter.

	VM parameters are numbered as follows:
		1	byte size of old-space (read-only)
		2	byte size of young-space (read-only)
		3	byte size of object memory (read-only)
		4	nil (was allocationCount (read-only))
		5	nil (was allocations between GCs (read-write)
		6	survivor count tenuring threshold (read-write)
		7	full GCs since startup (read-only)
		8	total milliseconds in full GCs since startup (read-only)
		9	Scavenging GCs
		10	total milliseconds in scavenging GCs since startup (read-only) since startup (read-only)
		11	tenures of surving objects since startup/last write (read-write)
		12	event trace mask; if 1 << eventType is set in the mask then event received by primGetNextEvent: will be printed to stderr.
		13	VM ticker start microseconds (Croquet/QwaqVM only)
		14	VM ticker count (Croquet/QwaqVM only)
		15	VM ticker call count (Croquet/QwaqVM only)
		16	total microseconds at idle since start-up (if non-zero)
		17	fraction of the code zone to use (Sista only; used to control code zone use to preserve sendAndBranchData on counter tripped callback)
		18	total milliseconds in full GC compaction since startup (a portion of parameter 8)
		19	scavenge threshold, the effective size of eden.  When eden fills to the threshold a scavenge is scheduled.
		20	utc microseconds at VM start-up (actually at time initialization, which precedes image load).
		21	root/remembered table size (occupancy) (read-only)
		22	root table overflows since startup (read-only)
		23	bytes of extra memory to reserve for VM buffers, plugins, etc (stored in image file header).
		24	memory threshold above which to shrink object memory (read-write)
		25	ammount to grow by when growing object memory (read-write)
		26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds (read-write)
		27	number of times mark loop iterated for current IGC/FGC (read-only) includes ALL marking
		28	number of times sweep loop iterated for current IGC/FGC (read-only)
		29	number of times make forward loop iterated for current IGC/FGC (read-only)
		30	number of times compact move loop iterated for current IGC/FGC (read-only)
		31	number of grow memory requests (read-only)
		32	number of shrink memory requests (read-only)
		33	number of root table entries used for current IGC/FGC (read-only)
		34	bytes allocated in total since start-up or reset (read-write)
		35	number of survivor objects after current IGC/FGC (read-only)
		36	millisecond clock when current IGC/FGC completed (read-only)
		37	number of marked objects for Roots of the world, not including Root Table entries for current IGC/FGC (read-only)
		38	milliseconds taken by current IGC (read-only)
		39	Number of finalization signals for Weak Objects pending when current IGC/FGC completed (read-only)
		40	BytesPerOop for this image
		41	imageFormatVersion for the VM
		42	number of stack pages in use (Cog Stack VM only, otherwise nil)
		43	desired number of stack pages (stored in image file header, max 65535; Cog VMs only, otherwise nil)
		44	size of eden, in bytes (Cog VMs only, otherwise nil)
		45	desired size of eden, in bytes (stored in image file header; Cog VMs only, otherwise nil)
		46	size of machine code zone, in bytes (stored in image file header; Cog JIT VM only, otherwise nil)
		47	desired size of machine code zone, in bytes (applies at startup only, stored in image file header; Cog JIT VM only)
		48	various properties stored in the image header (that instruct the VM) as an integer encoding an array of bit flags. 
			Bit 0: if set, tells the VM that the image's Process class has threadId as its 5th inst var 'threadAffinity' 
					(after nextLink, suspendedContext, priority & myList)
			Bit 1: on Cog JIT VMs asks the VM to set the flag bit in interpreted methods. This is useful when profiling a system to set the number
					of literals beyond which CompiledMethods are not jitted.
			Bit 2: if set, preempting does not yield. If not set, preempting a process puts it at the back of the run queue, yielding to all other
					process of the same priority. This was the Smalltalk-80 behavior, but it makes sharing structures between processes of 
					the same priority unnecesarily more complex.
			Bit 3: in a VM that supports muilt-threaded FFI, if set, the Window system will only be accessed from the first VM thread:
					'noThreadingOfGUIThread'
			Bit 4: in a Spur vm, if set, new finalization enabled. Enable for images with Ephemeron support.
					causes weaklings and ephemerons to be queued individually for finalization
			Bit 5: If set, wheel events will be delivered as such and not mapped to arrow key events.
					If unset, create fake keyboard events for wheel events. 
			Bit 6: See #doMixedArithmetic:
				If set, arithmetic primitives won't perform conversion in case of mixed SmallInteger/Float, and fail, letting the image decide what to do.
				If unset, the VM will make the conversion, meaning that `SmallInteger maxVal asFloat = SmallInteger maxVal` could evaluate to false.
			Bit 7: if set use the unix epoch for dates and times in files (FilePlugin / FileAttributesPlugin) / or is it about UTC???- If set UTC seconds from epoch, rather than local seconds
			Bit 8: if set upscaleDisplayIfHighDPI
		49	the size of the external semaphore table (read-write; Cog VMs only)
		50-51 reserved for VM parameters that persist in the image (such as eden above)
		52	root (remembered) table maximum size (read-only)
		53	the number of oldSpace segments (Spur only, otherwise nil)
		54	total size of free old space (Spur only, otherwise nil)
		55	ratio of growth and image size at or above which a GC will be performed post scavenge
		56	number of process switches since startup (read-only)
		57	number of ioProcessEvents calls since startup (read-only)
		58	number of forceInterruptCheck (Cog VMs) or quickCheckInterruptCalls (non-Cog VMs) calls since startup (read-only)
		59	number of check event calls since startup (read-only)
		60	number of stack page overflows since startup (read-only; Cog VMs only)
		61	number of stack page divorces since startup (read-only; Cog VMs only)
		62	number of machine code zone compactions since startup (read-only; Cog VMs only)
		63	milliseconds taken by machine code zone compactions since startup (read-only; Cog VMs only)
		64	current number of machine code methods (read-only; Cog VMs only)		
		65	In newer Cog VMs a set of flags describing VM features,
				if non-zero bit 0 implies multiple bytecode set support;
				if non-zero bit 1 implies read-only object support;
				if non-zero bit 2 implies the VM suffers from using an ITIMER heartbeat (if 0 it has a thread that provides the heartbeat)
			(read-only; Cog VMs only; nil in older Cog VMs, a boolean answering multiple bytecode support in not so old Cog VMs)
				if non-zero bit 3 implies the VM supports cross-platform BIT_IDENTICAL_FLOATING_POINT arithmetic
				if non-zero bit 4 implies the VM can catch exceptions in FFI calls and answer them as primitive failures
				if non-zero bit 5 implies the VM's suspend primitive backs up the process to before the wait if it was waiting on a condition variable
		66	the byte size of a stack page in the stack zone  (read-only; Cog VMs only)
		67	the maximum allowed size of old space in bytes, 0 implies no internal limit (Spur VMs only).
		68	the average number of live stack pages when scanned by GC (at scavenge/gc/become et al)
		69	the maximum number of live stack pages when scanned by GC (at scavenge/gc/become et al)
		70	the value of VM_PROXY_MAJOR (the interpreterProxy major version number)
		71	the value of VM_PROXY_MINOR (the interpreterProxy minor version number)
		72	total milliseconds in full GCs Mark phase since startup (read-only)
		73	total milliseconds in full GCs Sweep phase since startup (read-only, can be 0 depending on compactors)
		74	maximum pause time due to segment allocation
		75	whether arithmetic primitives will do mixed type arithmetic; if false they fail for different receiver and argument types
		76	the minimum unused headroom in all stack pages; Cog VMs only"

	<primitive: 254>
	(parameterIndex isInteger
	 and: [parameterIndex > 0]) ifTrue:
		[^nil].
	self primitiveFailed! !
!SystemDictionary methodsFor: 'vm parameters' library: #MinimalKernel01 stamp: 'jmv 11/9/2023 17:23:56' prior: 16971028!
   wordSize
	"Answer the size in bytes of an object pointer or word in the object memory.
	Smalltalk wordSize
	"

	^self vmParameterAt: 40! !
!Stream methodsFor: 'reading' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16967211!
      next
	"Answer the next object accessible by the receiver."

	self subclassResponsibility! !
!Stream methodsFor: 'writing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16967217!
                     nextPutAll: aCollection 
	"Append the elements of aCollection to the sequence of objects accessible 
	by the receiver. Answer aCollection."

	aCollection do: [:v | self nextPut: v].
	^aCollection! !
!Stream methodsFor: 'writing' library: #MinimalKernel01 stamp: 'djp 7/21/1998 11:40' prior: 16967226!
                   print: anObject
	anObject printOn: self! !
!Stream methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 12/9/2013 17:52' prior: 16967230!
             binary
	"Compatibility. If possible, store and retrieve bytes."
	self useBytes! !
!Stream methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 12/2/2010 08:37' prior: 16967546!
        is: aSymbol
	"Return true if the receiver responds to the stream protocol (if that's what's asked)"
	^ aSymbol == #Stream or: [ super is: aSymbol ]! !
!Stream methodsFor: 'nonhomogeneous accessing' library: #MinimalKernel01 stamp: 'jmv 9/5/2023 08:29:24' prior: 16967530!
                nextString
	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length."

	| bytes length |

	self binary.
	length := self next.		"first byte."
	length >= 192 ifTrue: [length := length - 192.
		1 to: 3 do: [:ii | length := length * 256 + self next]].
	bytes := ByteArray new: length.
	self nextInto: bytes.
	^bytes asString! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 20:26:41' prior: 16967236!
nextFloat32BigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'
	Float pi asIEEE32BitWord hex '16r40490FDB'
	Float pi negated asIEEE32BitWord hex '16rC0490FDB'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: false ])
			readStream nextFloat32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: true ])
			readStream nextFloat32BigEndian: true
	"
	| bytes |
	bytes := self next: 4.
	^ bytes float32At: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 20:28:46' prior: 16967258!
   nextFloat32Put: aFloat bigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'
	Float pi asIEEE32BitWord hex '16r40490FDB'
	Float pi negated asIEEE32BitWord hex '16rC0490FDB'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: false ]) hex 'DB0F4940'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: true ]) hex '40490FDB'
	"
	| bytes |
	bytes := ByteArray new: 4.
	bytes float32At: 1 put: aFloat bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/9/2025 11:59:30' prior: 16967280!
     nextFloat64BigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'

	(ByteArray streamContents: [ :strm |
		strm nextFloat64Put: Float pi bigEndian: false ])
			readStream nextFloat64BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextFloat64Put: Float pi bigEndian: true ])
			readStream nextFloat64BigEndian: true
	"
	| bytes |
	bytes := self next: 8.
	^ (bytes float64At: 1 bigEndian: bigEndian)
		+ 0.0 "Convert to SmallFloat64 if appropriate"! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:23:04' prior: 16967301!
                nextFloat64Put: aFloat bigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'

	(ByteArray streamContents: [ :strm |
		strm nextFloat64Put: Float pi bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextFloat64Put: Float pi bigEndian: true ]) hex
	"
	| bytes |
	bytes := ByteArray new: 8.
	bytes float64At: 1 put: aFloat bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:34:51' prior: 16967320!
                           nextInt16BigEndian: bigEndian
	"Answer the next  signed, 16-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextInt16Put: -12345 bigEndian: false ]) 
			readStream nextInt16BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextInt16Put: -12345 bigEndian: true ]) 
			readStream nextInt16BigEndian: true
	"
	| bytes |
	bytes := self next: 2.
	^ bytes int16At: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:35:32' prior: 16967337!
                           nextInt16Put: aNumber bigEndian: bigEndian
	"Store the given number as a signed, 16-bit integer on this (binary) stream.

	(16r10000-12345) hex '16rCFC7'

	(ByteArray streamContents: [ :strm |
		strm nextInt16Put: -12345 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextInt16Put: -12345 bigEndian: true ]) hex
	"
	| bytes |
	bytes := ByteArray new: 2.
	bytes int16At: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:36:17' prior: 16967354!
     nextInt32BigEndian: bigEndian
	"Answer the next signed, 32-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextInt32Put: -123456 bigEndian: false ]) 
			readStream nextInt32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextInt32Put: -123456 bigEndian: true ]) 
			readStream nextInt32BigEndian: true
	"
	| bytes |
	bytes := self next: 4.
	^ bytes int32At: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:36:30' prior: 16967371!
                          nextInt32Put: aNumber bigEndian: bigEndian
	"Store the given number as a signed, 32-bit integer on this (binary) stream.

	(16r100000000-123456) hex '16rFFFE1DC0'

	(ByteArray streamContents: [ :strm |
		strm nextInt32Put: -123456 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextInt32Put: -123456 bigEndian: true ]) hex
	"
	| bytes |
	bytes := ByteArray new: 4.
	bytes int32At: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/8/2023 17:37:04' prior: 16967389!
                          nextInt64BigEndian: bigEndian
	"Answer the next signed, 64-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextInt64Put: -1234567890123456789 bigEndian: false ]) 
			readStream nextInt64BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextInt64Put: -1234567890123456789 bigEndian: true ]) 
			readStream nextInt64BigEndian: true
	"
	| bytes |
	bytes := self next: 8.
	^ bytes int64At: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/8/2023 17:37:55' prior: 16967406!
nextInt64Put: aNumber bigEndian: bigEndian
	"Store the given number as a signed, 64-bit integer on this (binary) stream.

	(16r10000000000000000-1234567890123456789) hex '16rEEDDEF0B82167EEB' 

	(ByteArray streamContents: [ :strm |
		strm nextInt64Put: -1234567890123456789 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextInt64Put: -1234567890123456789 bigEndian: true ]) hex
	"
	| bytes |
	bytes := ByteArray new: 8.
	bytes int64At: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:37:24' prior: 16967425!
  nextUint16BigEndian: bigEndian
	"Answer the next unsigned, 16-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextUint16Put: 12345 bigEndian: false ]) 
			readStream nextUint16BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextUint16Put: 12345 bigEndian: true ]) 
			readStream nextUint16BigEndian: true
	"
	| bytes |
	bytes := self next: 2.
	^ bytes uint16At: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:37:38' prior: 16967442!
                      nextUint16Put: aNumber bigEndian: bigEndian
	"Store the given number as a unsigned, 16-bit integer on this (binary) stream.

	12345 hex  '16r3039'

	(ByteArray streamContents: [ :strm |
		strm nextUint16Put: 12345 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextUint16Put: 12345 bigEndian: true ]) hex
	"
	| bytes |
	bytes := ByteArray new: 2.
	bytes uint16At: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:38:20' prior: 16967459!
           nextUint32BigEndian: bigEndian
	"Answer the next unsigned, 32-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextUint32Put: 123456 bigEndian: false ]) 
			readStream nextUint32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextUint32Put: 123456 bigEndian: true ]) 
			readStream nextUint32BigEndian: true
	"
	| bytes |
	bytes := self next: 4.
	^ bytes uint32At: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/5/2023 17:38:44' prior: 16967476!
                    nextUint32Put: aNumber bigEndian: bigEndian
	"Store the given number as a unsigned, 32-bit integer on this (binary) stream.

	123456 hex '16r1E240'

	(ByteArray streamContents: [ :strm |
		strm nextUint32Put: 123456 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextUint32Put: 123456 bigEndian: true ]) hex
	"
	| bytes |
	bytes := ByteArray new: 4.
	bytes uint32At: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/8/2023 17:36:39' prior: 16967493!
        nextUint64BigEndian: bigEndian
	"Answer the next unsigned, 64-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextUint64Put: 1234567890123456789 bigEndian: false ]) 
			readStream nextUint64BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextUint64Put: 1234567890123456789 bigEndian: true ]) 
			readStream nextUint64BigEndian: true
	"
	| bytes |
	bytes := self next: 8.
	^ bytes uint64At: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' library: #MinimalKernel01 stamp: 'jmv 5/8/2023 17:36:03' prior: 16967511!
                          nextUint64Put: aNumber bigEndian: bigEndian
	"Store the given number as a unsigned, 64-bit integer on this (binary) stream.

	1234567890123456789 hex '16r112210F47DE98115' 

	(ByteArray streamContents: [ :strm |
		strm nextUint64Put: 1234567890123456789 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextUint64Put: 1234567890123456789 bigEndian: true ]) hex
	"
	| bytes |
	bytes := ByteArray new: 8.
	bytes uint64At: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!PositionableStream methodsFor: 'positioning' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16934917!
             position
	"Answer the current position of accessing the stream."
	^position! !
!PositionableStream methodsFor: 'positioning' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16934923!
                       position: anInteger 
	"Set position to anInteger as long as anInteger is within the bounds of the 
	receiver's contents.  If it is not, cause an error."

	anInteger >= 0 & (anInteger <= readLimit)
		ifTrue: [position := anInteger]
		ifFalse: [self positionError]! !
!PositionableStream methodsFor: 'positioning' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16934935!
                       reset
	"Set the receiver's position to the beginning of the sequence of objects."

	position := 0! !
!PositionableStream methodsFor: 'private' library: #MinimalKernel01 stamp: 'jmv 5/22/2022 18:43:45' prior: 16934941!
      on: aCollection
	"Initialize the stream to read over all of aCollection.
	The collection is considered to have useful content."

	collection := aCollection.
	readLimit := aCollection size.
	position := 0.
	self reset.! !
!PositionableStream methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'nice 11/22/2009 18:10' prior: 16934872!
             next: anInteger 
	"Answer the next anInteger elements of my collection. Must override 
	because default uses self contents species, which might involve a large 
	collection."

	| newArray |
	newArray := self collectionSpecies new: anInteger.
	1 to: anInteger do: [:index | newArray at: index put: self next].
	^newArray! !
!PositionableStream methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 3/1/2010 13:10' prior: 16934885!
          next: n into: aCollection startingAt: startIndex
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."
	| obj |
	0 to: n-1 do: [ :i |
		(obj := self next) ifNil: [ ^aCollection copyFrom: 1 to: startIndex+i-1 ].
		aCollection at: startIndex+i put: obj].
	^aCollection! !
!PositionableStream methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ar 12/23/1999 14:53' prior: 16934899!
                       nextInto: aCollection
	"Read the next elements of the receiver into aCollection.
	Return aCollection or a partial copy if less than aCollection
	size elements have been read."
	^self next: aCollection size into: aCollection startingAt: 1.! !
!PositionableStream methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16934910!
                 originalContents
	"Answer the receiver's actual contents collection, NOT a copy.  1/29/96 sw"

	^ collection! !
!PositionableStream methodsFor: 'mode' library: #MinimalKernel01 stamp: 'jmv 9/12/2023 12:30:15' prior: 16934951!
                              useBytes
	collection class = ByteArray ifFalse: [
		self error: 'Can not #useBytes' ]! !
!PositionableStream class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16935641!
 on: aCollection 
	"Answer a new instance of me, streaming over aCollection."

	^self basicNew on: aCollection! !
!ReadStream methodsFor: 'reading' library: #MinimalKernel01 stamp: 'jmv 11/17/2016 09:59:57' prior: 16943280!
 next
	"Answer the next object in the Stream represented by the receiver."

	^position >= readLimit
		ifFalse: [collection at: (position := position + 1)]! !
!ReadStream methodsFor: 'reading' library: #MinimalKernel01 stamp: 'ls 8/16/1998 00:46' prior: 16943288!
                          next: anInteger 
	"Answer the next anInteger elements of my collection.  overriden for efficiency"

	| ans endPosition |

	endPosition := position + anInteger  min:  readLimit.
	ans := collection copyFrom: position+1 to: endPosition.
	position := endPosition.
	^ans
! !
!ReadStream methodsFor: 'reading' library: #MinimalKernel01 stamp: 'ar 12/23/1999 15:01' prior: 16943299!
        next: n into: aCollection startingAt: startIndex
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."
	| max |
	max := (readLimit - position) min: n.
	aCollection 
		replaceFrom: startIndex 
		to: startIndex+max-1
		with: collection
		startingAt: position+1.
	position := position + max.
	max = n
		ifTrue:[^aCollection]
		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !
!ReadStream methodsFor: 'writing' library: #MinimalKernel01 stamp: 'jmv 5/28/2022 17:16:40' prior: 16943316!
             nextPutAll: aCollection
	self shouldNotImplement! !
!WriteStream methodsFor: 'reading' library: #MinimalKernel01 stamp: 'jmv 5/31/2022 15:27:30' prior: 17019394!
                              contents
	readLimit := readLimit max: position.
	^(collection copyFrom: 1 to: position) asStreamResult! !
!WriteStream methodsFor: 'reading' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 17019400!
       next
	self shouldNotImplement! !
!WriteStream methodsFor: 'reading' library: #MinimalKernel01 stamp: 'jmv 5/30/2022 10:57:04' prior: 17019404!
                 next: n
	self isWriteOnly ifTrue: [
		self error: 'This is a Write-Only Stream' ].
	^super next: n! !
!WriteStream methodsFor: 'writing' library: #MinimalKernel01 stamp: 'jmv 5/30/2022 10:58:13' prior: 17019410!
            next: n into: aCollection startingAt: startIndex
	self isWriteOnly ifTrue: [
		self error: 'This is a Write-Only Stream' ].
	^super next: n into: aCollection startingAt: startIndex! !
!WriteStream methodsFor: 'writing' library: #MinimalKernel01 stamp: 'jmv 1/8/2024 11:58:03' prior: 17019419!
                           nextPut: anObject 
	"Insert the argument at the next position in the Stream represented by the receiver."

	(anObject isCharacter and: [anObject codePoint > 255 and: [collection canHoldAnyCodePoint not]]) ifTrue: [
		collection := collection thatCanHoldAnyCodePoint ].
	position >= writeLimit
		ifTrue: [^ self pastEndPut: anObject]
		ifFalse: [
			position := position + 1.
			^collection at: position put: anObject].! !
!WriteStream methodsFor: 'writing' library: #MinimalKernel01 stamp: 'jmv 1/8/2024 11:55:05' prior: 17019435!
             nextPutAll: aCollection

	| newEnd |
	(aCollection canHoldAnyCodePoint and: [collection canHoldAnyCodePoint not]) ifTrue: [
		collection := collection thatCanHoldAnyCodePoint ].
	(self isCompatibleWithContents: aCollection)
		ifFalse: [ ^ super nextPutAll: aCollection ].

	newEnd := position + aCollection size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.
	position := newEnd.! !
!WriteStream methodsFor: 'writing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 17019453!
                  space
	"Append a space character to the receiver."

	self nextPut: Character space! !
!WriteStream methodsFor: 'positioning' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 17019459!
                       position: anInteger 
	readLimit := readLimit max: position.
	super position: anInteger! !
!WriteStream methodsFor: 'positioning' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 17019465!
                   reset
	readLimit := readLimit max: position.
	position := 0! !
!WriteStream methodsFor: 'private' library: #MinimalKernel01 stamp: 'jmv 6/6/2022 10:33:40' prior: 17019470!
                    isCompatibleWithContents: aCollection

	collection class == aCollection class
		ifTrue: [ ^ true ].

	(aCollection isByteString and: [ (collection is: #Text) or: [ collection is: #ArrayOfCharactersAndCodePoints ]])
		ifTrue: [ ^ true ].

	^ false! !
!WriteStream methodsFor: 'private' library: #MinimalKernel01 stamp: 'jmv 7/7/2022 10:44:06' prior: 17019481!
                         on: aCollection
	"Initialize the stream to write over all of aCollection.
	The collection contents are considered useless (most likely nil).
	Overwrite them.
	In the case of ReadWriteStream, for read operations, stream appears empty until stuff is added."

	super on: aCollection thatCanBeModified.
	readLimit := 0.
	writeLimit := aCollection size! !
!StdIOWriteStream methodsFor: 'streaming' library: #MinimalKernel01 stamp: 'jmv 11/17/2016 10:19:51' prior: 16966956!
           flush
	"Flush pending changes"
	^self primFlush: fileID! !
!StdIOWriteStream methodsFor: 'streaming' library: #MinimalKernel01 stamp: 'jmv 4/21/2022 14:10:29' prior: 16966961!
                nextPut: aCharacter
	"Write the given character or byte to this file.
		 StdIOWriteStream stdout nextPut: $a; flush.
	"
	self nextPutAll: (String with: aCharacter).
	^aCharacter! !
!StdIOWriteStream methodsFor: 'streaming' library: #MinimalKernel01 stamp: 'jmv 10/26/2022 15:55:49' prior: 16966970!
                     nextPutAll: aStringOrUTF8Bytes
	"Write the given String  or ByteArray (with utf-8 contents)
		 StdIOWriteStream stdout nextPutAll: '--- &#16r2713; ==='; flush.
		 StdIOWriteStream stdout nextPutAll: '--- &#10003; ==='; flush.
		 StdIOWriteStream stdout nextPutAll: #[226 156 147]; flush.
		StdIOWriteStream stdout nextPutAll: '¿El Ñandú toma agüita?', String newLineString; flush.
		StdIOWriteStream stdout nextPutAll: ('¿El Ñandú toma agüita?', String newLineString) asUtf8 ; flush.
	See at the end of this method for a larger example with NCRs for arbitrary Unicode
	"
	| utf8Bytes |
	utf8Bytes := aStringOrUTF8Bytes isString
		ifTrue: [ aStringOrUTF8Bytes asUtf8Bytes ]
		ifFalse: [ aStringOrUTF8Bytes ].
	self primWrite: fileID from: utf8Bytes startingAt: 1 count: utf8Bytes size.
	^aStringOrUTF8Bytes
"
StdIOWriteStream stdout nextPutAll: 'Лорем ипсум долор сит амет, дебет салутанди меи еи. Ан хис граеце утамур долорум, лорем принципес молестиае дуо ин. Еи мовет ностро оптион нам, еос епицури омиттантур ут. Ут мунере лаборе интеллегебат усу, еа сед дебет луптатум, видит иллуд иудицо яуо ут.'; flush
"! !
!StdIOWriteStream methodsFor: 'character writing' library: #MinimalKernel01 stamp: 'jmv 11/17/2016 10:48:18' prior: 16967015!
                   newLine
	"Append a newLine character to the receiver.
	The Cuis convention is to use lf on output."

	self nextPut: Character newLineCharacter! !
!StdIOWriteStream methodsFor: 'character writing' library: #MinimalKernel01 stamp: 'jmv 11/17/2016 11:08:02' prior: 16967023!
                space
	"Append a space character to the receiver."

	self nextPut: Character space! !
!StdIOWriteStream methodsFor: 'open / close' library: #MinimalKernel01 stamp: 'jmv 9/16/2019 13:47:35' prior: 16967029!
                  openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID := aFileID.
	name := streamName.! !
!StdIOWriteStream methodsFor: 'primitives' library: #MinimalKernel01 stamp: 'jmv 11/17/2016 10:20:17' prior: 16967042!
     primFlush: id
	"Flush pending changes to the disk"

	<primitive: 'primitiveFileFlush' module: 'FilePlugin'>! !
!StdIOWriteStream methodsFor: 'primitives' library: #MinimalKernel01 stamp: 'jmv 4/29/2025 17:01:32' prior: 16967049!
                           primWrite: id from: stringOrByteArray startingAt: startIndex count: count
	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."

	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>
	self error: 'StdIOWriteStream [', name, '] write failed'.! !
!StdIOWriteStream methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 11/17/2016 09:35:56' prior: 16967062!
 printOn: aStream
	"Put a printed version of the receiver onto aStream.  1/31/96 sw"

	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !
!StdIOWriteStream class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 11/17/2016 11:46:37' prior: 16967076!
stdout
	StdOut ifNil: [
		StdOut := self basicNew.
		StdOut 
			openOnHandle: self stdoutHandle 
			name: 'stdout' ].
	^StdOut! !
!StdIOWriteStream class methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 11/17/2016 09:26:09' prior: 16967083!
  stdioHandles
" answer handles: #(stdin stdout stderr) "
	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: ec>
	self primitiveFailed! !
!StdIOWriteStream class methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 11/17/2016 09:26:12' prior: 16967091!
          stdoutHandle

	^ self stdioHandles at: 2! !
!AdditionalMethodState methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 7/4/2023 16:01:43' prior: 16780624!
                             isMethodProperties
	"AdditionalMethodState holds
		Pragmas
		Method Properties (in the form of Associations)
	if any CompiledMethod needs them."

	^true! !
!AdditionalMethodState methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'md 2/16/2006 17:50' prior: 16780632!
              selector
	^selector! !
!BlockClosure methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'eem 5/24/2008 11:21' prior: 16793242!
                           outerContext
	^outerContext! !
!BlockClosure methodsFor: 'evaluating' library: #MinimalKernel01 stamp: 'eem 10/29/2024 15:16:35' prior: 16793246!
              value
	"Activate the receiver, creating a closure activation (MethodContext)
	 whose closure is the receiver and whose caller is the sender of this
	 message. Supply the copied values to the activation as its copied
	 temps. Primitive. Essential."
	<primitive: 201>

	numArgs ~= 0 ifTrue:
		[self numArgsError: 0].
	self primitiveFailed.! !
!BlockClosure methodsFor: 'evaluating' library: #MinimalKernel01 stamp: 'eem 10/29/2024 15:14:58' prior: 16793260!
                        value: firstArg
	"Activate the receiver, creating a closure activation (MethodContext)
	 whose closure is the receiver and whose caller is the sender of this
	 message. Supply the argument and copied values to the activation
	 as its argument and copied temps. Primitive. Essential."
	<primitive: 202>
	
	numArgs ~= 1 ifTrue:
		[self numArgsError: 1].
	self primitiveFailed.! !
!BlockClosure methodsFor: 'evaluating' library: #MinimalKernel01 stamp: 'eem 10/29/2024 15:16:47' prior: 16793275!
                   value: firstArg value: secondArg
	"Activate the receiver, creating a closure activation (MethodContext)
	 whose closure is the receiver and whose caller is the sender of this
	 message. Supply the arguments and copied values to the activation
	 as its arguments and copied temps. Primitive. Essential."
	<primitive: 203>

	numArgs ~= 2 ifTrue:
		[self numArgsError: 2].
	self primitiveFailed.! !
!BlockClosure methodsFor: 'evaluating' library: #MinimalKernel01 stamp: 'eem 10/29/2024 15:15:51' prior: 16793290!
 value: firstArg value: secondArg value: thirdArg
	"Activate the receiver, creating a closure activation (MethodContext)
	 whose closure is the receiver and whose caller is the sender of this
	 message. Supply the arguments and copied values to the activation
	 as its arguments and copied temps. Primitive. Essential."
	<primitive: 204>
	
	numArgs ~= 3 ifTrue:
		[self numArgsError: 3].
	self primitiveFailed.! !
!BlockClosure methodsFor: 'evaluating' library: #MinimalKernel01 stamp: 'eem 8/22/2008 14:21' prior: 16793306!
                    valueNoContextSwitch
	"An exact copy of BlockClosure>>value except that this version will not preempt
	 the current process on block activation if a higher-priority process is runnable.
	 Primitive. Essential."
	<primitive: 221>
	numArgs ~= 0 ifTrue:
		[self numArgsError: 0].
	self primitiveFailed! !
!BlockClosure methodsFor: 'evaluating' library: #MinimalKernel01 stamp: 'jmv 8/29/2010 18:33' prior: 16793318!
   valueWithPossibleArgument: anArg 
	"Evaluate the block represented by the receiver. 
	 If the block requires one argument, use anArg"

	numArgs = 0 ifTrue: [ ^self value ].
	^self value: anArg! !
!BlockClosure methodsFor: 'exceptions' library: #MinimalKernel01 stamp: 'ar 12/4/2009 18:30' prior: 16793327!
              ensure: aBlock
	"Evaluate a termination block after evaluating the receiver, regardless of
	 whether the receiver's evaluation completes.  N.B.  This method is *not*
	 implemented as a primitive.  Primitive 198 always fails.  The VM uses prim
	 198 in a context's method as the mark for an ensure:/ifCurtailed: activation."

	| complete returnValue |
	<primitive: 198>
	returnValue := self valueNoContextSwitch.
	complete ifNil:[
		complete := true.
		aBlock value.
	].
	^ returnValue! !
!BlockClosure methodsFor: 'printing' library: #MinimalKernel01 stamp: 'eem 5/24/2008 11:23' prior: 16793345!
           printOn: aStream
	aStream nextPutAll: '[closure] in '.
	outerContext printOn: aStream! !
!ContextPart methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'eem 6/27/2008 15:55' prior: 16837757!
                          at: index
	"Primitive. Assumes receiver is indexable. Answer the value of an
	 indexable element in the receiver. Fail if the argument index is not an
	 Integer or is out of bounds. Essential. See Object documentation
	 whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	<primitive: 210>
	index isInteger ifTrue:
		[self errorSubscriptBounds: index].
	index isNumber
		ifTrue: [^self at: index asInteger]
		ifFalse: [self errorNonIntegerIndex]! !
!ContextPart methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'eem 6/27/2008 15:57' prior: 16837775!
                              at: index put: value
	"Primitive. Assumes receiver is indexable. Answer the value of an
	 indexable element in the receiver. Fail if the argument index is not
	 an Integer or is out of bounds. Essential. See Object documentation
	 whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	<primitive: 211>
	index isInteger ifTrue:
		[self errorSubscriptBounds: index].
	index isNumber
		ifTrue: [^self at: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]! !
!ContextPart methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'eem 6/27/2008 15:56' prior: 16837794!
        basicAt: index
	"Primitive. Assumes receiver is indexable. Answer the value of an
	 indexable element in the receiver. Fail if the argument index is not an
	 Integer or is out of bounds. Essential. See Object documentation
	 whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	<primitive: 210>
	index isInteger ifTrue:
		[self errorSubscriptBounds: index].
	index isNumber
		ifTrue: [^self at: index asInteger]
		ifFalse: [self errorNonIntegerIndex]! !
!ContextPart methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'eem 6/27/2008 15:57' prior: 16837813!
                         basicAt: index put: value
	"Primitive. Assumes receiver is indexable. Answer the value of an
	 indexable element in the receiver. Fail if the argument index is not
	 an Integer or is out of bounds. Essential. See Object documentation
	 whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	<primitive: 211>
	index isInteger ifTrue:
		[self errorSubscriptBounds: index].
	index isNumber
		ifTrue: [^self at: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]! !
!ContextPart methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'eem 9/17/2014 17:13' prior: 16837832!
   basicSize
	"Primitive. Answer the number of indexable variables in the receiver. 
	This value is the same as the largest legal subscript. Essential. Do not 
	override in any subclass. See Object documentation whatIsAPrimitive.  Override the default primitive to give latitude to
	 the VM in context management."

	<primitive: 212>
	"The number of indexable fields of fixed-length objects is 0"
	^self primitiveFailed! !
!ContextPart methodsFor: 'debugger access' library: #MinimalKernel01 stamp: 'eem 11/27/2014 13:11' prior: 16837848!
        methodClass 
	"Answer the class in which the receiver's method was found."
	
	^self method methodClass ifNil: [self objectClass: self receiver].! !
!ContextPart methodsFor: 'debugger access' library: #MinimalKernel01 stamp: 'md 2/17/2006 18:47' prior: 16837856!
                          selector
	"Answer the selector of the method that created the receiver."

	^self method selector ifNil: [self method defaultSelector].! !
!ContextPart methodsFor: 'debugger access' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16837863!
                               sender
	"Answer the context that sent the message that created the receiver."

	^sender! !
!ContextPart methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 9/4/2023 18:56:01' prior: 16837869!
                       printOn: aStream 
	| selector class mclass |
	self method
		ifNil: [^ super printOn: aStream].
	class := self receiver class.
	mclass := self methodClass.
	selector := self selector ifNil: [ self method defaultSelector].
	class printNameOn: aStream.
	mclass == class 
		ifFalse: [
			aStream nextPut: $(.
			mclass printNameOn: aStream.
			aStream nextPut: $)].
	aStream nextPutAll: '>>'.
	aStream nextPutAll: selector.
	selector == #doesNotUnderstand: ifTrue: [
		aStream space.
		(self tempAt: 1) selector printOn: aStream.
	].
! !
!MethodContext methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16905625!
                       method
	^method! !
!MethodContext methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'jmv 3/1/2010 11:40' prior: 16905628!
                               outerContext
	"Answer the context within which the receiver is nested."

	^ closureOrNil
		ifNotNil: [closureOrNil outerContext]! !
!MethodContext methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16905635!
         receiver
	^receiver! !
!MethodContext methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'eem 8/20/2008 09:28' prior: 16905639!
                          tempAt: index 
	"Answer the value of the temporary variable whose index is the 
	 argument, index.  Primitive. Assumes receiver is indexable. Answer the
	 value of an indexable element in the receiver. Fail if the argument index
	 is not an Integer or is out of bounds. Essential. See Object documentation
	 whatIsAPrimitive.  Override the default at: primitive to give latitude to the
	 VM in context management."

	<primitive: 210>
	^self at: index! !
!MethodContext methodsFor: 'printing' library: #MinimalKernel01 stamp: 'eem 5/27/2008 17:23' prior: 16905656!
            printOn: aStream

	self outerContext
		ifNil: [super printOn: aStream]
		ifNotNil:
			[:outerContext|
			 aStream nextPutAll: '[] in '.
			 outerContext printOn: aStream]! !
!Message methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16901513!
     selector
	"Answer the selector of the receiver."
	^selector! !
!Boolean methodsFor: 'logical operations' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16795966!
           & aBoolean 
	"Evaluating conjunction -- Evaluate the argument.  Then answer true if both the
	receiver and the argument are true."
	self subclassResponsibility! !
!Boolean methodsFor: 'logical operations' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16795974!
       | aBoolean 
	"Evaluating disjunction (OR) -- Evaluate the argument.  Then answer true if
	either the receiver or the argument is true."
	self subclassResponsibility! !
!Boolean methodsFor: 'logical operations' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16795982!
  not
	"Negation-- answer true if the receiver is false, answer false if the receiver is true."
	self subclassResponsibility! !
!Boolean methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jpb 8/3/2019 00:11:00' prior: 16795989!
                         is: aSymbol
	^#Boolean = aSymbol or: [ super is: aSymbol ]! !
!Boolean methodsFor: 'copying' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16795994!
                       shallowCopy 
	"Receiver has two concrete subclasses, True and False.
	Only one instance of each should be made, so return self."! !
!False methodsFor: 'logical operations' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16864768!
        & alternativeObject 
	"Evaluating conjunction -- answer false since receiver is false."

	^self! !
!False methodsFor: 'logical operations' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16864774!
         | aBoolean 
	"Evaluating disjunction (OR) -- answer with the argument, aBoolean."

	^aBoolean! !
!False methodsFor: 'logical operations' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16864780!
           not
	"Negation -- answer true since the receiver is false."

	^true! !
!False methodsFor: 'printing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16864785!
               printOn: aStream 
	"Print false."
	aStream nextPutAll: 'false'! !
!True methodsFor: 'logical operations' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16999448!
           & alternativeObject 
	"Evaluating conjunction -- answer alternativeObject since receiver is true."

	^alternativeObject! !
!True methodsFor: 'logical operations' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16999455!
                  | aBoolean 
	"Evaluating disjunction (OR) -- answer true since the receiver is true."

	^self! !
!True methodsFor: 'logical operations' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16999461!
            not
	"Negation--answer false since the receiver is true."

	^false! !
!True methodsFor: 'printing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16999466!
                 printOn: aStream 
	aStream nextPutAll: 'true'! !
!Magnitude methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899545!
< aMagnitude 
	"Compare the receiver with the argument and answer with true if the 
	receiver is less than the argument. Otherwise answer false."

	^self subclassResponsibility! !
!Magnitude methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899553!
                             <= aMagnitude 
	"Compare the receiver with the argument and answer with true if the 
	receiver is less than or equal to the argument. Otherwise answer false."

	^(self > aMagnitude) not! !
!Magnitude methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899562!
                    = aMagnitude 
	"Compare the receiver with the argument and answer with true if the 
	receiver is equal to the argument. Otherwise answer false."

	^self subclassResponsibility! !
!Magnitude methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899570!
                              > aMagnitude 
	"Compare the receiver with the argument and answer with true if the 
	receiver is greater than the argument. Otherwise answer false."

	^aMagnitude < self! !
!Magnitude methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'nice 12/31/2008 04:06' prior: 16899578!
      >= aMagnitude 
	"Answer whether the receiver is greater than or equal to the argument."

	^aMagnitude <= self! !
!Magnitude methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899584!
between: min and: max 
	"Answer whether the receiver is less than or equal to the argument, max,
	and greater than or equal to the argument, min."

	^self >= min and: [self <= max]! !
!Magnitude methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899593!
                         hash
	"Hash must be redefined whenever = is redefined."

	^self subclassResponsibility! !
!Magnitude methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899599!
                       max: aMagnitude 
	"Answer the receiver or the argument, whichever has the greater magnitude."

	self > aMagnitude
		ifTrue: [^self]
		ifFalse: [^aMagnitude]! !
!Magnitude methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899607!
                 min: aMagnitude 
	"Answer the receiver or the argument, whichever has the lesser magnitude."

	self < aMagnitude
		ifTrue: [^self]
		ifFalse: [^aMagnitude]! !
!Number methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'jmv 11/11/2014 10:23' prior: 16919757!
                       // aNumber
	"Integer division with truncation toward negative infinity. 
	9//4 = 2
	-9//4 = -3
	-0.9//0.4 = -3
	#\\ answers the remainder from this division.
	See #//, #quo:, #div:"

	^ (self / aNumber) floor! !
!Number methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'jmv 5/12/2022 16:59:55' prior: 16919766!
\\ divisor
	"Modulo operation. Remainder of the integer division #// (Floored division, truncated to minus infinity, a.k.a Knuth's division)
	Answer a Number with the same sign as divisor. 
	9\\4 = 1
	-9\\4 = 3
	9\\ -4 = -3
	0.9\\0.4 = 0.1
	See http://en.wikipedia.org/wiki/Modulo_operation
	See #\\, #rem: and #mod:
	See detailed discussion at http://mathforum.org/library/drmath/view/52343.html
	"

	^self - (self // divisor * divisor)

	"Evaluate the following:"
"
Compiler evaluate: '
	| g d |
	d := 1.
	Feature require: ''Morphic-Widgets-Extras''.
	g := FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x \\ d ] color: Color green.
	g addFunction: [ :x | x // d ] color: Color red.
	g openInWorld'
"
"
Compiler evaluate: '
	| g d |
	d := -1.
	Feature require: ''Morphic-Widgets-Extras''.
	g := FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x \\ d ] color: Color green.
	g addFunction: [ :x | x // d ] color: Color red.
	g openInWorld'
"! !
!Number methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16919800!
                     abs
	"Answer a Number that is the absolute value (positive magnitude) of the receiver."

	self < 0
		ifTrue: [^self negated]
		ifFalse: [^self]! !
!Number methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16919807!
negated
	"Answer a Number that is the negation of the receiver."
	^0 - self! !
!Number methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/11/2019 11:41:36' prior: 16919812!
      = aNumber
	"Note: Consistency between #= and #hash for numeric classes is not done in the usual way (redefining them together), because we also need #= and #hash consistency across numeric classes:
	(3 = 3.0) ifTrue: [3 hash = 3.0 hash]
	Therefore, consistency between #= and #hash for numeric classes is validated by specific tests"

	^self subclassResponsibility! !
!Number methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/11/2019 11:41:27' prior: 16919826!
     hash
	"Note: Consistency between #= and #hash for numeric classes is not done in the usual way (redefining them together), because we also need #= and #hash consistency across numeric classes:
	(3 = 3.0) ifTrue: [3 hash = 3.0 hash]
	Therefore, consistency between #= and #hash for numeric classes is validated by specific tests"

	^self subclassResponsibility! !
!Number methodsFor: 'mathematical functions' library: #MinimalKernel01 stamp: 'jmv 8/2/2019 11:47:20' prior: 16919840!
                              raisedToInteger: exponent
	"The 0 raisedToInteger: 0 is an special case. In some contexts must be 1 and in others must
	be handled as an indeterminate form.
	Maybe further discussion is required on this topic."
	
	| bitProbe result |

	exponent negative ifTrue: [^self raisedToNegativeInteger: exponent ].
	exponent = 0 ifTrue: [^ self class one].
	exponent = 1 ifTrue: [^ self].

	bitProbe := 1 bitShift: exponent highBit - 1.
 	result := self class one.
 	[
		(exponent bitAnd: bitProbe) = 0 ifFalse: [result := result * self].
		bitProbe := bitProbe bitShift: -1.
		bitProbe > 0 ]
			whileTrue: [
				result := result * result].
	^result! !
!Number methodsFor: 'truncation and round off' library: #MinimalKernel01 stamp: 'wiz 5/29/2011 17:54' prior: 16919863!
     ceiling
	"Answer the integer nearest the receiver toward  infinity."

	| truncation |
	truncation := self truncated.
	self <= 0 ifTrue: [^truncation].
	self = truncation
		ifTrue: [^truncation]
		ifFalse: [^truncation + 1]! !
!Number methodsFor: 'truncation and round off' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16919873!
   floor
	"Answer the integer nearest the receiver toward negative infinity."

	| truncation |
	truncation := self truncated.
	self >= 0 ifTrue: [^truncation].
	self = truncation
		ifTrue: [^truncation]
		ifFalse: [^truncation - 1]! !
!Number methodsFor: 'converting' library: #MinimalKernel01 stamp: 'di 11/6/1998 13:44' prior: 16919883!
                adaptToInteger: rcvr andSend: selector
	"If I am involved in arithmetic with a Integer, convert us and evaluate exprBlock."
	^ self subclassResponsibility! !
!Number methodsFor: 'converting' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16919891!
                     asInteger
	"Answer an integer nearest the receiver toward zero."
	^self truncated! !
!Number methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jpb 8/2/2019 23:58:01' prior: 16919896!
   is: aSymbol
	"Note: Senders might prefer #isNumber for perfomance reasons. Still, Cuis tries to keep isXXX testing selectors to a minimum."
	^#Number = aSymbol or: [ super is: aSymbol]! !
!Number methodsFor: 'testing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16919905!
                     isNumber
	^ true! !
!Number methodsFor: 'testing' library: #MinimalKernel01 stamp: '' prior: 16919907!
                         isZero
	^self = 0! !
!Number methodsFor: 'testing' library: #MinimalKernel01 stamp: 'di 4/23/1998 11:18' prior: 16919910!
      negative
	"Answer whether the receiver is mathematically negative."

	^ self < 0! !
!Number methodsFor: 'intervals' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16919916!
                           to: stop do: aBlock 
	"Normally compiled in-line, and therefore not overridable.
	Evaluate aBlock for each element of the interval (self to: stop by: 1)."
	| nextValue |
	nextValue := self.
	[nextValue <= stop]
		whileTrue: 
			[aBlock value: nextValue.
			nextValue := nextValue + 1]! !
!Number methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 1/5/2014 19:55' prior: 16919928!
                          printString

	^String streamContents: [:str | self printOn: str base: 10]! !
!Number class methodsFor: 'constants' library: #MinimalKernel01 stamp: 'GabrielOmarCotelli 5/23/2009 20:46' prior: 16921095!
                      one

	^1! !
!Integer methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'jmv 12/24/2011 08:43' prior: 16891371!
         * aNumber
	"Refer to the comment in Number * " 
	aNumber isInteger ifTrue: [
		^ self
			digitMultiply: aNumber
			neg: (self negative xor: aNumber negative) ].
	^ aNumber adaptToInteger: self andSend: #*! !
!Integer methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'di 11/6/1998 13:59' prior: 16891380!
       + aNumber
	"Refer to the comment in Number + "
	aNumber isInteger ifTrue:
		[self negative == aNumber negative
			ifTrue: [^ (self digitAdd: aNumber) normalize]
			ifFalse: [^ self digitSubtract: aNumber]].
	^ aNumber adaptToInteger: self andSend: #+! !
!Integer methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'di 11/6/1998 13:59' prior: 16891391!
                         - aNumber
	"Refer to the comment in Number - "
	aNumber isInteger ifTrue:
		[self negative == aNumber negative
			ifTrue: [^ self digitSubtract: aNumber]
			ifFalse: [^ (self digitAdd: aNumber) normalize]].
	^ aNumber adaptToInteger: self andSend: #-! !
!Integer methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'jmv 8/1/2019 17:26:46' prior: 16891402!
                      // aNumber 
	| q |
	aNumber = 0 ifTrue: [^ ZeroDivide new signalReceiver: self selector: #// argument: aNumber].
	aNumber isInteger ifFalse: [ ^super // aNumber ].
	self = 0 ifTrue: [^ 0].
	q := self quo: aNumber.
	"Refer to the comment in Number>>#//."
	^(q negative
		ifTrue: [q * aNumber ~= self]
		ifFalse: [q = 0 and: [self negative ~= aNumber negative]])
			ifTrue: [q - 1"Truncate towards minus infinity."]
			ifFalse: [q]! !
!Integer methodsFor: 'bit manipulation' library: #MinimalKernel01 stamp: 'sqr 1/26/2014 13:38' prior: 16891513!
                               highBit
	"Answer the index of the high order bit of the receiver, or zero if the  
	receiver is zero. Raise an error if the receiver is negative, since  
	negative integers are defined to have an infinite number of leading 1's 
	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to 
	get the highest bit of the magnitude."
	self < 0 ifTrue: [^ self error: 'highBit is not defined for negative integers'].
	^ self highBitOfMagnitude! !
!Integer methodsFor: 'bit manipulation' library: #MinimalKernel01 stamp: 'jmv 12/4/2018 11:59:58' prior: 16891530!
         highBitOfMagnitude
	"Answer the position of the leading bit or zero if the  
	receiver is zero. Receiver has to be positive!!"

	| shifted bitNo |
	shifted := self < 0 ifTrue: [0 - self] ifFalse: [self].
	bitNo := 0.
	[shifted < 65536]
		whileFalse: 
			[shifted := shifted bitShift: -16.
			bitNo := bitNo + 16].
	shifted < 256
		ifFalse: 
			[shifted := shifted bitShift: -8.
			bitNo := bitNo + 8].
		
	"The high bits table can be obtained with:
	(1 to: 8) inject: #[0] into: [:highBits :rank | highBits , (highBits collect: [:e | rank])]."
	^bitNo + ( #[0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8] at: shifted + 1)! !
!Integer methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'di 11/6/1998 14:00' prior: 16891418!
                     < aNumber
	aNumber isInteger ifTrue:
		[self negative == aNumber negative
			ifTrue: [self negative
						ifTrue: [^ (self digitCompare: aNumber) > 0]
						ifFalse: [^ (self digitCompare: aNumber) < 0]]
			ifFalse: [^ self negative]].
	^ aNumber adaptToInteger: self andSend: #<! !
!Integer methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 9/1/2010 10:19' prior: 16891429!
                             <= aNumber
	aNumber isInteger ifTrue:
		[self negative == aNumber negative
			ifTrue: [self negative
						ifTrue: [^ (self digitCompare: aNumber) >= 0]
						ifFalse: [^ (self digitCompare: aNumber) <= 0]]
			ifFalse: [^ self negative]].
	^ aNumber adaptToInteger: self andSend: #<=! !
!Integer methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 5/27/2014 11:04' prior: 16891441!
                        = aNumber

	"Any object is equal to itself"
	self == aNumber ifTrue: [ ^ true ].

	aNumber isNumber ifFalse: [^ false].
	aNumber isInteger ifTrue: [
		aNumber class == self class ifFalse: [ ^false ].
		^ (self digitCompare: aNumber) = 0].
	^ aNumber adaptToInteger: self andSend: #=! !
!Integer methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'di 11/6/1998 14:00' prior: 16891453!
                          > aNumber
	aNumber isInteger ifTrue:
		[self negative == aNumber negative
			ifTrue: [self negative
						ifTrue: [^(self digitCompare: aNumber) < 0]
						ifFalse: [^(self digitCompare: aNumber) > 0]]
			ifFalse: [^ aNumber negative]].
	^ aNumber adaptToInteger: self andSend: #>! !
!Integer methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 9/1/2010 10:19' prior: 16891464!
                            >= aNumber
	aNumber isInteger ifTrue:
		[self negative == aNumber negative
			ifTrue: [self negative
						ifTrue: [^(self digitCompare: aNumber) <= 0]
						ifFalse: [^(self digitCompare: aNumber) >= 0]]
			ifFalse: [^ aNumber negative]].
	^ aNumber adaptToInteger: self andSend: #>=! !
!Integer methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 1/15/2025 09:57:42' prior: 16891476!
                    hash
	"Hash is reimplemented because = is implemented.
	Siimply answering self as #hash has bad performance for the following:
	| s |
	s := (1 to: 10000) asSet.
	[s includes: 123456] bench
	"

	"Can only happen in 64 bits images...
	See Float>>#hash, LargePositiveInteger>>#hash and LargeNegativeInteger>>#hash"
	self abs < Float maxExactInteger ifFalse: [
		^ self asFloat hash ].

	"In 32 bit image it will always go this way"
	^self hashMultiply! !
!Integer methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 1/15/2025 09:56:58' prior: 16891493!
                hashMultiply
	self subclassResponsibility! !
!Integer methodsFor: 'converting' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16891508!
     asInteger
	"Answer with the receiver itself."

	^self! !
!Integer methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jpb 8/2/2019 23:58:43' prior: 16891567!
                              is: aSymbol
	"Note: Senders might prefer #isInteger for perfomance reasons. Still, Cuis tries to keep isXXX testing selectors to a minimum."
	^#Integer = aSymbol or: [ super is: aSymbol ]! !
!Integer methodsFor: 'testing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16891576!
                      isInteger
	^true! !
!Integer methodsFor: 'truncation and round off' library: #MinimalKernel01 stamp: 'sqr 12/21/2013 17:55' prior: 16891498!
                   ceiling 
	"Refer to the comment in Number|ceiling."

	^self! !
!Integer methodsFor: 'truncation and round off' library: #MinimalKernel01 stamp: 'sqr 12/21/2013 17:56' prior: 16891503!
        floor 
	"Refer to the comment in Number|floor."

	^self! !
!SmallInteger methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'di 2/1/1999 21:29' prior: 16959486!
                        * aNumber 
	"Primitive. Multiply the receiver by the argument and answer with the
	result if it is a SmallInteger. Fail if the argument or the result is not a
	SmallInteger. Essential. No Lookup. See Object documentation whatIsAPrimitive."

	<primitive: 9>
	^ super * aNumber! !
!SmallInteger methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'di 2/1/1999 21:31' prior: 16959497!
                            + aNumber 
	"Primitive. Add the receiver to the argument and answer with the result
	if it is a SmallInteger. Fail if the argument or the result is not a
	SmallInteger  Essential  No Lookup. See Object documentation whatIsAPrimitive."

	<primitive: 1>
	^ super + aNumber! !
!SmallInteger methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16959509!
                      - aNumber 
	"Primitive. Subtract the argument from the receiver and answer with the
	result if it is a SmallInteger. Fail if the argument or the result is not a
	SmallInteger. Essential. No Lookup. See Object documentation
	whatIsAPrimitive."

	<primitive: 2>
	^super - aNumber! !
!SmallInteger methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'tk 11/30/2001 11:55' prior: 16959521!
                        // aNumber 
	"Primitive. Divide the receiver by the argument and answer with the
	result. Round the result down towards negative infinity to make it a
	whole integer. Fail if the argument is 0 or is not a SmallInteger.
	Essential. No Lookup. See Object documentation whatIsAPrimitive. "

	<primitive: 12>
	^ super // aNumber 	"Do with quo: if primitive fails"! !
!SmallInteger methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'tk 11/30/2001 11:53' prior: 16959535!
      \\ aNumber 
	"Primitive. Take the receiver modulo the argument. The result is the
	remainder rounded towards negative infinity, of the receiver divided by
	the argument Fail if the argument is 0 or is not a SmallInteger. Optional.
	No Lookup. See Object documentation whatIsAPrimitive."

	<primitive: 11>
	^ super \\ aNumber 	"will use // to compute it if primitive fails"! !
!SmallInteger methodsFor: 'arithmetic' library: #MinimalKernel01 stamp: 'jmv 6/25/2019 18:01:48' prior: 16959550!
                      quo: aNumber 
	"Primitive. Divide the receiver by the argument and answer with the 
	result. Round the result down towards zero to make it a whole integer. 
	Fail if the argument is 0 or is not a SmallInteger. Optional. See Object 
	documentation whatIsAPrimitive."
	<primitive: 13>
	aNumber = 0 ifTrue: [^ZeroDivide new signalReceiver: self selector: #quo: argument: aNumber ].
	(aNumber isMemberOf: SmallInteger)
		ifFalse: [^ super quo: aNumber].
	(aNumber = -1 and: [self = self class minVal])
		ifTrue: ["result is aLargeInteger" ^ self negated].
	self primitiveFailed! !
!SmallInteger methodsFor: 'bit manipulation' library: #MinimalKernel01 stamp: 'jmv 4/24/2016 01:40' prior: 16959660!
          bitAnd: arg 
	"Primitive. Answer an Integer whose bits are the logical OR of the
	receiver's bits and those of the argument, arg.
	Numbers are interpreted as having 2's-complement representation.
	Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 14>
	self >= 0 ifTrue: [^ arg bitAnd: self].
	^ arg < 0
		ifTrue: [(arg bitInvert bitOr: self bitInvert) bitInvert]
		ifFalse: [arg bitClear: self bitInvert]! !
!SmallInteger methodsFor: 'bit manipulation' library: #MinimalKernel01 stamp: 'di 4/30/1998 10:33' prior: 16959676!
bitOr: arg 
	"Primitive. Answer an Integer whose bits are the logical OR of the
	receiver's bits and those of the argument, arg.
	Numbers are interpreted as having 2's-complement representation.
	Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 15>
	self >= 0 ifTrue: [^ arg bitOr: self].
	^ arg < 0
		ifTrue: [(self bitInvert bitAnd: arg bitInvert) bitInvert]
		ifFalse: [(self bitInvert bitClear: arg) bitInvert]! !
!SmallInteger methodsFor: 'bit manipulation' library: #MinimalKernel01 stamp: 'mir 9/25/2008 15:18' prior: 16959693!
                    bitShift: arg 
	"Primitive. Answer an Integer whose value is the receiver's value shifted
	left by the number of bits indicated by the argument. Negative arguments
	shift right. The receiver is interpreted as having 2's-complement representation.
	Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 17>
	self >= 0 ifTrue: [^ super bitShift: arg].
	^ arg >= 0
		ifTrue: [(self negated bitShift: arg) negated]
		ifFalse: [(self bitInvert bitShift: arg) bitInvert].! !
!SmallInteger methodsFor: 'bit manipulation' library: #MinimalKernel01 stamp: 'mir 9/25/2008 15:18' prior: 16959711!
      bitXor: arg 
	"Primitive. Answer an Integer whose bits are the logical XOR of the
	receiver's bits and those of the argument, arg.
	Numbers are interpreted as having 2's-complement representation.
	Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 16>
	self >= 0 ifTrue: [^ arg bitXor: self].
	^ arg < 0
		ifTrue: [self bitInvert bitXor: arg bitInvert]
		ifFalse: [(self bitInvert bitXor: arg) bitInvert].! !
!SmallInteger methodsFor: 'bit manipulation' library: #MinimalKernel01 stamp: 'sqr 1/26/2014 13:48' prior: 16959727!
                              lowBit
	" Answer the index of the low order one bit.
		2r00101000 lowBit       (Answers: 4)
		2r-00101000 lowBit      (Answers: 4)"

	self = 0 ifTrue: [^0].
	^(self bitXor: self - 1) highBit! !
!SmallInteger methodsFor: 'testing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16959736!
              even
	^(self bitAnd: 1) = 0! !
!SmallInteger methodsFor: 'printing' library: #MinimalKernel01 stamp: 'ul 4/2/2016 20:19' prior: 16959740!
                      decimalDigitLength
	"Answer the number of digits printed out in base 10.
	 Note that this only works for positive SmallIntegers up to 63-bits."
	
	self <= 99999999 "8" ifTrue: [
		self <= 9999 "4" ifTrue: [
			self <= 99 "2" ifTrue: [
				self <= 9 "1" ifTrue: [ ^1].
				^2 ].
			self <= 999 "3" ifTrue: [ ^3].
			^4 ].
		self <= 999999 "6" ifTrue: [
			self <= 99999 "5" ifTrue: [ ^5 ].
			^6 ].
		self <= 9999999 "7" ifTrue: [ ^7 ].
		^8 ].
	self <= 1073741823 "10" ifTrue: [ "This is here only to avoid LargeInteger comparisons in 32-bit VMs"
		self <= 999999999 "9" ifTrue: [ ^9 ].
		^10 ].
	self <= 999999999999999 "15" ifTrue: [
		self <= 9999999999999 "13" ifTrue: [
			self <= 99999999999 "11" ifTrue: [
				self <= 9999999999 "10" ifTrue: [ ^10 ].
				^11 ].
			self <= 999999999999 "12" ifTrue: [ ^12 ].
			^13 ].
		self <= 99999999999999 "14" ifTrue: [ ^14 ].
		^15 ].
	self <= 99999999999999999 "17" ifTrue: [
		self <= 9999999999999999 "16" ifTrue: [ ^16 ].
		^17 ].
	self <= 999999999999999999 "18" ifTrue: [ ^18 ].
	^19 "(1 << 60 - 1) asString size"! !
!SmallInteger methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 7/6/2023 11:28:41' prior: 16959776!
    printString
	"Highly optimized version for base 10
	and that we know it is a SmallInteger."
	
	| integer next result len |
	self = 0 ifTrue: [^'0'].
	self < 0 ifTrue: [^'-', self negated printString].
	len := self decimalDigitLength.
	result := ByteArray new: len.
	integer := self.
	len to: 1 by: -1 do: [:i |
		next := integer // 10.
		result at: i put: 48 + (integer - (next * 10)).
		integer := next ].
	^result asString! !
!SmallInteger methodsFor: 'system primitives' library: #MinimalKernel01 stamp: 'tk 5/14/1999 20:54' prior: 16959792!
                               nextInstance
	"SmallIntegers can't be enumerated this way.  There are a finite number of them from from (SmallInteger minVal) to (SmallInteger maxVal), but you'll have to enumerate them yourself with:
	(SmallInteger minVal) to: (SmallInteger maxVal) do: [:integer | <your code here>].
	"

	self shouldNotImplement ! !
!SmallInteger methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16959571!
                < aNumber 
	"Compare the receiver with the argument and answer with true if the receiver is less 
	than the argument.  Otherwise answer false.  Fail if the argument is not a 
	SmallInteger.  Essential.  No Lookup.  See Object documentation whatIsAPrimitive."

	<primitive: 3>
	^super < aNumber! !
!SmallInteger methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16959583!
     <= aNumber 
	"Compare the receiver with the argument and answer true if the receiver is less 
	than or equal to the argument.  Otherwise answer false.  Fail if the argument is 
	not a SmallInteger.  Optional.  No Lookup.  See Object documentation 
	whatIsAPrimitive. "

	<primitive: 5>
	^super <= aNumber! !
!SmallInteger methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16959596!
                          = aNumber 
	"Compare the receiver with the argument and answer true if the receiver is 
	equal to the argument.  Otherwise answer false.  Fail if the argument is not a 
	SmallInteger.  Essential.  No Lookup.  See Object documentation 
	whatIsAPrimitive. "

	<primitive: 7>
	^super = aNumber! !
!SmallInteger methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16959608!
        > aNumber 
	"Compare the receiver with the argument and answer true if the receiver is 
	greater than the argument.  Otherwise answer false.  Fail if the argument is not a 
	SmallInteger.  Essential.  No Lookup.  See Object documentation whatIsAPrimitive."

	<primitive: 4>
	^super > aNumber! !
!SmallInteger methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16959620!
       >= aNumber 
	"Compare the receiver with the argument and answer true if the receiver is 
	greater than or equal to the argument.  Otherwise answer false.  Fail if the 
	argument is not a SmallInteger.  Optional.  No Lookup.  See Object 
	documentation whatIsAPrimitive."

	<primitive: 6>
	^super >= aNumber! !
!SmallInteger methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16959633!
                        ~= aNumber 
	"Compare the receiver with the argument and answer true if the receiver is not 
	equal to the argument.  Otherwise answer false.  Fail if the argument is not a 
	SmallInteger.  Essential.  No Lookup.  See Object documentation 
	whatIsAPrimitive. "

	<primitive: 8>
	^super ~= aNumber! !
!SmallInteger methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'SqR 8/3/2000 13:29' prior: 16959645!
       hashMultiply
	"Multiply by 1664525, take lower 28 bits, do not use LargeIntegers (not even in 32 bit images)"
	| low |

	low := self bitAnd: 16383.
	^(16r260D * low + ((16r260D * (self bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384))
			bitAnd: 16r0FFFFFFF! !
!SmallInteger methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'Squeak1.2 6/29/1997 10:40:55' prior: 16959656!
                            identityHash

	^self! !
!SmallInteger methodsFor: 'copying' library: #MinimalKernel01 stamp: 'sqr 12/21/2013 17:49' prior: 16959805!
                           shallowCopy

	^self! !
!LookupKey methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899263!
                          key
	"Answer the lookup key of the receiver."
	^key! !
!LookupKey methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899268!
                          key: anObject 
	"Store the argument, anObject, as the lookup key of the receiver."
	key := anObject! !
!LookupKey methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899274!
          < aLookupKey 
	^key < aLookupKey key! !
!LookupKey methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 8/9/2016 10:01:30' prior: 16899278!
           = aLookupKey

	self == aLookupKey ifTrue: [ ^ true ].
	self species == aLookupKey species
		ifFalse: [ ^false ].

	^ key = aLookupKey key! !
!LookupKey methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16899285!
                               hash
	"Hash is reimplemented because = is implemented."

	^key hash! !
!LookupKey methodsFor: 'printing' library: #MinimalKernel01 stamp: 'jmv 9/2/2012 21:43' prior: 16899290!
                printOn: aStream

	super printOn: aStream.
	aStream nextPut: $(.
	key printOn: aStream.
	aStream nextPut: $)! !
!LookupKey class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16899399!
                   key: aKey 
	"Answer a new instance of me with the argument as the lookup up."
	^self new key: aKey! !
!Association methodsFor: 'printing' library: #MinimalKernel01 stamp: 'sqr 12/20/2013 18:24' prior: 16784489!
             printOn: aStream

	aStream
		print: self key;
		nextPutAll: ' -> ';
		print: self value! !
!Association methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16784459!
                    key: aKey value: anObject 
	"Store the arguments as the variables of the receiver."

	key := aKey.
	value := anObject! !
!Association methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16784466!
                      value
	"Answer the value of the receiver."
	^value! !
!Association methodsFor: 'accessing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16784471!
                         value: anObject 
	"Store the argument, anObject, as the value of the receiver."
	value := anObject! !
!Association methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 8/9/2016 10:01:44' prior: 16784477!
           = anAssociation

	self == anAssociation ifTrue: [ ^ true ].
	^ super = anAssociation and: [value = anAssociation value]! !
!Association methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 6/11/2019 21:18:46' prior: 16784484!
                     hash
	"Hash is reimplemented because = is implemented."

	^ key hash! !
!Association class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16784573!
                         key: newKey value: newValue
	"Answer a new instance of me with the arguments as the key and
	value of the association."
	^(super key: newKey) value: newValue! !
!UndefinedObject methodsFor: 'printing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 17000565!
           printOn: aStream 
	aStream nextPutAll: 'nil'! !
!UndefinedObject methodsFor: 'testing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 17000558!
                             isNil
	^true! !
!UndefinedObject methodsFor: 'testing' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 17000561!
                             notNil
	^false! !
!UndefinedObject methodsFor: 'copying' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 17000569!
                           shallowCopy
	"Only one instance of UndefinedObject should ever be made, so answer 
	with self."! !
!Character methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 4/29/2025 10:41:03' prior: 16810574!
               hash
	"Hash is reimplemented because #hash for long Strings relies on it, and especially on being the same as the codePoint's for the ASCII range. Also see the comment at Integer>>#hash.
	| longString |
	longString := (1 to: 100)
		inject: ''
		into: [ :prev :each |
			prev , 'A lot of stuff, needs over 2000 chars!! ' ].
	self assert: longString asByteString hash = longString asUnicodeString hash.
	self assert: longString asByteString = longString asUnicodeString.
	"
	^self codePoint hash! !
!Character methodsFor: 'comparing' library: #MinimalKernel01 stamp: 'jmv 9/25/2023 16:46:30' prior: 16810592!
 identityHash
	"Answer the receiver's character code."
	<primitive: 171>
	^self primitiveFailed! !
!Character methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 6/6/2022 10:40:24' prior: 16810598!
                   isCharacter
	^true! !
!Character methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 1/8/2024 12:37:08' prior: 16810601!
                               isDigit
	"Answer whether the receiver is a digit."

	^ self codePoint between: 48 and: 57! !
!Character methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 1/8/2024 16:55:13' prior: 16810607!
                        isLetter
	"Answer whether the receiver is a letter."
	"
	(Character codePoint: 16r22C7) isLetter
	(Character codePoint: 16r042F) isLetter
	(Character codePoint: 16r0431) isLetter
	"
	^self isLowercase or: [ self isUppercase ]! !
!Character methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 5/6/2025 14:39:55' prior: 16810617!
                isLowercase
	"Answer whether the receiver is a letter."
	"
	(Character codePoint: 16r22C7) isLowercase
	(Character codePoint: 16r042F) isLowercase
	(Character codePoint: 16r0431) isLowercase
	"
	| i |
	"If no UnicodeData.txt tables, consider only ASCII"
	LowercaseLettersTable isNil ifTrue: [
		^ self codePoint between: 97 and: 122 ].
		
	i := self codePoint + 1.
	LowercaseLettersTable bitSize < i ifTrue: [ ^false ].
	^LowercaseLettersTable bitBooleanAt: i.! !
!Character methodsFor: 'testing' library: #MinimalKernel01 stamp: 'jmv 5/6/2025 14:40:28' prior: 16810634!
     isUppercase
	"Answer whether the receiver is an uppercase letter."
	"
	(Character codePoint: 16r22C7) isUppercase
	(Character codePoint: 16r042F) isUppercase
	(Character codePoint: 16r0431) isUppercase
	"
	| i |
	"If no UnicodeData.txt tables, consider only ASCII"
	UppercaseLettersTable isNil ifTrue: [
		^ self codePoint between: 65 and: 90 ].

	i := self codePoint + 1.
	UppercaseLettersTable bitSize < i ifTrue: [ ^false ].
	^UppercaseLettersTable bitBooleanAt: i.! !
!Character methodsFor: 'accesing' library: #MinimalKernel01 stamp: 'jmv 12/1/2024 11:32:58' prior: 16810563!
                           codePoint
	"Code points are the numbers assigned by the Unicode Consortium to every character in every writing system."
	"
	self assert: $A codePoint hex = '16r41'.
	self assert: $€ codePoint hex = '16r20AC'.
	"
	<primitive: 171>
	^self primitiveFailed! !
!Character methodsFor: 'copying' library: #MinimalKernel01 stamp: 'eem 2/5/2014 12:53' prior: 16810651!
                      shallowCopy
	"Answer the receiver, because Characters are unique."
	^self! !
!Character class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 4/30/2025 12:42:37' prior: 16811088!
                       binarySelectorCharacters
	^ '!!%&+-*/\,<=>?@~'! !
!Character class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 1/8/2024 12:13:35' prior: 16811093!
                   codePoint: anInteger
	"Answer the Character whose value is anInteger.
	
	self assert: (Character codePoint: 16r41) == $A.
	self assert: (Character codePoint: 16r20AC) == $€.
	"

	<primitive: 170>
	^self primitiveFailed! !
!Character class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'jmv 1/8/2024 12:16:02' prior: 16811103!
     digitValue: x 
	"Answer the Character whose digit value is x. For example,
	 answer $9 for x=9, $0 for x=0, $A for x=10, $Z for x=35."

	| n |
	n := x asInteger.
	^self codePoint: (n < 10 ifTrue: [n + 48] ifFalse: [n + 55])! !
!Character class methodsFor: 'instance creation' library: #MinimalKernel01 stamp: 'ST-80 5/31/1983 9:10:35' prior: 16811113!
new
	"Creating new characters is not allowed."

	self error: 'cannot create new characters'! !
!Character class methodsFor: 'accessing untypeable characters' library: #MinimalKernel01 stamp: 'jmv 5/17/2024 09:11:50' prior: 16811120!
                       lf
	"Answer the Character representing a linefeed."

	^`Character codePoint: 10`! !
!Character class methodsFor: 'accessing untypeable characters' library: #MinimalKernel01 stamp: 'jmv 8/28/2013 10:28' prior: 16811126!
     newLineCharacter
	"Answer the Character representing a newLine, that is, a linefeed.
	This should be the only method in the system that knows about this detail.
	Everybody else should eventually ask us."

	^self lf! !
!Character class methodsFor: 'accessing untypeable characters' library: #MinimalKernel01 stamp: 'jmv 5/17/2024 09:15:46' prior: 16811136!
                            space
	"Answer the Character representing a space."

	^ `Character codePoint: 32`! !
!Point methodsFor: 'copying' library: #MinimalKernel01 stamp: 'pb 10/29/2016 18:18:07' prior: 16933672!
   shallowCopy
	"Immutable"
	^ self.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7455-library-MinimalKernel01-JuanVuletich-2025Aug28-11h00m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7452] on 28 August 2025 at 12:06:56 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7456-library-MinimalKernel01-cleanup-JuanVuletich-2025Aug28-11h45m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7456] on 28 August 2025 at 1:50:45 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7457-library-MinimalKernel01-cleanup-JuanVuletich-2025Aug28-13h34m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7456] on 28 August 2025 at 3:04:20 pm'!
!Behavior methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 12/31/2009 09:48' prior: 16787761!
                               binding
	^ nil -> self! !
!Behavior methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'ar 5/17/2003 14:06' prior: 16787765!
       bindingOf: varName
	"Answer the binding of some variable resolved in the scope of the receiver"
	^superclass bindingOf: varName! !
!Behavior methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'ar 5/18/2003 18:13' prior: 16787772!
                              classBindingOf: varName
	"Answer the binding of some variable resolved in the scope of the receiver's class"
	^self bindingOf: varName! !
!Behavior methodsFor: 'copying' library: #MinimalKernel05ClassAndMethodCreation stamp: 'SqR 2/20/2015 21:09' prior: 16787874!
                        postCopy

	self methodDict: self methodDict copy! !
!Behavior methodsFor: 'testing class hierarchy' library: #MinimalKernel05ClassAndMethodCreation stamp: 'ar 3/12/98 12:36' prior: 16789124!
 includesBehavior: aClass
	^self == aClass or:[self inheritsFrom: aClass]! !
!Behavior methodsFor: 'testing class hierarchy' library: #MinimalKernel05ClassAndMethodCreation stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16789130!
                             inheritsFrom: aClass 
	"Answer whether the argument, aClass, is on the receiver's superclass 
	chain."

	| aSuperclass |
	aSuperclass := superclass.
	[aSuperclass == nil]
		whileFalse: 
			[aSuperclass == aClass ifTrue: [^true].
			aSuperclass := aSuperclass superclass].
	^false! !
!Behavior methodsFor: 'private' library: #MinimalKernel05ClassAndMethodCreation stamp: 'ST-80 5/31/1983 9:10:35' prior: 16787848!
   flushCache
	"Tell the interpreter to remove the contents of its method lookup cache, if it has 
	one.  Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 89>
	self primitiveFailed! !
!Behavior methodsFor: 'initialization' library: #MinimalKernel05ClassAndMethodCreation stamp: 'ar 7/15/1999 16:39' prior: 16787750!
                  superclass: aClass methodDictionary: mDict format: fmt
	"Basic initialization of the receiver.
	Must only be sent to a new instance; else we would need Object flushCache."
	superclass := aClass.
	format := fmt.
	methodDict := mDict.! !
!Behavior methodsFor: 'instances and variables' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 5/13/2025 09:26:11' prior: 16787858!
   maxAccessibleInstSize
	"Answer the maximum number of accessible named instance variables.
	 This depends on the bytecode set.
	Note: On images without Compiler / Parser / Encoder we'd need a class variable somewhere.
		Assume EncoderForV3PlusClosures if unknown"

	CompiledMethod preferredBytecodeSetEncoderClass isNil
		ifTrue: [ ^256 ].
	^CompiledMethod preferredBytecodeSetEncoderClass maxAccessibleInstSize! !
!Behavior methodsFor: 'method dictionary' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 2/28/2010 22:47' prior: 16787780!
                          addSelectorSilently: selector withMethod: compiledMethod 
	"Add the message selector with the corresponding compiled method to the 
	receiver's method dictionary.
	Do this without sending system change notifications"

	| oldMethodOrNil |
	oldMethodOrNil := self lookupSelector: selector.
	self methodDict at: selector put: compiledMethod.

	"Now flush Squeak's method cache, either by selector or by method"
	oldMethodOrNil ifNotNil: [oldMethodOrNil flushCache].
	selector flushCache.! !
!Behavior methodsFor: 'method dictionary' library: #MinimalKernel05ClassAndMethodCreation stamp: 'di 2/17/2000 22:37' prior: 16787799!
                 compiledMethodAt: selector 
	"Answer the compiled method associated with the argument, selector (a 
	Symbol), a message selector in the receiver's method dictionary. If the 
	selector is not in the dictionary, create an error notification."

	^ self methodDict at: selector! !
!Behavior methodsFor: 'method dictionary' library: #MinimalKernel05ClassAndMethodCreation stamp: 'di 3/27/1999 23:20' prior: 16787811!
    includesSelector: aSymbol 
	"Answer whether the message whose selector is the argument is in the 
	method dictionary of the receiver's class."

	^ self methodDict includesKey: aSymbol! !
!Behavior methodsFor: 'method dictionary' library: #MinimalKernel05ClassAndMethodCreation stamp: 'di 1/2/1999 15:45' prior: 16787820!
                               lookupSelector: selector
	"Look up the given selector in my methodDictionary.
	Return the corresponding method if found.
	Otherwise chase the superclass chain and try again.
	Return nil if no method is found."
	| lookupClass |
	lookupClass := self.
	[lookupClass == nil]
		whileFalse: 
			[(lookupClass includesSelector: selector)
				ifTrue: [^ lookupClass compiledMethodAt: selector].
			lookupClass := lookupClass superclass].
	^ nil! !
!Behavior methodsFor: 'method dictionary' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 2/28/2010 22:50' prior: 16787837!
methodDict
	methodDict ifNil: [self recoverFromMDFaultWithTrace].
	^ methodDict! !
!Behavior methodsFor: 'method dictionary' library: #MinimalKernel05ClassAndMethodCreation stamp: 'dvf 9/27/2005 17:08' prior: 16787843!
     methodDict: aDictionary
	methodDict := aDictionary! !
!ClassDescription methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'HAW 3/12/2019 22:09:16' prior: 16819049!
                               localBindingOf: varNameSymbol

	self subclassResponsibility ! !
!ClassDescription methodsFor: 'initialization' library: #MinimalKernel05ClassAndMethodCreation stamp: 'NS 4/6/2004 15:26' prior: 16819010!
                     organization: aClassOrg
	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."

	aClassOrg ifNotNil: [aClassOrg setSubject: self].
	organization := aClassOrg! !
!ClassDescription methodsFor: 'initialization' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 5/12/2025 12:01:54' prior: 16819021!
                           setInstVarNames: instVarArray
	"Private - for class initialization only"
	| required |
	required := self instSize.
	superclass ifNotNil: [
		required := required - superclass instSize].
	instVarArray size = required
		ifFalse:[
			^self error: required printString, ' instvar names are required'].
	instanceVariables := instVarArray size = 0
		ifFalse: [
			instVarArray == Array
				ifTrue: [ instVarArray ]
				ifFalse: [ Array withAll: instVarArray ]].! !
!ClassDescription methodsFor: 'initialization' library: #MinimalKernel05ClassAndMethodCreation stamp: 'NS 4/6/2004 15:31' prior: 16819039!
          superclass: aClass methodDictionary: mDict format: fmt
	"Basic initialization of the receiver"
	super superclass: aClass methodDictionary: mDict format: fmt.
	instanceVariables := nil.
	self organization: nil.! !
!Class methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 12/31/2009 09:49' prior: 16815406!
             binding

	^ Smalltalk associationAt: name ifAbsent: [nil -> self]! !
!Class methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 5/24/2014 11:00' prior: 16815411!
                              bindingOf: varName
	"Answer the binding of some variable resolved in the scope of the receiver"
	| aSymbol |
	aSymbol := varName asSymbol.

	"First look in receiver, and up the hierarchy. Inherited variables take precedence over globals."
	(self localBindingOf: aSymbol) ifNotNil: [ :binding | ^binding ].

	"Next look in globals."
	(Smalltalk bindingOf: aSymbol) ifNotNil: [ :binding | ^binding ].

	"Fail at the end."
	^nil! !
!Class methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'HAW 10/5/2020 08:09:51' prior: 16815428!
                   classVarBindingOf: varNameSymbol

	^self classPool bindingOf: varNameSymbol! !
!Class methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'HAW 10/5/2020 08:08:59' prior: 16815434!
                 localBindingOf: varNameSymbol
	"Answer the binding of some variable resolved in the scope of the receiver."

	"First look in classVar dictionary."
	(self classVarBindingOf: varNameSymbol) ifNotNil: [ :binding | ^binding ].

	"Next look in shared pools."
	self sharedPools do: [ :pool | 
		(pool bindingOf: varNameSymbol) ifNotNil: [ :binding | ^binding ].
	].

	"Finally look higher up the superclass chain and fail at the end."
	^superclass ifNotNil: [ superclass localBindingOf: varNameSymbol ]! !
!Class methodsFor: 'initialization' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 5/12/2025 17:16:17' prior: 16815343!
       addSubclass: aSubclass
	"Make the argument, aSubclass, be one of the subclasses of the receiver. 
	Create an error notification if the argument's superclass is not the receiver."

	aSubclass superclass ~~ self
		ifTrue: [^self error: aSubclass name , ' is not my subclass'].
	subclasses ifNil: [
		subclasses := Array with: aSubclass.
		^self].
	subclasses do: [ :cl | cl == aSubclass ifTrue: [ ^self ]]. "Already my subclass"
	subclasses := Array withAll: subclasses with: aSubclass.! !
!Class methodsFor: 'initialization' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 9/14/2023 10:10:53' prior: 16815362!
                   declareClassVariables: newVars
	"Declare class variables common to all instances.
	Answer whether recompilation is advisable."

	| conflicts |
	conflicts := false.
	classPool
		ifNotNil: [
			(classPool keys reject: [ :x | newVars includes: x ]) 
				do: [ :var | self removeClassVarName: var ]].
	(newVars reject: [:var | self classPool includesKey: var])
		do: [ :var | "adding"
			"check if new vars defined elsewhere"
			(self bindingOf: var)
				ifNotNil: [ 
					self error: var, ' is defined elsewhere'.
					conflicts := true ]].
	newVars size > 0
		ifTrue: [
			"in case it was nil"
			classPool := self classPool.
			newVars do: [:var |
				classPool declare: var from: 
					(Smalltalk at: #Undeclared ifAbsent: nil) ]].
	^ conflicts.! !
!Class methodsFor: 'initialization' library: #MinimalKernel05ClassAndMethodCreation stamp: 'ar 7/15/1999 15:37' prior: 16815389!
                  setName: aSymbol
	"Private - set the name of the class"
	name := aSymbol.! !
!Class methodsFor: 'initialization' library: #MinimalKernel05ClassAndMethodCreation stamp: 'ar 7/20/1999 11:23' prior: 16815395!
                  superclass: aClass methodDictionary: mDict format: fmt
	"Basic initialization of the receiver"
	super superclass: aClass methodDictionary: mDict format: fmt.
	subclasses := nil. "Important for moving down the subclasses field into Class"
! !
!Class methodsFor: 'copying' library: #MinimalKernel05ClassAndMethodCreation stamp: 'nice 12/29/2010 10:47' prior: 16815453!
                 copy 
	"Answer a copy of the receiver without a list of subclasses."
	| newClass |
	newClass := self class copy new
		superclass: superclass
		methodDict: self methodDict copy
		format: format
		name: name
		organization: self organization copy
		instVarNames: instanceVariables copy
		classPool: classPool copy
		sharedPools: sharedPools copy.
	Class instSize+1 to: self class instSize do:
		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].
	^ newClass! !
!Metaclass methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'ar 5/18/2003 18:13' prior: 16905032!
  bindingOf: varName

	^thisClass classBindingOf: varName! !
!Metaclass methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'HAW 3/12/2019 22:08:40' prior: 16905037!
 localBindingOf: varNameSymbol

	^thisClass localBindingOf: varNameSymbol ! !
!Metaclass methodsFor: 'copying' library: #MinimalKernel05ClassAndMethodCreation stamp: 'nice 12/29/2010 10:21' prior: 16905043!
                  postCopy
	"Don't share the reference to the sole instance."

	super postCopy.
	thisClass := nil.! !
!Metaclass methodsFor: 'instance creation' library: #MinimalKernel05ClassAndMethodCreation stamp: 'nk 11/9/2003 10:00' prior: 16905021!
                    new
	"The receiver can only have one instance. Create it or complain that
	one already exists."

	thisClass class ~~ self
		ifTrue: [^thisClass := self basicNew]
		ifFalse: [self error: 'A Metaclass should only have one instance!!']! !
!CompiledMethod methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 5/11/2012 15:40' prior: 16833393!
              endPC
	"Answer the index of the last bytecode."
	| size flagByte |
	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.
	 We can reuse size."
	size := self size.
	flagByte := self at: size.
	flagByte = 0 ifTrue: [
		"If last byte = 0, may be either 0, 0, 0, 0 or just 0"
		size-1 to: size-3 by: -1 do: [ :i |
			i < self initialPC ifTrue: [ ^ i ].
			(self at: i) = 0 ifFalse: [ ^ i ]].
		^size - 4].
	flagByte < 252 ifTrue: [
		"Magic sources (temp names encoded in last few bytes)"
		^flagByte <= 127
			ifTrue: [size - flagByte - 1]
			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].
	"Normal 4-byte source pointer"
	^size - 4! !
!CompiledMethod methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 12/17/2016 22:38:52' prior: 16833419!
                       initialPC
	"Answer the program counter for the receiver's first bytecode."
	^ (self numLiterals + 1) * Smalltalk wordSize + 1! !
!CompiledMethod methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'md 2/16/2006 11:30' prior: 16833427!
                          methodClass: aClass
	"set the class binding in the last literal to aClass"
	self literalAt: self numLiterals put: aClass binding! !
!CompiledMethod methodsFor: 'literals' library: #MinimalKernel05ClassAndMethodCreation stamp: 'ST-80 5/31/1983 9:10:35' prior: 16833435!
                   literalAt: index put: value 
	"Replace the literal indexed by the first argument with the
	second argument."

	^self objectAt: index + 1 put: value! !
!CompiledMethod methodsFor: 'literals' library: #MinimalKernel05ClassAndMethodCreation stamp: 'ST-80 5/31/1983 9:10:35' prior: 16833443!
objectAt: index put: value 
	"Store the value argument into a literal in the receiver.   An index of 2 
	corresponds to the first literal.  Fails if the index is less than 2 or greater than 
	the number of literals.  Answer the value as the result.  Normally only the
	compiler sends this message, because only the compiler stores values in 
	CompiledMethods.  Essential.  See Object documentation whatIsAPrimitive."

	<primitive: 69>
	self primitiveFailed! !
!CompiledMethod methodsFor: 'private' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 8/30/2023 12:04:05' prior: 16833461!
             flushCache
	"Tell the virtual machine to remove all references to this method from its method
	 lookup cache(s), if it has them. This is provided for backwards compatibility.
	 When a method is redefined (added to, removed from, or replaced in, a method
	 dictionary) then Symbol flushCache should be used. This is because adding or
	 removing a method may alter the method that a given selector should invoke
	 for methods other than the receiver.  For example, if a subclass inherits a
	 method and this is overridden, flushing the new method will not flush the existing
	 method.

	 If a method is modified in-place (for example, some bytecode is replaced by
	 bytecode that effects a breakpoint) then voidCogVMState should be used."

	<primitive: 116>! !
!CompiledMethod methodsFor: 'private' library: #MinimalKernel05ClassAndMethodCreation stamp: 'eem 11/29/2008 11:52' prior: 16833488!
    penultimateLiteral: anObject
	"Answer the penultimate literal of the receiver, which holds either
	 the receiver's selector or its properties (which will hold the selector)."
	| pIndex |
	(pIndex := self numLiterals - 1) > 0 
		ifTrue: [self literalAt: pIndex put: anObject]
		ifFalse: [self error: 'insufficient literals']! !
!CompiledMethod methodsFor: 'private' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 8/30/2023 12:17:03' prior: 16833502!
                  voidCogVMState
	"Tell the VM to remove all references to any machine code form of the method.
	 This primitive must be called whenever a method is in use and modified.  This is
	 more aggressive (and *much* more costly) than flushCache since it must search
	 through all context objects, making sure that none have a (hidden) machine code pc
	 in the receiver.  Since modifying a method will likely change the generated machine code,
	 modifying a method (rather than redefining it) requires this more aggressive flush.

	If this is needed for a bunch of methods, and not just one, consider calling
	Smalltalk voidCogVMState
	(primitive 214)"

	<primitive: 215>
	^self flushCache! !
!CompiledMethod class methodsFor: 'instance creation' library: #MinimalKernel05ClassAndMethodCreation stamp: 'tk 9/9/2000 20:36' prior: 16835763!
   basicNew: size

	self error: 'CompiledMethods may only be created with newMethod:header:' ! !
!CompiledMethod class methodsFor: 'instance creation' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 7/31/2016 16:11:49' prior: 16835770!
           createMethod: numberOfBytesForAllButTrailer trailer: bytes header: headerWord 
	| meth delta |
	meth := self newMethod: numberOfBytesForAllButTrailer + bytes size header: headerWord.
	"copy the encoded trailer data"
	delta := meth size - bytes size.
	1 to: bytes size do: [ :i |
		meth at: delta + i put: (bytes at: i)].
	^meth! !
!CompiledMethod class methodsFor: 'instance creation' library: #MinimalKernel05ClassAndMethodCreation stamp: 'Squeak1.2 6/29/1997 10:40:55' prior: 16835785!
                        new
	"This will not make a meaningful method, but it could be used
	to invoke some otherwise useful method in this class."
	^ self newMethod: 0 header: 0! !
!CompiledMethod class methodsFor: 'instance creation' library: #MinimalKernel05ClassAndMethodCreation stamp: 'tk 1/21/2000 15:25' prior: 16835794!
                new: size

	self error: 'CompiledMethods may only be created with newMethod:header:'! !
!CompiledMethod class methodsFor: 'instance creation' library: #MinimalKernel05ClassAndMethodCreation stamp: 'eem 8/13/2014 05:55' prior: 16835801!
                    newMethod: numberOfBytes header: headerWord
	"Primitive. Answer an instance of me. The number of literals (and other 
	 information) is specified by the headerWord (see my class comment).
	 The first argument specifies the number of fields for bytecodes in the
	 method. Fail if either argument is not a SmallInteger, or if numberOfBytes
	 is negative, or if memory is low. Once the header of a method is set by
	 this primitive, it cannot be changed to change the number of literals.
	 Essential. See Object documentation whatIsAPrimitive."

	<primitive: 79 error: ec>
	ec == #'insufficient object memory' ifTrue:
		[^self handleFailingNewMethod: numberOfBytes header: headerWord].
	^self primitiveFailed! !
!CompiledMethod class methodsFor: 'accessing' library: #MinimalKernel05ClassAndMethodCreation stamp: 'eem 12/26/2024 13:45:51' prior: 16835827!
           preferredBytecodeSetEncoderClass
	^PreferredBytecodeSetEncoderClass! !
!SystemDictionary methodsFor: 'miscelaneous' library: #MinimalKernel05ClassAndMethodCreation stamp: 'eem 8/28/2009 14:52' prior: 16971313!
              voidCogVMState
	"Void any internal caches the VM maintains other than the method lookup caches.
		 These comprise
				- the stack zone, where method activations are stored, and
				- the machine code zone, where the machine code form of CompiledMethods is held."
	<primitive: 214>
	^self primitiveFailed

	"Time millisecondsToRun: [Smalltalk voidCogVMState]"
	"(1 to: 10) collect: [:ign| Time millisecondsToRun: [Smalltalk voidCogVMState]]"! !
!MethodDictionary class methodsFor: 'instance creation' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 2/5/2024 18:26:44' prior: 16906534!
            new
	"change the default size to be a bit bigger to help reduce the number of #grows while filing in"
	^self newWithRoomForMoreThan: 16! !
!MethodDictionary class methodsFor: 'instance creation' library: #MinimalKernel05ClassAndMethodCreation stamp: 'di 11/4/97 20:11' prior: 16906542!
  newWithRoomForMoreThan: nElements
	"Create a Dictionary large enough to hold nElements without growing.
	Note that the basic size must be a power of 2.
	It is VITAL (see grow) that size gets doubled if nElements is a power of 2"
	| size |
	size := 1 bitShift: nElements highBit.
	^ (self basicNew: size) init: size! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7458-library-MinimalKernel05-JuanVuletich-2025Aug28-13h50m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7456] on 28 August 2025 at 3:11:14 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7459-library-MinimalKernel05-cleanup-JuanVuletich-2025Aug28-15h04m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7456] on 28 August 2025 at 3:15:13 pm'!
!Number methodsFor: 'converting' library: #MinimalKernel03Float stamp: 'di 11/6/1998 13:21' prior: 16919933!
                 adaptToFloat: rcvr andSend: selector 
	"If I am involved in arithmetic with a Float, convert me to a Float."
	^ rcvr perform: selector with: self asFloat! !
!Float methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'jmv 11/21/2018 17:04:24' prior: 16869548!
                   hash
	"Hash is reimplemented because = is implemented."

	| asInteger |
	self isFinite ifTrue: [
		asInteger := self truncated.
		"See Integer>>#hash, LargePositiveInteger>>#hash and LargeNegativeInteger>>#hash"
		"Very big integers will answer true when asked #= with their own conversion to Float,
		But that Float will #asInteger to a different integer. Use Float hash in those cases, to ensure equal hash value.
		In addition, there is a performance improvement: the hash in LargeIntegers could
		get very slow for very big numbers"
		(asInteger = self and: [ asInteger abs < Float maxExactInteger ]) ifTrue: [
			^ asInteger hash ]].
	"Both words of the float are used. (The bitShift:'s ensure that the intermediate results do not become a large integer.)
	Care is taken to answer same hash as an equal Integer."
	^ ((self basicAt: 1) bitShift: -4) +
	   ((self basicAt: 2) bitShift: -4)! !
!Float methodsFor: 'mathematical functions' library: #MinimalKernel03Float stamp: 'tao 10/15/97 14:23' prior: 16869579!
        reciprocalLogBase2
	"optimized for self = 10, for use in conversion for printing"

	^ self = 10.0
		ifTrue: [Ln2 / Ln10]
		ifFalse: [Ln2 / self ln]! !
!Float methodsFor: 'converting' library: #MinimalKernel03Float stamp: 'di 11/6/1998 13:07' prior: 16869586!
                             adaptToInteger: rcvr andSend: selector
	"If I am involved in arithmetic with an Integer, convert it to a Float."
	^ rcvr asFloat perform: selector with: self! !
!Float methodsFor: 'converting' library: #MinimalKernel03Float stamp: 'jmv 12/26/2018 14:33:41' prior: 16869594!
              partBits: aThreeArgumentBlock
	"
	Extract the bits for Sign, Mantissa and Exponent parts of the floating point representation.
	Just extract the bits. Do not add implicit bit. Do not correct denormals. Do not subtract exponent bias. Do nothing with infinites and NaN.
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	| signBit exponentBits mantissaBits leastSignificativeWord mostSignificativeWord |

	mostSignificativeWord := self basicAt: 1.
	leastSignificativeWord := self basicAt: 2.
	signBit := mostSignificativeWord bitShift: -31 .
	exponentBits := (mostSignificativeWord bitShift: -20 ) bitAnd: 16r7FF.
	mantissaBits := ((mostSignificativeWord bitAnd: 16r000FFFFF) bitShift: 32) + leastSignificativeWord.

	"Evaluate the block"
	^aThreeArgumentBlock value: signBit value: exponentBits value: mantissaBits! !
!Float methodsFor: 'converting' library: #MinimalKernel03Float stamp: 'jmv 8/30/2010 23:39' prior: 16869627!
               partValues: aThreeArgumentBlock
	^ self
		partValues: aThreeArgumentBlock
		ifInfinite: [ self error: 'Can not handle infinity' ]
		ifNaN: [ self error: 'Can not handle Not-a-Number' ].! !
!Float methodsFor: 'converting' library: #MinimalKernel03Float stamp: 'jmv 12/20/2024 16:41:27' prior: 16869636!
                  partValues: aThreeArgumentBlock ifInfinite: infinityBlock ifNaN: nanBlock
	"
	Float pi hex print
	Float pi partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	0.0 partValues: [ :sign :exponent :mantissa | { sign hex. exponent hex. mantissa hex} print ]
	For 0.0, exponent will be the minimum possible, i.e.  -1023, and mantissa will be 0.
	"

	^ self partBits: [ :signBit :exponentBits :mantissaBits |
		| sign exponent mantissa |

		"Extract the sign"
		sign := signBit = 0 ifTrue: [1] ifFalse: [-1].

		"Special cases: infinites and NaN"
		exponentBits = 16r7FF ifTrue: [
			^mantissaBits = 0
				ifTrue: [ infinityBlock valueWithPossibleArgument: self ]
				ifFalse: [ nanBlock valueWithPossibleArgument: self and: mantissaBits ]].

		"Unbias exponent: 16r3FF is bias"
		exponent := exponentBits - 16r3FF.
	
		exponentBits ~= 0
			ifTrue: [
				"Add back implicit leading 1 in fraction."
				mantissa := 16r0010000000000000 bitOr: mantissaBits ]
			ifFalse: [
				"If expPart = 0, I am +/-zero or a denormal value. In such cases, no implicit leading bit in mantissa."
				mantissa := mantissaBits.
				exponent := exponent + 1 ].

		"Evaluate the block"
		aThreeArgumentBlock value: sign value: exponent value: mantissa
	]! !
!Float methodsFor: 'testing' library: #MinimalKernel03Float stamp: 'jmv 4/8/2019 09:43:05' prior: 16869678!
isDenormalized
	"Denormalized numbers are only represented as BoxedFloat64"

	^ false! !
!Float methodsFor: 'testing' library: #MinimalKernel03Float stamp: 'jmv 8/1/2019 16:43:28' prior: 16869684!
                           isFinite
	"Infinities and Not a Number are only represented as BoxedFloat64"

	^ true! !
!Float methodsFor: 'testing' library: #MinimalKernel03Float stamp: 'jmv 8/2/2019 09:22:50' prior: 16869690!
                           isInfinite
	"Infinities are only represented as BoxedFloat64"

	^ false
! !
!Float methodsFor: 'testing' library: #MinimalKernel03Float stamp: 'jmv 8/1/2019 16:40:18' prior: 16869695!
        isNaN
	"Not a Number are only represented as BoxedFloat64"

	^ false! !
!Float methodsFor: 'testing' library: #MinimalKernel03Float stamp: '' prior: 16869699!
 isZero
	^self = 0.0! !
!Float methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'ar 6/20/2010 14:28' prior: 16869702!
                              at: index 
	"Avoid primitive in Object>>at:"

	^self basicAt: index! !
!Float methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'ar 6/20/2010 14:28' prior: 16869707!
              at: index put: value 
	"Avoid primitive in Object>>at:put:"

	^self basicAt: index put: value! !
!Float methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'eem 4/20/2009 09:34' prior: 16869713!
                   basicAt: index
	"Primitive. Assumes receiver is indexable. Answer the value of an 
	indexable element in the receiver. Fail if the argument index is not an 
	Integer or is out of bounds. Essential. Do not override in a subclass. See 
	Object documentation whatIsAPrimitive.

	This version of basicAt: is specifically for floats, answering the most significant
	word for index 1 and the least significant word for index 2.  This alows the VM
	to store floats in whatever order it chooses while it appears to the image that
	they are always in big-endian/PowerPC order."

	<primitive: 38>
	| ec |
	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."
		[^super basicAt: index].
	index isInteger ifTrue: [self errorSubscriptBounds: index].
	index isNumber
		ifTrue: [^self basicAt: index asInteger]
		ifFalse: [self errorNonIntegerIndex]! !
!Float methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'eem 4/20/2009 09:35' prior: 16869743!
            basicAt: index put: value
	"Primitive. Assumes receiver is indexable. Store the second argument 
	value in the indexable element of the receiver indicated by index. Fail 
	if the index is not an Integer or is out of bounds. Or fail if the value is 
	not of the right type for this kind of collection. Answer the value that 
	was stored. Essential. Do not override in a subclass. See Object 
	documentation whatIsAPrimitive.

	This version of basicAt: is specifically for floats, answering the most significant
	word for index 1 and the least significant word for index 2.  This alows the VM
	to store floats in whatever order it chooses while it appears to the image that
	they are always in big-endian/PowerPC order."

	<primitive: 39>
	| ec |
	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."
		[^super basicAt: index put: value].
	index isInteger
		ifTrue: [(index >= 1 and: [index <= self size])
					ifTrue: [self errorImproperStore]
					ifFalse: [self errorSubscriptBounds: index]].
	index isNumber
		ifTrue: [^self basicAt: index asInteger put: value]
		ifFalse: [self errorNonIntegerIndex]! !
!Float methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'jmv 12/26/2018 14:33:27' prior: 16869781!
                            exponentPart
	"
	Exponent part of the floating point representation.
	Valid for any floating point number (except zeros, infinities and NaNs).
	Includes correction of stored exponent bits for denormals (where it acts as a label, not a real exponent).
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self partValues: [ :sign :exponent :mantissa | exponent ]! !
!Float methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'jmv 12/26/2018 14:28:48' prior: 16869800!
                 mantissaPart
	"Equivalent to #significandAsInteger."
	"The actual bits in the mantissa of the receiver, as an integer, including the implicit leading 1 if appropriate.
	Does not include the sign.
	See #exponentPart and #signPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f mantissaPart * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self partValues: [ :sign :exponent :mantissa | mantissa ]! !
!Float methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'jmv 12/20/2024 16:45:10' prior: 16869818!
               nextTowardsZero
	"Answer the Float with largest magnitude but smaller than ours, with the same sign.
	Only for finite, non zero numbers."

	^ self partValues: [ :sign :myExponent :myMantissa |
		| exponent mantissa |
		myMantissa isZero ifTrue: [ self error: 'Not for zero values' ].
		(myMantissa = 16r10000000000000 and: [myExponent > Float emin])
			ifTrue: [
				mantissa := 16r1FFFFFFFFFFFFF.
				exponent := myExponent -1 ]
			ifFalse: [
				mantissa := myMantissa-1.
				exponent := myExponent ].
		Float signPart: sign mantissaPart: mantissa exponentPart:  exponent ]! !
!Float methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'jmv 4/5/2019 16:14:46' prior: 16869839!
               sign
	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.
	Handle IEEE754 negative-zero by reporting a sign of -1
	Warning!! This makes Float negativeZero the only number in the system such that
		x sign negated = x negated sign
	evaluates to false!!
	This precludes the simpler implementation in #signPart
	0.0 sign  ->  0
	0.0 signPart   ->  1
	-0.0 sign   ->  -1
	-0.0 signPart   ->  -1
	"

	"Negative number or -0.0"
	self signBit = 1 ifTrue: [ ^ -1 ].

	"Zero"
	self = 0.0 ifTrue: [ ^ 0 ].

	"Positive number otherwise"
	^ 1! !
!Float methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'jmv 4/5/2019 16:14:21' prior: 16869859!
         signPart
	"The sign of the mantissa.
	1 means positive number or 0.0
	-1 means negative number or -0.0
	See #mantissaPart and #exponentPart"
	"
	| f |
	f := -2.0.
	(f signPart * f mantissaPart * (2 raisedToInteger: f exponentPart-52)) asFloat.
	"
	^self partValues: [ :sign :exponent :mantissa | sign ]! !
!Float methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'jmv 12/26/2018 15:00:07' prior: 16869871!
                              significandAsInteger
	"The actual bits in the mantissa of the receiver, as an integer, including the implicit leading 1 if appropriate.
	See #mantissaPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. (f signPart * f significandAsInteger * (2 raisedToInteger: f exponentPart-52)) asFloat = f } print ].
	"
	^self mantissaPart! !
!Float methodsFor: 'printing' library: #MinimalKernel03Float stamp: 'nice 4/20/2010 22:48' prior: 16869885!
                             absPrintExactlyOn: aStream base: base
	"Print my value on a stream in the given base.  Assumes that my value is strictly
	positive; negative numbers, zero, and NaNs have already been handled elsewhere.
	Based upon the algorithm outlined in:
	Robert G. Burger and R. Kent Dybvig
	Printing Floating Point Numbers Quickly and Accurately
	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation
	June 1996.
	https://www.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf
	This version guarantees that the printed representation exactly represents my value
	by using exact integer arithmetic.
	See also #absPrintOn:base:mantissaSignificantBits:"

	| significand exp baseExpEstimate r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount slowbit shead |
	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].
	significand := self significandAsInteger.
	roundingIncludesLimits := significand even.
	"What follows is equivalent, but faster than
		exp := self exponentPart - 52."
	exp := (self exponent - 52) max: MinValLogBase2.
	baseExpEstimate := (self exponent * base asFloat reciprocalLogBase2 - 1.0e-10) ceiling.
	exp >= 0
		ifTrue:
			[significand ~= 16r10000000000000
				ifTrue:
					[r := significand bitShift: 1 + exp.
					s := 2.
					mPlus := mMinus := 1 bitShift: exp]
				ifFalse:
					[r := significand bitShift: 2 + exp.
					s := 4.
					mPlus := 2 * (mMinus := 1 bitShift: exp)]]
		ifFalse:
			[(exp = MinValLogBase2 or: [significand ~= 16r10000000000000])
				ifTrue:
					[r := significand bitShift: 1.
					s := 1 bitShift: 1 - exp.
					mPlus := mMinus := 1]
				ifFalse:
					[r := significand bitShift: 2.
					s := 1 bitShift: 2 - exp.
					mPlus := 2.
					mMinus := 1]].
	baseExpEstimate >= 0
		ifTrue: [s := s * (base raisedToInteger: baseExpEstimate)]
		ifFalse:
			[scale := base raisedToInteger: baseExpEstimate negated.
			r := r * scale.
			mPlus := mPlus * scale.
			mMinus := mMinus * scale].
	((r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])
		ifTrue: [baseExpEstimate := baseExpEstimate + 1]
		ifFalse:
			[r := r * base.
			mPlus := mPlus * base.
			mMinus := mMinus * base].
	(fixedFormat := baseExpEstimate between: -3 and: 6)
		ifTrue:
			[decPointCount := baseExpEstimate.
			baseExpEstimate <= 0
				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]
		ifFalse:
			[decPointCount := 1].
	slowbit := 1 - s lowBit .
	shead := s bitShift: slowbit.
	[d := (r bitShift: slowbit) // shead.
	r := r - (d * s).
	(tc1 := (r > mMinus) not and: [roundingIncludesLimits or: [r < mMinus]]) |
	(tc2 := (r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])] whileFalse:
		[aStream nextPut: (Character digitValue: d).
		r := r * base.
		mPlus := mPlus * base.
		mMinus := mMinus * base.
		decPointCount := decPointCount - 1.
		decPointCount = 0 ifTrue: [aStream nextPut: $.]].
	tc2 ifTrue:
		[(tc1 not or: [r * 2 >= s]) ifTrue: [d := d + 1]].
	aStream nextPut: (Character digitValue: d).
	decPointCount > 0
		ifTrue:
		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].
		aStream nextPutAll: '.0'].
	fixedFormat ifFalse:
		[aStream nextPut: $e.
		aStream nextPutAll: (baseExpEstimate - 1) printString]! !
!Float methodsFor: 'printing' library: #MinimalKernel03Float stamp: 'jmv 9/24/2018 10:56:53' prior: 16869990!
                     absPrintOn: aStream base: base
	"In Cuis, print Floats with enough digits to be able to recover later exactly the same Float."

	self absPrintExactlyOn: aStream base: base! !
!Float methodsFor: 'printing' library: #MinimalKernel03Float stamp: 'jmv 5/31/2021 07:37:11' prior: 16869998!
   printOn: aStream base: base
	"Handle sign, zero, and NaNs; all other values passed to absPrintOn:base:" 

	self isNaN ifTrue: [aStream nextPutAll: 'NaN'. ^ self]. "check for NaN before sign"
	self > 0.0
		ifTrue: [self absPrintOn: aStream base: base]
		ifFalse:
			[self sign = -1
				ifTrue: [aStream nextPutAll: '-'].
			self = 0.0
				ifTrue: [aStream nextPutAll: '0.0']
				ifFalse: [self negated absPrintOn: aStream base: base]]! !
!Float methodsFor: 'arithmetic' library: #MinimalKernel03Float stamp: 'nice 8/21/2010 22:31' prior: 16869534!
                             abs
	"This is faster than using Number abs and works for negativeZero."
	self <= 0.0
		ifTrue: [^ 0.0 - self]
		ifFalse: [^ self]! !
!Float methodsFor: 'arithmetic' library: #MinimalKernel03Float stamp: 'nice 12/20/2012 23:16' prior: 16869541!
            negated
	"Answer a Number that is the negation of the receiver.
	Implementation note: this version cares of negativeZero."

	^-1.0 * self! !
!Float class methodsFor: 'instance creation' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16871238!
                        basicNew
	^BoxedFloat64 basicNew: 2! !
!Float class methodsFor: 'instance creation' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16871242!
                              basicNew: anInteger
	^BoxedFloat64 basicNew: 2! !
!Float class methodsFor: 'instance creation' library: #MinimalKernel03Float stamp: 'jmv 4/2/2013 14:00' prior: 16871247!
                     new
	"Floats are 2 words of size"
	^self basicNew: 2! !
!Float class methodsFor: 'instance creation' library: #MinimalKernel03Float stamp: 'jmv 4/2/2013 14:04' prior: 16871252!
               new: s
	self error: 'Please call Float>>#new (without arguments).'.
	^self new! !
!Float class methodsFor: 'instance creation' library: #MinimalKernel03Float stamp: 'jmv 12/26/2018 13:54:36' prior: 16871258!
                signPart: signPart mantissaPart: mantissaPart exponentPart: exponentPart
	"
	Float signPart: Float pi signPart mantissaPart: Float pi mantissaPart exponentPart: Float pi exponentPart
	"
	^ mantissaPart asFloat * signPart timesTwoPower: exponentPart-52! !
!Float class methodsFor: 'constants' library: #MinimalKernel03Float stamp: 'nice 6/8/2009 15:33' prior: 16871269!
               fmin
	"Answer minimum positive representable value."
	
	^self denormalized
		ifTrue: [self fminDenormalized]
		ifFalse: [self fminNormalized]! !
!Float class methodsFor: 'constants' library: #MinimalKernel03Float stamp: 'jmv 4/5/2019 17:28:36' prior: 16871277!
                           fminDenormalized
	"Answer the minimum denormalized value representable.
	Denormalized numbers guarantees that the result x - y is non-zero when x !!= y.
	"
	
	^1.0 timesTwoPower: MinValLogBase2! !
!Float class methodsFor: 'constants' library: #MinimalKernel03Float stamp: 'jmv 10/13/2011 19:57' prior: 16871286!
        maxExactInteger
	"Answer the biggest integer such that it is exactly represented in a float, and all smaller integers also are"
	^1 bitShift: self precision! !
!Float class methodsFor: 'constants' library: #MinimalKernel03Float stamp: 'GabrielOmarCotelli 5/25/2009 15:42' prior: 16871294!
                               one
	
	^1.0! !
!Float class methodsFor: 'constants' library: #MinimalKernel03Float stamp: 'ST-80 5/31/1983 9:10:35' prior: 16871298!
                           pi
	"Answer the constant, Pi."
	^Pi! !
!Float class methodsFor: 'constants' library: #MinimalKernel03Float stamp: 'jmv 12/26/2018 13:44:22' prior: 16871302!
   precision
	"Answer the apparent precision of the floating point representation.
	That is the maximum number of radix-based digits (bits if radix=2) representable in floating point without rounding error.
	Technically, 52 bits are stored in the representation, and normalized numbers have an implied leading 1 that is not stored.
	Note that denormalized floating point numbers don't have the implied leading 1, and thus gradually lose precision.
	This format implements the IEEE 754 binary64 format."
	
	^53! !
!Float class methodsFor: 'class initialization' library: #MinimalKernel03Float stamp: 'jmv 12/26/2018 13:08:28' prior: 16871321!
 initClassCachedState
	"Float initialize"
	"Constants from Computer Approximations, pp. 182-183:
		Pi = 3.14159265358979323846264338327950288
		Pi/2 = 1.57079632679489661923132169163975144
		Pi*2 = 6.28318530717958647692528676655900576
		Pi/180 = 0.01745329251994329576923690768488612
		2.0 ln = 0.69314718055994530941723212145817657
		2.0 sqrt = 1.41421356237309504880168872420969808"

	Pi := 3.14159265358979323846264338327950288.
	Halfpi := Pi / 2.0.
	Twopi := Pi * 2.0.
	RadiansPerDegree := Pi / 180.0.

	Ln2 := 0.69314718055994530941723212145817657.
	Ln10 := 10.0 ln.
	Sqrt2 := 1.41421356237309504880168872420969808.
	E := 2.718281828459045235360287471353.

	MaxVal := 1.7976931348623157e308.
	MaxValLn := 709.782712893384.
	MinValLogBase2 := -1074.

	Infinity := MaxVal * MaxVal.
	NegativeInfinity := 0.0 - Infinity.
	NaN := Infinity - Infinity.
	NegativeZero := Float fmin negated nextTowardsZero.
! !
!Float class methodsFor: 'class initialization' library: #MinimalKernel03Float stamp: 'jmv 12/14/2015 23:48' prior: 16871353!
                      initialize
	"
	Float initialize
	"
	"Constants from Computer Approximations, pp. 182-183:
		Pi = 3.14159265358979323846264338327950288
		Pi/2 = 1.57079632679489661923132169163975144
		Pi*2 = 6.28318530717958647692528676655900576
		Pi/180 = 0.01745329251994329576923690768488612
		2.0 ln = 0.69314718055994530941723212145817657
		2.0 sqrt = 1.41421356237309504880168872420969808"

	self initClassCachedState! !
!Float class methodsFor: 'testing' library: #MinimalKernel03Float stamp: 'jmv 4/26/2019 09:02:14' prior: 16871369!
                   denormalized
	"Answer whether implementation supports denormalized numbers.
	Allowing denormalized numbers guarantees that the result x - y is non-zero when x !!= y."
	
	^true! !
!BoxedFloat64 methodsFor: 'mathematical functions' library: #MinimalKernel03Float stamp: 'jmv 11/27/2018 11:14:45' prior: 16797115!
         ln
	"Answer the natural logarithm of the receiver.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 58>
	^ self lnNonPrimitive! !
!BoxedFloat64 methodsFor: 'mathematical functions' library: #MinimalKernel03Float stamp: 'jmv 8/2/2019 10:36:02' prior: 16797123!
       raisedToInteger: exponent
	"Answer the receiver raised to aNumber."

	self isNaN ifTrue: [ ^self ].
	^super raisedToInteger: exponent! !
!BoxedFloat64 methodsFor: 'mathematical functions' library: #MinimalKernel03Float stamp: 'jmv 8/1/2019 19:10:12' prior: 16797131!
                     timesTwoPower: anInteger
	"Primitive. Answer with the receiver multiplied by 2 raised to the power of the argument.
	Optional. See Object documentation whatIsAPrimitive."

	<primitive: 54>
	anInteger isInteger ifFalse: [ ^DomainError signal: '#timesTwoPower: only defined for Integer argument.'].
	self isFinite ifFalse: [^self].
	self isZero ifTrue: [^self].
	
	"Make sure that (2.0 raisedTo: Integer) can be safely used without overflow
	For example:
		Float fminNormalized * (2.0 raisedTo: 2000) = Float infinity.
	while:
		(Float fminNormalized timesTwoPower: 2000) = (2.0 raisedTo: 2000+Float emin)."	
	anInteger > Float emax ifTrue: [^(self timesTwoPower: Float emax) timesTwoPower: anInteger - Float emax].
	
	"In case of gradual underflow, timesTwoPower: is not exact, so greatest care must be taken
	because two consecutive timesTwoPower: might differ from a single one"
	anInteger < Float emin
		ifTrue: [
			| deltaToUnderflow |
			deltaToUnderflow := Float emin - self exponent max: Float emin.
			deltaToUnderflow >= 0 ifTrue: [
				"self is already near or past underflow, so don't care, result will be zero"
				deltaToUnderflow := Float emin].
			^(self timesTwoPower: deltaToUnderflow) timesTwoPower: anInteger - deltaToUnderflow].
	
	"If (2.0 raisedToInteger: anInteger) fit in a positive SmallInteger, then use faster SmallInteger conversion.
	Note that SmallInteger maxVal highBit = 30 in a 32 bits image, so 1 can be shifted 29 times."
	anInteger > -29 ifTrue: [
		anInteger < 0 ifTrue: [^ self / (1 bitShift: (0 - anInteger)) asFloat].
		anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat]].
	
	^ self * (2.0 raisedToInteger: anInteger)! !
!BoxedFloat64 methodsFor: 'arithmetic' library: #MinimalKernel03Float stamp: 'di 11/6/1998 13:54' prior: 16796996!
 * aNumber 
	"Primitive. Answer the result of multiplying the receiver by aNumber.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 49>
	^ aNumber adaptToFloat: self andSend: #*! !
!BoxedFloat64 methodsFor: 'arithmetic' library: #MinimalKernel03Float stamp: 'di 11/6/1998 13:22' prior: 16797006!
                              + aNumber 
	"Primitive. Answer the sum of the receiver and aNumber. Essential.
	Fail if the argument is not a Float. See Object documentation
	whatIsAPrimitive."

	<primitive: 41>
	^ aNumber adaptToFloat: self andSend: #+! !
!BoxedFloat64 methodsFor: 'arithmetic' library: #MinimalKernel03Float stamp: 'di 11/6/1998 13:55' prior: 16797016!
            - aNumber 
	"Primitive. Answer the difference between the receiver and aNumber.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 42>
	^ aNumber adaptToFloat: self andSend: #-! !
!BoxedFloat64 methodsFor: 'arithmetic' library: #MinimalKernel03Float stamp: 'jmv 6/25/2019 17:44:27' prior: 16797026!
                            / aNumber 
	"Primitive. Answer the result of dividing receiver by aNumber.
	Fail if the argument is not a Float.
	Essential. See Object clas >> whatIsAPrimitive."

	<primitive: 50>
	aNumber isZero ifTrue: [^ ZeroDivide new signalReceiver: self selector: #/ argument: aNumber].
	^ aNumber adaptToFloat: self andSend: #/! !
!BoxedFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'di 11/6/1998 13:55' prior: 16797039!
            < aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is less than the argument. Otherwise return false.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 43>
	^ aNumber adaptToFloat: self andSend: #<! !
!BoxedFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'di 11/6/1998 13:55' prior: 16797051!
                              <= aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is less than or equal to the argument. Otherwise return
	false. Fail if the argument is not a Float. Optional. See Object
	documentation whatIsAPrimitive."

	<primitive: 45>
	^ aNumber adaptToFloat: self andSend: #<=! !
!BoxedFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'di 11/6/1998 13:56' prior: 16797064!
                 = aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is equal to the argument. Otherwise return false.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 47>
	aNumber isNumber ifFalse: [^ false].
	^ aNumber adaptToFloat: self andSend: #=! !
!BoxedFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'di 11/6/1998 13:57' prior: 16797078!
                         > aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is greater than the argument. Otherwise return false.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 44>
	^ aNumber adaptToFloat: self andSend: #>! !
!BoxedFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'eem 7/6/2009 11:11' prior: 16797091!
                           >= aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is greater than or equal to the argument. Otherwise return
	false. Fail if the argument is not a Float. Optional. See Object documentation 
	whatIsAPrimitive. "

	<primitive: 46>
	^ aNumber adaptToFloat: self andSend: #>=! !
!BoxedFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: '' prior: 16797103!
                              ~= aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is not equal to the argument. Otherwise return false.
	Fail if the argument is not a Float. Optional. See Object documentation
	whatIsAPrimitive."

	<primitive: 48>
	^super ~= aNumber! !
!BoxedFloat64 methodsFor: 'testing' library: #MinimalKernel03Float stamp: 'jmv 4/8/2019 09:43:27' prior: 16797186!
                 isDenormalized
	"Denormalized numbers are only represented as BoxedFloat64"

	^ self partBits: [ :signBit :exponentBits :mantissaBits |
		exponentBits = 0 and: [mantissaBits ~=0]]! !
!BoxedFloat64 methodsFor: 'testing' library: #MinimalKernel03Float stamp: 'jmv 8/1/2019 16:42:44' prior: 16797195!
                      isFinite
	"simple, byte-order independent test for rejecting Not-a-Number and (Negative)Infinity"

	^(self - self) = 0.0! !
!BoxedFloat64 methodsFor: 'testing' library: #MinimalKernel03Float stamp: 'jmv 8/1/2019 16:42:00' prior: 16797202!
                 isInfinite
	"Return true if the receiver is positive or negative infinity."

	^ self = Infinity or: [self = NegativeInfinity]! !
!BoxedFloat64 methodsFor: 'testing' library: #MinimalKernel03Float stamp: 'jmv 8/1/2019 16:39:56' prior: 16797209!
            isNaN
	"simple, byte-order independent test for Not-a-Number"

	^ self ~= self! !
!BoxedFloat64 methodsFor: 'truncation and round off' library: #MinimalKernel03Float stamp: 'jmv 5/21/2020 22:23:44' prior: 16797215!
         truncated
	"Answer with a SmallInteger equal to the value of the receiver without 
	its fractional part. The primitive fails if the truncated value cannot be 
	represented as a SmallInteger. In that case, the code below will compute 
	a LargeInteger truncated value.
	Raise an exception if no conversion to integer is possible, i.e. for Infinities and NaN.
	Essential. See Object documentation whatIsAPrimitive. "

	<primitive: 51>
	self isFinite ifFalse: [ ^self ].
	^ self partValues: [ :sign :exponent :mantissa |
		sign * (mantissa bitShift: exponent - 52) ]! !
!BoxedFloat64 methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'jmv 2/8/2021 18:54:45' prior: 16797236!
                     exponent
	"Primitive. Consider the receiver to be represented as a power of two
	multiplied by a mantissa between one and two  or between -1 and -2 (#significand).
	 Answer with the SmallInteger to whose power two is raised.
	Optional. See Object documentation whatIsAPrimitive.
	Note: invalid for infinities, NaN and zero.
	See also #signPart,  #significandAsInteger and #exponentPart
	"
	"
	{Float pi. Float fminNormalized. Float fminDenormalized. 2.0. -2.0} do: [ :f |
		{f. f significand . f exponent. f significand * (2 raisedToInteger: f exponent) = f } print ].
	"

	<primitive: 53>
	^super exponent! !
!BoxedFloat64 methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'jmv 8/1/2019 16:53:05' prior: 16797258!
         sign
	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0."

	self isNaN ifTrue: [ self error: 'Can not handle Not-a-Number' ].
	^super sign! !
!SmallFloat64 methodsFor: 'mathematical functions' library: #MinimalKernel03Float stamp: 'jmv 11/27/2018 11:14:36' prior: 16959210!
                         ln
	"Answer the natural logarithm of the receiver.
	 Optional. See Object documentation whatIsAPrimitive."

	<primitive: 558>
	^ self lnNonPrimitive! !
!SmallFloat64 methodsFor: 'mathematical functions' library: #MinimalKernel03Float stamp: 'jmv 8/1/2019 19:10:21' prior: 16959218!
      timesTwoPower: anInteger
	"Primitive. Answer with the receiver multiplied by 2 raised to the power of the argument.
	Optional. See Object documentation whatIsAPrimitive."

	<primitive: 554>
	anInteger isInteger ifFalse: [ ^DomainError signal: '#timesTwoPower: only defined for Integer argument.'].
	self isFinite ifFalse: [^self].
	self isZero ifTrue: [^self].
	
	"Make sure that (2.0 raisedTo: Integer) can be safely used without overflow
	For example:
		Float fminNormalized * (2.0 raisedTo: 2000) = Float infinity.
	while:
		(Float fminNormalized timesTwoPower: 2000) = (2.0 raisedTo: 2000+Float emin)."	
	anInteger > Float emax ifTrue: [^(self timesTwoPower: Float emax) timesTwoPower: anInteger - Float emax].
	
	"In case of gradual underflow, timesTwoPower: is not exact, so greatest care must be taken
	because two consecutive timesTwoPower: might differ from a single one"
	anInteger < Float emin
		ifTrue: [
			| deltaToUnderflow |
			deltaToUnderflow := Float emin - self exponent max: Float emin.
			deltaToUnderflow >= 0 ifTrue: [
				"self is already near or past underflow, so don't care, result will be zero"
				deltaToUnderflow := Float emin].
			^(self timesTwoPower: deltaToUnderflow) timesTwoPower: anInteger - deltaToUnderflow].
	
	"If (2.0 raisedToInteger: anInteger) fit in a positive SmallInteger, then use faster SmallInteger conversion.
	Note that SmallInteger maxVal highBit = 30 in a 32 bits image, so 1 can be shifted 29 times."
	anInteger > -29 ifTrue: [
		anInteger < 0 ifTrue: [^ self / (1 bitShift: (0 - anInteger)) asFloat].
		anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat]].
	
	^ self * (2.0 raisedToInteger: anInteger)! !
!SmallFloat64 methodsFor: 'accessing' library: #MinimalKernel03Float stamp: 'jmv 2/8/2021 18:54:52' prior: 16959294!
                              exponent
	"Primitive. Consider the receiver to be represented as a power of two
	multiplied by a mantissa between one and two (#significand).
	 Answer with the SmallInteger to whose power two is raised.
	Optional. See Object documentation whatIsAPrimitive.
	Note: invalid for infinities, NaN and zero.
	See comment at BoxedFloat64"

	<primitive: 553>
	^super exponent! !
!SmallFloat64 methodsFor: 'arithmetic' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16959080!
                        * aNumber 
	"Primitive. Answer the result of multiplying the receiver by aNumber.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 549>
	^ aNumber adaptToFloat: self andSend: #*! !
!SmallFloat64 methodsFor: 'arithmetic' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16959091!
                           + aNumber 
	"Primitive. Answer the sum of the receiver and aNumber. Essential.
	Fail if the argument is not a Float. See Object documentation
	whatIsAPrimitive."

	<primitive: 541>
	^ aNumber adaptToFloat: self andSend: #+! !
!SmallFloat64 methodsFor: 'arithmetic' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16959101!
         - aNumber 
	"Primitive. Answer the difference between the receiver and aNumber.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 542>
	^ aNumber adaptToFloat: self andSend: #-! !
!SmallFloat64 methodsFor: 'arithmetic' library: #MinimalKernel03Float stamp: 'jmv 6/25/2019 18:01:31' prior: 16959112!
                           / aNumber 
	"Primitive. Answer the result of dividing receiver by aNumber.
	Fail if the argument is not a Float.
	Essential. See Object clas >> whatIsAPrimitive."

	<primitive: 550>
	aNumber isZero ifTrue: [^ZeroDivide new signalReceiver: self selector: #/ argument: aNumber ].
	^ aNumber adaptToFloat: self andSend: #/! !
!SmallFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16959125!
         < aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is less than the argument. Otherwise return false.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 543>
	^ aNumber adaptToFloat: self andSend: #<! !
!SmallFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16959138!
                           <= aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is less than or equal to the argument. Otherwise return
	false. Fail if the argument is not a Float. Optional. See Object
	documentation whatIsAPrimitive."

	<primitive: 545>
	^ aNumber adaptToFloat: self andSend: #<=! !
!SmallFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16959151!
              = aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is equal to the argument. Otherwise return false.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 547>
	aNumber isNumber ifFalse: [^ false].
	^ aNumber adaptToFloat: self andSend: #=! !
!SmallFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16959165!
                      > aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is greater than the argument. Otherwise return false.
	Fail if the argument is not a Float. Essential. See Object documentation
	whatIsAPrimitive."

	<primitive: 544>
	^ aNumber adaptToFloat: self andSend: #>! !
!SmallFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16959178!
                        >= aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is greater than or equal to the argument. Otherwise return
	false. Fail if the argument is not a Float. Optional. See Object documentation 
	whatIsAPrimitive. "

	<primitive: 546>
	^ aNumber adaptToFloat: self andSend: #>=! !
!SmallFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16959191!
         ~= aNumber 
	"Primitive. Compare the receiver with the argument and return true
	if the receiver is not equal to the argument. Otherwise return false.
	Fail if the argument is not a Float. Optional. See Object documentation
	whatIsAPrimitive."

	<primitive: 548>
	^super ~= aNumber! !
!SmallFloat64 methodsFor: 'comparing' library: #MinimalKernel03Float stamp: 'eem 12/22/2014 12:36' prior: 16959203!
               identityHash
	"Answer an integer unique to the receiver."
	<primitive: 171>
	^self primitiveFailed! !
!SmallFloat64 methodsFor: 'truncation and round off' library: #MinimalKernel03Float stamp: 'jmv 8/2/2019 09:34:46' prior: 16959274!
                      truncated
	"Answer with a SmallInteger equal to the value of the receiver without 
	its fractional part. The primitive fails if the truncated value cannot be 
	represented as a SmallInteger. In that case, the code below will compute 
	a LargeInteger truncated value.
	Raise an exception if no conversion to integer is possible, i.e. for Infinities and NaN.
	Essential. See Object documentation whatIsAPrimitive. "

	<primitive: 551>

	^ self partValues: [ :sign :exponent :mantissa |
		sign * (mantissa bitShift: exponent - 52) ]! !
!SmallFloat64 methodsFor: 'copying' library: #MinimalKernel03Float stamp: 'eem 11/25/2014 07:54' prior: 16959309!
                         shallowCopy
	"Answer the receiver, because SmallFloat64s are unique."
	^self! !
!SmallInteger methodsFor: 'converting' library: #MinimalKernel03Float stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16959809!
                   asFloat
	"Primitive. Answer a Float that represents the value of the receiver.
	Essential. See Object documentation whatIsAPrimitive."

	<primitive: 40>
	self primitiveFailed! !

Float initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7460-library-MinimalKernel03-JuanVuletich-2025Aug28-15h11m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7456] on 28 August 2025 at 3:23:14 pm'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7461-library-MinimalKernel03-cleanup-JuanVuletich-2025Aug28-15h15m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7456] on 28 August 2025 at 3:25:56 pm'!
!Collection methodsFor: 'enumerating' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16828143!
               associationsDo: aBlock
	"Evaluate aBlock for each of the receiver's elements (key/value 
	associations).  If any non-association is within, the error is not caught now,
	but later, when a key or value message is sent to it."

	self do: aBlock! !
!Set methodsFor: 'accessing' library: #MinimalKernel04HashedCollections stamp: 'ST-80 5/31/1983 9:10:35' prior: 16957414!
                size
	^tally! !
!Set methodsFor: 'enumerating' library: #MinimalKernel04HashedCollections stamp: 'jmv 5/27/2015 13:49' prior: 16957452!
                        do: aBlock 
	| each |
	tally = 0 ifTrue: [^ self].
	1 to: array size do: [ :index |
		(each := array at: index) ifNotNil: [aBlock value: each]]! !
!Set methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'len 2/26/2016 21:29' prior: 16957460!
                         atNewIndex: index put: anObject
	array at: index put: anObject.
	tally := tally + 1.
	self fullCheck.
	^ anObject! !
!Set methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.2 6/29/1997 10:40:55' prior: 16957467!
              findElementOrNil: anObject
	"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found."
	| index |
	index := self scanFor: anObject.
	index > 0 ifTrue: [ ^ index ].

	"Bad scene.  Neither have we found a matching element
	nor even an empty slot.  No hashed set is ever supposed to get
	completely full."
	self error: 'There is no free space in this set!!'.! !
!Set methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'di 11/4/97 20:11' prior: 16957486!
     fullCheck
	"Keep array at least 1/4 free for decent hash behavior"
	array size - tally < (array size // 4 max: 1)
		ifTrue: [self grow]! !
!Set methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'jmv 3/1/2010 13:19' prior: 16957493!
  grow
	"Grow the elements array and reinsert the old elements"
	| oldElements |
	oldElements := array.
	array := Array new: array size + self growSize.
	tally := 0.
	oldElements do: [ :each |
		each ifNotNil: [self noCheckAdd: each]]! !
!Set methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16957504!
                       growSize
	^ array size max: 2! !
!Set methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16957508!
  init: n
	"Initialize array to an array size of n"
	array := Array new: n.
	tally := 0! !
!Set methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16957514!
          noCheckAdd: anObject
	array at: (self findElementOrNil: anObject) put: anObject.
	tally := tally + 1! !
!Set methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.2 6/29/1997 10:40:55' prior: 16957521!
                           scanFor: anObject
	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."
	| element start finish |
	start := (anObject hash \\ array size) + 1.
	finish := array size.

	"Search from (hash mod size) to the end."
	start to: finish do:
		[:index | ((element := array at: index) == nil or: [element = anObject])
			ifTrue: [^ index ]].

	"Search from 1 to where we started."
	1 to: start-1 do:
		[:index | ((element := array at: index) == nil or: [element = anObject])
			ifTrue: [^ index ]].

	^ 0  "No match AND no empty slot"! !
!Set methodsFor: 'testing' library: #MinimalKernel04HashedCollections stamp: 'jmv 1/10/2025 10:49:13' prior: 16957418!
    includes: anObject 
	^ (self lookup: anObject) ~~ nil! !
!Set methodsFor: 'testing' library: #MinimalKernel04HashedCollections stamp: 'jmv 7/4/2016 22:16' prior: 16957423!
                    is: aSymbol
	^aSymbol == #Set or: [ super is: aSymbol ]! !
!Set methodsFor: 'comparing' library: #MinimalKernel04HashedCollections stamp: 'jmv 6/12/2019 18:05:55' prior: 16957428!
            = aSet

	self == aSet ifTrue: [^ true].	"Any object is equal to itself"
	(aSet is: #Set) ifFalse: [^ false].
	(aSet is: #Dictionary) ifTrue: [^ false].
	self size = aSet size ifFalse: [^ false].
	self do: [ :each | (aSet includes: each) ifFalse: [^ false]].
	^ true! !
!Set methodsFor: 'comparing' library: #MinimalKernel04HashedCollections stamp: 'jmv 6/12/2019 18:09:50' prior: 16957440!
                          emptyCollectionHash
	^ Set hash! !
!Set methodsFor: 'lookup' library: #MinimalKernel04HashedCollections stamp: 'jmv 1/10/2025 10:48:11' prior: 16957444!
       lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise."

	^ array at: (self findElementOrNil: anObject).! !
!Set methodsFor: 'copying' library: #MinimalKernel04HashedCollections stamp: 'jmv 12/5/2014 11:02' prior: 16957548!
                 postCopy

	array := array copy! !
!Set class methodsFor: 'instance creation' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16957717!
                 new
	^ self newWithRoomForMoreThan: 4! !
!Set class methodsFor: 'instance creation' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16957722!
          newWithRoomForMoreThan: nElements
	"Create a Set large enough to hold nElements without growing"
	^ self basicNew init: (self sizeFor: nElements)! !
!Set class methodsFor: 'instance creation' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16957730!
                              sizeFor: nElements
	"Large enough size to hold nElements with some slop (see fullCheck)"
	nElements <= 0 ifTrue: [^ 1].
	^ nElements+1*4//3! !
!Dictionary methodsFor: 'accessing' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16848707!
           associationAt: key ifAbsent: aBlock 
	"Answer the association with the given key.
	If key is not found, return the result of evaluating aBlock."

	| index assoc |
	index := self findElementOrNil: key.
	assoc := array at: index.
	nil == assoc ifTrue: [ ^ aBlock value ].
	^ assoc! !
!Dictionary methodsFor: 'accessing' library: #MinimalKernel04HashedCollections stamp: 'JMM 12/12/2024 09:19:05' prior: 16848719!
     associationClass

	^Association! !
!Dictionary methodsFor: 'accessing' library: #MinimalKernel04HashedCollections stamp: 'jmv 9/20/2023 12:05:53' prior: 16848723!
                             at: key 
	"Answer the value at key.  If key is not found, create an error message."

	^self at: key ifAbsent: [ self errorKeyNotFound: key ]! !
!Dictionary methodsFor: 'accessing' library: #MinimalKernel04HashedCollections stamp: 'jmv 5/25/2014 15:51' prior: 16848731!
                   at: key ifAbsent: absentBlock
	"Answer the value associated with the key or, if key isn't found,
	answer the result of evaluating aBlock."

	| assoc |
	assoc := array at: (self findElementOrNil: key).
	assoc ifNil: [ ^ absentBlock value ].
	^ assoc value! !
!Dictionary methodsFor: 'accessing' library: #MinimalKernel04HashedCollections stamp: 'jmv 5/25/2014 15:51' prior: 16848742!
 at: key ifPresent: presentBlock
	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| v |
	v := self at: key ifAbsent: [ ^ nil ].
	^ presentBlock value: v
! !
!Dictionary methodsFor: 'accessing' library: #MinimalKernel04HashedCollections stamp: 'JMM 12/2/2024 09:54:17' prior: 16848754!
          at: key put: anObject
	"Set the value at key to be anObject. 
	If key is not found, create a new entry for key and set is value to anObject.
	If key is found, update the existing association.
	Answer anObject."

	| index assoc |
	index := self findElementOrNil: key.
	assoc := array at: index.
	assoc
		ifNil: [ self atNewIndex: index put: (self associationClass key: key value: anObject) ]
		ifNotNil: [ assoc value: anObject ].
	^ anObject! !
!Dictionary methodsFor: 'accessing' library: #MinimalKernel04HashedCollections stamp: 'jmv 11/1/2011 23:09' prior: 16848771!
      bindingOf: varName

	^self associationAt: varName ifAbsent: nil! !
!Dictionary methodsFor: 'testing' library: #MinimalKernel04HashedCollections stamp: 'RAA 8/23/2001 12:56' prior: 16848803!
  includesKey: key 
	"Answer whether the receiver has a key equal to the argument, key."
	
	self at: key ifAbsent: [^false].
	^true! !
!Dictionary methodsFor: 'testing' library: #MinimalKernel04HashedCollections stamp: 'jmv 7/4/2016 22:13' prior: 16848810!
 is: aSymbol
	^aSymbol == #Dictionary or: [ super is: aSymbol ]! !
!Dictionary methodsFor: 'enumerating' library: #MinimalKernel04HashedCollections stamp: 'ST-80 5/31/1983 9:10:35' prior: 16848777!
                           associationsDo: aBlock 
	"Evaluate aBlock for each of the receiver's key/value associations."

	super do: aBlock! !
!Dictionary methodsFor: 'enumerating' library: #MinimalKernel04HashedCollections stamp: 'ST-80 5/31/1983 9:10:35' prior: 16848784!
         do: aBlock 
	super do: [:assoc | aBlock value: assoc value]! !
!Dictionary methodsFor: 'enumerating' library: #MinimalKernel04HashedCollections stamp: 'ST-80 5/31/1983 9:10:35' prior: 16848789!
                              select: aBlock 
	"Evaluate aBlock with each of my values as the argument.  Collect into a new 
	dictionary, only those associations for which aBlock evaluates to true."

	| newCollection |
	newCollection := self species new.
	self associationsDo: 
		[:each | 
		(aBlock value: each value) ifTrue: [newCollection add: each]].
	^newCollection! !
!Dictionary methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16848854!
    noCheckAdd: anObject
	"Must be defined separately for Dictionary because (self findElementOrNil:) expects a key, not an association.  9/7/96 tk"

	array at: (self findElementOrNil: anObject key) put: anObject.
	tally := tally + 1! !
!Dictionary methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'SqR 2/20/2015 21:06' prior: 16848864!
                            postCopy
	"Must copy the associations, or later store will affect both the
original and the copy"

	array := array collect: [:each | each copy]! !
!Dictionary methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.2 6/29/1997 10:40:55' prior: 16848872!
         scanFor: anObject
	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."
	| element start finish |
	start := (anObject hash \\ array size) + 1.
	finish := array size.

	"Search from (hash mod size) to the end."
	start to: finish do:
		[:index | ((element := array at: index) == nil or: [element key = anObject])
			ifTrue: [^ index ]].

	"Search from 1 to where we started."
	1 to: start-1 do:
		[:index | ((element := array at: index) == nil or: [element key = anObject])
			ifTrue: [^ index ]].

	^ 0  "No match AND no empty slot"! !
!Dictionary methodsFor: 'lookup' library: #MinimalKernel04HashedCollections stamp: 'jmv 1/10/2025 10:48:44' prior: 16848698!
                      lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise."

	self do: [:each | anObject = each ifTrue: [^each]].
	^nil! !
!Dictionary methodsFor: 'comparing' library: #MinimalKernel04HashedCollections stamp: 'jmv 7/5/2016 09:20' prior: 16848815!
                              = aDictionary
	"Two dictionaries are equal if
	 (a) they are the same 'kind' of thing.
	 (b) they have the same set of keys.
	 (c) for each (common) key, they have the same value".

	self == aDictionary ifTrue: [^ true].	"Any object is equal to itself"
	(aDictionary is: #Dictionary) ifFalse: [^false].
	self size = aDictionary size ifFalse: [^false].
	self associationsDo: [:assoc|
		(aDictionary at: assoc key ifAbsent: [^false]) = assoc value
			ifFalse: [^false]].
	^true

! !
!Dictionary methodsFor: 'comparing' library: #MinimalKernel04HashedCollections stamp: 'jmv 6/12/2019 18:10:04' prior: 16848833!
                               emptyCollectionHash
	^ Dictionary hash! !
!Dictionary methodsFor: 'comparing' library: #MinimalKernel04HashedCollections stamp: 'jmv 6/12/2019 18:11:13' prior: 16848838!
                      hash
	"Note that this method is insensitive to contents when the size is greater than 10, so critical applications that compare many large collections of the same length will want to refine this behavior."

	| hash |
	hash := self emptyCollectionHash.
	self size <= 10 ifTrue: [
		self associationsDo: [ :association | hash := hash bitXor: association hash ]].
	^ hash bitXor: self size hash! !
!Dictionary methodsFor: 'variable bindings' library: #MinimalKernel04HashedCollections stamp: 'jmv 9/14/2023 10:06:58' prior: 16848900!
             declare: key from: aDictionary
	"Add key to the receiver. If key already exists, do nothing. If aDictionary 
	includes key, then remove it from aDictionary and use its association as 
	the element of the receiver. Answer it.
	If the key wasn't in the receiver or aDictionary, use nil as the value.
	Note: We allow aDictionary to be nil, although it normally is not."

	| association |
	(self includesKey: key) ifTrue: [^ nil].
	(aDictionary notNil and: [aDictionary includesKey: key])
		ifTrue: [
			association := aDictionary associationAt: key.
			self add: association.
			aDictionary removeKey: key.
			^ association ]
		ifFalse: [
			self at: key put: nil.
			^ nil ]! !
!IdentityDictionary methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'jmv 2/21/2020 12:33:35' prior: 16881647!
                      scanFor: anObject
	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."
	| finish scale start element |
	finish := array size.
	scale := finish // (Smalltalk maxIdentityHash + 1).
	scale = 0 ifTrue: [scale := 1].
	start := anObject identityHash * scale \\ finish + 1.

	"Search from (hash mod size) to the end."
	start to: finish do:
		[:index | ((element := array at: index) == nil or: [element key == anObject])
			ifTrue: [^ index ]].

	"Search from 1 to where we started."
	1 to: start-1 do:
		[:index | ((element := array at: index) == nil or: [element key == anObject])
			ifTrue: [^ index ]].

	^ 0  "No match AND no empty slot"! !
!SystemDictionary methodsFor: 'globals' library: #MinimalKernel04HashedCollections stamp: 'jmv 1/3/2016 00:22' prior: 16971055!
           at: aKey put: anObject 
	"Override from Dictionary to check Undeclared and fix up
	references to undeclared variables."

	| association |
	(self includesKey: aKey) ifFalse: [
		self flushClassNameCache.

		"Update existing association if there is one."
		(Undeclared includesKey: aKey) ifTrue: [
			association := self declare: aKey from: Undeclared.
			association value: anObject.
			^ anObject ]].

	"Update existing association if there is one."
	^super at: aKey put: anObject! !
!SystemDictionary methodsFor: 'globals' library: #MinimalKernel04HashedCollections stamp: 'jmv 12/28/2010 10:53' prior: 16971074!
                          flushClassNameCache
	"Smalltalk flushClassNameCache"
	"Forse recomputation of the cached list of class names."

	cachedClassNames := nil.
	cachedNonClassNames := nil! !
!SystemDictionary methodsFor: 'system attributes' library: #MinimalKernel04HashedCollections stamp: 'jmv 1/4/2024 15:39:42' prior: 16971083!
          maxIdentityHash
	"Answer the maximum identityHash value supported by the VM.
	Usually the VM is able to answer. It seems that SqueakJS (as of October 5, 2020) isn't.
	On primitive failure, still give a correct answer."

	<primitive: 176>	
	^ 16r3FFFFF							"22 bits in Spur"! !
!MethodDictionary methodsFor: 'accessing' library: #MinimalKernel04HashedCollections stamp: 'ul 6/18/2010 21:38' prior: 16906273!
       associationAt: key ifAbsent: aBlock 
	"Answer the association with the given key.
	If key is not found, return the result of evaluating aBlock."

	^(array at: (self scanFor: key)) 
		ifNil: [ aBlock value ]
		ifNotNil: [ :value | key -> value ]! !
!MethodDictionary methodsFor: 'accessing' library: #MinimalKernel04HashedCollections stamp: 'jmv 3/1/2010 11:41' prior: 16906284!
      at: key ifAbsent: aBlock

	| index |
	index := self findElementOrNil: key.
	(self basicAt: index) ifNil: [ ^ aBlock value ].
	^ array at: index! !
!MethodDictionary methodsFor: 'accessing' library: #MinimalKernel04HashedCollections stamp: 'jmv 3/1/2010 11:41' prior: 16906292!
           at: key put: value
	"Set the value at key to be value."
	| index |
	index := self findElementOrNil: key.
	(self basicAt: index)
		ifNil: [ 
			tally := tally + 1.
			self basicAt: index put: key]
		ifNotNil: [
			(array at: index) flushCache].
	array at: index put: value.
	self fullCheck.
	^ value! !
!MethodDictionary methodsFor: 'enumeration' library: #MinimalKernel04HashedCollections stamp: 'jmv 3/1/2010 11:45' prior: 16906305!
              associationsDo: aBlock 

	tally = 0 ifTrue: [^ self].
	1 to: self basicSize do: [ :i | 
		(self basicAt: i) ifNotNil: [ :key |
			aBlock value: (
				Association key: key value: (array at: i))]]! !
!MethodDictionary methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'jmv 2/5/2024 18:26:41' prior: 16906516!
                       grow 
	| newSelf |
	newSelf := self species newWithRoomForMoreThan: self basicSize.  "This will double the size"
	1 to: self basicSize do: [ :i |
		(self basicAt: i)
			ifNotNil: [ :key | newSelf at: key put: (array at: i)]].
	self become: newSelf! !
!MethodDictionary methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'jmv 12/5/2014 11:02' prior: 16906315!
    postCopy

	array := array copy! !
!MethodDictionary methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'Squeak1.2 6/29/1997 10:40:55' prior: 16906320!
                    scanFor: anObject
	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."
	| element start finish |
	start := (anObject identityHash \\ array size) + 1.
	finish := array size.

	"Search from (hash mod size) to the end."
	start to: finish do:
		[:index | ((element := self basicAt: index) == nil or: [element == anObject])
			ifTrue: [^ index ]].

	"Search from 1 to where we started."
	1 to: start-1 do:
		[:index | ((element := self basicAt: index) == nil or: [element == anObject])
			ifTrue: [^ index ]].

	^ 0  "No match AND no empty slot"! !
!IdentitySet methodsFor: 'private' library: #MinimalKernel04HashedCollections stamp: 'jmv 2/21/2020 12:33:27' prior: 16881722!
          scanFor: anObject
	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."
	| finish scale start element |
	finish := array size.
	scale := finish // (Smalltalk maxIdentityHash + 1).
	scale = 0 ifTrue: [scale := 1].
	start := anObject identityHash * scale \\ finish + 1.

	"Search from (hash mod size) to the end."
	start to: finish do:
		[:index | ((element := array at: index) == nil or: [element == anObject])
			ifTrue: [^ index ]].

	"Search from 1 to where we started."
	1 to: start-1 do:
		[:index | ((element := array at: index) == nil or: [element == anObject])
			ifTrue: [^ index ]].

	^ 0  "No match AND no empty slot"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7462-library-MinimalKernel04-JuanVuletich-2025Aug28-15h23m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7462] on 28 August 2025 at 3:50:22 pm'!
!CharacterSequence methodsFor: 'converting' library: #MinimalKernel02Symbol stamp: 'ST-80 5/31/1983 9:10:35' prior: 16812817!
       asSymbol
	"Answer the unique symbol whose characters are the characters of the string."
	^Symbol intern: self! !
!CharacterSequence class methodsFor: 'testing' library: #MinimalKernel02Symbol stamp: 'jmv 5/6/2025 15:02:25' prior: 16815227!
                representsSymbols
	^false! !
!String class methodsFor: 'system' library: #MinimalKernel02Symbol stamp: 'jmv 6/3/2022 10:29:45' prior: 16968633!
                symbolClassToUse
	"Answer the class to create symbols from us"
	^Symbol! !
!Symbol methodsFor: 'converting' library: #MinimalKernel02Symbol stamp: 'ST-80 5/31/1983 9:10:35' prior: 16969840!
  asSymbol! !
!Symbol methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'ST-80 5/31/1983 9:10:35' prior: 16969843!
    errorNoModification
	self error:  'symbols can not be modified.'! !
!Symbol methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'di 1/2/1999 17:00' prior: 16969848!
                  flushCache
	"Tell the interpreter to remove all entries with this symbol as a selector from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.
	NOTE:  Only one of the two selective flush methods needs to be used.
	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."

	<primitive: 119>
! !
!Symbol methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'ST-80 5/31/1983 9:10:35' prior: 16969862!
      string: aString 
	1 to: aString size do: [:j | super at: j put: (aString at: j)].
	^self! !
!Symbol class methodsFor: 'instance creation' library: #MinimalKernel02Symbol stamp: 'jmv 1/10/2025 11:53:15' prior: 16970066!
     intern: aStringOrSymbol

	^self accessProtect critical:
		[
			Symbols lookup: aStringOrSymbol ifAbsentAddFrom:
				[
					| preferByteStringForAscii |
					aStringOrSymbol isSymbol
						ifTrue: [ aStringOrSymbol ]
						ifFalse: [
							preferByteStringForAscii := aStringOrSymbol.
							(aStringOrSymbol isUnicodeString and: [ aStringOrSymbol isAscii ])
								ifTrue: [preferByteStringForAscii := aStringOrSymbol asByteString].
							preferByteStringForAscii class symbolClassToUse basicFromString: preferByteStringForAscii ].
				]
			].! !
!Symbol class methodsFor: 'instance creation' library: #MinimalKernel02Symbol stamp: 'jmv 12/1/2024 15:49:35' prior: 16970087!
                           lookup: aStringOrSymbol

	^self accessProtect critical: [
		Symbols lookup: aStringOrSymbol ].! !
!Symbol class methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'jmv 12/1/2024 15:47:52' prior: 16970115!
         accessProtect
	AccessProtect ifNil: [
		AccessProtect := Semaphore forMutualExclusion ].
	^AccessProtect! !
!Symbol class methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'jmv 6/3/2022 10:28:45' prior: 16970121!
basicFromString: aString
	"Private use. Answers an instance that is not yet interned.
	Can break the Symbol invariant: forAllSymbols, (s1 = s2) => (s1 == s2)
	Please don't call lightly."

	^(self basicNew: aString size) string: aString! !
!Symbol class methodsFor: 'services' library: #MinimalKernel02Symbol stamp: 'jmv 5/6/2025 14:51:13' prior: 16970107!
                            estimatedCount
	^Symbols estimatedSize! !
!Symbol class methodsFor: 'class initialization' library: #MinimalKernel02Symbol stamp: 'jmv 5/6/2025 15:06:49' prior: 16970093!
                     initialize
	"Rebuild the hash table"
	"
	Symbol initialize.
	"
	self accessProtect critical:
		[
			Symbols := WeakSet new.
			CharacterSequence allSubclassesDo: [ :cls | | sym |
				cls representsSymbols ifTrue: [
					sym := cls someInstance.
					[sym == nil] whileFalse: [
						Symbols add: sym.
						sym := sym nextInstance ]]]]! !
!Symbol class methodsFor: 'testing' library: #MinimalKernel02Symbol stamp: 'jmv 5/6/2025 15:02:37' prior: 16970111!
                         representsSymbols
	^true! !
!WeakSet methodsFor: 'adding and finding' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 13:11:00' prior: 17016130!
         add: newObject
	"Include newObject as one of the receiver's elements, but only if
	not already present.
	Answer newObject (even if another, but equal, object is already included)."

	| hash |
	hash := self hashFor: newObject.
	(self basicLookup: newObject withHash: hash) ifNil: [
		self basicAdd: newObject withHash: hash ].
	^newObject! !
!WeakSet methodsFor: 'adding and finding' library: #MinimalKernel02Symbol stamp: 'jmv 1/10/2025 10:55:11' prior: 17016144!
                includes: anObject 
	^ (self lookup: anObject) ~~ nil! !
!WeakSet methodsFor: 'adding and finding' library: #MinimalKernel02Symbol stamp: 'jmv 1/11/2025 10:14:21' prior: 17016149!
            lookup: anObject
	"Look for an element equal to anObject.
	If found, answer it. Answer nil otherwise.
	Note: The hash will be used several times, and it may be expensive. Ask for it just once."

	^self basicLookup: anObject withHash: (self hashFor: anObject)! !
!WeakSet methodsFor: 'adding and finding' library: #MinimalKernel02Symbol stamp: 'jmv 1/11/2025 10:22:07' prior: 17016160!
                               lookup: anObject ifAbsentAddFrom: aBlock
	"Look for an element equal to anObject.
	If found, answer it.
	If not found, evaluate aBlock, add the result and answer it.
	Note: Do NOT add anObject to the Set!!"
	
	| newObject |
	^(self lookup: anObject) ifNil: [
		newObject := aBlock value.
		self basicAdd: newObject withHash: (self hashFor: newObject).
		newObject ].! !
!WeakSet methodsFor: 'accessing' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 13:08:52' prior: 17016114!
                            estimatedSize
	"Actual size may be less: as our references to elements are weak, elements could vanish anytime."

	^estimatedSize! !
!WeakSet methodsFor: 'accessing' library: #MinimalKernel02Symbol stamp: 'jmv 5/14/2025 16:10:12' prior: 17016121!
         size
	| answer |
	answer := 0.
	buckets do: [ :bucket |
		bucket notNil ifTrue: [
			bucket do: [ :elem |
				elem notNil ifTrue: [ answer := answer + 1 ]]]].
	^answer.! !
!WeakSet methodsFor: 'initialization' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 12:44:39' prior: 17016175!
                             init: n
	"Initialize array to an array size of n"
	buckets := Array new: n.
	estimatedSize := 0.! !
!WeakSet methodsFor: 'testing' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 12:29:57' prior: 17016181!
            = aSet

	self == aSet ifTrue: [^ true].	"Any object is equal to itself"
	(aSet is: #Set) ifFalse: [^ false].
	(aSet is: #Dictionary) ifTrue: [^ false].
	self size = aSet size ifFalse: [^ false].
	self do: [ :each | (aSet includes: each) ifFalse: [^ false]].
	^ true! !
!WeakSet methodsFor: 'testing' library: #MinimalKernel02Symbol stamp: 'jmv 1/10/2025 10:10:13' prior: 17016192!
   is: aSymbol
	^aSymbol == #Set or: [ super is: aSymbol ]! !
!WeakSet methodsFor: 'comparing' library: #MinimalKernel02Symbol stamp: 'jmv 1/10/2025 10:17:35' prior: 17016197!
                   emptyCollectionHash
	^ Set hash! !
!WeakSet methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'jmv 1/14/2025 17:51:20' prior: 17016201!
             basicAdd: anObject withHash: hashValue
	"Add an object.
	Note: It is assumed that the argument is NOT already included. Check senders."

	| bucketIndex bucket indexInBucket bucketSize newBucket |

	"bucket creation is lazy"
	bucketIndex := self bucketIndexFor: hashValue.
	bucket := buckets at: bucketIndex.
	bucket ifNil: [ bucket := buckets at: bucketIndex put: (WeakArray new: self bucketDirectAccessSize)].

	"1. If our direct access spot in the hasheable area is free, just use it and we are done."
	indexInBucket := self indexInBucketFor: hashValue.
	(bucket at: indexInBucket) == nil ifTrue: [
		bucket at: indexInBucket put: anObject.
		estimatedSize := estimatedSize + 1.
		^self ].

	"2. If there is available room in the iterable part of the bucket, add our new element there."
	bucketSize := bucket size.
	self bucketIterablePartStart to: bucketSize do: [ :i |
		(bucket at: i) == nil ifTrue: [
			bucket at: i put: anObject.
			estimatedSize := estimatedSize + 1.
			^self ]].

	"There's no room in this bucket. It may be worth growing the collection.
	I (jmv) could not find a good heuristic on whether to grow the collection based on a single bucket.
	The adopted one was to limit average mean occupation over all buckets."
	estimatedSize > (buckets size * self bucketDesiredMeanOccupation) ifTrue: [
		self grow.
		"Now try again.
		Maybe the new element is added in the first part of the bucket,
		or in already available room in the second part. (1 and 2 above).
		Or maybe growing the bucket as below (3) is needed.
		What is sure is that this won't recurse more than once: buckets size was just doubled by #grow."
		^self basicAdd: anObject withHash: hashValue ].

	"3. We still need to grow the bucket. Grow it and add our new element."
	newBucket := WeakArray new: bucketSize + self bucketIterablePartGrow.
	newBucket replaceFrom: 1 to: bucketSize with: bucket startingAt: 1.
	newBucket at: bucketSize + 1 put: anObject.
	buckets at: bucketIndex put: newBucket.
	estimatedSize := estimatedSize + 1.! !
!WeakSet methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 14:56:03' prior: 17016267!
        basicLookup: anObject withHash: hashValue
	"Look for anObject. Assume hashValue is anObject hash, passed as argument to avoid possibly expensive repeated hash computation.
	Answer the element found, or nil if not found."

	| bucket indexInBucketForDirectAccess directAccessElelemt |
	bucket := buckets at: (self bucketIndexFor: hashValue).
	bucket ifNil: [ ^nil ].

	indexInBucketForDirectAccess := self indexInBucketFor: hashValue.
	directAccessElelemt := bucket at: indexInBucketForDirectAccess.
	(self areEqual: directAccessElelemt and: anObject)
		ifTrue: [ ^directAccessElelemt ].

	(self basicLook: anObject inIterablePartOf: bucket)
		ifNotNil: [ :index | | found |
			"We found it at the iterable part of the bucket.
			Move to the the direct access slot if possible."
			found := bucket at: index.
			directAccessElelemt isNil ifTrue: 
				[
					bucket at: indexInBucketForDirectAccess put: found.
					bucket at: index put: nil].
			^found].

	^nil! !
!WeakSet methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 14:38:32' prior: 17016300!
             bucketIndexFor: hashValue

	"The lowest few bits are used to index into each bucket.
	Don't use them for finding the bucket.
	See #indexInBucketFor:"
	^ ((hashValue bitShift: self bucketsHashShift)
			"Take only as much bits as we can use."
			bitAnd: buckets size-1)
				"And remember Smalltalk does 1-based indexing."
				+ 1! !
!WeakSet methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'jmv 1/14/2025 17:20:05' prior: 17016313!
     grow
	"Duplicate size of buckets. Keep old buckets.
	For each old bucket:
	- Duplicate it as a new bucket
	- Move elements that belong in the new bucket to it
	- If possible, move elements in the iterable area to the hasheable area. This is important for search performance.
	
	Note: An alternative implementation is simply
		self rehash: buckets size * 2
	But the current implementation is much faster, at the expense of additional memory consumption."

	| newBuckets oldBucketsSize maskForNewUsedHashBit anOldBucket aNewBucket elementHash diirectAccessIndexInBucket keepdOldBucket |
	estimatedSize := 0.
	oldBucketsSize := buckets size.
	maskForNewUsedHashBit := oldBucketsSize * self bucketDirectAccessSize. "We're directly accessing the full hash, including the lower bits."
	newBuckets := buckets grownTo: oldBucketsSize * 2.
	1 to: oldBucketsSize do:
		[ :indexToOldBucket |
			anOldBucket := buckets at: indexToOldBucket.
			anOldBucket ifNotNil:
				[
					keepdOldBucket := false.
					aNewBucket := nil.
					"Move elements in hasheable area to new bucket if appropriate."
					1 to: self bucketDirectAccessSize do:
						[ :indexInBucket |
							(anOldBucket at: indexInBucket) ifNotNil:
								[ :element |
									estimatedSize := estimatedSize + 1.
									((self hashFor: element) bitAnd: maskForNewUsedHashBit) = 0
									ifTrue:
										[ keepdOldBucket := true ]
									ifFalse:
										[
											aNewBucket ifNil: [
												aNewBucket := WeakArray new: anOldBucket size.
												newBuckets at: oldBucketsSize + indexToOldBucket put: aNewBucket ].
											aNewBucket at: indexInBucket put: (anOldBucket at: indexInBucket).
											anOldBucket at: indexInBucket put: nil ]]].
					"For elements is iterable area, try to move them to the hasheable area."
					self bucketIterablePartStart to: anOldBucket size do:
						[ :indexInBucket |
							(anOldBucket at: indexInBucket) ifNotNil:
								[ :element |
									estimatedSize := estimatedSize + 1.
									elementHash := self hashFor: element.
									diirectAccessIndexInBucket := self indexInBucketFor: elementHash.
									(elementHash bitAnd: maskForNewUsedHashBit) = 0
									ifTrue:
										[ "Stays in old bucket. Try to move to hasheable part."
											keepdOldBucket := true.
											(anOldBucket at: diirectAccessIndexInBucket) ifNil:
												[
													anOldBucket at: diirectAccessIndexInBucket put: element.
													anOldBucket at: indexInBucket put: nil ]]
									ifFalse:
										[ "Moves to new bucket. Try to move to hasheable part, or move to iterable part."
											aNewBucket ifNil: [
												aNewBucket := WeakArray new: anOldBucket size.
												newBuckets at: oldBucketsSize + indexToOldBucket put: aNewBucket ].
											(aNewBucket at: diirectAccessIndexInBucket) ifNil:
												[ aNewBucket at: diirectAccessIndexInBucket put: element ]
											ifNotNil:
												[ aNewBucket at: indexInBucket put: element ].
											anOldBucket at: indexInBucket put: nil ]]].
					keepdOldBucket ifFalse:
						[newBuckets at: indexToOldBucket put: nil ]]].
	buckets := newBuckets.! !
!WeakSet methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 14:38:55' prior: 17016414!
                             indexInBucketFor: hashValue
	"see also #bucketIndexFor:"

	^ (hashValue bitAnd: self bucketDirectAccessMask) + 1! !
!WeakSet methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'jmv 1/14/2025 11:55:48' prior: 17016420!
                            rehash
	self rehash: buckets size! !
!WeakSet methodsFor: 'private' library: #MinimalKernel02Symbol stamp: 'jmv 1/14/2025 11:55:25' prior: 17016424!
           rehash: newBucketsSize
	| oldBuckets |
	oldBuckets := buckets.
	self init: newBucketsSize.
	oldBuckets do:
		[:eachBucket |
			eachBucket ifNotNil:
				[
					eachBucket do:
						[:element |
							element notNil
								ifTrue: [self add: element]]]]! !
!WeakSet methodsFor: 'private-equality or identity' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 09:43:19' prior: 17016436!
                           areEqual: a and: b
	"To make it easy to implement WeakIdentitySet as a subclass."

	^a = b! !
!WeakSet methodsFor: 'private-equality or identity' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 09:32:18' prior: 17016442!
                             basicLook: anObject inIterablePartOf: aBucket
	"To make it easy to implement WeakIdentitySet as a subclass."
	"Answer the index or nil if not found"

	self bucketIterablePartStart to: aBucket size do: [ :i |
		(aBucket at: i) = anObject ifTrue: [ ^i ]].
	^nil! !
!WeakSet methodsFor: 'private-equality or identity' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 09:08:56' prior: 17016454!
                    hashFor: anObject
	"To make it easy to implement WeakIdentitySet as a subclass."

	^anObject hash! !
!WeakSet methodsFor: 'tuning constants' library: #MinimalKernel02Symbol stamp: 'jmv 1/14/2025 17:56:51' prior: 17016460!
  bucketDesiredMeanOccupation
	"How much of a bucket to use on average.
	Larger values, avoiding waste of memory on empty slots in buckets mean slower access due to hash conflicts forcing iteration on the iterable part of the unlucky buckets.
	Smaller values, avoiding iteration and faster access mean more wasted memory.
	Some experimentation sugges that using in average half of the buckets gives great performance, with some disregard for memory."

	^5! !
!WeakSet methodsFor: 'tuning constants' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 12:29:06' prior: 17016477!
                              bucketDirectAccessMask
	"The mask to apply to a hash value to index it (+1 due to 1-based indexing).
	Must equal #bucketDirectAccessSize-1.
	See also #bucketDirectAccessSize, #bucketIterablePartStart and #bucketsHashShift"

	^7! !
!WeakSet methodsFor: 'tuning constants' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 12:28:59' prior: 17016487!
bucketDirectAccessSize
	"The size of the initial part of each bucket, that is only used for elements with matching hash bits.
	See also #bucketDirectAccessMask, #bucketIterablePartStart and #bucketsHashShift"

	^8! !
!WeakSet methodsFor: 'tuning constants' library: #MinimalKernel02Symbol stamp: 'jmv 1/14/2025 17:53:35' prior: 17016497!
              bucketIterablePartGrow
	"Number of slots to add at once to the iterable part of Buckets."

	^1! !
!WeakSet methodsFor: 'tuning constants' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 12:29:13' prior: 17016503!
     bucketIterablePartStart
	"The first index of the iterable area of each Bucket.
	Must equal #bucketDirectAccessSize+1
	See also #bucketDirectAccessSize, #bucketDirectAccessMask and #bucketsHashShift"

	^9! !
!WeakSet methodsFor: 'tuning constants' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 12:29:22' prior: 17016513!
                        bucketsHashShift
	"The mask to apply to a hash value to index it (+1 due to 1-based indexing).
	Must equal (#bucketDirectAccessMask highBit negated)
	See also #bucketDirectAccessSize, #bucketDirectAccessMask and #bucketIterablePartStart"

	^ -3! !
!WeakSet methodsFor: 'copying' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 13:03:50' prior: 17016524!
                        postCopy

	self rehash! !
!WeakSet class methodsFor: 'instance creation' library: #MinimalKernel02Symbol stamp: 'jmv 1/13/2025 13:01:47' prior: 17016620!
      new
	^ self newWithRoomForMoreThan: 32! !
!WeakSet class methodsFor: 'instance creation' library: #MinimalKernel02Symbol stamp: 'jmv 6/2/2025 14:38:40' prior: 50331750!
                       newWithRoomForMoreThan: nElements
	"Create a Set large enough to hold nElements without growing
	WeakSet newWithRoomForMoreThan: 31
	WeakSet newWithRoomForMoreThan: 32
	"

	| answer |
	answer := self basicNew.
	answer init: (2 raisedToInteger: (nElements // answer bucketDesiredMeanOccupation max: 1) highBit -1).
	^answer! !

Symbol initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7463-library-MinimalKernel02-JuanVuletich-2025Aug28-15h47m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7462] on 28 August 2025 at 3:52:24 pm'!
!Object methodsFor: 'object serialization' library: #MinimalKernel06ObjectSerialization stamp: 'tk 4/8/1999 12:46' prior: 16921543!
                    comeFullyUpOnReload: smartRefStream
	"Normally this read-in object is exactly what we want to store. 7/26/96 tk"

	^ self! !
!Object methodsFor: 'object serialization' library: #MinimalKernel06ObjectSerialization stamp: 'tk 4/8/1999 12:05' prior: 16921550!
                               readDataFrom: aDataStream size: varsOnDisk
	"Fill in the fields of self based on the contents of aDataStream.  Return self.
	 Read in the instance-variables written by Object>>storeDataOn:.
	 NOTE: This method must send beginReference: before reading any objects from aDataStream that might reference it.
	 Allow aDataStream to have fewer inst vars.  See SmartRefStream."
	| cntInstVars cntIndexedVars |

	cntInstVars := self class instSize.
	self class isVariable
		ifTrue: [cntIndexedVars := varsOnDisk - cntInstVars.
				cntIndexedVars < 0 ifTrue: [
					self error: 'Class has changed too much.  Define a convertxxx method']]
		ifFalse: [cntIndexedVars := 0.
				cntInstVars := varsOnDisk]. 	"OK if fewer than now"

	aDataStream beginReference: self.
	1 to: cntInstVars do:
		[:i | self instVarAt: i put: aDataStream next].
	1 to: cntIndexedVars do:
		[:i | self basicAt: i put: aDataStream next].
	"Total number read MUST be equal to varsOnDisk!!"
	^ self	"If we ever return something other than self, fix calls 
			on (super readDataFrom: aDataStream size: anInteger)"! !
!CompiledMethod methodsFor: 'object serialization' library: #MinimalKernel06ObjectSerialization stamp: 'tk 10/6/2000 14:22' prior: 16833382!
                             readDataFrom: aDataStream size: varsOnDisk
	"Fill in my fields.  My header and number of literals are already installed.  Must read both objects for the literals and bytes for the bytecodes."

	self error: 'Must use readMethod'.! !
!Set methodsFor: 'object serialization' library: #MinimalKernel06ObjectSerialization stamp: 'tk 4/8/1999 13:05' prior: 16957552!
                       comeFullyUpOnReload: smartRefStream
	"Symbols have new hashes in this image."

	self rehash.
	"^ self"
! !
!WeakSet methodsFor: 'object serialization' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 1/13/2025 13:02:58' prior: 17016529!
           comeFullyUpOnReload: smartRefStream
	"Symbols have new hashes in this image."

	self rehash.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7464-library-MinimalKernel06-JuanVuletich-2025Aug28-15h50m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7462] on 28 August 2025 at 3:53:25 pm'!
!SystemDictionary methodsFor: 'special objects' library: #MinimalKernel07VMnImage stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16971306!
         specialObjectsArray  "Smalltalk specialObjectsArray at: 1"
	<primitive: 129>
	^ self primitiveFailed! !
!SystemDictionary methodsFor: 'primitives' library: #MinimalKernel07VMnImage stamp: 'jmv 6/16/2015 12:17' prior: 16971095!
                             primGetCurrentWorkingDirectoryUnix
	"Call getcwd() to get the current working directory.
	Shamelessly taken from OSProcess.pck.st and copied here.
	Answer nil on fail (i.e., non-Unix)"

	"
	Smalltalk primGetCurrentWorkingDirectoryUnix
	"

	<primitive: 'primitiveGetCurrentWorkingDirectory' module: 'UnixOSProcessPlugin'>
	^ nil! !
!SystemDictionary methodsFor: 'primitives' library: #MinimalKernel07VMnImage stamp: 'jmv 6/16/2015 12:17' prior: 16971109!
                          primGetCurrentWorkingDirectoryWindows
	"Call getcwd() to get the current working directory.
	Shamelessly taken from OSProcess.pck.st and copied here.
	Answer nil on fail (i.e., non-Windows)
	Note:
		Unfortunately, yhis windows implementation seems to always answer the directory 
		containing the image, and not the real Windows current directory.
		See #getCurrentWorkingDirectory"

	"
	Smalltalk primGetCurrentWorkingDirectoryWindows
	"

	<primitive: 'primitiveGetCurrentWorkingDirectory' module: 'Win32OSProcessPlugin'>
	^ nil! !
!SystemDictionary methodsFor: 'primitives' library: #MinimalKernel07VMnImage stamp: 'jmv 10/5/2015 08:30' prior: 16971129!
                primImageName
	"Answer the full path name for the current image."
	"
	Smalltalk primImageName
	"

	<primitive: 121>
	self primitiveFailed! !
!SystemDictionary methodsFor: 'primitives' library: #MinimalKernel07VMnImage stamp: 'jmv 1/13/2011 16:18' prior: 16971137!
                        primVmFileName
	"Answer the absolute file name of the the Smalltalk virtual machine"

	^ self getSystemAttribute: 0! !
!SystemDictionary methodsFor: 'primitives' library: #MinimalKernel07VMnImage stamp: 'jmv 9/17/2015 11:19' prior: 16971144!
              primVmPath
	"Answer the path for the directory containing the Smalltalk virtual machine. Return nil if this primitive is not implemented."
	"Smalltalk primVmPath"

	<primitive: 142>! !
!SystemDictionary methodsFor: 'miscelaneous' library: #MinimalKernel07VMnImage stamp: 'jmv 5/24/2025 20:38:06' prior: 16971153!
       cachedSystemAttribute: attributeID
	(attributeID between: 1001 and: 1009)
		ifFalse: [ ^nil ].
	SystemAttributeCache ifNil: [
		SystemAttributeCache := Array new: 9.
		1 to: 9 do: [ :i |
			SystemAttributeCache at: i put: (self primGetSystemAttribute: 1000+i) ]].
	^SystemAttributeCache at: attributeID-1000! !
!SystemDictionary methodsFor: 'miscelaneous' library: #MinimalKernel07VMnImage stamp: 'jmv 5/24/2025 20:38:36' prior: 16971166!
         getSystemAttribute: attributeID
  	"Optional. Answer the string for the system attribute with the given 
  	integer ID. Answer nil if the given attribute is not defined on this 
  	platform. On platforms that support invoking programs from command 
  	lines (e.g., Unix), this mechanism can be used to pass command line 
  	arguments to programs written in Squeak.
  
  	By convention, the first command line argument that is not a VM
  	configuration option is considered a 'document' to be filed in. Such a
  	document can add methods and classes, can contain a serialized object,
  	can include code to be executed, or any combination of these.
  
  	Currently defined attributes include: 
  	-1000	1000th command line argument that specify VM options
  	...
  	-1		first command line argument that specify VM options
  	0		the full path name for currently executing VM
  			(or, on some platforms, just the path name of the VM's directory) 
  	1		path name of this image (better use #imageName instead)
  	2		command line argument See #processCommandLineArguments
  	3		command line argument
  	...
  	1000	last possible command line argument
  	1001	this platform's operating system 'Mac OS', 'Win32', 'unix', ...
  	1002	operating system version
  	1003	this platform's processor type
  	1004	vm version
  	1005	window system name
  	1006	vm build id
  	1007	Interpreter class (Cog VM only)
  	1008	Cogit class (Cog VM only)
 	1009	Platform source version (Cog VM only?)
  	1201	max filename length (Mac OS only)
  	1202	file last error (Mac OS only)
  	10001	hardware details (Win32 only)
  	10002	operating system details (Win32 only)
  	10003	graphics hardware details (Win32 only)
  	"
	(self cachedSystemAttribute: attributeID) ifNotNil: [ :cached |
		^cached ].
	^self primGetSystemAttribute: attributeID.! !
!SystemDictionary methodsFor: 'miscelaneous' library: #MinimalKernel07VMnImage stamp: 'ar 5/16/2000 00:54' prior: 16971226!
       listBuiltinModule: index
	"Return the name of the n-th builtin module.
	This list is not sorted!!"
	<primitive: 572>
	^self primitiveFailed! !
!SystemDictionary methodsFor: 'miscelaneous' library: #MinimalKernel07VMnImage stamp: 'TPR 5/16/2000 16:56' prior: 16971234!
                    listLoadedModule: index
	"Return the name of the n-th loaded module.
	This list is not sorted!!"
	<primitive: 573>
	^self primitiveFailed! !
!SystemDictionary methodsFor: 'miscelaneous' library: #MinimalKernel07VMnImage stamp: 'ar 2/1/2000 15:39' prior: 16971242!
                        platformName
	"Return the name of the platform we're running on"
	^self getSystemAttribute: 1001! !
!SystemDictionary methodsFor: 'miscelaneous' library: #MinimalKernel07VMnImage stamp: 'jmv 5/26/2025 10:29:02' prior: 16971248!
                            primGetSystemAttribute: attributeID
  	"Optional. Answer the string for the system attribute with the given 
  	integer ID. Answer nil if the given attribute is not defined on this 
  	platform. On platforms that support invoking programs from command 
  	lines (e.g., Unix), this mechanism can be used to pass command line 
  	arguments to programs written in Squeak.
  
  	By convention, the first command line argument that is not a VM
  	configuration option is considered a 'document' to be filed in. Such a
  	document can add methods and classes, can contain a serialized object,
  	can include code to be executed, or any combination of these.
  
  	Currently defined attributes include: 
  	-1000	1000th command line argument that specify VM options
  	...
  	-1		first command line argument that specify VM options
  	0		the full path name for currently executing VM
  			(or, on some platforms, just the path name of the VM's directory) 
  	1		path name of this image (better use #imageName instead)
  	2		command line argument See #processCommandLineArguments
  	3		command line argument
  	...
  	1000	last possible command line argument
  	1001	this platform's operating system 'Mac OS', 'Win32', 'unix', ...
  	1002	operating system version
  	1003	this platform's processor type
  	1004	vm version
  	1005	window system name
  	1006	vm build id
  	1007	Interpreter class (Cog VM only)
  	1008	Cogit class (Cog VM only)
 	1009	Platform source version (Cog VM only?)
  	1201	max filename length (Mac OS only)
  	1202	file last error (Mac OS only)
  	10001	hardware details (Win32 only)
  	10002	operating system details (Win32 only)
  	10003	graphics hardware details (Win32 only)
  	"

	<primitive: 149>
	^ nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7465-library-MinimalKernel07-JuanVuletich-2025Aug28-15h52m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7462] on 28 August 2025 at 3:55:22 pm'!
!ClassBuilder methodsFor: 'class definition' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 1/4/2024 15:18:32' prior: 16816437!
    newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass
	"Create a new subclass of the given superclass with the given specification."
	| newFormat newClass |
	"Compute the format of the new class"
	newFormat := 
		self computeFormat: type 
			instSize: instVars size 
			forSuper: newSuper.

	newFormat
		ifNil: [^ nil].

	(oldClass == nil or:[oldClass isMeta not]) 
		ifTrue:[newClass := self privateNewSubclassOf: newSuper from: oldClass]
		ifFalse:[newClass := oldClass shallowCopy].

	newClass 
		superclass: newSuper
		methodDictionary: MethodDictionary new
		format: newFormat;
		setInstVarNames: instVars.

	oldClass ifNotNil:[
		newClass organization: oldClass organization.
		"Recompile the new class"
		oldClass hasMethods 
			ifTrue:[newClass compileAllFrom: oldClass].
		self recordClass: oldClass replacedBy: newClass.
	].

	(oldClass == nil or:[oldClass isObsolete not]) 
		ifTrue:[newSuper addSubclass: newClass]
		ifFalse:[newSuper addObsoleteSubclass: newClass].

	^newClass! !
!ClassBuilder methodsFor: 'validation' library: #MinimalKernel05ClassAndMethodCreation stamp: 'eem 2/27/2025 10:18:23' prior: 16816587!
                              checkInstSize: instSize errorMessage: errorMessage
	instSize > self class maxInstSize ifTrue:
		[self error: errorMessage.
		 ^false].
	instSize > self class maxAccessibleInstSize ifTrue:
		[Smalltalk isDevelopmentEnvironmentPresent ifTrue:
			[^self confirm: 'To access ', instSize printString, ' instance variables\requires the SistaV1 bytecode set.\See #preferredBytecodeSetEncoderClass:.' withNewLines].
		 ^false].
	^true! !
!ClassBuilder methodsFor: 'private' library: #MinimalKernel05ClassAndMethodCreation stamp: 'ar 2/27/2003 22:56' prior: 16816604!
                 privateNewSubclassOf: newSuper
	"Create a new meta and non-meta subclass of newSuper"
	"WARNING: This method does not preserve the superclass/subclass invariant!!"
	| newSuperMeta newMeta |
	newSuperMeta := newSuper ifNil:[Class] ifNotNil:[newSuper class].
	newMeta := Metaclass new.
	newMeta 
		superclass: newSuperMeta 
		methodDictionary: MethodDictionary new 
		format: newSuperMeta format.
	^newMeta new
! !
!ClassBuilder methodsFor: 'private' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 1/4/2024 15:17:05' prior: 16816620!
                               privateNewSubclassOf: newSuper from: oldClass
	"Create a new meta and non-meta subclass of newSuper using oldClass as template"
	"WARNING: This method does not preserve the superclass/subclass invariant!!"
	| newSuperMeta oldMeta newMeta |
	oldClass ifNil:[^self privateNewSubclassOf: newSuper].
	newSuperMeta := newSuper ifNil:[Class] ifNotNil:[newSuper class].
	oldMeta := oldClass class.
	newMeta := oldMeta shallowCopy.
	newMeta 
		superclass: newSuperMeta
		methodDictionary: MethodDictionary new
		format: (self computeFormat: oldMeta typeOfClass 
					instSize: oldMeta instVarNames size 
					forSuper: newSuperMeta);
		setInstVarNames: oldMeta instVarNames;
		organization: oldMeta organization.
	"Recompile the meta class"
	oldMeta hasMethods 
		ifTrue:[newMeta compileAllFrom: oldMeta].
	"Record the meta class change"
	self recordClass: oldMeta replacedBy: newMeta.
	"And create a new instance"
	^newMeta adoptInstance: oldClass from: oldMeta! !
!ClassBuilder methodsFor: 'class format' library: #MinimalKernel05ClassAndMethodCreation stamp: 'eem 2/27/2025 10:23:27' prior: 16816473!
                        computeFormat: type fullInstancesSize: newInstSize
	"Compute the new format for making oldClass a subclass of newSuper.
	 Answer the format or nil if there is any problem."

	| isVar isPointers isWeak bitsUnitSize |
	type == #compiledMethod ifTrue: [
		newInstSize > 0 ifTrue: [
			self error: 'A compiled method class cannot have named instance variables'.
			^nil].
		^CompiledMethod format].
	(self checkInstSize: newInstSize
		 errorMessage:  'Class has too many instance variables (', newInstSize printString,')') ifFalse: [
		^nil].
	type == #normal ifTrue:[isVar := isWeak := false. isPointers := true].
	type == #bytes ifTrue:[isVar := true. bitsUnitSize := 1. isPointers := isWeak := false].
	type == #shorts ifTrue:[isVar := true. bitsUnitSize := 2. isPointers := isWeak := false].
	type == #words ifTrue:[isVar := true. bitsUnitSize := 4. isPointers := isWeak := false].
	type == #longs ifTrue:[isVar := true. bitsUnitSize := 8. isPointers := isWeak := false].
	type == #variable ifTrue:[isVar := isPointers := true. isWeak := false].
	type == #weak ifTrue:[isVar := isWeak := isPointers := true].
	type == #ephemeron ifTrue:[isVar := false. isWeak := isPointers := true].
	type == #immediate ifTrue:[isVar := isWeak := isPointers := false].
	isVar ifNil: [ self error: 'Unsupported class format type: ', type. ^ nil ].
	(isPointers not and: [newInstSize > 0]) ifTrue: [
		self error: 'A non-pointer class cannot have named instance variables'.
		^nil].
	^self format: newInstSize variable: isVar bitsUnitSize: bitsUnitSize pointers: isPointers weak: isWeak! !
!ClassBuilder methodsFor: 'class format' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 1/4/2024 15:17:52' prior: 16816526!
                   computeFormat: type instSize: newInstSize forSuper: newSuper
	"Compute the new format for making oldClass a subclass of newSuper.
	Return the format or nil if there is any problem."

	^ self computeFormat: type fullInstancesSize: (newInstSize + (newSuper ifNil: [0] ifNotNil: [newSuper instSize]))! !
!ClassBuilder methodsFor: 'class format' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 1/4/2024 16:13:22' prior: 16816539!
          format: nInstVars variable: isVar bitsUnitSize: bitsUnitSize pointers: isPointers weak: isWeak

	"Compute the format for the given instance specfication.
	The class format is
		<5 bits inst spec><16 bits inst size>
	where the 5-bit inst spec is
			0	= 0 sized objects (UndefinedObject True False et al)
			1	= non-indexable objects with inst vars (Point et al)
			2	= indexable objects with no inst vars (Array et al)
			3	= indexable objects with inst vars (MethodContext AdditionalMethodState et al)
			4	= weak indexable objects with inst vars (WeakArray et al)
			5	= weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
			6	= unused
			7	= immediates (SmallInteger, Character, SmallFloat64)
			8	= unused
			9	= 64-bit indexable
		10-11	= 32-bit indexable (Bitmap, WideString)
		12-15	= 16-bit indexable
		16-23	= 8-bit indexable (ByteString)
		24-31	= compiled methods (CompiledMethod)"
	| instSpec |
	instSpec := isWeak
					ifTrue:
						[isVar
							ifTrue: [4]
							ifFalse: [5]]
					ifFalse:
						[isPointers
							ifTrue:
								[isVar
									ifTrue: [nInstVars > 0 ifTrue: [3] ifFalse: [2]]
									ifFalse: [nInstVars > 0 ifTrue: [1] ifFalse: [0]]]
							ifFalse:
								[isVar
									ifTrue: [bitsUnitSize caseOf: {
											[1] -> [16].
											[2] -> [12].
											[4] -> [10].
											[8] -> [9] }]
									ifFalse: [7]]].
	^(instSpec bitShift: 16) + nInstVars! !
!ClassBuilder methodsFor: 'initialization' library: #MinimalKernel05ClassAndMethodCreation stamp: 'jmv 11/27/2008 16:00' prior: 16816654!
       initialize
	instVarMap := IdentityDictionary new.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7466-library-MinimalKernel05-JuanVuletich-2025Aug28-15h53m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7462] on 28 August 2025 at 3:56:22 pm'!
!DataStream methodsFor: 'initialization' library: #MinimalKernel06ObjectSerialization stamp: 'di 6/9/97 08:03' prior: 16841651!
                             setStream: aStream
	"PRIVATE -- Initialization method."

	aStream binary.
	basePos := aStream position.	"Remember where we start.  Earlier part of file contains a class or method file-in.  Allow that to be edited.  We don't deal in absolute file locations."
	byteStream := aStream.! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16841663!
                             beginReference: anObject
    "WeÕre starting to read anObject. Remember it and its reference
     position (if we care; ReferenceStream cares). Answer the
     reference position."

    ^ 0! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16841673!
                        getCurrentReference
    "PRIVATE -- Return the currentReference posn.
     Overridden by ReferenceStream."

    ^ 0! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'tk 4/8/1999 13:11' prior: 16841680!
              maybeBeginReference: internalObject
	"Do nothing.  See ReferenceStream|maybeBeginReference:"

	^ internalObject! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 5/9/2025 14:07:49' prior: 16841687!
              next
	"Answer the next object in the stream."
	| type selector anObject isARefType pos internalObject |

	type := byteStream next.
	type ifNil: [
		pos := byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		byteStream position = 0 
			ifTrue: [self error: 'The file did not exist in this directory'] 
			ifFalse: [self error: 'Unexpected end of object file'].
		pos.	"so can see it in debugger"
		^ nil].
	type = 0 ifTrue: [
		pos := byteStream position.	"absolute!!!!"
		byteStream close.	"clean up"
		self error: 'Expected start of object, but found 0'.
		^ nil].
	isARefType := self noteCurrentReference: type.
	selector := #(
			readNil readTrue readFalse readInteger
			errorRead readSymbol readByteArray readArray
			readInstance readReference readBitmap readClass
			errorRead readFloat errorRead readShortInst
			readString readWordArray errorRead readWordLike
			readMethod 
			readCharacter readUnicodeString readUnicodeSymbol) at: type.
	anObject := self perform: selector. "A method that recursively
		calls next (readArray, readInstance, objectAt:) must save &
		restore the current reference position."
	isARefType ifTrue: [self beginReference: anObject].

		"After reading the externalObject, internalize it.
		 #readReference is a special case. Either:
		   (1) We actually have to read the object, recursively calling
			   next, which internalizes the object.
		   (2) We just read a reference to an object already read and
			   thus already interalized.
		 Either way, we must not re-internalize the object here."
	selector == #readReference ifTrue: [^ anObject].
	internalObject := anObject comeFullyUpOnReload: self.
	^ self maybeBeginReference: internalObject.! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16841744!
                  noteCurrentReference: typeID
    "PRIVATE -- If we support references for type typeID, remember
     the current byteStream position so we can add the next object to
     the ÔobjectsÕ dictionary, and return true. Else return false.
     This method is here to be overridden by ReferenceStream"

    ^ false! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 6/30/2011 09:33' prior: 16841757!
          objectAt: anInteger
	"PRIVATE -- Read & return the object at a given stream position.  08:18 tk  anInteger is a relative file position. "
	| savedPosn anObject refPosn |

	savedPosn := byteStream position.		"absolute"
	refPosn := self getCurrentReference.	"relative position"

	byteStream position: anInteger + basePos.	"was relative"
	anObject := self next.

	self setCurrentReference: refPosn.		"relative position"
	byteStream position: savedPosn.		"absolute"
	^ anObject! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 5/5/2023 20:16:17' prior: 16841775!
    readArray
	"PRIVATE -- Read the contents of an Array.
	 We must do beginReference: here after instantiating the Array
	 but before reading its contents, in case the contents reference
	 the Array. beginReference: will be sent again when we return to
	 next, but that's ok as long as we save and restore the current
	 reference position over recursive calls to next."
	| count array refPosn |

	count := byteStream nextUint32BigEndian: true.

	refPosn := self beginReference: (array := Array new: count).		"relative pos"
	1 to: count do: [:i |
		array at: i put: self next].
	self setCurrentReference: refPosn.		"relative pos"
	^ array! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 5/5/2023 20:16:28' prior: 16841798!
   readByteArray
	"PRIVATE -- Read the contents of a ByteArray."

	| count |
	count := byteStream nextUint32BigEndian: true.
	^ byteStream next: count  "assume stream is in binary mode"
! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 1/8/2024 12:18:49' prior: 16841807!
      readCharacter
    "PRIVATE -- Read a Character."

    ^ Character codePoint: (byteStream nextUint32BigEndian: true)! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16841814!
   readFalse
    "PRIVATE -- Read the contents of a False."

    ^ false! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 5/9/2025 12:00:55' prior: 16841820!
                        readFloat
	"PRIVATE -- Read the contents of a Float.
	 This is the fast way to read a Float.
	Read bigEndian / PowerPC order.
	Answer is BoxedFloat64 or SmallFloat64 as appropriate."

	^ byteStream nextFloat64BigEndian: true! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 9/14/2023 10:24:50' prior: 16841830!
                            readInstance
	"PRIVATE -- Read the contents of an arbitrary instance.
	 ASSUMES: readDataFrom:size: sends me beginReference: after it
	   instantiates the new object but before reading nested objects.
	 NOTE: We must restore the current reference position after
	   recursive calls to next.
	Let the instance, not the class read the data.  "
	| instSize aSymbol refPosn anObject newClass |

	instSize := (byteStream nextUint32BigEndian: true) - 1.
	refPosn := self getCurrentReference.
	aSymbol := self next.
	newClass := Smalltalk at: aSymbol asSymbol ifAbsent: [
		self error: 'Can not deserialize an instance of ', aSymbol, '. Class is missing.'.
		^nil ].
	anObject := newClass isVariable 	"Create object here"
			ifFalse: [newClass basicNew]
			ifTrue: [newClass basicNew: instSize - (newClass instSize)].
	self setCurrentReference: refPosn.  "before readDataFrom:size:"
	anObject := anObject readDataFrom: self size: instSize.
	self setCurrentReference: refPosn.  "before returning to next"
	^ anObject! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 5/5/2023 20:18:41' prior: 16841865!
             readInteger
    "PRIVATE -- Read the contents of a SmallInteger."

    ^ byteStream nextInt32BigEndian: true	"signed!!!!!!"! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16841873!
                           readNil
    "PRIVATE -- Read the contents of an UndefinedObject."

    ^ nil! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 5/5/2023 20:16:43' prior: 16841879!
                 readReference
	"Read the contents of an object reference. (Cf. outputReference:)  File is not now positioned at this object."
	| referencePosition |

	^ (referencePosition := (byteStream nextUint32BigEndian: true)) = self vacantRef	"relative"
		ifTrue:  [nil]
		ifFalse: [self objectAt: referencePosition]		"relative pos"! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'tk 1/8/97' prior: 16841892!
        readShortInst
	"Read the contents of an arbitrary instance that has a short header.
	 ASSUMES: readDataFrom:size: sends me beginReference: after it
	   instantiates the new object but before reading nested objects.
	 NOTE: We must restore the current reference position after
	   recursive calls to next.
	Let the instance, not the class read the data.  "
	| instSize aSymbol refPosn anObject newClass |

	instSize := (byteStream next) - 1.	"one byte of size"
	refPosn := self getCurrentReference.
	aSymbol := self readShortRef.	"class symbol in two bytes of file pos"
	newClass := Smalltalk at: aSymbol asSymbol.
	anObject := newClass isVariable 	"Create object here"
			ifFalse: [newClass basicNew]
			ifTrue: [newClass basicNew: instSize - (newClass instSize)].
	self setCurrentReference: refPosn.  "before readDataFrom:size:"
	anObject := anObject readDataFrom: self size: instSize.
	self setCurrentReference: refPosn.  "before returning to next"
	^ anObject! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 5/5/2023 20:17:23' prior: 16841926!
                           readShortRef
	"Read an object reference from two bytes only.  Original object must be in first 65536 bytes of the file.  Relative to start of data.  vacantRef not a possibility."

	^ self objectAt: (byteStream nextUint16BigEndian: true)! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 9/1/2023 17:03:35' prior: 16841937!
                 readString

	^byteStream nextString! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16841942!
                   readSymbol
    "PRIVATE -- Read the contents of a Symbol."

    ^ self readString asSymbol! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16841948!
                            readTrue
    "PRIVATE -- Read the contents of a True."

    ^ true! !
!DataStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'Squeak1.0 9/20/1996 10:50:05' prior: 16841954!
                    setCurrentReference: refPosn
    "PRIVATE -- Set currentReference to refPosn.
     Noop here. Cf. ReferenceStream."! !
!DataStream methodsFor: 'aux' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 5/9/2025 14:07:33' prior: 16841961!
              typeIDFor: anObject
	"Return the typeID for anObject's class.  This is where the tangle of objects is clipped to stop everything from going out.  
	Classes can control their instance variables by defining objectToStoreOnDataStream.
	Any object in blockers is not written out.  See ReferenceStream.objectIfBlocked: and DataStream nextPut:.
	Morphs do not write their owners.  See Morph.storeDataOn:   Each morph tells itself to 'prepareToBeSaved' before writing out."
	
	^ DataStream typeMap at: anObject class name ifAbsent: [9 "instance of any normal class"]! !
!DataStream methodsFor: 'aux' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 12/29/2016 15:36:22' prior: 16841982!
                vacantRef
	"Answer the magic 32-bit constant we use ***ON DISK*** as a stream 'reference
	 position' to identify a reference that's not yet filled in. This must be a
	 value that won't be used as an ordinary reference. Cf. outputReference: and
	 readReference. -- 
	 NOTE: We could use a different type ID for vacant-refs rather than writing
		object-references with a magic value. (The type ID and value are
		overwritten by ordinary object-references when weak refs are fullfilled.)"

	"In 32 bit Cuis it was:"
	"^ SmallInteger maxVal"

	"Use that very same value even if in 64 bit Cuis.
	This means that DataStreams are limited to 1GibiBytes in size."
	^16r3FFFFFFF! !
!DataStream class methodsFor: 'cached state access' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 6/17/2025 16:24:25' prior: 50332568!
              initCachedState
	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  #nextPut: writes these IDs to the data stream.
	NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  
	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)
	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"
	"
	DataStream initCachedState
	"
	| t |
	t := TypeMap := Dictionary newWithRoomForMoreThan: 80. "sparse for fast hashing"

	t at: #UndefinedObject put: 1.
	t at: #True put: 2.
	t at: #False put: 3.
	t at: #SmallInteger put: 4.
	"(type ID 5 was for Squeak's old String format)"
	t at: #Symbol put: 6.
	t at: #ByteArray put: 7.
	t at: #Array put: 8.
	"(type ID 9 is for arbitrary instances of any class. See #typeIDFor: See #writeInstance: See #readInstance)"
	"(type ID 10 is for references, See ReferenceStream>>tryToPutReference:typeID:)"
	t at: #Bitmap put: 11.
	t at: #Metaclass put: 12.
	"Type ID 13 was for Squeak's  HyperSqueak User classes."
	t at: #Float put: 14.
	t at: #BoxedFloat64 put: 14.
	t at: #SmallFloat64 put: 14.
	"(type ID 15 was for Squeak's old Deprecated compact Rects."
	"type ID 16 is an instance with short header.  See #beginInstance:size:"
	t at: #String put: 17.	"'new' String format, 1 or 4 bytes of length"
	t at: #WordArray put: 18.
	"type ID 19 was for Squeak's Word Array for Segment."
	"For all classes that are like WordArrays, store them as bits, and able to change endianness."
	Smalltalk do: [:cls |
		cls isBehavior ifTrue: [
			cls isPointers not & cls isVariable & cls isWords ifTrue: [
				(t includesKey: cls name) ifFalse: [
					t at: cls name put: 20 ]]]].
	t at: #CompiledMethod put: 21.	"special creation method"
	t at: #Character put: 22.
	t at: #UnicodeString put: 23.
	t at: #UnicodeSymbol put: 24.! !
!DataStream class methodsFor: 'cached state access' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 5/1/2015 21:09' prior: 16842523!
                     typeMap

	TypeMap ifNil: [ self initCachedState ].
	^TypeMap! !
!DataStream class methodsFor: 'instance creation' library: #MinimalKernel06ObjectSerialization stamp: 'di 2/15/98 14:03' prior: 16842443!
                      new
	^ self basicNew! !
!DataStream class methodsFor: 'instance creation' library: #MinimalKernel06ObjectSerialization stamp: 'di 6/24/97 00:18' prior: 16842447!
                              on: aStream
	"Open a new DataStream onto a low-level I/O stream."

	^ self basicNew setStream: aStream
		"aStream binary is in setStream:"
! !
!ReferenceStream methodsFor: 'initialization' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 2/6/2024 09:32:11' prior: 16945341!
      setStream: aStream
	"PRIVATE -- Initialization method."

	super setStream: aStream.
	references := IdentityDictionary newWithRoomForMoreThan: 4096 * 5.
	objects := IdentityDictionary newWithRoomForMoreThan: 4096 * 5.
	fwdRefEnds := IdentityDictionary new.
	skipping := IdentitySet new.
	blockers ifNil: [blockers := IdentityDictionary new].	"keep blockers we just passed in"
! !
!ReferenceStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'RAA 1/18/2001 11:52' prior: 16945356!
   beginReference: anObject
	"Remember anObject as the object we read at the position recorded by
	 noteCurrentReference:. This must be done after instantiating anObject but
	 before reading any of its contents that might (directly or indirectly) refer to
	 it. (It's ok to do this redundantly, which is convenient for #next.)
	 Answer the reference position."

	objects at: currentReference ifAbsent: [
		objects at: currentReference put: anObject.
		^ currentReference].
	(skipping includes: currentReference) ifFalse: [
		"If reading just to skip it, don't record this copy."
		objects at: currentReference put: anObject
	].
	^ currentReference		"position relative to start of data portion of file"! !
!ReferenceStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'tk 6/9/97 08:26' prior: 16945381!
    getCurrentReference
    "PRIVATE -- Return the currentReference posn.  Always a relative position.  So user can cut and paste the Smalltalk source code at the beginning of the file."

    ^ currentReference	"relative position"! !
!ReferenceStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'tk 4/8/1999 13:11' prior: 16945392!
                          maybeBeginReference: internalObject
	"See if need to record a reference.  In case in the file twice"

	(self isAReferenceType: (self typeIDFor: internalObject))
			ifTrue: [self beginReference: internalObject].
			"save the final object and give it out next time."
	^ internalObject! !
!ReferenceStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 3/2/2010 10:05' prior: 16945404!
 next
	"Answer the next object in the stream.  If this object was already read, don't re-read it.  File is positioned just before the object."
	| curPosn skipToPosn haveIt theObject wasSkipping |

	haveIt := true.
	curPosn := byteStream position - basePos.
	theObject := objects at: curPosn ifAbsent: [haveIt := false].
		"probe in objects is done twice when coming from objectAt:.  This is OK."
	skipToPosn := fwdRefEnds at: curPosn ifAbsent: nil.
	haveIt ifFalse: [ ^ super next].

	skipToPosn ifNotNil: [
		"Skip over the object and return the already-read-in value."
		byteStream position: skipToPosn + basePos		"make absolute"
	] ifNil: [
		"File is not positioned correctly.  Read object and throw it away."
		wasSkipping := skipping includes: curPosn.
		skipping add: curPosn.
		"fake _" super next.
		wasSkipping ifFalse: [skipping remove: curPosn ifAbsent: nil].
	].
	^ theObject
		! !
!ReferenceStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'tk 6/9/97 09:00' prior: 16945435!
    noteCurrentReference: typeID
	"PRIVATE -- If we support references for type typeID, remember
	 the current byteStream position so beginReference: can add the
	 next object to the 'objects' dictionary of reference positions,
	 then return true. Else return false."
	| answer |

	(answer := self isAReferenceType: typeID)
		ifTrue: [self setCurrentReference: (byteStream position - 1) - basePos "relative"
				"subtract 1 because we already read the object's type ID byte"].
	^ answer! !
!ReferenceStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: ' 6/9/97' prior: 16945453!
    objectAt: anInteger
    "PRIVATE -- Read & return the object at a given stream position.
     If we already read it, just get it from the objects dictionary.
     (Reading it again wouldn't work with cycles or sharing.)
     If not, go read it and put it in the objects dictionary.
     NOTE: This resolves a cross-reference in the ReferenceStream:
       1. A backward reference to an object already read (the normal case).
       2. A forward reference which is a sated weak reference (we record where
          the object ends so when we get to it normally we can fetch it from
          'objects' and skip over it).
       3. A backward reference to a 'non-reference type' per the long NOTE in
          nextPut: (we compensate here--seek back to re-read it and add the object
          to 'objects' to avoid seeking back to read it any more times).
       4. While reading a foward weak reference (case 2), we may recursively hit an
          ordinary backward reference to an object that we haven't yet read because
          we temporarily skipped ahead. Such a reference is forward in time so we
          treat it much like case 2.
     11/16-24/92 jhm: Handle forward refs. Cf. class comment and above NOTE.
	08:57 tk   anInteger is a relative position"
    | savedPosn refPosn anObject |

    ^ objects at: anInteger "relative position.  case 1: It's in 'objects'"
        ifAbsent:   "do like super objectAt:, but remember the fwd-ref-end position"
            [savedPosn := byteStream position.		"absolute"
            refPosn := self getCurrentReference.	"relative position"

            byteStream position: anInteger + basePos.	"was relative"
            anObject := self next.

            (self isAReferenceType: (self typeIDFor: anObject))
                ifTrue:  [fwdRefEnds at: anInteger put: byteStream position - basePos] "cases 2, 4"
                ifFalse: [objects at: anInteger put: anObject]. "case 3"

            self setCurrentReference: refPosn.		"relative position"
            byteStream position: savedPosn.		"absolute"
            anObject]! !
!ReferenceStream methodsFor: 'reading' library: #MinimalKernel06ObjectSerialization stamp: 'tk 6/9/97 08:24' prior: 16945521!
setCurrentReference: refPosn
    "PRIVATE -- Set currentReference to refPosn.  Always a relative position."

    currentReference := refPosn		"relative position"! !
!ReferenceStream methodsFor: 'aux' library: #MinimalKernel06ObjectSerialization stamp: 'jmv 5/9/2025 11:54:59' prior: 16945530!
                           isAReferenceType: typeID
	"Answer is:
		- true means a regular object reference (and the referenced object is in elsewhere in the stream)
		- false means either
				- an immediate (SmallInteger, Character, but not SmallFloat64) 
				- or a special object (nil, true, false) 
				- or a Class (actually an error condition. See #next and #nextPut:)
	"
	^ (#(0 0 0 0 1 1 1 1 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 1) at: typeID) = 1! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7467-library-MinimalKernel06-JuanVuletich-2025Aug28-15h55m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7462] on 28 August 2025 at 3:59:30 pm'!
!EncoderForSistaV1 class methodsFor: 'services' library: #MinimalKernel09CodeLibraryLoad stamp: 'jmv 7/31/2025 11:57:18' prior: 50357407!
displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvarToDisplace. Displace them by delta.
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"To handle inst var indexes > 255 the following is necessary:
		- Two byte ivar access opcodes, #[226 240 243], need to be prepended by a (possibly zero) extendA bytecode
		- 1 byte ivar access opcodes, [0..15],[200..207], need to also be followed by NOT bytecode 0x5F
	These conditions can be fullfilled by calling #withLongInstVarAccessBytecodes: . See senders and implementors."

	| pc end oldExtendA bytecode oldIvar newIvar bytecodeSize |

	"Just in case..."
	delta = 0 ifTrue: [ ^true ].
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		oldIvar := aCompiledMethodOrMethodSpec returnField+1.
		oldIvar >= firstIvarToDisplace ifTrue: [
			| primitiveCode |
			newIvar := oldIvar+delta.
			newIvar > 256 ifTrue: [
				aBoolean ifTrue: [self error: 'Can not convert a quick return instance variable into the long form.'].
				^false].
			aBoolean ifTrue: [
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	oldExtendA := nil.
	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							bytecodeSize := 2.
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256  ]]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							bytecodeSize := 2.
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format. Also handle extA (four byte format)"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldIvar := (aCompiledMethodOrMethodSpec at: pc+1) + 1.
			oldExtendA ifNotNil: [ oldIvar := oldExtendA * 256 + oldIvar ].
			oldIvar >= firstIvarToDisplace ifTrue: [
				newIvar := oldIvar+delta.
				(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format with possible oldExtendA"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
					oldExtendA notNil ifTrue: [
						aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ].
					"Shorten to 1 byte format + NOP #genPushInstVar:"
					(bytecode = 226 and: [ newIvar <= 16 ]) ifTrue: [
						bytecodeSize := 1.	"Hasn't any effect, but hopefully makes more sense to reader."
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					"Shorten to 1 byte format + NOP #genStorePopInstVar:"
					(bytecode = 240 and: [ newIvar <= 8 ]) ifTrue: [ 
						bytecodeSize := 1.	"Hasn't any effect, but hopefully makes more sense to reader."
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"#genUnsignedSingleExtendA:"
		oldExtendA := nil.
		bytecode = 224 ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldExtendA := aCompiledMethodOrMethodSpec at: pc+1 ].

		pc := pc + bytecodeSize ].

	^true! !
!EncoderForSistaV1 class methodsFor: 'services' library: #MinimalKernel09CodeLibraryLoad stamp: 'jmv 7/31/2025 11:56:39' prior: 50357611!
                            remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #displaceInstVarAccessesIn:starting:by:doIt:
	Note: Assumes the Sista V1 bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVar:
		#genStoreInstVar:
		#genStorePopInstVar:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"To handle inst var indexes > 255 the following is necessary:
		- Two byte ivar access opcodes, #[226 240 243], need to be prepended by a (possibly zero) extendA bytecode
		- 1 byte ivar access opcodes, [0..15],[200..207], need to also be followed by NOT bytecode 0x5F
	These conditions can be fullfilled by calling #withLongInstVarAccessBytecodes: . See senders and implementors."

	| pc end oldExtendA bytecode oldIvar bytecodeSize |

	"Just in case..."
	aDictionary isEmpty ifTrue: [ ^true ].

	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ].

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		oldIvar := aCompiledMethodOrMethodSpec returnField+1.
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			| primitiveCode |
			newIvar > 256 ifTrue: [
				aBoolean ifTrue: [self error: 'Can not convert a quick return instance variable into the long form.'].
				^false].
			aBoolean ifTrue: [
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	oldExtendA := nil.
	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		
		"#genPushInstVar: Short 1 byte format."
		bytecode < 16 ifTrue: [
			oldIvar := bytecode+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 16
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							bytecodeSize := 2.
							aCompiledMethodOrMethodSpec at: pc put: 226.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genStorePopInstVar: Short 1 byte format."
		(bytecode between: 200 and: 207) ifTrue: [
			oldIvar := bytecode-200+1.
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				newIvar <= 8
					ifTrue: [ "Keep it short."
						aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200 ]]
					ifFalse: [ "Make it two byte format"
						(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
							aBoolean ifTrue: [self error: 'Can not convert short instance variable access bytecodes to 4 byte'].
							^false].
						(pc+1 <= end and: [
							aCompiledMethodOrMethodSpec at: pc+1]) = 16r5F ifFalse: [
								aBoolean ifTrue: [self error: 'NOP padding missing'].
								^false ].
						aBoolean ifTrue: [
							bytecodeSize := 2.
							aCompiledMethodOrMethodSpec at: pc put: 240.
							aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
							oldExtendA notNil ifTrue: [
								aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ]]]]].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Two byte format. Also handle extA (four byte format)"
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldIvar := (aCompiledMethodOrMethodSpec at: pc+1) + 1.
			oldExtendA ifNotNil: [ oldIvar := oldExtendA * 256 + oldIvar ].
			aDictionary at: oldIvar ifPresent: [ :newIvar |
				(newIvar > 256 and: [oldExtendA isNil]) ifTrue: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 4 byte'].
					^false].
				"Update two byte format with possible oldExtendA"
				aBoolean ifTrue: [
					aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 \\ 256.
					oldExtendA notNil ifTrue: [
						aCompiledMethodOrMethodSpec at: pc-1 put: newIvar-1 // 256 ].
					"Shorten to 1 byte format + NOP #genPushInstVar:"
					(bytecode = 226 and: [ newIvar <= 16 ]) ifTrue: [
						bytecodeSize := 1.	"Hasn't any effect, but hopefully makes more sense to reader."
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ].
					"Shorten to 1 byte format + NOP #genStorePopInstVar:"
					(bytecode = 240 and: [ newIvar <= 8 ]) ifTrue: [
						bytecodeSize := 1.	"Hasn't any effect, but hopefully makes more sense to reader."
						aCompiledMethodOrMethodSpec at: pc put: newIvar-1+200.
						aCompiledMethodOrMethodSpec at: pc+1 put: 16r5F ]]]].

		"#genUnsignedSingleExtendA:"
		oldExtendA := nil.
		bytecode = 224 ifTrue: [
			pc+1 <= end ifFalse: [
				aBoolean ifTrue: [self error: 'Bad Method format'].
				^false].
			oldExtendA := aCompiledMethodOrMethodSpec at: pc+1 ].

		pc := pc + bytecodeSize ].

	^true! !
!EncoderForSistaV1 class methodsFor: 'services' library: #MinimalKernel09CodeLibraryLoad stamp: 'jmv 7/30/2025 16:14:42' prior: 50356720!
                       withLongInstVarAccessBytecodes: aCompiledMethodOrMethodSpec
	"Answer a CompiledMethod or MethodSpec that is functionally equivalent to the argument.
	But:
		- All instance variable accessing code are 'padded' to 4 bytes (see below).
		- All jump / branch bytecodes are 'padded' to 4 bytes (see below) AND corrected to jump to the correct place.

	This is to enable #remapInstVarAccessesIn:asPer:doIt: and #displaceInstVarAccessesIn:starting:by:doIt:
	to work on methods using short bytecodes that prevent the modification of the involved instance variable
	instance variable indexes in place.

	In the answer:
	- Short (1 byte) instance variable access bytecodes [0..15],[200..207] are kept unmodified, but followed by a NOP bytecode
	- Short (1 byte) jump / branch bytecodes [176..199] are converted to the the corresponding two byte format: #[237 238 239]
	- All the ivar access, jump and branch bytecodes are prepended with a (likely zero) extA or extB extension bytecode
		This includes  [0..15],[200..207], #[226 240 243], [176..199], #[237 238 239].
		Any extA or extB previously present is kept unmodified and not duplicated.
	- The result is larger than the argument #bytecodes. All jump / branch bytecodes are corrected to jump to the correct
		spot in the new, longer bytecodes sequence.

	Note 1: This is somewhat expensive and not especially optimized. It is expected to be needed in a very small percentage of
		methods: Only those that remap instance variables in the set of the first 256 ones to/from variables beyond index 255.
	Note 2: The result is not space optimal. In many cases the extA / extB will not actually be needed. Computing the optimum
		bytecode sequence is even more expensive. Besides this usually won't give a performance improvement, as both
		forms would be jitted to the same machine code by Cog."

	| bytecodesAndPadInfo newBytecodes |

	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		"No conversion possible."
		^nil ].

	"Quick return. Convert into a regular method."
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		| bytes |
		bytes := #[224 0 226 0 92] copy. "#genUnsignedSingleExtendA:, #genPushInstVarLong:, #genReturnTop"
		bytes at: 4 put: aCompiledMethodOrMethodSpec returnField.
		^aCompiledMethodOrMethodSpec copyWithBytecodes: bytes ].

	bytecodesAndPadInfo := aCompiledMethodOrMethodSpec bytecodes asArray.
	self withLongInstVarAccessConversion01On: bytecodesAndPadInfo.
	self withLongInstVarAccessConversion02On: bytecodesAndPadInfo.
	newBytecodes := self withLongInstVarAccessConversion03On: bytecodesAndPadInfo.
	^aCompiledMethodOrMethodSpec copyWithBytecodes: newBytecodes! !
!EncoderForSistaV1 class methodsFor: 'services' library: #MinimalKernel09CodeLibraryLoad stamp: 'jmv 7/29/2025 16:00:34' prior: 50356806!
       withLongInstVarAccessConversion01On: bytecodesAndPadInfo
	"Extract ivar accesses and jumps into aux arrays"

	| pc end hadExtendA oldExtendBByte bytecode bytecodeSize oldSize newBytes newExtendB oldDistance sizeDelta |
	
	hadExtendA := false.
	oldExtendBByte := nil.
	pc := 1.
	end := bytecodesAndPadInfo size.
	[pc <= end] whileTrue: [
		bytecode := bytecodesAndPadInfo at: pc.
		
		"#genPushInstVar: #genStorePopInstVar: Short 1 byte format."
		"Add a trailing NOP if not already there. Prepend with a zero extA if not already there."
		(bytecode < 16 or: [(bytecode between: 200 and: 207)]) ifTrue: [
			oldSize := (pc+1 <= end and: [bytecodesAndPadInfo at: pc+1]) = 16r5F
				ifTrue: [2] "Already had a trailing NOP"
				ifFalse: [1]. "Didn't have it."
			newBytes := {bytecode. 16r5F}. "Will indeed have a trailing NOP"
			hadExtendA ifFalse: [
				newBytes := #[224 0], newBytes]. "Will add a zero extA if it didn't have one already"
			bytecodesAndPadInfo at: pc put: { #ivarAccess. oldSize. newBytes size-oldSize. newBytes} ].
		
		"#genPushInstVar: #genStorePopInstVar: #genStoreInstVar: Regular 2 byte format."
		"Prepend with a zero extA if not already there."
		(#[226 240 243] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				^false].
			newBytes := {bytecode. bytecodesAndPadInfo at: pc+1}.
			hadExtendA ifFalse: [
				newBytes := #[224 0], newBytes]. "Add a zero extA before our bytecode if there wasn't one already there."
			bytecodesAndPadInfo at: pc put: ( { #ivarAccess. 2. newBytes size-2. newBytes}) ].
		
		"#genJump:, #genBranchPopTrue:, #genBranchPopFalse:, short 1 byte format. Also handle possible extB (four byte format)"
		"Convert to 2 byte format. Prepend with a zero extB if not already present (there shouldn't be one)."
		(bytecode between: 176 and: 199) ifTrue: [
			newExtendB := oldExtendBByte ifNil: [{225. 0}] ifNotNil: [nil]. 	"Add extB if not already there. Second byte for jump distance to be set later."
			newBytes := {bytecode >> 3 + 215. 0}. 						"Compute two byte bytecode (237, 238, 239). Second byte to be set later."
			sizeDelta := (oldExtendBByte ifNil: [2] ifNotNil: [0]) + 2-1. 		"extB size + newBytes size - oldSize"
			oldDistance := (bytecode bitAnd: 7) + 1.						"Extract jump distance from 1-byte bytecode"
			"Ignore very unlikely oldExtendB, for oldDistance. Assume zero. (It doesn't make sense to actually use it for 3 bit jumps!!)"
			bytecodesAndPadInfo at: pc put: ( {#branch. 1. sizeDelta. oldDistance. newExtendB. newBytes }) ].
		
		"#genJump:, #genBranchPopTrue:, #genBranchPopFalse:, Two byte format. Also handle possible extB (four byte format)"
		(#[237 238 239] includes: bytecode) ifTrue: [
			pc+1 <= end ifFalse: [
				^false].
			newExtendB := oldExtendBByte ifNil: [{225. 0}] ifNotNil: [nil]. 	"Add extB if not already there. Second byte for jump distance to be set later."
			newBytes := {bytecode. 0}. 									"Second byte for jump distance will be set later."
			sizeDelta := (oldExtendBByte ifNil: [2] ifNotNil: [0]) + 2-2. 		"extB size + newBytes size - oldSize"
			"Compute oldDistance. Include possible extB byte."
			oldDistance := bytecodesAndPadInfo at: pc+1.
			oldExtendBByte notNil ifTrue: [
				(bytecode = 237 and: [oldExtendBByte > 127]) ifTrue: [oldExtendBByte := oldExtendBByte-256].
				oldDistance := oldExtendBByte * 256 + oldDistance ].
			bytecodesAndPadInfo at: pc put: ( {#branch. 2. sizeDelta. oldDistance. newExtendB. newBytes }) ].
		
		"#genUnsignedSingleExtendA: and genUnsignedSingleExtendB: Will be taken into account for next bytecode."
		hadExtendA := bytecode = 224.
		oldExtendBByte := nil.
		(bytecode = 225 and: [pc+1 <= end]) ifTrue: [
			oldExtendBByte := bytecodesAndPadInfo at: pc+1 ].
		
		"Copied from EncoderForSistaV1 class >> bytecodeSize:"
		bytecodeSize := 1.
		bytecode >= 224 ifTrue: [ bytecodeSize := 2 ].
		bytecode >= 248 ifTrue: [ bytecodeSize := 3 ].
		pc := pc + bytecodeSize ].

	^true! !
!EncoderForSistaV1 class methodsFor: 'services' library: #MinimalKernel09CodeLibraryLoad stamp: 'jmv 7/29/2025 16:03:20' prior: 50356932!
                   withLongInstVarAccessConversion02On: bytecodesAndPadInfo
	"Correct #branch (branch and jump bytecodes) with correct jump distance."

	| newDistance oldDistance |
	1 to: bytecodesAndPadInfo size do: [ :i | | entry |
		entry := bytecodesAndPadInfo at: i.
		(entry isArray and: [entry first = #branch]) ifTrue: [ | newDistanceHigh newDistanceLow |
			oldDistance := entry fourth.
			newDistance := oldDistance.
			i+entry second to: i+entry second+oldDistance-oldDistance sign by: oldDistance sign do: [ :j | | eachJumpedOver |
				eachJumpedOver := bytecodesAndPadInfo at: j.
				eachJumpedOver isArray ifTrue: [ newDistance := newDistance + eachJumpedOver third ]].
			"See #genUnsignedSingleExtendB: and #genSignedSingleExtendB:"
			newDistanceHigh := newDistance >> 8. newDistanceHigh < 0 ifTrue: [newDistanceHigh := newDistanceHigh + 256].
			newDistanceLow := newDistance bitAnd: 255.
			entry fifth "High byte goes to existing extB if there was one. Or to a new one otherwise."
				ifNil: [ bytecodesAndPadInfo at: i-1 put: newDistanceHigh ]
				ifNotNil: [ :extB | extB at: 2 put: newDistanceHigh ].
			entry sixth at: 2 put: newDistanceLow ]].! !
!EncoderForSistaV1 class methodsFor: 'services' library: #MinimalKernel09CodeLibraryLoad stamp: 'jmv 7/29/2025 16:03:48' prior: 50356971!
                     withLongInstVarAccessConversion03On: bytecodesAndPadInfo
	"Write the updated bytecode sequence using the already calculated bytecodes."
	
	^ByteArray streamContents: [ :strm | | i |
		i := 1.
		[ i <= bytecodesAndPadInfo size ] whileTrue: [ | entry |
			entry := bytecodesAndPadInfo at: i.
			entry isArray
				ifTrue: [
					entry first == #ivarAccess ifTrue: [
						strm nextPutAll: entry fourth ].
					entry first == #branch ifTrue: [
						entry fifth ifNotNil: [ :extB | strm nextPutAll: extB ].
						strm nextPutAll: entry sixth ].
					i := i + entry second ]
				ifFalse: [
					strm nextPut: entry.
					i := i + 1 ]]].! !
!EncoderForV3PlusClosures class methodsFor: 'services' library: #MinimalKernel09CodeLibraryLoad stamp: 'jmv 7/31/2025 11:52:12' prior: 50357813!
                    displaceInstVarAccessesIn: aCompiledMethodOrMethodSpec starting: firstIvarToDisplace by: delta doIt: aBoolean
	"Remap instance variable accesses according to parameters.
	Affect instance variables access starting with ivar number firstIvarToDisplace. Displace them by delta.
	Instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Similar to #remapInstVarAccessesIn:asPer:doIt:
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive

	Warning: After calling on a CompiledMethod, you must do either
		aBoolean ifTrue: [aCompiledMethodOrMethodSpec voidCogVMState].
	or
		aBoolean ifTrue: [Smalltalk voidCogVMState].
	This is not done in this method, because when processing many, it is best to do
		Smalltalk voidCogVMState
	after all of them. See senders."
	
	"This method can not handle remapping of 1-byte ivar access bytecodes: [0..15], [96..103]
	This method can not convert two byte bytecodes #[128 129 130] to or from three byte 132 + #[64 160 192].
	However the Sista Bytecode version of this method can.
	It is therefore recommended to use the Sista Bytecode Set."

	| pc end bytecode followingByte thirdByte oldIvar newIvar bytecodeSize |
	"Just in case..."
	delta = 0 ifTrue: [ ^true ].
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ]	.

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			oldIvar := aCompiledMethodOrMethodSpec returnField+1.
			oldIvar >= firstIvarToDisplace ifTrue: [
				| primitiveCode |
				newIvar := oldIvar+delta.
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 							"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode + 1 ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		oldIvar >= firstIvarToDisplace ifTrue: [
			aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
			^false ]	.
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			followingByte+1 >= firstIvarToDisplace ifTrue: [
				followingByte+delta < 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: followingByte+delta ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			thirdByte+1 >= firstIvarToDisplace ifTrue: [
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: thirdByte+delta ]]].

		pc := pc + bytecodeSize ].

	^true! !
!EncoderForV3PlusClosures class methodsFor: 'services' library: #MinimalKernel09CodeLibraryLoad stamp: 'jmv 7/31/2025 11:52:49' prior: 50357941!
remapInstVarAccessesIn: aCompiledMethodOrMethodSpec asPer: aDictionary doIt: aBoolean
	"Remap all instance variable accesses according to aDictionary.
	aDictionary is of the form: {
		(oldIvarNumber -> newIvarNumber).
		...
		(oldIvarNumber -> newIvarNumber) }
	where instance variable numbers are 1-based.
	If aBoolean is false, just check if it is possible and answer true if so.
	If aBoolean is true, go ahead and do it. Raise an error on failure, because method(s) are now inconsistent.
	Note: If calling on a CompiledMethod, you must do
		Smalltalk voidCogVMState
	when done. But if you're processing a bunch of methods, do it after you're done with all of them.
	Similar to #displaceInstVarAccessesIn:starting:by:doIt:
	Note: Assumes the V3PlusClosures bytecode set is in use.
	Note: Based on InstructionStream>>scanFor:
	See also
		#genPushInstVarAllowForIvarsRemapping:
		#genStoreInstVarAllowForIvarsRemapping:
		#genStorePopInstVarAllowForIvarsRemapping:
		#returnField and #primitive"
	
	"This method can not handle remapping of 1-byte ivar access bytecodes: [0..15], [96..103]
	This method can not convert two byte bytecodes #[128 129 130] to or from three byte 132 + #[64 160 192].
	However the Sista Bytecode version of this method can.
	It is therefore recommended to use the Sista Bytecode Set."

	| pc end bytecode followingByte thirdByte oldIvar bytecodeSize |
	
	(self includesBehavior: aCompiledMethodOrMethodSpec encoderClass) ifFalse: [
		aBoolean ifTrue: [self error: 'BytecodeEncoder inconsistency'].
		^false ]	.

	pc := aCompiledMethodOrMethodSpec initialPC.
	end := aCompiledMethodOrMethodSpec endPC.

	"Quick return"
	aCompiledMethodOrMethodSpec isReturnField ifTrue: [
		aBoolean ifTrue: [
			aDictionary at: aCompiledMethodOrMethodSpec returnField+1 ifPresent: [ :newIvar |
				| primitiveCode |
				primitiveCode := newIvar-1 + 264.
				aCompiledMethodOrMethodSpec at: pc + 1 put: primitiveCode \\ 256.
				aCompiledMethodOrMethodSpec at: pc + 2 put: primitiveCode // 256 ]].
		^true ].

	[pc <= end] whileTrue: [
		bytecode := aCompiledMethodOrMethodSpec at: pc.
		
		"Copied from EncoderForV3PlusClosures class >> bytecodeSize:"
		bytecodeSize := true caseOf: {
			[bytecode <= 125] -> [1].
			[bytecode >= 176] -> [1].
			[bytecode >= 160] -> [2].						"long jumps"
			[bytecode >= 144] -> [1].						"short jumps"
			[bytecode >= 128] -> [ 							"extensions"
				#(2 2 2 2 3 2 2 1 1 1 2 3 3 3 3 4) at: bytecode - 127] }.
		
		"Can not handle short (single byte) instance variable access bytecodes at all"
		oldIvar := -1.
		bytecode < 16 ifTrue: [ oldIvar := bytecode + 1 ].
		(bytecode between: 96 and: 103) ifTrue: [ oldIvar := (bytecode bitAnd: 2r111) + 1 ].
		aDictionary at: oldIvar ifPresent: [ :newIvar |
			newIvar = oldIvar ifFalse: [
				aBoolean ifTrue: [self error: 'Can not handle short instance variable access bytecodes'].
				^false ]	].
		
		"Two byte instance variable access bytecodes"
		followingByte := pc+1 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 ].
		((#[128 129 130] includes: bytecode) and: [followingByte < 64]) ifTrue: [
			aDictionary at: followingByte+1 ifPresent: [ :newIvar |
				newIvar <= 64 ifFalse: [
					aBoolean ifTrue: [self error: 'Can not convert 2 byte instance variable access bytecodes to 3 byte'].
					^false].
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+1 put: newIvar-1 ]]].

		"Three byte instance variable access bytecodes"
		(bytecode = 132 and: [#[64 160 192] includes: followingByte]) ifTrue: [
			thirdByte := pc+2 <= end ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 ].
			aDictionary at: thirdByte+1 ifPresent: [ :newIvar |
				aBoolean ifTrue: [ aCompiledMethodOrMethodSpec at: pc+2 put: newIvar-1 ]]].

		pc := pc + bytecodeSize ].

	^true! !
!EncoderForV3PlusClosures class methodsFor: 'services' library: #MinimalKernel09CodeLibraryLoad stamp: 'jmv 7/30/2025 15:24:12' prior: 50356994!
                          withLongInstVarAccessBytecodes: aCompiledMethodOrMethodSpec
	"This method is provided for compatibility with EncoderForSistaV1.
	However, the desired result can not be produced for the V3 Bytecode Set.
	The reason is the need for a space padding NOP bytecode, missing in V3.
	Answer nil: no conversion possible."

	^nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7468-library-MinimalKernel09-JuanVuletich-2025Aug28-15h56m-jmv.001.cs.st----!

#(
	#(#ProtoObject #'Kernel-Objects')
	#(#Object #'Kernel-Objects')
	#(#Behavior #'Kernel-Classes')
	#(#ClassDescription #'Kernel-Classes')
	#(#Class #'Kernel-Classes')
	#(#Metaclass #'Kernel-Classes')
	#(#Collection #'Kernel-Collections')
	#(#SequenceableCollection #'Kernel-Collections')
	#(#ArrayedCollection #'Kernel-Collections')
	#(#Array #'Kernel-Collections')
	#(#ByteArray #'Kernel-Collections')
	#(#CompiledMethod #'Kernel-Methods')
	#(#LinkedList #'Kernel-Collections')
	#(#Semaphore #'Kernel-Processes')
	#(#CharacterSequence #'Kernel-Strings')
	#(#String #'Kernel-Strings')
	#(#Symbol #'Kernel-Strings')
	#(#Set #'Kernel-Collections')
	#(#Dictionary #'Kernel-Collections')
	#(#IdentityDictionary #'Kernel-Collections')
	#(#SystemDictionary #'Kernel-Support')
	#(#MethodDictionary #'Kernel-Methods')
	#(#SharedQueue #'Kernel-Collections')
	#(#Stream #'Kernel-Collections')
	#(#PositionableStream #'Kernel-Collections')
	#(#WriteStream #'Kernel-Collections')
	#(#AdditionalMethodState #'Kernel-Methods')
	#(#BlockClosure #'Kernel-Methods')
	#(#InstructionStream #'Kernel-Methods')
	#(#ContextPart #'Kernel-Methods')
	#(#MethodContext #'Kernel-Methods')
	#(#Message #'Kernel-Methods')
	#(#Pragma #'Kernel-Methods')
	#(#Boolean #'Kernel-Objects')
	#(#False #'Kernel-Objects')
	#(#True #'Kernel-Objects')
	#(#Magnitude #'Kernel-Objects')
	#(#Number #'Kernel-Numbers')
	#(#Float #'Kernel-Numbers')
	#(#BoxedFloat64 #'Kernel-Numbers')
	#(#SmallFloat64 #'Kernel-Numbers')
	#(#Integer #'Kernel-Numbers')
	#(#LargePositiveInteger #'Kernel-Numbers')
	#(#LargeNegativeInteger #'Kernel-Numbers')
	#(#SmallInteger #'Kernel-Numbers')
	#(#LookupKey #'Kernel-Support')
	#(#Association #'Kernel-Support')
	#(#UndefinedObject #'Kernel-Objects')
	#(#ProcessorScheduler #'Kernel-Processes')
	#(#Character #'Kernel-Strings')
	#(#Link #'Kernel-Support')
	#(#Process #'Kernel-Processes')
	#(#Point #'Kernel-Support')
	#(#IdentitySet #'Kernel-Collections')
	#(#ReadStream #'Kernel-Collections')
	#(#WeakArray #'Kernel-Collections')
	#(#WeakSet #'Kernel-Collections')
	#(#Exception #'Kernel-Exceptions')
	#(#Error #'Kernel-Exceptions')
	#(#ArithmeticError #'Kernel-Exceptions')
	#(#DomainError #'Kernel-Exceptions')
	#(#ArithmeticMessageError #'Kernel-Exceptions')
	#(#ZeroDivide #'Kernel-Exceptions')
	#(#StdIOWriteStream #'System-Support')
) do: [ :spec |
	SystemOrganization classify: spec first under: spec second ].
SystemOrganization removeEmptyCategories.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7469-MinimalKernel-ClassCategories-MergeIntoKernel-JuanVuletich-2025Apr29-11h10m-jmv.003.cs.st----!

'From Cuis7.5 [latest update: #7469] on 29 August 2025 at 11:17:10 am'!
!WeakArray class methodsFor: 'library membership' library: #MinimalKernel02Symbol stamp: 'jmv 8/29/2025 11:10:16'!
           includeInMinimalKernel02Symbol
	"Making this method part of the MinimalKernel02Symbol library means
	this class is also included, even if no actually used method is added."! !
!DomainError class methodsFor: 'library membership' library: #MinimalKernel03Float stamp: 'jmv 8/29/2025 11:07:20'!
                            includeInMinimalKernel03Float
	"Making this method part of the MinimalKernel03Float library means
	this class is also included, even if no actually used method is added."! !
!ZeroDivide class methodsFor: 'library membership' library: #MinimalKernel01 stamp: 'jmv 8/29/2025 11:08:55'!
    includeInMinimalKernel01
	"Making this method part of the MinimalKernel01 library means
	this class is also included, even if no actually used method is added."! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7470-AddEmptyClassesToLibraries-JuanVuletich-2025Aug29-11h02m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7470] on 29 August 2025 at 2:16:41 pm'!
!InnerListMorph methodsFor: 'geometry' stamp: 'jmv 8/29/2025 14:14:35' prior: 16886662!
                   desiredWidth
"Ok, this is a bit messed up. We need to return the width of the widest item in the list. If we grab every item in the list, it defeats the purpose of LazyListMorph. If we don't, then we don't know the size. This is a compromise -- if the list is less then 30 items, we grab them all. If not, we grab currently visible ones, until we've checked itemsToCheck of them, then take the max width out of that 'sampling', then enlarge it a bit. If you know a better way, please chime in."

	| maxW count itemsToCheck |

	itemsToCheck := 200.
	maxW := owner viewableWidth.
	count := 0.
	listItems do: [ :each |
		each ifNotNil: [
			maxW := maxW max: (self widthToDisplayItem: each contents)]].
	(count < itemsToCheck) ifTrue: [
		1 to: listItems size do: [:i | 
			(listItems at: i) ifNil: [ | item | 
				item := self item: i.
				maxW := maxW max: (self widthToDisplayItem: item contents) ].
			((count := count + 1) > itemsToCheck) ifTrue: [
				^maxW * 13//10  ]]].
	^maxW! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7471-InnerListMorph-horizontalScrollbar-tweak-JuanVuletich-2025Aug29-14h16m-jmv.001.cs.st----!

----QUIT----(29 August 2025 15:07:29) Cuis7.5-7471.image priorSource: 766629!

----STARTUP---- (5 September 2025 16:18:27) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.5-7471.image!


'From Cuis7.5 [latest update: #7471] on 1 September 2025 at 12:26:15 pm'!
!VectorEngine methodsFor: 'private' stamp: 'jmv 9/1/2025 12:25:55' prior: 50349388!
                         displayUtf32: aWordArray from: startIndex to: stopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours deltaXToCenter deltaXForDiacriticalMark deltaYForDiacriticalMark deltaXForBaseGlyph baseBoundsTop |
	deltaXForBaseGlyph := 0.0.
	baseBoundsTop := 0.0.
	nextGlyphX := destX.
	startIndex to: stopIndex do: [ :utf32Index | | utf32 i |
		utf32 := aWordArray at: utf32Index.
		
		"$i followed by a Combining Diacritical Mark is replaced by CodePoint 16r131 Dotless i
		This should also be done for VectorEngineWithPlugin"
		(utf32 = 16r69 and: [ utf32Index < stopIndex ] and: [
			(aWordArray at: utf32Index+1) between: 16r300 and: 16r36F ])
				ifTrue: [ utf32 := 16r131 ].
		i :=  self contourDataIndexForUtf32: utf32 contourDataIndexes: contourDataIndexes.
		advanceWidth := contourData at: i. i := i + 1.
		boundsLeft := contourData at: i. i := i + 1.
		boundsRight := contourData at: i. i := i + 1.
		boundsBottom := contourData at: i. i := i + 1.
		boundsTop := contourData at: i. i := i + 1.
		numContours := (contourData at: i) asInteger. i := i + 1.
		
		"TrueType doesn't speciy how to position diacritics wrt base character glyph.
		Horizontally center diacriticals wrt base glyph.
		See
			basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
			formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
			displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
		This should also be done for VectorEngineWithPlugin
		Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
		deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
		utf32 = 16r300 ifTrue: [	"Combining Grave Accent"
			deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
		utf32 = 16r301 ifTrue: [ 	"Combining Acute Accent"
			deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ].
		"DoubleWidth code points that combine above previous and following characters.
		Codepoints between 16r035C and 16r0363.
		Example: o͢o
		Don't center them"
		(utf32 between: 16r035C and: 16r0363) ifTrue: [
			deltaXToCenter := 0.0 ].
				
		deltaXForDiacriticalMark := 0.0.
		deltaYForDiacriticalMark := 0.
		advanceWidth = 0.0
			ifFalse: [ "Regular glyph"
				deltaXForBaseGlyph := deltaXToCenter.
				baseBoundsTop := boundsTop ]
			ifTrue: [ "Diacritical mark"
				deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
					ifFalse: [
						deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
						baseBoundsTop > boundsBottom ifTrue: [
							deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
		
		self
			glyphContours: numContours
			atx: nextGlyphX + deltaXForDiacriticalMark y: destY + deltaYForDiacriticalMark
			scalex: sx y: sy
			contourData: contourData i: i.
		
		nextGlyphX := nextGlyphX + (advanceWidth * sx) ].
	^nextGlyphX! !
!VectorEngine methodsFor: 'private' stamp: 'jmv 9/1/2025 12:26:02' prior: 50349484!
               displayUtf8: aByteArray fromByte: byteStartIndex toByte: byteStopIndex atx: destX y: destY scalex: sx y: sy contourData: contourData contourDataIndexes: contourDataIndexes
	
	| nextGlyphX byte1 byte2OrNil baseIndex advanceWidth boundsLeft boundsRight boundsBottom boundsTop numContours deltaXToCenter deltaXForDiacriticalMark deltaYForDiacriticalMark deltaXForBaseGlyph baseBoundsTop |
	deltaXForBaseGlyph := 0.0.
	baseBoundsTop := 0.0.
	nextGlyphX := destX.
	byte1 := nil.
	byte2OrNil := nil.
	baseIndex := 0.
	byteStartIndex to: byteStopIndex do: [ :byteIndex | | byte i |
		byte := aByteArray at: byteIndex.
		byte1 isNil ifTrue: [byte1 := byte ] ifFalse: [ byte2OrNil isNil ifTrue: [ byte2OrNil := byte ]].
		i := contourDataIndexes at: baseIndex + byte + 1.
		
		"$i followed by a Combining Diacritical Mark is replaced by CodePoint 305 Dotless i, UTF-8 #[196 177]
		(UnicodeString fromUtf8Bytes: #[105 105 204 129 32 105 204 128 32 105 204 130 32 105 204 131 32
			105 204 132 32 105 204 133 32 105 204 134 32 105 204 135 32 105 204 136 32 105 204 137 ]) edit
		This should also be done for VectorEngineWithPlugin"
		(byte1 = 105 and: [ byteIndex < (byteStopIndex-1) ] and: [
			(aByteArray at: byteIndex+1) = 204 or: [ (aByteArray at: byteIndex+1) = 205 and: [ (aByteArray at: byteIndex+2) < 176 ]]])
				ifTrue: [
					i := contourDataIndexes at: 196 + 1.
					i := contourDataIndexes at: i negated + 177 + 1 ].
		
		i < 0
			ifTrue: [ baseIndex := i negated ]
			ifFalse: [
				advanceWidth := contourData at: i. i := i + 1.
				boundsLeft := contourData at: i. i := i + 1.
				boundsRight := contourData at: i. i := i + 1.
				boundsBottom := contourData at: i. i := i + 1.
				boundsTop := contourData at: i. i := i + 1.
				numContours := (contourData at: i) asInteger. i := i + 1.
				"TrueType doesn't speciy how to position diacritics wrt base character glyph.
				Horizontally center diacriticals wrt base glyph.
				See
					basicDisplayUtf8:fromByte:toByte:at:trueTypeFont:
					formGlyphForUtf8Byte1:byte2:byte3:byte4:pixelSize:
					displayUtf32:from:to:at:trueTypeFont:color:scale:preventMirroring:
				This should also be done for VectorEngineWithPlugin
				Apparently OpenType can do better than TrueType, as it includes the GPOS table..."
				deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.51).
				byte1 = 204 ifTrue: [
					byte2OrNil = 128 ifTrue: [ "Combining Grave Accent"
						deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.43) ].
					byte2OrNil = 129 ifTrue: [ "Combining Acute Accent"
						deltaXToCenter := advanceWidth - (boundsRight+boundsLeft * 0.65) ]].
				"DoubleWidth code points that combine above previous and following characters.
				Codepoints between 16r035C and 16r0363.
				Example: o͢o
				Don't center them"
				(byte1 = 205 and: [ byte2OrNil between: 156 and: 163 ]) ifTrue: [
					deltaXToCenter := 0.0 ].
				
				deltaXForDiacriticalMark := 0.0.
				deltaYForDiacriticalMark := 0.
				advanceWidth = 0.0
					ifFalse: [ "Regular glyph"
						deltaXForBaseGlyph := deltaXToCenter.
						baseBoundsTop := boundsTop ]
					ifTrue: [ "Diacritical mark"
						deltaXForBaseGlyph = 0.0  "For instance, if the first code point to display is a diacritic, like when building a FormGlyph for it"
							ifFalse: [
								deltaXForDiacriticalMark := deltaXToCenter - deltaXForBaseGlyph * sx.
								baseBoundsTop > boundsBottom ifTrue: [
									deltaYForDiacriticalMark :=  baseBoundsTop - boundsBottom + 100 * sy ]]].
				
				self
					glyphContours: numContours
					atx: nextGlyphX + deltaXForDiacriticalMark y: destY + deltaYForDiacriticalMark
					scalex: sx y: sy
					contourData: contourData i: i.
				
				nextGlyphX := nextGlyphX + (advanceWidth * sx).
				baseIndex := 0.
				byte1 := nil.
				byte2OrNil := nil ]].
	^nextGlyphX! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7472-VectorEngineSmalltalk-fix-JuanVuletich-2025Sep01-12h23m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7490] on 3 September 2025 at 9:44:37 am'!
!Morph methodsFor: 'private' stamp: 'jmv 9/3/2025 09:39:05'!
  privateMove: aMorph toIndex: index
	"aMorph's position changes within in the submorph chain
	Move aMorph to the requested index."

	| oldIndex |
	oldIndex := submorphs indexOf: aMorph.
	index = oldIndex ifTrue: [ ^self ].
	index < oldIndex
		ifTrue: [
			oldIndex-1 to: index by: -1 do: [ :i |
				submorphs at: i+1 put: (submorphs at: i)]]
		ifFalse: [
			submorphs replaceFrom: oldIndex to: index-1 with: submorphs startingAt: oldIndex+1 ].
	submorphs at: index put: aMorph.
	self world ifNotNil: [aMorph redrawNeeded].
	self privateFixLayerOrder.
	self someSubmorphPositionOrExtentChanged.! !
!PluggableScrollPane methodsFor: 'private' stamp: 'jmv 9/3/2025 09:41:22'!
 privateMoveFrontMorph: aMorph
	"Position 1 and 2 in our submorphs are taken by our scrollbars"
	
	self privateMove: aMorph toIndex: 3! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 9/3/2025 09:40:32' prior: 50332040!
                             comeToFront

	"Restore default #layerNumber for us.
	We may still end behind other 'more topMost' morphs."
	self removeProperty: #layerNumber.
	owner privateMoveFrontMorph: self! !
!Morph methodsFor: 'private' stamp: 'jmv 9/3/2025 09:39:27' prior: 16914671!
                              privateMoveBackMorph: aMorph
	"aMorph's position changes within in the submorph chain
	Move aMorph behind all siblings"
	
	self privateMove: aMorph toIndex: submorphs size! !
!Morph methodsFor: 'private' stamp: 'jmv 9/3/2025 09:39:37' prior: 16914689!
    privateMoveFrontMorph: aMorph
	"aMorph's position changes within in the submorph chain
	Move aMorph to be above all siblings"
	
	self privateMove: aMorph toIndex: 1! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7473-comeToFront-inPluggableScrollPane-fix-JuanVuletich-2025Sep03-09h43m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7490] on 3 September 2025 at 10:14:05 am'!
!MessageNode methodsFor: 'macro transformations' stamp: 'jmv 9/3/2025 10:12:44' prior: 16903725!
                        transformIfNil: encoder

	(Preferences at: #avoidIfNilOptimization) ifTrue: [
		^false ].

	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."
	(MacroSelectors at: special) = #ifNotNil: ifTrue:
		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse:
			[^false].

		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.
		Slightly better code and more consistent with decompilation."
		self noteSpecialSelector: #ifNil:ifNotNil:.
		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.
		arguments := Array
						with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)
						with: (arguments first noteOptimizedIn: self).
		(self transform: encoder) ifFalse:
			[self error: 'compiler logic error'].
		^true].
	(self checkBlock: arguments first as: 'ifNil arg' from: encoder maxArgs: 0) ifFalse:
		[^false].
	arguments first noteOptimizedIn: self.
	^true! !
!MessageNode methodsFor: 'macro transformations' stamp: 'jmv 9/3/2025 10:13:15' prior: 16903757!
                             transformIfNilIfNotNil: encoder
	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we
	 transform the receiver to
		(var := receiver)
	 which is further transformed to
		(var := receiver) == nil ifTrue: .... ifFalse: ...
	 This does not allow the block variable to shadow an existing temp, but it's no different
	 from how to:do: is done."

	| ifNotNilArg |
	(Preferences at: #avoidIfNilOptimization) ifTrue: [
		^false ].
	
	ifNotNilArg := arguments at: 2.
	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder maxArgs: 0)
	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:
		[^false].

	ifNotNilArg numberOfArguments = 1 ifTrue:
		[receiver := AssignmentNode new
						variable: ifNotNilArg firstArgument
						value: receiver].

	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.
	receiver := MessageNode new
					receiver: receiver
					selector: #==
					arguments: (Array with: NodeNil)
					precedence: 2
					from: encoder.
	arguments do: [:arg| arg noteOptimizedIn: self].
	^true! !
!MessageNode methodsFor: 'macro transformations' stamp: 'jmv 9/3/2025 10:13:21' prior: 16903792!
     transformIfNotNilIfNil: encoder
	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we
	 transform the receiver to
		(var := receiver)
	 which is further transformed to
		(var := receiver) == nil ifTrue: .... ifFalse: ...
	 This does not allow the block variable to shadow an existing temp, but it's no different
	 from how to:do: is done."
	
	| ifNotNilArg |
	(Preferences at: #avoidIfNilOptimization) ifTrue: [
		^false ].
	
	ifNotNilArg := arguments at: 1.
	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)
	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder maxArgs: 0]) ifFalse:
		[^false].

	ifNotNilArg numberOfArguments = 1 ifTrue:
		[receiver := AssignmentNode new
						variable: ifNotNilArg firstArgument
						value: receiver].

	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.
	receiver := MessageNode new
					receiver: receiver
					selector: #==
					arguments: (Array with: NodeNil)
					precedence: 2
					from: encoder.
	arguments swap: 1 with: 2.
	arguments do: [:arg| arg noteOptimizedIn: self].
	^true! !
!MessageNode class methodsFor: 'class initialization' stamp: 'jmv 9/3/2025 10:11:57' prior: 16904147!
   initialize
	"
	MessageNode initialize
	"
	MacroSelectors := 
		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:
			and: or:
			whileFalse: whileTrue: whileFalse whileTrue
			to:do: to:by:do:
			caseOf: caseOf:otherwise:
			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:
			repeat ).
	MacroTransformers := 
		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:
			transformAnd: transformOr:
			transformWhile: transformWhile: transformWhile: transformWhile:
			transformToDo: transformToDo:
			transformCase: transformCase:
			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:
			transformRepeat: ).
	MacroEmitters := 
		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:
			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:
			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:
			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:
			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:
			emitCodeForRepeat:encoder:value:).
	MacroSizers := 
		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:
			sizeCodeForToDo:value: sizeCodeForToDo:value:
			sizeCodeForCase:value: sizeCodeForCase:value:
			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:
			sizeCodeForRepeat:value:).
	MacroPrinters := 
		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:
			printIfOn:indent: printIfOn:indent:
			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:
			printToDoOn:indent: printToDoOn:indent:
			printCaseOn:indent: printCaseOn:indent:
			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:
			printRepeatOn:indent:).
	Preferences
		name: #allowNonBooleanReceiversOfBooleanMessages
		description: 'If set, do not optimize boolean selectors, allowing, for example, new Boolean classes.'
		category: #programming type: Boolean value: false.
	Preferences
		name: #avoidIfNilOptimization
		description: 'If set, do not optimize #ifNil: #ifNotNil: and similar selectors, allowing alternative nil like objects.'
		category: #programming type: Boolean value: false.! !

MessageNode initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7474-NewPreference-avoidIfNilOptimization-JuanVuletich-2025Sep03-09h44m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7472] on 1 September 2025 at 2:48:08 pm'!

MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton eventHandler '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #MouseButtonEvent category: #'Morphic-Events' stamp: 'Install-7475-MouseButtonEvent-cleanup-JuanVuletich-2025Sep01-14h45m-jmv.001.cs.st 9/5/2025 16:18:27'!
MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton eventHandler'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 9/1/2025 13:00:02' prior: 16917242!
                              dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| aMorphHandlesIt grabAMorph handledByInner |
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchWith: aMorph ].

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^ #rejected ].

	"Install the prospective handler for the receiver"
	aMorphHandlesIt := self mouseButton3Pressed or: [aMorph handlesMouseDown: self].
	grabAMorph := false.
	"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
	self mouseButton1Pressed ifTrue: [
		aMorph owner ifNotNil: [ :o |
			(o allowsSubmorphDrag and: [ aMorph isSticky not ]) ifTrue: [
				grabAMorph := true ]]].

	"Now give submorphs a chance to handle the event"
	handledByInner := false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner := true ]]].

	(handledByInner or: [ (aMorph rejectsEvent: self) not and: [ aMorph fullIncludesPixel: position ] ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt
			ifTrue: [ ^self sendEventTo: aMorph ]
			ifFalse: [
				(grabAMorph and: [ handledByInner not ]) ifTrue: [
					self hand
						waitForClicksOrDrag: aMorph event: self
						dragSel: ((Preferences at: #clickGrabsMorphs) ifFalse: [#dragEvent:localPosition:])
						clkSel: ((Preferences at: #clickGrabsMorphs) ifTrue: [#dragEvent:localPosition:]).
					"false ifTrue: [ self hand grabMorph: aMorph ]."
					(Preferences at: #clickGrabsMorphs) ifFalse: [
						self shiftPressed
							ifTrue: [ (aMorph is: #SystemWindow) ifTrue: [ aMorph sendToBack ] ]
							ifFalse: [ aMorph activateWindow ] ].
					self wasHandled: true.
					^ self ]]].

	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected! !
!Morph methodsFor: 'events' stamp: 'jmv 9/1/2025 12:53:42' prior: 16911299!
                       mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition

	self root addHalo: aMouseButtonEvent.! !

MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #MouseButtonEvent category: #'Morphic-Events' stamp: 'Install-7475-MouseButtonEvent-cleanup-JuanVuletich-2025Sep01-14h45m-jmv.001.cs.st 9/5/2025 16:18:27'!
MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7475-MouseButtonEvent-cleanup-JuanVuletich-2025Sep01-14h45m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7473] on 1 September 2025 at 1:07:34 pm'!
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 9/1/2025 13:06:23' prior: 16916257!
      dispatchWith: aMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| handledByInner |

	"Try to get out quickly"
	(aMorph fullIncludesPixel: self eventPosition)
		ifFalse: [ ^#rejected ].

	"Now give submorphs a chance to handle the event"
	handledByInner := false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner := true ]]].

	"Check for being inside the receiver"
	(handledByInner or: [ (aMorph rejectsEvent: self) not ])
		ifTrue: [ ^ self sendEventTo: aMorph ].

	^ #rejected! !
!DropFilesEvent methodsFor: 'dispatching' stamp: 'jmv 9/1/2025 13:06:39' prior: 16852103!
       dispatchWith: aMorph
	"Drop is done on the innermost target that accepts it."

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position) ifFalse: [ ^#rejected ].

	"Go looking if any of our submorphs wants it"
	aMorph submorphsDo: [ :eachChild |
		(eachChild dispatchEvent: self) == #rejected ifFalse: [ ^self ]].

	(aMorph allowsFilesDrop and: [ (aMorph rejectsEvent: self) not ])
		ifTrue: [^ self sendEventTo: aMorph ].
	
	^#rejected! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 9/1/2025 13:06:54' prior: 50375739!
      dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| aMorphHandlesIt grabAMorph handledByInner |
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchWith: aMorph ].

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^ #rejected ].

	"Install the prospective handler for the receiver"
	aMorphHandlesIt := self mouseButton3Pressed or: [aMorph handlesMouseDown: self].
	grabAMorph := false.
	"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
	self mouseButton1Pressed ifTrue: [
		aMorph owner ifNotNil: [ :o |
			(o allowsSubmorphDrag and: [ aMorph isSticky not ]) ifTrue: [
				grabAMorph := true ]]].

	"Now give submorphs a chance to handle the event"
	handledByInner := false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner := true ]]].

	(handledByInner or: [ (aMorph rejectsEvent: self) not ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt
			ifTrue: [ ^self sendEventTo: aMorph ]
			ifFalse: [
				(grabAMorph and: [ handledByInner not ]) ifTrue: [
					self hand
						waitForClicksOrDrag: aMorph event: self
						dragSel: ((Preferences at: #clickGrabsMorphs) ifFalse: [#dragEvent:localPosition:])
						clkSel: ((Preferences at: #clickGrabsMorphs) ifTrue: [#dragEvent:localPosition:]).
					"false ifTrue: [ self hand grabMorph: aMorph ]."
					(Preferences at: #clickGrabsMorphs) ifFalse: [
						self shiftPressed
							ifTrue: [ (aMorph is: #SystemWindow) ifTrue: [ aMorph sendToBack ] ]
							ifFalse: [ aMorph activateWindow ] ].
					self wasHandled: true.
					^ self ]]].

	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected! !
!MouseScrollEvent methodsFor: 'dispatching' stamp: 'jmv 9/1/2025 13:07:08' prior: 16918024!
                   dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	"Try to get out quickly"
	| aMorphHandlesIt handledByInner |
	"FIXME - this works in all tested cases but one: when the window directly under the mouse doesn't have keyboard focus (i.e. a Transcript window)"
	(aMorph fullIncludesPixel: position) ifFalse: [ ^ #rejected ].
	"Install the prospective handler for the receiver"
	aMorphHandlesIt := false.
	(aMorph handlesMouseScroll: self) ifTrue: [
		eventHandler := aMorph.
		aMorphHandlesIt := true ].
	"Now give submorphs a chance to handle the event"
	handledByInner := false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner := true ]]].
	(handledByInner or: [
		 (aMorph rejectsEvent: self) not ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt ifTrue: [ ^ self sendEventTo: aMorph ]].
	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7476-EventDispatch-Cleanup-JuanVuletich-2025Sep01-13h03m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7474] on 1 September 2025 at 3:21:08 pm'!
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 9/1/2025 15:20:23' prior: 16804700!
                 removeOlderMethodVersions
	"Remove older versions of entries from the receiver."

	| newChangeList newList found |
	newChangeList := OrderedCollection new.
	newList := OrderedCollection new.
	found := Set new.
	changeList reverseWith: list do: [ :chRec :strNstamp | | str |
		str := strNstamp copyUpTo: $-.
		((str beginsWith: 'method: ') and: [found includes: str]) ifFalse: [
			found add: str.
			newChangeList add: chRec.
			newList add: strNstamp]].
	newChangeList size < changeList size ifTrue: [
		changeList := newChangeList reversed.
		list := newList reversed.
		listIndex := 0.
		self clearSelections ].
	self changed: #list.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7477-ChangeList-RemoveOlderVersions-fix-JuanVuletich-2025Sep01-15h20m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7475] on 1 September 2025 at 3:58:47 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/1/2025 15:33:21' prior: 16911728!
              processMouseDown: aMouseButtonEvent localPosition: localEventPosition
	"System level event handling."
	aMouseButtonEvent wasHandled ifTrue: [ ^self ]. "not interested"
	aMouseButtonEvent hand removePendingBalloonFor: self.
	aMouseButtonEvent wasHandled: true.
	self activateWindow.
	aMouseButtonEvent hand newMouseFocus: self.		"Mouse down sets mouse focus"

	aMouseButtonEvent mouseButton2Pressed ifTrue: [
		self mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition.
		aMouseButtonEvent hand removeHaloFromClick: aMouseButtonEvent on: self.
		^self ].

	aMouseButtonEvent mouseButton3Pressed ifTrue: [
		self mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition.
		^self ].

	self mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
	aMouseButtonEvent hand removeHaloFromClick: aMouseButtonEvent on: self.

	(self handlesMouseStillDown: aMouseButtonEvent) ifTrue:[
		self startStepping: #processMouseStillDown
			in: self mouseStillDownThreshold
			stepTime: self mouseStillDownStepRate ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/1/2025 15:40:18' prior: 16911868!
                  processMouseUp: aMouseButtonEvent localPosition: localEventPosition
	"System level event handling."

	aMouseButtonEvent wasHandled ifTrue: [^self]. "not interested"
	aMouseButtonEvent hand releaseMouseFocus: self.
	aMouseButtonEvent wasHandled: true.
	aMouseButtonEvent mouseButton3Changed ifTrue: [ 
		self mouseButton3Up: aMouseButtonEvent localPosition: localEventPosition.
		^self ].

	aMouseButtonEvent mouseButton2Changed ifTrue: [
		self mouseButton2Up: aMouseButtonEvent localPosition: localEventPosition.
		^self ].
	
	self mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition.
	self stopStepping: #processMouseStillDown! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 9/1/2025 15:35:14' prior: 16899924!
    mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Handle a mouse down event. Menu items get activated when the mouse is over them."

	aMouseButtonEvent shiftPressed ifTrue: [
		super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
		^self ].  "enable label editing" 
	aMouseButtonEvent hand newMouseFocus: owner. "Redirect to menu for valid transitions"
	owner selectItem: self! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 9/1/2025 15:38:24' prior: 16899968!
  mouseButton2Up: aMouseButtonEvent localPosition: localEventPosition
	"Create a copy of me or my submenu."

	aMouseButtonEvent shiftPressed ifTrue: [
		(subMenu
			ifNil: [ self duplicate ]
			ifNotNil: [
				(subMenu duplicate)
					addTitle: contents;
					addStayUpIcons;
					stayUp;
					adjustSubmorphsLayout;
					yourself ])
						openInHand ].
	super mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition.! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 9/1/2025 15:35:53' prior: 16879956!
                   mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| itemMorph |
	aMouseButtonEvent hand newKeyboardFocus: self.
	itemMorph := self itemFromPoint: localEventPosition.
	itemMorph ifNil: [
		super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
		^self ].
	self highlightedMorph: itemMorph.
	(itemMorph inToggleArea: (itemMorph internalize: (scroller internalize: localEventPosition)))
		ifTrue: [
			self toggleExpandedState: itemMorph event: aMouseButtonEvent.
			^self ]. 
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent 
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil
		dragSel: ((self valueOfProperty: #allowsItemDrag) = true ifTrue: [ #dragEvent:localPosition: ])! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 9/1/2025 15:36:09' prior: 16931640!
            mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| row |
	
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self.
		"If we are focusing, deselect, so that later selection doesn't result in deselect."
		scroller noSelection].
	row := self 
		rowAtLocation: localEventPosition
		ifNone:  [
			super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
			^self ].

	"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view.
	Model update will be done on mouse button up, so this feedback will be visible before that."
	scroller highlightedRow: row.

	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil
		dragSel: ((self valueOfProperty: #allowsItemDrag) = true ifTrue: [ #dragEvent:localPosition: ] ifFalse: [ nil ])! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 9/1/2025 15:36:27' prior: 16932334!
                           mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| oldIndex oldVal row w |
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self ].

	row := self rowAtLocation: localEventPosition.

	row = 0 ifTrue: [
		super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
		^self ].

	"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update the view."
	scroller highlightedRow: row.

	w := self owningWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff := (self listSelectionAt: row) not.
		dragStartRow := row.
		oldIndex := self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal := self listSelectionAt: oldIndex].

		"Different from PluggableListMorph. There, we highlight on mouse down, and act on mouse up.
		Here, we act on mouse down, because we support dragging of selection, so mouse up will
		only happen after user is finished dragging. In order to get the highlight visible for the user,
		update the model on next world cycle."
		UISupervisor whenUIinSafeState: [
			"Set or clear new primary selection (listIndex)"
			dragOnOrOff == true
				ifTrue: [self setSelectionIndex: row]
				ifFalse: [self setSelectionIndex: 0].
			"Need to restore the old one, due to how model works, and set new one."
			oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
			self listSelectionAt: row put: dragOnOrOff ].
	].
	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: nil
		tripleClkSel: nil
		dragSel: (
			aMouseButtonEvent shiftPressed ifFalse: [
				(self valueOfProperty: #allowsItemDrag) = true
						ifTrue: [ #dragEvent:localPosition: ] ifFalse: [ nil ] ])! !
!AutoCompleterMorph methodsFor: 'events' stamp: 'jmv 9/1/2025 15:39:43' prior: 16785333!
                    mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition

	(self includesPixel: aMouseButtonEvent eventPosition)
		ifTrue: [
			((self upButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ self stillActive; goUp. ^self ].
			((self downButtonPosition extent: ScrollBar scrollbarThickness) containsPoint: localEventPosition)
				ifTrue: [ self stillActive; goDown. ^self ].
			self selected: (localEventPosition y // self itemHeight) +  self firstVisible.
			completer insertSelected ]
		ifFalse: [ self delete. completer menuClosed ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7478-processMouseButton-cleanup-JuanVuletich-2025Sep01-15h52m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7476] on 1 September 2025 at 4:21:55 pm'!
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 9/1/2025 16:01:03' prior: 16917908!
                        processMouseOver: aMouseEvent
	"Re-establish the z-order for all morphs wrt the given event"

	| hand focus evt |
	hand := aMouseEvent hand.
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	"Now go looking for eventual mouse overs"
	hand startEventDispatch: aMouseEvent asMouseOver.
	"Get out early if there's no change"
	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."
		(leftMorphs isEmpty and: [enteredMorphs position = 0])])
		ifTrue: [
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self].
	focus := hand mouseFocus.
	"Send #mouseLeave as appropriate"
	evt := aMouseEvent asMouseLeave.
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					evt sendEventTo: m ]
				ifFalse: [overMorphs nextPut: m]]].
	"Send #mouseEnter as appropriate"
	evt := aMouseEvent asMouseEnter.
	enteredMorphs ifNil: [
		"inform: was called in handleEvent:"
		leftMorphs := enteredMorphs := overMorphs := nil.
		^self].
	enteredMorphs := enteredMorphs contents.
	enteredMorphs reverseDo: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [
					evt sendEventTo: m ]]].
	"And remember the over list"
	overMorphs ifNil: [
			"inform: was called in handleEvent:"
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self].
	mouseOverMorphs := overMorphs contents.
	leftMorphs := enteredMorphs := overMorphs := nil! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/1/2025 16:04:09' prior: 16878448!
                       startMouseDispatch: aMouseEvent

	aMouseEvent isMouseOver ifTrue: [
		self mouseFocus
			ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
			ifNil: [ owner dispatchEvent: aMouseEvent ].
		^self].

	"any mouse event but mouseOver"
	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			self mouseOverHandler processMouseOver: lastMouseEvent.
			^self ]].

	aMouseEvent isMove
		ifTrue: [
			self morphPosition: aMouseEvent eventPosition.
			self mouseFocus
				ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
				ifNil: [ owner dispatchEvent: aMouseEvent ]
		] ifFalse: [
		aMouseEvent isMouseScroll ifTrue: [
			owner dispatchEvent: aMouseEvent
		] ifFalse: [
			"Issue a synthetic move event if we're not at the position of the event"
			aMouseEvent eventPosition = self morphPosition ifFalse: [
				"Issue a mouse move event to make the receiver appear at the given position"
				self startMouseDispatch: (MouseMoveEvent new
					setType: #mouseMove
					position: aMouseEvent eventPosition
					buttons: aMouseEvent buttons
					hand: self
					stamp: aMouseEvent timeStamp) ].
			"Drop submorphs on button events"
			self hasSubmorphs
				ifTrue: [
					"Not if we are grabbing them"
					mouseClickState ifNil: [
						"Want to drop on mouseUp, NOT mouseDown"
						aMouseEvent isMouseUp ifTrue: [
							self dropMorphs: aMouseEvent ]
					]
				] ifFalse: [
					self mouseFocus
						ifNotNil: [ mouseFocus handleFocusEvent: aMouseEvent ]
						ifNil: [ owner dispatchEvent: aMouseEvent ]]]].
		self mouseOverHandler processMouseOver: lastMouseEvent! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7479-processMouseOver-cleanup-JuanVuletich-2025Sep01-16h17m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7477] on 2 September 2025 at 8:40:59 am'!
!Character class methodsFor: 'accessing untypeable characters' stamp: 'jmv 9/2/2025 08:18:29'!
  end

	^ `Character codePoint: 4`! !
!InputSensor methodsFor: 'keyboard' stamp: 'jmv 9/2/2025 08:19:42' prior: 16887867!
        kbdTest
	"
	Sensor kbdTest
	"
	"This test routine will print the unmodified character, its keycode,
	and the OR of all its modifier bits, until the character x is typed

Also useful:
	Sensor test
	"
	| char |
	char := nil.
	[ char == $x ] whileFalse: [
		[ self keyboardPressed ] whileFalse.
		char := self keyboard.
		Display fill: `5@5 extent: 600@50` fillColor: `Color white`.
		(String streamContents: [ :s |
			s
				nextPut: $-;
				nextPut: char;
				nextPut: $-;
				space;
				nextPutAll: char printString;
				space;
				nextPut: $(;
				print: char codePoint;
				nextPut: $);
				space.
			self isMouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].
			self isMouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].
			self isMouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].
			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].
			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].
			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].
			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ].
			Time now printOn: s
			])
		displayAt: 10 @ 10 ].! !
!Character class methodsFor: 'private' stamp: 'jmv 9/2/2025 08:18:34' prior: 16812005!
         constantNames
	^ #(backQuote backspace cr delete doubleQuote escape home end insert lf newPage noBreakSpace null pageUp singleQuote smalltalkDownArrow smalltalkLeftArrow smalltalkRightArrow smalltalkUpArrow space tab zeroWidthSpace)! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7480-Character-tweaks-JuanVuletich-2025Sep02-08h40m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7478] on 2 September 2025 at 12:37:34 pm'!
!VectorCanvas methodsFor: 'morphic' stamp: 'jmv 9/2/2025 12:36:44' prior: 17007382!
                      drawCurrentAndSubmorphs

	| currentNeedsDrawing submorphsNeedDrawing current |
	currentMorph visible ifFalse: [ ^self ].
	currentNeedsDrawing := true.
	submorphsNeedDrawing := currentMorph hasSubmorphs.
	clipRect notNil ifTrue: [
		self boundingRectOfCurrentIfTrivial ifNotNil: [ :mb |
			(mb intersects: clipRect) ifFalse: [
				currentNeedsDrawing := false.
				(currentMorph submorphsMightProtrude and: [currentMorph clipsSubmorphs not]) ifFalse: [
					submorphsNeedDrawing := false ]]]].

	currentNeedsDrawing ifTrue: [
		currentMorph drawOn: self.
		self displayBoundsSetOnCurrentMorph.
		self contourSetOnCurrentMorph.
		self contourUpdateOnAllOwners ].

	"Hold currentMorph in a temp in case of breakage in recursive calls on submorphs."
	current := currentMorph.
	submorphsNeedDrawing ifTrue: [
		"Display submorphs back to front"
		"coordinate system stack already set up for aMorph
		('ivars transformations' and 'currentTransformation')"
		self clippingByCurrentMorphDo: [
			currentMorph submorphsReverseDo: [ :m | self fullDraw: m ]]].

	currentNeedsDrawing ifTrue: [
		(current postDrawOn: self) ifTrue: [
			self displayBoundsUpdateOnCurrentMorph.
			self contourUpdateOnCurrentMorph.
			self contourUpdateOnAllOwners ].
		current isHighlighted ifTrue: [
			self drawHighlight: current ]].! !
!BitBltCanvas methodsFor: 'morphic' stamp: 'jmv 9/2/2025 12:36:50' prior: 16792183!
               drawCurrentAndSubmorphs

	| currentNeedsDrawing submorphsNeedDrawing current |
	currentMorph visible ifFalse: [ ^self ].
	currentNeedsDrawing := true.
	submorphsNeedDrawing := currentMorph hasSubmorphs.
	clipRect notNil ifTrue: [
		self boundingRectOfCurrentIfTrivial ifNotNil: [ :mb |
			(mb intersects: clipRect) ifFalse: [
				currentNeedsDrawing := false.
				(currentMorph submorphsMightProtrude and: [currentMorph clipsSubmorphs not]) ifFalse: [
					submorphsNeedDrawing := false ]]]].

	currentNeedsDrawing ifTrue: [
		currentMorph drawOn: self.
		self displayBoundsSetOnCurrentMorph.
		self contourClearOnCurrentMorph ].

	"Hold currentMorph in a temp in case of breakage in recursive calls on submorphs."
	current := currentMorph.
	submorphsNeedDrawing ifTrue: [
		"Display submorphs back to front"
		"coordinate system stack already set up for aMorph
		('ivars transformations' and 'currentTransformation')"
		self clippingByCurrentMorphDo: [
			currentMorph submorphsReverseDo: [ :m | self fullDraw: m ]]].

	currentNeedsDrawing ifTrue: [
		(current postDrawOn: self) ifTrue: [
			self displayBoundsUpdateOnCurrentMorph ].
		current isHighlighted ifTrue: [
			self drawHighlight: current ]].! !
!HybridCanvas methodsFor: 'morphic' stamp: 'jmv 9/2/2025 12:36:56' prior: 16881423!
                     drawCurrentAndSubmorphs
	"If we get here, we are drawing with BitBlt, not VectorCanvas.
	Clear morphIds of pixels drawn for currentMorph"

	| currentNeedsDrawing submorphsNeedDrawing current |
	currentMorph visible ifFalse: [ ^self ].
	currentNeedsDrawing := true.
	submorphsNeedDrawing := currentMorph hasSubmorphs.
	clipRect notNil ifTrue: [
		self boundingRectOfCurrentIfTrivial ifNotNil: [ :mb |
			(mb intersects: clipRect) ifFalse: [
				currentNeedsDrawing := false.
				(currentMorph submorphsMightProtrude and: [currentMorph clipsSubmorphs not]) ifFalse: [
					submorphsNeedDrawing := false ]]]].

	currentNeedsDrawing ifTrue: [
		currentMorph drawOn: self.
		self onMorphIdsDo: [
			currentMorph drawOn: self ].
		self displayBoundsSetOnCurrentMorph.
		self contourClearOnCurrentMorph ].

	"Hold currentMorph in a temp in case of breakage in recursive calls on submorphs."
	current := currentMorph.
	submorphsNeedDrawing ifTrue: [
		"Display submorphs back to front"
		"coordinate system stack already set up for aMorph
		('ivars transformations' and 'currentTransformation')"
		self clippingByCurrentMorphDo: [
			currentMorph submorphsReverseDo: [ :m | self fullDraw: m ]]].

	currentNeedsDrawing ifTrue: [
		(current postDrawOn: self) ifTrue: [
			self onMorphIdsDo: [
				current postDrawOn: self ].
			self displayBoundsUpdateOnCurrentMorph ].
		current isHighlighted ifTrue: [
			self drawHighlight: current ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7481-MorphicCanvas-tweak-JuanVuletich-2025Sep02-12h31m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7478] on 2 September 2025 at 12:41:07 pm'!
!Morph methodsFor: 'geometry services' stamp: 'jmv 9/2/2025 12:38:32' prior: 16912512!
    fullIncludesPixel: worldPoint
	"Answer true if worldPoint is in some submorph, even if not inside our shape.
	See comment at #includesPixel: for important notes on behavior."

	(self includesPixel: worldPoint) ifTrue: [ ^ true ].
	(self submorphsMightProtrude and: [self clipsSubmorphs not]) ifTrue: [
		self submorphsDo: [ :m |
			(m fullIncludesPixel: worldPoint) ifTrue: [ ^ true ]]].
	^ false.! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/2/2025 12:37:42'!
      allMorphsFrontToBackDo: aBlock
	"Evaluate the given block for all morphs in this composite morph (including the receiver).
	Do it front to back. Any morph partially covering another is drawn first."

	self allSubmorphsFrontToBackDo: aBlock.
	aBlock value: self.! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/2/2025 12:37:40'!
              allSubmorphsFrontToBackDo: aBlock
	"Evaluate the given block for all morphs in this composite morph (not including the receiver).
	Do it front to back. Any morph partially covering another is drawn first."

	submorphs do: [ :m |
		m allSubmorphsFrontToBackDo: aBlock.
		aBlock value: m ].! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/2/2025 12:40:43'!
                   morphVisibleAt: worldPoint
	"Find, if any a (possibly nested) submorph that #includesPixel: worldPoint,
	and is not covered by any other morph. Answer could also be self.
	Answer nil if neither us nor any submorph #includesPixel: worldPoint."

	| doWeIncludePixel |
	doWeIncludePixel := self includesPixel: worldPoint.
	(doWeIncludePixel or: [ self submorphsMightProtrude and: [self clipsSubmorphs not]]) ifTrue: [
		submorphs do: [ :m |
			(m morphVisibleAt: worldPoint) ifNotNil: [ :sm | ^sm ]]].
	doWeIncludePixel ifTrue: [ ^self ].
	^nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7482-morphVisibleAt-allMorphFrontToBackDo-JuanVuletich-2025Sep02-12h37m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7478] on 2 September 2025 at 12:45:45 pm'!

MouseEvent subclass: #MouseScrollEvent
	instanceVariableNames: 'direction eventHandler '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #MouseScrollEvent category: #'Morphic-Events' stamp: 'Install-7483-MouseScrollEvent-cleanup-JuanVuletich-2025Sep02-12h41m-jmv.001.cs.st 9/5/2025 16:18:27'!
MouseEvent subclass: #MouseScrollEvent
	instanceVariableNames: 'direction eventHandler'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!MouseScrollEvent methodsFor: 'dispatching' stamp: 'jmv 9/2/2025 12:44:22' prior: 50375984!
              dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	"Try to get out quickly"
	| aMorphHandlesIt handledByInner |
	"FIXME - this works in all tested cases but one: when the window directly under the mouse doesn't have keyboard focus (i.e. a Transcript window)"
	(aMorph fullIncludesPixel: position) ifFalse: [ ^ #rejected ].
	"Install the prospective handler for the receiver"
	aMorphHandlesIt := false.
	(aMorph handlesMouseScroll: self) ifTrue: [
		aMorphHandlesIt := true ].
	"Now give submorphs a chance to handle the event"
	handledByInner := false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner := true ]]].
	(handledByInner or: [
		 (aMorph rejectsEvent: self) not ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt ifTrue: [ ^ self sendEventTo: aMorph ]].
	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected.! !

MouseEvent subclass: #MouseScrollEvent
	instanceVariableNames: 'direction'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #MouseScrollEvent category: #'Morphic-Events' stamp: 'Install-7483-MouseScrollEvent-cleanup-JuanVuletich-2025Sep02-12h41m-jmv.001.cs.st 9/5/2025 16:18:27'!
MouseEvent subclass: #MouseScrollEvent
	instanceVariableNames: 'direction'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7483-MouseScrollEvent-cleanup-JuanVuletich-2025Sep02-12h41m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7481] on 2 September 2025 at 2:13:47 pm'!
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 9/2/2025 13:00:49'!
                           dispatchIn: aWorldMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the event position.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."

	self subclassResponsibility! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 9/2/2025 14:12:23'!
          dispatchIn: aWorldMorph
	"Drop is done on the innermost target that accepts it.
	If #rejectsEvent:, any party doesn't want the drop,or #wasHandled not by any reason, try with the owner."

	| handlerMorph dropped |
	handlerMorph := aWorldMorph morphVisibleAt: position.
	[ handlerMorph notNil and: [wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			handlerMorph allowsMorphDrop ifTrue: [
				"Do a symmetric check if both morphs like each other"
				dropped := self contents.
				((handlerMorph wantsDroppedMorph: dropped event: self)		"I want her"
					and: [dropped wantsToBeDroppedInto: handlerMorph])		"she wants me"
						ifTrue: [ self sendEventTo: handlerMorph ]].
			wasHandled
				ifFalse: [ handlerMorph invalidDrop: self ]
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!DropFilesEvent methodsFor: 'dispatching' stamp: 'jmv 9/2/2025 14:12:30'!
                dispatchIn: aWorldMorph
	"Drop is done on the innermost target that accepts it."

	| handlerMorph |
	handlerMorph := aWorldMorph morphVisibleAt: position.
	[ handlerMorph notNil and: [wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			handlerMorph allowsFilesDrop ifTrue: [
				self sendEventTo: handlerMorph ].
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!UserInputEvent methodsFor: 'dispatching' stamp: 'jmv 9/2/2025 14:12:37'!
                      dispatchIn: aWorldMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the event position.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."

	| handlerMorph |
	handlerMorph := aWorldMorph morphVisibleAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			self sendEventTo: handlerMorph.
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 9/2/2025 14:12:42'!
                             dispatchIn: aWorldMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the event position.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."
	
	| handlerMorph grabTheMorph |
	
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchIn: aWorldMorph ].

	handlerMorph := aWorldMorph morphVisibleAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			"aMorph is in the top-most unlocked, visible morph in the chain."
			(self mouseButton3Pressed or: [handlerMorph handlesMouseDown: self])
				ifTrue: [ self sendEventTo: handlerMorph ]
				ifFalse: [
					grabTheMorph := false.
					"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
					self mouseButton1Pressed ifTrue: [
						handlerMorph owner ifNotNil: [ :o |
							(o allowsSubmorphDrag and: [ handlerMorph isSticky not ]) ifTrue: [
								grabTheMorph := true ]]].
					grabTheMorph ifTrue: [
						self hand
							waitForClicksOrDrag: handlerMorph event: self
							dragSel: ((Preferences at: #clickGrabsMorphs) ifFalse: [#dragEvent:localPosition:])
							clkSel: ((Preferences at: #clickGrabsMorphs) ifTrue: [#dragEvent:localPosition:]).
						"false ifTrue: [ self hand grabMorph: aMorph ]."
						(Preferences at: #clickGrabsMorphs) ifFalse: [
							self shiftPressed
								ifTrue: [ (handlerMorph is: #SystemWindow) ifTrue: [ handlerMorph sendToBack ] ]
								ifFalse: [ handlerMorph activateWindow ] ].
						self wasHandled: true ]]
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!MouseScrollEvent methodsFor: 'dispatching' stamp: 'jmv 9/2/2025 14:12:46'!
                      dispatchIn: aWorldMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the event position.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."

	| handlerMorph |
	handlerMorph := aWorldMorph morphVisibleAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			(handlerMorph handlesMouseScroll: self) ifTrue: [
				self sendEventTo: handlerMorph ].
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 9/2/2025 11:15:43'!
          dispatchIn: aWorldMorph
	"Host window events do not have a position and are only dispatched to the World"

	self sendEventTo: aWorldMorph.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 11:28:15' prior: 16911595!
                           dispatchEvent: aMorphicEvent
	"This is the central entry for dispatching events in morphic. Given some event, find the right receiver and let him handle it."

	(self rejectsEventFully: aMorphicEvent)
		ifFalse: [ aMorphicEvent dispatchIn: self ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7484-NewMorphicEventDispatch-JuanVuletich-2025Sep02-12h55m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7478] on 2 September 2025 at 11:29:30 am'!

WindowEvent removeSelector: #dispatchWith:!

!methodRemoval: WindowEvent #dispatchWith: stamp: 'Install-7485-OldMorphicEventDispatch-removal-JuanVuletich-2025Sep02-11h28m-jmv.001.cs.st 9/5/2025 16:18:27'!
dispatchWith: aMorph
	"Host window events do not have a position and are only dispatched to the World"

	aMorph isWorldMorph ifFalse: [ ^#rejected ].
	self wasHandled ifTrue: [ ^self ].
	^ self sendEventTo: aMorph!

MouseScrollEvent removeSelector: #dispatchWith:!

!methodRemoval: MouseScrollEvent #dispatchWith: stamp: 'Install-7485-OldMorphicEventDispatch-removal-JuanVuletich-2025Sep02-11h28m-jmv.001.cs.st 9/5/2025 16:18:27'!
dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	"Try to get out quickly"
	| aMorphHandlesIt handledByInner |
	"FIXME - this works in all tested cases but one: when the window directly under the mouse doesn't have keyboard focus (i.e. a Transcript window)"
	(aMorph fullIncludesPixel: position) ifFalse: [ ^ #rejected ].
	"Install the prospective handler for the receiver"
	aMorphHandlesIt := false.
	(aMorph handlesMouseScroll: self) ifTrue: [
		aMorphHandlesIt := true ].
	"Now give submorphs a chance to handle the event"
	handledByInner := false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner := true ]]].
	(handledByInner or: [
		 (aMorph rejectsEvent: self) not ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt ifTrue: [ ^ self sendEventTo: aMorph ]].
	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected.!

MouseButtonEvent removeSelector: #dispatchWith:!

!methodRemoval: MouseButtonEvent #dispatchWith: stamp: 'Install-7485-OldMorphicEventDispatch-removal-JuanVuletich-2025Sep02-11h28m-jmv.001.cs.st 9/5/2025 16:18:27'!
dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| aMorphHandlesIt grabAMorph handledByInner |
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchWith: aMorph ].

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^ #rejected ].

	"Install the prospective handler for the receiver"
	aMorphHandlesIt := self mouseButton3Pressed or: [aMorph handlesMouseDown: self].
	grabAMorph := false.
	"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
	self mouseButton1Pressed ifTrue: [
		aMorph owner ifNotNil: [ :o |
			(o allowsSubmorphDrag and: [ aMorph isSticky not ]) ifTrue: [
				grabAMorph := true ]]].

	"Now give submorphs a chance to handle the event"
	handledByInner := false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner := true ]]].

	(handledByInner or: [ (aMorph rejectsEvent: self) not ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt
			ifTrue: [ ^self sendEventTo: aMorph ]
			ifFalse: [
				(grabAMorph and: [ handledByInner not ]) ifTrue: [
					self hand
						waitForClicksOrDrag: aMorph event: self
						dragSel: ((Preferences at: #clickGrabsMorphs) ifFalse: [#dragEvent:localPosition:])
						clkSel: ((Preferences at: #clickGrabsMorphs) ifTrue: [#dragEvent:localPosition:]).
					"false ifTrue: [ self hand grabMorph: aMorph ]."
					(Preferences at: #clickGrabsMorphs) ifFalse: [
						self shiftPressed
							ifTrue: [ (aMorph is: #SystemWindow) ifTrue: [ aMorph sendToBack ] ]
							ifFalse: [ aMorph activateWindow ] ].
					self wasHandled: true.
					^ self ]]].

	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected!

DropFilesEvent removeSelector: #dispatchWith:!

!methodRemoval: DropFilesEvent #dispatchWith: stamp: 'Install-7485-OldMorphicEventDispatch-removal-JuanVuletich-2025Sep02-11h28m-jmv.001.cs.st 9/5/2025 16:18:27'!
dispatchWith: aMorph
	"Drop is done on the innermost target that accepts it."

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position) ifFalse: [ ^#rejected ].

	"Go looking if any of our submorphs wants it"
	aMorph submorphsDo: [ :eachChild |
		(eachChild dispatchEvent: self) == #rejected ifFalse: [ ^self ]].

	(aMorph allowsFilesDrop and: [ (aMorph rejectsEvent: self) not ])
		ifTrue: [^ self sendEventTo: aMorph ].
	
	^#rejected!

DropEvent removeSelector: #dispatchWith:!

!methodRemoval: DropEvent #dispatchWith: stamp: 'Install-7485-OldMorphicEventDispatch-removal-JuanVuletich-2025Sep02-11h28m-jmv.001.cs.st 9/5/2025 16:18:27'!
dispatchWith: aMorph
	"Drop is done on the innermost target that accepts it."
	| dropped |

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^#rejected ].

	"Go looking if any of our submorphs wants it"
	aMorph submorphsDo: [ :eachChild |
		(eachChild dispatchEvent: self) == #rejected ifFalse: [
			^self ]].

	(aMorph rejectsEvent: self) ifFalse: [
		aMorph allowsMorphDrop ifTrue: [
			"Do a symmetric check if both morphs like each other"
			dropped := self contents.
			((aMorph wantsDroppedMorph: dropped event: self)	"I want her"
				and: [dropped wantsToBeDroppedInto: aMorph])		"she wants me"
					ifTrue: [ ^ self sendEventTo: aMorph ]].
		aMorph invalidDrop: self.
		wasHandled ifTrue: [
			self contents justDroppedInto: aMorph event: self.
			^self].
	].
	^#rejected!

MorphicEvent removeSelector: #dispatchWith:!

!methodRemoval: MorphicEvent #dispatchWith: stamp: 'Install-7485-OldMorphicEventDispatch-removal-JuanVuletich-2025Sep02-11h28m-jmv.001.cs.st 9/5/2025 16:18:27'!
dispatchWith: aMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."
	| handledByInner |

	"Try to get out quickly"
	(aMorph fullIncludesPixel: self eventPosition)
		ifFalse: [ ^#rejected ].

	"Now give submorphs a chance to handle the event"
	handledByInner := false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner := true ]]].

	"Check for being inside the receiver"
	(handledByInner or: [ (aMorph rejectsEvent: self) not ])
		ifTrue: [ ^ self sendEventTo: aMorph ].

	^ #rejected!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7485-OldMorphicEventDispatch-removal-JuanVuletich-2025Sep02-11h28m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7483] on 2 September 2025 at 2:19:34 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 08:56:28' prior: 16911916!
    rejectsEventFully: aMorphicEvent
	"Return true to reject the given event, for the receiver and all submorphs."

	^ self isLocked or: [ self visible not ]! !
!Morph methodsFor: 'geometry services' stamp: 'jmv 9/2/2025 09:13:45' prior: 16912422!
            coversAnyPixelCloserThan: maxDistance to: worldPoint
	"Answer true if our closest point to worldPoint is less than aNumber pixels away.
	In target surface (i.e. Display) coordinates.
	See #bitMask.
	Remember to do
	self removeProperty: #bitMask.
	when appropriate!! (i.e. when we change in such a way to make the bitMask invalid).

	Note: Requires VectorGraphics (#requiresVectorCanvas == true). Meant to be used only when really needed.
	Note: Prefer #isCloserThan:toPixel:, that doesn't use #bitMask, and doesn't require maintenance."

	| center coversIt maxDistanceSquared |
	self visible ifFalse: [
		^false ].
	privateDisplayBounds ifNil: [
		^false ].
	center := privateDisplayBounds center.
	"Quick checks: If not even within aNumber distance to display bounds, fail"
	(center y - worldPoint y) abs < (privateDisplayBounds height  // 2 + maxDistance) ifFalse: [
		^false ].
	(center x - worldPoint x) abs < (privateDisplayBounds width // 2 + maxDistance) ifFalse: [
		^false ].
	"Precise check with bitMask. If unavailable, just answer false. See #coversPixel:"
	coversIt := (self coversPixel: worldPoint) ifNil: [ ^false ].
	coversIt ifTrue: [ ^true ].
	maxDistanceSquared := maxDistance squared.
	maxDistance negated to: maxDistance do: [ :dy |
		maxDistance negated to: maxDistance do: [ :dx |
			dx squared + dy squared <= maxDistanceSquared ifTrue: [
				(self coversPixel: worldPoint + (dx@dy)) ifTrue: [ ^true ]]]].
	^false.! !
!Morph methodsFor: 'geometry services' stamp: 'jmv 9/2/2025 09:14:31' prior: 16912656!
       ownsPixel: worldPoint
	"Answer true if we own the pixel, i.e. we are the last morph drawn at worldPoint.
	Requires VectorGraphics (#requiresVectorCanvas == true), as we need VectorCanvas' morphIdAt: service.

	Valid if running on VectorCanvas.

	In case of running on HybridCanvas, this method is only valid for morphs that
	are drawn by VectorCanvas (i.e. they answer true to #requiresVectorCanvas).

	See #coversPixel:
	See #includesPixel:"

	self mainCanvas ifNotNil: [ :mainCanvas |
		mainCanvas canDoVectorGraphics ifTrue: [
			^ (mainCanvas morphIdAt: worldPoint) = self morphId ]].
	^ false.! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/2/2025 09:29:39' prior: 16913789!
             allSubmorphsDo: aBlock
	"Evaluate the given block for all morphs in this composite morph (not including the receiver)."

	submorphs do: [ :m |
		aBlock value: m.
		m allSubmorphsDo: aBlock].! !
!HaloMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 08:56:33' prior: 16877162!
   rejectsEventFully: anEvent
	"Return true to reject the given event, for the receiver and all submorphs."

	(super rejectsEventFully: anEvent) ifTrue: [^true].
	anEvent isDropEvent ifTrue: [^true]. "never attempt to drop on halos"
	^false! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7486-CommentTweaks-JuanVuletich-2025Sep02-14h13m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7483] on 2 September 2025 at 2:26:21 pm'!
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/2/2025 14:25:49' prior: 16913781!
                allMorphsDo: aBlock
	"Evaluate the given block for all morphs in this composite morph (including the receiver).
	Note: Redefined in WorldMorph to also include the Hand and any carried morphs."

	aBlock value: self.
	self allSubmorphsDo: aBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7487-CommentTweak-JuanVuletich-2025Sep02-14h19m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7485] on 2 September 2025 at 4:22:56 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 15:38:29'!
                             handleKeyboardFocusEvent: aMorphicEvent
	"Handle the given event. This message is sent if the receiver currently has the focus and is therefore receiving events directly from some hand."

	aMorphicEvent sendEventTo: self.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 15:38:33'!
                        handleMouseFocusEvent: aMorphicEvent
	"Handle the given event. This message is sent if the receiver currently has the focus and is therefore receiving events directly from some hand."

	aMorphicEvent sendEventTo: self.! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 16:19:20'!
                       handleKeyboardFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."

	self dispatchEvent: aMorphicEvent.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sendEventTo: self ].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sendEventTo: self ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [^self]].! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 16:19:09'!
                               handleMouseFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."

	self dispatchEvent: aMorphicEvent.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sendEventTo: self ].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sendEventTo: self ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [^self]].! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 16:20:44' prior: 16878438!
                  startKeyboardDispatch: aKeyboardEvent

	| focusedElement |
	
	focusedElement := self keyboardFocus ifNil: [ self world ].
	focusedElement handleKeyboardFocusEvent: aKeyboardEvent.
	
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 16:20:35' prior: 50376396!
                    startMouseDispatch: aMouseEvent

	aMouseEvent isMouseOver ifTrue: [
		self mouseFocus
			ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
			ifNil: [ owner dispatchEvent: aMouseEvent ].
		^self].

	"any mouse event but mouseOver"
	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			self mouseOverHandler processMouseOver: lastMouseEvent.
			^self ]].

	aMouseEvent isMove
		ifTrue: [
			self morphPosition: aMouseEvent eventPosition.
			self mouseFocus
				ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
				ifNil: [ owner dispatchEvent: aMouseEvent ]
		] ifFalse: [
		aMouseEvent isMouseScroll ifTrue: [
			owner dispatchEvent: aMouseEvent
		] ifFalse: [
			"Issue a synthetic move event if we're not at the position of the event"
			aMouseEvent eventPosition = self morphPosition ifFalse: [
				"Issue a mouse move event to make the receiver appear at the given position"
				self startMouseDispatch: (MouseMoveEvent new
					setType: #mouseMove
					position: aMouseEvent eventPosition
					buttons: aMouseEvent buttons
					hand: self
					stamp: aMouseEvent timeStamp) ].
			"Drop submorphs on button events"
			self hasSubmorphs
				ifTrue: [
					"Not if we are grabbing them"
					mouseClickState ifNil: [
						"Want to drop on mouseUp, NOT mouseDown"
						aMouseEvent isMouseUp ifTrue: [
							self dropMorphs: aMouseEvent ]
					]
				] ifFalse: [
					self mouseFocus
						ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
						ifNil: [ owner dispatchEvent: aMouseEvent ]]]].
		self mouseOverHandler processMouseOver: lastMouseEvent! !

MenuMorph removeSelector: #handleFocusEvent:!

!methodRemoval: MenuMorph #handleFocusEvent: stamp: 'Install-7488-MorphicEventDispatch-refactor-JuanVuletich-2025Sep02-16h19m-jmv.001.cs.st 9/5/2025 16:18:27'!
handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."

	self dispatchEvent: aMorphicEvent.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sendEventTo: self ].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sendEventTo: self ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [^self]].!

Morph removeSelector: #handleFocusEvent:!

!methodRemoval: Morph #handleFocusEvent: stamp: 'Install-7488-MorphicEventDispatch-refactor-JuanVuletich-2025Sep02-16h19m-jmv.001.cs.st 9/5/2025 16:18:27'!
handleFocusEvent: aMorphicEvent
	"Handle the given event. This message is sent if the receiver currently has the focus and is therefore receiving events directly from some hand."

	^aMorphicEvent sendEventTo: self!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7488-MorphicEventDispatch-refactor-JuanVuletich-2025Sep02-16h19m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7486] on 2 September 2025 at 4:50:11 pm'!
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 9/2/2025 16:26:30' prior: 50376337!
                   processMouseOver: aMouseEvent
	"Re-establish the z-order for all morphs wrt the given event"

	| hand focus evt |
	hand := aMouseEvent hand.
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	"Now go looking for eventual mouse overs"
	hand startEventDispatch: aMouseEvent asMouseOver.
	"Get out early if there's no change"
	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."
		(leftMorphs isEmpty and: [enteredMorphs position = 0])])
		ifTrue: [
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self].
	focus := hand mouseFocus.
	"Send #mouseLeave as appropriate"
	evt := aMouseEvent asMouseLeave.
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [evt sendEventTo: m ]
				ifFalse: [overMorphs nextPut: m]]].
	"Send #mouseEnter as appropriate"
	evt := aMouseEvent asMouseEnter.
	enteredMorphs ifNil: [
		"inform: was called in handleEvent:"
		leftMorphs := enteredMorphs := overMorphs := nil.
		^self].
	enteredMorphs := enteredMorphs contents.
	enteredMorphs reverseDo: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [evt sendEventTo: m ]]].
	"And remember the over list"
	overMorphs ifNil: [
			"inform: was called in handleEvent:"
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self].
	mouseOverMorphs := overMorphs contents.
	leftMorphs := enteredMorphs := overMorphs := nil! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 16:48:34' prior: 50377410!
   handleKeyboardFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."

	aMorphicEvent dispatchIn: self.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sendEventTo: self ].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sendEventTo: self ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [^self]].! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 16:48:43' prior: 50377450!
                  handleMouseFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."

	aMorphicEvent dispatchIn: self.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sendEventTo: self ].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sendEventTo: self ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [^self]].! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 15:00:45' prior: 16878418!
                     startDropEventDispatch: aDropEvent

	aDropEvent dispatchIn: owner..
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 15:00:54' prior: 16878425!
      startDropFilesEventDispatch: aDropFilesEvent

	aDropFilesEvent dispatchIn: owner.
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 16:32:00' prior: 50377501!
                        startMouseDispatch: aMouseEvent

	aMouseEvent isMouseOver ifTrue: [
		self mouseFocus
			ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
			ifNil: [ aMouseEvent dispatchIn: owner ].
		^self].

	"any mouse event but mouseOver"
	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			self mouseOverHandler processMouseOver: lastMouseEvent.
			^self ]].

	aMouseEvent isMove
		ifTrue: [
			self morphPosition: aMouseEvent eventPosition.
			self mouseFocus
				ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
				ifNil: [ aMouseEvent dispatchIn: owner ]
		] ifFalse: [
		aMouseEvent isMouseScroll ifTrue: [
			aMouseEvent dispatchIn: owner
		] ifFalse: [
			"Issue a synthetic move event if we're not at the position of the event"
			aMouseEvent eventPosition = self morphPosition ifFalse: [
				"Issue a mouse move event to make the receiver appear at the given position"
				self startMouseDispatch: (MouseMoveEvent new
					setType: #mouseMove
					position: aMouseEvent eventPosition
					buttons: aMouseEvent buttons
					hand: self
					stamp: aMouseEvent timeStamp) ].
			"Drop submorphs on button events"
			self hasSubmorphs
				ifTrue: [
					"Not if we are grabbing them"
					mouseClickState ifNil: [
						"Want to drop on mouseUp, NOT mouseDown"
						aMouseEvent isMouseUp ifTrue: [
							self dropMorphs: aMouseEvent ]
					]
				] ifFalse: [
					self mouseFocus
						ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
						ifNil: [ aMouseEvent dispatchIn: owner ]]]].
		self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 15:01:16' prior: 16878508!
                    startWindowEventDispatch: aWindowEvent

	aWindowEvent dispatchIn: owner.
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 9/2/2025 15:00:34' prior: 16878767!
 dropMorph: aMorph event: aMouseEvent
	"Drop the given morph which was carried by the hand"
	| morphData dropEvent |
	morphData := self grabMorphDataFor: aMorph.
	dropEvent := DropEvent new 
			setPosition: self morphPosition 
			contents: aMorph 
			hand: self
			formerOwner: (morphData at: 1)
			formerPosition: (morphData at: 2).
	dropEvent dispatchIn: owner.
	dropEvent wasHandled ifFalse: [ aMorph rejectDropMorphEvent: dropEvent ].
	self forgetGrabMorphDataFor: aMorph.
	self mouseOverHandler processMouseOver: aMouseEvent! !

HaloMorph removeSelector: #rejectsEventFully:!

!methodRemoval: HaloMorph #rejectsEventFully: stamp: 'Install-7489-refactor-JuanVuletich-2025Sep02-16h46m-jmv.001.cs.st 9/5/2025 16:18:27'!
rejectsEventFully: anEvent
	"Return true to reject the given event, for the receiver and all submorphs."

	(super rejectsEventFully: anEvent) ifTrue: [^true].
	anEvent isDropEvent ifTrue: [^true]. "never attempt to drop on halos"
	^false!

Morph removeSelector: #dispatchEvent:!

!methodRemoval: Morph #dispatchEvent: stamp: 'Install-7489-refactor-JuanVuletich-2025Sep02-16h46m-jmv.001.cs.st 9/5/2025 16:18:27'!
dispatchEvent: aMorphicEvent
	"This is the central entry for dispatching events in morphic. Given some event, find the right receiver and let him handle it."

	(self rejectsEventFully: aMorphicEvent)
		ifFalse: [ aMorphicEvent dispatchIn: self ].!

Morph removeSelector: #rejectsEventFully:!

!methodRemoval: Morph #rejectsEventFully: stamp: 'Install-7489-refactor-JuanVuletich-2025Sep02-16h46m-jmv.001.cs.st 9/5/2025 16:18:27'!
rejectsEventFully: aMorphicEvent
	"Return true to reject the given event, for the receiver and all submorphs."

	^ self isLocked or: [ self visible not ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7489-refactor-JuanVuletich-2025Sep02-16h46m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7486] on 2 September 2025 at 4:53:50 pm'!
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 16:52:00' prior: 50377684!
               handleKeyboardFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."

	aMorphicEvent dispatchIn: self.

	"Need to handle keyboard input if we have the focus."
	^ aMorphicEvent sendEventTo: self.! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 16:53:08' prior: 50377724!
                              handleMouseFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."

	aMorphicEvent dispatchIn: self.

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	aMorphicEvent isMouseOver ifTrue: [
		^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ 
		aMorphicEvent sendEventTo: self.
		^self ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil: [(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [
		^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil: [(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [
		^self]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7490-refactor-JuanVuletich-2025Sep02-16h50m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7489] on 2 September 2025 at 5:42:14 pm'!
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 9/2/2025 17:41:42' prior: 50376841!
         dispatchIn: aWorldMorph
	"Drop is done on the innermost target that accepts it.
	If #rejectsEvent:, any party doesn't want the drop,or #wasHandled not by any reason, try with the owner."

	| handlerMorph dropped |
	handlerMorph := aWorldMorph morphVisibleAt: position.
	[ handlerMorph notNil and: [wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			handlerMorph allowsMorphDrop ifTrue: [
				"Do a symmetric check if both morphs like each other"
				dropped := self contents.
				((handlerMorph wantsDroppedMorph: dropped event: self)		"I want her"
					and: [dropped wantsToBeDroppedInto: handlerMorph])		"she wants me"
						ifTrue: [ self sendEventTo: handlerMorph ]].
			wasHandled
				ifFalse: [
					handlerMorph invalidDrop: self.
					(self contents is: #DraggingGuideMorph) ifTrue: [
						self wasHandled: true.
						self contents delete ]
					]
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 17:35:40' prior: 50377764!
   startDropEventDispatch: aDropEvent

	aDropEvent dispatchIn: owner.
	self mouseOverHandler processMouseOver: lastMouseEvent! !
!DraggingGuideMorph methodsFor: 'drawing' stamp: 'jmv 9/2/2025 17:11:06' prior: 16851882!
        drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		fillRectangle: self localBounds
		color: (Theme current listHighlightFocused: true).! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7492-InvalidMethodDnD-fix-JuanVuletich-2025Sep02-17h39m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7492] on 3 September 2025 at 10:31:37 am'!
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 9/3/2025 10:30:54' prior: 50377925!
                        handleMouseFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."

	"#dispatchIn: and not #sendEventTo: so it is handled by the appropriate menu item."
	aMorphicEvent dispatchIn: self.
	
	"Handle clicks outside us, so we are closed. This will only be done if the event wasn't handled above,
	meaning that it is a click outside of us."
	aMorphicEvent isMouseButton ifTrue: [
		aMorphicEvent sendEventTo: self.
		^self ].
	
	"On MouseMove maybe activate submenu, or owner."
	aMorphicEvent isMove ifTrue: [
		"On #mouseMove we might transfer control to *either* the currently active submenu
		or the owner menu, if any.
		Since the active sub menu is always displayed upfront check it first."
		selectedItem ifNotNil: [
			(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [
				^self]].
		"Note: The following does not traverse upwards but it's the best I can do for now"
		popUpOwner ifNotNil: [
			(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [
				^self]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7493-MenuMouseFocusEvent-cleanup-JuanVuletich-2025Sep03-10h23m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7490] on 2 September 2025 at 5:59:00 pm'!
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/2/2025 17:58:33' prior: 50377490!
 startKeyboardDispatch: aKeyboardEvent

	| focusedElement |
	
	focusedElement := self keyboardFocus ifNil: [ self world ].
	aKeyboardEvent sendEventTo: focusedElement.
	self mouseOverHandler processMouseOver: lastMouseEvent! !

MenuMorph removeSelector: #handleKeyboardFocusEvent:!

!methodRemoval: MenuMorph #handleKeyboardFocusEvent: stamp: 'Install-7494-KeyboardFocusIsKing-JuanVuletich-2025Sep02-17h51m-jmv.001.cs.st 9/5/2025 16:18:27'!
handleKeyboardFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."

	aMorphicEvent dispatchIn: self.

	"Need to handle keyboard input if we have the focus."
	^ aMorphicEvent sendEventTo: self.!

Morph removeSelector: #handleKeyboardFocusEvent:!

!methodRemoval: Morph #handleKeyboardFocusEvent: stamp: 'Install-7494-KeyboardFocusIsKing-JuanVuletich-2025Sep02-17h51m-jmv.001.cs.st 9/5/2025 16:18:27'!
handleKeyboardFocusEvent: aMorphicEvent
	"Handle the given event. This message is sent if the receiver currently has the focus and is therefore receiving events directly from some hand."

	aMorphicEvent sendEventTo: self.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7494-KeyboardFocusIsKing-JuanVuletich-2025Sep02-17h51m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7494] on 3 September 2025 at 10:44:09 am'!

SystemWindow removeSelector: #justDroppedInto:event:!

!methodRemoval: SystemWindow #justDroppedInto:event: stamp: 'Install-7495-Cleanup-JuanVuletich-2025Sep03-10h43m-jmv.002.cs.st 9/5/2025 16:18:27'!
justDroppedInto: newOwnerMorph event: anEvent

	TopWindow ~~ self ifTrue: [ self activate ].
	^super justDroppedInto: newOwnerMorph event: anEvent!

MenuMorph removeSelector: #justDroppedInto:event:!

!methodRemoval: MenuMorph #justDroppedInto:event: stamp: 'Install-7495-Cleanup-JuanVuletich-2025Sep03-10h43m-jmv.002.cs.st 9/5/2025 16:18:27'!
justDroppedInto: newOwnerMorph event: evt
	| halo |
	super justDroppedInto: newOwnerMorph event: evt.
	halo := evt hand halo.
	(halo notNil and:[halo target hasOwner: self]) ifTrue: [
		"Grabbed single menu item"
		self addHalo: evt ].
	stayUp ifFalse: [ evt hand newMouseFocus: self ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7495-Cleanup-JuanVuletich-2025Sep03-10h43m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7495] on 3 September 2025 at 8:14:02 pm'!

MouseEvent subclass: #MouseEnterEvent
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #MouseEnterEvent category: #'Morphic-Events' stamp: 'Install-7496-MouseEnter-MouseLeave-MouseOver-JuanVuletich-2025Sep03-20h06m-jmv.001.cs.st 9/5/2025 16:18:27'!
MouseEvent subclass: #MouseEnterEvent
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

MouseEvent subclass: #MouseLeaveEvent
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #MouseLeaveEvent category: #'Morphic-Events' stamp: 'Install-7496-MouseEnter-MouseLeave-MouseOver-JuanVuletich-2025Sep03-20h06m-jmv.001.cs.st 9/5/2025 16:18:27'!
MouseEvent subclass: #MouseLeaveEvent
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

MouseEvent subclass: #MouseOverEvent
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #MouseOverEvent category: #'Morphic-Events' stamp: 'Install-7496-MouseEnter-MouseLeave-MouseOver-JuanVuletich-2025Sep03-20h06m-jmv.001.cs.st 9/5/2025 16:18:27'!
MouseEvent subclass: #MouseOverEvent
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!MouseButtonEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:18:55'!
                         mouseDownPosition: evtPos which: changedButtonsAndModifiers buttons: evtButtons hand: evtHand stamp: stamp
	type := #mouseDown.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	whichButton := changedButtonsAndModifiers.
	timeStamp := stamp.! !
!MouseButtonEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:19:01'!
                             mouseUpPosition: evtPos which: changedButtonsAndModifiers buttons: evtButtons hand: evtHand stamp: stamp
	type := #mouseUp.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	whichButton := changedButtonsAndModifiers.
	timeStamp := stamp.! !
!MouseEnterEvent methodsFor: 'dispatching' stamp: 'jmv 9/3/2025 15:58:35'!
                              sendEventTo: aMorph
	"Dispatch the receiver into aMorph.
	See #asMouseEnter, #asMouseLeave, #asMouseMove, #asMouseOver."

	type == #mouseEnter ifTrue: [
		aMorph processMouseEnter: self localPosition: (aMorph internalizeFromWorld: position).
		^self ].

	"Backstop. Just in case."
	super sendEventTo: aMorph.! !
!MouseEnterEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 15:55:53'!
 setPosition: evtEnd buttons: evtButtons hand: evtHand stamp: stamp

	type := #mouseEnter.
	position := evtEnd.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	timeStamp := stamp.! !
!MouseLeaveEvent methodsFor: 'dispatching' stamp: 'jmv 9/3/2025 15:58:18'!
            sendEventTo: aMorph
	"Dispatch the receiver into aMorph.
	See #asMouseEnter, #asMouseLeave, #asMouseMove, #asMouseOver."

	type == #mouseLeave ifTrue: [
		aMorph processMouseLeave: self localPosition: (aMorph internalizeFromWorld: position).
		^self ].

	"Backstop. Just in case."
	super sendEventTo: aMorph.! !
!MouseLeaveEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 15:55:43'!
 setPosition: evtEnd buttons: evtButtons hand: evtHand stamp: stamp

	type := #mouseLeave.
	position := evtEnd.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	timeStamp := stamp.! !
!MouseMoveEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 15:10:50'!
                 setPosition: evtEnd buttons: evtButtons hand: evtHand stamp: stamp

	type := #mouseMove.
	position := evtEnd.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	timeStamp := stamp.! !
!MouseOverEvent methodsFor: 'dispatching' stamp: 'jmv 9/3/2025 16:00:39'!
              sendEventTo: aMorph
	"Dispatch the receiver into aMorph.
	See #asMouseEnter, #asMouseLeave, #asMouseMove, #asMouseOver."

	type == #mouseOver ifTrue: [
		aMorph processMouseOver: self localPosition: (aMorph internalizeFromWorld: position).
		^self ].

	"Backstop. Just in case."
	super sendEventTo: aMorph.! !
!MouseOverEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:00:07'!
    setPosition: evtEnd buttons: evtButtons hand: evtHand stamp: stamp

	type := #mouseOver.
	position := evtEnd.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	timeStamp := stamp.! !
!MouseScrollEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 15:12:53'!
                setPosition: evtPos direction: evtDir buttons: evtButtons hand: evtHand stamp: stamp
	type := #mouseScroll.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	direction := evtDir.
	timeStamp := stamp.! !
!MouseEvent methodsFor: 'converting' stamp: 'jmv 9/3/2025 15:56:53' prior: 16917735!
                          asMouseEnter

	^ MouseEnterEvent new
		setPosition: position
		buttons: buttons
		hand: source
		stamp: Time millisecondClockValue "VMs report events using #millisecondClockValue"! !
!MouseEvent methodsFor: 'converting' stamp: 'jmv 9/3/2025 15:56:41' prior: 16917739!
                    asMouseLeave

	^ MouseLeaveEvent new
		setPosition: position
		buttons: buttons
		hand: source
		stamp: Time millisecondClockValue "VMs report events using #millisecondClockValue"! !
!MouseEvent methodsFor: 'converting' stamp: 'jmv 9/3/2025 15:11:12' prior: 16917743!
                    asMouseMove

	^ MouseMoveEvent new
		setPosition: position
		buttons: buttons
		hand: source
		stamp: Time millisecondClockValue "VMs report events using #millisecondClockValue"! !
!MouseEvent methodsFor: 'converting' stamp: 'jmv 9/3/2025 16:01:47' prior: 16917752!
                      asMouseOver
	"Convert the receiver into a mouse over event"

	^ MouseOverEvent new
		setPosition: position
		buttons: buttons
		hand: source
		stamp: Time millisecondClockValue "VMs report events using #millisecondClockValue"! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/3/2025 15:11:52' prior: 50377779!
startMouseDispatch: aMouseEvent

	aMouseEvent isMouseOver ifTrue: [
		self mouseFocus
			ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
			ifNil: [ aMouseEvent dispatchIn: owner ].
		^self].

	"any mouse event but mouseOver"
	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			self mouseOverHandler processMouseOver: lastMouseEvent.
			^self ]].

	aMouseEvent isMove
		ifTrue: [
			self morphPosition: aMouseEvent eventPosition.
			self mouseFocus
				ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
				ifNil: [ aMouseEvent dispatchIn: owner ]
		] ifFalse: [
		aMouseEvent isMouseScroll ifTrue: [
			aMouseEvent dispatchIn: owner
		] ifFalse: [
			"Issue a synthetic move event if we're not at the position of the event"
			aMouseEvent eventPosition = self morphPosition ifFalse: [
				"Issue a mouse move event to make the receiver appear at the given position"
				self startMouseDispatch: (MouseMoveEvent new
					setPosition: aMouseEvent eventPosition
					buttons: aMouseEvent buttons
					hand: self
					stamp: aMouseEvent timeStamp) ].
			"Drop submorphs on button events"
			self hasSubmorphs
				ifTrue: [
					"Not if we are grabbing them"
					mouseClickState ifNil: [
						"Want to drop on mouseUp, NOT mouseDown"
						aMouseEvent isMouseUp ifTrue: [
							self dropMorphs: aMouseEvent ]
					]
				] ifFalse: [
					self mouseFocus
						ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
						ifNil: [ aMouseEvent dispatchIn: owner ]]]].
		self mouseOverHandler processMouseOver: lastMouseEvent.! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 9/3/2025 15:46:40' prior: 16878933!
            initForEvents
	mouseOverHandler := nil.
	lastMouseEventTime := Time localMillisecondClock.
	lastMouseEvent := MouseMoveEvent new
			setPosition: `0@0`
			buttons: 0
			hand: self
			stamp: lastMouseEventTime.
	lastEventBuffer := {1. 0. 0. 0. 0. 0. nil. nil}.
	self dontWaitForMoreClicks.! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 9/3/2025 15:13:07' prior: 16879011!
     generateKeyboardEvent: evtBuf
	"Generate the appropriate mouse event for the given raw event buffer"
	| buttons modifiers type keyValue pressType stamp mouseScrollDirection |
	stamp := evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	(evtBuf sixth <= 0 or: [ (keyValue := evtBuf sixth) isNil ]) ifTrue: [ keyValue := Character macRomanToLatin1: evtBuf third ].

	modifiers := evtBuf fifth.
	pressType := evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type := #keyDown.
		lastKeyDownValue := keyValue ].
	pressType = EventSensor eventKeyUp ifTrue: [
		(keyValue = 9 and: [(modifiers anyMask: 1) and: [Smalltalk platformName = 'unix']])
			ifTrue: [
				"Linux VMs don't generate shift-tab keystroke. Turn #keyUp into #keystroke"
				pressType := EventSensor eventKeyChar ]
			ifFalse: [type := #keyUp ]].
	pressType = EventSensor eventKeyChar ifTrue: [
		type := #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [ 											"Control key pressed"
			keyValue < 27 ifTrue: [ 										"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [   									"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ "If Equal, Ctrl-alphabetic in Windows => do translate"
						lastKeyDownValue < 47 ]) ifTrue: [ 			"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue := (modifiers anyMask: 1)
							ifTrue: [ keyValue + 64 ]
							ifFalse: [ keyValue + 96   						"shift not pressed: conver to lowercase letter" ]]]].
			"On Windows, ctrl-backSpace is reported as ctrl-forwardDelete. But keyDown is ok, so we can know and fix."
			(keyValue = 127 and: [ lastKeyDownValue = 8 ])
				ifTrue: [ keyValue := 8 ].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [ modifiers := modifiers bitOr: 8 ]].
		(modifiers anyMask: 8) ifTrue: [ 									"CmdAlt key pressed (or Control key pressed, and #shouldControlEmulateAltFor: just answered true)"
			(modifiers anyMask: 1) ifTrue: [								"Shift pressed"
				| i |
				"It seems that for ctrl-shifted keys and cmd-shifted keys, the VM incorrectly reports the UNSHIFTED character.
				Correct this, at least for common cmd-shortcuts, and for the US keyboard... Sigh...
				(This has only been observed on Mac VMs, but seems harmless if proper shifted character is reported (as in Linux), as this wil be NOP)
				(On Windows, the situation is even worse: ctrl-{ is not even reported as a keystroke event. Only keyDown and keyUp.)"
				"#($' $, $. $9 $0 $[ $]) -> #($'' $< $> $( $) ${) $}"
				i := #[39 44 46 57 48 91 93 ] indexOf: keyValue.
				i > 0 ifTrue: [
					keyValue := #[34 60 62 40 41 123 125] at: i ]]]].
	buttons := modifiers bitShift: 3.
	"Linux and Windows VM send keyboard ctrl-upArrow and ctrl-downArrow when the user tries to scroll using the mouse wheel
	Mac VM sends cmd-option-ctrl-shift-upArrow and cmd-option-ctrl-shift-downArrow for trackpad vertical scroll gestures,
		and cmd-option-ctrl-shift-leftArrow and cmd-option-ctrl-shift-rightArrow for horizontal scroll gestures.
	This way of reporting scroll events by the VM also enables scrolling using the keyboard (actually, we can't tell if user gesture was on Mouse, Trackpad or Keyboard).
	But ctrl-shift and cmdAlt-shift are needed used for selecting while moving by word, line, etc.
	Additionally, #ctrlArrowsScrollHorizontally allows chosing between keyboard horizontal scroll and moving word by word in text editors."
	mouseScrollDirection := nil.
	"Ctrl for Keyboard or Mouse wheel gestures. All modifiers for Trackpad gestures."
	(buttons = InputSensor controlKey or: [buttons = InputSensor cmdAltOptionCtrlShiftModifierKeys]) ifTrue: [
		keyValue = 30
			ifTrue: [mouseScrollDirection := #up]
		ifFalse: [keyValue = 31
			ifTrue: [mouseScrollDirection := #down]]].
	"Ctrl for Keyboard or Mouse wheel gestures, only if preference is set. All modifiers for Trackpad gestures."
	((buttons = InputSensor controlKey and: [Preferences at: #ctrlArrowsScrollHorizontally]) or: [buttons = InputSensor cmdAltOptionCtrlShiftModifierKeys]) ifTrue: [
		keyValue = 28
			ifTrue: [mouseScrollDirection := #left]
		ifFalse: [keyValue = 29
			ifTrue: [mouseScrollDirection := #right]]].
	mouseScrollDirection ifNotNil: [
		^ MouseScrollEvent new
			setPosition: self morphPosition
			direction: mouseScrollDirection
			buttons: buttons
			hand: self
			stamp: stamp ].
	^ KeyboardEvent new
		setType: type
		buttons: buttons
		position: self morphPosition
		keyValue: keyValue
		hand: self
		stamp: stamp.! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 9/3/2025 15:41:30' prior: 16879170!
              generateMouseEvent: evtBuf 
	"Generate the appropriate mouse event for the given raw event buffer"

	| stamp pos buttons oldButtons modifiers oldModifiers buttonsAndModifiers oldButtonsAndModifiers trail |
	stamp := evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	pos := evtBuf third @ evtBuf fourth.
	
	buttons := evtBuf fifth.
	modifiers := evtBuf sixth.
	buttonsAndModifiers := buttons bitOr: (modifiers bitShift: 3).
	oldButtons := lastEventBuffer fifth.
	oldModifiers := lastEventBuffer sixth.
	oldButtonsAndModifiers := oldButtons bitOr: (oldModifiers bitShift: 3).
	
	lastEventBuffer := evtBuf.

	buttons = oldButtons ifTrue: [
		trail := self mouseTrailFrom: evtBuf.
		^MouseMoveEvent new
			setPosition: trail last
			buttons: buttonsAndModifiers
			hand: self
			stamp: stamp].

	^buttons > oldButtons
		ifTrue: [
			MouseButtonEvent new
				mouseDownPosition: pos
				which: (buttonsAndModifiers bitXor: oldButtonsAndModifiers)
				buttons: buttonsAndModifiers
				hand: self
				stamp: stamp ]
		ifFalse: [
			MouseButtonEvent new
				mouseUpPosition: pos
				which: (buttonsAndModifiers bitXor: oldButtonsAndModifiers)
				buttons: buttonsAndModifiers
				hand: self
				stamp: stamp ].! !
!HandMorph methodsFor: 'private events' stamp: 'jmv 9/3/2025 15:13:16' prior: 16879207!
        generateMouseScrollEvent: evtBuf
	"Generate the appropriate mouse wheel event for the given raw event buffer
	
	Copied from Sqeak 5.3 and modifed."

	| buttons modifiers stamp deltaX deltaY direction oldButtons |
	stamp := evtBuf second.
	stamp = 0 ifTrue: [stamp := Time millisecondClockValue ].
	deltaX := evtBuf third.
	deltaY := evtBuf fourth.
	"This implementation deliberatly ignores movements in both dimensions:"
	direction := 
		deltaY negative
			ifTrue: [ #down ]
			ifFalse: [ deltaY strictlyPositive
				ifTrue: [ #up ]
				ifFalse: [ deltaX negative
					ifTrue: [ #left ]
					ifFalse: [ deltaX strictlyPositive
						ifTrue: [ #right ]
						ifFalse: [ ^ nil "No movement, bailing out" ] ] ] ].
	modifiers := evtBuf fifth.
	buttons := (modifiers bitShift: 3) bitOr: (lastMouseEvent buttons bitAnd: 7).
	oldButtons := lastEventBuffer fifth 
		bitOr: (lastEventBuffer sixth bitShift: 3).
	lastEventBuffer := evtBuf.
	^ MouseScrollEvent new
		setPosition: self morphPosition 
		direction: direction
		buttons: (oldButtons bitXor: buttons)
		hand: self
		stamp: stamp! !

MouseScrollEvent removeSelector: #setType:position:direction:buttons:hand:stamp:!

!methodRemoval: MouseScrollEvent #setType:position:direction:buttons:hand:stamp: stamp: 'Install-7496-MouseEnter-MouseLeave-MouseOver-JuanVuletich-2025Sep03-20h06m-jmv.001.cs.st 9/5/2025 16:18:27'!
setType: evtType position: evtPos direction: evtDir buttons: evtButtons hand: evtHand stamp: stamp
	type := evtType.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	direction := evtDir.
	timeStamp := stamp.!

MouseMoveEvent removeSelector: #setType:position:buttons:hand:stamp:!

!methodRemoval: MouseMoveEvent #setType:position:buttons:hand:stamp: stamp: 'Install-7496-MouseEnter-MouseLeave-MouseOver-JuanVuletich-2025Sep03-20h06m-jmv.001.cs.st 9/5/2025 16:18:27'!
setType: evtType position: evtEnd buttons: evtButtons hand: evtHand stamp: stamp

	type := evtType.
	position := evtEnd.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	timeStamp := stamp!

MouseButtonEvent removeSelector: #setType:position:which:buttons:hand:stamp:!

!methodRemoval: MouseButtonEvent #setType:position:which:buttons:hand:stamp: stamp: 'Install-7496-MouseEnter-MouseLeave-MouseOver-JuanVuletich-2025Sep03-20h06m-jmv.001.cs.st 9/5/2025 16:18:27'!
setType: evtType position: evtPos which: button buttons: evtButtons hand: evtHand stamp: stamp
	type := evtType.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	whichButton := button.
	timeStamp := stamp.!

MouseEvent removeSelector: #setType:!

!methodRemoval: MouseEvent #setType: stamp: 'Install-7496-MouseEnter-MouseLeave-MouseOver-JuanVuletich-2025Sep03-20h06m-jmv.001.cs.st 9/5/2025 16:18:27'!
setType: aSymbol
	"For quick conversion between event types"
	type := aSymbol.!

MouseEvent removeSelector: #setType:position:buttons:hand:!

!methodRemoval: MouseEvent #setType:position:buttons:hand: stamp: 'Install-7496-MouseEnter-MouseLeave-MouseOver-JuanVuletich-2025Sep03-20h06m-jmv.001.cs.st 9/5/2025 16:18:27'!
setType: evtType position: evtPos buttons: evtButtons hand: evtHand
	type := evtType.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.!

MouseEvent removeSelector: #isMouseEnter!

!methodRemoval: MouseEvent #isMouseEnter stamp: 'Install-7496-MouseEnter-MouseLeave-MouseOver-JuanVuletich-2025Sep03-20h06m-jmv.001.cs.st 9/5/2025 16:18:27'!
isMouseEnter
	^ type == #mouseEnter!

MouseEvent removeSelector: #isMouseLeave!

!methodRemoval: MouseEvent #isMouseLeave stamp: 'Install-7496-MouseEnter-MouseLeave-MouseOver-JuanVuletich-2025Sep03-20h06m-jmv.001.cs.st 9/5/2025 16:18:27'!
isMouseLeave
	^ type == #mouseLeave!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7496-MouseEnter-MouseLeave-MouseOver-JuanVuletich-2025Sep03-20h06m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7495] on 3 September 2025 at 8:30:53 pm'!
!MouseButtonEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:06:13'!
             isMouseDown
	^ type == #mouseDown! !
!MouseButtonEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:07:19'!
                   isMouseUp
	^ type == #mouseUp! !
!MouseMoveEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:05:10'!
                         isMouseMove
	^true! !
!MouseOverEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:03:37'!
    isMouseOver
	^true! !
!MouseScrollEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:08:24'!
  isMouseScroll
	^ true! !
!MouseEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:06:18' prior: 16917797!
                     isMouseDown
	^ false! !
!MouseEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:03:41' prior: 16917813!
                      isMouseOver
	^false! !
!MouseEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:08:20' prior: 16917817!
                       isMouseScroll
	^ false! !
!MouseEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:07:28' prior: 16917821!
                    isMouseUp
	^ false! !
!Morph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:27:11' prior: 16911169!
                              keyDown: aKeyboardEvent
	"Handle a key down event. The default response is to do nothing."
	
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #'keyDown:' 
		ifPresentDo: [ :handler | handler value: aKeyboardEvent ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/3/2025 20:28:00' prior: 50377400!
                         handleMouseFocusEvent: aMouseEvent
	"Handle the given event. This message is sent if the receiver currently has the focus and is therefore receiving events directly from some hand."

	aMouseEvent sendEventTo: self.! !
!HaloHandleMorph methodsFor: 'act' stamp: 'jmv 9/3/2025 20:26:17' prior: 16876889!
                   send: selector withEvent: aMouseEvent
	| arity |
	owner ifNil: [ ^ self ].
	selector ifNil: [ ^ self ].
	arity := selector numArgs.
	arity = 0 ifTrue: [ ^ owner perform: selector ].
	arity = 1 ifTrue: [
		^ owner
			perform: selector
			with: aMouseEvent ].
	arity = 2 ifTrue: [
		^ owner
			perform: selector
			with: aMouseEvent
			with: self ].
	self error: 'Event handling selectors must be Symbols and take 0-2 arguments'! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 9/3/2025 20:25:33' prior: 50378026!
                       handleMouseFocusEvent: aMouseEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."

	"#dispatchIn: and not #sendEventTo: so it is handled by the appropriate menu item."
	aMouseEvent dispatchIn: self.
	
	"Handle clicks outside us, so we are closed. This will only be done if the event wasn't handled above,
	meaning that it is a click outside of us."
	aMouseEvent isMouseButton ifTrue: [
		aMouseEvent sendEventTo: self.
		^self ].
	
	"On MouseMove maybe activate submenu, or owner."
	aMouseEvent isMouseMove ifTrue: [
		"On #mouseMove we might transfer control to *either* the currently active submenu
		or the owner menu, if any.
		Since the active sub menu is always displayed upfront check it first."
		selectedItem ifNotNil: [
			(selectedItem activateSubmenu: aMouseEvent) ifTrue: [
				^self]].
		"Note: The following does not traverse upwards but it's the best I can do for now"
		popUpOwner ifNotNil: [
			(popUpOwner activateOwnerMenu: aMouseEvent) ifTrue: [
				^self]]].! !
!WorldMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:25:05' prior: 17018369!
        windowEvent: aWindowEvent

	aWindowEvent windowEventType == #windowClose
		ifTrue: [
			^TheWorldMenu basicNew quitSession]
! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/3/2025 16:05:22' prior: 50378339!
     startMouseDispatch: aMouseEvent

	aMouseEvent isMouseOver ifTrue: [
		self mouseFocus
			ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
			ifNil: [ aMouseEvent dispatchIn: owner ].
		^self].

	"any mouse event but mouseOver"
	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			self mouseOverHandler processMouseOver: lastMouseEvent.
			^self ]].

	aMouseEvent isMouseMove
		ifTrue: [
			self morphPosition: aMouseEvent eventPosition.
			self mouseFocus
				ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
				ifNil: [ aMouseEvent dispatchIn: owner ]
		] ifFalse: [
		aMouseEvent isMouseScroll ifTrue: [
			aMouseEvent dispatchIn: owner
		] ifFalse: [
			"Issue a synthetic move event if we're not at the position of the event"
			aMouseEvent eventPosition = self morphPosition ifFalse: [
				"Issue a mouse move event to make the receiver appear at the given position"
				self startMouseDispatch: (MouseMoveEvent new
					setPosition: aMouseEvent eventPosition
					buttons: aMouseEvent buttons
					hand: self
					stamp: aMouseEvent timeStamp) ].
			"Drop submorphs on button events"
			self hasSubmorphs
				ifTrue: [
					"Not if we are grabbing them"
					mouseClickState ifNil: [
						"Want to drop on mouseUp, NOT mouseDown"
						aMouseEvent isMouseUp ifTrue: [
							self dropMorphs: aMouseEvent ]
					]
				] ifFalse: [
					self mouseFocus
						ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
						ifNil: [ aMouseEvent dispatchIn: owner ]]]].
		self mouseOverHandler processMouseOver: lastMouseEvent.! !

MouseMoveEvent removeSelector: #isMove!

!methodRemoval: MouseMoveEvent #isMove stamp: 'Install-7497-MouseEvents-refactor-JuanVuletich-2025Sep03-20h14m-jmv.001.cs.st 9/5/2025 16:18:27'!
isMove
	^true!

MouseEvent removeSelector: #isMouseMove!

!methodRemoval: MouseEvent #isMouseMove stamp: 'Install-7497-MouseEvents-refactor-JuanVuletich-2025Sep03-20h14m-jmv.001.cs.st 9/5/2025 16:18:27'!
isMouseMove
	^ type == #mouseMove!

MouseEvent removeSelector: #isMove!

!methodRemoval: MouseEvent #isMove stamp: 'Install-7497-MouseEvents-refactor-JuanVuletich-2025Sep03-20h14m-jmv.001.cs.st 9/5/2025 16:18:27'!
isMove
	^false!

MorphicEvent removeSelector: #isMouseOver!

!methodRemoval: MorphicEvent #isMouseOver stamp: 'Install-7497-MouseEvents-refactor-JuanVuletich-2025Sep03-20h14m-jmv.001.cs.st 9/5/2025 16:18:27'!
isMouseOver
	^false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7497-MouseEvents-refactor-JuanVuletich-2025Sep03-20h14m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7495] on 3 September 2025 at 4:15:34 pm'!
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 9/3/2025 16:14:25' prior: 16917338!
                   sendEventTo: aMorph
	"Dispatch the receiver into aMorph."

	type == #mouseDown ifTrue: [
		aMorph processMouseDown: self localPosition: (aMorph internalizeFromWorld: position).
		^self ].
	type == #mouseUp ifTrue: [
		aMorph processMouseUp: self localPosition: (aMorph internalizeFromWorld: position).
		^self ].

	"Because any MouseEvent can be of the kinds handled by super."
	super sendEventTo: aMorph.! !
!MouseEnterEvent methodsFor: 'dispatching' stamp: 'jmv 9/3/2025 16:14:19' prior: 50378219!
            sendEventTo: aMorph
	"Dispatch the receiver into aMorph."

	aMorph processMouseEnter: self localPosition: (aMorph internalizeFromWorld: position).! !
!MouseLeaveEvent methodsFor: 'dispatching' stamp: 'jmv 9/3/2025 16:13:45' prior: 50378240!
               sendEventTo: aMorph
	"Dispatch the receiver into aMorph."

	aMorph processMouseLeave: self localPosition: (aMorph internalizeFromWorld: position).! !
!MouseMoveEvent methodsFor: 'dispatching' stamp: 'jmv 9/3/2025 16:14:13' prior: 16917864!
                sendEventTo: aMorph
	"Dispatch the receiver into aMorph."

	aMorph processMouseMove: self localPosition: (aMorph internalizeFromWorld: position).! !
!MouseOverEvent methodsFor: 'dispatching' stamp: 'jmv 9/3/2025 16:10:35' prior: 50378270!
                 sendEventTo: aMorph
	"Dispatch the receiver into aMorph."

	aMorph processMouseOver: self localPosition: (aMorph internalizeFromWorld: position).! !
!MouseScrollEvent methodsFor: 'dispatching' stamp: 'jmv 9/3/2025 16:14:04' prior: 16918086!
               sendEventTo: aMorph
	"Dispatch the receiver into aMorph."

	aMorph processMouseScroll: self localPosition: (aMorph internalizeFromWorld: position).! !

MouseEvent removeSelector: #sendEventTo:!

!methodRemoval: MouseEvent #sendEventTo: stamp: 'Install-7498-MouseEventDispatch-cleanup-JuanVuletich-2025Sep03-16h08m-jmv.002.cs.st 9/5/2025 16:18:27'!
sendEventTo: aMorph
	"Dispatch the receiver into aMorph.
	See #asMouseEnter, #asMouseLeave, #asMouseMove, #asMouseOver."

	type == #mouseOver ifTrue: [
		^aMorph processMouseOver: self localPosition: (aMorph internalizeFromWorld: position) ].
	type == #mouseEnter ifTrue: [
		^ aMorph processMouseEnter: self localPosition: (aMorph internalizeFromWorld: position) ].
	type == #mouseLeave ifTrue: [
		^aMorph processMouseLeave: self localPosition: (aMorph internalizeFromWorld: position) ].

	"Backstop. Just in case."
	^ super sendEventTo: aMorph!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7498-MouseEventDispatch-cleanup-JuanVuletich-2025Sep03-16h08m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7498] on 3 September 2025 at 8:34:22 pm'!
!MouseEvent methodsFor: 'comparing' stamp: 'jmv 9/3/2025 16:15:36' prior: 16917717!
                         = aMorphicEvent

	"Any object is equal to itself"
	self == aMorphicEvent ifTrue: [ ^ true ].

	self class == aMorphicEvent class ifFalse: [ ^ false ].

	position = aMorphicEvent eventPosition ifFalse: [ ^ false ].
	buttons = aMorphicEvent buttons ifFalse: [ ^ false ].
	^ true! !
!MouseEvent methodsFor: 'comparing' stamp: 'jmv 9/3/2025 16:15:56' prior: 16917730!
                    hash
	^ self class name hash bitXor: (position hash bitXor: buttons hash)! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 9/3/2025 16:17:48' prior: 50378952!
                       sendEventTo: aMorph
	"Dispatch the receiver into aMorph."

	self isMouseDown ifTrue: [
		aMorph processMouseDown: self localPosition: (aMorph internalizeFromWorld: position).
		^self ].
	self isMouseUp ifTrue: [
		aMorph processMouseUp: self localPosition: (aMorph internalizeFromWorld: position).
		^self ].! !
!MouseEnterEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:16:39' prior: 50378231!
                 setPosition: evtEnd buttons: evtButtons hand: evtHand stamp: stamp

	position := evtEnd.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	timeStamp := stamp.! !
!MouseLeaveEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:16:35' prior: 50378252!
                      setPosition: evtEnd buttons: evtButtons hand: evtHand stamp: stamp

	position := evtEnd.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	timeStamp := stamp.! !
!MouseMoveEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:16:30' prior: 50378261!
                       setPosition: evtEnd buttons: evtButtons hand: evtHand stamp: stamp

	position := evtEnd.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	timeStamp := stamp.! !
!MouseOverEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:16:20' prior: 50378282!
                       setPosition: evtEnd buttons: evtButtons hand: evtHand stamp: stamp

	position := evtEnd.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	timeStamp := stamp.! !
!MouseScrollEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:16:25' prior: 50378291!
                     setPosition: evtPos direction: evtDir buttons: evtButtons hand: evtHand stamp: stamp

	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	direction := evtDir.
	timeStamp := stamp.! !

MouseEvent removeSelector: #eventType!

!methodRemoval: MouseEvent #eventType stamp: 'Install-7499-MouseEvents-refactor-JuanVuletich-2025Sep03-20h32m-jmv.001.cs.st 9/5/2025 16:18:27'!
eventType
	^type!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7499-MouseEvents-refactor-JuanVuletich-2025Sep03-20h32m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7495] on 3 September 2025 at 4:23:22 pm'!

UserInputEvent subclass: #KeyboardEvent
	instanceVariableNames: 'keyValue keyEventType '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #KeyboardEvent category: #'Morphic-Events' stamp: 'Install-7500-UserInputEvent-refactor-p1-JuanVuletich-2025Sep03-16h21m-jmv.002.cs.st 9/5/2025 16:18:27'!
UserInputEvent subclass: #KeyboardEvent
	instanceVariableNames: 'keyValue keyEventType'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton buttonEventType '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #MouseButtonEvent category: #'Morphic-Events' stamp: 'Install-7500-UserInputEvent-refactor-p1-JuanVuletich-2025Sep03-16h21m-jmv.002.cs.st 9/5/2025 16:18:27'!
MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'whichButton buttonEventType'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!KeyboardEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:22:54' prior: 16894817!
                               setType: aSymbol buttons: anInteger position: pos keyValue: aValue hand: aHand stamp: stamp
	type := aSymbol.
	keyEventType := aSymbol.
	buttons := anInteger.
	position := pos.
	keyValue := aValue.
	source := aHand.
	wasHandled := false.
	timeStamp := stamp.! !
!MouseButtonEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:23:10' prior: 50378195!
  mouseDownPosition: evtPos which: changedButtonsAndModifiers buttons: evtButtons hand: evtHand stamp: stamp
	type := #mouseDown.
	buttonEventType := #mouseDown.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	whichButton := changedButtonsAndModifiers.
	timeStamp := stamp.! !
!MouseButtonEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:23:16' prior: 50378207!
             mouseUpPosition: evtPos which: changedButtonsAndModifiers buttons: evtButtons hand: evtHand stamp: stamp
	type := #mouseUp.
	buttonEventType := #mouseUp.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	whichButton := changedButtonsAndModifiers.
	timeStamp := stamp.! !

UserInputEvent subclass: #KeyboardEvent
	instanceVariableNames: 'keyEventType keyValue'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #KeyboardEvent category: #'Morphic-Events' stamp: 'Install-7500-UserInputEvent-refactor-p1-JuanVuletich-2025Sep03-16h21m-jmv.002.cs.st 9/5/2025 16:18:27'!
UserInputEvent subclass: #KeyboardEvent
	instanceVariableNames: 'keyEventType keyValue'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'buttonEventType whichButton'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #MouseButtonEvent category: #'Morphic-Events' stamp: 'Install-7500-UserInputEvent-refactor-p1-JuanVuletich-2025Sep03-16h21m-jmv.002.cs.st 9/5/2025 16:18:27'!
MouseEvent subclass: #MouseButtonEvent
	instanceVariableNames: 'buttonEventType whichButton'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7500-UserInputEvent-refactor-p1-JuanVuletich-2025Sep03-16h21m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7495] on 3 September 2025 at 4:24:16 pm'!
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 9/3/2025 16:23:45' prior: 16894658!
        sendEventTo: aMorph
	"Dispatch the receiver into anObject"
	keyEventType == #keystroke ifTrue: [
		self isFindClassShortcut ifTrue: [ 
			(Preferences at: #classFinder) value.
			^self ].
		self isCloseWindowShortcut ifTrue: [
			self closeCurrentWindowOf: aMorph.
			^self ].
		aMorph processKeystroke: self.
		^self ].
	keyEventType == #keyDown ifTrue: [
		aMorph processKeyDown: self.
		^self ].
	keyEventType == #keyUp ifTrue: [ 
		aMorph processKeyUp: self.
		^self ].
	super sendEventTo: aMorph.! !
!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:23:57' prior: 16894774!
                  isKeyDown
	^ keyEventType == #keyDown! !
!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:23:53' prior: 16894778!
  isKeyUp
	^ keyEventType == #keyUp! !
!KeyboardEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:23:49' prior: 16894784!
      isKeystroke
	^ keyEventType == #keystroke! !
!MouseButtonEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:23:33' prior: 50378741!
                           isMouseDown
	^ buttonEventType == #mouseDown! !
!MouseButtonEvent methodsFor: 'testing' stamp: 'jmv 9/3/2025 16:23:30' prior: 50378745!
                        isMouseUp
	^ buttonEventType == #mouseUp! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7501-UserInputEvent-refactor-p2-JuanVuletich-2025Sep03-16h23m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7495] on 3 September 2025 at 4:25:12 pm'!
!KeyboardEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:24:20' prior: 50379162!
            setType: aSymbol buttons: anInteger position: pos keyValue: aValue hand: aHand stamp: stamp
	
	keyEventType := aSymbol.
	buttons := anInteger.
	position := pos.
	keyValue := aValue.
	source := aHand.
	wasHandled := false.
	timeStamp := stamp.! !
!MouseButtonEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:24:24' prior: 50379173!
                  mouseDownPosition: evtPos which: changedButtonsAndModifiers buttons: evtButtons hand: evtHand stamp: stamp
	
	buttonEventType := #mouseDown.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	whichButton := changedButtonsAndModifiers.
	timeStamp := stamp.! !
!MouseButtonEvent methodsFor: 'private' stamp: 'jmv 9/3/2025 16:24:28' prior: 50379186!
mouseUpPosition: evtPos which: changedButtonsAndModifiers buttons: evtButtons hand: evtHand stamp: stamp
	
	buttonEventType := #mouseUp.
	position := evtPos.
	buttons := evtButtons.
	source := evtHand.
	wasHandled := false.
	whichButton := changedButtonsAndModifiers.
	timeStamp := stamp.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7502-UserInputEvent-refactor-p3-JuanVuletich-2025Sep03-16h24m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7494] on 4 September 2025 at 9:55:01 am'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
[ MorphicEvent subclass: #UserInputEvent
	instanceVariableNames: 'buttons position wasHandled'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events' ] on: MethodInCallStackToBecomeInvalid do: [ :ex | ex resume: true ]!

!classDefinition: #UserInputEvent category: #'Morphic-Events' stamp: 'Install-7503-UserInputEvent-refactor-p4-JuanVuletich-2025Sep04-09h53m-jmv.001.cs.st 9/5/2025 16:18:27'!
MorphicEvent subclass: #UserInputEvent
	instanceVariableNames: 'buttons position wasHandled'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7503-UserInputEvent-refactor-p4-JuanVuletich-2025Sep04-09h53m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7502] on 3 September 2025 at 8:42:46 pm'!
!Morph methodsFor: 'event handling testing' stamp: 'jmv 9/3/2025 20:40:16' prior: 16911495!
                             handlesMouseOver: aMouseEvent
	"Do I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty?  The default response is false." 

	"Use a property test to allow individual instances to specify this."
	^ self hasProperty: #'handlesMouseOver:'! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/3/2025 20:40:49' prior: 16911763!
                     processMouseEnter: aMouseEnterEvent localPosition: localEventPosition
	"System level event handling."
	aMouseEnterEvent isDraggingEvent ifTrue: [
		^self].
	self wantsBalloon ifTrue: [
		aMouseEnterEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: aMouseEnterEvent) ifTrue: [
		aMouseEnterEvent wasHandled: true.
		self mouseEnter: aMouseEnterEvent ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/3/2025 20:41:24' prior: 16911777!
                          processMouseLeave: aMouseLeaveEvent localPosition: localEventPosition
	"System level event handling."
	aMouseLeaveEvent hand removePendingBalloonFor: self.
	aMouseLeaveEvent isDraggingEvent ifTrue: [
		^self].
	(self handlesMouseOver: aMouseLeaveEvent) ifTrue: [
		aMouseLeaveEvent wasHandled: true.
		self mouseLeave: aMouseLeaveEvent ]! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 9/3/2025 20:40:58' prior: 16899990!
            processMouseEnter: aMouseEnterEvent localPosition: localEventPosition
	"System level event handling."
	"Do #mouseEnter: even if button down (others, like LayoutAdjustingMorph need the default behavior)"
	self wantsBalloon ifTrue: [
		aMouseEnterEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: aMouseEnterEvent) ifTrue:[
		aMouseEnterEvent wasHandled: true.
		self mouseEnter: aMouseEnterEvent ]! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 9/3/2025 20:41:33' prior: 16900006!
    processMouseLeave: aMouseLeaveEvent localPosition: localEventPosition
	"System level event handling."

	"Do #mouseLeave: even if button down (others, like LayoutAdjustingMorph need the default behavior)"
	aMouseLeaveEvent hand removePendingBalloonFor: self.
	(self handlesMouseOver: aMouseLeaveEvent) ifTrue: [
		aMouseLeaveEvent wasHandled: true.
		self mouseLeave: aMouseLeaveEvent ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7504-MouseEvents-cleanup-JuanVuletich-2025Sep03-20h38m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7502] on 3 September 2025 at 9:01:44 pm'!
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 9/3/2025 20:59:50' prior: 16917895!
                noticeMouseOver: aMorph event: aMouseOverEvent
	"Remember that the mouse is currently over some morph"
	leftMorphs ifNil: [ ^self ].		"Might happen if you halt during layout."
	(leftMorphs includes: aMorph) 
		ifTrue: [ leftMorphs remove: aMorph ]
		ifFalse: [ enteredMorphs nextPut: aMorph ].
	overMorphs nextPut: aMorph.! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 9/3/2025 20:48:41' prior: 16911047!
   acceptDroppingMorph: aMorph event: aDropEvent
	"This message is sent when a morph is dropped onto a morph that has agreed to accept the dropped morph by responding 'true' to the wantsDroppedMorph:event: message. This default implementation just adds the given morph to the receiver."
	
	self addMorph: aMorph! !
!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 9/3/2025 20:48:20' prior: 16911065!
                 justDroppedInto: newOwnerMorph event: aDropEvent 
	"This message is sent to a dropped morph after it has been dropped on -- and been accepted by -- a drop-sensitive morph"

	newOwnerMorph activateWindow! !
!Morph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:49:14' prior: 16911194!
      keyUp: aKeyboardEvent
	"Handle a key up event. The default response is to do nothing."
	
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #'keyUp:'
		ifPresentDo: [ :handler | handler value: aKeyboardEvent ]! !
!Morph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:54:09' prior: 16911315!
           mouseEnter: aMouseEnterEvent
	"Handle a mouseEnter event, meaning the mouse just entered my bounds with no button pressed.
	Note: a Morph must answer true to #handlesMouseOver: in order to receive this message."
	
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #mouseEnter: 
		ifPresentDo: [ :handler | handler value: aMouseEnterEvent ]! !
!Morph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:47:01' prior: 16911329!
        mouseHover: aMouseOverEvent localPosition: localEventPosition
	"Handle a mouse move event.
	This message will only be sent to Morphs that answer true to #handlesMouseHover for events that have not been previously handled.
	We can query aMouseMoveEvent to know about pressed mouse buttons."
	"Allow instances to dynamically use properties for handling common events."
	self
		valueOfProperty: #mouseHover:localPosition:
		ifPresentDo: [ :handler |
			handler
				value: aMouseOverEvent
				value: localEventPosition ].! !
!Morph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:55:43' prior: 16911348!
           mouseLeave: aMouseLeaveEvent
	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed.
	Note: a Morph must answer true to #handlesMouseOver: in order to receive this message."

	(Preferences at: #focusFollowsMouse)
		ifTrue: [aMouseLeaveEvent hand releaseKeyboardFocus: self].
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #mouseLeave: 
		ifPresentDo: [ :handler | handler value: aMouseLeaveEvent ].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/3/2025 20:44:29' prior: 16911815!
                            processMouseOver: aMouseOverEvent localPosition: localEventPosition
	"System level event handling."
	 self hasMouseFocus ifTrue: [
		"Got this directly through #handleFocusEvent: so check explicitly"
		((self rejectsEvent: aMouseOverEvent) not and: [self fullIncludesPixel: aMouseOverEvent eventPosition]) ifFalse: [
			^self ]].
	aMouseOverEvent hand noticeMouseOver: self event: aMouseOverEvent.
	"Open question: should any unhandled mouse move events be filtered out? (i.e. should mouseHover:localPosition: be called when a mouse button is pressed but the morph doesn't have mouse button handlers?  Essentially, what are the limits of what is considered 'hovering'?"
	(self handlesMouseHover and: [aMouseOverEvent wasHandled not]) ifTrue: [
		self
			mouseHover: aMouseOverEvent
			localPosition: localEventPosition ].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/3/2025 20:45:14' prior: 16911843!
                processMouseScroll: aMouseScrollEvent localPosition: localEventPosition
	((self handlesMouseScroll: aMouseScrollEvent) and: [ aMouseScrollEvent wasHandled not ]) ifTrue: [
		self
			mouseScroll: aMouseScrollEvent
			localPosition: localEventPosition.
		aMouseScrollEvent wasHandled: true ].! !
!Sample10PythagorasTree methodsFor: 'as yet unclassified' stamp: 'jmv 9/3/2025 20:45:45' prior: 16952695!
                mouseScroll: aMouseScrollEvent localPosition: localEventPosition
	aMouseScrollEvent direction
		caseOf: {
			[ #up ] 		-> 	[ angle := angle + 0.02. self redrawNeeded ].
			[ #down ] 	-> 	[ angle := (angle - 0.02) max: 0. self redrawNeeded ].
			[ #left ] 	-> 	[ depthLimit := depthLimit - 1 max: 1. self redrawNeeded].
			[ #right ] 	-> 	[ depthLimit := depthLimit + 1 min: 15. self redrawNeeded]
		}! !
!EntryFieldMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:54:16' prior: 16859332!
                      mouseEnter: aMouseEnterEvent
	super mouseEnter: aMouseEnterEvent.
	(Preferences at: #focusFollowsMouse)
		ifTrue: [ aMouseEnterEvent hand newKeyboardFocus: self ]! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:54:20' prior: 16899984!
      mouseEnter: aMouseEnterEvent
	"The mouse entered the receiver"
	owner ifNil: [ ^self ].
	owner selectItem: self! !
!IndentingListItemMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:54:25' prior: 16882745!
                mouseEnter: aMouseEnterEvent
	isHighlighted := true.
	self redrawNeeded.
	^super mouseEnter: aMouseEnterEvent! !
!IndentingListItemMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:55:49' prior: 16882751!
                  mouseLeave: aMouseLeaveEvent
	isHighlighted := false.
	self redrawNeeded.
	^super mouseLeave: aMouseLeaveEvent! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:54:31' prior: 16930996!
                   mouseEnter: aMouseEnterEvent
	"The mouse entered the receiver"
	mouseIsOver := true.
	self redrawNeeded.
	^super mouseEnter: aMouseEnterEvent! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:55:54' prior: 16931003!
                    mouseLeave: aMouseLeaveEvent
	"The mouse has left the area of the receiver"
	mouseIsOver := false.
	self redrawNeeded.
	^super mouseLeave: aMouseLeaveEvent! !
!HoverableButtonMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:54:36' prior: 16881179!
      mouseEnter: aMouseEnterEvent
	
	mouseEnterSelector ifNotNil: [ model perform: mouseEnterSelector ].
	^super mouseEnter: aMouseEnterEvent! !
!HoverableButtonMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:56:18' prior: 16881186!
                         mouseLeave: aMouseLeaveEvent
	
	mouseLeaveSelector ifNotNil: [
		model perform: mouseLeaveSelector ].
	^super mouseLeave: aMouseLeaveEvent! !
!PluggableScrollPane methodsFor: 'events' stamp: 'jmv 9/3/2025 20:45:52' prior: 16932775!
                        mouseScroll: aMouseScrollEvent localPosition: localEventPosition
	aMouseScrollEvent direction
		caseOf: {
			[ #up ] 		-> 		[ scrollBar scrollUp: 1 ].
			[ #down ] 	-> 		[ scrollBar scrollDown: 1 ].
			[ #left ] 	-> 		[ hScrollBar scrollUp: 1 ].
			[ #right ] 	-> 		[ hScrollBar scrollDown: 1 ] }! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:54:43' prior: 16880001!
                        mouseEnter: aMouseEnterEvent
	super mouseEnter: aMouseEnterEvent.
	(Preferences at: #focusFollowsMouse)
		ifTrue: [ aMouseEnterEvent hand newKeyboardFocus: self ]! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:54:50' prior: 16931686!
 mouseEnter: aMouseEnterEvent
	super mouseEnter: aMouseEnterEvent.
	(Preferences at: #focusFollowsMouse)
		ifTrue: [ aMouseEnterEvent hand newKeyboardFocus: self ]! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:56:07' prior: 16931693!
 mouseLeave: aMouseLeaveEvent
	super mouseLeave: aMouseLeaveEvent.
	scroller highlightedRow: nil! !
!TextModelMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:54:57' prior: 16992396!
        mouseEnter: aMouseEnterEvent
	super mouseEnter: aMouseEnterEvent.
	(Preferences at: #focusFollowsMouse)
		ifTrue: [ aMouseEnterEvent hand newKeyboardFocus: scroller ]! !
!TileResizeMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:47:09' prior: 16996146!
mouseHover: aMouseOverEvent localPosition: localEventPosition
	self selectResize: localEventPosition! !
!AutoCompleterMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:55:02' prior: 16785354!
                               mouseEnter: aMouseEnterEvent
	self activeHand newKeyboardFocus: completer textMorph.
	^ super mouseEnter: aMouseEnterEvent! !
!LayoutAdjustingMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:55:09' prior: 16896192!
       mouseEnter: aMouseEnterEvent
	super mouseEnter: aMouseEnterEvent.
	self cursor activateCursor.
	hand := aMouseEnterEvent hand! !
!LayoutAdjustingMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:56:12' prior: 16896198!
    mouseLeave: aMouseLeaveEvent
	super mouseLeave: aMouseLeaveEvent.
	hand ifNotNil: [
		hand := nil.
		Cursor defaultCursor activateCursor ].! !
!ResizeMorph methodsFor: 'events' stamp: 'jmv 9/3/2025 20:57:23' prior: 16948651!
                               mouseMove: aMouseMoveEvent localPosition: localEventPosition
	self selectTo: localEventPosition! !
!HandMorph methodsFor: 'event handling' stamp: 'jmv 9/3/2025 20:59:31' prior: 16878376!
     noticeMouseOver: aMorph event: aMouseOverEvent
	mouseOverHandler ifNil: [ ^self ].
	mouseOverHandler noticeMouseOver: aMorph event: aMouseOverEvent.! !
!DraggingGuideMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 9/3/2025 20:48:26' prior: 16851876!
    justDroppedInto: newOwnerMorph event: aDropEvent 
	
	self delete.
	aDropEvent hand redrawNeeded.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7505-MorphicEvents-cleanup-JuanVuletich-2025Sep03-20h42m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7505] on 4 September 2025 at 10:25:42 am'!
!Morph methodsFor: 'structure' stamp: 'jmv 8/31/2025 18:12:28' prior: 16913668!
                             allOwnersDo: aBlock
	"Evaluate aBlock with all owners of the receiver.
	Start from our owner, go up to top owner."
	
	owner ifNotNil: [ owner withAllOwnersDo: aBlock ]! !
!Morph methodsFor: 'structure' stamp: 'jmv 8/31/2025 18:11:35' prior: 16913674!
     allOwnersReverseDo: aBlock
	"Evaluate aBlock with all owners of the receiver.
	Start from top owner, go down to our owner."

	owner ifNotNil: [ owner withAllOwnersReverseDo: aBlock ]! !
!Morph methodsFor: 'structure' stamp: 'jmv 8/31/2025 18:12:34' prior: 16913747!
                      withAllOwnersDo: aBlock
	"Evaluate aBlock with the receiver and all of its owners.
	Start from us, go up to top owner."

	aBlock value: self.
	owner ifNotNil: [ owner withAllOwnersDo: aBlock ]! !
!Morph methodsFor: 'structure' stamp: 'jmv 8/31/2025 18:11:48' prior: 16913754!
            withAllOwnersReverseDo: aBlock
	"Evaluate aBlock with the receiver and all of its owners.
	Start from top owner, go down to us."

	owner ifNotNil: [ owner withAllOwnersReverseDo: aBlock ].
	aBlock value: self! !
!Morph methodsFor: 'accessing - flags' stamp: 'jmv 9/1/2025 10:23:07' prior: 16910539!
                     visible
	"Answer if I am visible -- default is true.
	Store value of 'hidden' instead, because flags default to false."

	^ (self privateFlagAt: 3) not! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7506-Morph-commentTweaks-JuanVuletich-2025Sep04-10h25m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7505] on 4 September 2025 at 10:32:00 am'!
!Morph methodsFor: 'testing' stamp: 'jmv 9/4/2025 10:30:44'!
                           isReallyUnlocked
	"Answer true only if none in the owner chain is locked (i.e. if we are really unlocked!!)"
	^self isLocked not and: [ owner isReallyUnlocked ]! !
!WorldMorph methodsFor: 'testing' stamp: 'jmv 9/4/2025 10:30:48'!
                          isReallyUnlocked
	"Answer true only if none in the owner chain is locked (i.e. if we are really unlocked!!)"
	^self isLocked not! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 9/4/2025 10:31:05' prior: 16913510!
          potentialEmbeddingTargets
	"Return the potential targets for embedding the receiver"
	| myRect myWorld |
	owner ifNil:[^#()].
	myWorld := owner world ifNil: [^#()].
	myRect := self displayFullBounds.
	^Array streamContents: [ :strm |
		myWorld allMorphsBut: self do: [ :m |
			(m isReallyVisible
			and: [ m isReallyUnlocked
				and: [(m displayFullBounds intersects: myRect)
					and: [(m ~= self)
						and: [(#(HaloMorph HaloHandleMorph) statePointsTo: m class name) not]]]])
		 ifTrue: [ strm nextPut: m ]]].! !

PasteUpMorph removeSelector: #isReallyVisible!

!methodRemoval: PasteUpMorph #isReallyVisible stamp: 'Install-7507-EmbeddingTargets-tweak-JuanVuletich-2025Sep04-10h26m-jmv.001.cs.st 9/5/2025 16:18:27'!
isReallyVisible
	"Answer true only if all the owner chain is visible (i.e. if we are really visible!!)"
	^self visible and: [owner isReallyVisible ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7507-EmbeddingTargets-tweak-JuanVuletich-2025Sep04-10h26m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7507] on 4 September 2025 at 10:50:24 am'!

ListItemWrapper removeSelector: #handlesMouseOver:!

!methodRemoval: ListItemWrapper #handlesMouseOver: stamp: 'Install-7508-Cleanup-JuanVuletich-2025Sep04-10h45m-jmv.001.cs.st 9/5/2025 16:18:27'!
handlesMouseOver: evt

	^false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7508-Cleanup-JuanVuletich-2025Sep04-10h45m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7507] on 4 September 2025 at 11:36:37 am'!
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:35:31'!
                            startDispatchFromHand: aHand
	"double dispatch the event dispatch"
	"An event of an unknown type was sent. What shall we do?!!"

	Smalltalk beep. 
	self printString displayAt: `0@0`.
	self wasHandled: true! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:35:35'!
          startDispatchFromHand: aHand
	"double dispatch the event dispatch"

	aHand startDropEventDispatch: self! !
!DropFilesEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:35:38'!
           startDispatchFromHand: aHand
	"double dispatch the event dispatch"

	aHand startDropFilesEventDispatch: self! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:33:54'!
       dispatchIn: aWorldMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the event position.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."

	| handlerMorph |
	handlerMorph := aWorldMorph morphVisibleAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			self sendEventTo: handlerMorph.
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:35:41'!
startDispatchFromHand: aHand
	"double dispatch the event dispatch"

	aHand startKeyboardDispatch: self! !
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:34:04'!
                dispatchIn: aWorldMorph
	"Dispatch me. The event will be passed to the front-most visible submorph that contains the event position.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."

	| handlerMorph |
	handlerMorph := aWorldMorph morphVisibleAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			self sendEventTo: handlerMorph.
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:35:44'!
   startDispatchFromHand: aHand
	"double dispatch the event dispatch"

	aHand startMouseDispatch: self! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:35:47'!
                  startDispatchFromHand: aHand
	"double dispatch the event dispatch"

	aHand startWindowEventDispatch: self! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:04:15' prior: 50379238!
                          sendEventTo: aMorph
	"Dispatch the receiver into anObject"
"
Revisar senders de
#definesKeyboardShortcuts.
"
	keyEventType == #keystroke ifTrue: [
		self isFindClassShortcut ifTrue: [ 
			(Preferences at: #classFinder) value.
			^self ].
		self isCloseWindowShortcut ifTrue: [
			self closeCurrentWindowOf: aMorph.
			^self ].
		aMorph processKeystroke: self.
		^self ].
	keyEventType == #keyDown ifTrue: [
		aMorph processKeyDown: self.
		^self ].
	keyEventType == #keyUp ifTrue: [ 
		aMorph processKeyUp: self.
		^self ].
	super sendEventTo: aMorph.! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 11:35:59' prior: 16878432!
                          startEventDispatch: aMorphicEvent

	owner ifNil: [ ^ self ].
	aMorphicEvent startDispatchFromHand: self.! !

WindowEvent removeSelector: #startDispatchFrom:!

!methodRemoval: WindowEvent #startDispatchFrom: stamp: 'Install-7509-Cleanup-JuanVuletich-2025Sep04-10h50m-jmv.001.cs.st 9/5/2025 16:18:27'!
startDispatchFrom: aHand
	"double dispatch the event dispatch"

	aHand startWindowEventDispatch: self!

MouseEvent removeSelector: #startDispatchFrom:!

!methodRemoval: MouseEvent #startDispatchFrom: stamp: 'Install-7509-Cleanup-JuanVuletich-2025Sep04-10h50m-jmv.001.cs.st 9/5/2025 16:18:27'!
startDispatchFrom: aHand
	"double dispatch the event dispatch"

	aHand startMouseDispatch: self!

KeyboardEvent removeSelector: #startDispatchFrom:!

!methodRemoval: KeyboardEvent #startDispatchFrom: stamp: 'Install-7509-Cleanup-JuanVuletich-2025Sep04-10h50m-jmv.001.cs.st 9/5/2025 16:18:27'!
startDispatchFrom: aHand
	"double dispatch the event dispatch"

	aHand startKeyboardDispatch: self!

DropFilesEvent removeSelector: #startDispatchFrom:!

!methodRemoval: DropFilesEvent #startDispatchFrom: stamp: 'Install-7509-Cleanup-JuanVuletich-2025Sep04-10h50m-jmv.001.cs.st 9/5/2025 16:18:27'!
startDispatchFrom: aHand
	"double dispatch the event dispatch"

	aHand startDropFilesEventDispatch: self!

DropEvent removeSelector: #startDispatchFrom:!

!methodRemoval: DropEvent #startDispatchFrom: stamp: 'Install-7509-Cleanup-JuanVuletich-2025Sep04-10h50m-jmv.001.cs.st 9/5/2025 16:18:27'!
startDispatchFrom: aHand
	"double dispatch the event dispatch"

	aHand startDropEventDispatch: self!

MorphicEvent removeSelector: #startDispatchFrom:!

!methodRemoval: MorphicEvent #startDispatchFrom: stamp: 'Install-7509-Cleanup-JuanVuletich-2025Sep04-10h50m-jmv.001.cs.st 9/5/2025 16:18:27'!
startDispatchFrom: aHand
	"double dispatch the event dispatch"
	"An event of an unknown type was sent. What shall we do?!!"

	Smalltalk beep. 
	self printString displayAt: `0@0`.
	self wasHandled: true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7509-Cleanup-JuanVuletich-2025Sep04-10h50m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7507] on 4 September 2025 at 12:01:58 pm'!
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:53:04' prior: 50376831!
               dispatchIn: aMorph
	"Dispatch me.
	Different subclasses will use a specific strategy to determine who will handle each event.
	Argument is usually the WorldMorph, but not always. See subclasses."

	self subclassResponsibility! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:41:18' prior: 16916284!
   sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."

	aMorph processUnknownEvent: self! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:41:22' prior: 16851962!
        sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."

	aMorph processDropMorph: self! !
!DropFilesEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:41:25' prior: 16852121!
      sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."

	aMorph processDropFiles: self! !
!UserInputEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:52:47' prior: 50376888!
      dispatchIn: aMorph
	"Dispatch me.
	Different subclasses will use a specific strategy to determine who will handle each event.
	See argument name in subclasses for the specific morph passed in."

	self subclassResponsibility! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:41:29' prior: 50379961!
    sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."
"
Revisar senders de
#definesKeyboardShortcuts.
"
	keyEventType == #keystroke ifTrue: [
		self isFindClassShortcut ifTrue: [ 
			(Preferences at: #classFinder) value.
			^self ].
		self isCloseWindowShortcut ifTrue: [
			self closeCurrentWindowOf: aMorph.
			^self ].
		aMorph processKeystroke: self.
		^self ].
	keyEventType == #keyDown ifTrue: [
		aMorph processKeyDown: self.
		^self ].
	keyEventType == #keyUp ifTrue: [ 
		aMorph processKeyUp: self.
		^self ].
	super sendEventTo: aMorph.! !
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 12:00:33' prior: 50379929!
                             dispatchIn: aWorldMorphOrFocusedMorph
	"Dispatch me.
	The event will be passed to the front-most visible submorph that contains the event position.
	Search usually starts with the WorldMorph, but it could be another morph if it is the hand's #mouseFocus.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."

	| handlerMorph |
	handlerMorph := aWorldMorphOrFocusedMorph morphVisibleAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			self sendEventTo: handlerMorph.
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 12:00:40' prior: 50376908!
     dispatchIn: aWorldMorphOrFocusedMorph
	"Dispatch me.
	The event will be passed to the front-most visible submorph that contains the event position.
	Search usually starts with the WorldMorph, but it could be another morph if it is the hand's #mouseFocus.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."
	
	| handlerMorph grabTheMorph |
	
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchIn: aWorldMorphOrFocusedMorph ].

	handlerMorph := aWorldMorphOrFocusedMorph morphVisibleAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			"aMorph is in the top-most unlocked, visible morph in the chain."
			(self mouseButton3Pressed or: [handlerMorph handlesMouseDown: self])
				ifTrue: [ self sendEventTo: handlerMorph ]
				ifFalse: [
					grabTheMorph := false.
					"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
					self mouseButton1Pressed ifTrue: [
						handlerMorph owner ifNotNil: [ :o |
							(o allowsSubmorphDrag and: [ handlerMorph isSticky not ]) ifTrue: [
								grabTheMorph := true ]]].
					grabTheMorph ifTrue: [
						self hand
							waitForClicksOrDrag: handlerMorph event: self
							dragSel: ((Preferences at: #clickGrabsMorphs) ifFalse: [#dragEvent:localPosition:])
							clkSel: ((Preferences at: #clickGrabsMorphs) ifTrue: [#dragEvent:localPosition:]).
						"false ifTrue: [ self hand grabMorph: aMorph ]."
						(Preferences at: #clickGrabsMorphs) ifFalse: [
							self shiftPressed
								ifTrue: [ (handlerMorph is: #SystemWindow) ifTrue: [ handlerMorph sendToBack ] ]
								ifFalse: [ handlerMorph activateWindow ] ].
						self wasHandled: true ]]
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:41:36' prior: 50379057!
                sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."

	self isMouseDown ifTrue: [
		aMorph processMouseDown: self localPosition: (aMorph internalizeFromWorld: position).
		^self ].
	self isMouseUp ifTrue: [
		aMorph processMouseUp: self localPosition: (aMorph internalizeFromWorld: position).
		^self ].! !
!MouseEnterEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:41:40' prior: 50378968!
          sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."

	aMorph processMouseEnter: self localPosition: (aMorph internalizeFromWorld: position).! !
!MouseLeaveEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:41:44' prior: 50378976!
            sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."

	aMorph processMouseLeave: self localPosition: (aMorph internalizeFromWorld: position).! !
!MouseMoveEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:41:48' prior: 50378984!
             sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."

	aMorph processMouseMove: self localPosition: (aMorph internalizeFromWorld: position).! !
!MouseOverEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:41:51' prior: 50378992!
              sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."

	aMorph processMouseOver: self localPosition: (aMorph internalizeFromWorld: position).! !
!MouseScrollEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 12:00:49' prior: 50376965!
            dispatchIn: aWorldMorphOrFocusedMorph
	"Dispatch me.
	The event will be passed to the front-most visible submorph that contains the event position.
	Search usually starts with the WorldMorph, but it could be another morph if it is the hand's #mouseFocus.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."

	| handlerMorph |
	handlerMorph := aWorldMorphOrFocusedMorph morphVisibleAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			(handlerMorph handlesMouseScroll: self) ifTrue: [
				self sendEventTo: handlerMorph ].
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!MouseScrollEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:41:55' prior: 50379000!
             sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."

	aMorph processMouseScroll: self localPosition: (aMorph internalizeFromWorld: position).! !
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 11:41:59' prior: 17017543!
               sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."

	aMorph processWindowEvent: self.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 11:46:45' prior: 50378787!
      handleMouseFocusEvent: aMouseEvent
	"Handle the given event.
	This message is sent if the receiver currently has the mouse focus
	and is therefore receiving events directly from some hand,
	without going through #dispatchIn:."

	aMouseEvent sendEventTo: self.! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 11:47:37' prior: 50378814!
                              handleMouseFocusEvent: aMouseEvent
	"Handle the given event.
		This message is sent if the receiver currently has the mouse focus
	and is therefore receiving events directly from some hand,
	without going through #dispatchIn:.
		Valid menu transitions are determined based on the menu currently holding the focus 
	after the mouse went down on one of its children."

	"#dispatchIn: and not #sendEventTo: so it is handled by the appropriate menu item."
	aMouseEvent dispatchIn: self.
	
	"Handle clicks outside us, so we are closed. This will only be done if the event wasn't handled above,
	meaning that it is a click outside of us."
	aMouseEvent isMouseButton ifTrue: [
		aMouseEvent sendEventTo: self.
		^self ].
	
	"On MouseMove maybe activate submenu, or owner."
	aMouseEvent isMouseMove ifTrue: [
		"On #mouseMove we might transfer control to *either* the currently active submenu
		or the owner menu, if any.
		Since the active sub menu is always displayed upfront check it first."
		selectedItem ifNotNil: [
			(selectedItem activateSubmenu: aMouseEvent) ifTrue: [
				^self]].
		"Note: The following does not traverse upwards but it's the best I can do for now"
		popUpOwner ifNotNil: [
			(popUpOwner activateOwnerMenu: aMouseEvent) ifTrue: [
				^self]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7510-BetterArgNamesAndComments-JuanVuletich-2025Sep04-11h36m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7507] on 4 September 2025 at 12:13:40 pm'!
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 12:04:33' prior: 50379904!
dispatchIn: focusedMorph
	"Dispatch me.
	The event will be passed to focusedMorph.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner.
	Note: event position is usually irrelevant for KeyboardEvents."

	| handlerMorph |
	handlerMorph := focusedMorph.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		(handlerMorph rejectsEvent: self) not ifTrue: [
			
			self sendEventTo: handlerMorph.
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 12:12:05' prior: 50380095!
        sendEventTo: aMorph
	"Event dispatch finished. Deliver us straight to aMorph for execution."
"
Revisar senders de
#definesKeyboardShortcuts.
"
	keyEventType == #keystroke ifTrue: [
		self isFindClassShortcut ifTrue: [ 
			(Preferences at: #classFinder) value.
			self wasHandled: true.
			^self ].
		self isCloseWindowShortcut ifTrue: [
			self closeCurrentWindowOf: aMorph.
			self wasHandled: true.
			^self ].
		aMorph processKeystroke: self.
		^self ].
	keyEventType == #keyDown ifTrue: [
		aMorph processKeyDown: self.
		^self ].
	keyEventType == #keyUp ifTrue: [ 
		aMorph processKeyUp: self.
		^self ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7511-wasHandledFlag-refactor-JuanVuletich-2025Sep04-12h01m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7507] on 4 September 2025 at 1:03:30 pm'!
!WindowEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 12:18:57' prior: 50376986!
                    dispatchIn: aWorldMorph
	"Host window events do not have a position and are only dispatched to the World"

	self wasHandled not ifTrue: [
		self sendEventTo: aWorldMorph ].! !
!Morph methodsFor: 'events' stamp: 'jmv 9/4/2025 12:31:43' prior: 16911180!
    keyStroke: aKeyboardEvent
	"Handle a keystroke event.
	Subclasses should call super, and check if the event was handled."

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [
			aKeyboardEvent wasHandled: true.
			^self ].

	aKeyboardEvent anyModifierKeyPressed ifTrue: [
		(self keyboardShortcut: aKeyboardEvent)
			ifTrue: [ aKeyboardEvent wasHandled: true ]].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 12:27:44' prior: 16911684!
                          processDropFiles: aDropFilesEvent
	"Handle a dropping file."
	
	aDropFilesEvent wasHandled: true.
	self dropFiles: aDropFilesEvent.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 12:27:30' prior: 16911693!
  processDropMorph: aDropEvent
	"Handle a dropping morph."

	| aMorph |
	aMorph := aDropEvent contents.
	aDropEvent wasHandled: true.
	aMorph justDroppedInto: self event: aDropEvent.
	self acceptDroppingMorph: aMorph event: aDropEvent.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 12:28:59' prior: 16912280!
                            processKeyDown: aKeyboardEvent
	"System level event handling."

	self handlesKeyboard ifFalse: [^self].
	aKeyboardEvent wasHandled: true.
	self keyDown: aKeyboardEvent.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 12:29:23' prior: 16911706!
                             processKeyUp: aKeyboardEvent
	"System level event handling."

	self handlesKeyboard ifFalse: [^self].
	aKeyboardEvent wasHandled: true.
	self keyUp: aKeyboardEvent! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 12:28:37' prior: 16911715!
  processKeystroke: aKeyboardEvent
	"System level event handling."

	self handlesKeyboard ifTrue: [
		self keyStroke: aKeyboardEvent.
		aKeyboardEvent wasHandled: true.
		self 
			valueOfProperty: #'keyStroke:'
			ifPresentDo: [ :handler | handler value: aKeyboardEvent ]].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 12:39:42' prior: 16911899!
                      processWindowEvent: aWindowEvent
	"Handle an event concerning our host window"

	(self wantsWindowEvent: aWindowEvent) ifFalse: [^self].
	aWindowEvent wasHandled: true.
	self windowEvent: aWindowEvent.
! !
!FindInSourceDialog methodsFor: 'events' stamp: 'jmv 9/4/2025 12:50:47' prior: 16869168!
                         keyStroke: aKeyboardEvent
	"Avoid the need to give focus to subwidgets"

	(aKeyboardEvent isArrowUp or: [  aKeyboardEvent isArrowDown ]) ifTrue: [
		scopeList keyStroke: aKeyboardEvent.
		aKeyboardEvent wasHandled: true.
		^self ].
	aKeyboardEvent isReturnKey ifTrue: [
		self ok.
		aKeyboardEvent wasHandled: true.
		^self ].
	aKeyboardEvent isEsc ifTrue: [
		self cancel.
		aKeyboardEvent wasHandled: true.
		^self ].
	searchField keyStroke: aKeyboardEvent.! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 9/4/2025 12:53:35' prior: 16900997!
 keyStroke: aKeyboardEvent
	| matchString selectable |
	aKeyboardEvent isReturnKey
		ifTrue: [
			selectedItem ifNotNil: [
				selectedItem hasSubMenu 
					ifTrue: [
						aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
						aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
					ifFalse: [
						selectedItem invokeWithEvent: aKeyboardEvent].
				aKeyboardEvent wasHandled: true.
				^self ].
			(selectable := self items) size = 1 
				ifTrue: [
					selectable first invokeWithEvent: aKeyboardEvent ].
			"Consume the event in any case"
			aKeyboardEvent wasHandled: true.
			^self].
	aKeyboardEvent isEsc
		ifTrue: [
			"escape key"
			self
				valueOfProperty: #matchString
				ifPresentDo: [ :str | 
					str isEmpty 
						ifFalse: [
							"If filtered, first ESC removes filter"
							self setProperty: #matchString toValue: String new.
							self selectItem: nil.
							self displayFiltered: aKeyboardEvent.
							aKeyboardEvent wasHandled: true.
							^self]].
			"If a stand-alone menu, just delete it"
			self delete.
			aKeyboardEvent hand
				newKeyboardFocus: prevKbdFocus;
				newMouseFocus: prevMouseFocus.
			aKeyboardEvent wasHandled: true.
			^self].
	aKeyboardEvent isArrowLeft | aKeyboardEvent isArrowRight
		ifTrue: [
			"left or right arrow key"
			(selectedItem notNil and: [selectedItem hasSubMenu]) 
				ifTrue: [
					aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
					selectedItem subMenu moveSelectionDown: 1 event: aKeyboardEvent.
					aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu ].
			"Consume the event in any case"
			aKeyboardEvent wasHandled: true.
			^self].
	aKeyboardEvent isArrowUp ifTrue: [aKeyboardEvent wasHandled: true.^self moveSelectionDown: -1 event: aKeyboardEvent].	"up arrow key"
	aKeyboardEvent isArrowDown ifTrue: [aKeyboardEvent wasHandled: true.^self moveSelectionDown: 1 event: aKeyboardEvent].	"down arrow key"
	aKeyboardEvent isPageUp ifTrue: [aKeyboardEvent wasHandled: true.^self moveSelectionDown: -5 event: aKeyboardEvent].	"page up key"
	aKeyboardEvent isPageDown ifTrue: [aKeyboardEvent wasHandled: true.^self moveSelectionDown: 5 event: aKeyboardEvent].	"page down key"
	matchString := self valueOfProperty: #matchString ifAbsent: [String new].
	matchString := aKeyboardEvent isBackspace
				ifTrue: [matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]
				ifFalse: [matchString copyWith: aKeyboardEvent keyCharacter].
	self setProperty: #matchString toValue: matchString.
	self displayFiltered: aKeyboardEvent.
	aKeyboardEvent wasHandled: true.! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 12:22:21' prior: 50380307!
       handleMouseFocusEvent: aMouseEvent
	"Handle the given event.
		This message is sent if the receiver currently has the mouse focus
	and is therefore receiving events directly from some hand,
	without going through #dispatchIn:.
		Valid menu transitions are determined based on the menu currently holding the focus 
	after the mouse went down on one of its children."

	"#dispatchIn: and not #sendEventTo: so it is handled by the appropriate menu item."
	aMouseEvent dispatchIn: self.
	
	"Handle clicks outside us, so we are closed. This will only be done if the event wasn't handled above,
	meaning that it is a click outside of us."
	aMouseEvent isMouseButton ifTrue: [
		aMouseEvent sendEventTo: self.
		^self ].
	
	"On MouseMove maybe activate submenu, or owner."
	aMouseEvent isMouseMove ifTrue: [
		"On #mouseMove we might transfer control to *either* the currently active submenu
		or the owner menu, if any.
		Since the active sub menu is always displayed upfront check it first."
		selectedItem ifNotNil: [
			(selectedItem activateSubmenu: aMouseEvent) ifTrue: [
				^self]].
		"Note: The following does not traverse upwards but it's the best I can do for now"
		popUpOwner ifNotNil: [
			(popUpOwner activateOwnerMenu: aMouseEvent) ifTrue: [
				^self]]].! !
!EntryFieldMorph methodsFor: 'events' stamp: 'jmv 9/4/2025 12:58:32' prior: 16859277!
                      keyStroke: aKeyboardEvent
	"Handle a keystroke event."
	
	super keyStroke: aKeyboardEvent.
	aKeyboardEvent wasHandled ifTrue: [
		contents := self editor string.
		self morphExtent: (self morphExtent max: self minimumExtent). "big enough to fit"
		self redrawNeeded.
		^self ].
	
	self pauseBlinking.

	"All the cases below consume the event."
	aKeyboardEvent wasHandled: true.

	"Return - check for special action"
	aKeyboardEvent isReturnKey ifTrue: [
		self crAction ifNotNil: [ :action |
			action value.
			^self ]].

	"Esc - check for special action"
	aKeyboardEvent isEsc ifTrue: [
		self escAction ifNotNil: [ :action |
			action value.
			^self  ]].

	self editor processKeystrokeEvent: aKeyboardEvent.
	contents := self editor string.
	self morphExtent: (self morphExtent max: self minimumExtent). "big enough to fit"
	self redrawNeeded.! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 9/4/2025 12:57:14' prior: 16879943!
                 keyStroke: aKeyboardEvent 
	"Process potential command keys"

	super keyStroke: aKeyboardEvent.
	aKeyboardEvent wasHandled ifTrue: [ ^self ].

	(self arrowKey: aKeyboardEvent) ifNotNil: [
		aKeyboardEvent wasHandled: true.
		^self ].

	aKeyboardEvent isEsc ifTrue: [
		" escape key"
		self mouseButton2Activity.
		aKeyboardEvent wasHandled: true ].! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 9/4/2025 12:58:51' prior: 16931615!
       keyStroke: aKeyboardEvent 
	"Process keys"

	| aCharacter |
	super keyStroke: aKeyboardEvent.
	aKeyboardEvent wasHandled ifTrue: [ ^self ].
	
	(self arrowKey: aKeyboardEvent) ifNotNil: [
		aKeyboardEvent wasHandled: true.
		^self ].

	"All the cases below consume the event."
	aKeyboardEvent wasHandled: true.
	aKeyboardEvent isReturnKey ifTrue: [
		doubleClickSelector notNil ifTrue: [(self window ifNil: [model]) perform: doubleClickSelector].
		^self].
	aKeyboardEvent isEsc ifTrue: [
		self mouseButton2Activity.
		^self ].
	aKeyboardEvent isDelete ifTrue: [
		self deleteAction.
		^self ].
	aKeyboardEvent isBackspace ifTrue: [
		self deleteAction.
		^self ].
	
	aCharacter := aKeyboardEvent keyCharacter.
	self keyboardSearch: aCharacter! !
!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 9/4/2025 13:02:18' prior: 16932009!
                      keyboardSearch: aChar
	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |
	nextSelection := oldSelection := self getCurrentSelectionIndex.
	max := self maximumSelection.
	milliSeconds := Time localMillisecondClock.
	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"
		lastKeystrokes := ''].
	lastKeystrokes := lastKeystrokes copyWith: aChar asLowercase.
	lastKeystrokeTime := milliSeconds.
	nextSelectionList := OrderedCollection newFrom: (list copyFrom: oldSelection + 1 to: max).
	nextSelectionList addAll: (list copyFrom: 1 to: oldSelection).
	"Get rid of blanks and style used in some lists"
	nextSelectionText := nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]
				ifNone: [^ self flash"match not found"].
	self owningWindow ifNotNil: [ :w |
		(w okToChangeDueTo: self) ifFalse: [^ self]].
	nextSelection := list findFirst: [:a | a == nextSelectionText].
	"No change if model is locked"
	oldSelection == nextSelection ifTrue: [^ self flash].
	self setSelectionIndex: nextSelection! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 12:21:11' prior: 50378071!
 startKeyboardDispatch: aKeyboardEvent

	| focusedElement |
	
	focusedElement := self keyboardFocus ifNil: [ self world ].
	aKeyboardEvent wasHandled not ifTrue: [
		aKeyboardEvent sendEventTo: focusedElement ].
	self mouseOverHandler processMouseOver: lastMouseEvent! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7512-wasHandledFlag-refactor-JuanVuletich-2025Sep04-12h13m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7507] on 4 September 2025 at 1:07:56 pm'!
!Morph methodsFor: 'events' stamp: 'jmv 9/4/2025 13:04:49' prior: 50378775!
                      keyDown: aKeyboardEvent
	"Handle a key down event. The default response is to do nothing."
	
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #'keyDown:' 
		ifPresentDo: [ :handler |
			handler value: aKeyboardEvent.
			aKeyboardEvent wasHandled: true ]! !
!Morph methodsFor: 'events' stamp: 'jmv 9/4/2025 13:05:01' prior: 50379482!
                             keyUp: aKeyboardEvent
	"Handle a key up event. The default response is to do nothing."
	
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #'keyUp:'
		ifPresentDo: [ :handler |
			handler value: aKeyboardEvent.
			aKeyboardEvent wasHandled: true ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:06:33' prior: 50380446!
                         processKeyDown: aKeyboardEvent
	"System level event handling."

	self handlesKeyboard ifFalse: [^self].
	"#keyDown: must set the event as #wasHandled: true if it effectively was."
	self keyDown: aKeyboardEvent.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:06:39' prior: 50380455!
                   processKeyUp: aKeyboardEvent
	"System level event handling."

	self handlesKeyboard ifFalse: [^self].
	"#keyUp: must set the event as #wasHandled: true if it effectively was."
	self keyUp: aKeyboardEvent.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:06:22' prior: 50380463!
                         processKeystroke: aKeyboardEvent
	"System level event handling."

	self handlesKeyboard ifTrue: [
		"#keyStroke: must set the event as #wasHandled: true if it effectively was."
		self keyStroke: aKeyboardEvent.
		self 
			valueOfProperty: #'keyStroke:'
			ifPresentDo: [ :handler |
				handler value: aKeyboardEvent.
				aKeyboardEvent wasHandled: true ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7513-wasHandledFlag-refactor-JuanVuletich-2025Sep04-13h03m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7507] on 4 September 2025 at 1:12:45 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:10:18' prior: 50380783!
                 processKeyDown: aKeyboardEvent
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	self handlesKeyboard ifFalse: [^self].
	self keyDown: aKeyboardEvent.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:10:27' prior: 50380793!
                           processKeyUp: aKeyboardEvent
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	self handlesKeyboard ifFalse: [^self].
	self keyUp: aKeyboardEvent.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:10:34' prior: 50380803!
                               processKeystroke: aKeyboardEvent
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	self handlesKeyboard ifTrue: [
		self keyStroke: aKeyboardEvent.
		self 
			valueOfProperty: #'keyStroke:'
			ifPresentDo: [ :handler |
				handler value: aKeyboardEvent.
				aKeyboardEvent wasHandled: true ]].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:10:44' prior: 50376083!
            processMouseDown: aMouseButtonEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	aMouseButtonEvent wasHandled ifTrue: [ ^self ]. "not interested"
	aMouseButtonEvent hand removePendingBalloonFor: self.
	aMouseButtonEvent wasHandled: true.
	self activateWindow.
	aMouseButtonEvent hand newMouseFocus: self.		"Mouse down sets mouse focus"

	aMouseButtonEvent mouseButton2Pressed ifTrue: [
		self mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition.
		aMouseButtonEvent hand removeHaloFromClick: aMouseButtonEvent on: self.
		^self ].

	aMouseButtonEvent mouseButton3Pressed ifTrue: [
		self mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition.
		^self ].

	self mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
	aMouseButtonEvent hand removeHaloFromClick: aMouseButtonEvent on: self.

	(self handlesMouseStillDown: aMouseButtonEvent) ifTrue:[
		self startStepping: #processMouseStillDown
			in: self mouseStillDownThreshold
			stepTime: self mouseStillDownStepRate ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:10:50' prior: 50379377!
            processMouseEnter: aMouseEnterEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	aMouseEnterEvent isDraggingEvent ifTrue: [
		^self].
	self wantsBalloon ifTrue: [
		aMouseEnterEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: aMouseEnterEvent) ifTrue: [
		aMouseEnterEvent wasHandled: true.
		self mouseEnter: aMouseEnterEvent ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:10:55' prior: 50379393!
                    processMouseLeave: aMouseLeaveEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	aMouseLeaveEvent hand removePendingBalloonFor: self.
	aMouseLeaveEvent isDraggingEvent ifTrue: [
		^self].
	(self handlesMouseOver: aMouseLeaveEvent) ifTrue: [
		aMouseLeaveEvent wasHandled: true.
		self mouseLeave: aMouseLeaveEvent ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:10:59' prior: 16911789!
              processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	aMouseMoveEvent wasHandled ifTrue: [ ^self ]. "not interested"
	"Rules say that by default a morph gets #mouseMove iff
		* the hand is not dragging anything,
			+ and some button is down,
			+ and the receiver is the current mouse focus."
	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue: [
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1 ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:11:04' prior: 50379546!
           processMouseOver: aMouseOverEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	 self hasMouseFocus ifTrue: [
		"Got this directly through #handleFocusEvent: so check explicitly"
		((self rejectsEvent: aMouseOverEvent) not and: [self fullIncludesPixel: aMouseOverEvent eventPosition]) ifFalse: [
			^self ]].
	aMouseOverEvent hand noticeMouseOver: self event: aMouseOverEvent.
	"Open question: should any unhandled mouse move events be filtered out? (i.e. should mouseHover:localPosition: be called when a mouse button is pressed but the morph doesn't have mouse button handlers?  Essentially, what are the limits of what is considered 'hovering'?"
	(self handlesMouseHover and: [aMouseOverEvent wasHandled not]) ifTrue: [
		self
			mouseHover: aMouseOverEvent
			localPosition: localEventPosition ].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:11:09' prior: 50376119!
          processMouseUp: aMouseButtonEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	aMouseButtonEvent wasHandled ifTrue: [^self]. "not interested"
	aMouseButtonEvent hand releaseMouseFocus: self.
	aMouseButtonEvent wasHandled: true.
	aMouseButtonEvent mouseButton3Changed ifTrue: [ 
		self mouseButton3Up: aMouseButtonEvent localPosition: localEventPosition.
		^self ].

	aMouseButtonEvent mouseButton2Changed ifTrue: [
		self mouseButton2Up: aMouseButtonEvent localPosition: localEventPosition.
		^self ].
	
	self mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition.
	self stopStepping: #processMouseStillDown! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:12:19' prior: 50379407!
                     processMouseEnter: aMouseEnterEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	"Do #mouseEnter: even if button down (others, like LayoutAdjustingMorph need the default behavior)"
	
	self wantsBalloon ifTrue: [
		aMouseEnterEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: aMouseEnterEvent) ifTrue:[
		aMouseEnterEvent wasHandled: true.
		self mouseEnter: aMouseEnterEvent ]! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:12:24' prior: 50379424!
                            processMouseLeave: aMouseLeaveEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	"Do #mouseLeave: even if button down (others, like LayoutAdjustingMorph need the default behavior)"
	
	aMouseLeaveEvent hand removePendingBalloonFor: self.
	(self handlesMouseOver: aMouseLeaveEvent) ifTrue: [
		aMouseLeaveEvent wasHandled: true.
		self mouseLeave: aMouseLeaveEvent ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7514-BetterComments-JuanVuletich-2025Sep04-13h07m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7507] on 4 September 2025 at 1:17:29 pm'!
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:17:16' prior: 50381016!
               processMouseEnter: aMouseEnterEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	self wantsBalloon ifTrue: [
		aMouseEnterEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: aMouseEnterEvent) ifTrue:[
		aMouseEnterEvent wasHandled: true.
		self mouseEnter: aMouseEnterEvent ]! !
!MenuItemMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:17:21' prior: 50381036!
   processMouseLeave: aMouseLeaveEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	aMouseLeaveEvent hand removePendingBalloonFor: self.
	(self handlesMouseOver: aMouseLeaveEvent) ifTrue: [
		aMouseLeaveEvent wasHandled: true.
		self mouseLeave: aMouseLeaveEvent ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7515-BetterComments-JuanVuletich-2025Sep04-13h12m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7515] on 4 September 2025 at 1:49:00 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:31:26' prior: 50380859!
                             processMouseDown: aMouseButtonEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	aMouseButtonEvent hand removePendingBalloonFor: self.
	aMouseButtonEvent wasHandled: true.
	self activateWindow.
	aMouseButtonEvent hand newMouseFocus: self.		"Mouse down sets mouse focus"

	aMouseButtonEvent mouseButton2Pressed ifTrue: [
		self mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition.
		aMouseButtonEvent hand removeHaloFromClick: aMouseButtonEvent on: self.
		^self ].

	aMouseButtonEvent mouseButton3Pressed ifTrue: [
		self mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition.
		^self ].

	self mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
	aMouseButtonEvent hand removeHaloFromClick: aMouseButtonEvent on: self.

	(self handlesMouseStillDown: aMouseButtonEvent) ifTrue:[
		self startStepping: #processMouseStillDown
			in: self mouseStillDownThreshold
			stepTime: self mouseStillDownStepRate ].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:31:43' prior: 50380931!
             processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	"Rules say that by default a morph gets #mouseMove iff
		* the hand is not dragging anything,
			+ and some button is down,
			+ and the receiver is the current mouse focus."
	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue: [
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1 ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:37:23' prior: 50380959!
           processMouseOver: aMouseOverEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	 self hasMouseFocus ifTrue: [
		"Got this directly through #handleFocusEvent: so check explicitly"
		((self rejectsEvent: aMouseOverEvent) not and: [self fullIncludesPixel: aMouseOverEvent eventPosition]) ifFalse: [
			^self ]].
	aMouseOverEvent hand noticeMouseOver: self event: aMouseOverEvent.
	"Open question: should any unhandled mouse move events be filtered out? (i.e. should mouseHover:localPosition: be called when a mouse button is pressed but the morph doesn't have mouse button handlers?  Essentially, what are the limits of what is considered 'hovering'?"
	self handlesMouseHover ifTrue: [
		self
			mouseHover: aMouseOverEvent
			localPosition: localEventPosition ].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:33:22' prior: 50379575!
                  processMouseScroll: aMouseScrollEvent localPosition: localEventPosition

	(self handlesMouseScroll: aMouseScrollEvent) ifTrue: [
		self
			mouseScroll: aMouseScrollEvent
			localPosition: localEventPosition.
		aMouseScrollEvent wasHandled: true ].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:32:22' prior: 50380990!
              processMouseUp: aMouseButtonEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	aMouseButtonEvent hand releaseMouseFocus: self.
	aMouseButtonEvent wasHandled: true.
	aMouseButtonEvent mouseButton3Changed ifTrue: [ 
		self mouseButton3Up: aMouseButtonEvent localPosition: localEventPosition.
		^self ].

	aMouseButtonEvent mouseButton2Changed ifTrue: [
		self mouseButton2Up: aMouseButtonEvent localPosition: localEventPosition.
		^self ].
	
	self mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition.
	self stopStepping: #processMouseStillDown! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:48:51' prior: 50380586!
                         handleMouseFocusEvent: aMouseEvent
	"Handle the given event.
		This message is sent if the receiver currently has the mouse focus
	and is therefore receiving events directly from some hand,
	without going through #dispatchIn:.
		Valid menu transitions are determined based on the menu currently holding the focus 
	after the mouse went down on one of its children."

	"#dispatchIn: and not #sendEventTo: so it is handled by the appropriate menu item."
	aMouseEvent dispatchIn: self.
	
	"If it is a mouse event and it wasn't handled, still deliver it to us: it may have been a click outside us,
	and then, we need to be closed. See MenuMorph >> #mouseButton1Down:localPosition:"
	aMouseEvent isMouseButton ifTrue: [
		aMouseEvent wasHandled ifFalse: [
			aMouseEvent sendEventTo: self.
			^self ]].
	
	"On MouseMove maybe activate submenu, or owner."
	aMouseEvent isMouseMove ifTrue: [
		"On #mouseMove we might transfer control to *either* the currently active submenu
		or the owner menu, if any.
		Since the active sub menu is always displayed upfront check it first."
		selectedItem ifNotNil: [
			(selectedItem activateSubmenu: aMouseEvent) ifTrue: [
				^self]].
		"Note: The following does not traverse upwards but it's the best I can do for now"
		popUpOwner ifNotNil: [
			(popUpOwner activateOwnerMenu: aMouseEvent) ifTrue: [
				^self]]].! !
!HierarchicalListMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:31:52' prior: 16880008!
                 processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"

	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue: [
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1 ]! !
!PluggableListMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:31:57' prior: 50334636!
processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"

	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	scroller highlightedRow: (
		(self viewableArea containsPoint: localEventPosition) ifTrue: [
			self rowAtLocation: localEventPosition ifNone: nil]).
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1 ]! !
!InnerTextMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 13:32:02' prior: 16887314!
              processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Re-implemented to allow for mouse-up move events"

	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7516-wasHandledFlag-refactor-JuanVuletich-2025Sep04-13h42m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7516] on 4 September 2025 at 2:54:56 pm'!
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 14:54:40' prior: 50378858!
                         startMouseDispatch: aMouseEvent

	aMouseEvent isMouseOver ifTrue: [
		self mouseFocus
			ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
			ifNil: [ aMouseEvent dispatchIn: owner ].
		^self].

	"any mouse event but mouseOver"
	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			self mouseOverHandler processMouseOver: lastMouseEvent.
			^self ]].

	aMouseEvent isMouseMove
		ifTrue: [
			self morphPosition: aMouseEvent eventPosition.
			self mouseFocus
				ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
				ifNil: [ aMouseEvent dispatchIn: owner ]
		] ifFalse: [
		aMouseEvent isMouseScroll ifTrue: [
			aMouseEvent dispatchIn: owner
		] ifFalse: [
			"Issue a synthetic move event if we're not at the position of the event"
			aMouseEvent eventPosition = self morphPosition ifFalse: [
				"Issue a mouse move event to make the receiver appear at the given position"
				(MouseMoveEvent new
					setPosition: aMouseEvent eventPosition
					buttons: aMouseEvent buttons
					hand: self
					stamp: aMouseEvent timeStamp) startDispatchFromHand: self ].
			"Drop submorphs on button events"
			self hasSubmorphs
				ifTrue: [
					"Not if we are grabbing them"
					mouseClickState ifNil: [
						"Want to drop on mouseUp, NOT mouseDown"
						aMouseEvent isMouseUp ifTrue: [
							self dropMorphs: aMouseEvent ]
					]
				] ifFalse: [
					self mouseFocus
						ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
						ifNil: [ aMouseEvent dispatchIn: owner ]]]].
		self mouseOverHandler processMouseOver: lastMouseEvent.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7517-MouseEventDispatchRefactor-JuanVuletich-2025Sep04-14h54m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7517] on 4 September 2025 at 4:18:44 pm'!
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 15:10:43'!
                             startDispatchFromHand: aHand
	"double dispatch the event dispatch"

	aHand startMouseButtonDispatch: self! !
!MouseMoveEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 15:11:18'!
         startDispatchFromHand: aHand
	"double dispatch the event dispatch"

	aHand startMouseMoveDispatch: self! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 15:48:22'!
          startMouseButtonDispatch: aMouseEvent

	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			self mouseOverHandler processMouseOver: lastMouseEvent.
			^self ]].

	"Issue a synthetic move event if we're not at the position of the event"
	aMouseEvent eventPosition = self morphPosition ifFalse: [
		"Issue a mouse move event to make the receiver appear at the given position"
		(MouseMoveEvent new
			setPosition: aMouseEvent eventPosition
			buttons: aMouseEvent buttons
			hand: self
			stamp: aMouseEvent timeStamp) startDispatchFromHand: self ].

	"Drop submorphs on button events"
	self hasSubmorphs
		ifTrue: [
			"Not if we are grabbing them"
			mouseClickState ifNil: [
				"Want to drop on mouseUp, NOT mouseDown"
				aMouseEvent isMouseUp ifTrue: [
					self dropMorphs: aMouseEvent ]]]
		ifFalse: [
			self mouseFocus
				ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
				ifNil: [ aMouseEvent dispatchIn: owner ]].

	self mouseOverHandler processMouseOver: lastMouseEvent.! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 15:43:48'!
    startMouseMoveDispatch: aMouseEvent

	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		mouseClickState handleEvent: aMouseEvent from: self ].

	self morphPosition: aMouseEvent eventPosition.
	self mouseFocus
		ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
		ifNil: [ aMouseEvent dispatchIn: owner ].
		
	self mouseOverHandler processMouseOver: lastMouseEvent.! !
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 15:41:31' prior: 50379948!
                         startDispatchFromHand: aHand
	"double dispatch the event dispatch
	Generic MouseEvent behavior. See inheritance."

	aHand startMouseDispatch: self! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 15:41:07' prior: 50381344!
               startMouseDispatch: aMouseEvent
	"For MouseEvents with default dispatch behavior"

	self hasSubmorphs
		ifFalse: [
			self mouseFocus
				ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
				ifNil: [ aMouseEvent dispatchIn: owner ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7518-MouseEventDispatchRefactor-JuanVuletich-2025Sep04-16h16m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7516] on 4 September 2025 at 4:02:21 pm'!
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 15:56:13' prior: 50378001!
                          startDropEventDispatch: aDropEvent

	aDropEvent dispatchIn: owner.! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 15:56:03' prior: 50377771!
                               startDropFilesEventDispatch: aDropFilesEvent

	aDropFilesEvent dispatchIn: owner.! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 15:57:40' prior: 50380738!
                startKeyboardDispatch: aKeyboardEvent

	| focusedElement |
	
	focusedElement := self keyboardFocus ifNil: [ self world ].
	aKeyboardEvent wasHandled not ifTrue: [
		aKeyboardEvent sendEventTo: focusedElement ].! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 15:58:18' prior: 50381424!
               startMouseButtonDispatch: aMouseEvent

	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			aMouseEvent wasHandled: true.
			^self ]].

	"Issue a synthetic move event if we're not at the position of the event"
	aMouseEvent eventPosition = self morphPosition ifFalse: [
		"Issue a mouse move event to make the receiver appear at the given position"
		(MouseMoveEvent new
			setPosition: aMouseEvent eventPosition
			buttons: aMouseEvent buttons
			hand: self
			stamp: aMouseEvent timeStamp) startDispatchFromHand: self ].

	"Drop submorphs on button events"
	self hasSubmorphs
		ifTrue: [
			"Not if we are grabbing them"
			mouseClickState ifNil: [
				"Want to drop on mouseUp, NOT mouseDown"
				aMouseEvent isMouseUp ifTrue: [
					self dropMorphs: aMouseEvent ]]]
		ifFalse: [
			self mouseFocus
				ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
				ifNil: [ aMouseEvent dispatchIn: owner ]].
		
	self mouseOverHandler processMouseOver: lastMouseEvent.! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 15:55:43' prior: 50377840!
            startWindowEventDispatch: aWindowEvent

	aWindowEvent dispatchIn: owner.! !
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 9/4/2025 15:57:30' prior: 50377847!
                         dropMorph: aMorph event: aMouseEvent
	"Drop the given morph which was carried by the hand"
	| morphData dropEvent |
	morphData := self grabMorphDataFor: aMorph.
	dropEvent := DropEvent new 
			setPosition: self morphPosition 
			contents: aMorph 
			hand: self
			formerOwner: (morphData at: 1)
			formerPosition: (morphData at: 2).
	dropEvent dispatchIn: owner.
	dropEvent wasHandled ifFalse: [ aMorph rejectDropMorphEvent: dropEvent ].
	self forgetGrabMorphDataFor: aMorph.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7519-MouseEventDispatch-simplify-JuanVuletich-2025Sep04-15h52m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7519] on 4 September 2025 at 4:40:30 pm'!
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 9/4/2025 16:07:29' prior: 50377626!
              processMouseOver: aMouseEvent
	"Re-establish the z-order for all morphs wrt the given event"

	| hand focus evt |
	hand := aMouseEvent hand.
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	"Now go looking for eventual mouse overs"
	aMouseEvent asMouseOver startDispatchFromHand: hand.
	"Get out early if there's no change"
	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."
		(leftMorphs isEmpty and: [enteredMorphs position = 0])])
		ifTrue: [
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self].
	focus := hand mouseFocus.
	"Send #mouseLeave as appropriate"
	evt := aMouseEvent asMouseLeave.
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [evt sendEventTo: m ]
				ifFalse: [overMorphs nextPut: m]]].
	"Send #mouseEnter as appropriate"
	evt := aMouseEvent asMouseEnter.
	enteredMorphs ifNil: [
		"inform: was called in handleEvent:"
		leftMorphs := enteredMorphs := overMorphs := nil.
		^self].
	enteredMorphs := enteredMorphs contents.
	enteredMorphs reverseDo: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [evt sendEventTo: m ]]].
	"And remember the over list"
	overMorphs ifNil: [
			"inform: was called in handleEvent:"
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self].
	mouseOverMorphs := overMorphs contents.
	leftMorphs := enteredMorphs := overMorphs := nil! !
!HandMorph methodsFor: 'event handling' stamp: 'jmv 9/4/2025 16:07:16' prior: 50338302!
   processEventQueue
	"Process user input events from the local input devices.
	Answer true if any event was handled (but ignore MouseMove)"

	| evt evtBuf type hadAny mcs hadAnyMouseEvent hadAnyMouseMoveEvent |
	mcs := mouseClickState.
	hadAny := false.
	hadAnyMouseEvent := false.
	hadAnyMouseMoveEvent := false.
	[ (evtBuf := Sensor nextEvent) isNil ] whileFalse: [
		type := evtBuf first.
		evt := self createEventFrom: evtBuf ofType: type.
		evt ifNotNil: [
			"Finally, handle it. But process only up to one mouseMove per cycle. Discard the rest."
			(evt isMouseMove and: [ hadAnyMouseMoveEvent ]) ifFalse: [
				evt startDispatchFromHand: self.
				(evt isMouse or: [ evt isKeyboard ]) ifTrue: [
					hadAny := true ].
				evt isMouse ifTrue: [
					hadAnyMouseEvent := true.
					evt isMouseMove ifTrue: [
						hadAnyMouseMoveEvent := true ]]]]].
	hadAnyMouseEvent ifFalse: [
		mcs 
			ifNotNil: [ 
				"No mouse events during this cycle. Make sure click states time out accordingly"
				mcs handleEvent: lastMouseEvent asMouseMove from: self ]].
	^hadAny! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7520-startEventDispatch-simplify1-JuanVuletich-2025Sep04-16h40m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7519] on 4 September 2025 at 4:40:44 pm'!

HandMorph removeSelector: #startEventDispatch:!

!methodRemoval: HandMorph #startEventDispatch: stamp: 'Install-7521-startEventDispatch-simplify2-JuanVuletich-2025Sep04-16h40m-jmv.001.cs.st 9/5/2025 16:18:28'!
startEventDispatch: aMorphicEvent

	owner ifNil: [ ^ self ].
	aMorphicEvent startDispatchFromHand: self.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7521-startEventDispatch-simplify2-JuanVuletich-2025Sep04-16h40m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7520] on 4 September 2025 at 4:23:17 pm'!
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/4/2025 16:06:00'!
    startGenericEventDispatch: aMorphicEvent

	aMorphicEvent dispatchIn: owner.! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 9/4/2025 16:06:06' prior: 50379883!
                         startDispatchFromHand: aHand
	"double dispatch the event dispatch"

	aHand startGenericEventDispatch: self.! !

HandMorph removeSelector: #startDropEventDispatch:!

!methodRemoval: HandMorph #startDropEventDispatch: stamp: 'Install-7522-startEventDispatch-simplify-JuanVuletich-2025Sep04-16h23m-jmv.001.cs.st 9/5/2025 16:18:28'!
startDropEventDispatch: aDropEvent

	aDropEvent dispatchIn: owner.!

HandMorph removeSelector: #startDropFilesEventDispatch:!

!methodRemoval: HandMorph #startDropFilesEventDispatch: stamp: 'Install-7522-startEventDispatch-simplify-JuanVuletich-2025Sep04-16h23m-jmv.001.cs.st 9/5/2025 16:18:28'!
startDropFilesEventDispatch: aDropFilesEvent

	aDropFilesEvent dispatchIn: owner.!

HandMorph removeSelector: #startWindowEventDispatch:!

!methodRemoval: HandMorph #startWindowEventDispatch: stamp: 'Install-7522-startEventDispatch-simplify-JuanVuletich-2025Sep04-16h23m-jmv.001.cs.st 9/5/2025 16:18:28'!
startWindowEventDispatch: aWindowEvent

	aWindowEvent dispatchIn: owner.!

WindowEvent removeSelector: #startDispatchFromHand:!

!methodRemoval: WindowEvent #startDispatchFromHand: stamp: 'Install-7522-startEventDispatch-simplify-JuanVuletich-2025Sep04-16h23m-jmv.001.cs.st 9/5/2025 16:18:28'!
startDispatchFromHand: aHand
	"double dispatch the event dispatch"

	aHand startWindowEventDispatch: self!

DropFilesEvent removeSelector: #startDispatchFromHand:!

!methodRemoval: DropFilesEvent #startDispatchFromHand: stamp: 'Install-7522-startEventDispatch-simplify-JuanVuletich-2025Sep04-16h23m-jmv.001.cs.st 9/5/2025 16:18:28'!
startDispatchFromHand: aHand
	"double dispatch the event dispatch"

	aHand startDropFilesEventDispatch: self!

DropEvent removeSelector: #startDispatchFromHand:!

!methodRemoval: DropEvent #startDispatchFromHand: stamp: 'Install-7522-startEventDispatch-simplify-JuanVuletich-2025Sep04-16h23m-jmv.001.cs.st 9/5/2025 16:18:28'!
startDispatchFromHand: aHand
	"double dispatch the event dispatch"

	aHand startDropEventDispatch: self!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7522-startEventDispatch-simplify-JuanVuletich-2025Sep04-16h23m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7522] on 5 September 2025 at 12:30:01 pm'!
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/5/2025 11:55:18'!
                              topMorphAt: worldPoint
	"Find, if any a (possibly nested) submorph that #includesPixel: worldPoint,
	and is not covered by any other morph. Answer could also be self.
	Answer nil if neither us nor any submorph #includesPixel: worldPoint.
	Note: do not include not #visible morphs (see #includesPixel:)."

	| doWeIncludePixel |
	doWeIncludePixel := self includesPixel: worldPoint.
	(doWeIncludePixel or: [ self submorphsMightProtrude and: [self clipsSubmorphs not]]) ifTrue: [
		submorphs do: [ :m |
			(m topMorphAt: worldPoint) ifNotNil: [ :sm | ^sm ]]].
	doWeIncludePixel ifTrue: [ ^self ].
	^nil! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/5/2025 12:27:08'!
                             topUnlockedMorphAt: worldPoint
	"Find, if any a (possibly nested) submorph that #includesPixel: worldPoint,
	and is not covered by any other morph. Answer could also be self.
	Answer nil if neither us nor any submorph #includesPixel: worldPoint.
	Note: do not include not #visible morphs (see #includesPixel:)."

	| doWeIncludePixel |
	self isLocked ifTrue: [ ^nil ].
	doWeIncludePixel := self includesPixel: worldPoint.
	(doWeIncludePixel or: [ self submorphsMightProtrude and: [self clipsSubmorphs not]]) ifTrue: [
		submorphs do: [ :m |
			(m topUnlockedMorphAt: worldPoint) ifNotNil: [ :sm | ^sm ]]].
	doWeIncludePixel ifTrue: [ ^self ].
	^nil! !
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 9/5/2025 12:27:36' prior: 50377967!
dispatchIn: aWorldMorph
	"Drop is done on the innermost target that accepts it.
	If #rejectsEvent:, any party doesn't want the drop,or #wasHandled not by any reason, try with the owner."

	| handlerMorph dropped |
	handlerMorph := aWorldMorph topUnlockedMorphAt: position.
	[ handlerMorph notNil and: [wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			handlerMorph allowsMorphDrop ifTrue: [
				"Do a symmetric check if both morphs like each other"
				dropped := self contents.
				((handlerMorph wantsDroppedMorph: dropped event: self)		"I want her"
					and: [dropped wantsToBeDroppedInto: handlerMorph])		"she wants me"
						ifTrue: [ self sendEventTo: handlerMorph ]].
			wasHandled
				ifFalse: [
					handlerMorph invalidDrop: self.
					(self contents is: #DraggingGuideMorph) ifTrue: [
						self wasHandled: true.
						self contents delete ]
					]
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!DropFilesEvent methodsFor: 'dispatching' stamp: 'jmv 9/5/2025 12:27:44' prior: 50376871!
dispatchIn: aWorldMorph
	"Drop is done on the innermost target that accepts it."

	| handlerMorph |
	handlerMorph := aWorldMorph topUnlockedMorphAt: position.
	[ handlerMorph notNil and: [wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			handlerMorph allowsFilesDrop ifTrue: [
				self sendEventTo: handlerMorph ].
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 9/5/2025 12:28:07' prior: 50380117!
      dispatchIn: aWorldMorphOrFocusedMorph
	"Dispatch me.
	The event will be passed to the front-most visible submorph that contains the event position.
	Search usually starts with the WorldMorph, but it could be another morph if it is the hand's #mouseFocus.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."

	| handlerMorph |
	handlerMorph := aWorldMorphOrFocusedMorph topUnlockedMorphAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			self sendEventTo: handlerMorph.
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'jmv 9/5/2025 12:28:11' prior: 50380141!
 dispatchIn: aWorldMorphOrFocusedMorph
	"Dispatch me.
	The event will be passed to the front-most visible submorph that contains the event position.
	Search usually starts with the WorldMorph, but it could be another morph if it is the hand's #mouseFocus.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."
	
	| handlerMorph grabTheMorph |
	
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchIn: aWorldMorphOrFocusedMorph ].

	handlerMorph := aWorldMorphOrFocusedMorph topUnlockedMorphAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			"aMorph is in the top-most unlocked, visible morph in the chain."
			(self mouseButton3Pressed or: [handlerMorph handlesMouseDown: self])
				ifTrue: [ self sendEventTo: handlerMorph ]
				ifFalse: [
					grabTheMorph := false.
					"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
					self mouseButton1Pressed ifTrue: [
						handlerMorph owner ifNotNil: [ :o |
							(o allowsSubmorphDrag and: [ handlerMorph isSticky not ]) ifTrue: [
								grabTheMorph := true ]]].
					grabTheMorph ifTrue: [
						self hand
							waitForClicksOrDrag: handlerMorph event: self
							dragSel: ((Preferences at: #clickGrabsMorphs) ifFalse: [#dragEvent:localPosition:])
							clkSel: ((Preferences at: #clickGrabsMorphs) ifTrue: [#dragEvent:localPosition:]).
						"false ifTrue: [ self hand grabMorph: aMorph ]."
						(Preferences at: #clickGrabsMorphs) ifFalse: [
							self shiftPressed
								ifTrue: [ (handlerMorph is: #SystemWindow) ifTrue: [ handlerMorph sendToBack ] ]
								ifFalse: [ handlerMorph activateWindow ] ].
						self wasHandled: true ]]
			
		].
		handlerMorph := handlerMorph owner.
	].! !
!MouseScrollEvent methodsFor: 'dispatching' stamp: 'jmv 9/5/2025 12:28:14' prior: 50380253!
            dispatchIn: aWorldMorphOrFocusedMorph
	"Dispatch me.
	The event will be passed to the front-most visible submorph that contains the event position.
	Search usually starts with the WorldMorph, but it could be another morph if it is the hand's #mouseFocus.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."

	| handlerMorph |
	handlerMorph := aWorldMorphOrFocusedMorph topUnlockedMorphAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			(handlerMorph handlesMouseScroll: self) ifTrue: [
				self sendEventTo: handlerMorph ].
			
		].
		handlerMorph := handlerMorph owner.
	].! !

Morph removeSelector: #morphVisibleAt:!

!methodRemoval: Morph #morphVisibleAt: stamp: 'Install-7523-lockedMorphs-fix-JuanVuletich-2025Sep05-11h51m-jmv.001.cs.st 9/5/2025 16:18:28'!
morphVisibleAt: worldPoint
	"Find, if any a (possibly nested) submorph that #includesPixel: worldPoint,
	and is not covered by any other morph. Answer could also be self.
	Answer nil if neither us nor any submorph #includesPixel: worldPoint."

	| doWeIncludePixel |
	doWeIncludePixel := self includesPixel: worldPoint.
	(doWeIncludePixel or: [ self submorphsMightProtrude and: [self clipsSubmorphs not]]) ifTrue: [
		submorphs do: [ :m |
			(m morphVisibleAt: worldPoint) ifNotNil: [ :sm | ^sm ]]].
	doWeIncludePixel ifTrue: [ ^self ].
	^nil!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7523-lockedMorphs-fix-JuanVuletich-2025Sep05-11h51m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7523] on 5 September 2025 at 3:03:52 pm'!
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 9/5/2025 13:23:41'!
                       dispatchMouseOverEvent: aMouseEvent
	"Generate and dispatch a MouseOver event.
	If appropriate, also generate and dispatch MouseEnter and MouseLeave events."

	| hand focus evt |
	hand := aMouseEvent hand.

	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	
	"Now go looking for eventual mouse overs.
	If this MouseOver gets delivered to some morph, it will end calling #noticeMouseOver:event:,
	updating our instance variables."
	aMouseEvent asMouseOver startDispatchFromHand: hand.
	
	"Get out early if there's no change"
	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."
		(leftMorphs isEmpty and: [enteredMorphs position = 0])])
		ifTrue: [
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self].
	
	focus := hand mouseFocus.
	"Send #mouseLeave as appropriate"
	evt := aMouseEvent asMouseLeave.
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [evt sendEventTo: m ]
				ifFalse: [overMorphs nextPut: m]]].
	"Send #mouseEnter as appropriate"
	evt := aMouseEvent asMouseEnter.
	enteredMorphs ifNil: [
		"inform: was called in handleEvent:"
		leftMorphs := enteredMorphs := overMorphs := nil.
		^self].
	enteredMorphs := enteredMorphs contents.
	enteredMorphs reverseDo: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [evt sendEventTo: m ]]].
	"And remember the over list"
	overMorphs ifNil: [
			"inform: was called in handleEvent:"
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self].
	mouseOverMorphs := overMorphs contents.
	leftMorphs := enteredMorphs := overMorphs := nil! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/5/2025 13:05:53'!
       dispatchMouseOverEvent
	"Generate and dispatch a MouseOver event.
	If appropriate, also generate and dispatch MouseEnter and MouseLeave events."

	self mouseOverHandler dispatchMouseOverEvent: lastMouseEvent.! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/5/2025 12:53:41' prior: 50381534!
                 startMouseButtonDispatch: aMouseEvent

	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			aMouseEvent wasHandled: true.
			^self ]].

	"Issue a synthetic move event if we're not at the position of the event"
	aMouseEvent eventPosition = self morphPosition ifFalse: [
		"Issue a mouse move event to make the receiver appear at the given position"
		(MouseMoveEvent new
			setPosition: aMouseEvent eventPosition
			buttons: aMouseEvent buttons
			hand: self
			stamp: aMouseEvent timeStamp) startDispatchFromHand: self ].

	"Drop submorphs on button events"
	self hasSubmorphs
		ifTrue: [
			"Not if we are grabbing them"
			mouseClickState ifNil: [
				"Want to drop on mouseUp, NOT mouseDown"
				aMouseEvent isMouseUp ifTrue: [
					self dropMorphs: aMouseEvent ]]]
		ifFalse: [
			self mouseFocus
				ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
				ifNil: [ aMouseEvent dispatchIn: owner ]].
		
	self dispatchMouseOverEvent.! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/5/2025 12:53:51' prior: 50381466!
       startMouseMoveDispatch: aMouseEvent

	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		mouseClickState handleEvent: aMouseEvent from: self ].

	self morphPosition: aMouseEvent eventPosition.
	self mouseFocus
		ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
		ifNil: [ aMouseEvent dispatchIn: owner ].
		
	self dispatchMouseOverEvent.! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
MouseOverHandler removeSelector: #processMouseOver:!

!methodRemoval: MouseOverHandler #processMouseOver: stamp: 'Install-7524-MouseOverHandler-cleanup-JuanVuletich-2025Sep05-15h02m-jmv.001.cs.st 9/5/2025 16:18:28'!
processMouseOver: aMouseEvent
	"Re-establish the z-order for all morphs wrt the given event"

	| hand focus evt |
	hand := aMouseEvent hand.
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	"Now go looking for eventual mouse overs"
	aMouseEvent asMouseOver startDispatchFromHand: hand.
	"Get out early if there's no change"
	(leftMorphs isNil or: [			"Should never happen, but it could if you halt during layout."
		(leftMorphs isEmpty and: [enteredMorphs position = 0])])
		ifTrue: [
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self].
	focus := hand mouseFocus.
	"Send #mouseLeave as appropriate"
	evt := aMouseEvent asMouseLeave.
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [evt sendEventTo: m ]
				ifFalse: [overMorphs nextPut: m]]].
	"Send #mouseEnter as appropriate"
	evt := aMouseEvent asMouseEnter.
	enteredMorphs ifNil: [
		"inform: was called in handleEvent:"
		leftMorphs := enteredMorphs := overMorphs := nil.
		^self].
	enteredMorphs := enteredMorphs contents.
	enteredMorphs reverseDo: [ :m |
		m isInWorld and: [
			(m == focus or: [m hasOwner: focus]) 
				ifTrue: [evt sendEventTo: m ]]].
	"And remember the over list"
	overMorphs ifNil: [
			"inform: was called in handleEvent:"
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self].
	mouseOverMorphs := overMorphs contents.
	leftMorphs := enteredMorphs := overMorphs := nil!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7524-MouseOverHandler-cleanup-JuanVuletich-2025Sep05-15h02m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7523] on 5 September 2025 at 3:04:16 pm'!
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 9/5/2025 14:16:11' prior: 16969494!
                             request: queryString centeredAt: aPoint initialAnswer: defaultAnswer validationBlock: validationBlock acceptBlock: acceptBlock cancelBlock: cancelBlock
	"Non-modal. Method returns immediately.
	Uses acceptBlock and cancelBlock to process user's answer later, when provided by them."
	| morph |
	morph := self newColumn
		setQuery: queryString
		initialAnswer: defaultAnswer;
		validationBlock: validationBlock;
		acceptBlock: acceptBlock;
		cancelBlock: cancelBlock.
	self runningWorld addMorph: morph centeredNear: aPoint - self deltaToTextPane.
	"(Preferences at: #focusFollowsMouse) ifFalse: [answer textBox focusText]."
	morph textBox focusText.
	^ morph! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 9/5/2025 14:15:59' prior: 16969533!
request: queryString initialAnswer: defaultAnswer orCancel: cancelBlock
	"Modal. This method returns after an answer is provided."

	| morph world |
	morph := self newColumn
		setQuery: queryString
		initialAnswer: defaultAnswer.
	world := self runningWorld.
	world ifNil: [
		| answer |
		answer := self.	"Just a marker object, can not use nil, because it is a possible answer (if user cancels)"
		UISupervisor whenUIinSafeState: [ answer := self request: queryString initialAnswer: defaultAnswer orCancel: cancelBlock ].
		 [ answer == self ] whileTrue: [ Processor yield ].
		^answer ].
	world addMorph: morph centeredNear: world activeHand morphPosition - self deltaToTextPane.
	morph textBox focusText.
	^ morph getUserResponseOrCancel: cancelBlock! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 9/5/2025 14:16:24' prior: 16969588!
 request: queryString initialAnswer: defaultAnswer verifying: validationBlock orCancel: cancelBlock
	"Modal. This method returns when an answer is provided."

	| morph world |
	morph := self newColumn
		setQuery: queryString
		initialAnswer: defaultAnswer;
		validationBlock: validationBlock.
	world := self runningWorld.
	world ifNil: [
		| answer |
		answer := self.	"Just a marker object, can not use nil, because it is a possible answer (if user cancels)"
		UISupervisor whenUIinSafeState: [
			answer := self request: queryString initialAnswer: defaultAnswer verifying: validationBlock orCancel: cancelBlock ].
		 [ answer == self ] whileTrue: [ Processor yield ].
		^answer ].
	world addMorph: morph centeredNear: world activeHand morphPosition - self deltaToTextPane.
	morph textBox focusText.
	^ morph getUserResponseOrCancel: cancelBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7525-StringRequestMorph-fixFocus-JuanVuletich-2025Sep05-15h03m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7525] on 5 September 2025 at 3:55:31 pm'!
!Transcript class methodsFor: 'private' stamp: 'jmv 9/5/2025 15:53:58' prior: 50342765!
   dirtyScreenRect: someDamage
	"aRectangle needs updating on real OS Screen. This can be simply done by
	DisplayScreen forceDeferredToScreen: damage.
	The reason to do something more complicated is because #forceDeferredToScreen: may be expensive, especially on Mac Intel VMs as of July 2025, and especially if done at high frequency (i.e. with a time interval between calls below 25 milliseconds.
	"
	| now |
	now := Time localMillisecondClock.
	lastDisplayFlush ifNil: [ lastDisplayFlush := now ].

	"If enough time has elapsed since last push, just do it."
	now - lastDisplayFlush > 60 ifTrue: [
		dirtyRectOnDisplay := someDamage quickMerge: dirtyRectOnDisplay.
		DisplayScreen forceDeferredToScreen: dirtyRectOnDisplay.
		dirtyRectOnDisplay := nil.
		lastDisplayFlush := now.
		^self
		].

	dirtyRectOnDisplay
		ifNil: [
			"We don't have a previous dirty rect. If there has been some, it has already been pushed to Screen.
			Start a forked process to push it. Do it in a while. In the meantime, other calls to this process may
			add additional damage. It is also possible that some other call to this method ends up clearing the
			dirtyRectOnDisplay. Consider that too."
			dirtyRectOnDisplay := someDamage.
			[
				(Delay forMilliseconds: 100) wait.
				dirtyRectOnDisplay ifNotNil: [
					DisplayScreen forceDeferredToScreen: dirtyRectOnDisplay.
					dirtyRectOnDisplay := nil.
					lastDisplayFlush := Time localMillisecondClock ].
			] forkAt: Processor userInterruptPriority ]
		ifNotNil: [
			"We already have a forked process that will soon do the push. Wait for it. Merge damage."
			dirtyRectOnDisplay := someDamage quickMerge: dirtyRectOnDisplay.
			].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7526-Transcript-tweak-JuanVuletich-2025Sep05-15h47m-jmv.001.cs.st----!

----QUIT----(5 September 2025 16:18:34) Cuis7.5-7526.image priorSource: 1394160!

----STARTUP---- (11 September 2025 17:28:35) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CuisImage\Cuis7.5-7526.image!


'From Cuis7.5 [latest update: #7526] on 7 September 2025 at 9:08:40 pm'!
!WorldMorph methodsFor: 'interaction loop' stamp: 'jmv 9/7/2025 21:07:35' prior: 50355617!
                       mainLoop

	[
		self displayWorldOn: canvas.
		[
			"Here canvas and waitDelay are passed as arguments.
			This is because when debugging Morphic, a new UI process,
			these ivars are updated, but in the debugger process we still want the original ones."
			self doOneCycleOn: canvas delay: waitDelay.
			UISupervisor isUIProcessRunning ]
				whileTrue: []
	] on: Error, Halt do: [ :ex |
		"Handle a drawing error"
		(ex signalerContext findContextSuchThat: [ :context |
				#(drawOn: postDrawOn: fullDraw: step stepAt:) statePointsTo: context selector ])
			ifNotNil: [ :context | | failingMorph selector |
				failingMorph := context selector = #fullDraw:
					ifTrue: [ (context at: 1) ]
					ifFalse: [ context receiver ].
				selector := context selector.
				(#(drawOn: postDrawOn: fullDraw:) statePointsTo: selector)
					ifTrue: [ failingMorph drawingFails ].
				(#(step stepAt:) statePointsTo: selector)
					ifTrue: [ failingMorph stopStepping ].
				"Install the old error handler, so we can re-raise the error.
				This means, open a Debugger.
				This will also create a new Morphic process. if the user closes the debugger."
				ex receiver error: ex description.
				"Create a new UI process, if the user proceeds in the debugger.
				This is to use a new, clean Canvas."
				UISupervisor newUIProcess ]
			ifNil: [
				"Debugging aid: Uncomment. Set Transcript to log to StdOut and File.
				Be ready to need to kill Cuis from the OS."
				"'-----' print.
				{Time now. Processor activeProcess. ex} print.
				thisContext printStack: 50.
				[UISupervisor newUIProcess] fork."
				"ex return"
				ex pass ]
	].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7527-HandleErrorsAndHaltsInSteppingMorphs-JuanVuletich-2025Sep07-21h02m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7527] on 8 September 2025 at 10:56:46 am'!
!WorldMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 9/8/2025 10:50:42'!
                    center: aMorph near: aPoint
	"Position the given morph in this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	aMorph morphExtent
		ifNil: [ aMorph positionInWorld: aPoint ]
		ifNotNil:
			[ :e |
				| trialRect delta |
				trialRect := Rectangle center: aPoint extent: e.
				delta := trialRect amountToTranslateWithin: self displayBounds.
				aMorph positionInWorld: (trialRect origin + delta) rounded ].! !
!PlacedMorph methodsFor: 'initialization' stamp: 'jmv 9/8/2025 10:56:28' prior: 16930393!
           openInWorld: aWorld
	"Add this morph to the requested World."

	aWorld addMorph: self.
	
	"We could have already set our location, or maybe #noteNewOwner: was redefined to set it.
	Position us near the hand only if we haven't been located somewhere already."
	(location isIdentity or: [ location isPureMirroring ])
		ifTrue: [ "No real position set yet"
			aWorld center: self near: aWorld activeHand morphPosition ].! !
!WorldMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 9/8/2025 10:50:55' prior: 17018741!
                            addMorph: aMorph centeredNear: aPoint
	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."

	self addMorph: aMorph.
	self center: aMorph near: aPoint.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7528-InitialMorphLocation-fix-JuanVuletich-2025Sep08-10h54m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7528] on 8 September 2025 at 11:26:02 am'!
!VersionsBrowserWindow class methodsFor: 'services' stamp: 'len 6/6/2025 16:30:54' prior: 17014785!
                        browseVersionsOf: method class: class meta: meta category: msgCategory selector: selector lostMethodPointer: sourcePointer extraChangeRecord: aChangeRecord
	| browser |
	browser := VersionsBrowser new.
	(browser scanVersionsOf: method class: class meta: meta category: msgCategory selector: selector)
		ifNil: [ self inform: 'No versions available'. ^nil ].
	aChangeRecord ifNotNil: [browser addedChangeRecord: aChangeRecord ].
	browser toggleListIndex: 1.
	VersionsBrowserWindow open: browser label: 'Recent versions of ', selector.
	^browser! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7529-AutoSelectCurrentMethodVersion-LucianoEstebanNotarfrancesco-2025Sep08-11h22m-len.001.cs.st----!

'From Cuis7.5 [latest update: #7529] on 8 September 2025 at 12:18:54 pm'!
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 9/8/2025 12:16:49' prior: 50381851!
dispatchIn: aWorldMorph
	"Drop is done on the innermost target that accepts it.
	If #rejectsEvent:, any party doesn't want the drop,or #wasHandled not by any reason, try with the owner."

	| handlerMorph dropped |
	handlerMorph := aWorldMorph topUnlockedMorphAt: position.
	[ handlerMorph notNil and: [wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			handlerMorph allowsMorphDrop ifTrue: [
				"Do a symmetric check if both morphs like each other"
				dropped := self contents.
				((handlerMorph wantsDroppedMorph: dropped event: self)		"I want her"
					and: [dropped wantsToBeDroppedInto: handlerMorph])		"she wants me"
						ifTrue: [ self sendEventTo: handlerMorph ]].
		].
		handlerMorph := handlerMorph owner.
	].
	wasHandled
		ifFalse: [
			handlerMorph invalidDrop: self.
			(self contents is: #DraggingGuideMorph) ifTrue: [
				self wasHandled: true.
				self contents delete ]
			]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7530-DnD-methodOnCategory-fix-JuanVuletich-2025Sep08-12h18m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7530] on 9 September 2025 at 8:25:40 am'!
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 9/8/2025 15:47:53' prior: 50379612!
       mouseEnter: aMouseEnterEvent
	"The mouse entered the receiver"
	super mouseEnter: aMouseEnterEvent.
	owner ifNotNil: [
		owner selectItem: self ]! !
!IndentingListItemMorph methodsFor: 'events' stamp: 'jmv 9/8/2025 15:48:07' prior: 50379619!
              mouseEnter: aMouseEnterEvent
	isHighlighted := true.
	self redrawNeeded.
	super mouseEnter: aMouseEnterEvent! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 9/8/2025 15:48:10' prior: 50379633!
                     mouseEnter: aMouseEnterEvent
	"The mouse entered the receiver"
	mouseIsOver := true.
	self redrawNeeded.
	super mouseEnter: aMouseEnterEvent! !
!HoverableButtonMorph methodsFor: 'events' stamp: 'jmv 9/8/2025 15:48:13' prior: 50379649!
                     mouseEnter: aMouseEnterEvent
	
	mouseEnterSelector ifNotNil: [ model perform: mouseEnterSelector ].
	super mouseEnter: aMouseEnterEvent! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7531-tweaks-JuanVuletich-2025Sep09-08h25m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7531] on 9 September 2025 at 11:28:58 am'!
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 9/9/2025 09:03:57' prior: 50379447!
                      noticeMouseOver: aMorph event: aMouseOverEvent
	"Remember that the mouse is currently over some morph"
	(leftMorphs includes: aMorph) 
		ifTrue: [ leftMorphs remove: aMorph ]
		ifFalse: [ enteredMorphs nextPut: aMorph ].
	overMorphs nextPut: aMorph.! !
!HandMorph methodsFor: 'event handling' stamp: 'jmv 9/9/2025 09:03:04' prior: 50379743!
           noticeMouseOver: aMorph event: aMouseOverEvent
	
	self mouseOverHandler noticeMouseOver: aMorph event: aMouseOverEvent.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7532-noticeMouseOver-cleanup-JuanVuletich-2025Sep09-11h27m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7531] on 9 September 2025 at 11:34:24 am'!
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 9/9/2025 10:08:03' prior: 50382044!
                     dispatchMouseOverEvent: aMouseEvent
	"Generate and dispatch a MouseOver event.
	If appropriate, also generate and dispatch MouseEnter and MouseLeave events."

	| hand mouseOverEvent mouseLeaveEvent mouseEnterEvent |
	hand := aMouseEvent hand.

	"mouseOverMorphs: Array with all morphs that have had a MouseOver event in the previous call.
	leftMorphs is initialized with all morphs that had the mouse over them
	overMorphs and enteredMorphs are initialized empty."
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	
	"Now go looking for eventual mouse overs.
	If this MouseOver gets delivered to some morph, it will end calling #noticeMouseOver:event:,
	updating our instance variables.
	leftMorphs will only keep morphs that no longer have the mouse over them.
	enteredMorphs will include morphs that have the mouse over them, and didn't before.
	overMorphs will include all morphs that have the mouse over them."
	mouseOverEvent := aMouseEvent asMouseOver.
	mouseOverEvent startDispatchFromHand: hand.
	"enteredMorphs and overMorphs are ordered:
	- First is the innest and topmost found morph.
	- Then comes its owner (meaning it is below it), and so on.
	- Last is the World, which is below every other morph."
	
	"Get out early if no change. No morph was entered or left, mouseOverMorphs remains same."
	(leftMorphs isEmpty and: [enteredMorphs position = 0])
		ifTrue: [
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self ].

	"Send #mouseLeave as appropriate. Order is inner to outer."
	mouseLeaveEvent := aMouseEvent asMouseLeave.
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m |
		m isInWorld ifTrue: [
			mouseLeaveEvent sendEventTo: m ]].
	
	"Send #mouseEnter as appropriate. Order is outer to Inner."
	mouseEnterEvent := aMouseEvent asMouseEnter.
	enteredMorphs := enteredMorphs contents.
	enteredMorphs reverseDo: [ :m |
		m isInWorld ifTrue: [
			mouseEnterEvent sendEventTo: m ]].
	
	"And remember the over list for the next call"
	mouseOverMorphs := overMorphs contents.
	leftMorphs := enteredMorphs := overMorphs := nil.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/9/2025 09:37:11' prior: 50381161!
          processMouseOver: aMouseOverEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	aMouseOverEvent hand noticeMouseOver: self event: aMouseOverEvent.
	
	"Open question: should any unhandled mouse move events be filtered out?
	(i.e. should mouseHover:localPosition: be called when a mouse button is pressed
	but the morph doesn't have mouse button handlers?
	Essentially, what are the limits of what is considered 'hovering'?"
	self handlesMouseHover ifTrue: [
		self
			mouseHover: aMouseOverEvent
			localPosition: localEventPosition ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7533-dispatchMouseOver-JuanVuletich-2025Sep09-11h28m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7531] on 9 September 2025 at 11:40:39 am'!
!MouseEnterEvent methodsFor: 'dispatching' stamp: 'jmv 9/9/2025 10:11:57'!
                      dispatchIn: neverMind
	"We are sent directly to recipient via #sendEventTo:"

	self shouldNotHappen! !
!MouseLeaveEvent methodsFor: 'dispatching' stamp: 'jmv 9/9/2025 10:12:02'!
              dispatchIn: neverMind
	"We are sent directly to recipient via #sendEventTo:"

	self shouldNotHappen! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/9/2025 09:54:39' prior: 50381493!
                              startMouseDispatch: aMouseEvent
	"For MouseEvents with default dispatch behavior"

	self hasSubmorphs
		ifFalse: [
			aMouseEvent dispatchIn: owner ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7534-MouseEventDispatch-JuanVuletich-2025Sep09-11h34m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7534] on 9 September 2025 at 11:43:42 am'!
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 9/9/2025 10:34:57' prior: 16901233!
keyboardFocusChange: aBoolean
	"Notify change due to green border for keyboard focus"

	aBoolean ifFalse: [
		(prevKbdFocus isNil or: [ prevKbdFocus hasKeyboardFocus ]) not ifTrue: [
			self deleteIfPopUp: nil.
			self redrawNeeded ]].
! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 9/9/2025 10:34:29' prior: 16900114!
                         select
	self isSelected: true.
	owner activeSubmenu: subMenu.
	subMenu ifNotNil: [
		self displayBounds ifNotNil: [ :r |
			subMenu delete.
			subMenu
				popUpAdjacentTo: (Array with: r topRight + `4@0` with: r topLeft)
				from: self ].
		subMenu selectItem: nil ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7535-CarefulMenuDelete-JuanVuletich-2025Sep09-11h42m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7534] on 9 September 2025 at 11:51:55 am'!
!HaloMorph methodsFor: 'event handling testing' stamp: 'jmv 9/9/2025 11:46:12'!
                       handlesMouseDown: aMouseButtonEvent

	^true! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 9/9/2025 11:49:40'!
                 mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Just remove us"
	
	self delete! !
!HaloMorph methodsFor: 'events' stamp: 'jmv 9/9/2025 11:49:43'!
                      mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition
	"Just remove us"
	
	self delete! !
!HaloMorph methodsFor: 'events-processing' stamp: 'jmv 9/9/2025 11:51:10' prior: 16877150!
                           rejectsEvent: aMorphicEvent
	"Return true to reject the given event. Submorphs might still handle it."

	"Only mouse button down events are handled by the halo itself"
	(aMorphicEvent isMouse and: [ aMorphicEvent isMouseDown ])
	ifTrue: [
		^ false ].
	^true! !
!TheWorldMenu class methodsFor: 'instance creation' stamp: 'jmv 9/9/2025 11:03:56' prior: 16994405!
                      getMenuIn: aWorld at: anActiveHand
	^ (self new world: aWorld hand: anActiveHand)
		buildWorldMenu! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7536-ClickOnHalo-fix-JuanVuletich-2025Sep09-11h43m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7534] on 9 September 2025 at 12:01:26 pm'!
!Transcripter methodsFor: 'accessing' stamp: 'jmv 9/9/2025 12:00:53' prior: 16998223!
                           clear
	DisplayScreen deferredUpdatingDisplay fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	self on: (String new: 100); endEntry.! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 9/9/2025 11:59:52' prior: 50335948!
                            endEntry
	| c d cb |
	c := self contents.
	DisplayScreen isDisplayExtentOk ifFalse: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame := frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d := textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb := textComposition characterBlockAtPoint:
			`0@0` + (0@(d+FontFamily defaultLineSpacing)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit := position := collection size.
		^ self endEntry].
	DisplayScreen deferredUpdatingDisplay fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	DisplayScreen deferredUpdatingDisplay getCanvas
		drawTextComposition: textComposition
		at: `4@4` + frame topLeft
		extent: Display extent
		color: `Color black`
		selectionColor: `Color blue`.
	DisplayScreen forceDeferredToScreen: frame.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7537-EmergencyEvaluator-Speedup-JuanVuletich-2025Sep09-11h51m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7534] on 9 September 2025 at 12:17:34 pm'!
!MenuItemMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:55' prior: 16899890!
      handlesMouseOver: anEvent
	"implements #mouseEnter: and/or #mouseLeave:"
	^true! !
!IndentingListItemMorph methodsFor: 'event handling testing' stamp: 'len 5/26/2019 05:12:45' prior: 16882757!
                               handlesMouseOver: event
	"implements #mouseEnter: and/or #mouseLeave:"
	^ true! !
!LayoutAdjustingMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:55' prior: 16896210!
     handlesMouseOver: evt
	"implements #mouseEnter: and/or #mouseLeave:"
	^ true! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7538-CommentTweaks-JuanVuletich-2025Sep09-12h15m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7538] on 10 September 2025 at 11:11:49 am'!
!Morph methodsFor: 'events' stamp: 'jmv 9/10/2025 11:09:28' prior: 50375826!
                           mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition

	aMouseButtonEvent shiftPressed
		ifTrue: [self addHalo: aMouseButtonEvent ]
		ifFalse: [self root addHalo: aMouseButtonEvent].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7539-InitialHaloToInnerMorphIfShiftKey-JuanVuletich-2025Sep10-11h11m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7538] on 9 September 2025 at 3:55:46 pm'!
!Rectangle methodsFor: 'transforming' stamp: 'jmv 9/9/2025 15:51:19' prior: 50337125!
      newRect2From: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect aHand delay |
	delay := Delay forMilliseconds: 10.
	rect := self.
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	[Sensor isAnyButtonPressed] whileTrue: 
		[delay wait.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen deferredUpdatingDisplay border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen forceDeferredToScreen: (rect merge: newRect).
			rect := newRect]].
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		releaseMouseFocus;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 9/9/2025 15:51:23' prior: 50337166!
              newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay := Delay forMilliseconds: 10.
	buttonStart := buttonNow := Sensor isAnyButtonPressed.
	rect := self.
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow := Sensor isAnyButtonPressed.
		newRect := newRectBlock value: rect.
		newRect = rect ifFalse:
			[DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen deferredUpdatingDisplay border: newRect width: 2 rule: Form reverse fillColor: `Color gray`.
			DisplayScreen forceDeferredToScreen: (rect merge: newRect).
			rect := newRect]].
	DisplayScreen deferredUpdatingDisplay border: rect width: 2 rule: Form reverse fillColor: `Color gray`.
	DisplayScreen forceDeferredToScreen: rect.
	" pay the price for reading the sensor directly ; get this party started "
	aHand := self runningWorld activeHand.
	aHand
		releaseMouseFocus;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 9/9/2025 15:51:39' prior: 16900839!
                             deleteIfPopUp: evt
	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."

	| h |
	h := evt ifNotNil: [ evt hand ].
	h ifNil: [
		self world ifNotNil: [ :w | h := h activeHand ]].
	h ifNil: [ h := self activeHand ].
	h ifNotNil: [
		h keyboardFocus == self ifTrue: [
			h newKeyboardFocus: prevKbdFocus ].
		h mouseFocus == self ifTrue: [
			"h newMouseFocus: prevMouseFocus."
			h releaseMouseFocus ]].
	stayUp ifFalse: [
		self delete.
		popUpOwner ifNotNil: [
			popUpOwner isSelected: false.
			popUpOwner deleteIfPopUp: evt ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7540-tweaks-JuanVuletich-2025Sep09-15h50m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7538] on 9 September 2025 at 4:08:57 pm'!
!TextEditor methodsFor: 'events' stamp: 'jmv 9/9/2025 16:08:29' prior: 16990023!
   mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	| b |

	initialSelectionStart := nil.
	initialSelectionStop := nil.
	doWordSelection := false.
	doParagraphSelection := false.

	b := textComposition characterBlockAtPoint: localEventPosition.
	(textComposition clickAt: localEventPosition) ifTrue: [
		markBlock := b.
		pointBlock := b.
		^ self ].
	
	aMouseButtonEvent shiftPressed
		ifFalse: [
			markBlock := b.
			pointBlock := b.	
			self setEmphasisHereFromText ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7541-tweak-JuanVuletich-2025Sep09-15h55m-jmv.002.cs.st----!

'From Cuis7.5 [latest update: #7540] on 10 September 2025 at 9:09:56 am'!
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/9/2025 17:17:12'!
           releaseKeyboardFocusIfOrOwnedBy: aMorph
	"If the given morph had the keyboard focus before, release it"
	keyboardFocus ifNotNil: [
		keyboardFocus withAllOwnersDo: [ :outerOwner |
			outerOwner == aMorph ifTrue: [self releaseKeyboardFocus]]]! !
!Morph methodsFor: 'events' stamp: 'jmv 9/10/2025 09:06:47' prior: 50379527!
                              mouseLeave: aMouseLeaveEvent
	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed.
	Note: a Morph must answer true to #handlesMouseOver: in order to receive this message."

	(Preferences at: #focusFollowsMouse)
		ifTrue: [aMouseLeaveEvent hand releaseKeyboardFocusIfOrOwnedBy: self].
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #mouseLeave: 
		ifPresentDo: [ :handler | handler value: aMouseLeaveEvent ].! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 9/9/2025 17:17:53' prior: 50343848!
              delete
	"Remove the receiver as a submorph of its owner and make its 
	new owner be nil."

	| aWorld |
	aWorld := self world ifNil: [ self runningWorld ].
	aWorld ifNotNil: [
		aWorld activeHand ifNotNil: [ :h | h
			releaseKeyboardFocusIfOrOwnedBy: self;
			releaseMouseFocus: self ]].
	self clearDependencyAndEvents.
	self allSubmorphsDo: [ :each |
		each clearDependencyAndEvents ].
	self privateDelete.! !

HandMorph removeSelector: #releaseKeyboardFocus:!

!methodRemoval: HandMorph #releaseKeyboardFocus: stamp: 'Install-7542-releaseFocus-tweak-JuanVuletich-2025Sep10-09h06m-jmv.001.cs.st 9/11/2025 17:28:35'!
releaseKeyboardFocus: aMorph
	"If the given morph had the keyboard focus before, release it"
	keyboardFocus ifNotNil: [
		keyboardFocus withAllOwnersDo: [ :outerOwner |
			outerOwner == aMorph ifTrue: [self releaseKeyboardFocus]]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7542-releaseFocus-tweak-JuanVuletich-2025Sep10-09h06m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7540] on 10 September 2025 at 9:14:47 am'!
!EntryFieldMorph methodsFor: 'blink cursor' stamp: 'jmv 9/9/2025 17:46:17' prior: 16859110!
        pauseBlinking
	"Show a solid cursor (non blinking) for a short while"
	pauseBlinking := true.
	self disablesEditing ifFalse: [
		"Show cursor right now if needed"
		showTextCursor ifFalse: [
			showTextCursor := true.
			textCursorRect ifNotNil: [ :r | self invalidateLocalRect: r ]]]! !
!EntryFieldMorph methodsFor: 'events-processing' stamp: 'jmv 9/9/2025 17:45:57' prior: 16859355!
                               keyboardFocusChange: aBoolean
	aBoolean
		ifTrue: [
			"A hand is wanting to send us characters..."
			editor ifNil: [ self editor ].
			self disablesEditing ifFalse: [
				self startBlinking ]]
		ifFalse: [
			self stopBlinking ].
	self redrawNeeded.! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 9/9/2025 17:47:20' prior: 16887262!
    keyboardFocusChange: aBoolean
	
	"The message is sent to a morph when its keyboard focus changes.
	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.
	In this case, all we need to do is to redraw border feedback"
	aBoolean
		ifTrue: [
			"A hand is wanting to send us characters..."
			editor ifNil: [ self editor storeSelectionInComposition ].	"Forces install"
			(self disablesEditing not and: [ editor hasSelection not ]) ifTrue: [
				self startBlinking ]]
		ifFalse: [ self stopBlinking ].
	
	(owner notNil and: [ owner drawsKeyboardFocusIndicator ])
		ifTrue: [ owner redrawNeeded ]
		ifFalse: [
			"Selection might be shown differently when focused"
			self textComposition selectionRects do: [ :r | self invalidateLocalRect: r ]]	.! !
!InnerTextMorph methodsFor: 'private' stamp: 'jmv 9/9/2025 17:49:01' prior: 16887561!
                        selectionChanged
	self textComposition selectionRects do: [ :r | self invalidateLocalRect: r ].
	(self disablesEditing not and: [ editor hasSelection not ])
		ifTrue: [ self hasKeyboardFocus ifTrue: [self startBlinking ]]
		ifFalse: [ self stopBlinking ]! !
!InnerTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 9/9/2025 17:47:44' prior: 16887664!
pauseBlinking
	"Show a solid cursor (non blinking) for a short while"
	pauseBlinking := true.
	textComposition ifNotNil: [
		self disablesEditing ifFalse: [
			"Show cursor right now if needed"
			textComposition showTextCursor ifFalse: [
				textComposition showTextCursor: true ]]]! !

InnerTextMorph removeSelector: #showsBlinkingCursor!

!methodRemoval: InnerTextMorph #showsBlinkingCursor stamp: 'Install-7543-cleanup-JuanVuletich-2025Sep10-09h09m-jmv.001.cs.st 9/11/2025 17:28:35'!
showsBlinkingCursor

	^self handlesKeyboard and: [ self disablesEditing not ]!

EntryFieldMorph removeSelector: #showsBlinkingCursor!

!methodRemoval: EntryFieldMorph #showsBlinkingCursor stamp: 'Install-7543-cleanup-JuanVuletich-2025Sep10-09h09m-jmv.001.cs.st 9/11/2025 17:28:35'!
showsBlinkingCursor

	^self handlesKeyboard and: [ self disablesEditing not ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7543-cleanup-JuanVuletich-2025Sep10-09h09m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7542] on 10 September 2025 at 9:42:12 am'!
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 9/10/2025 09:33:04' prior: 50382665!
              dispatchMouseOverEvent: aMouseEvent
	"Generate and dispatch a MouseOver event.
	If appropriate, also generate and dispatch MouseEnter and MouseLeave events."

	| hand |
	hand := aMouseEvent hand.

	"mouseOverMorphs: Array with all morphs that have had a MouseOver event in the previous call.
	leftMorphs is initialized with all morphs that had the mouse over them
	overMorphs and enteredMorphs are initialized empty."
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	
	"Now go looking for eventual mouse overs.
	If this MouseOver gets delivered to some morph, it will end calling #noticeMouseOver:event:,
	updating our instance variables.
	leftMorphs will only keep morphs that no longer have the mouse over them.
	enteredMorphs will include morphs that have the mouse over them, and didn't before.
	overMorphs will include all morphs that have the mouse over them."
	aMouseEvent asMouseOver startDispatchFromHand: hand.
	"enteredMorphs and overMorphs are ordered:
	- First is the innest and topmost found morph.
	- Then comes its owner (meaning it is below it), and so on.
	- Last is the World, which is below every other morph."
	
	"Get out early if no change. No morph was entered or left, mouseOverMorphs remains same."
	(leftMorphs isEmpty and: [enteredMorphs position = 0])
		ifTrue: [
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self ].
	enteredMorphs := enteredMorphs contents.
	overMorphs := overMorphs contents.

	"Send #mouseLeave as appropriate. Order is inner to outer."
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m |
		m isInWorld ifTrue: [
			aMouseEvent asMouseLeave sendEventTo: m ]].
	
	"Send #mouseEnter as appropriate. Order is outer to Inner."
	enteredMorphs reverseDo: [ :m |
		m isInWorld ifTrue: [
			aMouseEvent asMouseEnter sendEventTo: m ]].
	
	"And remember the over list for the next call"
	mouseOverMorphs := overMorphs.
	leftMorphs := enteredMorphs := overMorphs := nil.! !
!IndentingListItemMorph methodsFor: 'events' stamp: 'jmv 9/9/2025 17:14:22' prior: 50379626!
     mouseLeave: aMouseLeaveEvent
	isHighlighted := false.
	self redrawNeeded.
	super mouseLeave: aMouseLeaveEvent.! !
!PluggableButtonMorph methodsFor: 'events' stamp: 'jmv 9/9/2025 17:14:30' prior: 50379641!
                   mouseLeave: aMouseLeaveEvent
	"The mouse has left the area of the receiver"
	mouseIsOver := false.
	self redrawNeeded.
	super mouseLeave: aMouseLeaveEvent.! !
!HoverableButtonMorph methodsFor: 'events' stamp: 'jmv 9/9/2025 17:14:34' prior: 50379657!
      mouseLeave: aMouseLeaveEvent
	
	mouseLeaveSelector ifNotNil: [
		model perform: mouseLeaveSelector ].
	super mouseLeave: aMouseLeaveEvent.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7544-Cleanup-JuanVuletich-2025Sep10-09h41m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7542] on 10 September 2025 at 9:47:23 am'!
!Morph methodsFor: 'event handling testing' stamp: 'jmv 9/9/2025 16:29:29'!
     handlesKeyboardFocus
	"Return true if the receiver wishes to handle keyboard focus"

	^true! !
!EntryFieldMorph methodsFor: 'event handling testing' stamp: 'jmv 9/9/2025 16:54:42'!
           handlesKeyboardFocus
	"Not if we are read-only"
	
	^self disablesEditing not! !
!MenuItemMorph methodsFor: 'event handling testing' stamp: 'jmv 9/9/2025 16:59:30'!
                            handlesKeyboardFocus
	"It is handled by owner?"
	
	^false! !
!InnerHierarchicalListMorph methodsFor: 'event handling testing' stamp: 'jmv 9/9/2025 16:33:31'!
  handlesKeyboardFocus
	"Return true if the receiver wishes to handle keyboard focus.
	Answer false because it is handled by our owner, a HierarchicalListMorph"

	^false! !
!InnerListMorph methodsFor: 'event handling testing' stamp: 'jmv 9/9/2025 16:33:58'!
handlesKeyboardFocus
	"Return true if the receiver wishes to handle keyboard focus.
	Answer false because it is handled by our owner, a subinstance of PluggableListMorph"

	^false! !
!InnerTextMorph methodsFor: 'event handling testing' stamp: 'jmv 9/9/2025 16:54:48'!
                    handlesKeyboardFocus
	"Not if we are read-only"

	^self disablesEditing not! !
!TextModelMorph methodsFor: 'event handling' stamp: 'jmv 9/10/2025 09:54:46'!
   keyboardFocusChange: aBoolean
	"If user clicks or mouseEnters into the blank area not not covered by our inner text morph,
	(meaning no scrollbars, and text being shorter than us), then still give keyboard focus to it."
	
	aBoolean ifTrue: [
		self focusText ].! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/9/2025 17:17:38'!
               releaseKeyboardFocusIf: aMorph
	"If the given morph had the keyboard focus before, release it"
	keyboardFocus == aMorph ifTrue: [self releaseKeyboardFocus]! !
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 9/10/2025 09:46:10' prior: 50383275!
 dispatchMouseOverEvent: aMouseEvent
	"Generate and dispatch a MouseOver event.
	If appropriate, also generate and dispatch MouseEnter and MouseLeave events."

	| hand mustSetKeyboardFocus |
	hand := aMouseEvent hand.

	"mouseOverMorphs: Array with all morphs that have had a MouseOver event in the previous call.
	leftMorphs is initialized with all morphs that had the mouse over them
	overMorphs and enteredMorphs are initialized empty."
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	
	"Now go looking for eventual mouse overs.
	If this MouseOver gets delivered to some morph, it will end calling #noticeMouseOver:event:,
	updating our instance variables.
	leftMorphs will only keep morphs that no longer have the mouse over them.
	enteredMorphs will include morphs that have the mouse over them, and didn't before.
	overMorphs will include all morphs that have the mouse over them."
	aMouseEvent asMouseOver startDispatchFromHand: hand.
	"enteredMorphs and overMorphs are ordered:
	- First is the innest and topmost found morph.
	- Then comes its owner (meaning it is below it), and so on.
	- Last is the World, which is below every other morph."
	
	"Get out early if no change. No morph was entered or left, mouseOverMorphs remains same."
	(leftMorphs isEmpty and: [enteredMorphs position = 0])
		ifTrue: [
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self ].
	enteredMorphs := enteredMorphs contents.
	overMorphs := overMorphs contents.
	
	mustSetKeyboardFocus := Preferences at: #focusFollowsMouse.

	"Send #mouseLeave as appropriate. Release any keyboard focus.
	Order is inner to outer."
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m |
		mustSetKeyboardFocus ifTrue: [
			hand releaseKeyboardFocusIf: m ].
		m isInWorld ifTrue: [
			aMouseEvent asMouseLeave sendEventTo: m ]].
	
	"Set keyboard focus to the innermost (i.e. topmost) entered morph that will take it."
	enteredMorphs do: [ :m |
		m isInWorld ifTrue: [
			(mustSetKeyboardFocus and: [ m handlesKeyboardFocus ]) ifTrue: [
				hand newKeyboardFocus: m.
				"Do it just once!!"
				mustSetKeyboardFocus := false ]]].
	
	"Send #mouseEnter as appropriate. Order is outer to Inner."
	enteredMorphs reverseDo: [ :m |
		m isInWorld ifTrue: [
			aMouseEvent asMouseEnter sendEventTo: m ]].
	
	"And remember the over list for the next call"
	mouseOverMorphs := overMorphs.
	leftMorphs := enteredMorphs := overMorphs := nil.! !
!Morph methodsFor: 'events' stamp: 'jmv 9/9/2025 17:13:48' prior: 50383119!
                   mouseLeave: aMouseLeaveEvent
	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed.
	Note: a Morph must answer true to #handlesMouseOver: in order to receive this message."

	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #mouseLeave: 
		ifPresentDo: [ :handler | handler value: aMouseLeaveEvent ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7545-mouseEnterToFocus-newMechanism-JuanVuletich-2025Sep10-09h42m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7544] on 10 September 2025 at 10:02:44 am'!

AutoCompleterMorph removeSelector: #mouseEnter:!

!methodRemoval: AutoCompleterMorph #mouseEnter: stamp: 'Install-7546-removeOldMouseEnterToFocus-JuanVuletich-2025Sep10-10h01m-jmv.001.cs.st 9/11/2025 17:28:35'!
mouseEnter: aMouseEnterEvent
	self activeHand newKeyboardFocus: completer textMorph.
	^ super mouseEnter: aMouseEnterEvent!

TextModelMorph removeSelector: #mouseEnter:!

!methodRemoval: TextModelMorph #mouseEnter: stamp: 'Install-7546-removeOldMouseEnterToFocus-JuanVuletich-2025Sep10-10h01m-jmv.001.cs.st 9/11/2025 17:28:35'!
mouseEnter: aMouseEnterEvent
	super mouseEnter: aMouseEnterEvent.
	(Preferences at: #focusFollowsMouse)
		ifTrue: [ aMouseEnterEvent hand newKeyboardFocus: scroller ]!

PluggableListMorph removeSelector: #mouseEnter:!

!methodRemoval: PluggableListMorph #mouseEnter: stamp: 'Install-7546-removeOldMouseEnterToFocus-JuanVuletich-2025Sep10-10h01m-jmv.001.cs.st 9/11/2025 17:28:35'!
mouseEnter: aMouseEnterEvent
	super mouseEnter: aMouseEnterEvent.
	(Preferences at: #focusFollowsMouse)
		ifTrue: [ aMouseEnterEvent hand newKeyboardFocus: self ]!

HierarchicalListMorph removeSelector: #mouseEnter:!

!methodRemoval: HierarchicalListMorph #mouseEnter: stamp: 'Install-7546-removeOldMouseEnterToFocus-JuanVuletich-2025Sep10-10h01m-jmv.001.cs.st 9/11/2025 17:28:35'!
mouseEnter: aMouseEnterEvent
	super mouseEnter: aMouseEnterEvent.
	(Preferences at: #focusFollowsMouse)
		ifTrue: [ aMouseEnterEvent hand newKeyboardFocus: self ]!

EntryFieldMorph removeSelector: #mouseEnter:!

!methodRemoval: EntryFieldMorph #mouseEnter: stamp: 'Install-7546-removeOldMouseEnterToFocus-JuanVuletich-2025Sep10-10h01m-jmv.001.cs.st 9/11/2025 17:28:35'!
mouseEnter: aMouseEnterEvent
	super mouseEnter: aMouseEnterEvent.
	(Preferences at: #focusFollowsMouse)
		ifTrue: [ aMouseEnterEvent hand newKeyboardFocus: self ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7546-removeOldMouseEnterToFocus-JuanVuletich-2025Sep10-10h01m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7546] on 10 September 2025 at 12:03:03 pm'!
!IndentingListItemMorph methodsFor: 'event handling testing' stamp: 'jmv 9/10/2025 12:00:35'!
                               handlesKeyboardFocus
	"Return true if the receiver wishes to handle keyboard focus.
	Answer false because it is handled by our owner, a subinstance of HierarchicalListMorph"

	^false! !
!MouseOverHandler methodsFor: 'event handling' stamp: 'jmv 9/10/2025 11:57:44' prior: 50383435!
      dispatchMouseOverEvent: aMouseEvent
	"Generate and dispatch a MouseOver event.
	If appropriate, also generate and dispatch MouseEnter and MouseLeave events."

	| hand mustSetKeyboardFocus |
	hand := aMouseEvent hand.

	"mouseOverMorphs: Array with all morphs that have had a MouseOver event in the previous call.
	leftMorphs is initialized with all morphs that had the mouse over them
	overMorphs and enteredMorphs are initialized empty."
	leftMorphs := mouseOverMorphs asIdentitySet.
	"Assume some coherence for the number of objects in over list"
	overMorphs := WriteStream on: (Array new: leftMorphs size).
	enteredMorphs := WriteStream on: #().
	
	"Now go looking for eventual mouse overs.
	If this MouseOver gets delivered to some morph, it will end calling #noticeMouseOver:event:,
	updating our instance variables.
	leftMorphs will only keep morphs that no longer have the mouse over them.
	enteredMorphs will include morphs that have the mouse over them, and didn't before.
	overMorphs will include all morphs that have the mouse over them."
	aMouseEvent asMouseOver startDispatchFromHand: hand.
	"enteredMorphs and overMorphs are ordered:
	- First is the innest and topmost found morph.
	- Then comes its owner (meaning it is below it), and so on.
	- Last is the World, which is below every other morph."
	
	"Get out early if no change. No morph was entered or left, mouseOverMorphs remains same."
	(leftMorphs isEmpty and: [enteredMorphs position = 0])
		ifTrue: [
			leftMorphs := enteredMorphs := overMorphs := nil.
			^self ].
	enteredMorphs := enteredMorphs contents.
	overMorphs := overMorphs contents.
	
	mustSetKeyboardFocus := Preferences at: #focusFollowsMouse.

	"Send #mouseLeave as appropriate. Release any keyboard focus.
	Order is inner to outer."
	"Keep the order of the left morphs by recreating it from the mouseOverMorphs"
	leftMorphs size > 1 
		ifTrue: [leftMorphs := mouseOverMorphs select: [:m | leftMorphs includes: m]].
	leftMorphs do: [ :m |
		mustSetKeyboardFocus ifTrue: [
			hand releaseKeyboardFocusIf: m ].
		m isInWorld ifTrue: [
			aMouseEvent asMouseLeave sendEventTo: m ]].
	
	"Set keyboard focus to the innermost (i.e. topmost) entered morph that will take it."
	overMorphs do: [ :m |
		m isInWorld ifTrue: [
			(mustSetKeyboardFocus and: [ m handlesKeyboardFocus ]) ifTrue: [
				hand newKeyboardFocus: m.
				"Do it just once!!"
				mustSetKeyboardFocus := false ]]].
	
	"Send #mouseEnter as appropriate. Order is outer to Inner."
	enteredMorphs reverseDo: [ :m |
		m isInWorld ifTrue: [
			aMouseEvent asMouseEnter sendEventTo: m ]].
	
	"And remember the over list for the next call"
	mouseOverMorphs := overMorphs.
	leftMorphs := enteredMorphs := overMorphs := nil.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7547-mouseEnterToFocusFixes-JuanVuletich-2025Sep10-11h50m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7547] on 11 September 2025 at 8:57:11 am'!
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 9/9/2025 17:37:46' prior: 16887183!
                             mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	| mouseButton1DownHandled |

	mouseButton1DownHandled := self 
		valueOfProperty: #mouseButton1Up:localPosition:
		ifPresentDo: [ :handler | handler value: aMouseButtonEvent value: localEventPosition ]
		ifAbsent: [ false ].

	mouseButton1DownHandled ifFalse: [
		self handleInteraction: [ editor mouseButton1Up: aMouseButtonEvent  localPosition: localEventPosition ]].

	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ]! !
!MouseEvent methodsFor: 'dispatching' stamp: 'jmv 9/10/2025 16:20:12' prior: 50381902!
         dispatchIn: aWorldMorphOrFocusedMorph
	"Dispatch me.
	The event will be passed to the front-most visible submorph that contains the event position.
	Search usually starts with the WorldMorph, but it could be another morph if it is the hand's #mouseFocus.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."

	| handlerMorph |
	handlerMorph := aWorldMorphOrFocusedMorph topUnlockedMorphAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			self sendEventTo: handlerMorph ].
		handlerMorph := handlerMorph owner ].! !

EntryFieldMorph removeSelector: #mouseButton1Up:localPosition:!

!methodRemoval: EntryFieldMorph #mouseButton1Up:localPosition: stamp: 'Install-7548-MorphicEvents-Cleanup-JuanVuletich-2025Sep11-08h53m-jmv.001.cs.st 9/11/2025 17:28:35'!
mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition

	super mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition.
	self pauseBlinking
!

MouseScrollEvent removeSelector: #dispatchIn:!

!methodRemoval: MouseScrollEvent #dispatchIn: stamp: 'Install-7548-MorphicEvents-Cleanup-JuanVuletich-2025Sep11-08h53m-jmv.001.cs.st 9/11/2025 17:28:35'!
dispatchIn: aWorldMorphOrFocusedMorph
	"Dispatch me.
	The event will be passed to the front-most visible submorph that contains the event position.
	Search usually starts with the WorldMorph, but it could be another morph if it is the hand's #mouseFocus.
	If #rejectsEvent:, or #wasHandled not by any reason, try with the owner."

	| handlerMorph |
	handlerMorph := aWorldMorphOrFocusedMorph topUnlockedMorphAt: position.
	[ handlerMorph notNil and: [self wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			
			(handlerMorph handlesMouseScroll: self) ifTrue: [
				self sendEventTo: handlerMorph ].
			
		].
		handlerMorph := handlerMorph owner.
	].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7548-MorphicEvents-Cleanup-JuanVuletich-2025Sep11-08h53m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7547] on 11 September 2025 at 9:08:43 am'!
!MouseOverEvent methodsFor: 'dispatching' stamp: 'jmv 9/10/2025 16:19:55'!
                        dispatchIn: aWorldMorphOrFocusedMorph
	"Dispatch me.
	The event will be passed to all morphs at event position, in strict front to back order.
	This event is not handled, so it is passed to multiple recipients."

	| handlerMorph |
	handlerMorph := aWorldMorphOrFocusedMorph topUnlockedMorphAt: position.
	[ handlerMorph notNil ] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			self sendEventTo: handlerMorph ].
		handlerMorph := handlerMorph morphBehindAt: position ].! !
!Morph methodsFor: 'submorphs-accessing' stamp: 'jmv 9/11/2025 09:05:41'!
                              morphBehindAt: worldPoint
	"Answer the morph that
		- is behind us
		- covers worldPoint
		- is not locked, and no owner in the chain is
		- is visible, and all owners in the chain are
		- there's no other morph covering that point in between.
	Answer could be a sibling, a child of a sibling, our owner, some other ancestor, or some unrelated morph.
	Answer is nil only for the World."
	| top |
	owner ifNil: [
		^nil ].
	owner submorphsBehind: self do: [ :sibling |
		top := sibling topUnlockedMorphAt: worldPoint.
		top ifNotNil: [
			^top ]].
	(owner includesPixel: worldPoint)
		ifTrue: [
			^owner ].
	^owner morphBehindAt: worldPoint! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7549-Deliver-MouseOver-ToALLrelevantMorphs-JuanVuletich-2025Sep11-08h58m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7547] on 11 September 2025 at 9:12:13 am'!
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 9/9/2025 17:26:13' prior: 50382800!
   keyboardFocusChange: aBoolean
	"Notify change due to green border for keyboard focus"

	"We are losing focus"
	| newKeyboardFocus |
	aBoolean ifFalse: [
		newKeyboardFocus := self world activeHand keyboardFocus.
		(newKeyboardFocus ~~ prevKbdFocus and: [
			newKeyboardFocus notNil and: [
				(newKeyboardFocus hasOwner: self) not ]])
		ifTrue: [
			self deleteIfPopUp: nil.
			self redrawNeeded ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7550-MenuDefocusOnMouseMove-fix-JuanVuletich-2025Sep11-09h08m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7547] on 11 September 2025 at 9:17:34 am'!
!SystemWindow methodsFor: 'top window' stamp: 'jmv 9/9/2025 17:33:02' prior: 16980598!
  submorphToFocusKeyboard

	"Might answer nil"
	^self nextMorphThat: [ :m |
		m visible and: [
			(m handlesKeyboardFocus and: [ m isReallyVisible and: [ m isReallyUnlocked ]])
				and: [m owningWindow = self]]]! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/9/2025 17:30:29' prior: 16878546!
                   keyboardFocusNextWithinWindow
	| window |
	keyboardFocus ifNil: [^ false].
	window := keyboardFocus owningWindow.
	(keyboardFocus previousMorphThat: [ :m |
		m visible and: [
			(m handlesKeyboardFocus and: [ m isReallyVisible and: [ m isReallyUnlocked ]])
				and: [m owningWindow = window]]]) ifNotNil: [ :aMorph |
			self newKeyboardFocus: aMorph.
			aMorph keyboardFocused.
			^true ].
	^false! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/9/2025 17:30:14' prior: 16878572!
                       keyboardFocusPreviousWithinWindow
	| window |
	keyboardFocus ifNil: [^ false].
	window := keyboardFocus owningWindow.
	(keyboardFocus nextMorphThat: [ :m |
		m visible and: [
			(m handlesKeyboardFocus and: [ m isReallyVisible and: [ m isReallyUnlocked ]])
				and: [m owningWindow = window]]]) ifNotNil: [ :aMorph |
			self newKeyboardFocus: aMorph.
			aMorph keyboardFocused.
			^true ].
	^false! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/9/2025 17:28:25' prior: 16878617!
                       nextFocusMorph
	"Or nil"

	^(keyboardFocus ifNil: [ self world ])
		previousMorphThat: [ :m |
			m handlesKeyboardFocus and: [ m isReallyVisible and: [ m isReallyUnlocked ]]]
	
	"revisar, probar"! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/9/2025 17:28:43' prior: 16878632!
 previousFocusMorph
	"Or nil"

	^ (keyboardFocus ifNil: [ self world ])
		nextMorphThat: [ :m |
			m handlesKeyboardFocus and: [ m isReallyVisible and: [ m isReallyUnlocked ]]]
	
	"revisar, probar"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7551-handlesKeyboardFocus-not-handlesKeyboard-JuanVuletich-2025Sep11-09h12m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7538] on 9 September 2025 at 5:55:20 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/9/2025 17:51:56' prior: 50380825!
processKeyDown: aKeyboardEvent
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	self keyDown: aKeyboardEvent.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/9/2025 17:51:49' prior: 50380835!
   processKeyUp: aKeyboardEvent
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	self keyUp: aKeyboardEvent.! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/9/2025 17:51:39' prior: 50380845!
       processKeystroke: aKeyboardEvent
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	self keyStroke: aKeyboardEvent.
	self 
		valueOfProperty: #'keyStroke:'
		ifPresentDo: [ :handler |
			handler value: aKeyboardEvent.
			aKeyboardEvent wasHandled: true ].! !

InnerTextMorph removeSelector: #handlesKeyboard!

!methodRemoval: InnerTextMorph #handlesKeyboard stamp: 'Install-7552-AllMorphsHandleKeyboard-JuanVuletich-2025Sep09-17h51m-jmv.001.cs.st 9/11/2025 17:28:35'!
handlesKeyboard

	self isLocked ifTrue: [^false ].
	self disablesEditing ifTrue: [^false ].
	((owner is: #ScrollPane) and: [owner isLocked])
		ifTrue: [^false ].
	^self visible!

WorldMorph removeSelector: #handlesKeyboard!

!methodRemoval: WorldMorph #handlesKeyboard stamp: 'Install-7552-AllMorphsHandleKeyboard-JuanVuletich-2025Sep09-17h51m-jmv.001.cs.st 9/11/2025 17:28:35'!
handlesKeyboard

	^ true !

PluggableListMorph removeSelector: #handlesKeyboard!

!methodRemoval: PluggableListMorph #handlesKeyboard stamp: 'Install-7552-AllMorphsHandleKeyboard-JuanVuletich-2025Sep09-17h51m-jmv.001.cs.st 9/11/2025 17:28:35'!
handlesKeyboard

	self isLocked ifTrue: [^false ].
	^self visible!

HierarchicalListMorph removeSelector: #handlesKeyboard!

!methodRemoval: HierarchicalListMorph #handlesKeyboard stamp: 'Install-7552-AllMorphsHandleKeyboard-JuanVuletich-2025Sep09-17h51m-jmv.001.cs.st 9/11/2025 17:28:35'!
handlesKeyboard

	self isLocked ifTrue: [^false ].
	^self visible!

EntryFieldMorph removeSelector: #handlesKeyboard!

!methodRemoval: EntryFieldMorph #handlesKeyboard stamp: 'Install-7552-AllMorphsHandleKeyboard-JuanVuletich-2025Sep09-17h51m-jmv.001.cs.st 9/11/2025 17:28:35'!
handlesKeyboard

	^self visible!

MenuMorph removeSelector: #handlesKeyboard!

!methodRemoval: MenuMorph #handlesKeyboard stamp: 'Install-7552-AllMorphsHandleKeyboard-JuanVuletich-2025Sep09-17h51m-jmv.001.cs.st 9/11/2025 17:28:35'!
handlesKeyboard
	"Answer whether the receiver handle keyboard events"

	self isLocked ifTrue: [^false ].
	^self visible!

FindInSourceDialog removeSelector: #handlesKeyboard!

!methodRemoval: FindInSourceDialog #handlesKeyboard stamp: 'Install-7552-AllMorphsHandleKeyboard-JuanVuletich-2025Sep09-17h51m-jmv.001.cs.st 9/11/2025 17:28:35'!
handlesKeyboard

	^self visible!

Morph removeSelector: #handlesKeyboard!

!methodRemoval: Morph #handlesKeyboard stamp: 'Install-7552-AllMorphsHandleKeyboard-JuanVuletich-2025Sep09-17h51m-jmv.001.cs.st 9/11/2025 17:28:35'!
handlesKeyboard
	"Return true if the receiver wishes to handle keyboard events"

	"Use a property test to allow individual instances to specify this."
	^ self hasProperty: #'handlesKeyboard'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7552-AllMorphsHandleKeyboard-JuanVuletich-2025Sep09-17h51m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7552] on 11 September 2025 at 11:32:22 am'!
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 9/11/2025 11:29:24'!
                            mouseMove: aMouseMoveEvent localPosition: localEventPosition

	| eventPositionLocalToScroller |

	scroller highlightedRow: (
		(self viewableArea containsPoint: localEventPosition) ifTrue: [
			self rowAtLocation: localEventPosition ifNone: nil]).

	scroller ifNotNil: [
		eventPositionLocalToScroller := localEventPosition - scroller morphPosition.
		scroller  mouseMove: aMouseMoveEvent localPosition: eventPositionLocalToScroller ].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/11/2025 10:57:43' prior: 50381135!
                 processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	"Rules say that by default a morph gets #mouseMove iff
		* the hand is not dragging anything,
			+ and some button is down,
			+ and the receiver is the current mouse focus."
	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue: [
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1 ]! !
!DraggableButtonMorph methodsFor: 'events' stamp: 'jmv 9/11/2025 10:56:13' prior: 16851837!
      mouseMove: aMouseMoveEvent localPosition: localEventPosition

	aMouseMoveEvent anyButtonPressed ifTrue: [
		dragSelector ifNotNil: [
			model perform: dragSelector with: localEventPosition ]]! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 9/11/2025 11:00:03' prior: 50349832!
                             mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	
	scroller highlightedRow: (
		(self viewableArea containsPoint: localEventPosition) ifTrue: [
			self rowAtLocation: localEventPosition ifNone: nil]).
	
	aMouseMoveEvent anyButtonPressed ifFalse: [
		^self ].
	
	row := (localEventPosition y < 0 and: [ scrollBar scrollValue > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: `0@0`) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ self vLeftoverScrollRange > 0 and: [ scrollBar scrollValue < 1.0 ]])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [
					self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff := (self listSelectionAt: row) not.
		dragStartRow := row ].

	"Set meaning for subsequent dragging of selection"
	oldIndex := self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal := self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self setSelectionIndex: row ]
		ifFalse: [ self setSelectionIndex: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	dragStartRow ifNotNil: [
		(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
			self listSelectionAt: r put: dragOnOrOff ]].! !
!ResizeMorph methodsFor: 'events' stamp: 'jmv 9/11/2025 10:55:53' prior: 50379737!
                       mouseMove: aMouseMoveEvent localPosition: localEventPosition

	aMouseMoveEvent anyButtonPressed ifTrue: [
		self selectTo: localEventPosition ]! !

InnerTextMorph removeSelector: #processMouseMove:localPosition:!

!methodRemoval: InnerTextMorph #processMouseMove:localPosition: stamp: 'Install-7553-ProcessMouseMove-rework-JuanVuletich-2025Sep11-11h26m-jmv.001.cs.st 9/11/2025 17:28:35'!
processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Re-implemented to allow for mouse-up move events"

	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1]!

PluggableListMorph removeSelector: #processMouseMove:localPosition:!

!methodRemoval: PluggableListMorph #processMouseMove:localPosition: stamp: 'Install-7553-ProcessMouseMove-rework-JuanVuletich-2025Sep11-11h26m-jmv.001.cs.st 9/11/2025 17:28:35'!
processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"

	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	scroller highlightedRow: (
		(self viewableArea containsPoint: localEventPosition) ifTrue: [
			self rowAtLocation: localEventPosition ifNone: nil]).
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue:[
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1 ]!

HierarchicalListMorph removeSelector: #processMouseMove:localPosition:!

!methodRemoval: HierarchicalListMorph #processMouseMove:localPosition: stamp: 'Install-7553-ProcessMouseMove-rework-JuanVuletich-2025Sep11-11h26m-jmv.001.cs.st 9/11/2025 17:28:35'!
processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"Reimplemented because we really want #mouseMove when a morph is dragged around"

	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	self mouseMove: aMouseMoveEvent localPosition: localEventPosition.
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue: [
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1 ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7553-ProcessMouseMove-rework-JuanVuletich-2025Sep11-11h26m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7552] on 11 September 2025 at 11:39:39 am'!
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/9/2025 20:23:03' prior: 16878592!
                      newKeyboardFocus: aMorphOrNil
	"Make the given morph the new keyboard focus, canceling the previous keyboard focus if any.
	If the argument is nil, the current keyboard focus is cancelled."
	| oldFocus |
	keyboardFocus == aMorphOrNil ifFalse: [
		oldFocus := keyboardFocus.
		keyboardFocus := aMorphOrNil.
		oldFocus ifNotNil: [oldFocus keyboardFocusChange: false].
		aMorphOrNil ifNotNil: [aMorphOrNil keyboardFocusChange: true]].! !
!Morph methodsFor: 'event handling testing' stamp: 'jmv 9/11/2025 10:27:42'!
clickToFocusConsumesEvent
	"	For instance, for text editors and lists, if (Preferences at: #focusFollowsMouse) not, the click event
	used to set keyboard focus should not be used for anything else. Cursor position, selection, etc are not affected.
	 	For other morphs, like buttons, menu items, and the World, click may set keyboard focus, but the click action
	is also desired.
		Answer true by default. Morphs that want to react to the setting-focus click should redefine this method
	answering false. See inheritance."

	^true! !
!HaloHandleMorph methodsFor: 'event handling testing' stamp: 'jmv 9/11/2025 10:27:49'!
                    clickToFocusConsumesEvent
	"We react immediately to clicks, even if they are used to set keyboard focus on us.
	See inheritance."
	
	^false! !
!MenuItemMorph methodsFor: 'event handling testing' stamp: 'jmv 9/11/2025 10:27:33'!
                            clickToFocusConsumesEvent
	"We react immediately to clicks, even if they are used to set keyboard focus on us.
	See inheritance."
	
	^false! !
!PluggableButtonMorph methodsFor: 'event handling testing' stamp: 'jmv 9/11/2025 10:28:00'!
                     clickToFocusConsumesEvent
	"We react immediately to clicks, even if they are used to set keyboard focus on us.
	See inheritance."
	
	^false! !
!PasteUpMorph methodsFor: 'event handling testing' stamp: 'jmv 9/11/2025 10:28:08'!
                             clickToFocusConsumesEvent
	"We react immediately to clicks, even if they are used to set keyboard focus on us.
	See inheritance."
	
	^false! !
!LayoutAdjustingMorph methodsFor: 'event handling testing' stamp: 'jmv 9/11/2025 10:28:16'!
                     clickToFocusConsumesEvent
	"We react immediately to clicks, even if they are used to set keyboard focus on us.
	See inheritance."
	
	^false! !
!ResizeMorph methodsFor: 'event handling testing' stamp: 'jmv 9/11/2025 10:28:43'!
                              clickToFocusConsumesEvent
	"We react immediately to clicks, even if they are used to set keyboard focus on us.
	See inheritance."
	
	^false! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/11/2025 10:14:07' prior: 50381099!
                         processMouseDown: aMouseButtonEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	aMouseButtonEvent hand removePendingBalloonFor: self.
	aMouseButtonEvent wasHandled: true.
	self activateWindow.
	aMouseButtonEvent hand newMouseFocus: self.		"Mouse down sets mouse focus"

	aMouseButtonEvent mouseButton2Pressed ifTrue: [
		self mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition.
		aMouseButtonEvent hand removeHaloFromClick: aMouseButtonEvent on: self.
		^self ].

	aMouseButtonEvent mouseButton3Pressed ifTrue: [
		self mouseButton3Down: aMouseButtonEvent localPosition: localEventPosition.
		^self ].

	aMouseButtonEvent hand removeHaloFromClick: aMouseButtonEvent on: self.
	
	"If we click to focus, don't process this event as a regular click.
	See also #processMouseUp:localPosition:, where the focus is actually set."
	(self clickToFocusConsumesEvent and: [
		(Preferences at: #focusFollowsMouse) not and: [
			self hasKeyboardFocus not ]])
		ifFalse: [ self mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	(self handlesMouseStillDown: aMouseButtonEvent) ifTrue: [
		self startStepping: #processMouseStillDown
			in: self mouseStillDownThreshold
			stepTime: self mouseStillDownStepRate ].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/11/2025 11:38:31' prior: 50384079!
               processMouseMove: aMouseMoveEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	"Rules say that by default a morph gets #mouseMove iff
		* the hand is not dragging anything,
			+ and some button is down,
			+ and the receiver is the current mouse focus."
	aMouseMoveEvent hand hasSubmorphs ifTrue: [ ^self ].
	aMouseMoveEvent wasHandled: true.
	
	"If we click to focus, mouse down wasn't processed as a regular event in #processMouseDown:localPosition:,
	because we'll set keyboard focus on mouse up. Then, also ignore mouse moves.
	See also #processMouseUp:localPosition:, where the focus is actually set."
	(self clickToFocusConsumesEvent and: [
		(Preferences at: #focusFollowsMouse) not and: [
			self hasKeyboardFocus not ]])
		ifFalse: [ self mouseMove: aMouseMoveEvent localPosition: localEventPosition ].
	
	
	
	(aMouseMoveEvent anyButtonPressed and: [ self hasMouseFocus ]) ifFalse: [ ^self ].
	(self handlesMouseStillDown: aMouseMoveEvent) ifTrue: [
		"Step at the new location"
		self startStepping: #processMouseStillDown stepTime: 1 ]! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/11/2025 10:13:24' prior: 50381202!
                   processMouseUp: aMouseButtonEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	aMouseButtonEvent hand releaseMouseFocus: self.
	aMouseButtonEvent wasHandled: true.
	aMouseButtonEvent mouseButton3Changed ifTrue: [ 
		self mouseButton3Up: aMouseButtonEvent localPosition: localEventPosition.
		^self ].

	aMouseButtonEvent mouseButton2Changed ifTrue: [
		self mouseButton2Up: aMouseButtonEvent localPosition: localEventPosition.
		^self ].

	"If we click to focus, don't process this event as a regular click.
	See also #processMouseDown:localPosition:"
	(self clickToFocusConsumesEvent and: [
		(Preferences at: #focusFollowsMouse) not and: [
			self hasKeyboardFocus not ]])
		ifTrue: [ aMouseButtonEvent hand newKeyboardFocus: self ]
		ifFalse: [ self mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition ].

	self stopStepping: #processMouseStillDown! !
!EntryFieldMorph methodsFor: 'events' stamp: 'jmv 9/9/2025 17:59:00' prior: 16859303!
        mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	self editor mouseDown: aMouseButtonEvent index: (self characterIndexAtPoint: localEventPosition).
	self redrawNeeded.

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 9/9/2025 17:59:04' prior: 50376175!
                     mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| itemMorph |
	itemMorph := self itemFromPoint: localEventPosition.
	itemMorph ifNil: [
		super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
		^self ].
	self highlightedMorph: itemMorph.
	(itemMorph inToggleArea: (itemMorph internalize: (scroller internalize: localEventPosition)))
		ifTrue: [
			self toggleExpandedState: itemMorph event: aMouseButtonEvent.
			^self ]. 
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent 
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil
		dragSel: ((self valueOfProperty: #allowsItemDrag) = true ifTrue: [ #dragEvent:localPosition: ])! !
!PluggableListMorph methodsFor: 'events' stamp: 'jmv 9/11/2025 09:44:19' prior: 50376206!
                           mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| row |
	row := self 
		rowAtLocation: localEventPosition
		ifNone:  [
			super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
			^self ].

	"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update
	the view. Model update will be done on mouse button up, so this feedback will be visible before that."
	scroller highlightedRow: row.

	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil
		dragSel: ((self valueOfProperty: #allowsItemDrag) = true ifTrue: [ #dragEvent:localPosition: ] ifFalse: [ nil ])! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 9/11/2025 09:45:10' prior: 50376243!
                              mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| oldIndex oldVal row w |

	row := self rowAtLocation: localEventPosition.

	row = 0 ifTrue: [
		super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.
		^self ].

	"Highlight the row to be selected, for immediate user feedback in case the model takes a while to update
	the view. Model update will be done on mouse button up, so this feedback will be visible before that."
	scroller highlightedRow: row.

	w := self owningWindow.
	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"

		"Set meaning for subsequent dragging of selection"
		dragOnOrOff := (self listSelectionAt: row) not.
		dragStartRow := row.
		oldIndex := self getCurrentSelectionIndex.
		oldIndex ~= 0 ifTrue: [oldVal := self listSelectionAt: oldIndex].

		"Different from PluggableListMorph. There, we highlight on mouse down, and act on mouse up.
		Here, we act on mouse down, because we support dragging of selection, so mouse up will
		only happen after user is finished dragging. In order to get the highlight visible for the user,
		update the model on next world cycle."
		UISupervisor whenUIinSafeState: [
			"Set or clear new primary selection (listIndex)"
			dragOnOrOff == true
				ifTrue: [self setSelectionIndex: row]
				ifFalse: [self setSelectionIndex: 0].
			"Need to restore the old one, due to how model works, and set new one."
			oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].
			self listSelectionAt: row put: dragOnOrOff ].
	].
	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: nil
		tripleClkSel: nil
		dragSel: (
			aMouseButtonEvent shiftPressed ifFalse: [
				(self valueOfProperty: #allowsItemDrag) = true
						ifTrue: [ #dragEvent:localPosition: ] ifFalse: [ nil ] ])! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 9/9/2025 18:00:05' prior: 16887156!
                mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.

	self handleInteraction: [ editor mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: #doubleClickAndHalf:localPosition:
		tripleClkSel: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7554-clickToFocus-NewMechanism-JuanVuletich-2025Sep11-11h32m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7554] on 11 September 2025 at 12:32:36 pm'!
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/11/2025 12:31:21' prior: 50380897!
   processMouseEnter: aMouseEnterEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	self wantsBalloon ifTrue: [
		aMouseEnterEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: aMouseEnterEvent) ifTrue: [
		aMouseEnterEvent wasHandled: true.
		self mouseEnter: aMouseEnterEvent ].! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 9/11/2025 12:31:15' prior: 50380915!
         processMouseLeave: aMouseLeaveEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."

	aMouseLeaveEvent hand removePendingBalloonFor: self.
	(self handlesMouseOver: aMouseLeaveEvent) ifTrue: [
		aMouseLeaveEvent wasHandled: true.
		self mouseLeave: aMouseLeaveEvent ].! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/11/2025 12:30:19' prior: 50382118!
                               startMouseButtonDispatch: aMouseEvent

	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		(mouseClickState handleEvent: aMouseEvent from: self) ifTrue: [
			"Possibly dispatched #click: or something. Do not further process this event."
			aMouseEvent wasHandled: true.
			^self ]].

	"Issue a synthetic move event if we're not at the position of the event"
	aMouseEvent eventPosition = self morphPosition ifFalse: [
		"Issue a mouse move event to make the receiver appear at the given position"
		(MouseMoveEvent new
			setPosition: aMouseEvent eventPosition
			buttons: aMouseEvent buttons
			hand: self
			stamp: aMouseEvent timeStamp) startDispatchFromHand: self ].

	"Drop submorphs on button events"
	self hasSubmorphs
		ifTrue: [
			"Not if we are grabbing them"
			mouseClickState ifNil: [
				"Want to drop on mouseUp, NOT mouseDown"
				aMouseEvent isMouseUp ifTrue: [
					self dropMorphs: aMouseEvent ]]]
		ifFalse: [
			self mouseFocus
				ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
				ifNil: [ aMouseEvent dispatchIn: owner ]].

	self hasSubmorphs ifFalse: [
		self dispatchMouseOverEvent ].! !
!HandMorph methodsFor: 'events-processing' stamp: 'jmv 9/11/2025 12:30:30' prior: 50382159!
       startMouseMoveDispatch: aMouseEvent

	lastMouseEvent := aMouseEvent.	
	lastMouseEventTime := Time localMillisecondClock.

	"Check for pending drag or double click operations."
	mouseClickState ifNotNil: [
		mouseClickState handleEvent: aMouseEvent from: self ].

	self morphPosition: aMouseEvent eventPosition.
	self mouseFocus
		ifNotNil: [ mouseFocus handleMouseFocusEvent: aMouseEvent ]
		ifNil: [ aMouseEvent dispatchIn: owner ].

	self hasSubmorphs ifFalse: [
		self dispatchMouseOverEvent ].! !

MenuItemMorph removeSelector: #processMouseEnter:localPosition:!

!methodRemoval: MenuItemMorph #processMouseEnter:localPosition: stamp: 'Install-7555-Cleanup-JuanVuletich-2025Sep11-12h26m-jmv.001.cs.st 9/11/2025 17:28:35'!
processMouseEnter: aMouseEnterEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	self wantsBalloon ifTrue: [
		aMouseEnterEvent hand triggerBalloonFor: self after: self balloonHelpDelayTime].
	(self handlesMouseOver: aMouseEnterEvent) ifTrue:[
		aMouseEnterEvent wasHandled: true.
		self mouseEnter: aMouseEnterEvent ]!

MenuItemMorph removeSelector: #processMouseLeave:localPosition:!

!methodRemoval: MenuItemMorph #processMouseLeave:localPosition: stamp: 'Install-7555-Cleanup-JuanVuletich-2025Sep11-12h26m-jmv.001.cs.st 9/11/2025 17:28:35'!
processMouseLeave: aMouseLeaveEvent localPosition: localEventPosition
	"A MorphicEvent was delivered to us.
	If appropriate, handle it and mark it as #wasHandled: true."
	
	aMouseLeaveEvent hand removePendingBalloonFor: self.
	(self handlesMouseOver: aMouseLeaveEvent) ifTrue: [
		aMouseLeaveEvent wasHandled: true.
		self mouseLeave: aMouseLeaveEvent ]!

MouseEvent removeSelector: #isDraggingEvent!

!methodRemoval: MouseEvent #isDraggingEvent stamp: 'Install-7555-Cleanup-JuanVuletich-2025Sep11-12h26m-jmv.001.cs.st 9/11/2025 17:28:35'!
isDraggingEvent
	source ifNil:[^false].
	source hasSubmorphs ifTrue:[^true].
	self anyButtonPressed ifTrue:[^true].
	^false!

MorphicEvent removeSelector: #isDraggingEvent!

!methodRemoval: MorphicEvent #isDraggingEvent stamp: 'Install-7555-Cleanup-JuanVuletich-2025Sep11-12h26m-jmv.001.cs.st 9/11/2025 17:28:35'!
isDraggingEvent
	^false!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7555-Cleanup-JuanVuletich-2025Sep11-12h26m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7554] on 11 September 2025 at 12:41:51 pm'!
!TextModelMorph methodsFor: 'focus handling' stamp: 'jmv 9/11/2025 12:40:20'!
              hasKeyboardFocus
	"For all practical purposes, our inner text having focus means us having focus. No two separated concepts."
	^super hasKeyboardFocus or: [ scroller hasKeyboardFocus ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7556-ClickOnText-fix-JuanVuletich-2025Sep11-12h32m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7556] on 11 September 2025 at 1:03:33 pm'!
!DropEvent methodsFor: 'dispatching' stamp: 'jmv 9/11/2025 13:03:31' prior: 50382560!
     dispatchIn: aWorldMorph
	"Drop is done on the innermost target that accepts it.
	If #rejectsEvent:, any party doesn't want the drop,or #wasHandled not by any reason, try with the owner."

	| handlerMorph dropped |
	handlerMorph := aWorldMorph topUnlockedMorphAt: position.
	[ handlerMorph notNil and: [wasHandled not]] whileTrue: [
		((handlerMorph rejectsEvent: self) not and: [handlerMorph includesPixel: position]) ifTrue: [
			handlerMorph allowsMorphDrop ifTrue: [
				"Do a symmetric check if both morphs like each other"
				dropped := self contents.
				((handlerMorph wantsDroppedMorph: dropped event: self)		"I want her"
					and: [dropped wantsToBeDroppedInto: handlerMorph])		"she wants me"
						ifTrue: [ self sendEventTo: handlerMorph ]].
			wasHandled
				ifFalse: [
					handlerMorph invalidDrop: self.
					(self contents is: #DraggingGuideMorph) ifTrue: [
						self wasHandled: true.
						self contents delete ]
					]
		].
		handlerMorph := handlerMorph owner.
	].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7557-DnD-methodOnCategory-fix-again-JuanVuletich-2025Sep11-12h59m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7557] on 11 September 2025 at 3:15:32 pm'!
!LayoutAdjustingMorph methodsFor: 'events' stamp: 'jmv 9/11/2025 15:01:09' prior: 50379722!
              mouseEnter: aMouseEnterEvent
	super mouseEnter: aMouseEnterEvent.
	self cursor activateCursor.! !
!LayoutAdjustingMorph methodsFor: 'events' stamp: 'jmv 9/11/2025 15:04:19' prior: 50379729!
  mouseLeave: aMouseLeaveEvent
	super mouseLeave: aMouseLeaveEvent.
	aMouseLeaveEvent mouseButton1Pressed ifFalse: [
		Cursor defaultCursor activateCursor ].! !
!WindowEdgeAdjustingMorph methodsFor: 'adjusting' stamp: 'jmv 9/11/2025 15:13:15' prior: 17017350!
                              adjustOwnerAt: aGlobalPoint millisecondSinceLast: millisecondSinceLast

	self basicAdjustOwnerAt: aGlobalPoint.

	"If UI is becoming slow or is optimized for slow systems, resize without
	showing window contents, but only edges. But don't do it for rotated Windows!!"
	(owner isOrAnyOwnerIsRotated not and: [
		(Preferences at: #cheapWindowReframe) or: [millisecondSinceLast > 100]]) ifTrue: [
			owner displayBounds newRect2From: [ :f |
				self stopStepping.
				hand := nil.
				self basicAdjustOwnerAt: Sensor mousePoint.
				owner morphPosition extent: owner extentInWorld ].
			Cursor defaultCursor activateCursor ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7558-WindowReframe-fixes-JuanVuletich-2025Sep11-15h13m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7558] on 11 September 2025 at 3:43:02 pm'!
!Morph methodsFor: 'focus handling' stamp: 'jmv 9/11/2025 15:39:38'!
                            submorphToFocusKeyboard
	"Answer a preferred submorph for initial keyboard focus, if desired."
	^nil! !
!SystemWindow methodsFor: 'top window' stamp: 'jmv 9/11/2025 15:41:02' prior: 16980569!
activateAndSendTopToBack: aBoolean
	"Bring me to the front and make me able to respond to mouse and keyboard"

	| oldTop |
	owner 
		ifNil: [^self	"avoid spurious activate when drop in trash"].
	
	self isTopWindow ifTrue: [
		self comeToFront.
		^self ].

	oldTop := TopWindow.
	TopWindow := self.
	self needsRedraw: true.

	oldTop ifNotNil: [
		oldTop invalidateTitleArea.
		aBoolean ifTrue: [
			| bottomWindow |
			bottomWindow := oldTop owner submorphs reverse detect: [:one | one is: #SystemWindow].
			oldTop owner addMorph: oldTop behind: bottomWindow]].

	self comeToFront.

	"Set keyboard focus"
	self world ifNotNil: [ :w |
		self submorphToFocusKeyboard
			ifNotNil: [ :fkm | w activeHand newKeyboardFocus: fkm ]
			ifNil: [ w activeHand dispatchMouseOverEvent ]]! !

SystemWindow removeSelector: #submorphToFocusKeyboard!

!methodRemoval: SystemWindow #submorphToFocusKeyboard stamp: 'Install-7559-InitialKeyboardFocus-fix-JuanVuletich-2025Sep11-15h42m-jmv.001.cs.st 9/11/2025 17:28:35'!
submorphToFocusKeyboard

	"Might answer nil"
	^self nextMorphThat: [ :m |
		m visible and: [
			(m handlesKeyboardFocus and: [ m isReallyVisible and: [ m isReallyUnlocked ]])
				and: [m owningWindow = self]]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7559-InitialKeyboardFocus-fix-JuanVuletich-2025Sep11-15h42m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7559] on 11 September 2025 at 3:54:50 pm'!
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 10/12/2020 19:17:55' prior: 50382811!
                          select
	self isSelected: true.
	owner activeSubmenu: subMenu.
	subMenu ifNotNil: [
		self displayBounds ifNotNil: [ :r |
			subMenu delete.
			subMenu
				popUpAdjacentTo: (Array with: r topRight + `10@0` with: r topLeft)
				from: self ].
		subMenu selectItem: nil ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7560-tweak-JuanVuletich-2025Sep11-15h53m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7560] on 11 September 2025 at 4:27:57 pm'!
!ModalDialog methodsFor: 'modal UI' stamp: 'jmv 9/11/2025 16:10:40' prior: 16909536!
                             waitForUserResponse
	"Wait for the user to accept or cancel, and answer the response. Answers nil if the user cancels."
	"Details:
	This method suspends the current process until we have an appropriate 'response' and close.
	To keep the UI alive, it schedules a new Morphic Process that is terminated as ours is resumed.
	(If called from a non-UI process, a new Morphic process is not needed, but the calling process is suspended nevertheless)."

	| w |
	w := self world.
	w isNil ifTrue: [^ response ].
	callingProcess := nil.
	done := false.

	"If called from the UI process, suspend it (to later resume it with the answer)
	and run a new UI process for UI interaction with the receiver.."
	callingProcessIsUIProcess := UISupervisor isUIProcessRunning.
	callingProcessIsUIProcess ifTrue: [
		UISupervisor spawnNewMorphicProcessFor: w createNewCanvas: false ].

	"Suspend the calling process, regardless of it being the UI process or not.
	Usually variable 'done' will be false at this point.
	In the extremely rare case where user has already done [ok] or [cancel] in the just spawned new UI process,
	don't suspend us, as no one would resume us again."
	done ifFalse: [
		callingProcess := Processor activeProcess.
		callingProcess suspend ].

	"At this point we are resumed by ModalDialog >> #delete, after user doing [ok] or [cancel]"
	^ response.! !
!ModalDialog class methodsFor: 'instance creation' stamp: 'jmv 9/11/2025 16:19:08' prior: 16909606!
                openModal
	"Open a Modal Dialog. Answer user's response (if OK) or nil (if Cancel)
	This is an abstract class. Better play with SampleModalDialog. Inspect the result of:
		SampleModalDialog openModal
	Note: a ModalDialog can also be opened in non-modal mode calling #open.
		No answer will be returned, so #ok and #cancel need to do any approriate actions.
	"
	| world dialog answer prevKbdFocus |
	world := self runningWorld ifNil: [UISupervisor ui].
	prevKbdFocus := world activeHand keyboardFocus.
	dialog := self new beColumn buildWidgets.
	world addMorph: dialog centeredNear: world activeHand morphPosition.
	answer := dialog waitForUserResponse.
	prevKbdFocus ifNotNil: [ world activeHand newKeyboardFocus: prevKbdFocus ].
	^answer! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 9/11/2025 16:17:20' prior: 50382280!
               request: queryString initialAnswer: defaultAnswer orCancel: cancelBlock
	"Modal. This method returns after an answer is provided."

	| morph world prevKbdFocus response |
	morph := self newColumn
		setQuery: queryString
		initialAnswer: defaultAnswer.
	world := self runningWorld.
	world ifNil: [
		| answer |
		answer := self.	"Just a marker object, can not use nil, because it is a possible answer (if user cancels)"
		UISupervisor whenUIinSafeState: [ answer := self request: queryString initialAnswer: defaultAnswer orCancel: cancelBlock ].
		 [ answer == self ] whileTrue: [ Processor yield ].
		^answer ].
	prevKbdFocus := world activeHand keyboardFocus.
	world addMorph: morph centeredNear: world activeHand morphPosition - self deltaToTextPane.
	morph textBox focusText.
	response := morph getUserResponseOrCancel: cancelBlock.
	prevKbdFocus ifNotNil: [ world activeHand newKeyboardFocus: prevKbdFocus ].
	^response! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'jmv 9/11/2025 16:18:16' prior: 50382307!
                      request: queryString initialAnswer: defaultAnswer verifying: validationBlock orCancel: cancelBlock
	"Modal. This method returns when an answer is provided."

	| morph world prevKbdFocus response |
	morph := self newColumn
		setQuery: queryString
		initialAnswer: defaultAnswer;
		validationBlock: validationBlock.
	world := self runningWorld.
	world ifNil: [
		| answer |
		answer := self.	"Just a marker object, can not use nil, because it is a possible answer (if user cancels)"
		UISupervisor whenUIinSafeState: [
			answer := self request: queryString initialAnswer: defaultAnswer verifying: validationBlock orCancel: cancelBlock ].
		 [ answer == self ] whileTrue: [ Processor yield ].
		^answer ].
	prevKbdFocus := world activeHand keyboardFocus.
	world addMorph: morph centeredNear: world activeHand morphPosition - self deltaToTextPane.
	morph textBox focusText.
	response := morph getUserResponseOrCancel: cancelBlock.
	prevKbdFocus ifNotNil: [ world activeHand newKeyboardFocus: prevKbdFocus ].
	^response! !
!HandMorph methodsFor: 'focus handling' stamp: 'jmv 9/11/2025 16:05:47' prior: 50383108!
            releaseKeyboardFocusIfOrOwnedBy: aMorph
	"If the given morph had the keyboard focus before, release it"
	keyboardFocus ifNotNil: [
		keyboardFocus withAllOwnersDo: [ :outerOwner |
			outerOwner == aMorph ifTrue: [
				self releaseKeyboardFocus.
				"Try to find a good keyboard focus"
				self dispatchMouseOverEvent ]]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7561-KeyboardFocusOnDialogOrMorphDelete-JuanVuletich-2025Sep11-16h27m-jmv.001.cs.st----!

'From Cuis7.5 [latest update: #7539] on 10 September 2025 at 6:35:53 pm'!
!ExtractMethodParametersDetector methodsFor: 'private' stamp: 'NPM 9/10/2025 18:05:50'!
        firstPositionInIntervalToExtractIn: sourceRanges 

	^ (self intervalsToExtractIn: sourceRanges)
		min: [ :sourceRange | sourceRange first ]! !
!ExtractMethodParametersDetector methodsFor: 'private' stamp: 'NPM 9/10/2025 18:05:50'!
                         intervalsToExtractIn: sourceRanges

	^ sourceRanges select: [ :sourceRange | intervalToExtract includesAllOf: sourceRange ]! !
!ExtractMethodParametersDetector methodsFor: 'evaluating' stamp: 'NPM 9/10/2025 18:20:47' prior: 16863586!
                      value
	
	"Return the parse nodes of the parameters to use in the extracted method.
	
	Implementation details
	--------------
	The enumeration order of the parse nodes is non-deterministic.
	
	To fix this, I keep track of the position for each parameter node to sort
	results in the order they appear in the source code."
	
	| parameterNodePositions |
	
	parameterNodePositions := Dictionary new.
	
	methodNodeToRefactor completeSourceRangesDo: [ :parseNode :sourceRanges |
		(self shouldBeParameterized: parseNode appearingIn: sourceRanges)
			ifTrue: [ 
				parameterNodePositions
					at: parseNode
					put: (self firstPositionInIntervalToExtractIn: sourceRanges) ]].
		
	^ parameterNodePositions keys sort: [ :parameterNode :anotherParameterNode |
		(parameterNodePositions at: parameterNode) <= (parameterNodePositions at: anotherParameterNode) ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\7562-FixOrderOfParametersWhenExtractingAMethod-NicolasPapagnaMaldonado-2025Sep10-17h55m-NPM.001.cs.st----!

----QUIT----(11 September 2025 17:28:40) Cuis7.5-7562.image priorSource: 1624104!