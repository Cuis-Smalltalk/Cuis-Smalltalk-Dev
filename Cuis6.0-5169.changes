'From Cuis 6.0 [latest update: #5031] on 31 December 2021 at 3:19:41 pm'!


----QUIT----(31 December 2021 15:19:47) Cuis6.0-5031.image priorSource: 0!

----STARTUP---- (21 February 2022 14:50:15) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.0-5031.image!


'From Cuis 5.0 [latest update: #5007] on 30 December 2021 at 4:36:42 pm'!
!RenameClass methodsFor: 'applying - private' stamp: 'HAW 12/30/2021 16:28:15' prior: 16926919!
references: aMethodReference classVarNamed: aName

	^(aMethodReference actualClass theNonMetaClass definesClassVariableNamedInHierarchy: aName) 
		or: [ aMethodReference actualClass theMetaClass definesClassVariableNamedInHierarchy: aName ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5032-RenameClassFix-HernanWilkinson-2021Dec27-16h23m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5032] on 3 January 2022 at 8:33:41 pm'!

SystemWindow subclass: #PackageInstallerWindow
	instanceVariableNames: 'filterString filterInput currentIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Packages'!

!classDefinition: #PackageInstallerWindow category: #'Tools-Packages' stamp: 'Install-5033-PackageInstaller-MarianoMontone-2022Jan03-21h00m-MM.001.cs.st 2/21/2022 14:50:20'!
SystemWindow subclass: #PackageInstallerWindow
	instanceVariableNames: 'filterString filterInput currentIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Packages'!
!PackageInstallerWindow commentStamp: '<historical>' prior: 0!
I'm a tool for listing locally available Cuis packages and installing them.!

Object subclass: #PackageInstaller
	instanceVariableNames: 'packageList'
	classVariableNames: 'PackageList'
	poolDictionaries: ''
	category: 'Tools-Packages'!

!classDefinition: #PackageInstaller category: #'Tools-Packages' stamp: 'Install-5033-PackageInstaller-MarianoMontone-2022Jan03-21h00m-MM.001.cs.st 2/21/2022 14:50:20'!
Object subclass: #PackageInstaller
	instanceVariableNames: 'packageList'
	classVariableNames: 'PackageList'
	poolDictionaries: ''
	category: 'Tools-Packages'!
!PackageInstaller commentStamp: '<historical>' prior: 0!
                  I'm the model of PackageInstallerWindow.!
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 11/25/2021 15:21:52'!
  buildActionsBar

	| actionsBar | 
	
	actionsBar _ LayoutMorph newRow.
	
	actionsBar addMorph:
		(PluggableButtonMorph 
				model: self 
				action: #installPackage
				label: 'Install package').
	actionsBar addMorph:
		(PluggableButtonMorph
				model: self
				action: #updatePackageList
				label: 'Update package list').
	
	actionsBar addMorph: (LabelMorph contents: 'Search: ').
	
	filterInput _ TextModelMorph textProvider: self textGetter: #filterString textSetter: #filterString:.
	filterInput acceptOnCR: true;
		askBeforeDiscardingEdits: false.
	actionsBar addMorph: filterInput layoutSpec: (LayoutSpec fixedHeight: 30).
	
	^ actionsBar! !
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 11/25/2021 13:56:23'!
    buildDetailPane
	^ TextModelMorph textProvider:  self textGetter: #packageDescription! !
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 11/25/2021 15:23:37'!
                   buildMorphicWindow

	|layout|
		
	layout _ LayoutMorph newRow.
	layout addMorph: self buildPackageListMorph layoutSpec: (LayoutSpec proportionalWidth: 0.5).
	layout addAdjusterAndMorph: self buildDetailPane layoutSpec: (LayoutSpec proportionalWidth: 0.5).
	self addMorph: layout layoutSpec: (LayoutSpec proportionalWidth: 1).
	self addMorph: self buildActionsBar layoutSpec: (LayoutSpec new fixedHeight: 30; proportionalWidth: 1; yourself). 
	! !
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 11/25/2021 15:29:21'!
             buildPackageListMorph
	
	^ PluggableListMorph model: self listGetter: #packageListNames indexGetter: #currentIndex indexSetter: #currentIndex:.! !
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 12/27/2021 20:33:57' overrides: 16959063!
     windowColor
	^ Color fromHexString: '#88e6d8'! !
!PackageInstallerWindow methodsFor: 'initialization' stamp: 'MM 11/25/2021 15:18:18' overrides: 16959340!
     initialize
	super initialize.
	filterString _ ''.! !
!PackageInstallerWindow methodsFor: 'actions' stamp: 'MM 11/25/2021 19:26:26'!
                            installPackage
	self selectedPackage ifNotNil: [:package | 
		(FeatureRequirement name: package packageName)
		pathName: package fullName;
		satisfyRequirementsAndInstall]! !
!PackageInstallerWindow methodsFor: 'actions' stamp: 'MM 11/25/2021 14:04:10'!
  open
	self buildMorphicWindow.
	labelString _ 'Package Installer'.
	self openInWorld! !
!PackageInstallerWindow methodsFor: 'actions' stamp: 'MM 11/25/2021 15:30:07'!
                         updatePackageList

	model updatePackageList.
	self changed: #packageListNames! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 15:17:00'!
                              currentIndex
	^ currentIndex ifNil: [0]! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 15:17:08'!
    currentIndex: index
	currentIndex _ index.
	self changed: #acceptedContents! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 13:43:45'!
filterInput
	"Answer the value of filterInput"

	^ filterInput! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 13:43:45'!
             filterInput: anObject
	"Set the value of filterInput"

	filterInput _ anObject! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 13:43:45'!
                             filterString
	"Answer the value of filterString"

	^ filterString! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 16:53:16'!
          filterString: aString
	"Set the value of filterString"

	filterString _ aString.
	filterInput hasUnacceptedEdits: false.
	self currentIndex: nil.
	self changed: #packageListNames! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 16:18:21'!
                         filteredPackageList

	| packageList |
	
	packageList _ model packageList.
	
	^ filterString isEmpty
		ifTrue: [packageList]
		ifFalse: [packageList select: [:package | package packageName includesSubstring: filterString caseSensitive: false]]! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 14:18:16'!
                         getFilter
	^ [:str :el | el printString includesSubstring: str caseSensitive: false]! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 13:43:45' overrides: 16911717!
   model
	"Answer the value of model"

	^ model! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 13:43:45' overrides: 16911747!
           model: anObject
	"Set the value of model"

	model _ anObject! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 19:19:54'!
               packageDescription

	|package|
	
	package _ self selectedPackage.
	
	package ifNil: [^''].
	
	^ String streamContents: [:s | 
		s nextPutAll: package packageName;
			newLine.
		60 timesRepeat: [	s nextPut: $-].
		s newLine; newLine.
		
		package packageDescription ifNotEmpty: [:description |
			s nextPutAll: description;
				newLine;
				newLine].
		
		s nextPutAll: package description]! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 16:12:17'!
      packageListNames

	^ self filteredPackageList collect: [:package | package packageName].
	
	! !
!PackageInstallerWindow methodsFor: 'accessing' stamp: 'MM 11/25/2021 16:10:59'!
               selectedPackage
	currentIndex ifNil: [^nil].
	currentIndex isZero ifTrue: [^nil].
	^ self filteredPackageList at: currentIndex.! !
!PackageInstallerWindow class methodsFor: 'as yet unclassified' stamp: 'MM 11/25/2021 15:11:25'!
                            open

	^ self open: PackageInstaller new label: 'Package Installer'! !
!PackageInstallerWindow class methodsFor: 'as yet unclassified' stamp: 'MM 11/25/2021 17:15:50'!
                        worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		10.
			#label 			->	'Package Installer'.
			#object 			-> 	PackageInstallerWindow.
			#selector 		-> 		#open.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for installing local Cuis packages.'.
		} asDictionary}`! !
!PackageInstaller methodsFor: 'accessing' stamp: 'MM 11/25/2021 15:12:28'!
   addPackage: aPackageSpec

	packageList add: aPackageSpec! !
!PackageInstaller methodsFor: 'accessing' stamp: 'MM 11/25/2021 14:24:04'!
                         packageList
	"Answer the value of packageList"

	^ packageList! !
!PackageInstaller methodsFor: 'actions' stamp: 'MM 11/25/2021 19:16:55'!
                     collectPackagesFromDirectory: aDirectory

	"Create a collection of PackageSpec with package files found in aDirectory."
	
	|packageFiles|
	
	packageFiles _ aDirectory fileNamesMatching: '*.pck.st'.
		
	packageFiles do: [:packageFile | | codePackage |
		codePackage _ CodePackageFile onFileEntry: (aDirectory // packageFile).
		self addPackage: codePackage]! !
!PackageInstaller methodsFor: 'actions' stamp: 'MM 11/25/2021 14:39:54'!
               collectPackagesFromDisk

	"Collect PackageSpec with package files found in Cuis packages directories."
	
	self placesToLookForPackagesDo: [:aDirectory | 
		self collectPackagesFromDirectory: aDirectory]! !
!PackageInstaller methodsFor: 'actions' stamp: 'MM 11/25/2021 14:40:18'!
         placesToLookForPackagesDo: aBlock

	| base packagesDirectory |

	"Look in Cuis image folder and reasonable subfolders"
	base _ DirectoryEntry smalltalkImageDirectory.
	aBlock value: base.
	packagesDirectory _ base / 'Packages'.
	aBlock value: packagesDirectory.
	packagesDirectory allRegularDirectoriesDo: aBlock.
	base regularDirectoriesDo: [ :child |
		child = packagesDirectory ifFalse: [
			aBlock value: child.
			child allRegularDirectoriesDo: aBlock]].
	
	"Look in parent directory and reasonable subfolders. 
	Useful when image is stored in a subdirectory of the main app directory.
	This could be the case when the package comes from a 'main' git repo, and image is copied from gitHub.
	First try directories including the word Cuis in the name. Then try others."
	base parent regularDirectoriesDo: [ :dir |
		dir ~= base ifTrue: [
			('*Cuis*' match: dir name)
				ifTrue: [aBlock value: dir. dir allRegularDirectoriesDo: aBlock]]].
	base parent regularDirectoriesDo: [ :dir |
		dir ~= base ifTrue: [
			('*Cuis*' match: dir name)
				ifFalse: [aBlock value: dir. dir allRegularDirectoriesDo: aBlock]]].

	"Also look in host OS current directory"
	(base ~= DirectoryEntry currentDirectory and: [base parent ~= DirectoryEntry currentDirectory])
		ifTrue: [
			base _ DirectoryEntry currentDirectory.
			base allRegularDirectoriesDo: aBlock ]! !
!PackageInstaller methodsFor: 'actions' stamp: 'MM 1/1/2022 18:39:02'!
               updatePackageList
	
	(PopUpMenu confirm: 'I need to scan for packages. This takes some time. Continue?')
		ifFalse: [^ OrderedCollection new].
	packageList _ OrderedCollection new.
	self collectPackagesFromDisk.
	packageList sort: [:p1 :p2 | p1 packageName < p2 packageName].
	PackageList _ packageList.
	self changed: #packageList.
	^ packageList! !
!PackageInstaller methodsFor: 'initialization' stamp: 'MM 11/25/2021 16:15:28' overrides: 16920235!
                             initialize
	packageList _ PackageList ifNil: [self updatePackageList]! !
!CodePackageFile methodsFor: '*PackageInstaller' stamp: 'MM 11/19/2021 14:30:09'!
     packageDescription
	^ description! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5033-PackageInstaller-MarianoMontone-2022Jan03-21h00m-MM.001.cs.st----!

'From Cuis 6.0 [latest update: #5032] on 3 January 2022 at 8:33:44 pm'!

SystemWindow subclass: #PackageInstallerWindow
	instanceVariableNames: 'filterString filterInput currentIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Packages'!

!classDefinition: #PackageInstallerWindow category: #'Tools-Packages' stamp: 'Install-5034-PackageInstallerCategory-MarianoMontone-2022Jan03-21h32m-MM.001.cs.st 2/21/2022 14:50:20'!
SystemWindow subclass: #PackageInstallerWindow
	instanceVariableNames: 'filterString filterInput currentIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Packages'!

Object subclass: #PackageInstaller
	instanceVariableNames: 'packageList'
	classVariableNames: 'PackageList'
	poolDictionaries: ''
	category: 'Tools-Packages'!

!classDefinition: #PackageInstaller category: #'Tools-Packages' stamp: 'Install-5034-PackageInstallerCategory-MarianoMontone-2022Jan03-21h32m-MM.001.cs.st 2/21/2022 14:50:20'!
Object subclass: #PackageInstaller
	instanceVariableNames: 'packageList'
	classVariableNames: 'PackageList'
	poolDictionaries: ''
	category: 'Tools-Packages'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5034-PackageInstallerCategory-MarianoMontone-2022Jan03-21h32m-MM.001.cs.st----!

'From Cuis 6.0 [latest update: #5032] on 3 January 2022 at 9:19:11 pm'!
!TheWorldMenu methodsFor: 'menu' stamp: 'MM 1/3/2022 21:10:34'!
     openPackageDownloader
	"In PackageDownloader.pck"
	Smalltalk at: #PackageDownloaderWindow ifAbsent: [ 
		(PopUpMenu 
		confirm: 'The Package Downloader is not loaded', String newLineString, 'Would you like me to load it for you now?')
		ifTrue: [Feature require: #'PackageDownloader'] 
	].
	Smalltalk at: #PackageDownloaderWindow ifPresent: [ :cls | ^cls open ].
	self inform: 'Please install optional package PackageDownloader.pck.st', String newLineString, 'Feature require: #''PackageDownloader'' '! !
!TheWorldMenu class methodsFor: 'menu building' stamp: 'MM 1/3/2022 21:17:30'!
                        worldMenuForOpenGroup
	^ `{{
			#itemGroup 		-> 		20.
			#itemOrder 		-> 		10.
			#label 			->	'Package Downloader'.
			#selector 		-> 		#openPackageDownloader.
			#icon 			-> 		#packageIcon.
			#balloonText 	-> 		'A tool for downloading Cuis packages from the internet.'.
		} asDictionary}`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5035-PackageDownloaderMenu-MarianoMontone-2022Jan03-22h10m-MM.001.cs.st----!

'From Cuis 6.0 [latest update: #5035] on 3 January 2022 at 10:31:34 pm'!
!Theme methodsFor: 'tool colors' stamp: 'MM 1/3/2022 22:29:24'!
          packageDownloader
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color fromHexString: '#d0e973'` ]! !
!Theme methodsFor: 'tool colors' stamp: 'MM 1/3/2022 22:30:22'!
                            packageInstaller
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ `Color fromHexString: '#88e6d8'` ]! !
!PackageInstallerWindow methodsFor: 'GUI building' stamp: 'MM 1/3/2022 22:30:37' prior: 50331774 overrides: 16959063!
       windowColor
	^ Theme current packageInstaller! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5036-PackageToolsWindowsColors-MarianoMontone-2022Jan03-22h29m-MM.001.cs.st----!

'From Cuis 6.0 [latest update: #5032] on 4 January 2022 at 5:06:18 pm'!
!DebuggerMethodMap methodsFor: 'private' stamp: 'HAW 1/4/2022 17:04:37'!
                    privateTempAt: index in: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents ifXtraBindings: xtraBindingsBlock ifNot: notXtraBindingBlock

	| nameRefPair namesAndRefs |
	
	namesAndRefs _ self 
		privateTempRefsForContext: aContext
		startpcsToBlockExtents: theContextsStartpcsToBlockExtents.
		
	^index <= namesAndRefs size
		ifTrue: [
			nameRefPair _ namesAndRefs
				at: index
				ifAbsent: [ aContext errorSubscriptBounds: index ].
			notXtraBindingBlock value: nameRefPair last ]
		ifFalse: [ xtraBindingsBlock value: (aContext method xtraBindings at: index - namesAndRefs size) ]! !
!DebuggerMethodMap methodsFor: 'private' stamp: 'HAW 1/4/2022 17:04:45' prior: 16839255!
           privateTempAt: index in: aContext put: aValue startpcsToBlockExtents: theContextsStartpcsToBlockExtents
	
	^self 
		privateTempAt: index 
		in: aContext 
		startpcsToBlockExtents: theContextsStartpcsToBlockExtents 
		ifXtraBindings: [ :xtraBinding | xtraBinding value: aValue ]
		ifNot: [ :ref | self privateDereference: ref in: aContext put: aValue ]
		! !
!DebuggerMethodMap methodsFor: 'private' stamp: 'HAW 1/4/2022 17:05:12' prior: 16839270!
 privateTempAt: index in: aContext startpcsToBlockExtents: theContextsStartpcsToBlockExtents

	^self 
		privateTempAt: index 
		in: aContext 
		startpcsToBlockExtents: theContextsStartpcsToBlockExtents 
		ifXtraBindings: [ :xtraBinding | xtraBinding value ] 
		ifNot: [ :ref | self privateDereference: ref in: aContext ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5037-DebuggerMethodMapFix-HernanWilkinson-2022Jan04-17h04m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5032] on 4 January 2022 at 6:08:45 pm'!

TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex context bindings '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

!classDefinition: #Inspector category: #'Tools-Inspector' stamp: 'Install-5038-InspectorScriptAreaBehavesLikeWorkspace-HernanWilkinson-2022Jan04-17h06m-HAW.001.cs.st 2/21/2022 14:50:20'!
TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex context bindings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!
!PluggableTextModel methodsFor: 'binding' stamp: 'HAW 1/4/2022 18:02:38' overrides: 16901683!
        bindingOf: aString

	^textProvider bindingOf: aString! !
!Inspector methodsFor: 'shout styling' stamp: 'HAW 1/4/2022 18:06:01'!
hasBindingThatBeginsWith: aString 

	| beginsWithBlock |
	
	beginsWithBlock := [ :varName | varName beginsWith: aString ].
	
	^(self objectClass allInstVarNames anySatisfy: beginsWithBlock) or: [ bindings keys anySatisfy: beginsWithBlock ]! !
!Inspector methodsFor: 'shout styling' stamp: 'HAW 1/4/2022 17:35:55'!
      initializeBindings
	
	bindings _ Dictionary new.
	self changed: #actualContents.
! !
!Inspector methodsFor: 'binding' stamp: 'HAW 1/4/2022 18:02:01' overrides: 16901683!
                      bindingOf: aString
	
	(bindings includesKey: aString) ifFalse: [
		aString first isUppercase
			ifTrue: [^nil]
			ifFalse: [bindings at: aString put: nil]].
		
	^bindings associationAt: aString! !
!Inspector methodsFor: 'initialization' stamp: 'HAW 1/4/2022 17:36:05' prior: 16871917 overrides: 16920235!
               initialize

	super initialize.
	acceptedContentsCache _ ''.
	selectionIndex := 0.
	self initializeEvents.
	self initializeBindings ! !
!Inspector methodsFor: 'shout styling' stamp: 'HAW 1/4/2022 17:32:23' prior: 16872088!
  bindingNamesDo: aBlock

	self objectClass allInstVarNames do: aBlock.
	bindings keysDo: aBlock! !
!Inspector methodsFor: 'shout styling' stamp: 'HAW 1/4/2022 17:33:50' prior: 16872093!
       hasBindingOf: aString
	^ (self objectClass allInstVarNames includes: aString) or: [ 	bindings includesKey: aString ]! !

TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex context bindings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

!classDefinition: #Inspector category: #'Tools-Inspector' stamp: 'Install-5038-InspectorScriptAreaBehavesLikeWorkspace-HernanWilkinson-2022Jan04-17h06m-HAW.001.cs.st 2/21/2022 14:50:20'!
TextProvider subclass: #Inspector
	instanceVariableNames: 'acceptedContentsCache object selectionIndex context bindings'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Inspector'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5038-InspectorScriptAreaBehavesLikeWorkspace-HernanWilkinson-2022Jan04-17h06m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5038] on 5 January 2022 at 1:18:45 pm'!
!PlacedMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:20:00'!
      categoryInNewMorphMenu
	^ 'Vector Graphics'! !
!ProgressMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:46:33' overrides: 16895515!
  initializedInstance
	| progress |
	progress _ ProgressMorph label: 'Test progress' subLabel: 'this is the subheading'.
	[
		100 timesRepeat: [
			(Delay forMilliseconds: 30) wait.
			progress incrDone: 0.01 ].
		progress delete] fork.
	^progress! !
!HaloHandleMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:22:20' overrides: 16895531!
                      includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!HaloMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:22:38' overrides: 16895531!
            includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!DraggingGuideMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:23:37' overrides: 16895531!
   includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!TextParagraphMorph class methodsFor: 'instance creation' stamp: 'jmv 1/5/2022 12:30:08' overrides: 16895515!
         initializedInstance

	^self contents:
'I am a read-only text paragraph.
I can hold several lines of text.
Even with ', ' text ' bold, 'styles.' italic, '
Try resizing me with the Halo.'! !
!FillInTheBlankMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:37:37' overrides: 16895531!
              includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!ProgressBarMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:39:28' overrides: 16895531!
     includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!MenuLineMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:25:48' overrides: 16895531!
        includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!MenuMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:25:58' overrides: 16895531!
            includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"

	^ false! !
!BoxedMorph class methodsFor: 'new-morph participation' stamp: 'jmv 1/5/2022 12:09:00' prior: 16794540 overrides: 50332277!
                           categoryInNewMorphMenu
	^ 'Basic'! !
!TheWorldMenu methodsFor: 'private' stamp: 'jmv 1/5/2022 12:53:09' prior: 16970485!
       pvtAlphaSplitListDepth
	"Split factor.  A higher number results in fewer items in each submenu"
	^ 3! !

ProgressBarMorph class removeSelector: #categoryInNewMorphMenu!

!methodRemoval: ProgressBarMorph class #categoryInNewMorphMenu stamp: 'Install-5039-NewMorph-menu-reorganization-JuanVuletich-2022Jan05-13h15m-jmv.001.cs.st 2/21/2022 14:50:20'!
categoryInNewMorphMenu
	^ 'Widgets'!

FillInTheBlankMorph class removeSelector: #categoryInNewMorphMenu!

!methodRemoval: FillInTheBlankMorph class #categoryInNewMorphMenu stamp: 'Install-5039-NewMorph-menu-reorganization-JuanVuletich-2022Jan05-13h15m-jmv.001.cs.st 2/21/2022 14:50:20'!
categoryInNewMorphMenu
	^ 'Widgets'!

HaloMorph class removeSelector: #categoryInNewMorphMenu!

!methodRemoval: HaloMorph class #categoryInNewMorphMenu stamp: 'Install-5039-NewMorph-menu-reorganization-JuanVuletich-2022Jan05-13h15m-jmv.001.cs.st 2/21/2022 14:50:20'!
categoryInNewMorphMenu
	^ 'Halos'!

HaloHandleMorph class removeSelector: #categoryInNewMorphMenu!

!methodRemoval: HaloHandleMorph class #categoryInNewMorphMenu stamp: 'Install-5039-NewMorph-menu-reorganization-JuanVuletich-2022Jan05-13h15m-jmv.001.cs.st 2/21/2022 14:50:20'!
categoryInNewMorphMenu
	^ 'Halos'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5039-NewMorph-menu-reorganization-JuanVuletich-2022Jan05-13h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5038] on 5 January 2022 at 1:19:05 pm'!
!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jmv 1/5/2022 13:11:47' prior: 16866271!
                   grabMorph: aMorph moveUnderHand: moveUnderHand
	"Grab the given morph (i.e., add it to this hand and remove it from its current owner).
	If moveUnderHand is requested or it seems neccesary anyway, move the grabbed morph under the hand."

	| grabbed positionInHandCoordinates tx bounds |
	self releaseMouseFocus.	"Break focus"
	grabbed _ aMorph.
	aMorph owner ifNotNil: [ :o | grabbed _ o aboutToGrab: aMorph ].
	grabbed ifNil: [ ^ self ].
	grabbed _ grabbed aboutToBeGrabbedBy: self.
	grabbed ifNil: [ ^ self ].
	self hideHardwareCursor.
	self redrawNeeded.

	moveUnderHand ifTrue: [
		bounds _ nil.
		grabbed isInWorld ifTrue: [
			bounds _ (grabbed displayBounds ifNil: [grabbed fullBoundsInOwner ])
				translatedBy: grabbed morphPositionInWorld negated ].
		bounds ifNil: [ bounds _ grabbed fullBoundsInOwner ].
		positionInHandCoordinates _ (bounds center + bounds bottomRight //2) negated.
		self grabMorph: grabbed delta: positionInHandCoordinates.
		^self ].

	positionInHandCoordinates _ (grabbed isInWorld ifTrue: [grabbed] ifFalse: [aMorph])
		morphPositionInWorld - self morphPositionInWorld.

	tx _ GeometryTransformation identity.
	(grabbed isInWorld ifTrue: [grabbed] ifFalse: [aMorph]) withAllOwnersDo: [ :o |
		tx _ o location composedWith: tx ].
	self withAllOwnersReverseDo: [ :o |
		tx _ o location inverseTransformation composedWith: tx ].
	self grabMorph: grabbed delta: positionInHandCoordinates.

	grabbed location: tx.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5040-Hand-grabMorph-fix-JuanVuletich-2022Jan05-13h18m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5040] on 5 January 2022 at 4:26:32 pm'!
!Text methodsFor: 'attributes' stamp: 'jmv 1/5/2022 16:13:27' prior: 16964281!
hasAnyParagraphAttribute
	"Return false if there are no paragraph attributes"

	^runs values anySatisfy: [ :emphArray | emphArray anySatisfy: [ :attr | attr isParagraphAttribute ]]! !
!TextParagraphMorph methodsFor: 'accessing' stamp: 'jmv 1/5/2022 14:07:55' prior: 16969463!
            contents: aStringOrText
	textComposition textComposed ~= aStringOrText ifTrue: [
		textComposition	
			initialize;
			setModel: (TextModel withText: aStringOrText);
			extentForComposing: self extentForComposing;
			composeAll.
		extent _ textComposition usedExtent + (4 * borderWidth).
		self redrawNeeded ]! !
!TextParagraphMorph methodsFor: 'initialization' stamp: 'jmv 1/5/2022 14:10:00' prior: 16969478 overrides: 16794195!
                   initialize
	super initialize.
	extent _ `1250@1140`.
	textComposition _ TextComposition new.
	textComposition
		setModel: (TextModel withText: '');
		extentForComposing: self extentForComposing;
		composeAll.! !
!TextParagraphMorph methodsFor: 'private' stamp: 'jmv 1/5/2022 16:19:56' prior: 16969533!
                  fit
	"Adjust my height to fit the text."

	| newExtent oldExtent |
	(owner is: #ScrollPane) ifFalse: [
		^self ].
	newExtent _ extent x
		@ (textComposition usedHeight + (4 * borderWidth)
			max: FontFamily defaultLineSpacing + 2).
	extent = newExtent ifFalse: [
		oldExtent _ extent.
		extent _ newExtent.
		self extentChanged: oldExtent.
		owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
		self redrawNeeded ].! !
!TextComposition methodsFor: 'access' stamp: 'jmv 1/5/2022 16:19:07' prior: 16965514!
                           usedExtent
	"If there is any justified, rightFlush or centered text, assume all available width has been used."

	^ self usedWidth @ self usedHeight! !
!TextComposition methodsFor: 'access' stamp: 'jmv 1/5/2022 16:18:54' prior: 16965522!
                  usedWidth
	"If there is any justified, rightFlush or centered text, assume all available width has been used."

	^ maxRightX! !
!TextComposition methodsFor: 'composition' stamp: 'jmv 1/5/2022 16:18:59' prior: 16965537!
     composeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines atY: startingY 
	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"

	| newResult composer |
	composer _ TextComposer new.
	editor ifNotNil: [
		composer editor: editor ].
	newResult _ composer
				composeLinesFrom: start
				to: stop
				delta: delta
				into: lineColl
				priorLines: priorLines
				atY: startingY
				text: model actualContents
				extentForComposing: extentForComposing.
	lines _ newResult first asArray.

	"If there is any justified, rightFlush or centered text, assume all available width has been used."
	model actualContents hasAnyParagraphAttribute ifTrue: [ ^extentForComposing x ].

	^newResult second "right border of recomposed lines (bounded by extentForComposing x)"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5041-TextParagraphMorph-fix-JuanVuletich-2022Jan05-16h24m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5041] on 15 January 2022 at 9:08:32 pm'!
!Mutex methodsFor: 'mutual exclusion' stamp: 'jmv 1/15/2022 21:06:47'!
                       critical: aBlock onReentry: reentryBlock
	"Evaluate aBlock protected by the receiver.
	This method allows using the receiver either as a reentrant or non-reentrant Mutex.
	See https://en.wikipedia.org/wiki/Reentrant_mutex

	| m |
	m := Mutex new.
	m critical: [ 1 print. m critical: [ 2 print ] onReentry: ['Reentry attempt!!' print]. 3 print ]. 'Done'.
	"

	| activeProcess |
	activeProcess _ Processor activeProcess.
	activeProcess == owner ifTrue: [^reentryBlock value].
	^semaphore critical: [
		owner _ activeProcess.
		aBlock ensure: [owner _ nil]].! !
!Mutex methodsFor: 'mutual exclusion' stamp: 'jmv 1/15/2022 21:05:12'!
          criticalNonReentrant: aBlock
	"Evaluate aBlock protected by the receiver.
	Provides non-reentrant mutex behavior: Raise an error if attempted to reenter from same process.
	See https://en.wikipedia.org/wiki/Reentrant_mutex

	| m |
	m := Mutex new.
	m criticalNonReentrant: [ 1 print. m criticalNonReentrant: [ 2 print ]. 3 print ]. 'Done'.
	"

	^self critical: aBlock onReentry: [ self error: 'Mutex reentry attempted' ]! !
!Mutex methodsFor: 'mutual exclusion' stamp: 'jmv 1/15/2022 21:04:14' prior: 16898828!
 critical: aBlock
	"Evaluate aBlock protected by the receiver.
	Provides reentrant mutex behavior: Allow reentry from the same process.
	See https://en.wikipedia.org/wiki/Reentrant_mutex

	| m |
	m := Mutex new.
	m critical: [ 1 print. m critical: [ 2 print ]. 3 print ]. 'Done'.
	"

	^self critical: aBlock onReentry: aBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5042-Mutex-AllowNonReentrantMutexes-JuanVuletich-2022Jan15-20h58m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5041] on 16 January 2022 at 12:34:46 pm'!
!MessageSet methodsFor: 'message list' stamp: 'jmv 1/16/2022 12:33:04' prior: 16886389!
        sortByClassHierarchy
	"Sort the message-list by class / selector. List classes in hierarchical order."
	
	| aClass bClass classes classesAndPositions i |

	classes _ Set new.
	messageList do: [ :methodReference |
		methodReference actualClass ifNotNil: [ :actualClass | classes add: actualClass ]].
	classesAndPositions _ Dictionary new.
	i _ 1.
	Smalltalk hierarchySorted: classes do: [ :each |
		classesAndPositions at: each put: i.
		i _ i + 1 ].
	
	messageList _ messageList sort: [ :a :b |
		(a classSymbol = b classSymbol and: [ b classIsMeta = b classIsMeta ])
			ifTrue: [
				a methodSymbol == #Comment
					ifTrue: [ true ]
					ifFalse: [
						b methodSymbol == #Comment
							ifTrue: [ false ]
							ifFalse: [ a methodSymbol < b methodSymbol ]]]
			ifFalse: [
				aClass _ a actualClass.
				bClass _ b actualClass.
				aClass isNil == bClass isNil
					ifTrue: [
						aClass isNil
							ifTrue: [a classSymbol < b classSymbol]
							ifFalse: [(classesAndPositions at: aClass) < (classesAndPositions at: bClass)]]
					ifFalse: [aClass isNil]]].
	messageList do: [ :each | | d |
		d _ (each actualClass theNonMetaClass allSuperclasses select: [ :c |
			classesAndPositions includesKey: c ]) size.
		each prefixStringVersionWith: (
			String streamContents: [ :strm |
				d timesRepeat: [ strm nextPutAll: ' ---'].
				strm nextPut: Character space ]) ].
	self changed: #messageList.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5043-Better-SortByClassHierarchy-JuanVuletich-2022Jan15-21h08m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5043] on 17 January 2022 at 1:01:55 pm'!
!DisplayScreen methodsFor: 'accessing' stamp: 'jmv 1/17/2022 13:00:17' prior: 16844376!
                       getMainCanvas
	"Return a Canvas that can be used to draw onto the receiver.
	Being the sole 'main' canvas means a priviledge: Can use VectorEnginePlugin if available."

	| answer |
	answer _ [ MorphicCanvas onForm: self ]
				on: OutOfMemory
				do: [
					'Not enough memory to run VectorEngine. Using BitBltCanvas instead.' print.
					MorphicCanvas activeSubclass: BitBltCanvas.
					MorphicCanvas onForm: self ].
	^answer! !
!FontFamily class methodsFor: 'file read write' stamp: 'jmv 1/17/2022 12:01:11' prior: 16860354!
                  readAdditionalTrueTypeFonts
	Feature require: 'VectorGraphics'.
	(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
		Feature require: 'VectorEngineInSmalltalk' ].
	UISupervisor whenUIinSafeState: [
		Smalltalk at: #TrueTypeFontFamily ifPresent: [ :cls | cls readAdditionalFonts ]]! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 1/17/2022 12:01:06' prior: 16860413!
                             promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| selectedNameOrDirectory fontFamily |
	selectedNameOrDirectory _ self promptUserFolders.
	selectedNameOrDirectory isNil ifTrue: [ ^nil ].
	(FontFamily familyNamed: selectedNameOrDirectory)
		ifNotNil: [ :it | ^Preferences setDefaultFont: it familyName ].
	Feature require: 'VectorGraphics'.
	(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
		Feature require: 'VectorEngineInSmalltalk' ].
	UISupervisor whenUIinSafeState: [
		fontFamily _ FontFamily availableFamilies values
			detect: [ :any | any folderName = selectedNameOrDirectory name ]
			ifNone: [
				FontFamily familyNamed: ((Smalltalk at: #TrueTypeFontFamily) read: selectedNameOrDirectory) anyOne ].
		Preferences setDefaultFont: fontFamily familyName ]! !
!Morph methodsFor: 'private' stamp: 'jmv 1/17/2022 12:02:09' prior: 16895209!
                             privateAddAllMorphs: aCollection atIndex: index
	"Private. Add aCollection of morphs to the receiver"
	| myWorld itsWorld otherSubmorphs |
	myWorld _ self world.
	otherSubmorphs _ submorphs copyWithoutAll: aCollection.
	(index between: 0 and: otherSubmorphs size)
		ifFalse: [^ self error: 'index out of range'].
	index = 0
		ifTrue:[	submorphs _ aCollection asArray, otherSubmorphs]
		ifFalse:[	index = otherSubmorphs size
			ifTrue:[	submorphs _ otherSubmorphs, aCollection]
			ifFalse:[	submorphs _ otherSubmorphs copyReplaceFrom: index + 1 to: index with: aCollection ]].
	aCollection do: [:m | | itsOwner |
		itsOwner _ m owner.
		itsOwner ifNotNil: [
			itsWorld _ m world.
			(itsWorld == myWorld) ifFalse: [
				itsWorld ifNotNil: [m redrawNeeded]].
			(itsOwner ~~ self) ifTrue: [
				m owner privateRemove: m.
				m owner removedMorph: m ]].
		m privateOwner: self.
		myWorld ifNotNil: [m redrawNeeded].
		(myWorld == itsWorld) ifFalse: [m intoWorld: myWorld].
		itsOwner == self ifFalse: [
			self addedMorph: m.
			m noteNewOwner: self ].
	].
	self privateArrangeWantsToBeOnTop.
	self someSubmorphPositionOrExtentChanged! !
!Morph methodsFor: 'private' stamp: 'jmv 1/17/2022 12:02:35' prior: 16895264!
  privateAddMorph: aMorph atIndex: index position: aPointOrNil

	| oldIndex myWorld itsWorld oldOwner |
	((index >= 1) and: [index <= (submorphs size + 1)])
		ifFalse: [^ self error: 'index out of range'].
	myWorld _ self world.
	oldOwner _ aMorph owner.
	(oldOwner == self and: [(oldIndex _ submorphs indexOf: aMorph) > 0]) ifTrue: [
		"aMorph's position changes within in the submorph chain"
		oldIndex < index ifTrue:[
			"moving aMorph to back"
			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.
			submorphs at: index-1 put: aMorph.
		] ifFalse:[
			"moving aMorph to front"
			oldIndex-1 to: index by: -1 do:[:i|
				submorphs at: i+1 put: (submorphs at: i)].
			submorphs at: index put: aMorph.
		].
		aPointOrNil ifNotNil: [aMorph privatePosition: aPointOrNil].
	] ifFalse: [
		"adding a new morph"
		oldOwner ifNotNil: [
			itsWorld _ aMorph world.
			itsWorld ifNotNil: [aMorph invalidateBounds].
			oldOwner privateRemove: aMorph.
			oldOwner removedMorph: aMorph.
		].
		aMorph privateOwner: self.
		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).
		aPointOrNil ifNotNil: [aMorph privatePosition: aPointOrNil].
		(itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].
	].
	myWorld ifNotNil: [
		index = 1
			ifTrue: [aMorph redrawNeeded ]
			ifFalse: [aMorph invalidateBounds]].
	self privateArrangeWantsToBeOnTop.
	self someSubmorphPositionOrExtentChanged.
	oldOwner == self ifFalse: [
		self addedMorph: aMorph.
		aMorph noteNewOwner: self ]! !

BitBltCanvas removeSelector: #canDraw:!

!methodRemoval: BitBltCanvas #canDraw: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
canDraw: aMorph
	^aMorph requiresVectorCanvas not!

BitBltCanvas removeSelector: #setPluginAndForm:!

!methodRemoval: BitBltCanvas #setPluginAndForm: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
setPluginAndForm: aForm
	"No VectorEnginePlugin in BitBltCanvas."

	self setForm: aForm subPixelAntiAliasing: nil.!

MorphicCanvas class removeSelector: #withVectorEnginePluginOnForm:!

!methodRemoval: MorphicCanvas class #withVectorEnginePluginOnForm: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
withVectorEnginePluginOnForm: aForm
	"Note: Only one instance using VectorEnginePlugin should be acive at a time:
	the plugin holds numeric parameters that are not passed again on every call."

	^ self subclassToUse basicNew
		setPluginAndForm: aForm;
		initializeWithTranslation: `0@0`.!

MorphicCanvas removeSelector: #canDraw:!

!methodRemoval: MorphicCanvas #canDraw: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
canDraw: aMorph
	^true!

WorldMorph removeSelector: #canHandle:!

!methodRemoval: WorldMorph #canHandle: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
canHandle: aMorph

	^ canvas canDraw: aMorph!

Morph removeSelector: #canAdd:!

!methodRemoval: Morph #canAdd: stamp: 'Install-5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st 2/21/2022 14:50:20'!
canAdd: aMorph
	self world ifNotNil: [ :w |
		^w canHandle: aMorph ].
	^true!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5044-Separate-VectorEngine-SmalltalkImplementation-JuanVuletich-2022Jan17-12h41m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5044] on 18 January 2022 at 3:53:57 pm'!
!ContextVariablesInspector methodsFor: 'shout styling' stamp: 'jmv 1/18/2022 15:53:28' prior: 16834092 overrides: 50332238!
         bindingNamesDo: aBlock
	self fieldList do: aBlock! !
!ContextVariablesInspector methodsFor: 'shout styling' stamp: 'jmv 1/18/2022 15:53:22' prior: 16834097 overrides: 50332244!
               hasBindingOf: aString
	^ self fieldList includes: aString! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5045-ContextVariablesInspector-fix-JuanVuletich-2022Jan18-15h41m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5045] on 25 January 2022 at 9:34:42 am'!
!Character class methodsFor: 'class initialization' stamp: 'len 12/28/2021 12:09:45' prior: 16808458!
       greekLowercaseLetters
	"Answer the lowercase greek letters included in our font within the ASCII range.
	These are considered lowercase letters and can be used as identifiers (variable names, keyword or unary messages, etc)."
	^ 'àâäãåçéèµò'! !
!Character class methodsFor: 'class initialization' stamp: 'len 12/28/2021 12:09:40' prior: 16808469!
     greekUppercaseLetters
	"Answer the uppercase greek letters included in our font within the ASCII range.
	These are considered uppercase letters and can be used as identifiers (variable names, keyword or unary messages, etc)."
	^ 'ñó'! !
!Character class methodsFor: 'class initialization' stamp: 'len 1/9/2022 07:55:43' prior: 16808581!
               initializeUnicodeCodePoints
	"
	Character initializeUnicodeCodePoints
	String streamContents: [ :strm | 28 to: 255 do: [ :i | strm nextPut: (Character numericValue: i) ]]
	"

	"Initialize the table of Unicode code points"
	UnicodeCodePoints _ Array new: 256.
	0 to: 255 do: [ :code |
		UnicodeCodePoints at: code + 1 put: code ].

	"Arrows"
	UnicodeCodePoints at: 28+1 put: 8592.		"left arrow"
	UnicodeCodePoints at: 29+1 put: 8594.		"right arrow"
	UnicodeCodePoints at: 30+1 put: 8593.		"up arrow"
	UnicodeCodePoints at: 31+1 put: 8595.		"down arrow"
	
	"The following codes are different in ISO 8859-15 from those in ISO 8859-1,
	so the character code is not equal to the Unicode code point"
	UnicodeCodePoints at: 16rA4+1 put: 16r20AC.		"euro sign"
	UnicodeCodePoints at: 16rA6+1 put: 16r160.		"latin capital letter S with caron"
	UnicodeCodePoints at: 16rA8+1 put: 16r161.		"latin small letter s with caron"
	UnicodeCodePoints at: 16rB4+1 put: 16r17D.		"latin capital letter Z with caron"
	UnicodeCodePoints at: 16rB8+1 put: 16r17E.		"latin small letter z with caron"
	UnicodeCodePoints at: 16rBC+1 put: 16r152.		"latin capital ligature OE"
	UnicodeCodePoints at: 16rBD+1 put: 16r153.		"latin small ligature oe"
	UnicodeCodePoints at: 16rBE+1 put: 16r178.		"latin capital letter Y with diaeresis"

	"Mathematical symbols (see Character>>#namedCharactersTable)"
	UnicodeCodePoints at: 16r80+1 put: 16r221E.		"infinity"
	UnicodeCodePoints at: 16r81+1 put: 16r2135.		"aleph"
	UnicodeCodePoints at: 16r82+1 put: 16r2115.		"blackboard bold N"
	UnicodeCodePoints at: 16r83+1 put: 16r2124.		"blackboard bold Z"
	UnicodeCodePoints at: 16r84+1 put: 16r211A.		"blackboard bold Q"
	UnicodeCodePoints at: 16r85+1 put: 16r211D.		"blackboard bold R"
	UnicodeCodePoints at: 16r86+1 put: 16r2102.		"blackboard bold C"
	UnicodeCodePoints at: 16r87+1 put: 16r2119.		"blackboard bold P"
	UnicodeCodePoints at: 16r88+1 put: 16r03B1.		"alpha"
	UnicodeCodePoints at: 16r89+1 put: 16r03B2.		"beta"
	UnicodeCodePoints at: 16r8A+1 put: 16r03B3.		"gamma"
	UnicodeCodePoints at: 16r8B+1 put: 16r03B4.		"delta"
	UnicodeCodePoints at: 16r8C+1 put: 16r03B5.		"epsilon"
	UnicodeCodePoints at: 16r8D+1 put: 16r03BB.		"lambda"
	UnicodeCodePoints at: 16r8E+1 put: 16r03C0.		"pi"
	UnicodeCodePoints at: 16r8F+1 put: 16r03B6.		"zeta"
	UnicodeCodePoints at: 16r90+1 put: 16r2295.		"oplus"
	UnicodeCodePoints at: 16r91+1 put: 16r2297.		"otimes"
	UnicodeCodePoints at: 16r92+1 put: 16r2218.		"circ"
	UnicodeCodePoints at: 16r93+1 put: 16r2293.		"prod"
	UnicodeCodePoints at: 16r94+1 put: 16r2294.		"coprod"
	UnicodeCodePoints at: 16r95+1 put: 16r22A5.		"perp"
	UnicodeCodePoints at: 16r96+1 put: 16r0394.		"Delta"
	UnicodeCodePoints at: 16r97+1 put: 16r0393.		"Gamma"
	UnicodeCodePoints at: 16r98+1 put: 16r03C9.		"omega"
	UnicodeCodePoints at: 16r99+1 put: 16r21A0.		"SURJECTIVE ARROW"
	UnicodeCodePoints at: 16r9A+1 put: 16r21A3.		"INJECTIVE ARROW"
	UnicodeCodePoints at: 16r9B+1 put: 16r2194.		"BIJECTIVE ARROW"
	UnicodeCodePoints at: 16r9C+1 put: 16r21AA.		"INCLUSION ARROW"
	UnicodeCodePoints at: 16r9D+1 put: 16r21A6.		"MAPPING ARROW"
	UnicodeCodePoints at: 16r9E+1 put: 16r2202.		"partial differential"
	UnicodeCodePoints at: 16r9F+1 put: 16r221A.		"sqrt"! !
!Character class methodsFor: 'constants' stamp: 'len 1/8/2022 10:53:19' prior: 16808990!
        namedCharactersTable
	"Table of named characters that we can enter in an editor using \name.
	Please keep the names short and try to follow the naming convention used in LaTeX."
	^ #((left $) (right $) (up $) (down $) (oplus $ê) (otimes $ë) (times $◊) (div $˜) #(circ $í) (cdot $∑) (prod $ì) (coprod $î) (perp $ï) (alpha $à) (beta $â) (gamma $ä) (delta $ã) (epsilon $å) (lambda $ç) (mu $µ) (pi $é) (zeta $è) (Delta $ñ) (Gamma $ó) (omega $ò) (N $Ç) (Z $É) (Q $Ñ) (R $Ö) (C $Ü) (P $á) (infty $Ä) (aleph $Å) (sqrt $ü) (partial $û) (deg $∞))! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'len 8/20/2021 16:00:03' prior: 16939514!
        printIt
	"Treat the current text selection as an expression; evaluate it. Insert the 
	description of the result of evaluation after the selection and then make 
	this description the new text selection."
	| rpt |
	self
		evaluateSelectionAndDo: [ :result |
			rpt _ model fullPrintIt
				ifTrue: [result printText]
				ifFalse: [result printTextLimitedTo: 10000].
			rpt _ rpt copyReplaceAll: Character lf asString with: Character lf asString, ' '.
			self afterSelectionInsertAndSelect: 
				((' ', rpt, ' ') initialFontFrom: emphasisHere)]
		ifFail: [ morph flash ]
		profiled: false.! !

Character initializeUnicodeCodePoints!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5046-MathSymbolsUpdate-LucianoEstebanNotarfrancesco-2022Jan25-09h34m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5046] on 25 January 2022 at 10:15:45 am'!
!HierarchicalListMorph methodsFor: 'events' stamp: 'len 1/25/2022 10:15:18' prior: 16867333 overrides: 16892166!
                             doubleClick: aMouseButtonEvent localPosition: localEventPosition
	doubleClickSelector ifNotNil: [^ self model perform: doubleClickSelector].
	selectedMorph ifNotNil: [self toggleExpandedState: selectedMorph]! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'len 1/25/2022 10:14:08' prior: 16867364 overrides: 16911850!
                            mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| itemMorph |
	aMouseButtonEvent hand newKeyboardFocus: self.
	itemMorph _ self itemFromPoint: localEventPosition.
	itemMorph ifNil: [ ^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].
	self highlightedMorph: itemMorph.
	(itemMorph inToggleArea: (itemMorph internalize: (scroller internalize: localEventPosition)))
		ifTrue: [ ^self toggleExpandedState: itemMorph event: aMouseButtonEvent ]. 
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent 
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: #doubleClick:localPosition:
		dblClkNHalfSel: nil
		tripleClkSel: nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5047-DoubleClickToggleExpand-LucianoEstebanNotarfrancesco-2022Jan25-09h53m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5047] on 26 January 2022 at 4:33:58 pm'!
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 1/26/2022 16:31:14' prior: 50333101 overrides: 16892166!
                 doubleClick: aMouseButtonEvent localPosition: localEventPosition
	doubleClickSelector ifNotNil: [^ self model perform: doubleClickSelector].
	selectedMorph ifNotNil: [
		self toggleExpandedState: selectedMorph.
		self scrollSelectionIntoView ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5048-DoubleClickExpand-scrollSelectionIntoView-JuanVuletich-2022Jan26-16h31m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5048] on 26 January 2022 at 4:50:38 pm'!
!Object methodsFor: 'system primitives' stamp: 'jmv 1/26/2022 16:49:44' prior: 16903084!
              becomeForward: otherObject 
	"Primitive. All variables in the entire system that used to point
	to the receiver now point to the argument.
	Fails if either argument is a SmallInteger.

	Please see comment at #elementsForwardIdentityTo:
	"

	| newMethod oldMethod selector |
	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :process :context |
				self == context receiver ifTrue: [
					selector _ context method selector.
					oldMethod _ self class lookupSelector: selector.
					newMethod _ otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: self class name, ' has some instance running #', selector, '. This CompiledMethod would become invalid. #becomeForward: aborted.' ]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self } elementsForwardIdentityTo: { otherObject }! !
!Object methodsFor: 'system primitives' stamp: 'jmv 1/26/2022 16:50:06' prior: 16903114!
     becomeForward: otherObject copyHash: copyHash
	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.
	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.
	Fails if either argument is a SmallInteger.

	Please see comment at #elementsForwardIdentityTo:copyHash:
	"

	| newMethod oldMethod selector |
	self class == otherObject class ifFalse: [
		Processor 
			processesDo: [ :p | ] withStackFramestDo: [ :proces :context |
				self == context receiver ifTrue: [
					selector _ context method selector.
					oldMethod _ self class lookupSelector: selector.
					newMethod _ otherObject class lookupSelector: selector.
					oldMethod = newMethod ifFalse: [
						MethodInCallStackToBecomeInvalid
							signal: self class name, ' has some instance running #', selector, '. This CompiledMethod would become invalid. #becomeForward:copyHash: aborted.' ]]]
			runningProcessSearchStart: thisContext sender.
		].
	{ self }
		elementsForwardIdentityTo: { otherObject }
		copyHash: copyHash! !
!Array methodsFor: 'converting' stamp: 'jmv 1/26/2022 16:48:48' prior: 16780806!
                      elementsForwardIdentityTo: otherArray
	"This primitive performs a bulk mutation, causing all pointers to the elements of the
	 receiver to be replaced by pointers to the corresponding elements of otherArray.

	 The identityHashes remain with the pointers in us rather than with the objects so that
	 the objects in the receiver should still be properly indexed in any existing hashed
	 structures after the mutation.

	Warning: This means that the identityHash of objects in otherArray will change. This
	is most likely a problem if those objects are already in any identityHashed collection!!
	See #elementsForwardIdentityTo:copyHash:.
	They should be #rehash 'ed.

	Additionally, any hashed (not identityHashed) collection with elements in the receiver
	will most likely break if the #hash message gives now a different answer!!
	They should be #rehash 'ed.

	Warning. This is a dangerous operation and it could lead to a crash if some object in
	receiver or argument is receiver of a method currently in execution.
	See #anyReceiverInStackIn: See senders."

	<primitive: 72 error: ec>
	ec == #'bad receiver' ifTrue:
		[^self error: 'receiver must be of class Array'].
	ec == #'bad argument' ifTrue:
		[^self error: (otherArray class == Array
						ifTrue: ['arg must be of class Array']
						ifFalse: ['receiver and argument must have the same size'])].
	ec == #'inappropriate operation' ifTrue:
		[^self error: 'can''t become immediates such as SmallIntegers or Characters'].
	ec == #'no modification' ifTrue:
		[^self error: 'can''t become immutable objects'].
	ec == #'object is pinned' ifTrue:
		[^self error: 'can''t become pinned objects'].
	ec == #'insufficient object memory' ifTrue:
		[self error: 'The virtual machine is out-of-date.  Please upgrade.'].
	self primitiveFailed! !
!Array methodsFor: 'converting' stamp: 'jmv 1/26/2022 16:47:28' prior: 16780851!
              elementsForwardIdentityTo: otherArray copyHash: copyHash
	"This primitive performs a bulk mutation, causing all pointers to the elements of the
	 receiver to be replaced by pointers to the corresponding elements of otherArray.

	 If copyHash is true, the identityHashes remain with the pointers in rather than with the
	 objects so that the objects in the receiver should still be properly indexed in any
	 existing hashed structures after the mutation.	
	Warning: This means that the identityHash of objects in otherArray will change. This
	is most likely a problem if those objects are already in any identityHashed collection!!

	If copyHash is false, then the hashes of the objects in otherArray remain unchanged.
	If you know what you're doing this may indeed be what you want.
	Warning: This means that any identityHashed collection with elements in otherArray
	will not be broken, but any identityHashed collection with elements in self will be!!
	They should be #rehash 'ed.

	Additionally, any hashed (not identityHashed) collection with elements in the receiver
	will most likely break if the #hash message gives now a different answer!!
	They should be #rehash 'ed.

	Warning. This is a dangerous operation and it could lead to a crash if some object in
	receiver or argument is receiver of a method currently in execution.
	See #anyReceiverInStackIn: See senders."

	<primitive: 249 error: ec>
	ec == #'bad receiver' ifTrue:
		[^self error: 'receiver must be of class Array'].
	ec == #'bad argument' ifTrue:
		[^self error: (otherArray class == Array
						ifTrue: ['arg must be of class Array']
						ifFalse: ['receiver and argument must have the same size'])].
	ec == #'inappropriate operation' ifTrue:
		[^self error: 'can''t become immediates such as SmallIntegers or Characters'].
	ec == #'no modification' ifTrue:
		[^self error: 'can''t become immutable objects'].
	ec == #'object is pinned' ifTrue:
		[^self error: 'can''t become pinned objects'].
	self primitiveFailed! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5049-become-betterComments-JuanVuletich-2022Jan26-16h41m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5038] on 18 January 2022 at 7:34:47 pm'!
!ContextPart methodsFor: 'private-exceptions' stamp: 'jar 1/18/2022 18:57:25'!
                         runUntilReturnFrom: aContext
	"Run the receiver (which must be a stack top context) until aContext returns. Avoid a context that cannot return. 
	Note: to avoid infinite recursion of MNU error inside unwind blocks, implement e.g. a wrapper around the message 
	sentTo: receiver in #doesNotUnderstand:. Note: This method was meant to be used exclusively by #unwindTo."

	| here unwindBottom newTop |
	here _ thisContext.
	"Avoid a context that cannot return (see Note 1 below)"
	unwindBottom _ (self findContextSuchThat: [:ctx | ctx selector = #cannotReturn:]) ifNil: [aContext].
	newTop _ aContext sender.
	"Insert ensure context under unwindBottom in self's stack (see Note 2 below)"
	unwindBottom insertSender: (self class contextEnsure: [here jump]).
	self jump.  "Control jumps to top (see Note 2 below)"
	"Control resumes here once the above inserted ensure block is executed"
	^newTop  "Return the new top context (see Note 3 below)"

	"Note 1: returning from #cannotReturn's sender would crash the VM so we install a guard ensure context right 
	above it and after returning here the unwind will continue safely. Try running and debugging this example 
	(avoid Proceeding the BCR error though; it may indeed crash the image):
	[[[] ensure: [^2]] ensure: [^42]] fork"

	"Note 2: the receiver is run by jumping directly to it (the active process abandons thisContext and executes 
	the receiver on its own stack; the receiver is its top context). However, before jumping to top we insert an ensure 
	block under unwindBottom context that will execute a jump back to thisContext when evaluated. The inserted 
	guard ensure context is removed once control jumps back to thisContext."

	"Note 3: it doesn't matter newTop is not a proper stack top context because #unwindTo will only use it as a starting 
	point in the search for the next unwind context and the computation will never return here. Cf. the pattern in 
	#runUntilErrorOrReturnFrom:: removing the inserted ensure context by stepping until popped when executing 
	non-local returns is not applicable here and would fail tests testTerminateInNestedEnsureWithReturn1 through 4."
! !
!ContextPart methodsFor: 'private-exceptions' stamp: 'jar 1/18/2022 18:55:12' prior: 16833502!
                               unwindTo: aContext

	| top ctxt outerMost |
	"If the receiver represents a block already halfways through an unwind, complete that unwind block
	first; if there are multiple such nested unwind blocks, try to complete the outer-most one; all nested 
	unwind blocks will be completed in the process; see tests in UnwindTest, testTerminationDuringUnwind. 
	Note: Halfway-through blocks have already set the complete variable (tempAt: 2) in their defining
	#ensure:/#ifCurtailed contexts from nil to true; we'll search for the bottom-most one.
	Note: #findNextUnwindContextUpTo: starts searching from the receiver's sender so we must check 
	whether the receiver itself is an unwind context as well; see testTerminateEnsureAsStackTop."
	ctxt _ top _ self.
	ctxt isUnwindContext ifFalse: [ctxt _ ctxt findNextUnwindContextUpTo: aContext].
	[ctxt isNil] whileFalse: [
		(ctxt tempAt:2) ifNotNil: [
			outerMost _ ctxt].
		ctxt _ ctxt findNextUnwindContextUpTo: aContext].
	outerMost ifNotNil: [top _ (top runUntilReturnFrom: outerMost) sender].

	"By now no halfway-through unwind blocks are on the stack. Create a new top context for each 
	pending unwind block (tempAt: 1) and execute it on the unwind block's stack to execute non-local 
	returns correctly. Cf. the unwind pattern in #resume:through:. In #unwindTo, using #value instead of 
	#runUntilReturnFrom: would lead to an incorrect evaluation of non-local returns on the wrong stack. 
	Note: top points to the former outerMost sender now, i.e. to the next unexplored context."
	ctxt _ top.
	ctxt isUnwindContext ifFalse: [ctxt _ ctxt findNextUnwindContextUpTo: aContext].
	[ctxt isNil] whileFalse: [
		(ctxt tempAt: 2) ifNil: [
			ctxt tempAt: 2 put: true.
			top _ (ctxt tempAt: 1) asContextWithSender: ctxt.
			top runUntilReturnFrom: top].
		ctxt _ ctxt findNextUnwindContextUpTo: aContext]
! !
!Process methodsFor: 'changing process state' stamp: 'jar 1/18/2022 19:30:02' prior: 16917643!
     terminate 
	"Stop the process that the receiver represents forever. Unwind to execute pending ensure: and
	 ifCurtailed: blocks before terminating; allow all unwind blocks to run; if they are currently in
	 progress, let them finish. If the process is in the middle of a #critical: section, release it properly."
	
	"If terminating the active process, create a parallel stack and run unwinds from there;
	 if terminating a suspended process, create a parallel stack for the process being terminated
	 and resume the suspended process to complete its termination from the parallel stack. Use
	 a priority higher than the active priority to make the process that invoked the termination
	 wait for its completion."

	"If terminating a suspended process (including runnable or blocked), always suspend the 
	 terminating process first so it doesn't accidentally get woken up. Equally important is the
	 side effect of the suspension; for pre-2022 VMs #suspend returns a list the process was
	 previously waiting on; figure out if we are terminating the process while waiting in
	 Semaphore>>critical:. In this case, pop the suspendedContext so that we leave the ensure:
	 block inside Semaphore>>critical: without signaling the semaphore.
	 Execute termination wrapped in #valueEnsured to ensure it completes even if the 
	 terminator process itself gets terminated before it's finished; see testTerminateInTerminate."

	| top |
	self isActiveProcess ifTrue: [
		top _ thisContext.
		^[top unwindTo: nil. self suspend] asContext jump].

	[	| oldList |
		suspendedContext isContext ifFalse: [^self].
		oldList _ self suspend.
		(oldList class == Semaphore and:[
			suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue: [
				suspendedContext _ suspendedContext home	].
		top _ suspendedContext.
		suspendedContext _ [top unwindTo: nil. self suspend] asContext.
		self priority: Processor activePriority + 1; resume
	] valueEnsured! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5050-terminate-NewImplementation-JaromirMatas-2022Jan18-19h00m-jar.001.cs.st----!

'From Cuis 6.0 [latest update: #5050] on 27 January 2022 at 3:10:23 pm'!
!Process methodsFor: 'test support' stamp: 'jar 6/1/2021 11:57:00'!
      terminateFromForkedProcess
	"Stop the process that the receiver represents forever. Unwind to execute pending ensure:/ifCurtailed: blocks before terminating.
	Process termination and exception handling in border cases has been the subject of a deep overhaul in the first months of 2021, by Jaromir Matas.
	See, for instance
		https://lists.cuis.st/mailman/archives/cuis-dev/2021-May/003171.html
		https://lists.cuis.st/mailman/archives/cuis-dev/2021-June/003187.html
	You can also look for other related mail threads in the Cuis mail list.
	Many new tests were added to BaseImageTests.pck.st
	Thank you Jaromir for this important contribution!!
	Note: This implementation was replaced by a new one, also from Jaromir, on January, 2022. This new implementation
	instead of using a separate process, use a separate, cloned stack, from the same process.
	We are keeping the 2021 approach, terminating from a new, forked process, in this method,
	just in case it proves useful too."

	| ctxt unwindBlock oldList outerMost top newTop |
	self isRunning ifTrue: [
		"If terminating the active process, suspend it first and terminate it as a suspended process."
		[self terminate] fork.
		^self suspend].

	[ "run the whole termination wrapped in #valueEnsured to ensure unwind is completed 	even if 
	the process terminating another process gets terminated - see #testTerminateInTerminate"
	"Always suspend the process first so it doesn't accidentally get woken up"
	oldList _ self suspend.
	suspendedContext ifNil: [^self]. "self is already terminated"
	"Figure out if we are terminating the process while waiting in Semaphore>>critical:
	In this case, pop the suspendedContext so that we leave the ensure: block inside
	Semaphore>>critical: without signaling the semaphore."
	(oldList class == Semaphore and:[
		suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue: [
			suspendedContext _ suspendedContext home.
	].

	top _ suspendedContext.
	suspendedContext _ nil. "disable this process while running its stack in active process below"
	"If terminating a process halfways through an unwind, try to complete that unwind block first;
	if there are multiple such nested unwind blocks, try to complete the outer-most one; nested 
	unwind blocks will be completed in the process. Halfway-through blocks have already set the 
	complete variable (tempAt: 2) in their defining #ensure:/#ifCurtailed contexts from nil to true.
	Note: #findNextUnwindContextUpTo: starts searching from the receiver's sender but the receiver 
	itself may be an unwind context."
	ctxt _ top.
	ctxt isUnwindContext ifFalse: [ctxt _ ctxt findNextUnwindContextUpTo: nil].
	[ctxt isNil] whileFalse: [
		(ctxt tempAt:2) ifNotNil: [
			outerMost _ ctxt].
		ctxt _ ctxt findNextUnwindContextUpTo: nil].
	outerMost ifNotNil: [newTop _ self complete: top to: outerMost].

	"By now no halfway-through unwind blocks are on the stack. Create a new top context for each 
	pending unwind block (tempAt: 1) and execute it on the unwind block's stack. 
	Note: using #value instead of #complete:to: would lead to incorrect evaluation of non-local returns.
	Note: newTop sender points to the former outerMost sender, i.e. the next unexplored context."
	ctxt _ newTop ifNil: [top] ifNotNil: [newTop sender].
	ctxt isUnwindContext ifFalse: [ctxt _ ctxt findNextUnwindContextUpTo: nil].
	[ctxt isNil] whileFalse: [
		(ctxt tempAt: 2) ifNil: [
			ctxt tempAt: 2 put: true.
			unwindBlock _ ctxt tempAt: 1.
			top _ unwindBlock asContextWithSender: ctxt.
			self complete: top to: top].
		ctxt _ ctxt findNextUnwindContextUpTo: nil]
	] valueEnsured! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5051-terminateFromForkedProcess-JaromirMatas-2022Jan27-15h09m-jar.001.cs.st----!

'From Cuis 6.0 [latest update: #5049] on 27 January 2022 at 11:53:45 am'!
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 1/27/2022 11:36:54'!
                        recompileSingleRecursion: force from: oldClass to: newClass
	"Based on #recompile:from:to:mutate:
	Older behavior of that method (before January 2022) did a single BFS on the hierarchy tree,
	creating new classes when traveling downwards, and migrating instances before returning upwards.
	This was changed to build the entire hierarchy, then validate with #canUpdateFrom: and only keep
	the new classes, and migrate instances if #canUpdateFrom: answered true.
	This breaks when recompiling the instance side of the Behavior hierarchy (Behavior, ClassDescription,
	Class and Metaclass).
	This method, appropriate for these classes does a single recursion, i.e. the pre-2022 behavior.
	It uses a more restrictive check for existing instances: It will not allow recompilation if any instance is
	executing any method, regardless of it being affected by the reshaping of the class or not. For this
	reason, for other classes, we prefer the more careful check done by #canUpdateFrom:
	
	See senders."

	(newClass == oldClass and: [force not]) ifTrue:[
		^newClass].

	currentClassIndex _ 0.
	maxClassIndex _ oldClass withAllSubclasses size.

	(oldClass == newClass) ifTrue: [
		"Recompile from newClass without mutating"
		self informUserDuring: [
			newClass withAllSubclassesDo: [ :cl |
				self showProgressFor: cl.
				cl compileAll ]].
		^newClass].

	"Recompile oldClass to newClass"
	self informUserDuring: [
		self mutate: oldClass to: newClass.
	].
	^oldClass "now mutated to newClass"! !
!ClassBuilder methodsFor: 'class mutation' stamp: 'eem 6/11/2008 16:47'!
 mutate: oldClass to: newClass
	"Mutate the old class and subclasses into newClass and subclasses.
	Note: This method is slightly different from: #mutate:toSuper: since
	here we are at the root of reshaping and have two distinct roots."

	self showProgressFor: oldClass.
	"Convert the subclasses"
	oldClass subclasses do:[:oldSubclass| | newSubclass |
		newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
		self mutate: oldSubclass to: newSubclass.
	].
	"And any obsolete ones"
	oldClass obsoleteSubclasses do:[:oldSubclass| | newSubclass |
		oldSubclass ifNotNil:[
			newSubclass := self reshapeClass: oldSubclass toSuper: newClass.
			self mutate: oldSubclass to: newSubclass.
		].
	].
	self update: oldClass to: newClass.
	^newClass! !
!ProcessorScheduler methodsFor: 'services' stamp: 'jmv 1/27/2022 11:08:03'!
    anyReceiverInStackInstanceOfClassIn: anArray
	"Iterate over all methods currently in execution. Answer true if in any of them 'self class' an element of argument"
	"
	Processor anyReceiverInStackInstanceOfClassIn: { WorldMorph }
	Processor anyReceiverInStackInstanceOfClassIn: { Text }
	"
	self
		processesDo: [ :p | ]
		withStackFramestDo: [ :p :c |
			(anArray statePointsTo: c receiver class)
				ifTrue: [ ^ true ]]
		runningProcessSearchStart: nil.
	^ false! !
!ClassBuilder methodsFor: 'class definition' stamp: 'jmv 1/27/2022 11:48:17' prior: 16811187!
                name: className subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe
	"Define a new class.
	If unsafe is true do not run any validation checks.
	This facility is provided to implement important system changes."
	
	| oldClass newClass organization instVars classVars force needNew oldCategory copyOfOldClass newCategory behaviorClasses |
	
	instVars _ Scanner new scanFieldNames: instVarString.
	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].

	"Validate the proposed name"
	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].
	oldClass _ Smalltalk at: className ifAbsent: nil.
	oldClass isBehavior 
		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"
	copyOfOldClass _ oldClass copy.

	unsafe ifFalse:[
		"Run validation checks so we know that we have a good chance for recompilation"
		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].
		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].
		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].

	"See if we need a new subclass"
	needNew _ self needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass.
	needNew ifNil: [^nil]. "some error"

	(needNew and:[unsafe not]) ifTrue:[
		"Make sure we don't redefine any dangerous classes"
		(self tooDangerousClasses includes: oldClass name) ifTrue:[
			self error: oldClass name, ' cannot be changed'.
		].
		"Check if the receiver should not be redefined"
		(oldClass notNil and:[oldClass shouldNotBeRedefined]) ifTrue:[
			self notify: oldClass name asText allBold, 
						' should not be redefined!! \Proceed to store over it.' withNewLines]].

	needNew ifTrue:[
		"Create the new class"
		newClass _ self 
			newSubclassOf: newSuper 
			type: type 
			instanceVariables: instVars
			from: oldClass.
		newClass ifNil: [ ^nil]. "Some error"
		newClass setName: className.
	] ifFalse:[
		"Reuse the old class"
		newClass _ oldClass.
	].

	"Install the class variables and pool dictionaries... "
	force _ (newClass declare: classVarString) | (newClass sharing: poolString).

	"... classify ..."
	newCategory _ category withBlanksTrimmed.
	organization _ Smalltalk organization.
	oldClass ifNotNil: [oldCategory := (organization categoryOfElement: oldClass name) asSymbol].
	organization classify: newClass name under: newCategory.

	"... recompile ..."
	(oldClass notNil and: [oldClass includesBehavior: Behavior])
		ifTrue: [
			"This is only true for Behavior, ClassDescription, Class and Metaclass. Special treatment."
			unsafe ifFalse: [
				behaviorClasses _ (oldClass withAllSubclasses select: [ :c | c isMeta not ]) asArray.
				(Processor anyReceiverInStackInstanceOfClassIn: behaviorClasses) ifTrue: [
					self error: oldClass name,' has some subInstance running some CompiledMethod.'.
					^nil ]].
			"Please see comment at this method"
			newClass _ self recompileSingleRecursion: force from: oldClass to: newClass ]
		ifFalse: [
			"Other classes"
			newClass _ self recompile: force from: oldClass to: newClass mutate: false ].
	newClass isNil ifTrue: [ ^nil ].

	"... export if not yet done ..."
	(Smalltalk at: newClass name ifAbsent: nil) == newClass ifFalse:[
		[Smalltalk at: newClass name put: newClass]
			on: AttemptToWriteReadOnlyGlobal do:[:ex| ex resume: true].
		Smalltalk flushClassNameCache.
	].

	self doneCompiling: newClass.
	
	"... notify interested clients ..."
	oldClass ifNil: [
		SystemChangeNotifier uniqueInstance classAdded: newClass inCategory: newCategory.
		^ newClass].
	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.
	newCategory ~= oldCategory 
		ifTrue: [SystemChangeNotifier uniqueInstance classRecategorized: newClass from: oldCategory to: newCategory ].
	^newClass! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5052-SpecialRecompilationForBehaviorInstanceSide-JuanVuletich-2022Jan27-11h52m-jmv.002.cs.st----!

'From Cuis 6.0 [latest update: #5049] on 27 January 2022 at 1:38:52 pm'!

ListItemWrapper subclass: #SystemCategoryWrapper
	instanceVariableNames: 'itemName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!

!classDefinition: #SystemCategoryWrapper category: #'Tools-Browser' stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
ListItemWrapper subclass: #SystemCategoryWrapper
	instanceVariableNames: 'itemName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Browser'!
!Browser methodsFor: 'system category list' stamp: 'len 1/25/2022 08:19:55'!
      selectedSystemCategory
	"Answer the name of the selected system category or nil."

	^selectedSystemCategory! !
!Browser methodsFor: 'system category list' stamp: 'len 1/25/2022 08:48:29'!
    setSelectedSystemCategory: aString
	"Set the selected system category and update all other selections to be deselected."
	selectedSystemCategory _ aString.
	selectedClassName _ nil.
	selectedMessageCategory _ nil.
	selectedMessage _ nil.
	self editSelection: (aString isNil ifTrue: [#none] ifFalse: [#newClass]).
	metaClassIndicated _ false.
	self setClassOrganizer.
	self changed: #selectedSystemCategory.
	self changed: #classList.
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self changed: #instanceMessagesIndicated.
	self changed: #classCommentIndicated.
	self changed: #classMessagesIndicated.
	self acceptedContentsChanged! !
!Browser methodsFor: 'system category list' stamp: 'len 1/27/2022 13:19:44'!
           setSelectedSystemCategoryTreeItem: aSystemCategoryWrapper
	aSystemCategoryWrapper ifNotNil: [self setSelectedSystemCategory: aSystemCategoryWrapper withoutListWrapper]! !
!Browser methodsFor: 'system category list' stamp: 'len 1/27/2022 13:12:19'!
        systemCategoryRoots
	"Answer the roots of the forest of system categories."
	| subcategories roots name |
	subcategories _ Dictionary new.
	self systemCategoryList do: [:each|
		name _ (each findTokens: '-') first.
		(subcategories at: name ifAbsentPut: [OrderedCollection new]) add: each].
	roots _ OrderedCollection new.
	self systemCategoryList do: [:each|
		name _ (each findTokens: '-') first.
		(roots includes: name) ifFalse:
			[(subcategories at: name) size > 1 ifTrue: [roots add: name] ifFalse: [roots add: (subcategories at: name) first]]].
	^ roots collect: [:each| SystemCategoryWrapper with: each name: each model: self]! !
!HierarchicalListMorph methodsFor: 'accessing' stamp: 'len 6/7/2020 05:36:17'!
                  roots
	"Answer the root items. These are instances of IndentingListItemMorph and submorphs of the scroller."
	| list |
	list _ self getList collect: [:each| each withoutListWrapper].
	^ scroller submorphs select: [:each| list includes: each withoutListWrapper]! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'len 1/27/2022 13:13:34'!
             buildMorphicSystemCategoryList
	^(HierarchicalListMorph
		model: model
		listGetter: #systemCategoryRoots
		indexGetter: #selectedSystemCategory
		indexSetter: #setSelectedSystemCategoryTreeItem:
		mainView: self
		menuGetter: #systemCategoryMenu
		keystrokeAction: #systemCatListKey:from:)
			autoDeselect: true;
			autoExpand: true;
			yourself! !
!ListItemWrapper methodsFor: 'as yet unclassified' stamp: 'len 6/7/2020 05:02:26'!
               isAncestorOf: anObject
	^ false! !
!ListItemWrapper methodsFor: 'as yet unclassified' stamp: 'len 6/6/2020 16:29:09' overrides: 16902975!
                      printOn: aStream
	aStream nextPutAll: self asString! !
!SystemCategoryWrapper methodsFor: 'accessing' stamp: 'len 1/27/2022 13:33:52' overrides: 16881049!
     contents
	| prefix subcategories |
	(item includes: $-) ifTrue: [^ #()].
	prefix _ item, '-'.
	subcategories _ OrderedCollection new.
	model systemCategoryList do: [:each|
		(each beginsWith: prefix)
			ifTrue: [subcategories add: (each copyFrom: prefix size + 1 to: each size)]].
	^ subcategories collect: [:each| self class with: prefix, each name: each model: model]! !
!SystemCategoryWrapper methodsFor: 'testing' stamp: 'len 6/6/2020 12:48:40' overrides: 16881045!
          canBeDragged
	^ false! !
!SystemCategoryWrapper methodsFor: 'testing' stamp: 'len 1/26/2022 07:00:37' overrides: 50334027!
     isAncestorOf: aString
	^ (item includes: $-) not and: [aString beginsWith: item, '-']! !
!SystemCategoryWrapper methodsFor: 'private' stamp: 'len 6/6/2020 12:46:34'!
                          setItem: anObject name: aString model: aModel
	item _ anObject.
	model _ aModel.
	itemName _ aString! !
!SystemCategoryWrapper methodsFor: 'converting' stamp: 'len 6/6/2020 16:28:40' overrides: 16881037!
                    asString
	^ itemName! !
!SystemCategoryWrapper class methodsFor: 'instance creation' stamp: 'len 6/6/2020 12:46:06'!
           with: anObject name: aString model: aModel
	^ self new  setItem: anObject name: aString model: aModel! !
!Browser methodsFor: 'annotation' stamp: 'len 1/25/2022 08:20:16' prior: 16795128 overrides: 16820468!
                annotation
	"Provide a line of content for an annotation pane, representing information about the method associated with the selected class and selector in the receiver."

	|  aSelector aClass |
	(aClass _ self selectedClassOrMetaClass)
		ifNil: [
			self selectedSystemCategory ifNotNil: [ :sysCat |
				^self annotationForSystemCategory: sysCat ].
			^ ''].
	self editSelection == #editComment
		ifTrue: [^ self annotationForSelector: #Comment ofClass: aClass].
	self isEditingExistingClass 
		ifTrue: [^ self annotationForSelector: #Definition ofClass: aClass].
	(aSelector _ self selectedMessageName)
		ifNil: [^ ''].
	^ self annotationForSelector: aSelector ofClass: aClass! !
!Browser methodsFor: 'class functions' stamp: 'len 1/27/2022 13:12:42' prior: 16795273!
                              defineClass: defString notifying: aRequestor  
	"The receiver's textual content is a request to define a new class. The
	source code is defString. If any errors occur in compilation, notify
	aRequestor."
	| oldClass class newClassName defTokens keywdIx |
	oldClass _ self selectedClassOrMetaClass.
	defTokens _ defString findTokens: Character separators.
	keywdIx _ defTokens findFirst: [ :x | x beginsWith: 'category' ].
	keywdIx _ defTokens findFirst: [ :x | '*subclass*' match: x ].
	newClassName _ (defTokens at: keywdIx+1) copyWithoutAll: '#()'.
	((oldClass isNil or: [ oldClass theNonMetaClass name asString ~= newClassName ])
		and: [ Smalltalk includesKey: newClassName asSymbol ]) ifTrue: [
			"Attempting to define new class over existing one when
				not looking at the original one in this browser..."
			(self confirm: (newClassName bold , ' is an existing class in this system.
Redefining it might cause serious problems.
Is this really what you want to do?'))
				ifFalse: [ ^ false ]].
	"ar 8/29/1999: Use oldClass superclass for defining oldClass
	since oldClass superclass knows the definerClass of oldClass."
	oldClass ifNotNil: [ oldClass _ oldClass superclass ].
	class _ Compiler
				evaluate: defString
				notifying: aRequestor
				logged: true.
	(class isKindOf: Behavior)
		ifTrue: [
				self changed: #systemCategoryRoots.
				self changed: #classList.
				self changed: #clearUserEdits.
				self setClass: class selector: nil.
				"self clearUserEditFlag; editClass."
				^ true ]
		ifFalse: [ ^ false ]! !
!Browser methodsFor: 'class list' stamp: 'len 1/27/2022 13:28:49' prior: 16795505!
              defaultClassList
	"Answer an array of the class names of the selected category. Answer an 
	empty array if no selection exists."

	| answer prefix |
	selectedSystemCategory ifNil: [^ #()].
	answer _ systemOrganizer listAtCategoryNamed: selectedSystemCategory.
	prefix _ selectedSystemCategory, '-'.
	systemOrganizer categories do: [:each| (each beginsWith: prefix) ifTrue: [answer _ answer, (systemOrganizer listAtCategoryNamed: each)]].
	^ answer! !
!Browser methodsFor: 'class list' stamp: 'len 1/25/2022 08:44:48' prior: 16795595!
          recent
	"Let the user select from a list of recently visited classes.  11/96 stp.
	 12/96 di:  use class name, not classes themselves.
	 : dont fall into debugger in empty case"

	| className class recentList |
	recentList _ self class recentClasses select: [:n | Smalltalk includesKey: n].
	recentList size = 0 ifTrue: [^ Smalltalk beep].
	className _ (SelectionMenu selections: recentList) startUpMenu.
	className ifNil: [^ self].
	class _ Smalltalk at: className.
	self setSelectedSystemCategory: class category.
	self selectClass: class! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:26' prior: 16796311!
                              addSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection"
	
	| newName |
	newName _ self newSystemCategoryNameIfNone: [ ^self ].	
	systemOrganizer
		addCategory: newName
		before: selectedSystemCategory.
	self setSelectedSystemCategory: newName.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:30' prior: 16796329!
                       alphabetizeSystemCategories
	systemOrganizer sortCategories.
	self setSelectedSystemCategory: nil.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:36' prior: 16796359!
                    changeSystemCategories: aString 
	"Update the class categories by parsing the argument aString."

	systemOrganizer changeFromString: aString.
	self changed: #systemCategoryRoots.
	^ true! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/25/2022 08:41:44' prior: 16796368!
editSystemCategories
	"Retrieve the description of the class categories of the system organizer."

	self setSelectedSystemCategory: nil.
	self editSelection: #editSystemCategories.
	self changed: #editSystemCategories.
	self acceptedContentsChanged! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:48' prior: 16796390!
  moveAllToOtherSystemCategory
	"If a class category is selected, prompt user for category to move to,
	create a Confirmer so the user can verify that all the classes in current category
 	should be moved to the selected category."
	| newSystemCategory |
	selectedSystemCategory ifNil: [ ^ self ].
	newSystemCategory _ Smalltalk systemCategoryFromUserWithPrompt: 'Move classes to System Category...'.
	(newSystemCategory notNil and: [
		self classList size > 0 and: [ self confirm: 'Are you sure you want to
move classes from ' , selectedSystemCategory , ' 
to ' , newSystemCategory , '?' ]]) ifTrue: [
		"Safer this way (#classList will be a collection of strings with spaces and who knows what in the future.  So let's just get the classes we need directly)"
		(SystemOrganization classesAt: selectedSystemCategory) do: [ :eaClass |
			eaClass category: newSystemCategory ].
		self changed: #systemCategoryRoots ].! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:53' prior: 16796422!
        moveSystemCategoryBottom
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryBottom: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:12:58' prior: 16796431!
                        moveSystemCategoryDown
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryDown: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:13:03' prior: 16796440!
                            moveSystemCategoryTop
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryTop: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:13:07' prior: 16796449!
                              moveSystemCategoryUp
	selectedSystemCategory ifNil: [^ self].
	systemOrganizer moveCategoryUp: selectedSystemCategory.
	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:13:13' prior: 16796493!
removeSystemCategory
	"If a class category is selected, create a Confirmer so the user can 
	verify that the currently selected class category and all of its classes
 	should be removed from the system. If so, remove it."

	selectedSystemCategory ifNil: [^ self].
	(self classList size = 0
		or: [self confirm: 'Are you sure you want to
remove this system category 
and all its classes?'])
		ifTrue: [
			systemOrganizer removeSystemCategory: selectedSystemCategory.
			self setSelectedSystemCategory: nil.
			self changed: #systemCategoryRoots ]! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:13:21' prior: 16796513!
                        renameSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection
	
	21-Mar-2012 jmv Note: This is not recorded appropriately in change sets.
	The easiest solution is to trigger #classRecategorized for all classes in the category.
	But this is not a real solution, as the resulting changeset would not do a rename,
	but create a new category (that would go to the bottom) with all the classes.
	
	In the meantime, disable the menu entry. This is not so important after all.
	"
	| oldName newName |
	selectedSystemCategory ifNil: [ ^ self].  "no selection"
	oldName _ selectedSystemCategory.
	newName _ self
		request: 'New category name?'
		initialAnswer: oldName
		verifying: [:aString| aString notEmpty and: [aString ~= oldName]]
		do: [:aString|
			newName _ aString asSymbol.
			systemOrganizer
				renameCategory: oldName
				toBe: newName.
			self setSelectedSystemCategory: newName.
			self changed: #systemCategoryRoots]! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/25/2022 08:46:41' prior: 16796549!
                      systemCategoryBrowser
	"Create a new system category browser with initial textual 
	contents set to aString."

	| newBrowser |
	selectedSystemCategory
		ifNotNil: [
			newBrowser _ Browser new.
			newBrowser setSelectedSystemCategory: self selectedSystemCategory.
			newBrowser setClass: self selectedClassOrMetaClass selector: self selectedMessageName.
			^newBrowser].
	^nil! !
!Browser methodsFor: 'system category functions' stamp: 'len 1/27/2022 13:13:26' prior: 16796564!
  updateSystemCategories
	"The class categories were changed in another browser. The receiver must 
	reorganize its lists based on these changes."

	self changed: #systemCategoryRoots! !
!Browser methodsFor: 'initialization' stamp: 'len 1/25/2022 08:45:06' prior: 16796701!
                setClass: aBehavior selector: aSymbol
	"Set the state of a new, uninitialized Browser."

	| isMeta aClass messageCatIndex |
	aBehavior ifNil: [^ self].
	aBehavior isMeta
		ifTrue: [
			isMeta _ true.
			aClass _ aBehavior soleInstance]
		ifFalse: [
			isMeta _ false.
			aClass _ aBehavior].
	self setSelectedSystemCategory: aClass category.
	self selectClass: aClass.
	self metaClassIndicated: isMeta.
	aSymbol ifNil: [^ self].
	messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.
	self messageCategoryListIndex: (messageCatIndex > 0
		ifTrue: [messageCatIndex + 1]
		ifFalse: [0]).
	messageCatIndex = 0 ifTrue: [^ self].
	self messageListIndex: (
		(aBehavior organization listAtCategoryNumber: messageCatIndex)
			indexOf: aSymbol).! !
!HierarchyBrowser methodsFor: 'initialization' stamp: 'len 1/27/2022 13:17:22' prior: 16867924 overrides: 16795422!
                classListIndex: newIndex
	"Cause system organization to reflect appropriate category"

	| newClassName index |

	(classList isInBounds: newIndex) ifTrue: [
		newClassName _ (classList at: newIndex) withoutLeadingBlanks.
		selectedSystemCategory _ systemOrganizer categoryOfElement: newClassName].
	index _ super classListIndex: newIndex.
	self changed: #systemCategorySingleton.
	^ index! !
!Categorizer methodsFor: 'accessing' stamp: 'len 1/27/2022 13:37:32' prior: 16800846!
   listAtCategoryNamed: categoryName
	"Answer the array of elements associated with the name, categoryName."

	^ self listAtCategoryNumber: (categoryArray indexOf: categoryName ifAbsent: [^ #()])! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 8/2/2021 14:45:19' prior: 16869615!
                          drawLineToggleToTextFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor hasToggle: hasToggle
	"If I am not the only item in my container, draw the line between:
		- my left edge
		- and my text left edge"

	| aMorphCenter hLineY hLineLeft rect right |
	anIndentingListItemMorph isSoleItem ifTrue: [ ^ self ].
	hasToggle ifFalse: [
		rect _ anIndentingListItemMorph toggleRectangle.
		aMorphCenter _ anIndentingListItemMorph externalize: rect center.
		right _ (anIndentingListItemMorph externalize: rect rightCenter) x.
		hLineY _ aMorphCenter y.
		hLineLeft _ aMorphCenter x - 1.
		aCanvas
			line: hLineLeft @ hLineY
			to: right @ hLineY
			width: 1
			color: lineColor ]! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'len 1/23/2022 11:48:29' prior: 16869640!
            drawLinesFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor 
	anIndentingListItemMorph indentLevel > 0 ifTrue: [
		| hasToggle |
		hasToggle _ anIndentingListItemMorph hasToggle.
	
		"Draw line from toggle to text"
		self
			drawLineToggleToTextFor: anIndentingListItemMorph
			on: aCanvas
			lineColor: lineColor
			hasToggle: hasToggle.

		"Draw the line from toggle to the nextSibling's toggle"
		anIndentingListItemMorph nextSibling ifNotNil: [
			self
				drawLinesToNextSiblingFor: anIndentingListItemMorph
				on: aCanvas
				lineColor: lineColor
				hasToggle: hasToggle ]].

	"If it have children and am expanded, draw a line to its first child"
	(anIndentingListItemMorph firstChild notNil and: [
			anIndentingListItemMorph isExpanded ]) ifTrue: [
		self
			drawLinesToFirstChildFor: anIndentingListItemMorph
			on: aCanvas
			lineColor: lineColor]! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 7/18/2014 09:30' prior: 16869668!
                     drawLinesOn: aCanvas 
	| lColor bottomY topY tx clipRect |
	lColor _ Theme current line.
	tx _ aCanvas currentTransformation.
	clipRect _ aCanvas clipRect.
	topY _ (tx internalizePosition: clipRect topLeft) y min: (tx internalizePosition: clipRect topRight) y.
	bottomY _ (tx internalizePosition: clipRect bottomLeft) y max: (tx internalizePosition: clipRect bottomRight) y.
	self submorphs do: [ :submorph | 
		(submorph isExpanded or: [
			(submorph morphPosition y between: topY and: bottomY) or: [
				submorph nextSibling notNil and: [
					submorph nextSibling morphPosition y between: topY and: bottomY ] ] ])
		ifTrue: [
			self
				drawLinesFor: submorph
				on: aCanvas
				lineColor: lColor ]]
	! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 9/20/2012 21:49' prior: 16869693!
                          drawLinesToFirstChildFor: anIndentingListItemMorph on: aCanvas lineColor: lineColor
	"Draw line from me to next sibling"

	| vLineX vLineTop vLineBottom childCenter firstChild |
	"child in the drawn tree. it is acually our submorph"
	firstChild _ anIndentingListItemMorph firstChild.
	childCenter _ firstChild externalize: firstChild toggleRectangle center.
	vLineX _ childCenter x - 1.
	vLineTop _ (anIndentingListItemMorph
		externalize: anIndentingListItemMorph morphExtent) y.
	firstChild hasToggle
		ifTrue: [ vLineBottom _ childCenter y - 7 ]
		ifFalse: [ vLineBottom _ childCenter y ].
	aCanvas
		line: vLineX @ vLineTop
		to: vLineX @vLineBottom
		width: 1
		color: lineColor! !
!HierarchicalListMorph methodsFor: 'commands' stamp: 'len 6/7/2020 05:36:50' prior: 16867270!
                   expandAllAsPer: aBlock

	scroller submorphs isEmpty ifTrue: [^self].
	self roots do: [:each| each beFullyExpandedAsPer: aBlock].
	scroller adjustExtent.
	self setScrollDeltas! !
!HierarchicalListMorph methodsFor: 'selection' stamp: 'len 6/7/2020 05:31:21' prior: 16867700!
               privateVisualSelection: item
	"Called internally to set a new selection.
	Does not update model"
	| index |
	item isNil ifTrue: [^ self privateVisualSelectionIndex: 0].
	index _ self indexForItem: item.
	index > 0 ifFalse:
		[self expandAllAsPer: [:each| each complexContents isAncestorOf: item withoutListWrapper].
		index _ self indexForItem: item].
	self privateVisualSelectionIndex: index! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'len 1/27/2022 13:08:33' prior: 16797091!
                         buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList systemCatList classList |

	systemCatList _ self buildMorphicSystemCategoryList.
	classList _ self buildMorphicClassList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
"	systemCatList rightSibling: classList."
	classList leftSibling: systemCatList rightSibling: messageCatList.
	messageCatList leftSibling: classList rightSibling: messageList.
	messageList leftSibling: messageCatList.
	
	classList makeItemsDraggable.
"	systemCatList 
		acceptDropsFrom: classList 
		performing: #categorizeUnderCategoryAt:class:
		whenOutsideList: #categorizeUnderNewCategoryClass:.
"		
	messageList makeItemsDraggable.
	messageCatList 
		acceptDropsFrom: messageList 
		performing: #categorizeUnderCategoryAt:selector: 
		whenOutsideList: #categorizeUnderNewCategorySelector:.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: systemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: (self buildMorphicClassColumnWith: classList) proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!BrowserWindow methodsFor: 'menu commands' stamp: 'len 1/25/2022 08:21:41' prior: 16797329!
            openSystemCategoryBrowser
	"Create and schedule a new system category browser with initial textual
	contents set to aString."

	model systemCategoryBrowser ifNotNil: [ :newBrowser |
		newBrowser selectedSystemCategory ifNotNil: [ :category |
			BrowserWindow
				openNoSysCat: newBrowser
				label: 'Classes in category ', category ]]! !
!BrowserWindow methodsFor: 'updating' stamp: 'len 1/25/2022 08:20:58' prior: 16797373 overrides: 16821953!
   classAdded: addedClass

	self model selectedSystemCategory = addedClass category 
		ifTrue: [ self model changed: #classList ]! !
!BrowserWindow methodsFor: 'updating' stamp: 'len 1/25/2022 08:21:31' prior: 16797380 overrides: 16821960!
                   classRenamed: aClass from: oldClassName to: newClassName inCategory: aCategoryName

	| currentSelectedClass |
	
	self canDiscardEdits ifTrue: [
		self model selectedSystemCategory = aCategoryName ifTrue: [
			currentSelectedClass := self model selectedClass.
			currentSelectedClass ifNil: [ 
				self model originalSelectedClassName = oldClassName ifTrue: [ 
					currentSelectedClass := aClass ]].
			
		 	self model changed: #classList.
			self model selectClass: currentSelectedClass ]]! !
!BrowserWindow methodsFor: 'commands' stamp: 'len 1/25/2022 08:45:23' prior: 16797559!
                           findClass

	| scopedClassNames |
	
	scopedClassNames _ model potentialClassNames asOrderedCollection.
	
	self class 
		findClassFrom: scopedClassNames 
		ifFound: [:foundClass |
			model setSelectedSystemCategory: foundClass category.
			model selectClass: foundClass ]! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'len 1/25/2022 09:07:08' prior: 16818367 overrides: 50334569!
                        buildMorphicWindow
	"Create a pluggable version of all the views for a Browser, using Morphic widgets."

	| sysCatList msgCatList upperPanes clsLayout clsList msgList |
	model setSelectedSystemCategory: model systemCategoryList first.
	sysCatList _ PluggableListMorph
			model: model 
			listGetter: #systemCategorySingleton
			indexGetter: #indexIsOne 
			indexSetter: #indexIsOne:
			mainView: self
			menuGetter: #codeFileListMenu
			keystrokeAction: #codeFileListKey:from:.
	sysCatList hideScrollBarsIndefinitely.
	
	msgCatList _ PluggableListMorph
			model: model 
			listGetter: #messageCategoryList
			indexGetter: #messageCategoryListIndex 
			indexSetter: #messageCategoryListIndex:
			mainView: self
			menuGetter: #messageCategoryMenu
			keystrokeAction: nil.

	clsList := self buildMorphicClassList.
	clsLayout := self buildMorphicClassColumnWith: clsList.
	msgList := self buildMorphicMessageList.
	sysCatList rightSibling: clsList.
	clsList leftSibling: sysCatList rightSibling: msgCatList.
	msgCatList leftSibling: clsList rightSibling: msgList.
	msgList leftSibling: msgCatList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: clsLayout proportionalWidth: 0.3;
		addAdjusterAndMorph: msgCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: msgList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: sysCatList fixedHeight: Preferences standardCodeFont lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.
	model changed: #editSelection! !
!CodeFileBrowserWindow methodsFor: 'commands' stamp: 'len 1/25/2022 09:08:23' prior: 16818655 overrides: 50334658!
                findClass
	| pattern foundClass classNames index foundCodeFile |
	self okToChange ifFalse: [^ self flash].
	self request: 'Class name?' do: [:aString|
		aString isEmpty ifFalse:
			[pattern _ aString asLowercase.
			classNames _ Set new.
			classNames addAll: model caseCodeSource classDictionary keys.
			classNames _ classNames asArray select: 
				[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].
			classNames isEmpty ifFalse:
				[index _ classNames size = 1
					ifTrue: [1]
					ifFalse: [(PopUpMenu labelArray: classNames lines: #()) startUpMenu].
				index = 0 ifFalse:
					[foundCodeFile _ nil.
					foundClass _ nil.
					(model caseCodeSource classDictionary includesKey: (classNames at: index))
						ifTrue:
							[foundClass _ model caseCodeSource classDictionary at: (classNames at: index).
							foundCodeFile _ model caseCodeSource].
					foundClass ifNotNil:
						[model setSelectedSystemCategory: foundCodeFile name asSymbol.
						model classListIndex: (model classList indexOf: foundClass name)]]]]]! !

BrowserWindow removeSelector: #buildMorphicSystemCatList!

!methodRemoval: BrowserWindow #buildMorphicSystemCatList stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
buildMorphicSystemCatList

	^PluggableListMorph
		model: model
		listGetter: #systemCategoryList
		indexGetter: #systemCategoryListIndex
		indexSetter: #systemCategoryListIndex:
		mainView: self
		menuGetter: #systemCategoryMenu
		keystrokeAction: #systemCatListKey:from:!

BrowserWindow removeSelector: #buildMorphicSystemCategoryTree!

Browser removeSelector: #systemCategoryTree!

Browser removeSelector: #systemCategoryListIndex:!

!methodRemoval: Browser #systemCategoryListIndex: stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
systemCategoryListIndex: anInteger
	"Set the selected system category index to be anInteger. Update all other 
	selections to be deselected."
	
	| index systemCategoryList |
	
	systemCategoryList _ self systemCategoryList.
	index _ systemCategoryList ifInBounds: anInteger ifNot: 0.
	
	selectedSystemCategory _ index = 0 ifFalse: [ systemCategoryList at: index ].
	selectedClassName _ nil.
	selectedMessageCategory _ nil.
	selectedMessage _ nil.
	self editSelection: ( index = 0 ifTrue: [#none] ifFalse: [#newClass]).
	metaClassIndicated _ false.
	self setClassOrganizer.
	self changed: #systemCategorySelectionChanged.
	self changed: #systemCategoryListIndex.	"update my selection"
	self changed: #classList.
	self changed: #messageCategoryList.
	self changed: #messageList.
	self changed: #relabel.
	self changed: #instanceMessagesIndicated.
	self changed: #classCommentIndicated.
	self changed: #classMessagesIndicated.
	self acceptedContentsChanged!

Browser removeSelector: #selectedSystemCategoryName!

!methodRemoval: Browser #selectedSystemCategoryName stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
selectedSystemCategoryName
	"Answer the name of the selected system category or nil."

	^selectedSystemCategory!

Browser removeSelector: #systemCategoryListIndex!

!methodRemoval: Browser #systemCategoryListIndex stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
systemCategoryListIndex
	"Answer the index of the selected class category."

	systemOrganizer ifNil: [ ^0 ].
	selectedSystemCategory ifNil: [ ^0 ].
	^self systemCategoryList indexOf: selectedSystemCategory!

Browser removeSelector: #categorizeUnderNewCategoryClass:!

!methodRemoval: Browser #categorizeUnderNewCategoryClass: stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
categorizeUnderNewCategoryClass: aClassName

	| newCategory |
	
	newCategory _ self newSystemCategoryNameIfNone: [ ^self ].
	
	systemOrganizer
		addCategory: newCategory;
		classify: aClassName withBlanksTrimmed asSymbol under: newCategory.
		
	self changed: #systemCategoryList.
	self changed: #classList.!

Browser removeSelector: #categorizeUnderCategoryAt:class:!

!methodRemoval: Browser #categorizeUnderCategoryAt:class: stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
categorizeUnderCategoryAt: aSystemCategoryIndex class: aClassName 

	systemOrganizer classify: aClassName withBlanksTrimmed asSymbol under: (self systemCategoryList at: aSystemCategoryIndex).
	self changed: #classList!

Browser removeSelector: #selectCategoryForClass:!

!methodRemoval: Browser #selectCategoryForClass: stamp: 'Install-5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st 2/21/2022 14:50:20'!
selectCategoryForClass: theClass

	self systemCategoryListIndex: (self systemCategoryList indexOf: theClass category)
!

SystemOrganization
        renameCategory: #'Theme-Core' toBe: #'Graphics-Themes';
        renameCategory: #'System-TextAttributes' toBe: #'System-Text-Attributes';
        renameCategory: #'System-FileMan-Core' toBe: #'System-File System';
        renameCategory: #'Exceptions Kernel' toBe: #'Exceptions-Kernel';
        renameCategory: #'Exceptions Extensions' toBe: #'Exceptions-Extensions'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5053-HierarchicalSystemCategories-LucianoEstebanNotarfrancesco-2022Jan27-13h04m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5053] on 31 January 2022 at 1:40:48 pm'!
!Browser methodsFor: 'class list' stamp: 'len 1/28/2022 16:21:42' prior: 50334156!
            defaultClassList
	"Answer an array of the class names of the selected category. Answer an 
	empty array if no selection exists."
	| answer |
	selectedSystemCategory ifNil: [^ #()].
	answer _ systemOrganizer listAtCategoryNamed: selectedSystemCategory.
	"If it's a top category, include the classes of all its subcategories:"
	(selectedSystemCategory includes: $-) ifFalse:
		[| prefix |
		prefix _ selectedSystemCategory, '-'.
		systemOrganizer categories do: [:each| (each beginsWith: prefix) ifTrue: [answer _ answer, (systemOrganizer listAtCategoryNamed: each)]]].
	^ answer! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5054-HierarchicalSystemCategories-fix-LucianoEstebanNotarfrancesco-2022Jan31-13h40m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5053] on 31 January 2022 at 1:48:30 pm'!
!MethodReference methodsFor: 'setting' stamp: 'len 1/30/2022 05:52:06'!
          indentLevel: anInteger
	self removeStringVersionPrefix.
	stringVersion _ (String streamContents: [:aStream| anInteger timesRepeat: [aStream nextPutAll: '    ']]), stringVersion! !
!MessageSet methodsFor: 'message list' stamp: 'len 1/30/2022 05:51:23' prior: 50332629!
                    sortByClassHierarchy
	"Sort the message-list by class / selector. List classes in hierarchical order."
	
	| aClass bClass classes classesAndPositions i |

	classes _ Set new.
	messageList do: [ :methodReference |
		methodReference actualClass ifNotNil: [ :actualClass | classes add: actualClass ]].
	classesAndPositions _ Dictionary new.
	i _ 1.
	Smalltalk hierarchySorted: classes do: [ :each |
		classesAndPositions at: each put: i.
		i _ i + 1 ].
	
	messageList _ messageList sort: [ :a :b |
		(a classSymbol = b classSymbol and: [ b classIsMeta = b classIsMeta ])
			ifTrue: [
				a methodSymbol == #Comment
					ifTrue: [ true ]
					ifFalse: [
						b methodSymbol == #Comment
							ifTrue: [ false ]
							ifFalse: [ a methodSymbol < b methodSymbol ]]]
			ifFalse: [
				aClass _ a actualClass.
				bClass _ b actualClass.
				aClass isNil == bClass isNil
					ifTrue: [
						aClass isNil
							ifTrue: [a classSymbol < b classSymbol]
							ifFalse: [(classesAndPositions at: aClass) < (classesAndPositions at: bClass)]]
					ifFalse: [aClass isNil]]].
	messageList do: [ :each |
		each indentLevel:
			(each actualClass theNonMetaClass allSuperclasses select: [ :c |
				classesAndPositions includesKey: c ]) size ].
	self changed: #messageList.! !
!MethodReference methodsFor: 'setting' stamp: 'len 1/30/2022 05:49:54' prior: 16890498!
                          removeStringVersionPrefix
	| i prefixCoda |
	prefixCoda _ '] - '.
	i _ stringVersion findString: prefixCoda.
	i = 0 ifFalse: [stringVersion _ stringVersion copyFrom: i + prefixCoda size to: stringVersion size].
	stringVersion _ stringVersion withoutLeadingBlanks! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5055-MessageSet-indenting-useSpaces-LucianoEstebanNotarfrancesco-2022Jan31-13h40m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5053] on 31 January 2022 at 1:56:49 pm'!
!BitBltBoundsFinderCanvas methodsFor: 'morphic' stamp: 'len 1/31/2022 13:55:54' prior: 16789013!
              updateBoundsIn: aWorldMorph addDamageTo: aDamageRecorder

	aWorldMorph submorphsDo: [ :morph |
		self fullAddRedrawRect: morph to: aDamageRecorder ].
	self updateHandsDisplayBounds: aWorldMorph.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5056-FixSlowdownWhenUsingHalos-JuanVuletich-2022Jan31-13h49m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5056] on 1 February 2022 at 7:53:06 pm'!
!Categorizer methodsFor: 'accessing' stamp: 'len 2/1/2022 19:45:05'!
   renameCategory: oldCatString to: newCatString
	"Rename a category. No action if new name already exists, or if old name does not exist."
	
	| index newCategory |
	
	newCategory _ newCatString withBlanksTrimmed.
	"new name exists, so no action"
	(categoryArray indexOf: newCategory) > 0 ifTrue: [^ self].
	
	"old name not found, so no action"
	(index _ categoryArray indexOf: oldCatString) = 0 ifTrue: [^ self].	
	
	"need to change identity so smart list update will notice the change"
	categoryArray _ categoryArray copy.  
	categoryArray at: index put: newCategory! !
!ClassOrganizer methodsFor: 'accessing' stamp: 'len 2/1/2022 19:46:01' overrides: 50335022!
           renameCategory: oldCatString to: newCatString

	| newCategory oldElementsBefore oldElementsAfter |
	
	newCategory _ newCatString withBlanksTrimmed.
	oldElementsBefore _ self listAtCategoryNamed: oldCatString.
	SystemChangeNotifier uniqueInstance doSilently: [
		super renameCategory: oldCatString to: newCatString].
	
	oldElementsAfter _ (self listAtCategoryNamed: oldCatString) asSet.
	oldElementsBefore do: [:each | (oldElementsAfter includes: each)
		ifFalse: [self notifyOfChangedSelector: each from: oldCatString to: newCategory]].
	
	self notifyOfChangedCategoryFrom: oldCatString to: newCategory.! !
!Browser methodsFor: 'message category functions' stamp: 'len 2/1/2022 19:45:44' prior: 16795873!
                               renameCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection"
	| oldIndex oldName newName |
	selectedClassName ifNil: [^ self].
	selectedMessageCategory ifNil: [ ^self ].
	oldIndex _ self messageCategoryListIndex.
	oldName _ self selectedMessageCategoryName.
	newName _ self
		request: 'New category name?'
		initialAnswer: oldName
		verifying: [:aString| aString notEmpty and: [aString ~= oldName]]
		do: [:aString|
			newName _ aString asSymbol.
			self classOrMetaClassOrganizer
				renameCategory: oldName
				to: newName.
			self classListIndex: self classListIndex.
			self messageCategoryListIndex: oldIndex.
			self changed: #messageCategoryList]! !
!Browser methodsFor: 'system category functions' stamp: 'len 2/1/2022 19:35:19' prior: 50334304!
          removeSystemCategory
	"If a class category is selected, create a Confirmer so the user can 
	verify that the currently selected class category and all of its classes
 	should be removed from the system. If so, remove it."

	selectedSystemCategory ifNil: [^ self].
	(self classList size = 0
		or: [self confirm: 'Are you sure you want to
remove this system category 
and all its classes?'])
		ifTrue: [
			"Remove subcategories:"
			systemOrganizer removeCategoriesMatching: selectedSystemCategory, '-*'.
			"Then remove the top category (it doesn't do anything if it doesn't exist):"
			systemOrganizer removeSystemCategory: selectedSystemCategory.
			self setSelectedSystemCategory: nil.
			self changed: #systemCategoryRoots ]! !
!Browser methodsFor: 'system category functions' stamp: 'len 2/1/2022 19:45:55' prior: 50334325!
   renameSystemCategory
	"Prompt for a new category name and add it before the
	current selection, or at the end if no current selection
	
	21-Mar-2012 jmv Note: This is not recorded appropriately in change sets.
	The easiest solution is to trigger #classRecategorized for all classes in the category.
	But this is not a real solution, as the resulting changeset would not do a rename,
	but create a new category (that would go to the bottom) with all the classes.
	
	In the meantime, disable the menu entry. This is not so important after all.
	"
	| oldName newName |
	selectedSystemCategory ifNil: [^ self].  "no selection"
	oldName _ selectedSystemCategory.
	newName _ self
		request: 'New category name?'
		initialAnswer: oldName
		verifying: [:aString| aString notEmpty and: [aString ~= oldName]]
		do: [:aString|
			newName _ aString asSymbol.
			"If it's a top category, rename subcategories first:"
			(oldName includes: $-) ifFalse:
				[(systemOrganizer categoriesMatching: oldName, '-*')
					do: [:each| systemOrganizer renameCategory: each to: newName, (each allButFirst: oldName size)]].
			systemOrganizer renameCategory: oldName to: newName.
			self setSelectedSystemCategory: newName.
			self changed: #systemCategoryRoots]! !
!SystemCategoryWrapper methodsFor: 'accessing' stamp: 'len 2/1/2022 19:50:41' prior: 50334037 overrides: 16881049!
                    contents
	| prefix subcategories |
	(item includes: $-) ifTrue: [^ #()].
	prefix _ item, '-'.
	subcategories _ OrderedCollection new.
	model systemCategoryList do: [:each|
		(each beginsWith: prefix)
			ifTrue: [subcategories add: (each allButFirst: prefix size)]].
	^ subcategories collect: [:each| self class with: prefix, each name: each model: model]! !

ClassOrganizer removeSelector: #renameCategory:toBe:!

!methodRemoval: ClassOrganizer #renameCategory:toBe: stamp: 'Install-5057-FixRenameAndRemoveSystemCategory-LucianoEstebanNotarfrancesco-2022Feb01-19h20m-len.001.cs.st 2/21/2022 14:50:20'!
renameCategory: oldCatString toBe: newCatString

	| newCategory oldElementsBefore oldElementsAfter |
	
	newCategory _ newCatString withBlanksTrimmed.
	oldElementsBefore _ self listAtCategoryNamed: oldCatString.
	SystemChangeNotifier uniqueInstance doSilently: [
		super renameCategory: oldCatString toBe: newCatString].
	
	oldElementsAfter _ (self listAtCategoryNamed: oldCatString) asSet.
	oldElementsBefore do: [:each | (oldElementsAfter includes: each)
		ifFalse: [self notifyOfChangedSelector: each from: oldCatString to: newCategory]].
	
	self notifyOfChangedCategoryFrom: oldCatString to: newCategory.!

Categorizer removeSelector: #renameCategory:toBe:!

!methodRemoval: Categorizer #renameCategory:toBe: stamp: 'Install-5057-FixRenameAndRemoveSystemCategory-LucianoEstebanNotarfrancesco-2022Feb01-19h20m-len.001.cs.st 2/21/2022 14:50:20'!
renameCategory: oldCatString toBe: newCatString
	"Rename a category. No action if new name already exists, or if old name does not exist."
	
	| index newCategory |
	
	newCategory _ newCatString withBlanksTrimmed.
	"new name exists, so no action"
	(categoryArray indexOf: newCategory) > 0 ifTrue: [^ self].
	
	"old name not found, so no action"
	(index _ categoryArray indexOf: oldCatString) = 0 ifTrue: [^ self].	
	
	"need to change identity so smart list update will notice the change"
	categoryArray _ categoryArray copy.  
	categoryArray at: index put: newCategory!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5057-FixRenameAndRemoveSystemCategory-LucianoEstebanNotarfrancesco-2022Feb01-19h20m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5057] on 2 February 2022 at 5:03:04 pm'!
!Process class methodsFor: 'documentation' stamp: 'jmv 2/2/2022 17:02:55' prior: 16917849!
                          terminateExamples
"
This is the contents of the examples posted by Jaromir to exercise his worn on process termination and exceptions.
It was posted to the Cuis mail list at https://lists.cuis.st/mailman/archives/cuis-dev/2021-May/003171.html
(or maybe, it is a later version of edition of it if this comment is not up to date!!)

Thanks Jaromir for this great contribution!!

Workspace new
		contents: Process terminateExamples;
		openLabel: 'Jaromir Mata''s Process - terminate examples Cuis'.
"
^


'"Process - Cuis terminate examples
Some examples to illustrate the termination bugs and test the proposed rewrite of #terminate
=========================================="
"terminate suspended:"

| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess suspend] ensure: [
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor activeProcess suspend. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"

".......................................
terminate runnable:"

| p |
p := [
	[
		[ ] ensure: [
			[Processor yield] ensure: [
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor yield. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"
".......................................
terminate blocked:"

| p s |
s := Semaphore new.
p := [
	[
		[ ] ensure: [
			[s wait] ensure: [
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"


| p s |
s := Semaphore new.
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				s wait. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3"

".......................................
terminate active:"

| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess terminate] ensure: [
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
"Two yields necessary: terminate active is a two-step procedure"
Processor yield. Processor yield.
Transcript show: p isTerminated printString

"prints x1 x2 x3"


| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor activeProcess terminate. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
"Two yields necessary: terminate active is a two-step procedure"
Processor yield. Processor yield.
Transcript show: p isTerminated printString

"prints x1 x2 x3"



"==========================================
unhandled error:
Termination happens when the user hits Abandon on the Debugger window."
"cf.: prints x1 x2 x3 x4 when hit Proceed"

[
	[ ] ensure: [
		[self error: ''unwind test''] ensure: [
			Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: ''unwind test''.
			Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x2 x3"

"........................
nested unhandled errors:"

| p |
p := [
	[
		[ ] ensure: [
			[self error: ''unwind test outer''] ensure: [
				self error: ''unwind test inner''.
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield.
"prints x1 x2 x3"


"triple nested errors:"

[self error: ''outer error''] ensure: [
    [self error: ''middle error''] ensure: [
        [self error: ''inner error''] ensure: [
            Transcript show: ''x1''].
        Transcript show: ''x2''].
    Transcript show: ''x3''].
Transcript show: ''x4''
"prints x1 x2 x3"
"same result when wrapped in fork"


[] ensure: [
[self error: ''outer error''] ensure: [
    [self error: ''middle error''] ensure: [
        [self error: ''inner error''] ensure: [
            Transcript show: ''x1''].
        Transcript show: ''x2''].
    Transcript show: ''x3''].
Transcript show: ''x4'']
"prints x1 x2 x3 x4"
"same result when wrapped in fork"



"=========================================
error and non-local return combined:"

"Termination happens when the user hits Abandon on the Debugger window."

"........................
non-local return inside inner-most halfway thru unwind block:"

[
	[ ] ensure: [
		[self error: ''unwind test''] ensure: [
			^Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: ''unwind test''. 
			^Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x3"

"........................
non-local return inside outer-most halfway thru unwind block:"

[
	[ ] ensure: [
		[self error: ''unwind test''] ensure: [
			Transcript show: ''x1'']. 
		^Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: ''unwind test''. 
			Transcript show: ''x1'']. 
		^Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''


"prints x1 x2 x3"


"one more level..."
[
	[
		[ ] ensure: [
			[ ] ensure: [
				self error: ''unwind test''. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		^Transcript show: ''x3'']
] ensure: [
	Transcript show: ''x4'']

"prints x1 x2 x3 x4 (even if wrapped in #fork)"



".............................
non-local return outside halfway thru unwind blocks:"

[
	[ ] ensure: [
		[self error: ''unwind test''] ensure: [
			Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	^Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: ''unwind test''. 
			Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	^Transcript show: ''x3''].
Transcript show: ''x4''


"prints x1 x2 x3"


"============================================================
For comparison only:"

"The tests presented here are not affected by the new #terminate.
(A) an unhandled error unwind in the preceding examples followed the new termination logic completing all unwind blocks halfway through their execution
(B) a handled error unwind follows the traditional ''direct'' unwind path using simpler semantics - it doesn''t complete unwind blocks halfway through their execution"

".........................................
handled error:"


[
	[
		[ ] ensure: [
			[self error: ''unwind test''] ensure: [
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3'']
] on: Error do: [].
Transcript show: ''x4''

"prints x1 x3 x4, skips x2"

[
	[
		[ ] ensure: [
			[] ensure: [
				self error: ''unwind test''.
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3'']
] on: Error do: [].
Transcript show: ''x4''

"prints x3 x4, skips x1 x2"

"............................................
nested handled errors:"

| p |
p := [
	[
		[
			[ ] ensure: [
				[self error: ''unwind test outer''] ensure: [
					self error: ''unwind test inner''.
					Transcript show: ''x1'']. 
				Transcript show: ''x2'']
		] ensure: [
			Transcript show: ''x3'']
	] on: Error do: [].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield. Processor yield.

"prints x3 x4, skips x1 x2"



"............................................
non-local return:"

"Similarly a simple non-local return execution follows a ''direct'' unwind path logic in #resume[:through:] using simpler semantics."

[
	[ ] ensure: [
		[^1] ensure: [
			Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x3, skips x2"


[
	[ ] ensure: [
		[] ensure: [
			^Transcript show: ''x1'']. 
		Transcript show: ''x2'']
] ensure: [
	Transcript show: ''x3''].
Transcript show: ''x4''

"prints x1 x3, skips x2"



"==========================================
Crazies:"

"These tests explore new #teminate behavior under more extreme circumstances.
Unwind after active process termination"

[ ] ensure: [
	[Processor activeProcess terminate] ensure: [Transcript show: ''x1'']. 
	Transcript show: ''x2''
	]
"prints x1 x2 and terminates UI - recoverable via Alt+. or cmd+."


"Unwind after active process suspension during termination:"

| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess suspend] ensure: [
				Processor activeProcess suspend. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3'']
] newProcess.
p resume.
Processor yield.
p terminate
"suspends UI and prints x1 x2 x3 after Alt+. recovery"


"Unwind after double active process termination:"

| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess terminate] ensure: [
				Processor activeProcess terminate. 
				Transcript show: ''x1'']. 
			Transcript show: ''x2'']
	] ensure: [
		Transcript show: ''x3''].
	Transcript show: ''x4''
] newProcess.
p resume.
Processor yield. Processor yield. Processor yield. Processor yield.
Transcript show: p isTerminated printString
"lets UI live and prints x1 x2 x3"


| p |
p := [
	[] ensure: [ 
		Processor activeProcess terminate. Transcript show: ''x1''. 
		Processor activeProcess terminate. Transcript show: ''x2'']. 
] newProcess.
p resume.
Processor yield. Processor yield. Processor yield. Processor yield.
Transcript show: p isTerminated printString
"lets current UI live and prints x1 x2"


| p ap |
p := [
	[ ap := Processor activeProcess. ap terminate. Transcript show: ''x1'' ] 
		ensure: [ ap terminate. Transcript show: ''x2'' ]. 
] newProcess.
p resume.
Processor yield. Processor yield. Processor yield.
Transcript show: p isTerminated printString
"lets current UI live and prints x2"


| p |
p := [
	[ Processor activeProcess terminate ] 
		ensure: [ Processor activeProcess terminate ]. 
] newProcess.
p resume.
Processor yield. Processor yield. Processor yield. 
Transcript show: p isTerminated printString
"answers true, no error"



"Unwind after active process termination combined with non-local return:"

| p |
p := [
	[] ensure: [ 
		Processor activeProcess terminate. Transcript show: ''x1''. 
		true ifTrue: [^2]. 
		Processor activeProcess terminate. Transcript show: ''x2'']
] newProcess.
p resume.
Processor yield. Processor yield. 
Transcript show: p isTerminated printString
"prints x1 and correctly raises BlockCannotReturn error"


"Unwind after BlockCannotReturn error:"

| p a |

a := Array new: 4 withAll: false.
p := [
         [
        	[ ] ensure: [
        			[Processor activeProcess suspend] ensure: [
            			^a at: 1 put: true].
        			a at: 2 put: true]
		] ensure: [a at: 3 put: true].
		a at: 4 put: true
    ] newProcess.
p resume.
Processor yield.
"make sure p is suspended and none of the unwind blocks has finished yet"
self assert: p isSuspended.
a noneSatisfy: [ :b | b ].
"now terminate the process and make sure all unwind blocks have finished"
p terminate.
self assert: p isTerminated.
self assert: a first & a third.
self assert: (a second | a fourth) not.
"--->   #(true false true false) ...OK"


"Triple nested active process terminate:"

[	x := ''''.
	[Processor activeProcess terminate] ensure: [
	    [Processor activeProcess terminate] ensure: [
	        [Processor activeProcess terminate] ensure: [
	            x:=x,''3''].
	        x:=x,''2''].
	    x:=x,''1''].
	x:=x,''0''
] fork
x
"---> ''321'' ...OK"

"Same as before but without fork:"

x := ''''.
[Processor activeProcess terminate] ensure: [
    [Processor activeProcess terminate] ensure: [
        [Processor activeProcess terminate] ensure: [
            x:=x,''3''].
        x:=x,''2''].
    x:=x,''1''].
x:=x,''0''
x
"terminates UI and answers ---> ''321'' after Alt+. recovery"
"(Squeak crashes irrecoverably)"


"Triple nested active process terminate:"

p := 
[	x := ''''.
	[] ensure: [
		[Processor activeProcess suspend] ensure: [
		    [Processor activeProcess suspend] ensure: [
		        [Processor activeProcess suspend] ensure: [
		            x:=x,''3''].
		        x:=x,''2''].
		    x:=x,''1''].
		x:=x,''0'']
] newProcess resume.
Processor yield.
p terminate
x   
"Cuis suspends UI repeatedly but answers ---> ''3210'' after repeated Alt+. recovery
Squeak answers ---> ''3210'' without suspending UI - why the difference?
Without fork Squeak suspends UI just once but Cuis 3 times, both answer x correctly"


"These behave as expected and won''t crash the image even after proceeding the BlockCannotReturn error:"

[^2] fork

[[self error: ''error''] ensure: [^2]] fork

"do-it:"
"Both statements need to be executed separately in a Workspace"
a := [true ifTrue: [^ 1] yourself]
[a value] on: BlockCannotReturn do: [:ex | ex resume]

"do-it:"
"Both statements need to be executed separately in a Workspace"
a := [true ifTrue: [^ 1]. 2]
a value

"These will deal with MessageNotUnderstood correctly and won''t crash the image or loop infinitely"

[] ensure: [self gotcha. Transcript show: ''0'']

[] ensure: [[self gotcha] ensure: [self halt. Transcript show: ''0'']]

[self error: ''error''] ensure: [[self gotcha] ensure: [Transcript show: ''0'']]

[self error: ''error''] ensure: [self gotcha. Transcript show: ''0'']

"This one freezes UI after Halt -> Proceed but recoverable via Alt+."
[[] ensure: [[self gotcha] ensure: [self halt. Transcript show: ''0'']]] fork.



"===============
Some additional unsorted examples:"

"This example should show both ZeroDivide and MessageNotUnderstood errors"

x1 := x2 := x3 := nil.
p:=[
		[
			[ ] ensure: [ "halfway through completion when suspended"
				[ ] ensure: [ "halfway through completion when suspended"
					Processor activeProcess suspend. 
					x1 := (2 / 0  "error!!") > 0]. 
				x2 := true]
		] ensure: [ "not started yet when suspended"
			x3 := true]
] newProcess resume.
Processor yield.
p terminate
{x1 . x2 . x3} --->  #(MessageNotUnderstood: ZeroDivide>>> true true) 


'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5058-terminateExamples-fixFormat-JuanVuletich-2022Feb02-16h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5058] on 2 February 2022 at 7:20:43 pm'!
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 2/2/2022 19:18:58'!
                               newUIProcessIfNeeded
	"Answer is not nil only if a new process was created."

	UIProcess ifNotNil: [ :oldUIProcess |
		oldUIProcess isTerminated ifTrue: [
			oldUIProcess 	animatedUI ifNotNil: [ :guiRootObject |
				self spawnNewMorphicProcessFor: guiRootObject.
				^UIProcess ]]].
	^nil! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jmv 2/2/2022 17:15:10' prior: 16953292!
                              handleUserInterrupt
	| p |
	"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
	p _ UISupervisor newUIProcessIfNeeded.
	p ifNil: [
		p _ Sensor shiftPressed | Preferences cmdDotInterruptTakesStatistics
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	Preferences cmdDotEnabled ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		p == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(p name beginsWith: '[system]') ifTrue: [
			 ('Process {', p printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			p isTerminated
				ifTrue: [ ('Process {', p printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [ UISupervisor userInterrupt: p ]] fork
		]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5059-UserInterruptCreatesUIProcessIfNone-JuanVuletich-2022Feb02-19h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5059] on 4 February 2022 at 5:00:17 pm'!
!SystemOrganizer methodsFor: 'categories' stamp: 'len 2/4/2022 05:52:38'!
                             allClassesAt: aCategoryName
	"Same as >>classesAt: but if aCategoryName is a top category it includes all classes in subcategories."
	^ (self fullListAtCategoryNamed: aCategoryName) collect: [:aClassName | Smalltalk classNamed: aClassName]! !
!SystemOrganizer methodsFor: 'categories' stamp: 'len 2/4/2022 04:47:04' overrides: 16801145!
               classesAt: aCategoryName
	^ (self listAtCategoryNamed: aCategoryName) collect: [:aClassName | Smalltalk classNamed: aClassName]! !
!SystemOrganizer methodsFor: 'categories' stamp: 'len 2/4/2022 05:44:37'!
                   fullListAtCategoryNamed: aCategoryName
	"Same as >>listAtCategoryNamed: but include subcategories if aCategoryName is a top category."
	| answer |
	answer _ self listAtCategoryNamed: aCategoryName.
	"If it's a top category, include the classes of all its subcategories:"
	(aCategoryName includes: $-) ifFalse:
		[| prefix |
		prefix _ aCategoryName, '-'.
		self categories do: [:each| (each beginsWith: prefix) ifTrue: [answer _ answer, (self listAtCategoryNamed: each)]]].
	^ answer! !
!SystemOrganizer methodsFor: 'categories' stamp: 'HAW 2/4/2022 16:54:25' overrides: 16801152!
                           testCaseClassesAt: aCategoryName

	^(self classesAt: aCategoryName) select: [ :aClass | aClass is: #TestCaseClass ]! !
!Browser methodsFor: 'class list' stamp: 'len 2/4/2022 05:45:07' prior: 50334905!
                       defaultClassList
	"Answer an array of the class names of the selected category. Answer an 
	empty array if no selection exists."
	selectedSystemCategory ifNil: [^ #()].
	^ systemOrganizer fullListAtCategoryNamed: selectedSystemCategory! !
!SystemOrganizer methodsFor: 'source code management' stamp: 'HAW 10/13/2021 09:31:11' prior: 16958859!
         classMethodCountOf: category

	^  (self classesAt: category) sum: [ :cl | cl class selectors size ] ifEmpty: 0.! !
!SystemOrganizer methodsFor: 'source code management' stamp: 'HAW 10/13/2021 09:31:23' prior: 16958866!
     instanceMethodCountOf: category

	^ (self classesAt: category) sum: [ :cl | cl selectors size ] ifEmpty: 0.! !
!SystemOrganizer methodsFor: 'source code management' stamp: 'HAW 10/13/2021 09:31:30' prior: 16958873!
         linesOfCodeOf: category
"
SystemOrganization linesOfCodeOf: #'System-Files'
"
	"An approximate measure of lines of.
	Includes comments, but excludes blank lines."

	^ (self classesAt: category) sum: [ :cl | cl linesOfCode ] ifEmpty: 0.! !
!TestSuite class methodsFor: 'instance creation' stamp: 'HAW 2/4/2022 16:59:36' prior: 16963311!
                forSystemCategoryNamed: aCategoryName  using: aSystemOrganizer

	| testCaseClasses |

	testCaseClasses _ aSystemOrganizer testCaseClassesAt: aCategoryName.

	^ testCaseClasses isEmpty 
		ifTrue: [ self forClasses: (aSystemOrganizer allClassesAt: aCategoryName) named: aCategoryName, ' infered tests' ]
		ifFalse: [ self forTestCaseClasses: testCaseClasses named: aCategoryName, ' tests' ]
		
! !

Categorizer removeSelector: #testCaseClassesAt:!

!methodRemoval: Categorizer #testCaseClassesAt: stamp: 'Install-5060-FixRunningTestsOnTopSystemCategories-LucianoEstebanNotarfrancesco+HernanWilkinson-2022Feb04-16h47m-HAW.001.cs.st 2/21/2022 14:50:20'!
testCaseClassesAt: aCategoryName

	^(self classesAt: aCategoryName) select: [ :aClass | aClass is: #TestCaseClass ]!

Categorizer removeSelector: #classesAt:!

!methodRemoval: Categorizer #classesAt: stamp: 'Install-5060-FixRunningTestsOnTopSystemCategories-LucianoEstebanNotarfrancesco+HernanWilkinson-2022Feb04-16h47m-HAW.001.cs.st 2/21/2022 14:50:20'!
classesAt: aCategoryName

	^(self listAtCategoryNamed: aCategoryName) collect: [:aClassName | Smalltalk classNamed: aClassName ]
		!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5060-FixRunningTestsOnTopSystemCategories-LucianoEstebanNotarfrancesco+HernanWilkinson-2022Feb04-16h47m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5060] on 4 February 2022 at 6:11:13 pm'!
!TestSuite class methodsFor: 'instance creation' stamp: 'HAW 2/4/2022 16:59:36' prior: 50335854!
                forSystemCategoryNamed: aCategoryName  using: aSystemOrganizer

	| testCaseClasses |

	testCaseClasses _ aSystemOrganizer testCaseClassesAt: aCategoryName.

	^ testCaseClasses isEmpty 
		ifTrue: [ self forClasses: (aSystemOrganizer allClassesAt: aCategoryName) named: aCategoryName, ' infered tests' ]
		ifFalse: [ self forTestCaseClasses: testCaseClasses named: aCategoryName, ' tests' ]
		
! !
!TestSuite class methodsFor: 'instance creation - private' stamp: 'HAW 2/4/2022 18:06:52' prior: 16963350!
         forClasses: classes named: aName

	| testMethods suite classTests tests testPrintString |
	
	"I don't want repeated tests. TestCase does not redefine #= so instead of redefining it and use a Set
	I decided to keep the related tests methods in a different set and decide to add it or note base on that
	- Hernan"
	
	testMethods := Set new.
	tests := OrderedCollection new.
	
	classes do: [ :aClass |
		classTests := (self forClass: aClass) tests.
		classTests do: [ :aTest | 
				testPrintString := aTest printString.
				(testMethods includes: testPrintString) ifFalse: [ 
					testMethods add: testPrintString.
					tests add: aTest ]]].
		
	suite := self named: aName.
	suite addTests: tests.
	
	^suite
		
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5061-FindingTests-HernanWilkinson-2022Feb04-17h03m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5061] on 4 February 2022 at 6:35:06 pm'!
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/4/2022 18:33:36' prior: 16940776!
                             testSuiteForCategoryOf: aClass

	^TestSuite forSystemCategoryNamed: self codeProvider selectedSystemCategory using: SystemOrganization 
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5062-cmd+yFixWhenOnTopSystemCategory-HernanWilkinson-2022Feb04-18h33m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5062] on 7 February 2022 at 11:18:53 am'!
!Browser methodsFor: 'self-updating' stamp: 'len 2/5/2022 05:17:22' overrides: 16821313!
                               updateIfNeeded
	super updateIfNeeded.
	self changed: #systemCategoryRoots! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5063-updateSystemCategoriesWhenLoadingPackage-LucianoEstebanNotarfrancesco-2022Feb07-11h17m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5062] on 7 February 2022 at 11:23:53 am'!
!BrowserWindow methodsFor: 'GUI building' stamp: 'len 2/4/2022 04:23:29' prior: 50334569!
       buildMorphicWindow
	"Create a pluggable version of all the morphs for a Browser in Morphic"

	| upperPanes messageCatList messageList systemCatList classList |

	systemCatList _ self buildMorphicSystemCategoryList.
	classList _ self buildMorphicClassList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	classList rightSibling: messageCatList.
	messageCatList leftSibling: classList rightSibling: messageList.
	messageList leftSibling: messageCatList.
	
"	classList makeItemsDraggable.
	systemCatList 
		acceptDropsFrom: classList 
		performing: #categorizeUnderCategoryAt:class:
		whenOutsideList: #categorizeUnderNewCategoryClass:.
"		
	messageList makeItemsDraggable.
	messageCatList 
		acceptDropsFrom: messageList 
		performing: #categorizeUnderCategoryAt:selector: 
		whenOutsideList: #categorizeUnderNewCategorySelector:.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: systemCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: (self buildMorphicClassColumnWith: classList) proportionalWidth: 0.2;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.2;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5064-BrowserWindowDNUFix-LucianoEstebanNotarfrancesco-2022Feb07-11h18m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5064] on 8 February 2022 at 9:29:26 am'!
!WorldMorph methodsFor: 'world menu' stamp: 'MM 2/8/2022 09:25:39' prior: 16982796!
                             findAWindowSatisfying: qualifyingBlock orMakeOneUsing: makeBlock
	"Locate a window satisfying a block, open it, and bring it to the front.  Create one if necessary, by using the makeBlock"
	| aWindow |
	submorphs do: [ :aMorph |
		(((aWindow _ aMorph) is: #SystemWindow) and: [ qualifyingBlock value: aWindow ]) ifTrue: [
			aWindow isCollapsed ifTrue: [ aWindow expand ].
			aWindow activateAndForceLabelToShow.
			^ aWindow ]].
	"None found, so create one"
	^ makeBlock value.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5065-ReturnFoundWindows-MarianoMontone-2022Feb08-09h25m-MM.001.cs.st----!

'From Cuis 6.0 [latest update: #5065] on 8 February 2022 at 2:36:26 pm'!
!CodePackageFile methodsFor: 'accessing' stamp: 'HAW 2/8/2022 14:35:17' prior: 16819729 overrides: 16817357!
     description
	^String streamContents: [ :s |
		s nextPutAll: 'Code Package File: '.
		s nextPutAll: self fullName; newLine; newLine.
		s nextPutAll: 'Provides: '.
		self provides printDetailsOn: s.
		s newLine.
		self requires ifNotEmpty: [ :requirements | 
			s nextPutAll: 'Requires: '.
			(requirements sorted: [:a :b | a name < b name]) do: [ :req |
				s newLine; space.
				req printDetailsOn: s ].
			s newLine ].
		s newLine.
		sourceSystem isEmpty ifFalse:[
			s nextPutAll: sourceSystem; newLine; newLine ]
	]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5066-CodePackageFile description-HernanWilkinson-2022Feb08-14h27m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5062] on 9 February 2022 at 11:02:38 am'!
!TheWorldMenu class methodsFor: 'help menu' stamp: 'HAW 2/9/2022 11:00:10'!
                  helpMenuOptions
	
	^ `{
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		10.
				#label 			-> 		'About this System...'.
				#object 			-> 		Smalltalk.
				#selector 		-> 		#aboutThisSystem.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'current version information.'
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		20.
				#label 			-> 		'Terse Guide to Cuis'.
				#selector 		-> 		#openTerseGuide.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'explore Cuis Smalltalk'
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		30.
				#label 			-> 		'Class Comment Browser'.
				#selector 		-> 		#openCommentGuide.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'search & explore Cuis Class Comments'
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		40.
				#label 			-> 		'Code management in Cuis'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCodeManagementInCuis.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'Features are kept in Packages.'
			} asDictionary.
			{
				#itemGroup 	-> 		10.
				#itemOrder 		-> 		50.
				#label 			-> 		'Using GitHub to host Cuis packages'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openCuisAndGitHub.
				#icon 			->			#helpIcon.
				#balloonText 	-> 		'GitHub usage pattern.'
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		10.
				#label 			-> 		'Editor keyboard shortcuts'.
				#object 			-> 		SmalltalkEditor.
				#selector 		-> 		#openHelp.
				#icon 			-> 		#keyboardShortcutsIcon.
				#balloonText 	-> 		'summary of keyboard shortcuts in editors for Smalltalk code.'
			} asDictionary.
			{
				#itemGroup 	-> 		20.
				#itemOrder 		-> 		20.
				#label 			-> 		'Useful Expressions'.
				#object 			-> 		Utilities.
				#selector 		-> 		#openUsefulExpressions.
				#icon 			-> 		#chatIcon.
				#balloonText 	-> 		'a window full of useful expressions.'
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		10.
				#label 			-> 		'VM Statistics'.
				#selector 		-> 		#vmStatistics.
				#icon 			-> 		#systemMonitorIcon.
				#balloonText 	-> 		'obtain some intriguing data about the vm.'
			} asDictionary.
			{
				#itemGroup 	-> 		30.
				#itemOrder 		-> 		20.
				#label 			-> 		'Space Left'.
				#selector 		-> 		#garbageCollect.
				#icon 			-> 		#removableMediaIcon.
				#balloonText 	-> 		'perform a full garbage-collection and report how many bytes of space remain in the image.'
			} asDictionary.
		}`! !
!TheWorldMenu methodsFor: 'construction' stamp: 'HAW 2/9/2022 11:00:35' prior: 16970015!
                              helpMenu
	"Build the help menu for the world."

	^ DynamicMenuBuilder buildTitled: 'Help...' targeting: self collectingMenuOptionsWith: #helpMenuOptions.
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5067-HelpMenuMadeDynamic-HernanWilkinson-2022Feb09-10h50m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5067] on 21 February 2022 at 12:19:35 pm'!
!Feature class methodsFor: 'convenience' stamp: 'jmv 2/21/2022 12:04:19' prior: 16853099!
                       require: featureNameOrFilename
	"
	Answer whether the request is fulfilled.
	Feature require: 'StyledTextInstaller'
	Feature require: 'Sound'
	Feature require: 'Tests'
	"
	| req ext fileEntry |
	ext _ '.pck.st'.
	((featureNameOrFilename endsWith: ext) and: [
				fileEntry _ featureNameOrFilename asFileEntry.
				fileEntry exists ])
		ifTrue: [
			req _ FeatureRequirement name: (fileEntry name withoutSuffix: ext).
			req pathName: fileEntry pathName.
			]
		ifFalse: [ req _ FeatureRequirement name: featureNameOrFilename ].
	req isAlreadySatisfied ifFalse: [
		req require ].
	^req isAlreadySatisfied! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5068-require-answerSuccess-JuanVuletich-2022Feb21-12h18m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5067] on 21 February 2022 at 12:25:58 pm'!
!FontFamily class methodsFor: 'file read write' stamp: 'jmv 2/21/2022 12:21:16' prior: 50332701!
               readAdditionalTrueTypeFonts
	(Feature require: 'VectorGraphics') ifTrue: [
		(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
			Feature require: 'VectorEngineInSmalltalk' ].
		UISupervisor whenUIinSafeState: [
			Smalltalk at: #TrueTypeFontFamily ifPresent: [ :cls | cls readAdditionalFonts ]]].! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 2/21/2022 12:22:03' prior: 50332714!
            promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| selectedNameOrDirectory fontFamily |
	selectedNameOrDirectory _ self promptUserFolders.
	selectedNameOrDirectory isNil ifTrue: [ ^nil ].
	(FontFamily familyNamed: selectedNameOrDirectory)
		ifNotNil: [ :it | ^Preferences setDefaultFont: it familyName ].
	(Feature require: 'VectorGraphics') ifTrue: [
		(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
			Feature require: 'VectorEngineInSmalltalk' ].
		UISupervisor whenUIinSafeState: [
			fontFamily _ FontFamily availableFamilies values
				detect: [ :any | any folderName = selectedNameOrDirectory name ]
				ifNone: [
					FontFamily familyNamed: ((Smalltalk at: #TrueTypeFontFamily) read: selectedNameOrDirectory) anyOne ].
			Preferences setDefaultFont: fontFamily familyName ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5069-GracefulVectorGraphicsLoadFailure-JuanVuletich-2022Feb21-12h19m-jmv.001.cs.st----!

----QUIT----(21 February 2022 14:50:27) Cuis6.0-5069.image priorSource: 74!

----STARTUP---- (16 May 2022 10:22:18) as C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\Cuis6.0-5069.image!


'From Cuis 6.0 [latest update: #5069] on 21 February 2022 at 4:42:24 pm'!
!Morph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:03:26'!
                     layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	Please make them natural numbers.
	See implementors."

	^self valueOfProperty: #layerNumber ifAbsent: [100]! !
!Morph methodsFor: 'testing' stamp: 'jmv 2/21/2022 16:41:36'!
                         honorsLayerOrder
	"Most morphs don't go through the expense of the needed resorting."

	^false! !
!Morph methodsFor: 'private' stamp: 'jmv 2/21/2022 16:33:14'!
privateFixLayerOrder
	"Ensure that morphs with smaller #layerNumber are above morphs with larger #layerNumber."

	| layerNumbers sortedSubmorphs newIndex |
	self honorsLayerOrder ifFalse: [ ^self ].
	submorphs size < 2 ifTrue: [ ^self ].
	layerNumbers _ Set new.
	submorphs do: [ :m | layerNumbers add: m layerNumber ].
	layerNumbers _ layerNumbers asArray sort.
	sortedSubmorphs _ Array new: submorphs size.
	newIndex _ 1.
	layerNumbers do: [ :layerNumber |
		submorphs withIndexDo: [ :m :i |
			m layerNumber = layerNumber ifTrue: [
				sortedSubmorphs at: newIndex put: m.
				newIndex = i ifFalse: [ m invalidateBounds ].
				newIndex _ newIndex + 1 ]]].
	submorphs _ sortedSubmorphs.! !
!PasteUpMorph methodsFor: 'testing' stamp: 'jmv 2/21/2022 16:16:13' overrides: 50336283!
                   honorsLayerOrder

	^true! !
!StringRequestMorph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:39:20' overrides: 50336274!
   layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be above regular morphs."

	^30! !
!FillInTheBlankMorph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:39:13' overrides: 50336274!
                      layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be above regular morphs."

	^30! !
!HoverHelpMorph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:40:23' overrides: 50336274!
                           layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be on top."

	^10! !
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:38:31' overrides: 50336274!
              layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^20! !
!AutoCompleterMorph methodsFor: 'accessing' stamp: 'jmv 2/21/2022 16:38:39' overrides: 50336274!
                              layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	^20! !
!Morph methodsFor: 'private' stamp: 'jmv 2/21/2022 16:00:38' prior: 50332745!
                 privateAddAllMorphs: aCollection atIndex: index
	"Private. Add aCollection of morphs to the receiver"
	| myWorld itsWorld otherSubmorphs |
	myWorld _ self world.
	otherSubmorphs _ submorphs copyWithoutAll: aCollection.
	(index between: 0 and: otherSubmorphs size)
		ifFalse: [^ self error: 'index out of range'].
	index = 0
		ifTrue:[	submorphs _ aCollection asArray, otherSubmorphs]
		ifFalse:[	index = otherSubmorphs size
			ifTrue:[	submorphs _ otherSubmorphs, aCollection]
			ifFalse:[	submorphs _ otherSubmorphs copyReplaceFrom: index + 1 to: index with: aCollection ]].
	aCollection do: [:m | | itsOwner |
		itsOwner _ m owner.
		itsOwner ifNotNil: [
			itsWorld _ m world.
			(itsWorld == myWorld) ifFalse: [
				itsWorld ifNotNil: [m redrawNeeded]].
			(itsOwner ~~ self) ifTrue: [
				m owner privateRemove: m.
				m owner removedMorph: m ]].
		m privateOwner: self.
		myWorld ifNotNil: [m redrawNeeded].
		(myWorld == itsWorld) ifFalse: [m intoWorld: myWorld].
		itsOwner == self ifFalse: [
			self addedMorph: m.
			m noteNewOwner: self ].
	].
	self privateFixLayerOrder.
	self someSubmorphPositionOrExtentChanged! !
!Morph methodsFor: 'private' stamp: 'jmv 2/21/2022 16:00:42' prior: 50332783!
          privateAddMorph: aMorph atIndex: index position: aPointOrNil

	| oldIndex myWorld itsWorld oldOwner |
	((index >= 1) and: [index <= (submorphs size + 1)])
		ifFalse: [^ self error: 'index out of range'].
	myWorld _ self world.
	oldOwner _ aMorph owner.
	(oldOwner == self and: [(oldIndex _ submorphs indexOf: aMorph) > 0]) ifTrue: [
		"aMorph's position changes within in the submorph chain"
		oldIndex < index ifTrue:[
			"moving aMorph to back"
			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.
			submorphs at: index-1 put: aMorph.
		] ifFalse:[
			"moving aMorph to front"
			oldIndex-1 to: index by: -1 do:[:i|
				submorphs at: i+1 put: (submorphs at: i)].
			submorphs at: index put: aMorph.
		].
		aPointOrNil ifNotNil: [aMorph privatePosition: aPointOrNil].
	] ifFalse: [
		"adding a new morph"
		oldOwner ifNotNil: [
			itsWorld _ aMorph world.
			itsWorld ifNotNil: [aMorph invalidateBounds].
			oldOwner privateRemove: aMorph.
			oldOwner removedMorph: aMorph.
		].
		aMorph privateOwner: self.
		submorphs _ submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).
		aPointOrNil ifNotNil: [aMorph privatePosition: aPointOrNil].
		(itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].
	].
	myWorld ifNotNil: [
		index = 1
			ifTrue: [aMorph redrawNeeded ]
			ifFalse: [aMorph invalidateBounds]].
	self privateFixLayerOrder.
	self someSubmorphPositionOrExtentChanged.
	oldOwner == self ifFalse: [
		self addedMorph: aMorph.
		aMorph noteNewOwner: self ]! !
!Morph methodsFor: 'private' stamp: 'jmv 2/21/2022 16:00:45' prior: 16895395!
                           privateMoveBackMorph: aMorph

	| oldIndex myWorld index |
	myWorld _ self world.
	"aMorph's position changes within in the submorph chain"
	"moving aMorph to front"
	oldIndex _ submorphs indexOf: aMorph.
	"moving aMorph to back"
	index _ submorphs size.
	submorphs replaceFrom: oldIndex to: index-1 with: submorphs startingAt: oldIndex+1.
	submorphs at: index put: aMorph.
	myWorld ifNotNil: [aMorph redrawNeeded].
	self privateFixLayerOrder.
	self someSubmorphPositionOrExtentChanged.! !
!Morph methodsFor: 'private' stamp: 'jmv 2/21/2022 16:00:48' prior: 16895413!
         privateMoveFrontMorph: aMorph

	| oldIndex myWorld |
	myWorld _ self world.
	"aMorph's position changes within in the submorph chain"
	"moving aMorph to front"
	oldIndex _ submorphs indexOf: aMorph.
	oldIndex-1 to: 1 by: -1 do: [ :i |
		submorphs at: i+1 put: (submorphs at: i)].
	submorphs at: 1 put: aMorph.
	myWorld ifNotNil: [aMorph redrawNeeded].
	self privateFixLayerOrder.
	self someSubmorphPositionOrExtentChanged.! !

AutoCompleterMorph removeSelector: #wantsToBeOnTop!

!methodRemoval: AutoCompleterMorph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ true!

MenuMorph removeSelector: #wantsToBeOnTop!

!methodRemoval: MenuMorph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ stayUp not!

HoverHelpMorph removeSelector: #wantsToBeOnTop!

!methodRemoval: HoverHelpMorph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ true!

FillInTheBlankMorph removeSelector: #wantsToBeOnTop!

!methodRemoval: FillInTheBlankMorph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ true!

StringRequestMorph removeSelector: #wantsToBeOnTop!

!methodRemoval: StringRequestMorph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ true!

Morph removeSelector: #wantsToBeOnTop:!

!methodRemoval: Morph #wantsToBeOnTop: stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop: aBoolean
	"If true, will be above all siblings who don't."

	self privateFlagAt: 6 put: aBoolean.!

Morph removeSelector: #wantsToBeOnTop!

!methodRemoval: Morph #wantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
wantsToBeOnTop
	"If true, will be above all siblings who don't."

	^ self privateFlagAt: 6.!

Morph removeSelector: #privateArrangeWantsToBeOnTop!

!methodRemoval: Morph #privateArrangeWantsToBeOnTop stamp: 'Install-5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st 5/16/2022 10:22:22'!
privateArrangeWantsToBeOnTop
	"Ensure that all morphs who #wantsToBeOnTop (i.e. toppers) are above all morphs who not #wantsToBeOnTop.
	Do it without reordering these two subsets.
	Do it in a single pass, and exit as soon as possible."

	| firstMisplacedTopperIndex firstNonTopperIndex topper nonTopper |
	submorphs size < 2 ifTrue: [ ^self ].
	firstMisplacedTopperIndex _ 0.
	firstNonTopperIndex _ 1.
	[
		"Look for next."
		[ (submorphs at: firstNonTopperIndex) wantsToBeOnTop ] whileTrue: [
			firstNonTopperIndex _ firstNonTopperIndex + 1.
			firstNonTopperIndex = submorphs size ifTrue: [
				"All toppers until the end (at most, one non topper as last). Nothing else to do."
				^self ]].
		firstMisplacedTopperIndex _ firstMisplacedTopperIndex max: firstNonTopperIndex+1.
		[ (submorphs at: firstMisplacedTopperIndex) wantsToBeOnTop not ] whileTrue: [
			firstMisplacedTopperIndex _ firstMisplacedTopperIndex + 1.
			firstMisplacedTopperIndex > submorphs size ifTrue: [
				"No more toppers until the end. Nothing else to do."
				^self ]].

		"We have actually found a misplaced topper. Fix it!!"
		nonTopper _ submorphs at: firstNonTopperIndex.
		topper _ submorphs at: firstMisplacedTopperIndex.
		submorphs at: firstNonTopperIndex put: topper invalidateBounds.
		submorphs at: firstMisplacedTopperIndex put: nonTopper invalidateBounds.
	] repeat.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5070-MorphLayers-JuanVuletich-2022Feb21-15h55m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5069] on 21 February 2022 at 2:32:51 pm'!
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:24:44'!
            largeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences largeFonts
	"

	self defaultFontSize: 18.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:25:01'!
         veryLargeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences veryLargeFonts
	"

	self defaultFontSize: 24.! !
!Preferences class methodsFor: 'fonts' stamp: 'jmv 2/21/2022 14:27:24'!
                  defaultFontSize: pointSize
	"
	Adjust sizes for GUI elements.
	
	Preferences defaultFontSize: 5
	Preferences defaultFontSize: 6
	
	Preferences defaultFontSize: 7
	Preferences defaultFontSize: 9
	Preferences defaultFontSize: 11
	Preferences defaultFontSize: 14
	Preferences defaultFontSize: 18
	Preferences defaultFontSize: 24
	Preferences defaultFontSize: 32
	"
	| font titleFont |
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize..
	self
		setListFontTo: font;
		setMenuFontTo: font;
		setCodeFontTo: font;
		setButtonFontTo: font;
		setSystemFontTo: font.
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	self setWindowTitleFontTo: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	pointSize > 14
		ifTrue: [ Preferences enable: #biggerCursors ]
		ifFalse: [ Preferences disable: #biggerCursors ].
	Cursor defaultCursor activateCursor.
	^font! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:24:37' prior: 16915575!
                            hugeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences hugeFonts
	"

	self defaultFontSize: 32.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:24:48' prior: 16915583!
                           smallFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences smallFonts
	"
	
	self defaultFontSize: 11.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:24:52' prior: 16915591!
                  standardFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences standardFonts
	"

	self defaultFontSize: 14.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:24:57' prior: 16915599!
                   tinyFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences tinyFonts
	"

	self defaultFontSize: 7.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 2/21/2022 14:25:05' prior: 16915615!
                      verySmallFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences verySmallFonts
	"
	
	self defaultFontSize: 9.! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 2/21/2022 13:23:58' prior: 16863485!
                 topLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topLeft corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ `Color white` * gradientTopFactor.
	bottomColor _ `Color white` * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1 max: 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (w - 1 - x @ (w - 1 - y)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 2/21/2022 13:29:28' prior: 16972017!
                        changeFontSizes

	(MenuMorph new defaultTarget: Preferences)
		addTitle: 'Make GUI elements';
		addStayUpIcons;
		add: 'Huge' action: #hugeFonts;
		add: 'Very Large' action: #veryLargeFonts;
		add: 'Large' action: #largeFonts;
		add: 'Regular Size' action: #standardFonts;
		add: 'Small' action: #smallFonts;
		add: 'Very Small'action: #verySmallFonts;
		add: 'Tiny'action: #tinyFonts;
		popUpInWorld: self runningWorld! !

Preferences class removeSelector: #defaultFont07!

!methodRemoval: Preferences class #defaultFont07 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont07
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences defaultFont07
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 7)
			(setMenuFontTo: 8)
			(setWindowTitleFontTo: 9)
			(setCodeFontTo: 7)
			(setButtonFontTo: 7)
			(setSystemFontTo: 8)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont08!

!methodRemoval: Preferences class #defaultFont08 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont08
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences defaultFont08
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 8)
			(setMenuFontTo: 9)
			(setWindowTitleFontTo: 10)
			(setCodeFontTo: 8)
			(setButtonFontTo: 8)
			(setSystemFontTo: 8)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #veryBigFonts!

!methodRemoval: Preferences class #veryBigFonts stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
veryBigFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences veryBigFonts
	"

	self defaultFont36!

Preferences class removeSelector: #defaultFont17!

!methodRemoval: Preferences class #defaultFont17 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont17
	"Sets not only fonts but other GUI elements
	to fit high resolution or large screens
	Preferences defaultFont17
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 17)
			(setMenuFontTo: 17)
			(setWindowTitleFontTo: 22)
			(setCodeFontTo: 17)
			(setButtonFontTo: 17)
			(setSystemFontTo: 17)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont22!

!methodRemoval: Preferences class #defaultFont22 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont22
	"Sets not only fonts but other GUI elements
	to fit high resolution or large screens
	Preferences defaultFont22
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 22)
			(setMenuFontTo: 22)
			(setWindowTitleFontTo: 28)
			(setCodeFontTo: 22)
			(setButtonFontTo: 22)
			(setSystemFontTo: 22)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont14!

!methodRemoval: Preferences class #defaultFont14 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont14
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont14
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 14)
			(setMenuFontTo: 14)
			(setWindowTitleFontTo: 17)
			(setCodeFontTo: 14)
			(setButtonFontTo: 14)
			(setSystemFontTo: 14)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont46!

!methodRemoval: Preferences class #defaultFont46 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont46
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont46
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 46)
			(setMenuFontTo: 46)
			(setWindowTitleFontTo: 60)
			(setCodeFontTo: 46)
			(setButtonFontTo: 46)
			(setSystemFontTo: 46)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont28!

!methodRemoval: Preferences class #defaultFont28 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont28
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont28
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 28)
			(setMenuFontTo: 28)
			(setWindowTitleFontTo: 36)
			(setCodeFontTo: 28)
			(setButtonFontTo: 28)
			(setSystemFontTo: 28)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont06!

!methodRemoval: Preferences class #defaultFont06 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont06
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences defaultFont06
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 6)
			(setMenuFontTo: 7)
			(setWindowTitleFontTo: 8)
			(setCodeFontTo: 6)
			(setButtonFontTo: 6)
			(setSystemFontTo: 7)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont60!

!methodRemoval: Preferences class #defaultFont60 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont60
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont60
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 60)
			(setMenuFontTo: 60)
			(setWindowTitleFontTo: 80)
			(setCodeFontTo: 60)
			(setButtonFontTo: 60)
			(setSystemFontTo: 60)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont11!

!methodRemoval: Preferences class #defaultFont11 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont11
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont11
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 11)
			(setMenuFontTo: 12)
			(setWindowTitleFontTo: 14)
			(setCodeFontTo: 11)
			(setButtonFontTo: 11)
			(setSystemFontTo: 11)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont12!

!methodRemoval: Preferences class #defaultFont12 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont12
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont12
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 12)
			(setMenuFontTo: 12)
			(setWindowTitleFontTo: 14)
			(setCodeFontTo: 12)
			(setButtonFontTo: 12)
			(setSystemFontTo: 12)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont10!

!methodRemoval: Preferences class #defaultFont10 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont10
	"Sets not only fonts but other GUI elements
	to fit medium resolution or medium size screens
	Preferences defaultFont10
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 10)
			(setMenuFontTo: 11)
			(setWindowTitleFontTo: 12)
			(setCodeFontTo: 10)
			(setButtonFontTo: 10)
			(setSystemFontTo: 10)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #defaultFont05!

!methodRemoval: Preferences class #defaultFont05 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont05
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences defaultFont05
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 5)
			(setMenuFontTo: 6)
			(setWindowTitleFontTo: 7)
			(setCodeFontTo: 5)
			(setButtonFontTo: 5)
			(setSystemFontTo: 6)).
	Preferences disable: #biggerCursors.!

Preferences class removeSelector: #bigFonts!

!methodRemoval: Preferences class #bigFonts stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
bigFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences bigFonts
	"

	self defaultFont22!

Preferences class removeSelector: #defaultFont80!

!methodRemoval: Preferences class #defaultFont80 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont80
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont80
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 80)
			(setMenuFontTo: 80)
			(setWindowTitleFontTo: 80)
			(setCodeFontTo: 80)
			(setButtonFontTo: 80)
			(setSystemFontTo: 80)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont36!

!methodRemoval: Preferences class #defaultFont36 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont36
	"Sets not only fonts but other GUI elements
	to fit very high resolution or very large screens
	Preferences defaultFont36
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 36)
			(setMenuFontTo: 36)
			(setWindowTitleFontTo: 46)
			(setCodeFontTo: 36)
			(setButtonFontTo: 36)
			(setSystemFontTo: 36)).
	Preferences enable: #biggerCursors.!

Preferences class removeSelector: #defaultFont09!

!methodRemoval: Preferences class #defaultFont09 stamp: 'Install-5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st 5/16/2022 10:22:22'!
defaultFont09
	"Sets not only fonts but other GUI elements
	to fit low resolution or small screens
	Preferences defaultFont09
	"

	Preferences
		setDefaultFont: FontFamily defaultFamilyName
		spec: #(
			(setListFontTo: 9)
			(setMenuFontTo: 10)
			(setWindowTitleFontTo: 11)
			(setCodeFontTo: 9)
			(setButtonFontTo: 9)
			(setSystemFontTo: 9)).
	Preferences disable: #biggerCursors.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5071-GUIElementSizes-simplify-JuanVuletich-2022Feb21-14h29m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5071] on 22 February 2022 at 10:02:30 am'!

InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag textComposition editor pauseBlinking acceptOnCR hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex needsFit acceptOn '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #InnerTextMorph category: 'Morphic-Widgets' stamp: 'Install-5072-InnerTextMorph-acceptOn-ivarRename-JuanVuletich-2022Feb22-10h01m-jmv.001.cs.st 5/16/2022 10:22:22'!
InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag textComposition editor pauseBlinking acceptOnCR hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex needsFit acceptOn'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 2/22/2022 10:01:59' prior: 16870378!
      acceptOnCR
	"Answer whether the receiver wants to accept when the Return key is hit"

	^ acceptOn == true! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 2/22/2022 10:01:59' prior: 16870561!
                     processKeystrokeEvent: evt
	| action |

	(acceptOn and: [evt isReturnKey]) ifTrue: [^ self acceptContents].

	self pauseBlinking.
	
	"Return - check for special action"
	evt isReturnKey ifTrue: [	
		action _ self crAction.
		action ifNotNil: [ ^action value]].
	
	"Esc - check for special action"
	evt isEsc ifTrue: [			
		action _ self escAction.
		action ifNotNil: [ ^action value]].
	
	self handleInteraction: [ editor processKeystrokeEvent: evt ].	
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].! !
!InnerTextMorph methodsFor: 'initialization' stamp: 'jmv 2/22/2022 10:01:59' prior: 16870660 overrides: 16794195!
initialize
	super initialize.
	wrapFlag _ true.
	acceptOn _ false.
	hasUnacceptedEdits _ false.
	hasEditingConflicts _ false.
	askBeforeDiscardingEdits _ true.
	needsFit _ false.! !
!InnerTextMorph methodsFor: 'accept/cancel' stamp: 'jmv 2/22/2022 10:01:59' prior: 16870947!
             acceptOnCR: trueOrFalse
	acceptOn _ trueOrFalse! !

InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag textComposition editor pauseBlinking acceptOn hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex needsFit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #InnerTextMorph category: 'Morphic-Widgets' stamp: 'Install-5072-InnerTextMorph-acceptOn-ivarRename-JuanVuletich-2022Feb22-10h01m-jmv.001.cs.st 5/16/2022 10:22:22'!
InnerPluggableMorph subclass: #InnerTextMorph
	instanceVariableNames: 'model wrapFlag textComposition editor pauseBlinking acceptOn hasUnacceptedEdits hasEditingConflicts askBeforeDiscardingEdits styler autoCompleter mutex needsFit'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5072-InnerTextMorph-acceptOn-ivarRename-JuanVuletich-2022Feb22-10h01m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5071] on 22 February 2022 at 10:06:47 am'!
!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 2/22/2022 10:06:21'!
    keystrokeAction: aBlock
	"Sets the action to perform when user presses any key"

	self setProperty: #keyStroke: toValue: aBlock.! !
!TextModelMorph methodsFor: 'initialization' stamp: 'jmv 2/22/2022 09:44:48'!
              keystrokeAction: aBlock
	
	scroller keystrokeAction: aBlock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5073-TextMorph-keystrokeAction-JuanVuletich-2022Feb22-10h02m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5071] on 22 February 2022 at 10:11:26 am'!
!InnerTextMorph methodsFor: 'accept/cancel' stamp: 'jmv 2/22/2022 10:00:47'!
acceptOnAny: aBoolean
	aBoolean
		ifTrue: [ acceptOn _ #any ]
		ifFalse: [
			acceptOn = #any
				ifTrue: [ acceptOn _ #none ]].! !
!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 2/22/2022 10:07:31' prior: 50337095!
     acceptOnCR
	"Answer whether the receiver wants to accept when the Return key is hit"

	^ acceptOn == #enter! !
!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 2/22/2022 10:09:51' prior: 50337102!
                   processKeystrokeEvent: evt
	| action |

	(acceptOn = #enter and: [evt isReturnKey]) ifTrue: [^ self acceptContents].

	self pauseBlinking.
	
	"Return - check for special action"
	evt isReturnKey ifTrue: [	
		action _ self crAction.
		action ifNotNil: [ ^action value]].
	
	"Esc - check for special action"
	evt isEsc ifTrue: [			
		action _ self escAction.
		action ifNotNil: [ ^action value]].
	
	self handleInteraction: [ editor processKeystrokeEvent: evt ].	
	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ].

	acceptOn = #any ifTrue: [self acceptContents].! !
!InnerTextMorph methodsFor: 'initialization' stamp: 'jmv 2/22/2022 10:00:57' prior: 50337122 overrides: 16794195!
      initialize
	super initialize.
	wrapFlag _ true.
	acceptOn _ #none.
	hasUnacceptedEdits _ false.
	hasEditingConflicts _ false.
	askBeforeDiscardingEdits _ true.
	needsFit _ false.! !
!InnerTextMorph methodsFor: 'accept/cancel' stamp: 'jmv 2/22/2022 10:08:16' prior: 50337131!
             acceptOnCR: aBoolean
	aBoolean
		ifTrue: [ acceptOn _ #enter ]
		ifFalse: [
			acceptOn = #enter
				ifTrue: [ acceptOn _ #none ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5074-TextMorph-acceptOnAnyKeystroke-JuanVuletich-2022Feb22-10h06m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5074] on 22 February 2022 at 4:59:29 pm'!
!MenuMorph methodsFor: 'accessing' stamp: 'jmv 2/22/2022 16:57:50' prior: 50336340 overrides: 50336274!
                         layerNumber
	"Morphs with smaller layer number will always cover those with larger ones.
	We want to be rather on top."

	stayUp ifTrue: [ ^super layerNumber ].
	^20! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5075-PinnedMenusDontStayAtFront-JuanVuletich-2022Feb22-16h57m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5075] on 22 February 2022 at 5:19:27 pm'!
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 2/22/2022 17:18:57' prior: 16870457 overrides: 16892224!
                         mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	"If we don't focus, do nothing. Focus will be got at button up."
	self hasKeyboardFocus ifFalse: [
		^self ].

	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.

	self handleInteraction: [ editor mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: #doubleClickAndHalf:localPosition:
		tripleClkSel: nil! !
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 2/22/2022 17:19:14' prior: 16870486 overrides: 16892239!
                     mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	| mouseButton1DownHandled |

	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"
	self hasKeyboardFocus ifFalse: [
		^ aMouseButtonEvent hand newKeyboardFocus: self ].

	self pauseBlinking.

	mouseButton1DownHandled := self 
		valueOfProperty: #mouseButton1Up:localPosition:
		ifPresentDo: [ :handler | handler value: aMouseButtonEvent value: localEventPosition ]
		ifAbsent: [ false ].

	mouseButton1DownHandled ifFalse: [
		self handleInteraction: [ editor mouseButton1Up: aMouseButtonEvent  localPosition: localEventPosition ]].

	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5076-clickToFocus-requireFurtherClickToSetCursor-JuanVuletich-2022Feb22-17h18m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5075] on 22 February 2022 at 5:21:29 pm'!
!InnerTextMorph methodsFor: 'events' stamp: 'jmv 2/22/2022 17:20:38' prior: 50337265 overrides: 16892224!
                mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	"If we don't focus, Get focus, and continue (i.e. position the cursor)"
	self hasKeyboardFocus ifFalse: [
		aMouseButtonEvent hand newKeyboardFocus: self ].

	super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition.

	self handleInteraction: [ editor mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: #doubleClickAndHalf:localPosition:
		tripleClkSel: nil! !
!InnerTextMorph methodsFor: 'events' stamp: 'HAW 11/30/2021 14:54:59' prior: 50337292 overrides: 16892239!
     mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	| mouseButton1DownHandled |

	self pauseBlinking.

	mouseButton1DownHandled := self 
		valueOfProperty: #mouseButton1Up:localPosition:
		ifPresentDo: [ :handler | handler value: aMouseButtonEvent value: localEventPosition ]
		ifAbsent: [ false ].

	mouseButton1DownHandled ifFalse: [
		self handleInteraction: [ editor mouseButton1Up: aMouseButtonEvent  localPosition: localEventPosition ]].

	(owner is: #ScrollPane) ifTrue: [
		owner scrollSelectionIntoView ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5077-clickToFocus-singleClickToFocusAndSetCursor-JuanVuletich-2022Feb22-17h18m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5075] on 23 February 2022 at 9:14:18 am'!
!SmalltalkEditor methodsFor: 'quick action (shift+click)' stamp: 'jmv 2/23/2022 09:03:41' prior: 16941021!
                          quickPrintOfNodeUnder: aMousePosition

	| mousePositionInText |
	
	mousePositionInText := morph positionInTextOf: aMousePosition.

	self 
		withMethodNodeAndClassDo: [ :methodNode :class | 
			methodNode 
				withParseNodeIncluding: mousePositionInText 
				do: [ :aNodeUnderCursor | morph showBalloon: (self hoverHelpToShowEvaluating: aNodeUnderCursor)]
				ifAbsent: [  morph flash  ]]
		ifErrorsParsing: [ :anError | morph showBalloon: anError messageText ]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 09:01:52' prior: 16893953!
                   showBalloon: msgString
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	self showBalloon: msgString hand: nil! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 09:12:43' prior: 16893963!
                       showBalloon: msgString hand: aHand
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| w balloon h |
	w _ self world ifNil: [^ self].
	h _ aHand ifNil: [ w activeHand ].
	balloon _ HoverHelpMorph contents: msgString.
	
	"Do it in a while. In some cases, processing the event that
	might have triggered us might also remove any Help Balloon"
	UISupervisor whenUIinSafeState: [
		balloon popUpForHand: h ].! !

InnerTextMorph removeSelector: #showHoverHelpWith:!

!methodRemoval: InnerTextMorph #showHoverHelpWith: stamp: 'Install-5078-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h01m-jmv.001.cs.st 5/16/2022 10:22:22'!
showHoverHelpWith: msgString 
	
	| w balloon h |
	(w _ self world) ifNil: [^ self].
	h _ w activeHand.
	balloon _ HoverHelpMorph contents: msgString.
	
	"Do it in a while. In some cases, processing the event that might have triggered us might also remove any Help Balloon"
	UISupervisor whenUIinSafeState: [ balloon popUpForHand: h ]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5078-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h01m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5075] on 23 February 2022 at 9:52:32 am'!
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 09:44:22'!
                      showBalloon: msgString hand: aHand doWordWrap: aBoolean
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| w balloon h |
	w _ self world ifNil: [^ self].
	h _ aHand ifNil: [ w activeHand ].
	balloon _ HoverHelpMorph contents: msgString doWordWrap: aBoolean.
	
	"Do it in a while. In some cases, processing the event that
	might have triggered us might also remove any Help Balloon"
	UISupervisor whenUIinSafeState: [
		balloon popUpForHand: h ].! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:48:39'!
             contents: aString doWordWrap: aBoolean
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' doWordWrap: true) openInHand
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' doWordWrap: false) openInHand
	"

	^self new contents: aString wrappedTo: (aBoolean ifTrue: [FontFamily defaultLineSpacing * 13])! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 09:52:20' prior: 50337411!
showBalloon: msgString hand: aHand
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	self showBalloon: msgString hand: aHand doWordWrap: false.! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:47:55' prior: 16868413!
            contents: aString
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph') openInHand
	"

	^ self new contents: aString wrappedTo: nil! !

HoverHelpMorph class removeSelector: #contentsWrapped:!

!methodRemoval: HoverHelpMorph class #contentsWrapped: stamp: 'Install-5079-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h14m-jmv.001.cs.st 5/16/2022 10:22:22'!
contentsWrapped: aString
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contentsWrapped: 'This is a HoverHelpMorph with a rather long contents to see how it gets wrapped. Is this long enough? Maybe a few more words are in order.') openInHand
	"

	^self new contentsWrapped: aString!

HoverHelpMorph removeSelector: #contents:!

!methodRemoval: HoverHelpMorph #contents: stamp: 'Install-5079-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h14m-jmv.001.cs.st 5/16/2022 10:22:22'!
contents: aString

	self contents: aString wrappedTo: nil!

HoverHelpMorph removeSelector: #contents:doWordWrap:!

HoverHelpMorph removeSelector: #contentsWrapped:!

!methodRemoval: HoverHelpMorph #contentsWrapped: stamp: 'Install-5079-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h14m-jmv.001.cs.st 5/16/2022 10:22:22'!
contentsWrapped: aString
	
	self contents: aString wrappedTo: FontFamily defaultLineSpacing * 13!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5079-HoverHelp-cleanup-JuanVuletich-2022Feb23-09h14m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5075] on 23 February 2022 at 9:55:28 am'!
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:54:20' prior: 50337500!
                        contents: aString
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.') openInHand
	"

	^ self contents: aString doWordWrap: true! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:55:05' prior: 50337472!
      contents: aString doWordWrap: aBoolean
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' doWordWrap: true) openInHand
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' doWordWrap: false) openInHand
	"

	^self contents: aString wrappedTo: (aBoolean ifTrue: [FontFamily defaultLineSpacing * 13])! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5080-HoverHelpMorph-contents-doWordWrap-JuanVuletich-2022Feb23-09h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5078] on 23 February 2022 at 10:51:01 am'!
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 10:00:14' prior: 50337453!
       showBalloon: msgStringOrText hand: aHand doWordWrap: aBoolean
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| w balloon h |
	w _ self world ifNil: [^ self].
	h _ aHand ifNil: [ w activeHand ].
	balloon _ HoverHelpMorph contents: msgStringOrText doWordWrap: aBoolean.
	
	"Do it in a while. In some cases, processing the event that
	might have triggered us might also remove any Help Balloon"
	UISupervisor whenUIinSafeState: [
		balloon popUpForHand: h ].! !
!HoverHelpMorph methodsFor: 'accessing' stamp: 'jmv 2/23/2022 09:59:48' prior: 16868333!
                               contents: aStringOrText wrappedTo: wordWrapWidthOrNil
	"If wordWrapWidthOrNil is nil, don't do wordwrap, and make the morph as wide as needed"

	| width |
	contents _ aStringOrText.
	width _ wordWrapWidthOrNil ifNil: [9999999].
	textComposition _ TextComposition new.
	textComposition
		setModel: (TextModel withText: contents asText);
		extentForComposing: 	width@9999999.
	textComposition composeAll.
	self morphExtent: textComposition usedExtent + 8.! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:58:59' prior: 50337552!
                contents: aStringOrText
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.') openInHand
	"

	^ self contents: aStringOrText doWordWrap: true! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 09:59:37' prior: 16868421!
                          contents: aStringOrText wrappedTo: wordWrapWidthOrNil
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather long contents to see how it gets wrapped. Is this long enough? Maybe a few more words are in order.'
		wrappedTo: 150) openInHand
	"

	^self new contents: aStringOrText wrappedTo: wordWrapWidthOrNil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5081-HoverHelpMorph-refactor-JuanVuletich-2022Feb23-10h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5078] on 23 February 2022 at 10:52:53 am'!
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 2/23/2022 10:43:04' prior: 50337490!
  showBalloon: msgStringOrText hand: aHand
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| doWordWrap msg |
	doWordWrap _ true.
	msg _ msgStringOrText.
	msgStringOrText last isLineSeparator ifTrue: [
		doWordWrap _ false.
		msg _ msg allButLast ].
	self
		showBalloon: msg
		hand: aHand
		doWordWrap: doWordWrap.! !
!HoverHelpMorph class methodsFor: 'instance creation' stamp: 'jmv 2/23/2022 10:30:25' prior: 50337563!
 contents: aStringOrText doWordWrap: aBoolean
	"Make up and return a HoverHelp for morph.
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' doWordWrap: true) openInHand
	(HoverHelpMorph contents: 'This is a HoverHelpMorph with a rather largish contents, to show the effect of word wrap.' blue doWordWrap: false) openInHand
	"

	| widthOrNil |
	widthOrNil _ aBoolean ifTrue: [FontFamily defaultLineSpacing * (aStringOrText size sqrt * 1.5 max: 13)].
	^self contents: aStringOrText wrappedTo: widthOrNil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5082-HoverHelp-ActivateWordWrapOnRegularTooltips-JuanVuletich-2022Feb23-10h51m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5078] on 23 February 2022 at 10:53:19 am'!
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 2/23/2022 10:14:03' prior: 16821826!
     optionalButtonTuples
	"Answer a tuple buttons, in the format:
			button label
			selector to send
			help message"

	| aList textConstructor |
	textConstructor _ [ :string :backgroundColor | 
		string asText addAttribute: (TextBackgroundColor color: backgroundColor) ].

	aList _ #(
		(10	'browse'			browseMethodFull							'view this method in a browser')
		(11	'senders' 			browseSendersOfMessages							'browse senders of...' 						browseSendersOfMethod)
		(16	'implementors'			browseMessages							'browse implementors of...' 						browseImplementors)
		(12	'versions'			browseVersions							'browse versions')), 

		(Preferences decorateBrowserButtons
			ifTrue: [
				{{13	. 'inheritance'.	 #methodInheritance. 	'Browse Method Inheritance

', (textConstructor value: 'green' value: `Color green muchLighter`),': sends to super
', (textConstructor value: 'tan' value: `Color tan`), ': has override(s)
', (textConstructor value: 'mauve' value: `Color blue muchLighter`), ': both of the above
', (textConstructor value: 'pink' value: `Color red muchLighter`), ': is an override but doesn''t call super
', (textConstructor value: 'pinkish tan' value: `Color r: 0.94 g: 0.823 b: 0.673`), ': has override(s), also is an override but doesn''t call super
'}}]
			ifFalse: [
				{#(13	'inheritance'		 methodInheritance	 'browse method inheritance')}]),

		#(
		(12	'hierarchy'			browseHierarchy							'browse class hierarchy')
		(10	'inst vars'			browseInstVarRefs							'inst var refs...')
		(11	'class vars'			browseClassVarRefs							'class var refs...')
		(10	'show...'			offerWhatToShowMenu							'menu of what to show in lower pane')).

	^ aList! !
!ChangeSorterWindow methodsFor: 'menu building' stamp: 'jmv 2/23/2022 10:35:35' prior: 16807707!
            changeSetMenu
	"Set up aMenu to hold commands for the change-set-list pane.  This could be for a single or double changeSorter"

	| aMenu isForBaseSystem |
	isForBaseSystem _ model changeSet isForBaseSystem.
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu addTitle: 'Change Set'.
	aMenu addStayUpIcons.

	aMenu add: 'File out and remove (o)' 			action: #fileOutAndRemove 	icon: #fileOutIcon 	enabled: isForBaseSystem.
	aMenu add: 'File out and keep (k)' 				action: #fileOutAndKeep 		icon: #fileOutIcon.
	aMenu addLine.

	aMenu add: 'Rename change set (r)' 			action: #rename 					icon: #saveAsIcon 	enabled: isForBaseSystem.
	aMenu add: 'Destroy change set (x)' 			action: #remove 					icon: #warningIcon 	enabled: isForBaseSystem.
	aMenu addLine.
	model currentCanHavePreambleAndPostscript ifTrue: [
		aMenu addLine.
		model currentHasPreamble
			ifTrue: [
				aMenu add: 'Edit preamble (p)' 		action: #addPreamble 			icon: #textEditorIcon.
				aMenu add: 'Remove preamble' 	action: #removePreamble 		icon: #listRemoveIcon ]
			ifFalse: [
				aMenu add: 'Add preamble (p)' 	action: #addPreamble 			icon: #listAddIcon ].
		model currentHasPostscript
			ifTrue: [
				aMenu add: 'Edit postscript...' 		action: #editPostscript 			icon: #textEditorIcon .
				aMenu add: 'Remove postscript' 	action: #removePostscript 		icon: #listRemoveIcon ]
			ifFalse: [
				aMenu add: 'Add postscript...' 		action: #editPostscript 			icon: #listAddIcon ].
	].
	aMenu addLine.

	"CONFLICTS SECTION"
	(aMenu add: 'conflicts with other change sets' 	target: self 	action: #browseMethodConflicts 	icon: #emblemImportantIcon)
		setBalloonText: 'Browse all methods that occur both in this change set and in at least one other change set.'.
	aMenu addLine.

	"CHECKS SECTION"
	(aMenu add: 'trim history' 						action: #trimHistory 				icon: #clockIcon 		enabled: isForBaseSystem)
		setBalloonText: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.
 NOTE: can cause confusion if later filed in over an earlier version of these changes.'.

	(aMenu add: 'view affected class categories' action: #viewAffectedClassCategories icon: #packageIcon)
		setBalloonText: ' Show class categories affected by any contained change'.

	^ aMenu! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 2/23/2022 10:37:07' prior: 16882518!
           add: aString action: aSymbol icon: symbolOrFormOrNil enabled: aBoolean
	"Append a menu item with the given label. If the item is selected, it will send the given selector to the default target object."
	"Details: Note that the menu item added captures the default target object at the time the item is added; the default target can later be changed before added additional items without affecting the targets of previously added entries. The model is that each entry is like a button that knows everything it needs to perform its action."

	^(self add: aString
		target: defaultTarget
		action: aSymbol
		argumentList: #())
			setIcon: symbolOrFormOrNil;
			isEnabled: aBoolean! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5083-MiscTooltipsTweaks-JuanVuletich-2022Feb23-10h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5083] on 23 February 2022 at 12:48:38 pm'!
!Message methodsFor: 'comparing' stamp: 'eem 11/27/2021 12:27'!
          hasIdenticalContentsAs: aMessage
	"Answer if the argument's selector and arguments are identically equal to those of the receiver.
	 It is assumed that the argument aMessage is, in fact, a message."
       selector ~~ aMessage selector ifTrue:
		[^false].
	1 to: args size do:
		[:i| (args at: i) ~~ (aMessage arguments at: i) ifTrue: [^false]].
	^true! !
!Object methodsFor: 'error handling' stamp: 'eem 11/27/2021 12:55' prior: 16902064 overrides: 16920394!
                    doesNotUnderstand: aMessage 
	 "Handle the fact that there was an attempt to send the given
	  message to the receiver but the receiver does not understand
	  this message (typically sent from the machine when a message
	  is sent to the receiver and no method is defined for that selector).

	 Raise the MessageNotUnderstood signal.  If it is caught, answer
	 the result supplied by the exception handler.  If it is not caught,
	 answer the result of resending the message within a guard for
	 infinite recursion. This allows, for example, the programmer to
	 implement the method and continue."

	"Testing: (3 activeProcess)"

	| exception resumeValue |
	(exception := MessageNotUnderstood new)
		message: aMessage;
		receiver: self.
	resumeValue := exception signal.
	^exception reachedDefaultHandler "i.e. exception was not caught..."
		ifTrue:
			[[aMessage sentTo: self]
				on: MessageNotUnderstood
				do: [:ex|
					(self == ex receiver
					and: [aMessage hasIdenticalContentsAs: ex message]) ifFalse:
						[ex pass].
					self error: 'infinite recursion in doesNotUnderstand:']]
		ifFalse: [resumeValue]! !
!MethodContext methodsFor: 'private' stamp: 'jmv 3/2/2010 17:09' prior: 16888606!
               cannotReturn: result
	closureOrNil ifNotNil: [
		^self cannotReturn: result to: sender].
	Debugger
		openContext: thisContext
		label: 'computation has been terminated'
		contents: nil! !
!Process methodsFor: 'private' stamp: 'jmv 2/23/2022 12:39:44' prior: 16917440!
                    complete: topContext to: aContext 
	"Run topContext on behalf of self on topContext's stack until aContext is popped or an unhandled 
	error is raised. Return self's new top context. Note: topContext must be a stack top context.
	Note: This method is meant to be called primarily by Process>>#terminate."

	| pair top error |
	pair _ topContext runUnwindUntilErrorOrReturnFrom: aContext.
	top _ pair first.
	error _ pair second.
	"If an error was detected jump back to the debugged process and re-signal the error;
	some errors may require a special care - see notes below."
	error ifNotNil: [
		error class == MessageNotUnderstood ifTrue: [error initialize]. "reset reachedDefaultHandler"
		top jump].
	^top

"Note: To prevent an infinite recursion of the MessageNotUnderstood error, reset reachedDefaultHandler before jumping back; this will prevent #doesNotUnderstand: from resending the unknown message."! !

Smalltalk removeClassNamed: #ProceedBlockCannotReturn!

!classRemoval: #ProceedBlockCannotReturn stamp: 'Install-5084-terminateAndFriends-JaromirMatas-EliotMiranda-2022Feb23-12h38m-jmv.001.cs.st 5/16/2022 10:22:23'!
Warning subclass: #ProceedBlockCannotReturn
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions-Kernel'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5084-terminateAndFriends-JaromirMatas-EliotMiranda-2022Feb23-12h38m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5084] on 23 February 2022 at 1:02:23 pm'!
!UISupervisor class methodsFor: 'gui process' stamp: 'jmv 2/23/2022 12:58:56' prior: 50335722!
         newUIProcessIfNeeded
	"Answer is not nil only if a new process was created."

	UIProcess ifNotNil: [ :oldUIProcess |
		oldUIProcess isSuspended ifTrue: [ oldUIProcess terminate ].
		oldUIProcess isTerminated ifTrue: [
			oldUIProcess 	animatedUI ifNotNil: [ :guiRootObject |
				self spawnNewMorphicProcessFor: guiRootObject.
				^UIProcess ]]].
	^nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5085-CmdPeriod-recoversSuspendedUIProcess-JuanVuletich-2022Feb23-12h58m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5084] on 23 February 2022 at 1:09:48 pm'!
!Process methodsFor: 'changing process state' stamp: 'jar 2/22/2022 22:22:22' prior: 50333499!
terminate 
	"Stop the process that the receiver represents forever. Unwind to execute pending ensure: and
	 ifCurtailed: blocks before terminating; allow all unwind blocks to run; if they are currently in
	 progress, let them finish. If the process is in the middle of a #critical: section, release it properly."
	
	"If terminating the active process, create a parallel stack and run unwinds from there;
	 if terminating a suspended process, create a parallel stack for the process being terminated
	 and resume the suspended process to complete its termination from the parallel stack. Use
	 a priority higher than the active priority to make the process that invoked the termination
	 wait for its completion."

	"If terminating a suspended process (including runnable or blocked), always suspend the 
	 terminating process first so it doesn't accidentally get woken up. Equally important is the
	 side effect of the suspension. In 2022 a new suspend semantics has been introduced:
	 the revised #suspend backs up a process waiting on a conditional variable to the send that
	 invoked the wait state, while the pre-2022 #suspend simply removed the process from
	 the conditional variable's list it was previously waiting on; figure out if we are terminating
	 the process while waiting in Semaphore>>critical:. In this case, pop the suspendedContext
	 so that we leave the ensure: block inside Semaphore>>critical: without signaling the semaphore.
	 Execute termination wrapped in #valueEnsured to ensure it completes even if the terminator
	 process itself gets terminated before it's finished; see testTerminateInTerminate."

	| context |
	self isActiveProcess ifTrue: [
		context _ thisContext.
		^[context unwindTo: nil. self suspend] asContext jump].

	[	| oldList |
		oldList _ myList.
		self suspend.
		(oldList class == Semaphore and: [
			suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue: [
				suspendedContext _ suspendedContext home	].
		context _ suspendedContext ifNil: [^self].
		suspendedContext _ [context unwindTo: nil. self suspend] asContext.
		self priority: Processor activePriority + 1; resume
	] valueEnsured! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5086-terminate-JaromirMatas-2022Feb23-13h02m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5086] on 23 February 2022 at 1:15:14 pm'!
!Process class methodsFor: 'documentation' stamp: 'jar 2/3/2022 12:23:58' prior: 50335236!
            terminateExamples
"
This is the contents of the examples posted by Jaromir to exercise his worn on process termination and exceptions.
It was posted to the Cuis mail list at https://lists.cuis.st/mailman/archives/cuis-dev/2021-May/003171.html
(or maybe, it is a later version of edition of it if this comment is not up to date!!)

Thanks Jaromir for this great contribution!!

Workspace new
		contents: Process terminateExamples;
		openLabel: 'Jaromir Matas''s Process - terminate examples Cuis'.
"
^


'"
The following examples illustrate the behavior and semantics of the new #terminate.
"
"
Part 1: terminate a healthy process inside an unwind block
======================================
Show that all pending unwind blocks get executed regardless whether they have already started or not.
"
"
terminate a suspended process:
....................................................
"
| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess suspend] ensure: [
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor activeProcess suspend. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

"
terminate a runnable process:
.................................................
"
| p |
p := [
	[
		[ ] ensure: [
			[Processor yield] ensure: [
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor yield. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

"
terminate a blocked process:
...............................................
"
| p |
p := [
	[
		[ ] ensure: [
			[Semaphore new wait] ensure: [
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Semaphore new wait. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

"
terminate the active process:
................................................
"
| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess terminate] ensure: [
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"

| p |
p := [
	[
		[ ] ensure: [
			[ ] ensure: [
				Processor activeProcess terminate. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString

"prints x1 x2 x3 true"


"
Part 2: terminate a process after encountering an unhandled error inside an unwind block
===========================================================
Show that all unhandled errors inside unwind blocks get caught and all pending unwind blocks get executed as expected.
"
"
Termination happens when you hit Abandon on the Debugger window.
Note: when you hit Proceed the computation will continue normally and will print x1 x2 x3 x4
"
"
one unhandled error scenario:
.................................................
"
[
	[ ] ensure: [
		[self error: #unwind_test] ensure: [
			Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: #unwind_test.
			Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x2 x3"

"
multiple nested unhandled errors:
........................................................
"
[
	[
		[ ] ensure: [
			[self error: #outer_error] ensure: [
				self error: #inner_error.
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] fork

"prints x1 x2 x3"

[
	[
		[self error: #outer_error] ensure: [
			[self error: #middle_error] ensure: [
				self error: #inner_error.
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] fork
"prints x1 x2 x3"


[self error: #outer_error] ensure: [
    [self error: #middle_error] ensure: [
        [self error: #inner_error] ensure: [
            Transcript show: #x1].
        Transcript show: #x2].
    Transcript show: #x3].
Transcript show: #x4
"prints x1 x2 x3"
"same result when wrapped in fork"


[] ensure: [
[self error: #outer_error] ensure: [
    [self error: #middle_error] ensure: [
        [self error: #inner_error] ensure: [
            Transcript show: #x1].
        Transcript show: #x2].
    Transcript show: #x3].
Transcript show: #x4]
"prints x1 x2 x3 x4"
"same result when wrapped in fork"


"
Part 3: terminate a process after encountering an unhandled error AND a non-local return inside an unwind block
==========================================================================
Show the semantics of non-local returns inside unwind blocks combined with unhandled error during termination.
"
"
Termination happens when you hit Abandon on the Debugger window.
Note: when you hit Proceed the computation will continue normally and will print x1 x2 x3 x4"
"

"
non-local return inside inner-most halfway-thru unwind block:
......................................................................................................
"
[
	[ ] ensure: [
		[self error: #unwind_test] ensure: [
			^Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: #unwind_test. 
			^Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x3"

"
non-local return inside outer-most halfway-thru unwind block:
......................................................................................................
"
[
	[ ] ensure: [
		[self error: #unwind_test] ensure: [
			Transcript show: #x1]. 
		^Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: #unwind_test. 
			Transcript show: #x1]. 
		^Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4


"prints x1 x2 x3"

"
one more level...:
............................
"
[
	[
		[ ] ensure: [
			[ ] ensure: [
				self error: #unwind_test. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		^Transcript show: #x3]
] ensure: [
	Transcript show: #x4].
Transcript show: #x5

"prints x1 x2 x3 x4 (even if wrapped in #fork)"

"
non-local return outside halfway-thru unwind blocks:
......................................................................................
"
[
	[ ] ensure: [
		[self error: #unwind_test] ensure: [
			Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	^Transcript show: #x3].
Transcript show: #x4

"prints x1 x2 x3"


[
	[ ] ensure: [
		[ ] ensure: [
			self error: #unwind_test. 
			Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	^Transcript show: #x3].
Transcript show: #x4

"prints x1 x2 x3"


"
Part 4: COMPARISON with the behavior when encountering a handled error or a healthy non-local return inside an unwind block
===================================================================================
Show that ONLY pending unwind blocks that have not yet started get executed during an exception or non-local return unwind.
Why? Handled exceptions and non-local returns do not use #terminate and so do not follow the new terminate semantics and use the traditional simpler semantics instead, skipping unwind blocks halfway through their execution (see #resume[:through:] methods).
"

"
one single handled error scenario:
.......................................................
"
[
	[
		[ ] ensure: [
			[self error: #unwind_test] ensure: [
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3]
] on: Error do: [].
Transcript show: #x4

"prints x1 x3 x4 only, skips x2"

[
	[
		[ ] ensure: [
			[] ensure: [
				self error: #unwind_test.
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3]
] on: Error do: [].
Transcript show: #x4

"prints x3 x4 only, skips x1 and x2"

"
multiple nested handled errors:
...................................................
"
[
	[
		[ ] ensure: [
			[self error: #unwind_test_outer] ensure: [
				self error: #unwind_test_inner.
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3]
] on: Error do: [].
Transcript show: #x4

"prints x3 x4 only, skips x1 and x2"

"
non-local return scenario:
.........................................
"
[
	[ ] ensure: [
		[^Transcript show: #x0] ensure: [
			Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x0 x1 x3 only, skips x2"


[
	[ ] ensure: [
		[] ensure: [
			^Transcript show: #x1]. 
		Transcript show: #x2]
] ensure: [
	Transcript show: #x3].
Transcript show: #x4

"prints x1 x3 only, skips x2"


"
Part 4: Crazies - explore new teminate behavior and semantics under more extreme circumstances:
==================================================================
Show that the system will not crash and execute all pending unwind blocks as expected.
"

"
Unwind after active process termination; run in the UI. CAUTION: save image first!!
All examples following this one can be run in the UI; forking them is for convenience.
"
[ ] ensure: [
	[Processor activeProcess terminate] ensure: [
		Transcript show: #x1]. 
	Transcript show: #x2
	]
"prints x1 x2 and suspends the UI; recover via Alt+."


"
Unwind after active process termination; run forked
"
[
	[ ] ensure: [
		[Processor activeProcess terminate] ensure: [
			Transcript show: #x1]. 
		Transcript show: #x2
		]
] forkAt: Processor activePriority + 1
"prints x1 x2"


"
Unwind after double active process termination:
"
| p |
p := [
	[Processor activeProcess terminate] 	ensure: [
		Processor activeProcess terminate. Transcript show: #x1 ]
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString
"prints x1 true"


"
Unwind after double active process termination (equivalent to previous):
"
| p ap |
p := [
	[ap := Processor activeProcess. ap terminate] 	ensure: [
		ap terminate. Transcript show: #x1]
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString
"prints x1 true"


"
Unwind after double active process termination inside the same unwind block:
"
| p |
p := [
	[] ensure: [ 
		Processor activeProcess terminate. Transcript show: #x1. 
		Processor activeProcess terminate. Transcript show: #x2]
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString
"prints x1 x2 true"


"
Unwind after double active process termination inside nested unwind blocks:
"
| p |
p := [
	[
		[] ensure: [
			[Processor activeProcess terminate] ensure: [
				Processor activeProcess terminate. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume.
Transcript show: p isTerminated printString
"prints x1 x2 x3 true"


"
Unwind after active process termination combined with non-local return:
"
| p |
p := [
	[] ensure: [ 
		Processor activeProcess terminate. Transcript show: #x1. 
		true ifTrue: [^Transcript show: #x2]]
] newProcess priority: Processor activePriority + 1.
"raise active priority to avoid preemption in Cuis"
p resume
"prints x1 x2 and raises BlockCannotReturn error as expected"


"
Unwind after triple nested active process termination - run forked:
"
[
	[Processor activeProcess terminate] ensure: [
	    [Processor activeProcess terminate] ensure: [
	        [Processor activeProcess terminate] ensure: [
	            Transcript show: #x1].
	        Transcript show: #x2].
	    Transcript show: #x3].
	Transcript show: #x4
] forkAt: Processor activePriority + 1
"prints x1 x2 x3"


"
Unwind after triple nested active process termination - run in the UI:
"
[Processor activeProcess terminate] ensure: [
    [Processor activeProcess terminate] ensure: [
        [Processor activeProcess terminate] ensure: [
            Transcript show: #x1].
        Transcript show: #x2].
    Transcript show: #x3].
Transcript show: #x4
"prints x1 x2 x3 and suspends the UI; recover via Alt+."


"
Unwind after active process suspension during termination inside nested unwind blocks:
"
| p |
p := [
	[
		[ ] ensure: [
			[Processor activeProcess suspend] ensure: [
				Processor activeProcess suspend. 
				Transcript show: #x1]. 
			Transcript show: #x2]
	] ensure: [
		Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
p terminate.
"first terminate gets suspended inside the unwind block as expected"
p terminate.
"second terminate (or resume) then finishes the termination"
Transcript show: p isTerminated printString
"prints x1 x2 x3 true"


"
Unwind multiple nested active process suspension:
"
| p |
p := [
	[Processor activeProcess suspend] ensure: [
	    [Processor activeProcess suspend] ensure: [
	        [Processor activeProcess suspend] ensure: [
	            Transcript show: #x1].
	        Transcript show: #x2].
	    Transcript show: #x3].
	Transcript show: #x4
] newProcess.
p resume.
Processor yield.
"p stops at the first suspend"
p terminate.
"termiination stops at the second suspend"
p resume.
"after resuming, p stops at the next suspend"
p resume

"prints x1 x2 x3"


"
Part 5: Some additional unsorted examples
============================
Show that the system will not crash and execute all pending unwind blocks as expected.
"

"
Raise a ZeroDivide exception after 1 second.
"
| p |
p := [ [ (Delay forSeconds: 100) wait ] ensure: [ 1 / 0 ] ] newProcess resume.
(Delay forSeconds: 1) wait.
p terminate.


"
BlockCannotReturn error inside nested unwind block during termination:
(this is one of many similar test scenarios in ProcessTerminateUnwindNonLocalReturn class)
"
| p a |
a := Array new: 4 withAll: false.
p := [	[[
			[ ] ensure: [
				[Processor activeProcess suspend] ensure: [
					^a at: 1 put: true].
				a at: 2 put: true]
		] ensure: [
			a at: 3 put: true].
		a at: 4 put: true
	] ensure: [
		Transcript show: a]
] newProcess.
p resume.
Processor yield.
p terminate
"prints #(true false true false)"
"!!!!!! without fork crashes image"

"
Show the examples terminate peacefully after Abandoning the BlockCannotReturn notifications.
CAUTION: Proceeding BlockCannotReturn debugger notifications WILL crash your image !!!!!! 
Save the image first if you want to try.
"

[^2] fork

[[self error: #error] ensure: [^2]] fork

[[[] ensure: [^2]] ensure: [^42]] fork

[[] ensure: [[^2] fork]] fork

"
Guess the result of this test:
"
"Both statements need to be executed separately."
a := [true ifTrue: [^ 1]. 2]
"execute separately"
a value
"What would you say should be the right answer and why??"


"
This example will immediately crash your image !!!!!!
"
"Both statements need to be executed separately."
a := [true ifTrue: [^ 1] yourself]
"execute separately"
[a value] on: BlockCannotReturn do: [:ex | ex resume]


"
Note: The following examples require a fix in #doesNotUnderstand: preventing an infinite recursion of the MNU error.
"

"
Show both ZeroDivide and MessageNotUnderstood errors are raised and all unwind blocks executed after closing the debuggers.
"
[
	[
		[ ] ensure: [ "halfway through completion when suspended"
			[ ] ensure: [ "halfway through completion when suspended"
				Transcript show: (1 / 0) > 0]. "raise ZeroDivide AND MessageNotUnderstood errors"
			Transcript show: #x2]
	] ensure: [ "not started yet when suspended"
		Transcript show: #x3]
] fork
"prints Error: infinite recursion in doesNotUnderstand: x2 x3"


"
Show the following examples deal with MessageNotUnderstood error correctly and do nott crash or freeze the image or cycle through the MessageNotUnderstood error indefinitely. (Note: a fix in #doesNotUnderstand: preventing an infinite recursion of the MNU error needs to be applied.)
Accept gotcha when asked (it represents an unknown method) and Proceed or Abandon as you like...
"
[] ensure: [self gotcha. Transcript show: #done]

[] ensure: [[self gotcha] ensure: [self halt. Transcript show: #done]

[self error: #error] ensure: [self gotcha. Transcript show: #done]

[self error: #error] ensure: [[self gotcha] ensure: [Transcript show: #done]]

[[] ensure: [[self gotcha] ensure: [self halt. Transcript show: #done]]] fork
"This one used to freeze Cuis UI after Halt -> Proceed but recoverable via Alt+.
Latest terminate with the above mentioned #dnu fix executes as expected."


'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5087-terminateExamples-JaromirMatas-2022Feb23-13h14m-jar.001.cs.st----!

'From Cuis 6.0 [latest update: #5087] on 24 February 2022 at 3:22:30 pm'!
!Morph methodsFor: 'geometry services' stamp: 'jmv 2/24/2022 15:10:48' prior: 16893458!
coversPixel: worldPoint
	"Answer true if pixel worldPoint is covered by us (or a submorph of ours), even if we are not visible a it
	because of some other morph above us also covers it.

	WARNING: Might answer nil when we simply don't know. It is generally advisable to call this method only for
	morphs where the answer is not nil:
		- BoxedMorphs. No sepecial care needed. (Senders in the base Cuis image are of this kind).
		- Morphs drawn by VectorCanvas (i.e. they #requiresVectorCanvas). See notes below.
	
	Note: If your morph #requiresVectorCanvas, and depends on this general implementation, remember to 
	`removeProperty: #bitMask` whenever it becomes invalid due to changes in your morphs. You may consider
	using #ownsPixel: if appropriate, that doesn't require any maintenance and is cheaper (in cpu and memory).
	See #bitMask.

	See #ownsPixel:
	See #includesPixel:"

	self visible ifTrue: [
		"Expensive way for morphs with arbitrary shape in VectorGraphics.
		The base Cuis System doesn't use this.
		Use this in applications if the expense of maintaining #bitMask is worth it."
		self canvas ifNotNil: [ :canvas |
			canvas canDoVectorGraphics ifTrue: [
				^(self bitMask pixelValueAt: worldPoint - self displayFullBounds topLeft) = 1 ]].

		"This is cheap and OK for unrotated Morphs with a rectangular shape.
		In general, the answer is not strictly correct.
		BoxedMorph redefines this method with an equally cheap implementation that can also handle
		rotated morphs (but assuming they are of rectangular shape)."
		self basicDisplayBounds ifNotNil: [ :r |
			(r containsPoint: worldPoint) ifFalse: [ ^false ] ]].

	"If we don't know."
	^ nil.! !
!Morph methodsFor: 'geometry services' stamp: 'jmv 2/24/2022 15:20:12' prior: 16893533!
   includesPixel: worldPoint
	"Answer true if the grabbing from the pixel argument pixel with the mouse should grab us:

	- Answer true if we own the pixel, i.e. we are the last morph drawn at worldPoint.

	- Some implementations (BoxedMorph) may also answer true if we cover but don't own the pixel,
	meaning that some other morph was drawn later, covering us.

	- For other morphs, not BoxedMorph, (i.e. they run this implementation), if VectorGraphics is not active,
	answer true for any point that lies within our bounds. If this is the case, consider using VectorGraphics: In addition to
	many other advantages, this method will always answer a strictly correct answer.

	Therefore, senders need to be aware that the answer is meaningful only when it is known that no other morph
	covers us. A common case is to find the topmost morph at some position. In that case, iterating front to back ensures
	that if any other morph covers us, it is found first.

	Note: This method is redefined by some subclasses. This implementation is only used for morphs drawn by VectorCanvas,
	either because the main canvas is a VectorCanvas, or because it is a HybridCanvas and we answer true to #requiresVectorCanvas.
	(See other implementors)

	Note: Also see #ownsPixel: and #coversPixel:"

	"Check if #ownsPixel:, if possible."
	self canvas ifNotNil: [ :canvas |
		canvas canDoVectorGraphics ifTrue: [
			^ (canvas morphIdAt: worldPoint) = self morphId ]].

	"This is cheap and OK for unrotated Morphs with a rectangular shape.
	In general, the answer is not strictly correct. (There are false positives, for submorphs or sibling morphs covering us).
	BoxedMorph redefines this method with an equally cheap implementation that can also handle
	rotated morphs (but assuming they are of rectangular shape)."
	self visible ifTrue: [
		self basicDisplayBounds ifNotNil: [ :r |
			^r containsPoint: worldPoint ]].

	^ false.! !
!BoxedMorph methodsFor: 'geometry services' stamp: 'jmv 2/24/2022 15:21:55' prior: 16794420 overrides: 50338710!
                       includesPixel: worldPoint
	"Answer true if the grabbing from the pixel argument pixel with the mouse should grab us:
	(See comment and implementation at Morph).
	Note: This implementation also answer true if we cover but don't own the pixel,
	meaning that some other morph was drawn later, covering us.
	Therefore, senders need to be aware that the answer is meaningful only when it is known that no other morph covers us.
	Note: This implementation is only used for morphs with a cheap #coversPixel:.
	(See other implementors)
	Also see #ownsPixel: and #coversPixel:"

	^ self visible and: [self coversPixel: worldPoint].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5088-TweaksToComments-JuanVuletich-2022Feb24-14h58m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5087] on 25 February 2022 at 11:46:13 am'!
!Morph methodsFor: 'private' stamp: 'jmv 2/25/2022 10:14:37'!
     privateDisplayBounds
	^privateDisplayBounds! !
!Morph methodsFor: 'private' stamp: 'jmv 2/25/2022 10:14:44'!
                   privateDisplayBounds: aRectangle
	privateDisplayBounds _ aRectangle! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 11:05:08'!
                   contourClearOnCurrentMorph
	"Remove knowledge of any contour."

	currentMorph setProperty: #contour toValue: nil.
	currentMorph setProperty: #contourY0 toValue: nil.
	currentMorph setProperty: #contourY1 toValue: nil.! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 10:24:04'!
                             displayBoundsSetOnCurrentMorph
	"At time of last draw on world canvas. nil if unknown.
		(i.e. privateDisplayBounds is not to represent morph bounds in any other context).
	Clipped appropiately if some owner clips currentMorph.
	See also #displayBoundsUpdateOn:"

	currentMorph canvas ifNotNil: [ :c |
		(self isBoundsFinderCanvas or: [c canvasToUse == self canvasToUse]) ifTrue: [
			currentMorph privateDisplayBounds: self canvasToUse boundingRectOfCurrentMorphAfterDraw ]].! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 10:24:29'!
                          displayBoundsUpdateOnCurrentMorph
	"At time of last draw on world canvas. nil if unknown.
	Only to be used for the world canvas
		(i.e. privateDisplayBounds is not to represent morph bounds in any other context).
	Rectangle is clipped appropiately if some owner clips currentMorph.
	To be called after #postDrawOn:. See also #displayBoundsSetOn:
	This more complicated update is needed because the contour information from #drawOn: was lost
	when drawing submorphs. So, the contour from #drawOn: needs to be retrieved, and updated with the
	new contour information from #postDrawOn:"

	currentMorph canvas ifNotNil: [ :c |
		(self isBoundsFinderCanvas or: [c canvasToUse == self canvasToUse]) ifTrue: [
			currentMorph privateDisplayBounds: 
				(currentMorph privateDisplayBounds quickMerge:
					self canvasToUse boundingRectOfCurrentMorphAfterDraw) ]].! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 11:05:31' prior: 16896141!
               drawCurrentAsError
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	r _ currentMorph morphLocalBoundsForError.
	w _ r extent > `50@50`
		ifTrue: [ 6 ]
		ifFalse: [ 2 ].
	self
		frameAndFillRectangle: r
		fillColor: `Color red`
		borderWidth: w
		borderColor: `Color yellow`.
	self line: r topLeft+1 to: r bottomRight-w width: w color: `Color yellow`.
	self line: r topRight + (w negated@1) to: r bottomLeft + (1@ w negated) width: w color: `Color yellow`.	
	self displayBoundsSetOnCurrentMorph.
	self contourClearOnCurrentMorph.! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 11:05:28' prior: 16896161!
                  drawCurrentAsOutline

	currentMorph visible ifTrue: [
		self displayBoundsSetOnCurrentMorph.
		self contourClearOnCurrentMorph.
		self frameReverseGlobalRect: currentMorph displayBounds borderWidth: 2 ].! !
!BitBltBoundsFinderCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 10:25:11' prior: 16788991!
                fullUpdateCurrentProtrudingBounds
	"Recursively update display bounds, for currentMorph and all submorphs,
	but only for those whose bounds may go outside owner bounds."

	self displayBoundsSetOnCurrentMorph.! !
!BitBltBoundsFinderCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 10:25:17' prior: 16789037!
           updateCurrentBounds
	"Update display bounds, for currentMorph only."

	self displayBoundsSetOnCurrentMorph.! !
!BitBltCanvas methodsFor: 'morphic' stamp: 'jmv 2/25/2022 11:05:23' prior: 16789851 overrides: 16896136!
        drawCurrentAndSubmorphs
	
	currentMorph visible ifTrue: [

		currentMorph drawOn: self.
		self displayBoundsSetOnCurrentMorph.
		self contourClearOnCurrentMorph.

		"Display submorphs back to front"
		"coordinate system stack already set up for aMorph
		('ivars transformations' and 'currentTransformation')"
		self clippingByCurrentMorphDo: [
			currentMorph submorphsReverseDo: [ :m | self fullDraw: m ]].

		(currentMorph postDrawOn: self) ifTrue: [
			self displayBoundsUpdateOnCurrentMorph ].

		currentMorph isHighlighted ifTrue: [
			self drawHighlight: currentMorph ].
	].! !

MorphicCanvas removeSelector: #contourOfCurrentMorphAfterDrawInto:into:!

!methodRemoval: MorphicCanvas #contourOfCurrentMorphAfterDrawInto:into: stamp: 'Install-5089-MorphicCanvas-refactor-JuanVuletich-2022Feb25-11h44m-jmv.001.cs.st 5/16/2022 10:22:23'!
contourOfCurrentMorphAfterDrawInto: anArray into: aBlock
	"We don't compute contours. See other implementors."!

BoxedMorph removeSelector: #displayBoundsUpdateFrom:!

!methodRemoval: BoxedMorph #displayBoundsUpdateFrom: stamp: 'Install-5089-MorphicCanvas-refactor-JuanVuletich-2022Feb25-11h44m-jmv.001.cs.st 5/16/2022 10:22:23'!
displayBoundsUpdateFrom: aCanvas
	"Private for framework use. NOP here. See super implementation.
	See also #knowsOwnLocalBounds and #wantsContour."!

Morph removeSelector: #displayBoundsSetFrom:!

!methodRemoval: Morph #displayBoundsSetFrom: stamp: 'Install-5089-MorphicCanvas-refactor-JuanVuletich-2022Feb25-11h44m-jmv.001.cs.st 5/16/2022 10:22:23'!
displayBoundsSetFrom: aCanvas
	"Private for framework use.
	At time of last draw on world canvas. nil if unknown.
	Only to be used for the world canvas (i.e. this ivar is not to represent our bounds in any other context).
	Clipped appropiately if some owner clips us.
	See also #displayBoundsUpdateFrom:"

	self canvas ifNotNil: [ :c |
		(aCanvas isBoundsFinderCanvas or: [c canvasToUse == aCanvas canvasToUse]) ifTrue: [
			privateDisplayBounds _ aCanvas canvasToUse boundingRectOfCurrentMorphAfterDraw.
			self wantsContour
				ifTrue: [
					 (aCanvas canvasToUse
						contourOfCurrentMorphAfterDrawInto: (self valueOfProperty: #contour) 
						into: [ :contourArray :contourY0 :contourY1 |
							self setProperty: #contour toValue: contourArray.
							self setProperty: #contourY0 toValue: contourY0.
							self setProperty: #contourY1 toValue: contourY1 ])]
				ifFalse: [
					self setProperty: #contour toValue: nil.
					self setProperty: #contourY0 toValue: nil.
					self setProperty: #contourY1 toValue: nil ]]].!

Morph removeSelector: #displayBoundsUpdateFrom:!

!methodRemoval: Morph #displayBoundsUpdateFrom: stamp: 'Install-5089-MorphicCanvas-refactor-JuanVuletich-2022Feb25-11h44m-jmv.001.cs.st 5/16/2022 10:22:23'!
displayBoundsUpdateFrom: aCanvas
	"Private for framework use.
	At time of last draw on world canvas. nil if unknown.
	Only to be used for the world canvas (i.e. this ivar is not to represent our bounds in any other context).
	Rectangle is clipped appropiately if some owner clips us.
	To be called after #postDrawOn:. See also #displayBoundsSetFrom:
	This more complicated update is needed because the contour information from #drawOn: was possibly
	when drawing submorphs. So, the controur from #drawOn: needs to be retrieved, and updated with the
	new contour information from #postDrawOn:"

	self canvas ifNotNil: [ :c |
		(aCanvas isBoundsFinderCanvas or: [c canvasToUse == aCanvas canvasToUse]) ifTrue: [
			privateDisplayBounds _ privateDisplayBounds
				quickMerge: aCanvas canvasToUse boundingRectOfCurrentMorphAfterDraw.
			self wantsContour ifTrue: [
				(aCanvas canvasToUse
					contourOfCurrentMorphAfterDrawUpdate: (self valueOfProperty: #contour)
					oldTop: (self valueOfProperty: #contourY0)
					oldBottom: (self valueOfProperty: #contourY1)
					into: [ :contourArray :contourY0 :contourY1 |
						self setProperty: #contour toValue: contourArray.
						self setProperty: #contourY0 toValue: contourY0.
						self setProperty: #contourY1 toValue: contourY1 ])]]].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5089-MorphicCanvas-refactor-JuanVuletich-2022Feb25-11h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5089] on 25 February 2022 at 12:39:21 pm'!
!Morph methodsFor: 'geometry services' stamp: 'jmv 2/25/2022 12:38:57' prior: 16893352!
           collides: aMorph
	"Answer whether the pixels used by morphs touch at least at one place.
	Morphs not in the BoxedMorph hierarchy should answer #true to wantsContour."

	privateDisplayBounds ifNil: [
		^false ].

	"Quick check with display bounds"
	aMorph displayFullBounds
		ifNil: [ ^false ]
		ifNotNil: [ :r |
			(self displayFullBounds intersects: r) ifFalse: [ ^false ]].

	"Precise check with contour, if available"
	(self valueOfProperty: #contour) ifNotNil: [ :contour | | contourTop contourBottom |
		contourTop _ self valueOfProperty: #contourY0.
		contourBottom _ self valueOfProperty: #contourY1.
		^ aMorph contourIntersects: contour top: contourTop bottom: contourBottom ].

	"If contour is not available, and both displayBounds overlap, answer true, as it is the best we can know."
	^ true! !

Morph removeSelector: #displayBoundsIntersects:!

!methodRemoval: Morph #displayBoundsIntersects: stamp: 'Install-5090-Collides-fix-JuanVuletich-2022Feb25-11h56m-jmv.001.cs.st 5/16/2022 10:22:23'!
displayBoundsIntersects: aRectangle

	privateDisplayBounds ifNil: [
		^false ].
	^privateDisplayBounds intersects: aRectangle!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5090-Collides-fix-JuanVuletich-2022Feb25-11h56m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5090] on 3 March 2022 at 9:31:30 am'!
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:09:42' prior: 50336647!
          hugeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences hugeFonts
	"

	self defaultFontSize: 32.
	self setPreference: #guiElementsSize toValue:  #hugeFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:09:46' prior: 50336595!
largeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences largeFonts
	"

	self defaultFontSize: 18.
	self setPreference: #guiElementsSize toValue:  #largeFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:09:49' prior: 50336656!
                             smallFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences smallFonts
	"
	
	self defaultFontSize: 11.
	self setPreference: #guiElementsSize toValue:  #smallFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:09:53' prior: 50336665!
                      standardFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences standardFonts
	"

	self defaultFontSize: 14.
	self setPreference: #guiElementsSize toValue:  #standardFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:09:56' prior: 50336674!
                    tinyFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences tinyFonts
	"

	self defaultFontSize: 7.
	self setPreference: #guiElementsSize toValue:  #tinyFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:10:00' prior: 50336603!
                           veryLargeFonts
	"Sets not only fonts but other GUI elements
	to fit regular resolution and size screens
	Preferences veryLargeFonts
	"

	self defaultFontSize: 24.
	self setPreference: #guiElementsSize toValue:  #veryLargeFonts.! !
!Preferences class methodsFor: 'bigger and smaller GUI' stamp: 'jmv 3/3/2022 09:10:04' prior: 50336683!
                 verySmallFonts
	"Sets not only fonts but other GUI elements
	to fit very low resolution or very small screens
	Preferences verySmallFonts
	"
	
	self defaultFontSize: 9.
	self setPreference: #guiElementsSize toValue:  #verySmallFonts.! !
!Theme class methodsFor: 'user interface' stamp: 'jmv 3/3/2022 09:30:54' prior: 50336719!
                         changeFontSizes

	| options menu currentIndex |
	options _ #(
		#('Huge' #hugeFonts)
		#('Very Large' #veryLargeFonts)
		#('Large' #largeFonts)
		#('Default Size' #standardFonts)
		#('Small' #smallFonts)
		#('Very Small' #verySmallFonts)
		#('Tiny' #tinyFonts)).
	menu _ MenuMorph new defaultTarget: Preferences.
	menu
		addTitle: 'Make GUI elements';
		addStayUpIcons;
		stayUp: true.
	options do: [ :pair |
		menu add: pair first action: pair second ].
	currentIndex _ (options size / 2) ceiling.
	(Preferences preferenceAt: #guiElementsSize) ifNotNil: [ :pref |
		options withIndexDo: [ :pair :i |
			pair second = pref preferenceValue ifTrue: [ currentIndex _ i ]]].
	menu selectItem: (menu items at: currentIndex).
	menu popUpInWorld: self runningWorld.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5091-GUIElementSizeEnh-JuanVuletich-2022Mar03-09h09m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5091] on 6 March 2022 at 7:04:57 pm'!
!Morph methodsFor: '*ui-draganddrop' stamp: 'KenD 3/4/2022 12:56:00' prior: 16892094!
         wantsDroppedMorph: aMorph event: evt
	"Return true if the receiver wishes to accept the given morph, 
	 which is being dropped by a hand in response to the given event. 
	Note that for a successful drop operation both parties need to agree. 
	The symmetric check is done automatically via aMorph wantsToBeDroppedInto: self.
	 Individual Morpks may override by setting the corresponding property
	 to an appropriate two argument closure."

	^self valueOfProperty: #wantsDroppedMorph:event:
		 ifPresentDo: [ :wantsMorphEvt | wantsMorphEvt value: aMorph value: evt ]
		 ifAbsent: [ true ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5092-wantsDroppedMorphEvent-KenDickey-2022Mar06-19h04m-KenD.001.cs.st----!

'From Cuis 6.0 [latest update: #5092] on 8 March 2022 at 9:11:26 pm'!
!Morph methodsFor: 'halos and balloon help' stamp: 'HAW 3/8/2022 20:40:29' prior: 50337661!
            showBalloon: msgStringOrText hand: aHand
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| doWordWrap msg |
	doWordWrap _ true.
	msg _ msgStringOrText.
	(msgStringOrText notEmpty and: [ msgStringOrText last isLineSeparator ]) ifTrue: [
		doWordWrap _ false.
		msg _ msg allButLast ].
	self
		showBalloon: msg
		hand: aHand
		doWordWrap: doWordWrap.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5093-EmptyBallonStringEmpty-HernanWilkinson-2022Mar08-20h40m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5093] on 21 March 2022 at 10:46:27 am'!
!StringRequestMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:00:32' overrides: 16880172!
                             categoryInNewMorphMenu

	^ 'User Interface'! !
!PluggableButtonMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:05:05' overrides: 50332354!
                         categoryInNewMorphMenu

	^ 'User Interface'! !
!PluggableButtonMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:06:38' overrides: 16911762!
                         includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"
	
	^ true! !
!PluggableButtonMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:05:26' overrides: 16895515!
                               initializedInstance

	^ self example! !
!TextParagraphMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:15:12' overrides: 50332354!
  categoryInNewMorphMenu

	^ 'User Interface'! !
!FillInTheBlankMorph class methodsFor: 'examples' stamp: 'KenD 3/14/2022 14:51:54'!
                             example1
	| aFillInTheBlankMorph |
	aFillInTheBlankMorph _ self new
		emptyTextDisplayMessage: 'Enter answer here';
		setQuery: 'Ask Question Here'
		initialAnswer: 'Enter answer here'
		acceptOnCR: true.
	aFillInTheBlankMorph responseUponCancel: 'returnOnCancel'.
	^ aFillInTheBlankMorph.! !
!FillInTheBlankMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 14:55:00' overrides: 50332354!
    categoryInNewMorphMenu

	^ 'User Interface'! !
!AutoCompleterMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:16:19' overrides: 50332354!
                           categoryInNewMorphMenu

	^ 'User Interface'! !
!ProgressMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 15:00:20' prior: 16920078 overrides: 16880172!
                categoryInNewMorphMenu

	^ 'User Interface'! !
!UpdatingLabelMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 14:57:58' prior: 16976219 overrides: 16877771!
           categoryInNewMorphMenu

	^ 'User Interface'! !
!FillInTheBlankMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 14:34:24' prior: 16857038 overrides: 16895515!
          initializedInstance
	| aFillInTheBlankMorph |
	aFillInTheBlankMorph _ self new
		emptyTextDisplayMessage: 'Enter answer here';
		setQuery: 'Ask Question Here'
		initialAnswer: 'Enter answer here'
		acceptOnCR: true.
	aFillInTheBlankMorph responseUponCancel: 'returnOnCancel'.
	^ aFillInTheBlankMorph.! !
!HoverHelpMorph class methodsFor: 'new-morph participation' stamp: 'KenD 3/14/2022 14:56:58' prior: 16868464 overrides: 50332354!
              categoryInNewMorphMenu

	^ 'User Interface'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5094-NewMorphCategory-KenDickey-2022Mar21-10h44m-KenD.001.cs.st----!

'From Cuis 6.0 [latest update: #5069] on 25 March 2022 at 11:37:28 am'!
!TaskbarMorph methodsFor: 'initialization' stamp: 'KLG 3/23/2022 22:49:02' overrides: 16893832!
           balloonText
	"Answer the ballon text .
	
	Done dynamicly; System might change during my lifetime."

	^ 'About this system:' bold, `String newLineString`, Smalltalk systemInformationString! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5095-TaskbarMorph-BalloonText-GeraldKlix-2022Mar25-11h36m-KLG.001.cs.st----!

'From Cuis 6.0 [latest update: #5095] on 26 March 2022 at 5:15:50 pm'!
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/26/2022 17:12:35'!
         drawTextComposition: aTextComposition at: drawingPosition extent: anExtent color: c selectionColor: sc
	"strict boolean controls whether to avoid or include the last line, if it doesn't fully fit in visibleTextBounds"

	self drawTextComposition: aTextComposition at: drawingPosition extent: anExtent color: c selectionColor: sc avoidOverhang: false! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/26/2022 17:12:41'!
                     drawTextComposition: aTextComposition at: drawingPosition extent: anExtent color: c selectionColor: sc avoidOverhang: strict
	"strict boolean controls whether to avoid or include the last line, if it doesn't fully fit in visibleTextBounds"

	| displayScanner leftInRun line possiblyVisible firstLineIndex lastLineIndex |

	possiblyVisible _ currentTransformation boundsOfInverseTransformOf: self clipRect.
	possiblyVisible _ (possiblyVisible translatedBy: drawingPosition negated) intersect: (0@0 extent: anExtent).

	displayScanner _ MorphicScanner new
		defaultFont: aTextComposition defaultFont;
		text: aTextComposition textComposed
		foreground: c.
	displayScanner canvas: self.

	leftInRun _ 0.
	"Take clipRect into account. Extrememly fast scrolls and redraws of huge files (like .sources)"
	firstLineIndex _ aTextComposition lineIndexForPoint: (possiblyVisible topLeft max: `0@0`).
	lastLineIndex _ aTextComposition lineIndexForPoint: (possiblyVisible bottomRight min: anExtent).
	firstLineIndex
		to: lastLineIndex
		do: [ :i |
			line _ aTextComposition lines at: i.
			(strict not or: [ line top + line baseline < possiblyVisible bottom ]) ifTrue: [
				aTextComposition
					displaySelectionInLine: line
					on: self
					textTopLeft: drawingPosition
					selectionColor: sc.
				leftInRun _ displayScanner displayLine: line textTopLeft: drawingPosition leftInRun: leftInRun ]]! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 3/26/2022 17:09:42' prior: 16974349!
                       endEntry
	| c d cb |
	c _ self contents.
	DisplayScreen isDisplayExtentOk ifFalse: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d _ textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ textComposition characterBlockAtPoint:
			`0@0` + (0@(d+FontFamily defaultLineSpacing)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		drawTextComposition: textComposition
		at: `4@4` + frame topLeft
		extent: Display extent
		color: `Color black`
		selectionColor: `Color blue`.
	DisplayScreen screenUpdateRequired: nil! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 3/26/2022 17:10:07' prior: 16870315 overrides: 16794207!
                       drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		drawTextComposition: self textComposition
		at: `0@0`
		extent: extent
		color: color
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus).

	model actualContents isEmpty ifTrue: [
		owner
			valueOfProperty: #emptyTextDisplayMessage
			ifPresentDo: [ :msg |
				aCanvas
					drawString: msg
					at: `0@0`
					font: nil
					color: Theme current textEmptyDisplayMessage ]].! !
!TextParagraphMorph methodsFor: 'drawing' stamp: 'jmv 3/26/2022 17:08:48' prior: 16969487 overrides: 16794207!
       drawOn: aCanvas
	| b |
	b _ self morphLocalBounds insetBy: borderWidth * 2.
	aCanvas
		fillRectangle: self morphLocalBounds color: color.
	aCanvas
		drawTextComposition: textComposition
		at: b topLeft
		extent: b extent
		color: Theme current text
		selectionColor: `Color red`
		avoidOverhang: true.
	aCanvas
		frameRectangle: self morphLocalBounds
		color: borderColor
		borderWidth: borderWidth
		borderStyleSymbol: nil! !
!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 3/26/2022 17:11:33' prior: 16868384 overrides: 16794207!
          drawOn: aCanvas

	| r |
	r _ self morphLocalBounds.
	aCanvas roundRect: r color: self color radius: 4.
	aCanvas
		drawTextComposition: textComposition
		at: `4@4`
		extent: extent - 8
		color: `Color black`
		selectionColor: (Theme current textHighlightFocused: false).! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/26/2022 17:14:13' prior: 16895930!
                    textComposition: aTextComposition bounds: boundsRect color: c selectionColor: sc
	"Prefer #drawTextComposition:at:extent:..."

	self drawTextComposition: aTextComposition at: boundsRect topLeft extent: boundsRect extent color: c selectionColor: sc avoidOverhang: false! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 3/26/2022 17:14:36' prior: 16895939!
                     textComposition: aTextComposition bounds: boundsRect color: c selectionColor: sc avoidOverhang: strict
	"Prefer #drawTextComposition:at:extent:..."

	self drawTextComposition: aTextComposition at: boundsRect topLeft extent: boundsRect extent color: c selectionColor: sc avoidOverhang: strict! !

MorphicCanvas removeSelector: #textComposition:at:extent:color:selectionColor:!

MorphicCanvas removeSelector: #textComposition:at:extent:color:selectionColor:avoidOverhang:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5096-drawTextComposition-fix-JuanVuletich-2022Mar26-17h06m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5096] on 7 April 2022 at 2:16:39 pm'!
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 4/7/2022 14:15:05' prior: 16881931!
     contentsWithMarkers: aString inverse: inverse 
	"Set the menu item entry. Parse aString for embedded markers."

	| markerIndex marker |
	contentString _ nil.	"get rid of old"
	self removeAllMorphs.	"get rid of old markers if updating"
	icon _ nil.
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	contentString _ aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: `0@2`.
	marker lock! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5097-MenuItemsWithToogle-fix-JuanVuletich-2022Apr07-14h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5097] on 7 April 2022 at 2:44:30 pm'!

PluggableButtonMorph removeSelector: #model:!

!methodRemoval: PluggableButtonMorph #model: stamp: 'Install-5098-PluggableButtonMorph-Fix-JuanVuletich-2022Apr07-14h44m-jmv.001.cs.st 5/16/2022 10:22:23'!
model: anObject
	"Set my model and make me me a dependent of the given object."

	model ifNotNil: [model removeDependent: self].
	stateSelector ifNotNil: [
		anObject ifNotNil: [anObject addDependent: self]].
	model _ anObject!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5098-PluggableButtonMorph-Fix-JuanVuletich-2022Apr07-14h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5098] on 7 April 2022 at 2:48:54 pm'!
!LabelMorph methodsFor: 'accessing' stamp: 'jmv 4/7/2022 14:48:31'!
                              contentsFromPrintString: anObject

	self contents: anObject printString! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5099-LabelMorph-contentsFromPrintString-JuanVuletich-2022Apr07-14h48m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5096] on 4 April 2022 at 5:43:09 pm'!
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 4/4/2022 17:41:25'!
                       afterCompiling: aSourceCode do: aBlock ifFail: failBlock

	| context provider receiver |
	
	provider := self codeProvider.
	(provider respondsTo: #doItReceiver) 
		ifTrue: [
			receiver := provider doItReceiver.
			context := provider doItContext]
		ifFalse: [
			receiver := context := nil].

	^self afterCompiling: aSourceCode do: aBlock for: receiver in: context ifFail: failBlock.
	! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 4/4/2022 17:42:02' prior: 16939419!
    debugIt

	self lineSelectAndEmptyCheck: [^self].
	self 
		afterCompiling: self selectionAsStream upToEnd
		do: [ :compiler :method :receiver :context | method ifNotNil: [ self debug: method receiver: receiver in: context ]]
		ifFail: [].! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 4/4/2022 17:42:30' prior: 16939459!
                         evaluate: aSourceCode andDo: aBlock ifFail: failBlock profiled: doProfile
	
	| result | 
	
	^ self 
		afterCompiling: aSourceCode 
		do: [ :compiler :method :receiver :context | method ifNotNil: [
			result := compiler evaluateMethod: method to: receiver logged: true profiled: doProfile.
			aBlock value: result ]]
		ifFail: failBlock.! !

SmalltalkEditor removeSelector: #afterCompiling:do:!

!methodRemoval: SmalltalkEditor #afterCompiling:do: stamp: 'Install-5100-FixWalkbackOnRecompileCancel-JuanVuletich-2022Apr04-17h41m-jmv.001.cs.st 5/16/2022 10:22:23'!
afterCompiling: aSourceCode do: aBlock

	| context provider receiver |
	
	provider := self codeProvider.
	(provider respondsTo: #doItReceiver) 
		ifTrue: [
			receiver := provider doItReceiver.
			context := provider doItContext]
		ifFalse: [
			receiver := context := nil].

	^self afterCompiling: aSourceCode do: aBlock for: receiver in: context ifFail: [ nil ].
	!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5100-FixWalkbackOnRecompileCancel-JuanVuletich-2022Apr04-17h41m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5101] on 8 April 2022 at 3:51:43 pm'!
!Preferences class methodsFor: 'standard queries' stamp: 'jmv 4/8/2022 15:50:57'!
                          shiftClickShowsImplementors
	^ self
		valueOfFlag: #shiftClickShowsImplementors
		ifAbsent: [ false ].! !
!CodeWindow methodsFor: 'GUI building' stamp: 'KenD 3/22/2022 13:37:53' prior: 16821755!
                             buildMorphicCodePane
	"Construct the pane that shows the code.
	Respect the Preference for standardCodeFont."
	
	| codePane |
	
	codePane := self createCodePaneMorph.	
	(Preferences valueOfFlag: #shiftClickShowsImplementors)
		ifTrue: [ self addShiftClickEventHandlerFor: codePane ].
		
	^codePane! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5101-ShiftClickImplementorsPreference-KenDickey-2022Apr08-15h50m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5101] on 7 April 2022 at 4:24:09 pm'!
!Stream methodsFor: 'printing' stamp: 'jmv 4/7/2022 16:03:27'!
 print: anObject fractionDigits:  placesDesired
	anObject printOn: self fractionDigits:  placesDesired! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 4/7/2022 16:10:38'!
          formatVMParameter: aNumber
	"Format a VM parameter that may have been reported either as a Float or
	an Integer. If a VM parameter is defined in units of milliseconds but internally
	measured to microsecond precision by the VM, the VM may choose to return
	the value as a Float in order to retain full precision. Otther representations
	such as Fraction may seem more natural but are difficult to instantiate in
	the VM, hence the presumption of Float for representation of higher precision
	millisecond values."

	^ aNumber isFloat
		ifTrue: [ aNumber < 1000
			ifTrue: [ aNumber printStringFractionDigits: 5 ]
			ifFalse: [ aNumber rounded printStringWithCommas ] ]
		ifFalse: [ aNumber asInteger printStringWithCommas ].! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 4/7/2022 16:22:50'!
                            vmStatisticsReportOn: str
	"
	(TextModel new contents: Utilities vmStatisticsReportString) openLabel: 'VM Statistics'
	"

	| params oldSpaceEnd youngSpaceEnd memorySize fullGCs fullGCTime fullGCCompactionTime incrGCs incrGCTime tenureCount upTime
	  upTime2 fullGCs2 fullGCTime2  incrGCs2 incrGCTime2 tenureCount2 freeSize youngSize used spur timeReporter idleMs idleMs2 codeCompactionTime codeCompactionsOrNil codeCompactionTime2 codeCompactions2 maxParams |
	"Pad to protect for a VM that does not answer the expected parameter array"
	maxParams := 63. "max position referenced in this method"
	params := Array streamContents: [ :strm |
				strm nextPutAll: Smalltalk getVMParameters.
				[strm position < maxParams] whileTrue: [strm nextPut: nil]].
	oldSpaceEnd			:= params at: 1.
	youngSpaceEnd		:= params at: 2.
	memorySize			:= params at: 3.
	fullGCs			:= params at: 7.
	fullGCTime			:= params at: 8.
	incrGCs			:= params at: 9.
	incrGCTime			:= params at: 10.
	tenureCount			:= params at: 11.
	fullGCCompactionTime	:= params at: 18.
	codeCompactionsOrNil	:= params at: 62.
	codeCompactionTime	:= params at: 63.
	
	upTime := (params at: 20) ~= 0 "utcMicrosecondClock at startup in later Spur VMs"
				ifTrue: [Time primUtcMicrosecondClock - (params at: 20) + 500 // 1000]
				ifFalse: [Time primMillisecondClock]. "Fall back on old microsecond clock; Good for 47.5 days"
	spur := (params at: 41)
				ifNotNil: [ :p | p anyMask: 16]
				ifNil: [false].
	timeReporter := [:time| | seconds |
					seconds := time / 1000.
					seconds >= (60*60*24)
						ifTrue:
							[str print: seconds / 60 // 60 // 24; nextPut: $d; space;
								print: seconds / 60 // 60 \\ 24; nextPut: $h; space]
						ifFalse:
							[seconds >= (60*60) ifTrue:
								[str print: (seconds / 60 // 60); nextPut: $h; space]].
					str
						print: (seconds / 60 \\ 60) asInteger; nextPut: $m; space;
						print: (seconds \\ 60) asInteger; nextPut: $s].
	str	nextPutAll: 'uptime		'.
	timeReporter value: upTime.
	(idleMs := params at: 16) ~= 0 ifTrue:
		[str tab; nextPutAll: '(runtime '.
		 idleMs := idleMs // 1000.
		 timeReporter value: upTime - idleMs.
		 str nextPutAll: ', idletime '.
		 timeReporter value: idleMs.
		 str nextPut: $)].
	str newLine.

	str	nextPutAll: 'memory			';
		nextPutAll: (self formatVMParameter: memorySize); nextPutAll: ' bytes'; newLine.
	str	nextPutAll:	'	old		';
		nextPutAll: (self formatVMParameter: oldSpaceEnd); nextPutAll: ' bytes (';
		print: oldSpaceEnd / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.

	spur ifTrue:
		[(youngSize := (params at: 19)  * 7 // 5) = 0 ifTrue: [params at: 44].
		 youngSize := youngSize roundUpTo: 1024.
		 str	nextPutAll: '	young		';
			nextPutAll: (self formatVMParameter: youngSize); nextPutAll: ' bytes (';
			print: youngSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
		youngSize := youngSpaceEnd. "used eden"
		freeSize := (params at: 54) + (params at: 44) - youngSize.
		used := youngSize + oldSpaceEnd - freeSize.
		str	nextPutAll: '	used		';
			nextPutAll: (self formatVMParameter: used); nextPutAll: ' bytes (';
			print: used / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	free		';
			nextPutAll: (self formatVMParameter: freeSize); nextPutAll: ' bytes (';
			print: freeSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine]
		ifFalse: "Earlier VM and V3 object memory"
		[str	nextPutAll: '	young		';
			nextPutAll: (self formatVMParameter: (youngSpaceEnd - oldSpaceEnd)); nextPutAll: ' bytes (';
			print: (youngSpaceEnd - oldSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	used		';
			nextPutAll: (self formatVMParameter: youngSpaceEnd); nextPutAll: ' bytes (';
			print: (youngSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	free		';
			nextPutAll: (self formatVMParameter: (memorySize - youngSpaceEnd)); nextPutAll: ' bytes (';
			print: (memorySize - youngSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine].

	str	nextPutAll: 'GCs					';
		nextPutAll: (self formatVMParameter: (fullGCs + incrGCs)).
	fullGCs + incrGCs > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime / (fullGCs + incrGCs) fractionDigits: 1; 
			nextPutAll: ' ms between GCs'.
		 idleMs > 0 ifTrue:
			[str
				space;
				print: upTime - idleMs / (fullGCs + incrGCs) fractionDigits: 1; 
				nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime); nextPutAll: ' ms (';
		print: fullGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime)';
		nextPutAll: ', avg '; print: (fullGCTime / (fullGCs max: 1)) fractionDigits: 1; nextPutAll: ' ms'.
	(spur and: [fullGCCompactionTime ~= 0]) ifTrue:
		[str	newLine; nextPutAll: '		marking			';
			nextPutAll: (self formatVMParameter: (fullGCTime - fullGCCompactionTime)); nextPutAll: ' ms (';
			print: (fullGCTime - fullGCCompactionTime) / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: (fullGCTime - fullGCCompactionTime / (fullGCs max: 1)) fractionDigits: 1;
			nextPutAll: ' ms,'; newLine;
			nextPutAll: '		compacting			';
			nextPutAll: (self formatVMParameter: fullGCCompactionTime); nextPutAll: ' ms (';
			print: fullGCCompactionTime / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: fullGCCompactionTime / (fullGCs max: 1) fractionDigits: 1;
			nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: (spur ifTrue: ['	scavenges				'] ifFalse: ['	incr			']);
		nextPutAll: (self formatVMParameter: incrGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime); nextPutAll: ' ms (';
		print: incrGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime), avg '; print: incrGCTime / incrGCs fractionDigits: 1; nextPutAll: ' ms'; newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount).
	tenureCount = 0 ifFalse:
		[spur
			ifTrue: [str nextPutAll: ' (avg '; print: tenureCount // (incrGCs max: 1); nextPutAll: ' tenures per scavenge)']
			ifFalse: [str nextPutAll: ' (avg '; print: incrGCs // tenureCount; nextPutAll: ' GCs/tenure)']].
	str	newLine.

	codeCompactionsOrNil ifNotNil:
		[str
			nextPutAll: '	code compactions				'.
		codeCompactionsOrNil = 0
			ifTrue: [str
				nextPutAll: codeCompactionsOrNil asString; newLine]
			ifFalse: [str
				nextPutAll: (self formatVMParameter: codeCompactionsOrNil); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime); nextPutAll: ' ms (';
				print: codeCompactionTime / (upTime - idleMs) * 100 fractionDigits: 3;
				nextPutAll: '% runtime), avg '; print: codeCompactionTime / codeCompactionsOrNil fractionDigits: 1; nextPutAll: ' ms'; newLine]].

LastStats ifNil: [LastStats := Array new: 9]
ifNotNil: [
	LastStats size < 9 ifTrue:
		[LastStats := LastStats, (Array new: 9 - LastStats size withAll: 0)].
	upTime2 := upTime - (LastStats at: 1).
	fullGCs2 := fullGCs - (LastStats at: 2).
	fullGCTime2 := fullGCTime - (LastStats at: 3).
	incrGCs2 := incrGCs - (LastStats at: 4).
	incrGCTime2 := incrGCTime - (LastStats at: 5).
	tenureCount2 := tenureCount - (LastStats at: 6).
	idleMs2 := idleMs - (LastStats at: 7).
	codeCompactionsOrNil ifNotNil:
		[codeCompactions2	:= codeCompactionsOrNil - (LastStats at: 8).
		 codeCompactionTime2	:= codeCompactionTime - (LastStats at: 9)].

	str	nextPutAll: 'GCs since last view					';
		nextPutAll: (self formatVMParameter: (fullGCs2 + incrGCs2)).
	fullGCs2 + incrGCs2 > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime2 // (fullGCs2 + incrGCs2); 
			nextPutAll: ' ms between GCs'.
			idleMs2 > 0 ifTrue:
				[str
					nextPutAll: ', ';
					print: upTime2 - idleMs2 // (fullGCs2 + incrGCs2);
					nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str	newLine.
	str	nextPutAll: '	uptime				'; print: (upTime2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, runtime ';		   print: (upTime2 - idleMs2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, idletime ';		   print: (idleMs2 / 1000.0) fractionDigits: 1; nextPutAll: ' s'; newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs2).
	fullGCs2 + fullGCTime2 > 0 ifTrue:
		[str	nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime2); nextPutAll: ' ms (';
			print: fullGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
			nextPutAll: '% runtime)'.
		 str	nextPutAll: ', avg '; print: fullGCTime2 / (fullGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: (spur ifTrue: ['	scavenges				'] ifFalse: ['	incr			']);
		nextPutAll: (self formatVMParameter: incrGCs2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime2); nextPutAll: ' ms (';
		print: incrGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
		nextPutAll: '% runtime), avg '; print: incrGCTime2 / (incrGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'.
	str	newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount2).
	tenureCount2 = 0 ifFalse:
		[spur
			ifTrue: [str nextPutAll: ' (avg '; print: tenureCount2 // (incrGCs2 max: 1); nextPutAll: ' tenures per scavenge)']
			ifFalse: [str nextPutAll: ' (avg '; print: incrGCs2 // tenureCount2; nextPutAll: ' GCs/tenure)']].
	str	newLine.
	codeCompactionsOrNil ifNotNil:
		[str	nextPutAll: '	code compactions				';
			nextPutAll: (self formatVMParameter: codeCompactions2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime2); nextPutAll: ' ms (';
			print: codeCompactionTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 3;
			nextPutAll: '% runtime)'.
		 codeCompactions2 > 0 ifTrue:
			[str nextPutAll: ', avg '; print: codeCompactionTime2 / codeCompactions2 fractionDigits: 1; nextPutAll: ' ms'; newLine.]]
].
	LastStats := { upTime. fullGCs. fullGCTime. incrGCs. incrGCTime. tenureCount. idleMs. codeCompactionsOrNil. codeCompactionTime }.! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 4/7/2022 16:23:20' prior: 16977488!
    vmStatisticsReportString
	"
	(TextModel new contents: Utilities vmStatisticsReportString) openLabel: 'VM Statistics'
	"

	^String streamContents: [:s| self vmStatisticsReportOn: s] estimatedSize: 2048! !

Utilities class removeSelector: #textMarkerForShortReport!

!methodRemoval: Utilities class #textMarkerForShortReport stamp: 'Install-5102-vmStatistics-fromSqueak-JuanVuletich-2022Apr07-15h42m-jmv.001.cs.st 5/16/2022 10:22:23'!
textMarkerForShortReport

	^  'Since last view	'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5102-vmStatistics-fromSqueak-JuanVuletich-2022Apr07-15h42m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5102] on 8 April 2022 at 10:02:13 am'!

PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #PluggableButtonMorph category: 'Morphic-Widgets' stamp: 'Install-5103-PluggableButtonMorph-Enhancements-JuanVuletich-2022Apr08-09h51m-jmv.001.cs.st 5/16/2022 10:22:23'!
PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 4/8/2022 09:53:39'!
             magnifiedIcon: aForm
	"Meaning: Don't magnify aForm to adapt it to our extent."

	icon _ nil.
	magnifiedIcon _ aForm! !
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 4/8/2022 09:54:21'!
                          mouseOverColor: aColor
	"If set, ignore #adoptWidgetsColor: for mouse over!!"

	mouseOverColor _ aColor! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/8/2022 09:55:29'!
  actionArgument: actionArg

	actionArgument _ actionArg.! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/4/2022 14:20:33' overrides: 16794180!
                              defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ nil! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/8/2022 09:56:23'!
                 model: anObject stateGetter: getStateSel stateArgument: getStateArg action: actionSel actionArgument: actionArg label: aString

	stateSelector _ getStateSel.
	stateArgument _ getStateArg.
	actionSelector _ actionSel.
	actionArgument _ actionArg.
	self model: anObject.
	self label: aString! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/4/2022 14:40:45'!
        stateArgument: getStateArg

	stateArgument _ getStateArg.! !
!PluggableButtonMorph class methodsFor: 'instance creation' stamp: 'jmv 4/8/2022 09:56:47'!
       model: anObject stateGetter: getStateSel stateArgument: getStateArg action: actionSel actionArgument: actionArg label: aString
	^ self new
		model: anObject
		stateGetter: getStateSel
		stateArgument: getStateArg
		action: actionSel
		actionArgument: actionArg
		label: aString! !
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 4/4/2022 15:09:55' prior: 16909952 overrides: 16891474!
                     adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	mouseOverColor ifNil: [
		self color: (Theme current buttonColorFrom: paneColor) ]! !
!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jmv 4/8/2022 09:59:49' prior: 16910004!
         performAction
	"Inform the model that this button has been pressed. "
	self isEnabled ifFalse: [^ self].
	actionSelector ifNotNil: [
		actionArgument
			ifNil: [ model perform: actionSelector ]
			ifNotNil: [ model perform: actionSelector with: actionArgument ]].! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 4/4/2022 15:04:03' prior: 16910017!
                         draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver | self isPressed ifTrue: [
		c _ mouseOverColor ifNil: [ c lighter ]].
	c _ self enableColorWith: c.
	aCanvas
		fillRectangle: self morphLocalBounds
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: (borderColor ifNil: [ c ]).

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 4/4/2022 15:08:49' prior: 16910102!
               drawRoundLookOn: aCanvas
	| r colorForButton rect |
	colorForButton _ self isPressed
		ifFalse: [
			self mouseIsOver
				ifTrue: [	 mouseOverColor ifNil: [ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]]
				ifFalse: [ color ]]
		ifTrue: [ mouseOverColor ifNil: [ color adjustSaturation: 0.1 brightness: -0.1 ]].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		rect _ self morphLocalBounds insetBy: `3@3`.
		r _ r min: (rect width min: rect height) * 0.5.
		aCanvas roundRect: rect color: (self enableColorWith: colorForButton) radius: r ].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ].! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/8/2022 10:01:16' prior: 16910251 overrides: 16911743!
                initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	enableSelector _ nil.
	stateSelector _ nil.
	stateArgument _ nil.
	actionSelector _ nil.
	actionArgument _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	mouseOverColor _ nil.
	actWhen _ #buttonUp.
	extent _  `20 @ 15`! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 4/8/2022 10:01:37' prior: 16910275!
                model: anObject stateGetter: getStateSel action: actionSel label: aString

	stateSelector _ getStateSel.
	stateArgument _ nil.
	actionSelector _ actionSel.
	actionArgument _ nil.
	self model: anObject.
	self label: aString! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 4/8/2022 09:59:44' prior: 16910300!
  getState
	"Answer the result of sending the receiver's model the stateSelector message."

	^ stateSelector 
		ifNil: [false]
		ifNotNil: [
			stateArgument
				ifNil: [	model perform: stateSelector]
				ifNotNil: [	model perform: stateSelector with: stateArgument]].! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 4/4/2022 14:52:00' prior: 16910308!
                      magnifiedIcon
	| factor magnifiedExtent w h |

	magnifiedIcon ifNotNil: [ ^magnifiedIcon ].
	icon ifNil: [ ^nil ].
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		w _ icon width.
		h _ icon height.
		w*h = 0 ifFalse: [
			factor _ 1.0 * extent x / w min: 1.0 * extent y / h.
			factor = 1.0 ifFalse: [
				magnifiedExtent _ (icon extent * factor) rounded.
				magnifiedIcon _ icon magnifyTo: magnifiedExtent ]]].
	^magnifiedIcon! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'jmv 4/4/2022 14:52:16' prior: 16910360 overrides: 16893120!
                             extentChanged: oldExtent
	"Our extent changed. Must layout submorphs again."

	super extentChanged: oldExtent.
	icon ifNotNil: [
		magnifiedIcon _ nil ]! !

PluggableButtonMorph class removeSelector: #model:stateGetter:stateArgument:action:label:!

PluggableButtonMorph removeSelector: #model:stateGetter:stateArgument:action:label:!

PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #PluggableButtonMorph category: 'Morphic-Widgets' stamp: 'Install-5103-PluggableButtonMorph-Enhancements-JuanVuletich-2022Apr08-09h51m-jmv.001.cs.st 5/16/2022 10:22:23'!
PluggableMorph subclass: #PluggableButtonMorph
	instanceVariableNames: 'label font icon stateSelector enableSelector actionSelector isPressed mouseIsOver magnifiedIcon actWhen roundButtonStyle iconName secondaryActionSelector stateArgument actionArgument mouseOverColor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5103-PluggableButtonMorph-Enhancements-JuanVuletich-2022Apr08-09h51m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5103] on 8 April 2022 at 10:33:32 am'!
!MorphicCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:19:20'!
                       privateFrameAndFillGlobalRect: rect fillColor: fillColor borderWidth: borderWidth color: borderColor
	self subclassResponsibility.! !
!MorphicCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:20:16'!
           privateFrameGlobalRect: rect borderWidth: borderWidth color: borderColor
	self subclassResponsibility.! !
!MorphicCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:21:02'!
       privateFrameReverseGlobalRect: r borderWidth: borderWidth
	self subclassResponsibility.! !
!BitBltCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:19:32' overrides: 50340354!
   privateFrameAndFillGlobalRect: rect fillColor: fillColor borderWidth: borderWidth color: borderColor
	"
	(BitBltCanvas onForm: Display)
		privateFrameAndFillGlobalRect: (10@10 extent: 300@200)
		fillColor: Color green
		borderWidth: 20
		color: Color red.
	Display forceToScreen
	"
	engine
		combinationRule: (borderColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: borderColor;
		frameRect: rect borderWidth: borderWidth;
		combinationRule: (fillColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: fillColor;
		fillRect: (rect insetBy: borderWidth).
		! !
!BitBltCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:20:24' overrides: 50340361!
     privateFrameGlobalRect: rect borderWidth: borderWidth color: borderColor
	"
	(BitBltCanvas onForm: Display)
		privateFrameGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20
		color: Color red.
	Display forceToScreen
	"

	engine
		combinationRule: (borderColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: borderColor;
		frameRect: rect borderWidth: borderWidth.! !
!BitBltCanvas methodsFor: 'private-framework' stamp: 'jmv 4/8/2022 10:21:09' overrides: 50340367!
                        privateFrameReverseGlobalRect: rect borderWidth: borderWidth
	"
	(BitBltCanvas onForm: Display)
		privateFrameReverseGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	engine
		sourceForm: nil;
		fillColor: `Color gray`;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth! !
!HaloMorph methodsFor: 'drawing' stamp: 'jmv 4/8/2022 10:20:48' prior: 16864571 overrides: 16794207!
                drawOn: aCanvas 

	| b |
	target ifNil: [^super drawOn: aCanvas].
	"Debugging aid"
	"aCanvas
		fillRectangle: haloBox
		color: (Color red alpha: 0.2).
	aCanvas
		fillRectangle: self morphLocalBounds
		color: (Color gray alpha: 0.4)."
	target haloShowsCoordinateSystem ifTrue: [
		target displayFullBounds ifNotNil: [ :fb |
			aCanvas privateFrameGlobalRect: fb borderWidth: 3 color: `Color black alpha: 0.1`.
			b _ target displayBounds.
			b = fb ifFalse: [
				aCanvas privateFrameGlobalRect: b borderWidth: 3 color: `Color black alpha: 0.1` ].
			self drawCoordinateSystemOn: aCanvas ]].! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 4/8/2022 10:21:25' prior: 50338891!
                         drawCurrentAsOutline

	currentMorph visible ifTrue: [
		self displayBoundsSetOnCurrentMorph.
		self contourClearOnCurrentMorph.
		self privateFrameReverseGlobalRect: currentMorph displayBounds borderWidth: 2 ].! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 4/8/2022 10:19:50' prior: 16896175!
                     drawHighlight: aMorph

	aMorph displayBounds ifNotNil: [ :r |
		self
			privateFrameAndFillGlobalRect: r
			fillColor: `Color pink alpha: 0.2`
			borderWidth: 4
			color: `Color black` ].! !

BitBltCanvas removeSelector: #frameGlobalRect:borderWidth:color:!

!methodRemoval: BitBltCanvas #frameGlobalRect:borderWidth:color: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameGlobalRect: rect borderWidth: borderWidth color: borderColor
	"
	(BitBltCanvas onForm: Display)
		frameGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20
		color: Color red.
	Display forceToScreen
	"

	engine
		combinationRule: (borderColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: borderColor;
		frameRect: rect borderWidth: borderWidth.!

BitBltCanvas removeSelector: #frameAndFillGlobalRect:fillColor:borderWidth:color:!

!methodRemoval: BitBltCanvas #frameAndFillGlobalRect:fillColor:borderWidth:color: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameAndFillGlobalRect: rect fillColor: fillColor borderWidth: borderWidth color: borderColor
	"
	(BitBltCanvas onForm: Display)
		frameAndFillGlobalRect: (10@10 extent: 300@200)
		fillColor: Color green
		borderWidth: 20
		color: Color red.
	Display forceToScreen
	"
	engine
		combinationRule: (borderColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: borderColor;
		frameRect: rect borderWidth: borderWidth;
		combinationRule: (fillColor isOpaque ifTrue: [Form paint] ifFalse: [Form blend]);
		fillColor: fillColor;
		fillRect: (rect insetBy: borderWidth).
		!

BitBltCanvas removeSelector: #frameReverseGlobalRect:borderWidth:!

!methodRemoval: BitBltCanvas #frameReverseGlobalRect:borderWidth: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameReverseGlobalRect: rect borderWidth: borderWidth
	"
	(BitBltCanvas onForm: Display)
		frameReverseGlobalRect: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	engine
		sourceForm: nil;
		fillColor: `Color gray`;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth!

MorphicCanvas removeSelector: #frameReverseGlobalRect:borderWidth:!

!methodRemoval: MorphicCanvas #frameReverseGlobalRect:borderWidth: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameReverseGlobalRect: r borderWidth: borderWidth
	self subclassResponsibility.!

MorphicCanvas removeSelector: #frameGlobalRect:borderWidth:color:!

!methodRemoval: MorphicCanvas #frameGlobalRect:borderWidth:color: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameGlobalRect: rect borderWidth: borderWidth color: borderColor
	self subclassResponsibility.!

MorphicCanvas removeSelector: #frameAndFillGlobalRect:fillColor:borderWidth:color:!

!methodRemoval: MorphicCanvas #frameAndFillGlobalRect:fillColor:borderWidth:color: stamp: 'Install-5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st 5/16/2022 10:22:23'!
frameAndFillGlobalRect: rect fillColor: fillColor borderWidth: borderWidth color: borderColor
	self subclassResponsibility.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5104-clearlyStatePrivateMethods-JuanVuletich-2022Apr08-10h30m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5104] on 8 April 2022 at 4:07:29 pm'!
!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'jmv 4/8/2022 16:05:32'!
                        addSelector: aSymbol

	self protected: [
		Selectors at: aSymbol ifAbsentPut: 0 ].! !
!Preferences class methodsFor: 'initialization' stamp: 'jmv 4/8/2022 16:06:06' prior: 16916067!
          compileAccessMethodForPreference: aPreference
	"Compile an accessor method for the given preference"

	self class compileSilently: (aPreference name, '
	^ self valueOfFlag: #', aPreference name, ' ifAbsent: [', aPreference defaultValue storeString, ']') classified: 'standard queries'.
	SmalltalkCompleter addSelector: aPreference name.! !
!Preferences class methodsFor: 'personalization' stamp: 'jmv 4/8/2022 16:05:45' prior: 16916261!
           compileHardCodedPref: prefName enable: aBoolean
	"Compile a method that returns a simple true or false (depending on the value of aBoolean) when Preferences is sent prefName as a message"

	self class compileSilently: (prefName asString, '
	"compiled programatically -- return hard-coded preference value"
	^ ', aBoolean storeString) classified: 'hard-coded prefs'.
	SmalltalkCompleter addSelector: prefName.
	
"Preferences compileHardCodedPref: #testing enable: false"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5105-AutoPreferences-AddToSmalltalkCompleter-JuanVuletich-2022Apr08-16h02m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5105] on 18 April 2022 at 10:52:39 am'!
!LayoutSpec methodsFor: 'testing' stamp: 'jmv 4/18/2022 10:51:25' prior: 16880452!
                     isProportionalHeight
	"Zero actuaqlly means fixed height."

	^ proportionalHeight notNil and: [ proportionalHeight isZero not ].! !
!LayoutSpec methodsFor: 'testing' stamp: 'jmv 4/18/2022 10:50:58' prior: 16880456!
         isProportionalWidth
	"Zero actuaqlly means fixed width."

	^ proportionalWidth notNil and: [ proportionalWidth isZero not ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5106-LayoutWalkbackFix-JuanVuletich-2022Apr18-10h21m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5106] on 18 April 2022 at 11:07:10 am'!
!BoxedMorph methodsFor: 'window like behavior' stamp: 'jmv 4/18/2022 11:06:19'!
       fullScreen
	"Zoom Window to Full World size with possible DeskMargins"

	| left right possibleBounds |
	(self hasProperty: #originalBounds)
		ifFalse: [ "Expand"
			self setProperty: #originalBounds toValue: self displayBounds.
			left := right := 0.
			possibleBounds := (RealEstateAgent maximumUsableAreaInWorld: self world) 
				insetBy: (left @ 0 corner: right @ 0).
			possibleBounds := possibleBounds insetBy: Theme current fullScreenDeskMargin
		] 
		ifTrue: [ "Contract"
			possibleBounds := self valueOfProperty: #originalBounds.
			self removeProperty: #originalBounds.
		].
	self morphPosition: possibleBounds topLeft extent: possibleBounds extent! !
!BoxedMorph methodsFor: 'window like behavior' stamp: 'jmv 4/18/2022 11:05:48'!
                          resize: boundingBox
	(self hasProperty: #originalBounds) ifFalse: [
		self setProperty: #originalBounds toValue: self displayBounds].
	self morphPosition: boundingBox origin extent: boundingBox extent! !

SystemWindow removeSelector: #resize:!

!methodRemoval: SystemWindow #resize: stamp: 'Install-5107-Move-fullScreen-upInHierarchy-JuanVuletich-2022Apr18-11h05m-jmv.001.cs.st 5/16/2022 10:22:23'!
resize: boundingBox
	(self hasProperty: #originalBounds) ifFalse: [
		self setProperty: #originalBounds toValue: self displayBounds].
	self morphPosition: boundingBox origin extent: boundingBox extent!

SystemWindow removeSelector: #fullScreen!

!methodRemoval: SystemWindow #fullScreen stamp: 'Install-5107-Move-fullScreen-upInHierarchy-JuanVuletich-2022Apr18-11h05m-jmv.001.cs.st 5/16/2022 10:22:23'!
fullScreen
	"Zoom Window to Full World size with possible DeskMargins"

	"SystemWindow fullScreen"

	| left right possibleBounds |
	(self hasProperty: #originalBounds)
		ifFalse: [ "Expand"
			self setProperty: #originalBounds toValue: self displayBounds.
			left := right := 0.
			possibleBounds := (RealEstateAgent maximumUsableAreaInWorld: self world) 
				insetBy: (left @ 0 corner: right @ 0).
			possibleBounds := possibleBounds insetBy: Theme current fullScreenDeskMargin
		] 
		ifTrue: [ "Contract"
			possibleBounds := self valueOfProperty: #originalBounds.
			self removeProperty: #originalBounds.
		].
	self morphPosition: possibleBounds topLeft extent: possibleBounds extent!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5107-Move-fullScreen-upInHierarchy-JuanVuletich-2022Apr18-11h05m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5107] on 21 April 2022 at 2:14:21 pm'!
!Workspace methodsFor: 'variable declarations' stamp: 'jmv 4/21/2022 12:40:46' prior: 16981452!
                          nameForObject: object
	"Answer a name suitable for a Workspace variable"
	^ (object class name, object identityHash printString) asIdentifier: false! !
!ReferencesExplorer methodsFor: 'references' stamp: 'jmv 4/21/2022 12:40:50' prior: 16925300 overrides: 16904267!
                      getList

	| wrapper |
	wrapper _ ReferencesExplorerWrapper
		with: self finder rootNode object
		name: self rootObject identityHash printString
		model: self finder rootNode.
	wrapper finderSkipsClasses: self finder skipClasses.
	^Array with: wrapper! !
!WeightExplorer methodsFor: 'references' stamp: 'jmv 4/21/2022 12:40:54' prior: 16980762 overrides: 50340730!
                    getList

	| wrapper |
	wrapper _ WeightExplorerWrapper
		with: self finder rootNode object
		name: self rootObject identityHash printString
		model: self finder rootNode.
	wrapper finderSkipsClasses: self finder skipClasses.
	^Array with: wrapper! !
!CPUWatcher methodsFor: 'porcine capture' stamp: 'jmv 4/21/2022 12:40:58' prior: 16800225!
           openMorphicWindowForSuspendedProcess: aProcess
	| menu rule |
	menu _ MenuMorph new.
	"nickname  allow-stop  allow-debug"
	rule _ (ProcessBrowser rulesFor: aProcess) second.
	menu add: 'Dismiss this menu' target: menu action: #delete; addLine.
	menu add: 'Open Process Browser' target: ProcessBrowserWindow action: #openProcessBrowser.
	menu add: 'Resume'
		target: self
		action: #resumeProcess:fromMenu:
		argumentList: { aProcess . menu }.
	menu add: 'Terminate'
		target: self
		action: #terminateProcess:fromMenu:
		argumentList: { aProcess . menu }.
	rule ifTrue: [
		menu add: 'Debug at a lower priority'
			target: self
			action: #debugProcess:fromMenu:
			argumentList: { aProcess . menu }.
	].
	menu addTitle: aProcess identityHash printString,
		' ', aProcess name,
		' is taking too much time and has been suspended.
What do you want to do with it?'.
	menu stayUp.
	menu popUpInWorld
! !
!ProcessBrowser methodsFor: 'process list' stamp: 'jmv 4/21/2022 12:45:28' prior: 16918550!
                               processNameList
	"since processList is a WeakArray, we have to strengthen the result"
	| tally |
	tally _ CPUWatcher current ifNotNil: [ :pw | pw tally ].
	^ (processList asOrderedCollection
		copyWithout: nil)
		collect: [:each | | percent |
			percent _ tally
				ifNotNil: [
					(((tally occurrencesOf: each) * 100.0 / tally size) rounded
						printString padded: #left to: 2 with: $ ), '% '  ]
				ifNil: [ '' ].
			percent, (each browserPrintStringFull: false)
		]! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 4/21/2022 11:33:12' prior: 16836998!
         printHMSOn: aStream separator: aChar
	"Print just hh:mm:ss"
	aStream
		nextPutAll: (self hour printString padded: #left to: 2 with: $0);
		nextPut: aChar;
		nextPutAll: (self minute printString padded: #left to: 2 with: $0);
		nextPut: aChar;
		nextPutAll: (self second printString padded: #left to: 2 with: $0).
! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 4/21/2022 12:17:14' prior: 16837021!
       printOn: aStream withLeadingSpace: printLeadingSpaceToo includeOffset: aBoolean
	"Print as per ISO 8601 section 5.4.2
	If printLeadingSpaceToo is false, prints either:
		'YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)
	If printLeadingSpaceToo is true, prints either:
		' YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for positive years) or '-YYYY-MM-DDThh:mm:ss.s+ZZ:zz:z' (for negative years)
	"

	self printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo.
	aStream nextPut: $T.
	self printHMSOn: aStream.
	self nanoSecond ~= 0 ifTrue:
		[ | z ps |
		ps := self nanoSecond printString padded: #left to: 9 with: $0.
		z := ps findLast: [ :c | c numericValue > $0 numericValue ].
		(z > 0) ifTrue: [aStream nextPut: $.].
		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ].
	aBoolean ifTrue: [
		aStream
			nextPut: (offset positive ifTrue: [$+] ifFalse: [$-]);
			nextPutAll: (offset hours abs printString padded: #left to: 2 with: $0);
			nextPut: $:;
			nextPutAll: (offset minutes abs printString padded: #left to: 2 with: $0).
		"Note: We should check the ISO to see if the seconds part is supported by the standard
		(usually not an issue. offsets usually don't include seconds)"
		offset seconds = 0 ifFalse: [
			aStream
				nextPut: $:;
				nextPutAll: (offset seconds abs truncated printString) ]]! !
!DateAndTime methodsFor: 'squeak protocol' stamp: 'jmv 4/21/2022 12:17:20' prior: 16837087!
               printYMDOn: aStream withLeadingSpace: printLeadingSpaceToo
	"Print just the year, month, and day on aStream.

	If printLeadingSpaceToo is true, then print as:
		' YYYY-MM-DD' (if the year is positive) or '-YYYY-MM-DD' (if the year is negative)
	otherwise print as:
		'YYYY-MM-DD' or '-YYYY-MM-DD' "

	| year month day |
	self dayMonthYearDo: [ :d :m :y | year := y. month := m. day := d ].
	year negative
		ifTrue: [ aStream nextPut: $- ]
		ifFalse: [ printLeadingSpaceToo ifTrue: [ aStream space ]].
	aStream
		nextPutAll: (year abs printString padded: #left to: 4 with: $0);
		nextPut: $-;
		nextPutAll: (month printString padded: #left to: 2 with: $0);
		nextPut: $-;
		nextPutAll: (day printString padded: #left to: 2 with: $0)
! !
!DateAndTime methodsFor: 'public protocol' stamp: 'jmv 4/21/2022 12:17:00' prior: 16837249!
    filenamishPrintOn: aStream
	"
	String streamContents: [ :strm | DateAndTime now filenamishPrintOn: strm ]
	"
	
	| year month day monthName |
	self dayMonthYearDo: [ :d :m :y | year := y. month := m. day := d ].
	year negative
		ifTrue: [ aStream nextPut: $- ].
	monthName _ Month nameOfMonth: month.
	aStream
		nextPutAll: (year abs printString padded: #left to: 4 with: $0);
		nextPutAll: (monthName copyFrom: 1 to: 3);
		nextPutAll: (day printString padded: #left to: 2 with: $0);
		nextPut: $-;
		nextPutAll: (self hour printString padded: #left to: 2 with: $0);
		nextPut: $h;
		nextPutAll: (self minute printString padded: #left to: 2 with: $0);
		nextPut: $m! !
!Date methodsFor: 'printing' stamp: 'jmv 4/21/2022 12:44:30' prior: 16836364!
                      printOn: aStream format: formatArray 
	"Print a description of the receiver on aStream using the format 
	denoted the argument, formatArray: 
	
		#(item item item sep monthfmt yearfmt twoDigits) 
	
		items: 1=day 2=month 3=year will appear in the order given, 
	
		separated by sep which is eaither an ascii code or character. 
	
		monthFmt: 1=09 2=Sep 3=September 
	
		yearFmt: 1=1996 2=96 
	
		digits: (missing or)1=9 2=09. 
	
	See the examples in printOn: and mmddyy"
	| gregorian twoDigits element monthFormat |
	gregorian _ self dayMonthYearDo: [ :d :m :y | {d. m. y} ].
	twoDigits _ formatArray size > 6 and: [(formatArray at: 7) > 1].
	1 to: 3 do: 
		[ :i | 
			element := formatArray at: i.
			element = 1
				ifTrue: [twoDigits
						ifTrue: [aStream
								nextPutAll: (gregorian first printString
										padded: #left
										to: 2
										with: $0)]
						ifFalse: [gregorian first printOn: aStream]].
			element = 2
				ifTrue: [monthFormat := formatArray at: 5.
					monthFormat = 1
						ifTrue: [twoDigits
								ifTrue: [aStream
										nextPutAll: (gregorian middle printString
												padded: #left
												to: 2
												with: $0)]
								ifFalse: [gregorian middle printOn: aStream]].
					monthFormat = 2
						ifTrue: [aStream
								nextPutAll: ((Month nameOfMonth: gregorian middle)
										copyFrom: 1
										to: 3)].
					monthFormat = 3
						ifTrue: [aStream
								nextPutAll: (Month nameOfMonth: gregorian middle)]].
			element = 3
				ifTrue: [(formatArray at: 6)
							= 1
						ifTrue: [gregorian last printOn: aStream]
						ifFalse: [aStream
								nextPutAll: ((gregorian last \\ 100) printString
										padded: #left
										to: 2
										with: $0)]].
			i < 3
				ifTrue: [(formatArray at: 4)
							~= 0
						ifTrue: [aStream nextPut: (formatArray at: 4) asCharacter]]]
! !
!Semaphore methodsFor: 'printing' stamp: 'jmv 4/21/2022 12:23:17' prior: 16933187 overrides: 16823635!
                           printOn: aStream
	super printOn: aStream.
	aStream
		nextPutAll: ' with ';
		nextPutAll: excessSignals printString;
		space;
		nextPutAll: ('signal' pluralize: excessSignals ~= 1)! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 4/21/2022 12:38:28' prior: 16896796!
                 displayBulletTextLeft: texLeft number: bulletNumber
	"texLeft is relative to the morph currently being drawn"

	| pattern i c j s bullet bulletPos bulletSize prefix |
	pattern _ paragraphStyle listBulletPattern.
	bullet _ pattern.
	(i _ pattern indexOf: $%) > 0
		ifTrue: [ bullet _ bulletNumber printString]
		ifFalse: [
			(i _ pattern indexOf: $z) > 0
				ifTrue: [ bullet _ (Character numericValue: 96 + bulletNumber) asString ]
				ifFalse: [
					(i _ pattern indexOf: $Z) > 0
						ifTrue: [ bullet _ (Character numericValue: 64 + bulletNumber) asString ]]].
	prefix _ 0.
	i > 0 ifTrue: [
		c _ pattern at: i.
		j _ i.
		s _ pattern size.
		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j _ j + 1 ].
		j _ j - 1.
		bulletSize _ j-i+1.
		prefix _ bulletSize - bullet size max: 0.
		bullet size > bulletSize ifTrue: [
			bullet _ bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].
		bullet _ (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].
	bulletPos _ paragraphStyle firstIndent + texLeft + ((font widthOf: $9) * prefix)@destY.
	canvas
		drawString: bullet
		from: 1
		to: bullet size
		at: bulletPos
		font: font
		color: foregroundColor! !
!CodePackageListWindow methodsFor: 'commands' stamp: 'jmv 4/21/2022 12:46:41' prior: 16820393!
             deletePackage

	| current cs |
	current _ model selection.
	current ifNil: [ ^self ].
	model selectionIndex: 0.	"no selection"
	cs _ ChangeSet existingOrNewChangeSetForPackage: current.
	cs isEmpty ifFalse: [
		cs name: cs hash printString, cs name.
		cs isForBaseSystem: true ].
	CodePackage deregister: current! !
!ChangeSet class methodsFor: 'change set to use' stamp: 'jmv 4/21/2022 12:38:35' prior: 16806699!
  baseSystemNameFor: aChangeSetNumber

	^String streamContents: [ :strm |
	strm
		nextPutAll: (aChangeSetNumber printString padded: #left to: 4 with: $0);
		nextPutAll: '-CuisCore-';
"		nextPutAll: Utilities authorName asCamelCase;"
		nextPutAll: 'AuthorName';
"		nextPutAll: '-';
		nextPutAll: Utilities authorInitials asCamelCase;"
		nextPutAll: '-' ]! !
!SpaceTallyItem methodsFor: 'printing' stamp: 'jmv 4/21/2022 12:48:02' prior: 16944083 overrides: 16902975!
                 printOn: aStream

	analyzedClassName
		ifNotNil: [ aStream nextPutAll: analyzedClassName asString]. 
	aStream nextPutAll: ' ('.
	codeSize
		ifNotNil: [ aStream nextPutAll: 'code size: ' ;  nextPutAll: codeSize printString]. 
	instanceCount
		ifNotNil: [ aStream nextPutAll: ' instance count: ' ;  nextPutAll: instanceCount printString]. 
	spaceForInstances
		ifNotNil: [ aStream nextPutAll: ' space for instances: ' ;  nextPutAll: spaceForInstances printString]. 
	aStream nextPut: $).
	! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 4/21/2022 12:42:11' prior: 16929082!
   scanPast: rangeType level: level
	"first level adds no suffix to the rangeType.
	Suffix from 1 to 7 added in cycles , ((level-2) mod(7) + 1)"
	| cycle typePlusCycle |
	
	cycle := level <= 1 
		ifTrue: [0]
		ifFalse:[ ((level - 2) \\ 7) + 1].
	typePlusCycle := cycle = 0 
		ifTrue:[rangeType]
		ifFalse:[(rangeType, cycle printString) asSymbol].
	^self scanPast: typePlusCycle
! !
!ExtractMethodApplier methodsFor: 'private - parameterizing' stamp: 'jmv 4/21/2022 12:42:59' prior: 16851319!
                      buildInitialSelectorAnswer: parseNodesToParameterize
	"builds a selector with the shape of #m1 if unary, or #m1: something m2: else if it has args"

	^ parseNodesToParameterize
		ifEmpty: [ self formatAsKeyword: 'm1' ]
		ifNotEmpty: [ parseNodesToParameterize
			inject: ''
			into: [ :partialSelector :parseNode |
				| currentKeyword |
				currentKeyword _ 'm' , (parseNodesToParameterize indexOf: parseNode) printString , ': '.
				partialSelector
				, (self formatAsKeyword: currentKeyword)
				, (self formatAsMethodArgument: parseNode name)
				, String newLineString ] ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5108-Number-printString-not-asString-JuanVuletich-2022Apr21-14h13m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5107] on 21 April 2022 at 2:27:53 pm'!
!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 4/21/2022 12:17:39' prior: 16837512 overrides: 16903961!
              readFrom: aStream

	| offset date time ch |

	date _ Date readFrom: aStream.
	[aStream peek isDigit]
		whileFalse: [aStream next].
	time _ Time readFrom: aStream.
	aStream atEnd
		ifTrue: [ offset _ self localOffset ]
		ifFalse: [
			ch _ aStream next.
			ch = $+ ifTrue: [ch _ Character space].
			offset _ Duration fromString: (String with: ch), '0:', aStream upToEnd, ':0'].
		
	^ self
		year: date yearNumber
		month: date monthIndex
		day: date dayOfMonth
		hour: time hour
		minute: time minute
		second: time second
		nanoSecond: time nanoSecond
		offset: offset


	"
		DateAndTime readFrom: '-1199-01-05T20:33:14.321-05:00' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.1+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.02+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.003+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0004+01:01' readStream
  		DateAndTime readFrom: ' 2002-05-16T17:20:45.00005' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000006+01:01' readStream

		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000007+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.00000008-01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.000000009+01:01' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45.0000000001+01:01' readStream

 		DateAndTime readFrom: ' 2002-05-16T17:20' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45' readStream
		DateAndTime readFrom: ' 2002-05-16T17:20:45+01:57' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45-02:34' readStream
 		DateAndTime readFrom: ' 2002-05-16T17:20:45+00:00' readStream
		DateAndTime readFrom: ' 1997-04-26T01:02:03+01:02:3' readStream
 	"! !
!Character methodsFor: 'converting' stamp: 'jmv 4/21/2022 12:18:12' prior: 16808326!
         asText
	^ (String with: self) asText! !
!EventSensor methodsFor: 'test' stamp: 'jmv 4/21/2022 12:19:09' prior: 16849504!
       printEventBuffer: evtBuf
	"Print the event buffer, currently only used by the method `test`."

	| type buttons macRomanCode modifiers pressType stamp unicodeCodePoint |
	type _ evtBuf first.
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	type = EventSensor eventTypeMouse
		ifTrue: [ | position |
			position _ evtBuf third @ evtBuf fourth.
			buttons _ evtBuf fifth.
			modifiers _ evtBuf sixth.
			Transcript
				newLine;
				show: 'Mouse';
				show: ' position:', position printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeMouseScroll
		ifTrue: [ | delta |
			delta _ evtBuf third @ evtBuf fourth.
			buttons _ evtBuf fifth.
			modifiers _ evtBuf sixth.
			Transcript
				newLine;
				show: 'Scroll';
				show: ' delta:', delta printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeKeyboard 
		ifTrue: [
			macRomanCode _ evtBuf third.
			unicodeCodePoint _ evtBuf sixth.
			pressType _ evtBuf fourth.
			modifiers _ evtBuf fifth.
			pressType = EventSensor eventKeyDown ifTrue: [
				type _ #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				type _ #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				type _ #keystroke].
			Transcript
				newLine;
				show: type;
				show: ' macRomanCode:', macRomanCode printString, '-', 
					(Character numericValue: (Character macRomanToLatin1: macRomanCode)) asString, '-';
				show: ' unicodeCodePoint:', unicodeCodePoint printString.
			(Character iso8859s15CodeForUnicodeCodePoint: unicodeCodePoint) ifNotNil: [ :latin15 |
				Transcript show: '-', (String with: (Character numericValue: latin15)), '-' ].
			Transcript
				show: ' modifiers:', modifiers printString.
			(modifiers anyMask: 8) ifTrue: [ Transcript show: ' [commandWinAlt]' ].
			(modifiers anyMask: 4) ifTrue: [ Transcript show: ' [macOption]' ].
			(modifiers anyMask: 2) ifTrue: [ Transcript show: ' [control]' ].
			(modifiers anyMask: 1) ifTrue: [ Transcript show: ' [shift]' ].
			].! !
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 12:19:48' prior: 16948165!
                               asUnHtml
	"Strip out all Html stuff (commands in angle brackets <>) and convert
the characters &<> back to their real value.  Leave actual cr and tab as
they were in text."
	| in out char rest did inString |

	"Hack in some minimal workaround for Unicode stuff"
	inString _ self copyReplaceAll: '‚Äô' with: (String with: $').
	"Check if we can handle this in #safeValue: in some way..."
	inString = self ifFalse: [ self halt ].
	
	in _ ReadStream on: inString.
	out _ WriteStream on: (String new: self size).
	[ in atEnd ] whileFalse: [
		in peek = $<
			ifTrue: [in unCommand] 	"Absorb <...><...>"
			ifFalse: [(char _ in next) = $&
						ifTrue: [rest _ in upTo: $;.
								did _ out position.
								rest = 'lt' ifTrue: [out nextPut: $<].
								rest = 'gt' ifTrue: [out nextPut: $>].
								rest = 'amp' ifTrue: [out nextPut: $&].
								rest = 'deg' ifTrue: [out nextPut: $°].
								rest = 'quot' ifTrue: [out nextPut: $"].
								rest first = $# ifTrue: [ out nextPut: (Character numericValue: rest findPositiveInteger) ].
								did = out position ifTrue: [
									out nextPut: $&; nextPutAll: rest.
									"self error: 'unknown encoded HTML char'."
									"Please add it to this method"]]
						ifFalse: [out nextPut: char]].
		].
	^ out contents! !
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 12:20:42' prior: 16948630!
                     surroundedBySingleQuotes
	"Answer the receiver with leading and trailing quotes.  "

	^ `(String with: $')`, self, `(String with: $')`! !
!Symbol class methodsFor: 'instance creation' stamp: 'jmv 4/21/2022 12:22:42' prior: 16951087!
                       internCharacter: aCharacter

	OneCharacterSymbols ifNil: [^self intern: (String with: aCharacter)].

	^OneCharacterSymbols at: aCharacter numericValue + 1
! !
!Text methodsFor: 'converting' stamp: 'jmv 4/21/2022 13:32:02' prior: 16963797!
                 withCuisLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>"

	| newText wrongLineEnd |
	wrongLineEnd _ String crlfString detect: [ :char | (char = Character newLineCharacter) not ].
	(string includes: wrongLineEnd) ifFalse: [ ^self copy ].
	newText _ self copyReplaceAll: String crlfString with: String newLineString asTokens: false.
	(newText asString includes: wrongLineEnd) ifFalse: [ ^newText ].
	^newText copyReplaceAll: (String with: wrongLineEnd) with: String newLineString asTokens: false.! !
!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 4/21/2022 14:10:29' prior: 16945482 overrides: 16945776!
    nextPut: aCharacter
	"Write the given character or byte to this file.
		 StdIOWriteStream stdout nextPut: $a; flush.
	"
	self nextPutAll: (String with: aCharacter).
	^aCharacter! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/21/2022 11:50:00' prior: 16846081!
              normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	self addString: (String with: aKeyboardEvent keyCharacter).
	^false! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 4/21/2022 12:11:06' prior: 50333069!
                         printIt
	"Treat the current text selection as an expression; evaluate it. Insert the 
	description of the result of evaluation after the selection and then make 
	this description the new text selection."
	| rpt |
	self
		evaluateSelectionAndDo: [ :result |
			rpt _ model fullPrintIt
				ifTrue: [result printText]
				ifFalse: [result printTextLimitedTo: 10000].
			rpt _ rpt copyReplaceAll: String lfString with: String lfString, ' '.
			self afterSelectionInsertAndSelect: 
				((' ', rpt, ' ') initialFontFrom: emphasisHere)]
		ifFail: [ morph flash ]
		profiled: false.! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/21/2022 11:50:34' prior: 16940901 overrides: 50341338!
   normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| stopIndex startIndex string key |
	aKeyboardEvent keyCharacter isLetter ifTrue: [^ super normalCharacter: aKeyboardEvent].
	"Allow to enter named (otherwise untypable) characters like the alpha greek letter as \alpha."
	string _ self privateCurrentString.
	stopIndex _ self pointIndex - 1.
	(stopIndex between: 2 and: string size)
		ifFalse: [^ super normalCharacter: aKeyboardEvent].
	startIndex _ stopIndex.
	"Look backwards and find a character that is not a letter (we want to find '\' just a few characters behind):"
	[startIndex > 0 and: [stopIndex - startIndex < 7 and: [(string at: startIndex) isLetter]]] whileTrue: [startIndex _ startIndex - 1].
	(startIndex > 0 and: [(string at: startIndex) = $\])
		ifFalse: [^ super normalCharacter: aKeyboardEvent].
	key _ string copyFrom: startIndex+1 to: stopIndex.
	(Character namedCharactersTable detect: [:one| key = one first] ifNone: [])
		ifNotNil: [:aPair| self selectFrom: startIndex to: stopIndex; replaceSelectionWith: (String with: aPair second)].
	^ super normalCharacter: aKeyboardEvent! !
!MorphicScanner methodsFor: 'scanning' stamp: 'jmv 4/21/2022 12:30:58' prior: 50340983!
displayBulletTextLeft: texLeft number: bulletNumber
	"texLeft is relative to the morph currently being drawn"

	| pattern i c j s bullet bulletPos bulletSize prefix |
	pattern _ paragraphStyle listBulletPattern.
	bullet _ pattern.
	(i _ pattern indexOf: $%) > 0
		ifTrue: [ bullet _ bulletNumber printString]
		ifFalse: [
			(i _ pattern indexOf: $z) > 0
				ifTrue: [ bullet _ String with: (Character numericValue: 96 + bulletNumber) ]
				ifFalse: [
					(i _ pattern indexOf: $Z) > 0
						ifTrue: [ bullet _ String with: (Character numericValue: 64 + bulletNumber) ]]].
	prefix _ 0.
	i > 0 ifTrue: [
		c _ pattern at: i.
		j _ i.
		s _ pattern size.
		[ j <= s and: [ (pattern at: j) = c ] ] whileTrue: [ j _ j + 1 ].
		j _ j - 1.
		bulletSize _ j-i+1.
		prefix _ bulletSize - bullet size max: 0.
		bullet size > bulletSize ifTrue: [
			bullet _ bullet copyFrom: bullet size - bulletSize + 1 to: bullet size ].
		bullet _ (pattern copyFrom: 1 to: i-1), bullet, (pattern copyFrom: j+1 to: pattern size) ].
	bulletPos _ paragraphStyle firstIndent + texLeft + ((font widthOf: $9) * prefix)@destY.
	canvas
		drawString: bullet
		from: 1
		to: bullet size
		at: bulletPos
		font: font
		color: foregroundColor! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 4/21/2022 11:36:42' prior: 16928939!
                  scanBinary
	| c d |
	c := self currentChar.
	currentTokenSourcePosition := sourcePosition.
	currentToken := String with: c.
	d := self nextChar.
	((self isBinarySelectorCharacter: c) or: [c == $:]) ifFalse: [^currentToken].
	(c == $: and: [d == $=]) 
		ifTrue: [" := assignment"
			currentToken := currentToken , (String with: d).
			self nextChar.
			^currentToken].
	(c == $| and: [d == $|])
		ifTrue: ["|| empty temp declaration"
			^currentToken].
	c _ d.
	[
		d _ self peekChar.
		c == $-
			ifTrue: [ d isDigit not ]
			ifFalse: [ self isBinarySelectorCharacter: c ]
	]
		whileTrue: [
			currentToken _ currentToken copyWith: c.
			c _ self nextChar ].
	^currentToken! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5109-String-with-character-not-character-asString-JuanVuletich-2022Apr21-14h14m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5109] on 22 April 2022 at 11:59:26 am'!
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 11:43:33'!
                     asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!Symbol methodsFor: 'converting' stamp: 'jmv 4/21/2022 11:43:54' overrides: 50341481!
                        asPlainString
	"Answer a plain String, not a Symbol."
	| newString |
	newString _ String new: self size.
	1 to: self size do: [:index | newString at: index put: (self at: index)].
	^newString! !
!Text methodsFor: 'converting' stamp: 'jmv 4/21/2022 11:44:03'!
                             asPlainString
	"Answer a plain String, not a Text."
	^string! !
!Object methodsFor: 'accessing' stamp: 'jmv 4/21/2022 12:12:08' prior: 16901498!
               addInstanceVarNamed: aName withValue: aValue
	"Add an instance variable named aName and give it value aValue"
	self class addInstVarName: aName asPlainString.
	self instVarAt: self class instSize put: aValue! !
!Object methodsFor: 'error handling' stamp: 'jmv 4/21/2022 12:12:44' prior: 16902188!
                       primitiveFailed: selector
	"Announce that a primitive has failed and there is no appropriate 
	Smalltalk code to run."

	self error: selector asPlainString, ' failed'! !
!Object methodsFor: 'system primitives' stamp: 'jmv 4/21/2022 12:12:17' prior: 16903149!
                             className
	"Answer a string characterizing the receiver's class, for use in list views for example"

	^ self class name asPlainString! !
!Object methodsFor: 'system primitives' stamp: 'jmv 4/21/2022 12:12:34' prior: 16903240!
                              instVarNamed: aString
	"Return the value of the instance variable in me with that name.  Slow and unclean, but very useful. "

	^ self instVarAt: (self class allInstVarNames indexOf: aString asPlainString)


! !
!Object methodsFor: 'system primitives' stamp: 'jmv 4/21/2022 12:12:38' prior: 16903249!
                   instVarNamed: aString put: aValue
	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful. "

	^ self instVarAt: (self class allInstVarNames indexOf: aString asPlainString) put: aValue
! !
!TextModel methodsFor: 'as yet unclassified' stamp: 'jmv 4/21/2022 12:12:51' prior: 16968959!
                      saveOn: stream as: format
	"Saves the model to the given stream"
	stream binary.
	stream nextPutAll: self actualContents asPlainString.! !
!Workspace methodsFor: 'shout styling' stamp: 'jmv 4/21/2022 11:48:30' prior: 16981489!
                             toggleStyling

	shouldStyle _ self shouldStyle not.
	actualContents _ actualContents asPlainString asText.
	self changed: #actualContents! !
!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 4/21/2022 12:13:05' prior: 16821535!
                    copySelector
	"Copy the selected selector to the clipboard"

	| selector |
	(selector _ self selectedMessageName) ifNotNil: [
		Clipboard storeObject: selector asPlainString]! !
!Browser methodsFor: 'accessing' stamp: 'jmv 4/21/2022 11:55:18' prior: 16795049!
                            contents: input notifying: aRequestor
	"The retrieved information has changed and its source must now be
	 updated. The information can be a variety of things, depending on
	 the list selections (such as templates for class or message definition,
	 methods) or the user menu commands (such as definition, comment).
	Answer the result of updating the source."

	| aString aText theClass |
	aString _ input asPlainString.
	aText _ input asText.
	editSelection == #editSystemCategories ifTrue: [ ^ self changeSystemCategories: aString ].
	self isEditingClass ifTrue: [
		[
			self defineClass: aString notifying: aRequestor 
		] on: RecompilationFailure do: [ :ex |
			self inform: ex messageText.
			^ false].
		^ true].
	editSelection == #editComment
		ifTrue: [
			theClass _ self selectedClass.
			theClass
				ifNil: [
					self inform: 'You must select a class
before giving it a comment.'.
					^ false].
			theClass comment: aText stamp: Utilities changeStamp.
			self changed: #classCommentText.
			^ true].
	editSelection == #editMessageCategories ifTrue: [ ^ self changeMessageCategories: aString ].
	editSelection == #editMessage | (editSelection == #newMessage)
		ifTrue: [
			^ self okayToAccept
				ifFalse:[ false ]
				ifTrue: [
					(self compileMessage: aText notifying: aRequestor)
						ifTrue: [ self triggerEvent: #annotationChanged ];
						yourself ]].
	editSelection == #none
		ifTrue: [
			self inform: 'This text cannot be accepted
in this part of the browser.'.
			^ false].
	self error: 'unacceptable accept'! !
!Browser methodsFor: 'class comment pane' stamp: 'jmv 4/21/2022 11:51:10' prior: 16795169!
  newClassComment: aText
	"The user has just entered aText.
	It may be all red (a side-effect of replacing the default comment), so remove the color if it is."
	| theClass |
	theClass _ self selectedClassOrMetaClass theNonMetaClass.
	theClass ifNotNil: [
		theClass classComment: aText asPlainString ].
	self changed: #classCommentText.
	^ true! !
!Browser methodsFor: 'class functions' stamp: 'jmv 4/21/2022 12:13:11' prior: 50334105!
              defineClass: defString notifying: aRequestor  
	"The receiver's textual content is a request to define a new class. The
	source code is defString. If any errors occur in compilation, notify
	aRequestor."
	| oldClass class newClassName defTokens keywdIx |
	oldClass _ self selectedClassOrMetaClass.
	defTokens _ defString findTokens: Character separators.
	keywdIx _ defTokens findFirst: [ :x | x beginsWith: 'category' ].
	keywdIx _ defTokens findFirst: [ :x | '*subclass*' match: x ].
	newClassName _ (defTokens at: keywdIx+1) copyWithoutAll: '#()'.
	((oldClass isNil or: [ oldClass theNonMetaClass name asPlainString ~= newClassName ])
		and: [ Smalltalk includesKey: newClassName asSymbol ]) ifTrue: [
			"Attempting to define new class over existing one when
				not looking at the original one in this browser..."
			(self confirm: (newClassName bold , ' is an existing class in this system.
Redefining it might cause serious problems.
Is this really what you want to do?'))
				ifFalse: [ ^ false ]].
	"ar 8/29/1999: Use oldClass superclass for defining oldClass
	since oldClass superclass knows the definerClass of oldClass."
	oldClass ifNotNil: [ oldClass _ oldClass superclass ].
	class _ Compiler
				evaluate: defString
				notifying: aRequestor
				logged: true.
	(class isKindOf: Behavior)
		ifTrue: [
				self changed: #systemCategoryRoots.
				self changed: #classList.
				self changed: #clearUserEdits.
				self setClass: class selector: nil.
				"self clearUserEditFlag; editClass."
				^ true ]
		ifFalse: [ ^ false ]! !
!MessageNames methodsFor: 'search' stamp: 'jmv 4/21/2022 12:13:33' prior: 16883920!
        searchString: aString
	"Take what the user typed and find all selectors containing it"

	searchString _ aString asPlainString.
	self changed: #relabel.
	selectorList _ nil.
	self changed: #selectorList.
	self changed: #messageList.
	^ true! !
!ProtocolBrowser methodsFor: 'accessing' stamp: 'jmv 4/21/2022 12:13:43' prior: 16920513 overrides: 16886909!
                               labelString
	"Answer the string for the window title"
	
	^ 'Protocol for: ', baseClass name, ' up to: ', (selectedName ifNil: [ ProtoObject name asPlainString ])! !
!ChangeList methodsFor: 'scanning' stamp: 'jmv 4/21/2022 12:13:48' prior: 16801419!
       classDefinitionRecordFrom: tokens
	
	| classDefinition isMeta itemPosition className record fullClassName category stamp |
	
	itemPosition _ file position.
	fullClassName _ tokens second.
	isMeta _ fullClassName includesSubString: ' class'.
	className _ isMeta ifTrue: [fullClassName substrings first] ifFalse: [fullClassName].
	category _ CompiledMethod classCategoryFrom: tokens.
	stamp _ CompiledMethod stampFrom: tokens.
	classDefinition _ file nextChunk.
	
	record _ ChangeRecord new 
		file: file 
		position: itemPosition 
		type: #classDefinition 
		class: className asSymbol 
		category: category 
		meta: isMeta 
		stamp: stamp.
		
	record markAsTest: (classDefinition beginsWith: TestCase name asPlainString).
	
	^record
! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 4/21/2022 12:13:56' prior: 16801730!
        compareToCurrentVersion
	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"

	| change class s1 s2 differDesc diffWords |
	listIndex = 0
		ifTrue: [^ self].
	change _ changeList at: listIndex.
	((class _ change changeClass) notNil
			and: [class includesSelector: change methodSelector])
		ifTrue: [
			s1 _ (class sourceCodeAt: change methodSelector) asPlainString.
			s2 _ change string.
			s1 = s2
				ifTrue: [^ self inform: 'Exact Match'].
			diffWords _ self shouldDiffWords.
			differDesc _ diffWords
				ifTrue: [ 'Words']
				ifFalse: [ 'Lines'].
			(TextModel
				withText: (
					(DifferenceFinder
						displayPatchFrom: s1 to: s2
						tryWords: diffWords
						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))
							font: Preferences standardCodeFont))
				openLabel: 'Comparison to Current Version: ', differDesc, 
					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]
		ifFalse: [self flash]! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 4/21/2022 12:13:58' prior: 16802172!
      selectUnchangedMethods
	"Selects all method definitions for which there is already a method in the current image, whose source is exactly the same.  9/18/96 sw"

	| change class |
	1 to: changeList size do: [ :i | 
		change _ changeList at: i.
		listSelections at: i put:
			((change changeType == #method and:
				[(class _ change changeClass) notNil]) and:
					[(class includesSelector: change methodSelector) and:
						[change string = (class sourceCodeAt: change methodSelector) asPlainString ]])].
	self changed: #allSelections.
	self changed: #annotation! !
!Debugger class methodsFor: 'opening' stamp: 'jmv 4/21/2022 12:14:04' prior: 16839003!
                   openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	Preferences logDebuggerStackToFile ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	w := UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !
!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 4/21/2022 12:14:07' prior: 16855597!
     pattern: textOrStringOrNil

	textOrStringOrNil
		ifNil: [pattern _ '*']
		ifNotNil: [pattern _ textOrStringOrNil asPlainString].
	self updateFileList.
	^ true
! !
!FileList methodsFor: 'private' stamp: 'jmv 4/21/2022 11:51:15' prior: 16855693!
            put: aText
	"Private - put the supplied text onto the file"

	| nameUsed type |
	brevityState == #fullFile ifTrue: [
		directory // fileName writeStreamDo: [ :stream |
			nameUsed _ stream name.
			stream nextPutAll: aText asPlainString ].
		fileName = nameUsed
			ifTrue: [ acceptedContentsCache _ aText asPlainString]
			ifFalse: [self updateFileList].		"user chose a different name (instead of overwriting)"
		^ true  "accepted"].

	listIndex = 0 ifTrue: [
		self inform: 'No fileName is selected'.
		^ false  "failed"].
	type _ 'These'.
	brevityState = #briefFile ifTrue: [type _ 'Abbreviated'].
	brevityState = #briefHex ifTrue: [type _ 'Abbreviated'].
	brevityState = #fullHex ifTrue: [type _ 'Hexadecimal'].
	brevityState = #FileList ifTrue: [type _ 'Directory'].
	self inform: ('{1} contents cannot
meaningfully be saved at present.' format:{type}).
	^ false  "failed"
! !
!SimpleServiceEntry methodsFor: 'printing' stamp: 'jmv 4/21/2022 12:14:12' prior: 16936592 overrides: 16902975!
                               printOn: aStream

	aStream nextPutAll: self class name; nextPutAll: ': ('.
	self provider
		ifNotNil: [ aStream nextPutAll: provider printString].
	aStream nextPutAll: ' --- '. 
	self selector
		ifNotNil: [ aStream nextPutAll: selector asPlainString].
	aStream nextPut: $)

! !
!Behavior methodsFor: 'accessing method dictionary' stamp: 'jmv 4/21/2022 12:15:27' prior: 16785905!
     firstCommentAt:  selector
	"Answer a string representing the first comment in the method associated with selector.  Return an empty string if the relevant source file is not available, or if the method's source code does not contain a comment.  Not smart enough to bypass quotes in string constants, but does map doubled quote into a single quote."

	| sourceString commentStart  pos nextQuotePos |

	sourceString _ (self sourceCodeAt: selector) asPlainString.
	sourceString size = 0 ifTrue: [^ ''].
	commentStart _ sourceString findString: '"' startingAt: 1.
	commentStart = 0 ifTrue: [^ ''].
	pos _ commentStart + 1.
	[(nextQuotePos _ sourceString findString: '"' startingAt: pos) = (sourceString findString: '""' startingAt: pos)]
		whileTrue:
			[pos _ nextQuotePos + 2].
	
	commentStart = nextQuotePos ifTrue: [^ ''].  "Must have been a quote in string literal"

	^ (sourceString copyFrom: commentStart + 1 to: nextQuotePos - 1) copyReplaceAll: '""' with: '"'


"Behavior firstCommentAt: #firstCommentAt:"! !
!Behavior methodsFor: 'accessing method dictionary' stamp: 'jmv 4/21/2022 12:15:31' prior: 16786142!
     standardMethodHeaderFor: aSelector
	| args |
	args _ (1 to: aSelector numArgs)	collect:[:i| 'arg', i printString].
	args size = 0 ifTrue:[^aSelector asPlainString].
	args size = 1 ifTrue:[^aSelector,' arg1'].
	^String streamContents:[:s|
		(aSelector findTokens: ':') with: args do: [ :tok :arg |
			s nextPutAll: tok; nextPutAll:': '; nextPutAll: arg; nextPutAll:' '.
		].
	].
! !
!ClassDescription methodsFor: 'accessing' stamp: 'jmv 4/21/2022 11:51:22' prior: 16813790!
       comment: aStringOrText
	"Set the receiver's comment to be the argument, aStringOrText."

	self theNonMetaClass classComment: aStringOrText asPlainString.! !
!ClassDescription methodsFor: 'accessing' stamp: 'jmv 4/21/2022 11:51:27' prior: 16813798!
        comment: aStringOrText stamp: aStamp
	"Set the receiver's comment to be the argument, aStringOrText."

	self theNonMetaClass classComment: aStringOrText asPlainString stamp: aStamp.! !
!ClassDescription methodsFor: 'compiling' stamp: 'jmv 4/21/2022 11:51:05' prior: 16814138!
            compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource
	| methodAndNode selector isExistingMethod |
	methodAndNode _ self basicCompile: text asPlainString notifying: requestor 
							trailer: self defaultMethodTrailer ifFail: [^nil].
	selector _ methodAndNode selector.
	isExistingMethod _ self includesSelector: selector.
	isExistingMethod
		ifTrue: [
			(self theNonMetaClass isOkToChangeMethod: selector isMeta: self isMeta)
				ifFalse: [self error: 'Method modification not allowed']]
		ifFalse: [
			(self theNonMetaClass isOkToAddMethod: selector isMeta: self isMeta)
				ifFalse: [self error: 'Method addition not allowed']].
	logSource ifTrue: [
		self logMethodSource: text forMethodWithNode: methodAndNode 
			inCategory: category withStamp: changeStamp notifying: requestor.
	].
	self addAndClassifySelector: selector withMethod: methodAndNode 
		method inProtocol: category notifying: requestor.
	^ methodAndNode selector! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/21/2022 12:15:51' prior: 16814593!
            fileOutMethod: selector
	"Write source code of a single method on a file.  Make up a name for the file."

	| nameBody |
	(selector == #Comment) ifTrue: [^ self inform: 'Sorry, cannot file out class comment in isolation.'].
	(self includesSelector: selector) ifFalse: [^ self error: 'Selector ', selector asPlainString, ' not found'].
	nameBody _ self name , '-' , (selector copyReplaceAll: ':' with: '').
	DirectoryEntry smalltalkImageDirectory // (nameBody asFileName, '.st') writeStreamDo: [ :fileStream |
		fileStream timeStamp.
		self printMethodChunk: selector withPreamble: true
			on: fileStream moveSource: false toFile: 0 ]! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/21/2022 12:16:07' prior: 16814823!
        printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex
	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."
	| preamble method oldPos newPos sourceFile endPos |
	doPreamble 
		ifTrue: [preamble _ self name , ' methodsFor: ' ,
					(self organization categoryOfElement: selector) asPlainString printString]
		ifFalse: [preamble _ ''].
	method _ self methodDict at: selector ifAbsent: [
		outStream nextPutAll: selector; newLine.
		outStream tab; nextPutAll: '** ERROR  -  THIS METHOD IS MISSING ** '; newLine; newLine.
		outStream nextPutAll: '  '.
		^ outStream].

	((method fileIndex = 0
		or: [(SourceFiles at: method fileIndex) == nil])
		or: [(oldPos _ method filePosition) = 0])
	ifTrue: [
		"The source code is not accessible.  We must decompile..."
		preamble size > 0 ifTrue: [ outStream newLine; nextPut: $!!; nextChunkPut: preamble; newLine].
		outStream nextChunkPut: method decompileString]
	ifFalse: [
		sourceFile _ SourceFiles at: method fileIndex.
		preamble size > 0
			ifTrue:    "Copy the preamble"
				[outStream copyPreamble: preamble from: sourceFile at: oldPos]
			ifFalse:
				[sourceFile position: oldPos].
		"Copy the method chunk"
		fileIndex = 0 ifFalse: [
			outStream padTo: SourceFiles pointerScaleForWriting put: $  ].
		newPos _ outStream position.
		outStream copyMethodChunkFrom: sourceFile.
		moveSource ifTrue: [    "Set the new method source pointer"
			endPos _ outStream position.
			method checkOKToAdd: endPos - newPos at: newPos in: method fileIndex.
			method setSourcePosition: newPos inFile: fileIndex]].
	preamble size > 0 ifTrue: [ outStream nextChunkPut: ' ' ].
	^ outStream newLine! !
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 4/21/2022 12:15:44' prior: 16815329!
                           classThatDefinesInstanceVariable: instVarName
	(instanceVariables notNil and: [instanceVariables includes: instVarName asPlainString]) ifTrue: [^ self]. 
	^ superclass ifNotNil: [superclass classThatDefinesInstanceVariable: instVarName]! !
!ClassDescription methodsFor: 'private' stamp: 'jmv 4/21/2022 11:51:40' prior: 16815590!
                       logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor
	| priorMethodOrNil overridenMethodOrNil |
	
	priorMethodOrNil := self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: nil.
	overridenMethodOrNil := self superclass ifNotNil: [ :aSuperclass | 
		aSuperclass lookupSelector: aCompiledMethodWithNode selector ].
	
	aCompiledMethodWithNode method 
		putSource: aText asPlainString
		fromParseNode: aCompiledMethodWithNode node
		class: self 
		category: category 
		withStamp: changeStamp 
		inFile: 2 
		priorMethod: priorMethodOrNil 
		overridesMethod: overridenMethodOrNil.! !
!Class class methodsFor: 'instance creation' stamp: 'jmv 4/21/2022 12:03:15' prior: 16811073!
    templateForSubclassOf: priorClassName category: systemCategoryName 
	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"

	^ priorClassName asPlainString, ' subclass: #NameOfSubclass
	instanceVariableNames: ''''
	classVariableNames: ''''
	poolDictionaries: ''''
	category: ''' , systemCategoryName asPlainString , ''''! !
!ClassBuilder class methodsFor: 'cleanup obsolete classes' stamp: 'jmv 4/21/2022 12:16:44' prior: 16812677!
                       cleanupClassHierarchyFor: aClassDescription
	
	| myName mySuperclass |
	mySuperclass _ aClassDescription superclass.
	(self isReallyObsolete: aClassDescription) ifTrue: [
		
		"Remove class >>>from SystemDictionary if it is obsolete"
		myName _ aClassDescription name asPlainString.
		Smalltalk keys do: [:each | 
			(each asPlainString = myName and: [(Smalltalk at: each) == aClassDescription])
				ifTrue: [Smalltalk removeKey: each]].

		"Make class officially obsolete if it is not"
		(aClassDescription name asPlainString beginsWith: 'AnObsolete')
			ifFalse: [aClassDescription obsolete].

		aClassDescription isObsolete 
			ifFalse: [self error: 'Something wrong!!'].

		"Add class to obsoleteSubclasses of its superclass"
		mySuperclass
			ifNil: [self error: 'Obsolete subclasses of nil cannot be stored'].
		(mySuperclass obsoleteSubclasses includes: aClassDescription)
			ifFalse: [mySuperclass addObsoleteSubclass: aClassDescription].
	] ifFalse:[
		"check if superclass has aClassDescription in its obsolete subclasses"
		mySuperclass ifNil:[mySuperclass _ Class]. "nil subclasses"
		mySuperclass removeObsoleteSubclass: aClassDescription.
	].
	"And remove its obsolete subclasses if not actual superclass"
	aClassDescription obsoleteSubclasses do:[:obs|
		obs superclass == aClassDescription ifFalse:[
			aClassDescription removeObsoleteSubclass: obs]].
! !
!ContextPart methodsFor: 'debugger access' stamp: 'jmv 4/21/2022 12:18:44' prior: 16832301!
        errorReportOn: strm
	"Write a detailed error report on the stack (above me) on a stream.  For both the error file, and emailing a bug report.  Suppress any errors while getting printStrings.  Limit the length."

	| cnt aContext startPos |
 	strm print: Date today; space; print: Time now; newLine.
	strm newLine.
	strm nextPutAll: 'VM: ';
		nextPutAll: Smalltalk platformName;
		nextPutAll: ' - ';
		nextPutAll: Smalltalk vmVersion;
		newLine.
	strm nextPutAll: 'Image: ';
		nextPutAll: Smalltalk version;
		nextPutAll: ' [';
		nextPutAll: Smalltalk lastUpdateString;
		nextPutAll: ']';
		newLine.
	strm newLine.
	
	"Note: The following is an open-coded version of ContextPart>>stackOfSize: since this method may be called during a low space condition and we might run out of space for allocating the full stack."
	cnt _ 0.  startPos _ strm position.
	aContext _ self.
	[aContext notNil and: [(cnt _ cnt + 1) < Debugger defaultDebugStackSize]] whileTrue: [
		aContext printDetails: strm.	"variable values"
		strm newLine.
		aContext _ aContext sender].

	strm newLine; nextPutAll: '--- The full stack ---'; newLine.
	aContext _ self.
	cnt _ 0.
	[aContext == nil] whileFalse: [
		cnt _ cnt + 1.
		cnt = Debugger defaultDebugStackSize ifTrue: [strm nextPutAll: ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'; newLine ].
		strm print: aContext; newLine.  "just class>>selector"	

		strm position > (startPos+40000) ifTrue: [strm nextPutAll: '...etc...'.
			^ self]. 	"exit early"
		cnt > 100 ifTrue: [strm nextPutAll: '-- and more not shown --'.  ^ self].
		aContext _ aContext sender].
! !
!CompiledMethod methodsFor: 'printing' stamp: 'jmv 4/21/2022 14:05:52' prior: 16828523!
                              printPrimitiveOn: aStream
	"Print the primitive on aStream"
	| primIndex primDecl |
	(primIndex := self primitive) = 0 ifTrue:
		[^self].
	primIndex = 120 ifTrue: "External call spec"
		[^aStream print: (self literalAt: 1); newLine].
	aStream nextPutAll: '<primitive: '.
	primIndex = 117
		ifTrue: [
			primDecl := self literalAt: 1.
			(primDecl at: 2) asPlainString printOn: aStream.
			(primDecl at: 1) ifNotNil: [ :moduleName |
				aStream nextPutAll:' module: '.
				moduleName asPlainString printOn: aStream]]
		ifFalse: [
			aStream print: primIndex].
	self primitiveErrorVariableName ifNotNil: [ :primitiveErrorVariableName |
		aStream nextPutAll: ' error: '; nextPutAll: primitiveErrorVariableName].
	aStream nextPut: $>; newLine! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/21/2022 12:23:33' prior: 16963529!
           findString: aString startingAt: start 
	"Answer the index of subString within the receiver, starting at position start.
	If the receiver does not contain subString, answer 0."

	^string findString: aString asPlainString startingAt: start! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/21/2022 12:23:37' prior: 16963539!
findString: aString startingAt: start caseSensitive: caseSensitive
	"Answer the index of subString within the receiver, starting at index 
	start. If the receiver does not contain subString, answer 0."

	^string findString: aString asPlainString startingAt: start caseSensitive: caseSensitive! !
!Text methodsFor: 'converting' stamp: 'jmv 4/21/2022 11:52:11' prior: 50341308!
        withCuisLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>"

	| newText wrongLineEnd |
	wrongLineEnd _ String crlfString detect: [ :char | (char = Character newLineCharacter) not ].
	(string includes: wrongLineEnd) ifFalse: [ ^self copy ].
	newText _ self copyReplaceAll: String crlfString with: String newLineString asTokens: false.
	(newText asPlainString includes: wrongLineEnd) ifFalse: [ ^newText ].
	^newText copyReplaceAll: (String with: wrongLineEnd) with: String newLineString asTokens: false.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/21/2022 12:27:00' prior: 16952125!
                obsoleteClasses   "Smalltalk obsoleteClasses inspect"
	"NOTE:  Also try inspecting comments below"
	| obs c |
	obs _ OrderedCollection new.  Smalltalk garbageCollect.
	Metaclass allInstancesDo:
		[:m | c _ m soleInstance.
		(c notNil and: ['AnOb*' match: c name asPlainString])
			ifTrue: [obs add: c]].
	^ obs asArray

"Likely in a ClassDict or Pool...
(Association allInstances select: [:a | (a value isKindOf: Class) and: ['AnOb*' match: a value name]]) asArray
"
"Obsolete class refs or super pointer in last lit of a method...
| n l found |
Smalltalk browseAllSelect:
	[:m | found _ false.
	1 to: m numLiterals do:
		[:i | (((l _ m literalAt: i) isMemberOf: Association)
				and: [(l value isKindOf: Behavior)
				and: ['AnOb*' match: l value name]])
			ifTrue: [found _ true]].
	found]
"! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 4/21/2022 12:27:24' prior: 16952296!
     testFormatter2
	"Smalltalk testFormatter2"
	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.
	The formatting used will be classic monochrome"
	| newCodeString badOnes n oldCodeString oldTokens newTokens |
	badOnes _ OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldCodeString _ (cls sourceCodeAt: selector) asPlainString.
					newCodeString _ cls compilerClass new
						format: oldCodeString
						in: cls
						notifying: nil.
					oldTokens _ oldCodeString findTokens: Character separators.
					newTokens _ newCodeString findTokens: Character separators.
					oldTokens = newTokens ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes
		name: 'Formatter Discrepancies'.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 4/21/2022 12:24:39' prior: 16953900!
           allMethodsSourceStringMatching: aString
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.
	Search the class comments also.
	Argument might include $*, that matches any subsequence.
	For example, try:
		ensure:*[*close*]
	"
	| list classCount adder |
	list _ Set new.
	adder _ [ :mrClass :mrSel |
		list add: (MethodReference class: mrClass selector: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size
		during: [ :barBlock |
			classCount _ 0.
			Smalltalk allClassesDo: [ :class |
				barBlock value: (classCount _ classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						(aString match: (cl sourceCodeAt: sel)) ifTrue: [
							adder
								value: cl
								value: sel ]].

					(aString match: cl organization classComment) ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 4/21/2022 12:24:43' prior: 16953935!
                      allMethodsWithSourceString: aString matchCase: caseSensitive
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"
	| list classCount adder |
	list _ Set new.
	adder _ [ :mrClass :mrSel |
		list add: (MethodReference class: mrClass selector: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size
		during: [ :barBlock |
			classCount _ 0.
			Smalltalk allClassesDo: [ :class |
				barBlock value: (classCount _ classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						((cl sourceCodeAt: sel)
							findString: aString
							startingAt: 1
							caseSensitive: caseSensitive) > 0 ifTrue: [
							adder
								value: cl
								value: sel ]].
					(cl organization classComment
						findString: aString
						startingAt: 1
						caseSensitive: caseSensitive) > 0 ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 4/21/2022 13:55:07' prior: 16954061!
                       allPrimitiveMethodsInCategories: aList
	"Answer an OrderedCollection of all the methods that are implemented by primitives in the given categories.  1/26/96 sw"

	| aColl method | 
	aColl _ OrderedCollection new: 200.
	self allBehaviorsDo: [ :aClass |
		(aList includes: (SystemOrganization categoryOfElement: aClass theNonMetaClass name asPlainString) asPlainString)
			ifTrue: [
				aClass selectorsDo: [ :sel | 
					method _ aClass compiledMethodAt: sel.
					method primitive ~= 0
						ifTrue: [
							aColl addLast: aClass name , ' ' , sel 
								, ' ' , method primitive printString]]]].
	^ aColl

"Smalltalk allPrimitiveMethodsInCategories: #('Collections-Streams' 'Files-Streams' 'Files-Abstract' 'Files-Macintosh')"! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 4/21/2022 12:26:01' prior: 16955505!
                              assureStartupStampLogged
	"If there is a startup stamp not yet actually logged to disk, do it now."
	| changesFile directory oldUserChanges oldUserChangesName |
	StartupStamp ifNil: [^ self].
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			changesFile nextChunkPut: StartupStamp; newLine.
			self forceChangesToDisk ]].
	Preferences autoNumberUserChanges ifTrue: [
		oldUserChanges _ Smalltalk defaultUserChangesName asFileEntry.
		oldUserChanges exists ifTrue: [
			directory _ oldUserChanges parent.
			oldUserChangesName _ directory nextNameFor: oldUserChanges nameWithoutExtension extension: 'changes'.
			oldUserChanges rename: oldUserChangesName ]].
	Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
		stream newLine; newLine.
		stream nextChunkPut: StartupStamp; newLine ].
	StartupStamp _ nil! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'jmv 4/21/2022 11:52:20' prior: 16955733!
             logChange: aStringOrText preamble: preambleOrNil
	"Write the argument, aString, onto the changes file."
	| aString changesFile |
	self assureStartupStampLogged.
	aString _ aStringOrText asPlainString.
	aString firstNoBlankIndex = 0 ifTrue: [^ self].  "null doits confuse replay"
	
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			preambleOrNil ifNotNil: [
				changesFile nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			changesFile nextChunkPut: aString.
			self forceChangesToDisk ]].
	Utilities logsUserChanges ifTrue: [
		Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
			stream newLine; newLine.
			preambleOrNil ifNotNil: [
				stream nextPut: $!!; nextChunkPut: preambleOrNil; newLine ].
			stream nextChunkPut: aString ]]! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 4/21/2022 12:24:47' prior: 16956527!
                      browseClassCommentsWithString: aString
	"Smalltalk browseClassCommentsWithString: 'my instances' "
	"Launch a message list browser on all class comments containing aString as a substring."
	| caseSensitive suffix list |
	suffix _ (caseSensitive _ Sensor shiftPressed)
		ifTrue: [ ' (case-sensitive)' ]
		ifFalse: [ ' (use shift for case-sensitive)' ].
	list _ Set new.
	Smalltalk allClassesDo: [ :class |
		(class organization classComment
			findString: aString
			startingAt: 1
			caseSensitive: caseSensitive) > 0 ifTrue: [
			list add: (MethodReference class: class selector: #Comment) ]].
	^ self
		browseMessageList: list
		name: 'Class comments containing ', aString printString, suffix
		autoSelect: aString.! !
!SmartRefStream methodsFor: 'class changed shape' stamp: 'jmv 4/21/2022 13:55:16' prior: 16942101!
             writeClassRename: newName was: oldName
	"Write a method that tells which modern class to map instances to."
	| oldVer sel code |

	oldVer _ self versionSymbol: (structures at: oldName).
	sel _ oldName asPlainString.
	sel at: 1 put: (sel at: 1) asLowercase.
	sel _ sel, oldVer.	"i.e. #rectangleoc4"

	code _ WriteStream on: (String new: 500).
	code nextPutAll: sel; newLine.
	code newLine; tab; nextPutAll: '^ ', newName.	"Return new class"

	self class compile: code contents classified: 'conversion'.

! !
!Exception methodsFor: 'exceptionDescription' stamp: 'jmv 4/21/2022 13:55:24' prior: 16849782!
      description
	
"Return a textual description of the exception."

	| desc |
	desc := self class name asPlainString.
	^ self messageText
		ifNil: [ desc]
		ifNotNil: [ :mt | desc , ': ' , mt ]! !
!MessageNotUnderstood methodsFor: 'exceptionBuilder' stamp: 'jmv 4/21/2022 13:53:45' prior: 16886078 overrides: 16849791!
     messageText
	"Return an exception's message text."

	^ messageText
		ifNil: [
			message
				ifNil: [super messageText]
				ifNotNil: [message lookupClass printString , '>>' , message selector asPlainString]]! !
!Compiler methodsFor: 'public access' stamp: 'jmv 4/21/2022 12:09:54' prior: 16830822!
                     evaluateMethod: method to: receiver logged: doLog profiled: doProfile
	
	"See evaluate:in:to:notifying:ifFail:logged:profiled:
	It does the same but without compiling because it recevies the result of the compilation 
	as the parameter method. 
	self should have compile method"

	| value toLog itsSelection itsSelectionString |
	
	"(jmv) Log before evaluating. This way, if the evaluation is halted by whatever reason, it is logged anyway"
	doLog ifTrue: [
		toLog _ ((requestor respondsTo: #selection)  
			and: [ (itsSelection _ requestor selection) notNil
			and: [ (itsSelectionString _ itsSelection asPlainString) isEmptyOrNil not ]])
				ifTrue: [ itsSelectionString ]
				ifFalse: [ sourceStream contents ].
		SystemChangeNotifier uniqueInstance evaluated: toLog context: context ].

	"Evaluate now."
	doProfile
		ifTrue: [
			TimeProfileBrowser onBlock: [
				value _ receiver
					withArgs: (context ifNil: [#()] ifNotNil: [{context}])
					executeMethod: method ]]
		ifFalse: [
			value _ receiver
				withArgs: (context ifNil: [#()] ifNotNil: [{context}])
				executeMethod: method ].

	^ value! !
!Compiler methodsFor: 'private' stamp: 'jmv 4/21/2022 12:06:13' prior: 16830897!
                         from: textOrStream class: aClass context: aContext notifying: req

	sourceStream _ (textOrStream is: #Stream)
		ifTrue: [ textOrStream ]
		ifFalse: [ ReadStream on: textOrStream asPlainString ].
	class _ aClass.
	context _ aContext.
	requestor _ req! !
!Scanner methodsFor: 'public access' stamp: 'jmv 4/21/2022 14:07:18' prior: 16931689!
             scanMessageParts: sourceString
	"Return an array of the form (comment keyword comment arg comment keyword comment arg comment) for the message pattern of this method.  Courtesy of Ted Kaehler, June 1999"

	| coll nonKeywords |
	coll := OrderedCollection new.
	self scan: (ReadStream on: sourceString asPlainString).
	nonKeywords := 0.
	[tokenType == #doIt] whileFalse:
		[(currentComment == nil or: [currentComment isEmpty])
			ifTrue: [coll addLast: nil]
			ifFalse: [coll addLast: currentComment removeFirst.
				[currentComment isEmpty] whileFalse:
					[coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].
		(token numArgs < 1 or: [token = #| and: [ coll size > 1 ] ])
			ifTrue: [(nonKeywords := nonKeywords + 1) > 1 ifTrue: [^ coll]]
						"done with header"
			ifFalse: [nonKeywords := 0].
		coll addLast: token.
		self scanToken].
	(currentComment == nil or: [currentComment isEmpty])
		ifTrue: [coll addLast: nil]
		ifFalse: [coll addLast: currentComment removeFirst.
			[currentComment isEmpty] whileFalse: [
				coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].
	^ coll! !
!Scanner methodsFor: 'public access' stamp: 'jmv 4/21/2022 11:57:10' prior: 16931727!
    scanTokenPositionsIn: textOrString into: aBlock
	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments, in textOrString."

	self initScannerForTokenization.
	source := (ReadStream on: textOrString asPlainString).
	self step.
	self step.
	self scanAllTokenPositionsInto: aBlock

	"| code |
	code := '       #( 1 2 #( 3 4 ))  16r123 123 123.0  ', (Scanner sourceCodeAt: #scanTokenPositionsIn:into:).
	Scanner new scanTokenPositionsIn: code into: [:start :end| Transcript cr; nextPut: $_; nextPutAll: (code copyFrom: start to: end); nextPut: $_; endEntry]"

	"CodeDiffBuilder buildDisplayPatchFrom:  (Scanner sourceCodeAt: #scanTokenPositionsIn:into:) to:  ((Scanner sourceCodeAt: #scanTokenPositionsIn:into:) copyReplaceAll: String crString with: '')"

	"CodeDiffBuilder buildDisplayPatchFrom:  'colorTable ^colorTable ifNil: [colorTable _ ST80ColorTable]' to:'colorTable ^colorTable ifNil: [colorTable _ ST80ColorTable]'"! !
!Scanner methodsFor: 'public access' stamp: 'jmv 4/21/2022 11:57:14' prior: 16931760!
                       scanTokens: textOrString 
	"Answer an Array that has been tokenized as though the input text, 
	textOrString, had appeared between the array delimitors #( and ) in a 
	Smalltalk literal expression."

	self initScannerForTokenization.
	self scan: (ReadStream on: textOrString asPlainString).
	self scanLitVec.
	^token

	"Scanner new scanTokens: 'identifier keyword: 8r31 ''string'' .'"! !
!Scanner methodsFor: 'public access' stamp: 'jmv 4/21/2022 11:57:20' prior: 16931775!
      typedScanTokens: textOrString 
	"Answer an Array that has been tokenized with literals mapped to literals,
	 special characters mapped to symbols and variable names and keywords
	 to strings. This methiod accepts _ (underscore) as an assignment token
	 irrespective of whether the system prefers := as the assignment token."
	| s |
	self initScannerForTokenization.
	self scan: (ReadStream on: textOrString asPlainString).
	s := WriteStream on: (Array new: 16).
	[tokenType == #doIt] whileFalse:
		[(token == #- 
		  and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue: 
			[self scanToken.
			 token := token negated].
		s nextPut: token.
		self scanToken].
	^s contents

	"Scanner new typedScanTokens: (Scanner sourceCodeAt: #typedScanTokens:)"! !
!Parser methodsFor: 'private' stamp: 'jmv 4/21/2022 14:07:26' prior: 16907200!
initPattern: aString notifying: req return: aBlock
	| result |
	self
		init: (ReadStream on: aString asPlainString)
		notifying: req
		failBlock: [^nil].
	encoder _ self.
	result _ aBlock value: (self pattern: false inContext: nil).
	encoder _ failBlock _ nil.  "break cycles"
	^result! !
!Parser methodsFor: 'scanning' stamp: 'jmv 4/21/2022 11:56:21' prior: 16907484!
               transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a serie of immediately following vertical bars, up arrows and a binary selector.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain."
	| toMakeBinary |
	toMakeBinary _ #(verticalBar upArrow colon).
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here := here asPlainString.
	hereType := #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			here := here , token asPlainString.
			hereEnd := hereEnd + 1.
			self scanToken].
	(tokenType == #binary and: [hereMark + here size = mark])
		ifTrue: [
			here := here asString , token.
			hereType := #binary.
			hereEnd := hereEnd + token size.
			self scanToken].! !
!MethodNode methodsFor: 'printing' stamp: 'jmv 4/21/2022 14:05:40' prior: 16889779!
               printPrimitiveOn: aStream
	"Print the primitive on aStream"
	| primDecl |
	primitive = 0 ifTrue:
		[^self].
	primitive = 120 ifTrue: "External call spec"
		[^aStream print: encoder literals first].
	aStream nextPutAll: '<primitive: '.
	primitive = 117
		ifTrue:
			[primDecl := encoder literals at: 1.
			 (primDecl at: 2) asPlainString printOn: aStream.
			 (primDecl at: 1) ifNotNil:
				[:moduleName|
				aStream nextPutAll:' module: '.
				moduleName asPlainString printOn: aStream]]
		ifFalse:
			[aStream print: primitive].
	self primitiveErrorVariableName ifNotNil:
		[:primitiveErrorVariableName|
		 aStream nextPutAll: ' error: '; nextPutAll: primitiveErrorVariableName].
	aStream nextPut: $>.
	((Smalltalk classNamed: #StackInterpreter) ifNil: [Smalltalk classNamed: #Interpreter]) ifNotNil:
		[:interpreterClass|
		 aStream nextPutAll: ' "', ((interpreterClass primitiveTable) at: primitive + 1), '" ']! !
!Editor methodsFor: 'menu messages' stamp: 'jmv 4/21/2022 11:52:46' prior: 16845712!
                      pasteString
	"Paste the text's string from the shared buffer over the current selection and 
	redisplay if necessary.
	Pasting a string means using destination current attributes if appropriate."

	self replaceSelectionWith: self clipboardStringOrText asPlainString! !
!Editor class methodsFor: 'class initialization' stamp: 'jmv 4/21/2022 12:09:30' prior: 16846327!
                 collectCmdShortcutsSpecUsing: anInitializationMessage

	| shortcutsSpec dynamicInitializationMessage |
	
	shortcutsSpec := self perform: anInitializationMessage.

	dynamicInitializationMessage := (self name asPlainString uncapitalized, anInitializationMessage asPlainString capitalized) asSymbol.
	(Smalltalk allClassesImplementing: dynamicInitializationMessage) do: [ :aClass | 
		shortcutsSpec := shortcutsSpec, (aClass soleInstance perform: dynamicInitializationMessage) ].

	^shortcutsSpec

! !
!DirectoryEntry methodsFor: 'actions-path' stamp: 'jmv 4/21/2022 12:07:53' prior: 16843227!
                 / pathString
	"Answer an instance of DirectoryEntry.
	If you want an instance of FileEntry, please call #//"
	^self concatPathComponentsAsDirectory: pathString asPathComponents! !
!DirectoryEntry methodsFor: 'actions-path' stamp: 'jmv 4/21/2022 12:07:59' prior: 16843236!
                // pathString
	"Answer an instance of FileEntry.
	If you want an instance of DirectoryEntry, please call #/"
	^self concatPathComponentsAsFile: pathString asPathComponents! !
!RemoteString methodsFor: 'private' stamp: 'jmv 4/21/2022 11:52:54' prior: 16925803!
                            string: aStringOrText onFileNumber: fileNumber toFile: aFileStream
	"Store this as the receiver's text if source files exist."

	| position |
	fileNumber = 0 ifFalse: [
		aFileStream padTo: SourceFiles pointerScaleForWriting put: $  ].
	position _ aFileStream position.
	self fileNumber: fileNumber position: position.
	aFileStream nextChunkPut: aStringOrText asPlainString! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 4/21/2022 13:56:44' prior: 16819321!
                    writeFeatureSpecOn: aStream
	| provides |
	provides _ featureSpec provides.
	aStream
		nextPut: $!!; 
		nextChunkPut: 'provides: ', provides name asPlainString printString, ' ', provides version printString, ' ', provides revision printString;
		newLine.
	featureSpec requires do: [ :requires |
		aStream
		nextPut: $!!; 
			nextChunkPut: 'requires: ', requires name asPlainString printString, ' ', requires minVersion printString, ' ', requires minRevision printString, ' ', requires maxVersion printString;
			newLine ]! !
!FeatureRequirement methodsFor: 'accessing' stamp: 'jmv 4/21/2022 13:56:14' prior: 16853268!
                      packageFileName
	"Answer a package name based on feature name"

	^ name asPlainString, '.pck.st'! !
!FeatureRequirement methodsFor: 'private' stamp: 'jmv 4/21/2022 13:56:56' prior: 16853493!
 addToLoad: toLoad withMyRequirements: requirements

	"Add self to OrderedCollection 'toLoad' before any requirements I have"
	| myRequirements |
	myRequirements := self requirements.
	toLoad do: [ :featureReq | 
		(myRequirements anySatisfy: [ :req | featureReq sameNameAs: req])
		ifTrue: [
			"Transcript show: ('adding ', self name asPlainString, ' before: ', featureReq name asPlainString); newLine."
			toLoad add: self before: featureReq.
			^ toLoad
		]
	].
	"Transcript show: ('adding ', self name asPlainString); newLine."
	toLoad addLast: self.
	^ toLoad
		! !
!Preferences class methodsFor: 'personalization' stamp: 'jmv 4/21/2022 13:57:07' prior: 50340592!
   compileHardCodedPref: prefName enable: aBoolean
	"Compile a method that returns a simple true or false (depending on the value of aBoolean) when Preferences is sent prefName as a message"

	self class compileSilently: (prefName asPlainString, '
	"compiled programatically -- return hard-coded preference value"
	^ ', aBoolean storeString) classified: 'hard-coded prefs'.
	SmalltalkCompleter addSelector: prefName.
	
"Preferences compileHardCodedPref: #testing enable: false"! !
!Morph methodsFor: 'meta-actions' stamp: 'jmv 4/21/2022 13:57:14' prior: 16894448!
               addEmbeddingMenuItemsTo: aMenu hand: aHandMorph
	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self potentialEmbeddingTargets reverseDo: [:m | 
		menu 
			add: m class name asPlainString 
			targetHighlight: m 
			action: #addMorphFrontFromWorldPosition: 
			argumentList: {self}].
	aMenu ifNotNil:[
		menu submorphCount > 0 
			ifTrue:[aMenu add:'embed into' subMenu: menu].
	].
	^menu! !
!StringRequestMorph methodsFor: 'accessing' stamp: 'jmv 4/21/2022 11:53:20' prior: 16950278!
                      response: aText
	"Sent when text pane accepts."
	response _ aText.
	validationBlock ifNotNil: [(validationBlock value: aText asPlainString) ifFalse: [self flash. ^ false]].
	[acceptBlock ifNotNil: [acceptBlock value: aText asPlainString]] ensure: [self delete].
	^ true! !
!StringRequestMorph methodsFor: 'initialization' stamp: 'jmv 4/21/2022 11:57:45' prior: 16950327!
             addTitle: aString
	| titleMorph s pp w |
	titleMorph _ BoxedMorph new noBorder.
	titleMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line |
		s _ LabelMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphExtent: (w + 24) @ (pp y).
	self addMorphKeepMorphHeight: titleMorph.
	^titleMorph morphWidth! !
!SystemWindow methodsFor: 'printing' stamp: 'jmv 4/21/2022 14:07:36' prior: 16959735 overrides: 16894539!
                 printOn: aStream 
	aStream nextPutAll: labelString asPlainString! !
!FillInTheBlankMorph methodsFor: 'accessing' stamp: 'jmv 4/21/2022 11:53:24' prior: 16856873!
                              response: aText
	"Sent when text pane accepts."

	response _ aText asPlainString.
	done _ true.
	^ true
! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 4/21/2022 11:57:39' prior: 16882751!
                             addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w newMorph |
	
	newMorph _ BoxedMorph new noBorder.
	newMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line | | font |
		font _ Preferences standardMenuFont.
		s _ LabelMorph new
			contents: line;
			font: (titleMorph
				ifNil: [ font bold ]
				ifNotNil: [ font italic ])..
		newMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ newMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	newMorph morphExtent: (w + 16) @ (pp y).
	titleMorph
		 ifNil: [
			titleMorph _ newMorph.
			self addMorphFront: titleMorph ]
		ifNotNil: [ self addMorphBack: newMorph ].
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'jmv 4/21/2022 14:08:24' prior: 16881653!
                           from: aPopupMenu title: titleStringOrNil
	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."

	| menu items lines selections labelString labelPlainString j emphasis |
	menu _ self new.
	titleStringOrNil ifNotNil: [
		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].
	labelString _ aPopupMenu labelString.
	labelPlainString _ labelString asPlainString.
	items _ labelPlainString lines.
	(labelString is: #Text) ifTrue: [
		"Pass along text emphasis if present"
		j _ 1.
		items _ items collect: [ :item |
			j _ labelPlainString findString: item startingAt: j.
			emphasis _ TextEmphasis new emphasisCode: (labelString emphasisAt: j).
			item asText addAttribute: emphasis]].
	lines _ aPopupMenu lineArray.
	lines ifNil: [lines _ #()].
	menu cancelValue: 0.
	menu defaultTarget: menu.
	selections _ (1 to: items size) asArray.
	1 to: items size do: [ :i |
		menu add: (items at: i) target: menu action: #selectMVCItem: argument: (selections at: i) icon: (aPopupMenu iconAt: i).
		(lines includes: i) ifTrue: [menu addLine]].
	^ menu
! !
!HaloSpec methodsFor: 'printing' stamp: 'jmv 4/21/2022 13:54:03' prior: 16865374 overrides: 16902975!
                       printOn: aStream
	"Add a textual printout representing the receiver to a stream"

	super printOn: aStream.
	aStream nextPutAll: ' (', addHandleSelector asPlainString, ' ', iconSymbol asPlainString, ')'! !
!PseudoClass methodsFor: 'class' stamp: 'jmv 4/21/2022 14:08:33' prior: 16920761!
 comment: aString
	self classComment: aString asPlainString! !
!PseudoClass methodsFor: 'methods' stamp: 'jmv 4/21/2022 13:57:19' prior: 16921171!
              removeSelector: aSelector
	| catName |
	catName := self class removedCategoryName asPlainString.
	self organization addCategory: catName before: self organization categories first.
	self organization classify: aSelector under: catName.
	self sourceCodeAt: aSelector put:'methodWasRemoved' asText.! !
!TestCase class methodsFor: 'building suites' stamp: 'jmv 4/21/2022 13:57:23' prior: 16961897!
                     buildSuite
	| suite |
	suite _ TestSuite new.
	^ self isAbstract
		ifTrue: [
			suite name: self name asPlainString.
			self allSubclasses
				do: [:each | each isAbstract
						ifFalse: [each addToSuiteFromSelectors: suite]].
			suite]
		ifFalse: [self addToSuiteFromSelectors: suite]! !
!TestCase class methodsFor: 'building suites' stamp: 'jmv 4/21/2022 13:57:33' prior: 16961919!
buildSuiteFromMethods: testMethods 
	| suite |
	suite _ TestSuite new
				name: self name asPlainString;
				yourself.
	^self addToSuite: suite fromMethods: testMethods! !
!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 4/21/2022 13:57:39' prior: 16943959!
 saveTo: aFileName
	"
	| st |
	st := SpaceTally new.
	st spaceTally: (Array with: EllipseMorph with: Point).
	st saveTo: 'spaceTally2'
	"

	DirectoryEntry smalltalkImageDirectory // aFileName forceWriteStreamDo: [ :stream |
		results do: [ :each |
				stream nextPutAll: each analyzedClassName asPlainString; 
						nextPutAll: ' '; nextPutAll: each codeSize printString; 
						nextPutAll: ' '; nextPutAll: each instanceCount printString; 
						nextPutAll: ' '; nextPutAll: each spaceForInstances printString; newLine ]]! !
!SpaceTallyItem methodsFor: 'printing' stamp: 'jmv 4/21/2022 13:57:44' prior: 50341052 overrides: 16902975!
       printOn: aStream

	analyzedClassName
		ifNotNil: [ aStream nextPutAll: analyzedClassName asPlainString]. 
	aStream nextPutAll: ' ('.
	codeSize
		ifNotNil: [ aStream nextPutAll: 'code size: ' ;  nextPutAll: codeSize printString]. 
	instanceCount
		ifNotNil: [ aStream nextPutAll: ' instance count: ' ;  nextPutAll: instanceCount printString]. 
	spaceForInstances
		ifNotNil: [ aStream nextPutAll: ' space for instances: ' ;  nextPutAll: spaceForInstances printString]. 
	aStream nextPut: $).
	! !
!SHTextStylerST80 methodsFor: 'styling' stamp: 'jmv 4/21/2022 11:53:28' prior: 16930719!
                       styleWorkspaceFrom: start to: end allowEmphasis: aBoolean
	"Style a copy of part of the model text. Then apply attributes to model text. Useful for Workspaces.
	Call #formatWorkspace: becore calling us.
	Note: classOrMetaClass is assumed to be nil.
	Note: after last call, do `textModel changed: #shoutStyled`"

	parser
		source: (formattedText asPlainString copyFrom: start to: end).
	parser parse.
	parser ranges ifNotNil: [ :ranges |
		ranges do: [ :range |
			(self attributesFor: range rangeType) ifNotNil: [ :attributes |
				attributes do: [ :each |
					"For Workspaces, avoid attributes that affect text layout: very large contents would be slow."
					(aBoolean or: [each emphasisCode noMask: 3]) ifTrue: [
						formattedText
							addAttribute: each
							from: range start +start-1
							to: range end +start-1 ]]]]].! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 4/21/2022 11:44:19' prior: 16930846!
  parseSetWorkspace: aBoolean
	"Answer a collection of SHRanges by parsing aText.
	When formatting it is not necessary to set the workspace, and this can make the parse take less time, so aBoolean specifies whether the parser should be given the workspace"
	parser ifNil: [ parser := SHParserST80 new ].
	parser
		workspace:
			(aBoolean ifTrue: [ workspace ]);
		classOrMetaClass: classOrMetaClass;
		source: formattedText asPlainString.
	parser parse.
	^ parser ranges.! !
!RemoveParameter methodsFor: 'initialization' stamp: 'jmv 4/21/2022 13:54:26' prior: 16926383!
        initializeNamed: aParameterToRemove
	ofKeywordAtIndex: aParameterIndex
	from: anOldSelector 
	creating: aNewSelector 
	implementors: implementorsCollection 
	senders: sendersCollection
	
	super initializeFrom: anOldSelector to: aNewSelector implementors: implementorsCollection senders: sendersCollection.

	parameterToRemove := aParameterToRemove.
	parameterIndex := aParameterIndex.
	senderReplacementString := newSelector isUnary ifTrue: [ newSelector asPlainString ] ifFalse: [ '' ].
	isLastParameter := oldSelector numArgs = parameterIndex 
	! !
!RenameGlobal class methodsFor: 'exceptions' stamp: 'jmv 4/21/2022 13:57:52' prior: 16927247!
                           errorMessageForGlobalNotDefined: anOldName

	^ anOldName asPlainString, ' is not defined as global variable'! !
!SafelyRemoveClass class methodsFor: 'exceptions' stamp: 'jmv 4/21/2022 13:57:58' prior: 16931267!
             errorMessageForCanNotRemove: aClassToSafelyRemove dueToReferencesToAll: referenced

	^String streamContents: [ :stream |
		stream 
			nextPutAll: aClassToSafelyRemove name asPlainString;
			nextPutAll: ' can not be removed '.
	
		referenced size = 1 
			ifTrue: [ (referenced includes: aClassToSafelyRemove) 
				ifTrue: [ stream nextPutAll: 'because it has references' ]
				ifFalse: [ stream 
					nextPutAll: 'because it subclass, ';
					nextPutAll: referenced anyOne name asPlainString;
					nextPutAll: ', has references' ]]
			ifFalse: [ (referenced includes: aClassToSafelyRemove)
				ifTrue: [ stream 
					nextPutAll: 'due to references to: ';
					nextPutAll: referenced asCommaStringAnd ]
				ifFalse: [ stream
					nextPutAll: 'due to references to its subclasses: ';
					nextPutAll: referenced asCommaStringAnd ]]]! !
!SafelyRemoveClass class methodsFor: 'warnings' stamp: 'jmv 4/21/2022 13:58:02' prior: 16931327!
                              warningMessageFor: aClassToSafelyRemove hasSubclasses: allSubclasses

	^String streamContents: [ :stream |
		stream nextPutAll: aClassToSafelyRemove name asPlainString.
		allSubclasses size = 1
			ifTrue: [ stream nextPutAll: ' has a subclass' ]
			ifFalse: [ stream 
					nextPutAll: ' has ';
					print:  allSubclasses size;
					nextPutAll: ' subclasses' ].
		stream nextPutAll: ' that will be removed'].
		
	! !
!RenameGlobalApplier methodsFor: 'refactoring - parameters request' stamp: 'jmv 4/21/2022 13:58:07' prior: 16927321!
           askNewName

	newName := self request: 'Enter new name:' initialAnswer: oldName asPlainString.
	newName := newName withBlanksTrimmed asSymbol.
	! !
!SafelyRemoveClassApplier methodsFor: 'refactoring - parameters request' stamp: 'jmv 4/21/2022 14:08:56' prior: 16931359!
                   confirmationMessageText
	
	^'Are you sure you want to remove ', classToRemove name asPlainString, '?'! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5110-asPlainString-JuanVuletich-2022Apr22-11h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5110] on 22 April 2022 at 10:53:26 am'!
!Symbol methodsFor: 'converting' stamp: 'jmv 4/22/2022 10:52:24' prior: 16950728 overrides: 16948150!
            asString
	^ self asPlainString! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5111-DontRepeatYourself-JuanVuletich-2022Apr22-10h52m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5111] on 22 April 2022 at 12:06:34 pm'!
!Symbol methodsFor: 'converting' stamp: 'jmv 4/21/2022 14:47:23' overrides: 16948682!
                              uncapitalized
	^ self asPlainString uncapitalized asSymbol! !
!Message methodsFor: 'stub creation' stamp: 'jmv 4/21/2022 14:42:52' prior: 16883625!
            argumentNameAt: anIndex havingNamed: alreadyNamedArguments

	| argumentName |
	
	argumentName _ (self arguments at: anIndex) argumentName.
	[alreadyNamedArguments includes: argumentName] whileTrue: [argumentName _ argumentName, anIndex printString].
	alreadyNamedArguments add: argumentName.

	^argumentName! !
!EventSensor methodsFor: 'test' stamp: 'jmv 4/21/2022 14:43:09' prior: 50341177!
                        printEventBuffer: evtBuf
	"Print the event buffer, currently only used by the method `test`."

	| type buttons macRomanCode modifiers pressType stamp unicodeCodePoint |
	type _ evtBuf first.
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp := Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	type = EventSensor eventTypeMouse
		ifTrue: [ | position |
			position _ evtBuf third @ evtBuf fourth.
			buttons _ evtBuf fifth.
			modifiers _ evtBuf sixth.
			Transcript
				newLine;
				show: 'Mouse';
				show: ' position:', position printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeMouseScroll
		ifTrue: [ | delta |
			delta _ evtBuf third @ evtBuf fourth.
			buttons _ evtBuf fifth.
			modifiers _ evtBuf sixth.
			Transcript
				newLine;
				show: 'Scroll';
				show: ' delta:', delta printString;
				show: ' buttons:', buttons printString;
				show: ' modifiers:', modifiers printString.
			].
	type = EventSensor eventTypeKeyboard 
		ifTrue: [
			macRomanCode _ evtBuf third.
			unicodeCodePoint _ evtBuf sixth.
			pressType _ evtBuf fourth.
			modifiers _ evtBuf fifth.
			pressType = EventSensor eventKeyDown ifTrue: [
				type _ #keyDown].
			pressType = EventSensor eventKeyUp ifTrue: [
				type _ #keyUp].
			pressType = EventSensor eventKeyChar ifTrue: [
				type _ #keystroke].
			Transcript
				newLine;
				show: type;
				show: ' macRomanCode:', macRomanCode printString, '-', 
					(String with: (Character numericValue: (Character macRomanToLatin1: macRomanCode))), '-';
				show: ' unicodeCodePoint:', unicodeCodePoint printString.
			(Character iso8859s15CodeForUnicodeCodePoint: unicodeCodePoint) ifNotNil: [ :latin15 |
				Transcript show: '-', (String with: (Character numericValue: latin15)), '-' ].
			Transcript
				show: ' modifiers:', modifiers printString.
			(modifiers anyMask: 8) ifTrue: [ Transcript show: ' [commandWinAlt]' ].
			(modifiers anyMask: 4) ifTrue: [ Transcript show: ' [macOption]' ].
			(modifiers anyMask: 2) ifTrue: [ Transcript show: ' [control]' ].
			(modifiers anyMask: 1) ifTrue: [ Transcript show: ' [shift]' ].
			].! !
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 14:43:55' prior: 16948102!
                         asLowercase
	"Answer a String made up from the receiver whose characters are all 
	lowercase."

	^ self copy asPlainString translateToLowercase! !
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 14:44:01' prior: 16948215!
                           asUppercase
	"Answer a String made up from the receiver whose characters are all 
	uppercase."

	^self copy asPlainString translateToUppercase! !
!String methodsFor: 'converting' stamp: 'jmv 4/21/2022 14:46:00' prior: 16948682!
                            uncapitalized
	"Answer an object like the receiver but with first character downshifted if necesary"
	"'MElViN' uncapitalized"
	"#Will uncapitalized"
	| answer |
	self isEmpty ifTrue: [^ self].
	answer _ self isString
				ifTrue: ["don't modify receiver"
					self copy]
				ifFalse: [self asPlainString].
	answer at: 1 put: (answer at: 1) asLowercase.
	^ answer! !
!Symbol methodsFor: 'converting' stamp: 'jmv 4/21/2022 14:47:21' prior: 16950738 overrides: 16948361!
            capitalized
	^ self asPlainString capitalized asSymbol! !
!Symbol class methodsFor: 'access' stamp: 'jmv 4/21/2022 14:47:39' prior: 16950906!
                  selectorsContaining: aString
	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."

	| size selectorList ascii |

	selectorList _ OrderedCollection new.
	(size _ aString size) = 0 ifTrue: [^selectorList].

	aString size = 1 ifTrue:
		[
			ascii _ aString first numericValue.
			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]
		].

	aString first isValidInIdentifiers ifFalse:
		[
			aString size = 2 ifTrue: 
				[Symbol hasInterned: aString ifTrue:
					[:s | selectorList add: s]].
			^selectorList
		].

	selectorList _ selectorList copyFrom: 2 to: selectorList size.

	self allSymbolTablesDo: [:each |
		each size >= size ifTrue:
			[(each findSubstring: aString in: each startingAt: 1 
				matchTable: CaseInsensitiveOrder) > 0
						ifTrue: [selectorList add: each]]].

	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"
		each numArgs < 0 and: [each asPlainString uncapitalized numArgs < 0]].

"Symbol selectorsContaining: 'scon'"! !
!Symbol class methodsFor: 'access' stamp: 'jmv 4/21/2022 14:47:44' prior: 16950943!
 selectorsMatching: aStringPattern
	"Answer a list of selectors that match aStringPattern within them. Case-insensitive.
	 Does return symbols that begin with a capital letter."

	| selectorList |

	selectorList := OrderedCollection new.

	aStringPattern isEmpty ifTrue: [^selectorList].

	self allSymbolTablesDo:
		[:each | (aStringPattern match: each) ifTrue: [selectorList add: each]].

	^selectorList reject: "reject non-selectors, but keep ones that begin with an uppercase"
		[:each | each numArgs < 0 and: [each asPlainString uncapitalized numArgs < 0]]

	"Symbol selectorsMatching: 'parse:*'"! !
!ContentPack class methodsFor: 'code pack' stamp: 'jmv 4/21/2022 14:52:08' prior: 16831704!
         compilePayloadWith: contentMap

	| category |
	category _ self generatedMethodsCategory.
	self
		compile: 'contentMap' , String newLineString , '	^ ' , contentMap asString
		classified: category.

	self
		compile: 'objectCount' , String newLineString , '	^ ' , payload size asString
		classified: category.

	payload withIndexDo: [ :blob :index | | selector |
		selector _ 'object', index printString.
		self
			compile: selector, String newLineString, '	^ ', blob surroundedBySingleQuotes
			classified: category ]! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 4/21/2022 14:50:36' prior: 16941635!
                               mapClass: incoming
	"See if the old class named nm exists.  If so, return it.  If not, map it to a new class, and save the mapping in renamed.  "

	| cls oldVer sel nm |

	self flag: #bobconv.	


	nm _ renamed at: incoming ifAbsent: [incoming].	"allow pre-mapping around collisions"
	(nm endsWith: ' class') 
		ifFalse: [cls _ Smalltalk at: nm ifAbsent: nil.
			cls ifNotNil: [^ cls]]  	"Known class.  It will know how to translate the instance."
		ifTrue: [cls _ Smalltalk at: nm substrings first asSymbol ifAbsent: nil.
			cls ifNotNil: [^ cls class]]. 	"Known class.  It will know how to translate the instance."
	oldVer _ self versionSymbol: (structures at: nm).
	sel _ nm asPlainString.
	sel at: 1 put: (sel at: 1) asLowercase.
	sel _ sel, oldVer.	"i.e. #rectangleoc4"
	Symbol hasInterned: sel ifTrue: [:symb | 
		(self class canUnderstand: sel asSymbol) ifTrue: [
			cls _ self perform: sel asSymbol]].	"This class will take responsibility"
	cls ifNil: [cls _ self writeClassRenameMethod: sel was: nm
					fromInstVars: (structures at: nm).
			   cls class == String ifTrue: [cls _ nil]].
	cls ifNotNil: [renamed at: nm put: cls name].
	^ cls
! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 4/21/2022 14:50:49' prior: 16942014!
     versionSymbol: instVarList
	"Create the symbolic code (like a version number) for this class in some older version.  First initials of all the inst vars, followed by the class version number.  Returns a string, caller makes it into a compound selector.  "

	| str |
	str _ instVarList size = 1 ifFalse: [''] ifTrue: ['x'].		"at least one letter"
	2 to: instVarList size do: [:ind |
		str _ str, (instVarList at: ind) first asPlainString].
	str _ str, instVarList first printString.	"the number"
	^ str

" | list | list _ (Array with: Paragraph classVersion), (Paragraph alistInstVarNames).
(SmartRefStream  on: (DummyStream on: nil)) versionSymbol: list
"! !
!Process methodsFor: 'printing' stamp: 'jmv 4/21/2022 14:51:05' prior: 16917393!
                            browserPrintStringFull: aBoolean

	^String streamContents: [ :stream |
		aBoolean ifTrue: [
			stream
				nextPutAll: self statusString;
				space ].
		priority printOn: stream.
		stream nextPutAll: ' ('.
		self hash printOn: stream.
		stream
			nextPutAll: ') ';
			nextPutAll: self name.
		self animatedUI ifNotNil: [ :ui |
			stream nextPutAll: ' - '.
			ui printOn: stream ].
		aBoolean ifTrue: [
			stream
				nextPutAll: ': ';
				nextPutAll: suspendedContext printString ]]! !
!Parser methodsFor: 'scanning' stamp: 'jmv 4/21/2022 14:51:40' prior: 50342769!
            transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a serie of immediately following vertical bars, up arrows and a binary selector.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain."
	| toMakeBinary |
	toMakeBinary _ #(verticalBar upArrow colon).
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here := here asPlainString.
	hereType := #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			here := here , token asPlainString.
			hereEnd := hereEnd + 1.
			self scanToken].
	(tokenType == #binary and: [hereMark + here size = mark])
		ifTrue: [
			here := here asPlainString , token.
			hereType := #binary.
			hereEnd := hereEnd + token size.
			self scanToken].! !
!DecompilerConstructor methodsFor: 'constructor' stamp: 'jmv 4/21/2022 14:51:55' prior: 16841277!
                            codeInst: index

	^InstanceVariableNode new
		name: (instVars at: index + 1 ifAbsent: ['unknown', index printString])
		index: index + 1! !
!SerializableClosureDecompilerConstructor methodsFor: 'constructor' stamp: 'jmv 4/21/2022 14:52:15' prior: 16935519 overrides: 50343677!
           codeInst: index

	^ SerializableClosureInstanceVariableNode new
		name: (instVars at: index + 1 ifAbsent: ['unknown', index printString])
		index: index + 1! !
!TextEditor methodsFor: 'attributes' stamp: 'jmv 4/21/2022 14:55:04' prior: 16966411!
          offerFontStyleMenu
	"This is a user command, and generates undo"

	| emphases menuStrings entries reply code startIndex attribute |
	startIndex _ self startIndex.
	code _ model actualContents emphasisAt: startIndex.
	emphases _ #(bold italic underlined struckThrough superscript subscript withST80Glyphs).
	menuStrings _ Array streamContents: [ :strm |
		strm nextPut:(code isZero ifTrue: ['<on>'] ifFalse: ['<off>']), 'normal'.
		emphases do: [ :emph |
			strm nextPut:
				((code anyMask: (TextEmphasis perform: emph) emphasisCode)
					ifTrue: ['<on>'] ifFalse: ['<off>']),
				emph asPlainString ]].
	entries _ `#(normal)`, emphases.
	reply _ (SelectionMenu labelList: menuStrings lines: #(1) selections: entries) startUpMenu.
	reply ifNotNil: [
		attribute _ TextEmphasis perform: reply.
		((menuStrings at: (entries indexOf: reply)) beginsWith: '<on>')
			ifTrue: [ self unapplyAttributes: {attribute} ]
			ifFalse: [ self applyAttribute:  attribute ]].
	morph updateFromTextComposition.! !
!TextEditor methodsFor: 'model access' stamp: 'jmv 4/21/2022 14:55:17' prior: 16967033!
   wordUnder: aPositionInText
	
	| wordUnderCursorRange word indexOfSpace |
	
	wordUnderCursorRange := self wordRangeUnder: aPositionInText.
	word := (model actualContents copyFrom: wordUnderCursorRange first to: wordUnderCursorRange last) asPlainString.
	
	"I have to handle the edge case where the cursor is for example between a ' and the first letter of the word.
	In that case the range will include words with spaces - Hernan"
	indexOfSpace := word indexOf: $  ifAbsent: [ ^word ].
	
	^word first: indexOfSpace -1 
	
			! !
!SmalltalkEditor methodsFor: 'contextual rename' stamp: 'jmv 4/21/2022 14:55:41' prior: 16939347!
               withMethodNodeAndClassDo: aBlock ifErrorsParsing: anErrorBlock

	| selectedClass methodNode |

	selectedClass := self selectedClassOrMetaClassOrUndefinedObject.
	[ 
		[ methodNode := selectedClass methodNodeFor: model actualContents asPlainString ]
			on: UndeclaredVariableWarning do: [ :ex | ex resume ]
	] on: Error do: [ :anError |  ^ anErrorBlock value: anError ].

	^aBlock value: methodNode value: selectedClass.! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 4/21/2022 14:55:29' prior: 16939888!
 explainClass: symbol 
	"Is symbol a class variable or a pool variable?"
	| provider class reply classes |
	provider _ self codeProvider.
	(provider respondsTo: #selectedClassOrMetaClass)
		ifFalse: [^ nil].
	(class _ provider selectedClassOrMetaClass) ifNil: [^ nil].
	"no class is selected"
	(class isKindOf: Metaclass)
		ifTrue: [class _ class soleInstance].
	classes _ (Array with: class)
				, class allSuperclasses.
	"class variables"
	reply _ classes detect: [:each | (each classVarNames detect: [:name | symbol = name]
					ifNone: nil)
					notNil]
				ifNone: nil.
	reply ifNotNil: [
		^ String streamContents: [:str |
			str
				nextPutAll: symbol;
				nextPutAll: ' is a class variable, defined in class ';
				nextPutAll: reply printString, '\' withNewLines;
				nextPutAll: 'Smalltalk browseAllCallsOn: (';
				nextPutAll: reply printString;
				nextPutAll: ' classPool associationAt: #';
				nextPutAll: symbol;
				nextPutAll: ').']].
	"pool variables"
	classes do: [:each | (each sharedPools
			detect: [:pool | (pool includesKey: symbol)
					and: 
						[reply _ pool.
						true]]
			ifNone: nil)
			notNil].
	reply
		ifNil: [(Undeclared includesKey: symbol)
				ifTrue: [
					^ String streamContents: [:str |
						str
							nextPutAll: symbol;
							nextPutAll: ' is an undeclared variable.';
							nextPutAll: 'Smalltalk browseAllCallsOn: (Undeclared associationAt: #';
							nextPutAll: symbol;
							nextPutAll: ').']]]
		ifNotNil: 
			[classes _ Array streamContents: [ :strm |
				Smalltalk
					allBehaviorsDo: [:each | (each sharedPools
							detect: 
								[:pool | 
								pool == reply]
							ifNone: nil)
							notNil ifTrue: [strm nextPut: each]]].
			"Perhaps not print whole list of classes if too long. (unlikely)"
			^ String streamContents: [:str |
				str
					nextPutAll: symbol;
					nextPutAll: ' is a pool variable from the pool ';
					nextPutAll: (Smalltalk keyAtIdentityValue: reply) asPlainString;
					nextPutAll: ', which is used by the following classes ';
					nextPutAll: classes printString , '\' withNewLines;
					nextPutAll: 'Smalltalk browseAllCallsOn: (';
					nextPutAll: (Smalltalk keyAtIdentityValue: reply) asPlainString;
					nextPutAll: ' bindingOf: #';
					nextPutAll: symbol;
					nextPutAll: ').']].
	^ nil! !
!TextReplaceCommand methodsFor: 'printing' stamp: 'jmv 4/21/2022 14:56:16' prior: 16969683 overrides: 16902975!
                              printOn: aStream
	old isEmpty ifTrue: [
		^aStream nextPutAll: 'typed: '; nextPutAll: new asPlainString withDescriptiveLineEndings surroundedBySingleQuotes].
	new isEmpty ifTrue: [
		^aStream nextPutAll: 'deleted: '; nextPutAll: old asPlainString withDescriptiveLineEndings surroundedBySingleQuotes ].
	aStream
		nextPutAll: 'replaced: ';
		nextPutAll: old asPlainString withDescriptiveLineEndings surroundedBySingleQuotes;
		nextPutAll: ' with: ';
		nextPutAll: new asPlainString withDescriptiveLineEndings surroundedBySingleQuotes ! !
!FileIOAccessor methodsFor: 'accessing' stamp: 'jmv 4/21/2022 14:56:34' prior: 16854764!
              slash
	"Given that FileMan supports $/ as path delimiter regardless of the platform,
	this method is mostly for FileMan's own use, and general usage is discouraged.
	Just use '/' "
	slash ifNil: [ slash _ String with: self pathNameDelimiter ].
	^slash! !
!Utilities class methodsFor: 'tailoring system' stamp: 'jmv 4/21/2022 14:57:58' prior: 16977374!
stripMethods: tripletList messageCode: messageString
	"Used to 'cap' methods that need to be protected for proprietary reasons, etc.; call this with a list of triplets of symbols of the form  (<class name>  <#instance or #class> <selector name>), and with a string to be produced as part of the error msg if any of the methods affected is reached"

	| aClass sel keywords codeString |
	tripletList do:
		[:triplet |  
			(aClass _ (Smalltalk at: triplet first ifAbsent: nil)) ifNotNil: [
				triplet second == #class ifTrue: [
					aClass _ aClass class].
				sel _ triplet third.
				keywords _ sel keywords.
				(keywords size = 1 and: [keywords first asSymbol isKeyword not])
					ifTrue: [
						codeString _ keywords first]
					ifFalse: [
						codeString _ ''.
						keywords withIndexDo:
							[:kwd :index |
								codeString _ codeString, ' ', (keywords at: index), ' ',
									'arg', index printString]].
				codeString _ codeString, '
	self codeStrippedOut: ', (messageString surroundedBySingleQuotes).

				aClass compile: codeString classified: 'stripped']]! !
!Utilities class methodsFor: 'vm statistics' stamp: 'jmv 4/21/2022 14:58:36' prior: 50339755!
           vmStatisticsReportOn: str
	"
	(TextModel new contents: Utilities vmStatisticsReportString) openLabel: 'VM Statistics'
	"

	| params oldSpaceEnd youngSpaceEnd memorySize fullGCs fullGCTime fullGCCompactionTime incrGCs incrGCTime tenureCount upTime
	  upTime2 fullGCs2 fullGCTime2  incrGCs2 incrGCTime2 tenureCount2 freeSize youngSize used spur timeReporter idleMs idleMs2 codeCompactionTime codeCompactionsOrNil codeCompactionTime2 codeCompactions2 maxParams |
	"Pad to protect for a VM that does not answer the expected parameter array"
	maxParams := 63. "max position referenced in this method"
	params := Array streamContents: [ :strm |
				strm nextPutAll: Smalltalk getVMParameters.
				[strm position < maxParams] whileTrue: [strm nextPut: nil]].
	oldSpaceEnd			:= params at: 1.
	youngSpaceEnd		:= params at: 2.
	memorySize			:= params at: 3.
	fullGCs			:= params at: 7.
	fullGCTime			:= params at: 8.
	incrGCs			:= params at: 9.
	incrGCTime			:= params at: 10.
	tenureCount			:= params at: 11.
	fullGCCompactionTime	:= params at: 18.
	codeCompactionsOrNil	:= params at: 62.
	codeCompactionTime	:= params at: 63.
	
	upTime := (params at: 20) ~= 0 "utcMicrosecondClock at startup in later Spur VMs"
				ifTrue: [Time primUtcMicrosecondClock - (params at: 20) + 500 // 1000]
				ifFalse: [Time primMillisecondClock]. "Fall back on old microsecond clock; Good for 47.5 days"
	spur := (params at: 41)
				ifNotNil: [ :p | p anyMask: 16]
				ifNil: [false].
	timeReporter := [:time| | seconds |
					seconds := time / 1000.
					seconds >= (60*60*24)
						ifTrue:
							[str print: seconds / 60 // 60 // 24; nextPut: $d; space;
								print: seconds / 60 // 60 \\ 24; nextPut: $h; space]
						ifFalse:
							[seconds >= (60*60) ifTrue:
								[str print: (seconds / 60 // 60); nextPut: $h; space]].
					str
						print: (seconds / 60 \\ 60) asInteger; nextPut: $m; space;
						print: (seconds \\ 60) asInteger; nextPut: $s].
	str	nextPutAll: 'uptime		'.
	timeReporter value: upTime.
	(idleMs := params at: 16) ~= 0 ifTrue:
		[str tab; nextPutAll: '(runtime '.
		 idleMs := idleMs // 1000.
		 timeReporter value: upTime - idleMs.
		 str nextPutAll: ', idletime '.
		 timeReporter value: idleMs.
		 str nextPut: $)].
	str newLine.

	str	nextPutAll: 'memory			';
		nextPutAll: (self formatVMParameter: memorySize); nextPutAll: ' bytes'; newLine.
	str	nextPutAll:	'	old		';
		nextPutAll: (self formatVMParameter: oldSpaceEnd); nextPutAll: ' bytes (';
		print: oldSpaceEnd / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.

	spur ifTrue:
		[(youngSize := (params at: 19)  * 7 // 5) = 0 ifTrue: [params at: 44].
		 youngSize := youngSize roundUpTo: 1024.
		 str	nextPutAll: '	young		';
			nextPutAll: (self formatVMParameter: youngSize); nextPutAll: ' bytes (';
			print: youngSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
		youngSize := youngSpaceEnd. "used eden"
		freeSize := (params at: 54) + (params at: 44) - youngSize.
		used := youngSize + oldSpaceEnd - freeSize.
		str	nextPutAll: '	used		';
			nextPutAll: (self formatVMParameter: used); nextPutAll: ' bytes (';
			print: used / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	free		';
			nextPutAll: (self formatVMParameter: freeSize); nextPutAll: ' bytes (';
			print: freeSize / memorySize * 100 fractionDigits: 1; nextPutAll: '%)'; newLine]
		ifFalse: "Earlier VM and V3 object memory"
		[str	nextPutAll: '	young		';
			nextPutAll: (self formatVMParameter: (youngSpaceEnd - oldSpaceEnd)); nextPutAll: ' bytes (';
			print: (youngSpaceEnd - oldSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	used		';
			nextPutAll: (self formatVMParameter: youngSpaceEnd); nextPutAll: ' bytes (';
			print: (youngSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine.
		str	nextPutAll: '	free		';
			nextPutAll: (self formatVMParameter: (memorySize - youngSpaceEnd)); nextPutAll: ' bytes (';
			print: (memorySize - youngSpaceEnd / memorySize * 100) fractionDigits: 1; nextPutAll: '%)'; newLine].

	str	nextPutAll: 'GCs					';
		nextPutAll: (self formatVMParameter: (fullGCs + incrGCs)).
	fullGCs + incrGCs > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime / (fullGCs + incrGCs) fractionDigits: 1; 
			nextPutAll: ' ms between GCs'.
		 idleMs > 0 ifTrue:
			[str
				space;
				print: upTime - idleMs / (fullGCs + incrGCs) fractionDigits: 1; 
				nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime); nextPutAll: ' ms (';
		print: fullGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime)';
		nextPutAll: ', avg '; print: (fullGCTime / (fullGCs max: 1)) fractionDigits: 1; nextPutAll: ' ms'.
	(spur and: [fullGCCompactionTime ~= 0]) ifTrue:
		[str	newLine; nextPutAll: '		marking			';
			nextPutAll: (self formatVMParameter: (fullGCTime - fullGCCompactionTime)); nextPutAll: ' ms (';
			print: (fullGCTime - fullGCCompactionTime) / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: (fullGCTime - fullGCCompactionTime / (fullGCs max: 1)) fractionDigits: 1;
			nextPutAll: ' ms,'; newLine;
			nextPutAll: '		compacting			';
			nextPutAll: (self formatVMParameter: fullGCCompactionTime); nextPutAll: ' ms (';
			print: fullGCCompactionTime / fullGCTime * 100 fractionDigits: 1;
			nextPutAll: '%) avg '; print: fullGCCompactionTime / (fullGCs max: 1) fractionDigits: 1;
			nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: (spur ifTrue: ['	scavenges				'] ifFalse: ['	incr			']);
		nextPutAll: (self formatVMParameter: incrGCs); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime); nextPutAll: ' ms (';
		print: incrGCTime / (upTime - idleMs) * 100 fractionDigits: 2;
		nextPutAll: '% runtime), avg '; print: incrGCTime / incrGCs fractionDigits: 1; nextPutAll: ' ms'; newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount).
	tenureCount = 0 ifFalse:
		[spur
			ifTrue: [str nextPutAll: ' (avg '; print: tenureCount // (incrGCs max: 1); nextPutAll: ' tenures per scavenge)']
			ifFalse: [str nextPutAll: ' (avg '; print: incrGCs // tenureCount; nextPutAll: ' GCs/tenure)']].
	str	newLine.

	codeCompactionsOrNil ifNotNil:
		[str
			nextPutAll: '	code compactions				'.
		codeCompactionsOrNil = 0
			ifTrue: [str
				nextPutAll: codeCompactionsOrNil printString; newLine]
			ifFalse: [str
				nextPutAll: (self formatVMParameter: codeCompactionsOrNil); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime); nextPutAll: ' ms (';
				print: codeCompactionTime / (upTime - idleMs) * 100 fractionDigits: 3;
				nextPutAll: '% runtime), avg '; print: codeCompactionTime / codeCompactionsOrNil fractionDigits: 1; nextPutAll: ' ms'; newLine]].

LastStats ifNil: [LastStats := Array new: 9]
ifNotNil: [
	LastStats size < 9 ifTrue:
		[LastStats := LastStats, (Array new: 9 - LastStats size withAll: 0)].
	upTime2 := upTime - (LastStats at: 1).
	fullGCs2 := fullGCs - (LastStats at: 2).
	fullGCTime2 := fullGCTime - (LastStats at: 3).
	incrGCs2 := incrGCs - (LastStats at: 4).
	incrGCTime2 := incrGCTime - (LastStats at: 5).
	tenureCount2 := tenureCount - (LastStats at: 6).
	idleMs2 := idleMs - (LastStats at: 7).
	codeCompactionsOrNil ifNotNil:
		[codeCompactions2	:= codeCompactionsOrNil - (LastStats at: 8).
		 codeCompactionTime2	:= codeCompactionTime - (LastStats at: 9)].

	str	nextPutAll: 'GCs since last view					';
		nextPutAll: (self formatVMParameter: (fullGCs2 + incrGCs2)).
	fullGCs2 + incrGCs2 > 0 ifTrue:
		[str
			nextPutAll: ' ('; 
			print: upTime2 // (fullGCs2 + incrGCs2); 
			nextPutAll: ' ms between GCs'.
			idleMs2 > 0 ifTrue:
				[str
					nextPutAll: ', ';
					print: upTime2 - idleMs2 // (fullGCs2 + incrGCs2);
					nextPutAll: ' ms runtime between GCs'].
		 str nextPut: $)].
	str	newLine.
	str	nextPutAll: '	uptime				'; print: (upTime2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, runtime ';		   print: (upTime2 - idleMs2 / 1000.0) fractionDigits: 1;
		nextPutAll: ' s, idletime ';		   print: (idleMs2 / 1000.0) fractionDigits: 1; nextPutAll: ' s'; newLine.
	str	nextPutAll: '	full				';
		nextPutAll: (self formatVMParameter: fullGCs2).
	fullGCs2 + fullGCTime2 > 0 ifTrue:
		[str	nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: fullGCTime2); nextPutAll: ' ms (';
			print: fullGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
			nextPutAll: '% runtime)'.
		 str	nextPutAll: ', avg '; print: fullGCTime2 / (fullGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'].
	str	newLine.
	str	nextPutAll: (spur ifTrue: ['	scavenges				'] ifFalse: ['	incr			']);
		nextPutAll: (self formatVMParameter: incrGCs2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: incrGCTime2); nextPutAll: ' ms (';
		print: incrGCTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 1;
		nextPutAll: '% runtime), avg '; print: incrGCTime2 / (incrGCs2 max: 1) fractionDigits: 1; nextPutAll: ' ms'.
	str	newLine.
	str	nextPutAll: '	tenures				';
		nextPutAll: (self formatVMParameter: tenureCount2).
	tenureCount2 = 0 ifFalse:
		[spur
			ifTrue: [str nextPutAll: ' (avg '; print: tenureCount2 // (incrGCs2 max: 1); nextPutAll: ' tenures per scavenge)']
			ifFalse: [str nextPutAll: ' (avg '; print: incrGCs2 // tenureCount2; nextPutAll: ' GCs/tenure)']].
	str	newLine.
	codeCompactionsOrNil ifNotNil:
		[str	nextPutAll: '	code compactions				';
			nextPutAll: (self formatVMParameter: codeCompactions2); nextPutAll: ' totalling '; nextPutAll: (self formatVMParameter: codeCompactionTime2); nextPutAll: ' ms (';
			print: codeCompactionTime2 / (upTime2 - idleMs2) * 100 fractionDigits: 3;
			nextPutAll: '% runtime)'.
		 codeCompactions2 > 0 ifTrue:
			[str nextPutAll: ', avg '; print: codeCompactionTime2 / codeCompactions2 fractionDigits: 1; nextPutAll: ' ms'; newLine.]]
].
	LastStats := { upTime. fullGCs. fullGCTime. incrGCs. incrGCTime. tenureCount. idleMs. codeCompactionsOrNil. codeCompactionTime }.! !
!Cursor class methodsFor: 'instance creation' stamp: 'jmv 4/21/2022 14:59:41' prior: 16834708!
                               resizeForEdge: aSymbol 
	"Cursor resizeForEdge: #top"
	"Cursor resizeForEdge: #bottomLeft"

	"Do not erase this literal, as it helps 'senders' workproperly, and it protects these methods from accidental deletion"
	self nominallyUnsent: #(#resizeBottomCursor #resizeBottomLeftCursor #resizeBottomRightCursor #resizeLeftCursor #resizeRightCursor #resizeTopCursor #resizeTopLeftCursor #resizeTopRightCursor ).
	
	^ self perform: ('resize' , aSymbol capitalized, 'Cursor') asSymbol! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 4/21/2022 15:00:08' prior: 16893855!
  editBalloonHelpContent: aString
	self
		request: 'Edit the balloon help text for ' , self shortPrintString
		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString])
		do: [:reply|
			(reply isEmpty or: [reply asPlainString = self noHelpString])
				ifTrue: [self setBalloonText: nil]
				ifFalse: [self setBalloonText: reply]]! !
!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 4/21/2022 15:01:58' prior: 16911082!
      keyboardSearch: aChar 
	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |
	nextSelection _ oldSelection _ self getCurrentSelectionIndex.
	max _ self maximumSelection.
	milliSeconds _ Time localMillisecondClock.
	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"
		lastKeystrokes _ ''].
	lastKeystrokes _ lastKeystrokes copyWith: aChar asLowercase.
	lastKeystrokeTime _ milliSeconds.
	nextSelectionList _ OrderedCollection newFrom: (list copyFrom: oldSelection + 1 to: max).
	nextSelectionList addAll: (list copyFrom: 1 to: oldSelection).
	"Get rid of blanks and style used in some lists"
	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]
				ifNone: [^ self flash"match not found"].
	self owningWindow ifNotNil: [ :w |
		(w okToChangeDueTo: self) ifFalse: [^ self]].
	nextSelection _ list findFirst: [:a | a == nextSelectionText].
	"No change if model is locked"
	oldSelection == nextSelection ifTrue: [^ self flash].
	^ self setSelectionIndex: nextSelection! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 4/21/2022 15:03:31' prior: 16959496!
                 addTileResizerMenuTo: aMenu
	"We can look at preferences here to decide what too do"
	(Preferences tileResizerInWindowMenu) ifFalse: [
		aMenu add: 'resize full' 		action: #resizeFull icon: #resizeFullIcon;
		add: 'resize top' 				action: #resizeTop icon: #resizeTopIcon;
		add: 'resize left' 				action: #resizeLeft icon: #resizeLeftIcon;
		add: 'resize bottom' 			action: #resizeBottom icon: #resizeBottomIcon;
		add: 'resize right' 				action: #resizeRight icon: #resizeRightIcon;
		add: 'resize top left' 			action: #resizeTopLeft icon: #resizeTopLeftIcon;
		add: 'resize top right' 		action: #resizeTopRight icon: #resizeTopRightIcon;
		add: 'resize bottom left' 		action: #resizeBottomLeft icon: #resizeBottomLeftIcon;
		add: 'resize bottom right' 	action: #resizeBottomRight icon: #resizeBottomRightIcon]
	ifTrue: [ |resizeMorph|
		"Use embedded resize morph"
		resizeMorph _ TileResizeMorph new
							selectionColor: (self widgetsColor adjustSaturation: -0.2 brightness: 0.25) ;
							action: [:resize | |resizeMsg|
								resizeMsg _ ('resize', resize asPlainString capitalized) asSymbol.
								self perform: resizeMsg.
								aMenu delete];
							yourself.
		aMenu addMorphBack: resizeMorph].
	^aMenu.! !
!CodeWindow methodsFor: 'GUI building' stamp: 'jmv 4/21/2022 15:04:42' prior: 16821800!
  optionalButtonRow
	"Answer a row of control buttons"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph
			model: self
			stateGetter: nil
			action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		tuple size > 3 ifTrue: [ button setBalloonText: tuple fourth ].
		tuple size > 4 ifTrue: [ button secondaryActionSelector: tuple fifth ].
		buttons add: button ].
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row
		addMorphs: buttons
		widthProportionalTo: widths.
	^ row.! !
!ChangeListWindow methodsFor: 'GUI building' stamp: 'jmv 4/21/2022 15:04:52' prior: 16802773 overrides: 50344340!
                   optionalButtonRow
	"Answer a row of buttons to occur in a tool pane"

	| row buttons widths buttonColor |
	buttons _ OrderedCollection new.
	widths _ OrderedCollection new.
	buttonColor _ self buttonColor.
	self optionalModelButtonTuples do: [ :tuple | | button |
		widths add: tuple first.
		button _ PluggableButtonMorph 
					model: model
					stateGetter: nil
					action: tuple third.
		button color: buttonColor.
		button label: tuple second.
		buttons add: button.
		button setBalloonText: tuple fourth].
	buttons add: self lineDiffButton.
	widths add: 14.
	buttons add: self wordDiffButton.
	widths add: 16.
	model wantsPrettyDiffOption ifTrue: [
		buttons add:  self prettyLineDiffButton.
		widths add: 21.
		buttons add:  self prettyWordDiffButton.
		widths add: 23 ].
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons widthProportionalTo: widths.
	^row! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 4/21/2022 15:05:08' prior: 16839672!
             customButtonRow
	"Answer a button pane affording the user one-touch access to certain functions; the pane is given the formal name 'customButtonPane' by which it can be retrieved by code wishing to send messages to widgets residing on the pane"

	| button buttons row buttonColor |
	
	buttons _ OrderedCollection new.
	buttonColor _ self buttonColor.
	"button with target = self"
	button _ PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #proceed.
	button color: buttonColor.
	button label: 'Proceed'.
	button setBalloonText: 'close the debugger and proceed.'.
	buttons add: button.
	"buttons with model target"
	self customButtonSpecs do: [ :tuple |
		button _ PluggableButtonMorph 
					model: self
					stateGetter: nil
					action: tuple second.
		button color: buttonColor.
		button label: tuple first.
		tuple size > 2 ifTrue: [button setBalloonText: tuple third].
		buttons add: button].

	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.
	row addMorphs: buttons.
	^row! !
!ProcessBrowserWindow methodsFor: 'menu commands' stamp: 'jmv 4/21/2022 15:05:23' prior: 16919065!
                            changePriority
	| newPriority rule |
	rule _ (model class rulesFor: model selectedProcess) second.
	rule
		ifFalse: [self inform: 'Nope, won''t change priority of ' , model selectedProcess name.
			^ self].
	self request: 'New priority'
		initialAnswer: model selectedProcess priority printString
		verifying: [:aString| ([aString asNumber asInteger] on: Error do: []) isInteger]
		do: [:aString|
			newPriority _ aString asNumber asInteger.
			(newPriority between: 1 and: Processor highestPriority)
			ifTrue:
				[model class setProcess: model selectedProcess toPriority: newPriority.
				model updateProcessList]
			ifFalse: [self inform: 'Bad priority']]! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 4/21/2022 15:06:17' prior: 16782844!
              calculateWidth

	| width font |

	width _ 120.
	font _ self class listFont.

	1
		to: self entryCount
		do: [ :index | width _ width max: (font widthOfString: (completer entries at: index) asPlainString)].

	self entryCount > self itemsPerPage ifTrue: [ width _ width + ScrollBar scrollbarThickness ].

	^ width ! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 4/21/2022 15:06:25' prior: 16782888!
         drawItemOf: index on: aCanvas width: width top: itemTop

	| rectangle entry |
	
	rectangle _ 1@itemTop extent: width@self itemHeight.
	index = self selected ifTrue: [ aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].

	entry _ completer entries at: index.
	aCanvas
		drawString: entry asPlainString
		at: rectangle topLeft
		font: self class listFont
		color: (self colorOf: entry).
	! !
!TheWorldMenu methodsFor: 'private' stamp: 'jmv 4/21/2022 15:07:11' prior: 16970504!
   pvtNewMenuForSplitLists: splitLists
| firstChar lastChar menu subMenu |
menu := MenuMorph new defaultTarget: self.
	1
		to: splitLists size
		do: [ :i |
			firstChar := i = 1
				ifTrue: [ $A ]
				ifFalse: [ 
					(splitLists at: i) first name first: 3 ].
			lastChar := i = splitLists size
				ifTrue: [ $Z ]
				ifFalse: [ 
					(splitLists at: i) last name first: 3 ].
			subMenu := MenuMorph new.
			(splitLists at: i) do: [ :cl |
				subMenu
					add: cl name
					target: self
					action: #newMorphOfClass:event:
					argument: cl ].
			menu
				add: (String with: firstChar) , ' - ' , (String with: lastChar)
				subMenu: subMenu ].
	^ menu.! !
!ChangeRecord methodsFor: 'access' stamp: 'jmv 4/22/2022 12:04:22' prior: 16803213 overrides: 16802727!
          fileOutOn: aFileStream
	"File the receiver out on the given file stream"

	| aString |
	type == #method
		ifTrue: [
			aFileStream newLine; nextPut: $!!.
			aString _  class printString
							, (meta ifTrue: [' class methodsFor: ']
									ifFalse: [' methodsFor: '])
							, category asString printString.
			stamp ifNotNil: [
				aString _ aString, ' stamp: ''', stamp, ''''].
			aFileStream nextChunkPut: aString.
			aFileStream newLine ].

	type == #preamble ifTrue: [ aFileStream nextPut: $!! ].

	type == #classComment
		ifTrue: [
			aFileStream nextPut: $!!.
			aFileStream nextChunkPut: class printString, ' commentStamp: ', stamp storeString.
			aFileStream newLine ].
		
	type == #classDefinition ifTrue: [
		aFileStream nextPut: $!!.
		aFileStream nextChunkPut: 
			'classDefinition: ', 
			(self isMetaClassChange ifTrue: [self changeClassName, ' class'] ifFalse: [self changeClassName]) printString,
			' category: ', self category printString.
		aFileStream newLine ].

	aFileStream nextChunkPut: self string.
	
	type == #method ifTrue: [ aFileStream nextChunkPut: ' '; newLine ].
	type == #classComment ifTrue: [ aFileStream newLine ].
	aFileStream newLine! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/21/2022 15:08:37' prior: 16806158!
                 postscriptString
	"Answer the string representing the postscript.  "

	^ postscript
		ifNil: [postscript]
		ifNotNil: [postscript actualContents asPlainString]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/21/2022 15:08:40' prior: 16806172!
        preambleString
	"Answer the string representing the preamble"

	^ preamble
		ifNotNil: [ preamble actualContents asPlainString ]! !
!PseudoClass methodsFor: 'removing' stamp: 'jmv 4/21/2022 15:09:34' prior: 16920866!
       removeAllUnmodified
	| stClass |
	self exists ifFalse:[^self].
	self removeUnmodifiedMethods: self selectors.
	stClass := self realClass.
	(self hasDefinition and:[stClass definition = self definition]) ifTrue:[definition := nil].
	(self hasComment and:[stClass comment asPlainString = self comment asPlainString]) ifTrue:[ self classComment: nil].
	metaClass ifNotNil: [ metaClass removeAllUnmodified]! !
!PseudoClass methodsFor: 'removing' stamp: 'jmv 4/21/2022 15:09:46' prior: 16920880!
                     removeUnmodifiedMethods: aCollection
	| stClass |
	self exists ifFalse:[^self].
	stClass := self realClass.
	aCollection do:[:sel|
		(self sourceCodeAt: sel) = (stClass sourceCodeAt: sel ifAbsent:['']) asPlainString ifTrue:[
			self removeMethod: sel.
		].
	].
	self organization removeEmptyCategories.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5112-AFewMore-JuanVuletich-2022Apr22-12h02m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5112] on 22 April 2022 at 12:16:44 pm'!
!LabelMorph commentStamp: '<historical>' prior: 16877578!
                    LabelMorph is a "lightweight" Morph to display a String. It supports only a single font, color, and emphasis combination. For multiple text styles, use TextModelMorph or TextParagraphMorph.

Structure:
instance var    	Type              Description 
font 			StrikeFont 		(normally nil; then the accessor #font gives back  a Font or nil #defaultFont) 
emphasis 		SmallInteger	bitmask determining character attributes (underline, bold, 	italics, struckThrough) 
contents 		String 			The text that will be displayed. 
!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5113-LabelMorph-comment-JuanVuletich-2022Apr22-12h16m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5113] on 24 April 2022 at 2:00:40 pm'!
!TheWorldMenu methodsFor: 'private' stamp: 'jmv 4/24/2022 13:59:58' prior: 50344488!
                             pvtNewMenuForSplitLists: splitLists
	| firstPrefix lastPrefix menu subMenu |
	menu _ MenuMorph new defaultTarget: self.
	1
		to: splitLists size
		do: [ :i |
			firstPrefix _ i = 1
				ifTrue: [ 'A' ]
				ifFalse: [ (splitLists at: i) first name first: 3 ].
			lastPrefix _ i = splitLists size
				ifTrue: [ 'Z' ]
				ifFalse: [ (splitLists at: i) last name first: 3 ].
			subMenu _ MenuMorph new.
			(splitLists at: i) do: [ :cl |
				subMenu
					add: cl name
					target: self
					action: #newMorphOfClass:event:
					argument: cl ].
			menu
				add: firstPrefix , ' - ' , lastPrefix
				subMenu: subMenu ].
	^ menu.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5114-FixRecentBreakage-JuanVuletich-2022Apr24-13h56m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5114] on 25 April 2022 at 11:13:18 am'!
!Object methodsFor: 'printing' stamp: 'jmv 4/25/2022 10:36:41' prior: 16903030!
                       shortPrintString
	"Answer a String whose characters are a description of the receiver.
	This is a short one, good for showing users (for example, in ObjectExplorers).
	If you want to print without a character limit, use fullPrintString.

	This description is to be meaningful for a Smalltalk programmer and usually includes
	a hint on the class of the object.

	Usually you should not reimplement this method in subclasses, but #printOn:

	See the comments at:
		#printString
		#displayStringOrText
		#asString
		#storeString"

	^ self printStringLimitedTo: 128.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5115-shortPrintString-aBitLarger-JuanVuletich-2022Apr25-10h36m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5114] on 25 April 2022 at 11:04:24 am'!
!Pragma commentStamp: 'HAW 4/25/2022 11:03:54' prior: 16914659!
                       I represent an occurrence of a pragma in a compiled method.  A pragma is a literal message pattern that occurs between angle brackets at the start of a method after any temporaries.  A common example is the primitive pragma:
	<primitive: 123 errorCode: 'errorCode'>
but one can add one's own and use them as metadata attached to a method.  Because pragmas are messages one can browse senders and implementors and perform them.  One can query a method for its pragmas by sending it the pragmas message, which answers an Array of instances of me, one for each pragma in the method.

I can provide information about the defining class, method, its selector, as well as the information about the pragma keyword and its arguments. See the two 'accessing' protocols for details. 'accessing-method' provides information about the method the pragma is found in, while 'accessing-pragma' is about the pragma itself.

Instances are retrieved using one of the pragma search methods of the 'finding' protocol on the class side.

To browse all methods with pragmas in the system evaluate
	Smalltalk browseAllSelect: [:m| m pragmas notEmpty]
and to browse all nonprimitive methods with pragmas evaluate
	Smalltalk browseAllSelect: [:m| m primitive isZero and: [m pragmas notEmpty]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5116-PragmaDocumentationFix-HernanWilkinson-2022Apr25-11h03m-HAW.001.cs.st----!

'From Cuis 6.0 [latest update: #5116] on 30 April 2022 at 7:35:28 pm'!
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 4/30/2022 19:34:06' prior: 50337402!
                              showBalloon: msgString
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	self world ifNotNil: [ :w |
		self showBalloon: msgString hand: w activeHand ].! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 4/30/2022 19:32:54' prior: 50337589!
             showBalloon: msgStringOrText hand: aHand doWordWrap: aBoolean
	"Pop up a balloon containing the given string,
	first removing any existing BalloonMorphs in the world."

	| balloon |
	balloon _ HoverHelpMorph contents: msgStringOrText doWordWrap: aBoolean.
	
	"Do it in a while. In some cases, processing the event that
	might have triggered us might also remove any Help Balloon"
	UISupervisor whenUIinSafeState: [
		balloon popUpForHand: aHand ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5117-BalloonMorph-tweaks-JuanVuletich-2022Apr30-19h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5117] on 2 May 2022 at 10:45:22 am'!
!CompiledMethod methodsFor: 'source code management' stamp: 'len 4/30/2022 18:38:39' prior: 16829062!
               getPreambleFrom: aFileStream at: position
	|  writeStream c p |
	writeStream _ String new writeStream.
	p _ position - 1.
	c _ nil.
	aFileStream position: p.
	aFileStream atEnd ifTrue: [ ^ nil ].
	[ p >= 0 and: [ c ~~ $!! ]] whileTrue: [
		aFileStream position: p.
		c _ aFileStream basicNext.
		p _ p - 1 ].
	[ p >= 0] whileTrue: [
		aFileStream position: p.
		c _ aFileStream basicNext.
		c == $!!
			ifTrue: [^ writeStream contents reverse ]
			ifFalse: [ writeStream nextPut: c ].
		p _ p - 1 ].
	^ nil! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5118-MethodPreambleFix-forExclamationMarkSelector-LucianoEstebanNotarfrancesco-2022May02-10h37m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5117] on 1 May 2022 at 1:28:07 pm'!
!Bag methodsFor: 'enumerating' stamp: 'len 5/1/2022 13:24:53' overrides: 16823144!
                               collect: aBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument. Collect the resulting values into a collection that is like the receiver and nswer the new collection."
	| answer |
	answer _ self species new.
	self withOccurrencesDo: [:each :times| answer add: (aBlock value: each) withOccurrences: times].
	^ answer! !
!Bag methodsFor: 'enumerating' stamp: 'len 5/1/2022 13:25:01' overrides: 16823221!
                     count: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument.  Return the number that answered true."
	| count |
	count _ 0.
	self withOccurrencesDo: [:each :times| (aBlock value: each) ifTrue: [count _ count + times]].
	^ count! !
!Bag methodsFor: 'enumerating' stamp: 'len 5/1/2022 13:22:14'!
 withOccurrencesDo: aBlock
	contents associationsDo: [:each| aBlock value: each key value: each value]! !
!Collection methodsFor: 'enumerating' stamp: 'len 5/1/2022 13:25:40' prior: 16823221!
 count: aBlock
	"Evaluate aBlock with each of the receiver's elements as the argument.  Return the number that answered true."
	| count |
	count _ 0.
	self do: [:each| (aBlock value: each) ifTrue: [count _ count + 1]].
	^ count! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5119-FasterCollectionCountAndBagCollectAndCount-LucianoEstebanNotarfrancesco-2022May01-13h21m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5119] on 2 May 2022 at 11:17:37 am'!
!Browser methodsFor: 'system category list' stamp: 'len 5/1/2022 14:21:49' prior: 50333979!
               systemCategoryRoots
	"Answer the roots of the forest of system categories."
	| categories subcategories roots name |
	categories _ self systemCategoryList.
	subcategories _ Dictionary new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(subcategories at: name ifAbsentPut: [OrderedCollection new]) add: each].
	roots _ OrderedCollection new.
	categories do: [:each|
		name _ (each findTokens: '-') first.
		(roots includes: name) ifFalse:
			[(subcategories at: name) size > 1 ifTrue: [roots add: name] ifFalse: [roots add: (subcategories at: name) first]]].
	^ roots collect: [:each| SystemCategoryWrapper with: each name: each model: self]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5120-systemCategotyRoots-fixRaceCondition-LucianoEstebanNotarfrancesco-2022May02-11h17m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5116] on 28 April 2022 at 12:03:39 pm'!
!ArrayedCollection methodsFor: 'testing' stamp: 'jmv 4/27/2022 10:28:41' overrides: 16823965!
                               isEmpty
	^self size = 0! !
!Interval methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:20:19' overrides: 16823965!
              isEmpty
	^self size = 0! !
!OrderedCollection methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:20:47' overrides: 16823965!
     isEmpty
	^self size = 0! !
!RunArray methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:24:21' overrides: 16823965!
              isEmpty
	^runs size = 0! !
!Text methodsFor: 'testing' stamp: 'jmv 4/28/2022 11:17:59' overrides: 16823965!
                    isEmpty
	^self size = 0! !
!Object methodsFor: 'copying' stamp: 'jmv 4/27/2022 12:36:30' prior: 16901914!
                      copyForClipboard
	"The answer is used both for internal (Smalltalk) and external (Host OS) clipboard.
	Some subclasses might need specific behavior."
	^self copy! !
!CodeProvider methodsFor: 'annotation' stamp: 'jmv 4/28/2022 11:40:04' prior: 16820527!
   annotationForSelector: aSelector ofClass: aClass 
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	^ String streamContents: [ :strm |
		Preferences methodAnnotations
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp _ self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						strm
							print: ((aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm | cm linesOfCode]);
							nextPutAll: ' lines of code' ].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount _ Smalltalk numberOfSendersOf: aSelector.
						sendersCount _ sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount _ Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount _ implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp _ VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						(aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm |
							(CodePackage packageOfMethod: cm methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList _ (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					[#closuresInfo] -> [
						strm nextPutAll: (aClass closuresInfoAt: aSelector)].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ] ].! !
!CodeProvider methodsFor: 'commands' stamp: 'jmv 4/28/2022 11:40:20' prior: 16820882!
 removeClass
	"Remove the selected class from the system, at interactive user request.  Make certain the user really wants to do this, since it is not reversible.  Answer true if removal actually happened."

	| message  className classToRemove result |
	classToRemove _ self selectedClassOrMetaClass ifNil: [Smalltalk beep. ^ false].
	classToRemove _ classToRemove theNonMetaClass.
	className _ classToRemove name.
	message _ 'Are you certain that you
want to REMOVE the class ', className, '
from the system?'.
	(result _ self confirm: message)
		ifTrue: [
			classToRemove subclasses notEmpty
				ifTrue: [(self confirm: 'class has subclasses: ' , message)
					ifFalse: [^ false]].
			classToRemove removeFromSystem.
			self changed: #classList.
			true].
	^ result! !
!Browser methodsFor: 'accessing' stamp: 'jmv 4/27/2022 11:17:38' prior: 16794998 overrides: 16820774!
                       acceptedStringOrText
	"Depending on the current selection, different information is retrieved.
	Answer a string description of that information. This information is the
	method of the currently selected class and message."

	| comment theClass latestCompiledMethod |
	latestCompiledMethod _ currentCompiledMethod.
	currentCompiledMethod _ nil.

	editSelection == #none ifTrue: [^ ''].
	editSelection == #editSystemCategories 
		ifTrue: [^ systemOrganizer printString].
	self isEditingNewClass 
		ifTrue: [^ (theClass _ self selectedClass)
			ifNil: [
				Class template: selectedSystemCategory]
			ifNotNil: [
				Class templateForSubclassOf: theClass category: selectedSystemCategory]].
	self isEditingExistingClass 
		ifTrue: [^ self classDefinitionText ].
	editSelection == #editComment 
		ifTrue: [
			(theClass _ self selectedClass) ifNil: [^ ''].
			comment _ theClass comment.
			currentCompiledMethod _ theClass organization commentRemoteStr.
			^ comment isEmpty
				ifTrue: ['This class has not yet been commented.']
				ifFalse: [comment]].
	editSelection == #editMessageCategories 
		ifTrue: [^ self classOrMetaClassOrganizer printString].
	editSelection == #newMessage
		ifTrue: [
			^ (theClass _ self selectedClassOrMetaClass) 
				ifNil: ['']
				ifNotNil: [theClass sourceCodeTemplate]].
	editSelection == #editMessage
		ifTrue: [
			self showingByteCodes ifTrue: [^ self selectedBytecodes].
			currentCompiledMethod _ latestCompiledMethod.
			^ self selectedMessage].

	self error: 'Browser internal error: unknown edit selection.'! !
!Browser methodsFor: 'class list' stamp: 'jmv 4/27/2022 11:18:00' prior: 50334173!
                            recent
	"Let the user select from a list of recently visited classes.  11/96 stp.
	 12/96 di:  use class name, not classes themselves.
	 : dont fall into debugger in empty case"

	| className class recentList |
	recentList _ self class recentClasses select: [:n | Smalltalk includesKey: n].
	recentList isEmpty ifTrue: [^ Smalltalk beep].
	className _ (SelectionMenu selections: recentList) startUpMenu.
	className ifNil: [^ self].
	class _ Smalltalk at: className.
	self setSelectedSystemCategory: class category.
	self selectClass: class! !
!Browser methodsFor: 'message category functions' stamp: 'jmv 4/27/2022 11:18:05' prior: 16795849!
                              removeMessageCategory
	"If a message category is selected, create a Confirmer so the user can 
	verify that the currently selected message category should be removed
 	from the system. If so, remove it."

	| messageCategoryName |
	selectedMessageCategory ifNil: [^ self].
	messageCategoryName _ self selectedMessageCategoryName.
	(self messageList isEmpty
		or: [self confirm: 'Are you sure you want to
remove this method category 
and all its methods?'])
		ifTrue: [
			self selectedClassOrMetaClass removeCategory: messageCategoryName.
			self messageCategoryListIndex: 0.
			self changed: #classSelectionChanged].
	self changed: #messageCategoryList.
! !
!Browser methodsFor: 'system category functions' stamp: 'jmv 4/28/2022 11:40:27' prior: 50334237!
            moveAllToOtherSystemCategory
	"If a class category is selected, prompt user for category to move to,
	create a Confirmer so the user can verify that all the classes in current category
 	should be moved to the selected category."
	| newSystemCategory |
	selectedSystemCategory ifNil: [ ^ self ].
	newSystemCategory _ Smalltalk systemCategoryFromUserWithPrompt: 'Move classes to System Category...'.
	(newSystemCategory notNil and: [
		self classList notEmpty and: [ self confirm: 'Are you sure you want to
move classes from ' , selectedSystemCategory , ' 
to ' , newSystemCategory , '?' ]]) ifTrue: [
		"Safer this way (#classList will be a collection of strings with spaces and who knows what in the future.  So let's just get the classes we need directly)"
		(SystemOrganization classesAt: selectedSystemCategory) do: [ :eaClass |
			eaClass category: newSystemCategory ].
		self changed: #systemCategoryRoots ].! !
!Browser methodsFor: 'system category functions' stamp: 'jmv 4/27/2022 11:18:09' prior: 50335092!
        removeSystemCategory
	"If a class category is selected, create a Confirmer so the user can 
	verify that the currently selected class category and all of its classes
 	should be removed from the system. If so, remove it."

	selectedSystemCategory ifNil: [^ self].
	(self classList isEmpty
		or: [self confirm: 'Are you sure you want to
remove this system category 
and all its classes?'])
		ifTrue: [
			"Remove subcategories:"
			systemOrganizer removeCategoriesMatching: selectedSystemCategory, '-*'.
			"Then remove the top category (it doesn't do anything if it doesn't exist):"
			systemOrganizer removeSystemCategory: selectedSystemCategory.
			self setSelectedSystemCategory: nil.
			self changed: #systemCategoryRoots ]! !
!MessageSet methodsFor: 'private' stamp: 'jmv 4/27/2022 11:18:12' prior: 16886626!
                  setFilteredList: newList
	"Establish newList as the new list if appropriate, and adjust the window title accordingly; if the new list is of the same size as the old, warn and do nothing"

	newList isEmpty
		ifTrue: [
			^ self inform: 'Nothing would be left in the list if you did that'].
	newList size = messageList size
		ifTrue: [
			^ self inform: 'That leaves the list unchanged'].
	self initializeMessageList: newList.
	self changed: #relabel! !
!MessageNames methodsFor: 'search' stamp: 'jmv 4/28/2022 11:40:38' prior: 16883883!
        computeSelectorListFromSearchString
	"Compute selector list from search string"
	| sorted |
	sorted _ SortedCollection sortBlock: [ :x :y |
		x asLowercase <= y asLowercase ].
	(searchString findBetweenSubStrs: ';') do: [ :selPat | | raw n m |
		selPat notEmpty ifTrue: [
			(selPat first = $" and: [
				selPat last = $" and: [ selPat size > 2 ]])
				ifTrue: [
					Symbol
						hasInterned:
							(selPat
								copyFrom: 2
								to: selPat size - 1)
						ifTrue: [ :sym |
							sorted add: sym ]]
				ifFalse: [
					raw _ ((n _ selPat occurrencesOf: $*) > 0 | ((m _ selPat occurrencesOf: $#) > 0) and: [ selPat size > (n + m) ])
						ifTrue: [ Symbol selectorsMatching: selPat ]
						ifFalse: [ Symbol selectorsContaining: selPat ].
					sorted addAll: raw ]]].
	selectorList _ sorted asArray  select: [ :sym |
		(Smalltalk isThereAnImplementorOf: sym) or: [ Smalltalk isThereAReferenceTo: sym ]].
	^ selectorList.! !
!MessageNames methodsFor: 'selector list' stamp: 'jmv 4/28/2022 11:40:43' prior: 16883930 overrides: 16886320!
              messageList
	"Answer the receiver's message list, computing it if necessary. The way 
	to force a recomputation is to set the messageList to nil"
	messageList
		ifNil: [
			messageList _ selectedSelector
				ifNil: [#()]
				ifNotNil: [
					Smalltalk allImplementorsOf: selectedSelector].
			self initializeMessageList: messageList.
			self messageListIndex: (messageList notEmpty
				ifTrue: [1]
				ifFalse: [0])
			].
	^ messageList! !
!SinglePackageBrowser methodsFor: 'lists' stamp: 'jmv 4/27/2022 11:18:16' prior: 16936688 overrides: 50335818!
                         defaultClassList
	"Answer an array of the class names of the selected category. Answer an 
	empty array if no selection exists."
	| answer |
	answer _ selectedSystemCategory
		ifNil: [#()]
		ifNotNil: [
			(package includesSystemCategory: selectedSystemCategory)
				ifTrue: [ systemOrganizer listAtCategoryNamed: selectedSystemCategory ]
				ifFalse: [ 
					package extensionClassNamesIn: (selectedSystemCategory copyFrom: 2 to: selectedSystemCategory size) ]].
	selectedClassName ifNil: [
		answer isEmpty ifFalse: [
			selectedClassName _ answer first.
			self setClassOrganizer.
			self editSelection: #editClass ]].
	^answer! !
!SinglePackageBrowser methodsFor: 'lists' stamp: 'jmv 4/27/2022 11:18:20' prior: 16936711 overrides: 16795936!
                       messageCategoryList
	"Answer the selected category of messages."

	"Do not include the -- all -- category"
	| answer |
	answer _ self rawMessageCategoryList.
	selectedMessageCategory ifNil: [
		answer isEmpty ifFalse: [
			(package includesSystemCategory: selectedSystemCategory) ifFalse: [
				selectedMessageCategory _ answer first ]]].
	^answer! !
!SinglePackageBrowser methodsFor: 'lists' stamp: 'jmv 4/27/2022 11:18:23' prior: 16936725 overrides: 16796114!
                  messageList
	"Answer an Array of the message selectors of the currently selected message category, provided that the messageCategoryListIndex is in proper range.  Otherwise, answer an empty Array  If messageCategoryListIndex is found to be larger than the number of categories (it happens!!) (??), it is reset to zero."

	| answer |
	answer _ selectedMessageCategory
		ifNil: [ #() ]
		ifNotNil: [
			(self classOrMetaClassOrganizer listAtCategoryNamed: selectedMessageCategory) ifNil: [
				selectedMessageCategory _ nil.
				#() ]].
	selectedMessage ifNil: [
		answer isEmpty ifFalse: [
			(package includesSystemCategory: selectedSystemCategory) ifFalse: [
				selectedMessage _ answer first.
				self editSelection: #editMessage ]]].
	^answer! !
!CodeFileBrowser methodsFor: 'removing' stamp: 'jmv 4/27/2022 11:18:26' prior: 16818147 overrides: 50345145!
     removeMessageCategory
	"If a message category is selected, create a Confirmer so the user can 
	verify that the currently selected message category should be removed
 	from the system. If so, remove it."

	| messageCategoryName |
	selectedMessageCategory ifNil: [ ^self ].
	messageCategoryName _ self selectedMessageCategoryName.
	(self messageList isEmpty
		or: [self confirm: 'Are you sure you want to
remove this method category 
and all its methods?']) ifFalse: [^ self].
	self selectedClassOrMetaClass removeCategory: messageCategoryName.
	self messageCategoryListIndex: 0.
	self changed: #messageCategoryList.! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 4/28/2022 11:41:06' prior: 16801795!
                             destroyCurrentCodeOfSelections
	"Actually remove from the system any in-memory methods with class and selector identical to items current selected.  This may seem rather arcane but believe me it has its great uses, when trying to split out code.  To use effectively, first file out a change set that you wish to split off.  Then open a ChangeList browser on that fileout.  Now look through the methods, and select any of them which you want to remove completely from the system, then issue this command.  For those methods where you have made changes to pre-existing versions, of course, you won't want to remove them from the system, so use this mechanism with care!!"

	|  aClass aChange aList |
	aList _ OrderedCollection new.
	1 to: changeList size do:
		[:index |
			(listSelections at: index) ifTrue:
				[aChange _ changeList at: index.
				(aChange changeType == #method
					and: [(aClass _ aChange changeClass) notNil
					and: [aClass includesSelector: aChange methodSelector]])
						ifTrue:
							[aList add: {aClass. aChange methodSelector}]]].

	aList notEmpty ifTrue: [
		(self confirm: 'Warning!! This will actually remove ', aList size printString,  ' method(s) from the system!!') ifFalse: [^ self]].
	aList do: [ :aPair |
		Transcript newLine; show: 'Removed: ', aPair first printString, '.', aPair second.
		aPair first removeSelector: aPair second ]! !
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 4/27/2022 11:18:28' prior: 16801925!
        removeNonSelections
	"Remove the unselected items from the receiver."

	| newChangeList newList |

	newChangeList _ OrderedCollection new.
	newList _ OrderedCollection new.

	1 to: changeList size do: [ :i | 
		(listSelections at: i) ifTrue: [
			newChangeList add: (changeList at: i).
			newList add: (list at: i)]].
	newChangeList isEmpty ifTrue: [
		^ self inform: 'That would remove everything.
Why would you want to do that?'].

	newChangeList size < changeList size
		ifTrue: [
			changeList _ newChangeList.
			list _ newList.
			listIndex _ 0.
			self clearSelections ].
	self changed: #list

	! !
!ChangeList class methodsFor: 'public access' stamp: 'jmv 4/28/2022 11:40:57' prior: 16802548!
   browseRecentLogOn: origChangesFileEntry
	"figure out where the last snapshot or quit was, then browse the recent entries."

	| end done block positions prevBlock |
	origChangesFileEntry readStreamDo: [ :changesFile |
		positions _ SortedCollection new.
		end _ changesFile size.
		prevBlock _ end.
		block _ end - 1024 max: 0.
		done _ false.
		[ done or: [ positions notEmpty ]]
			whileFalse: [
				changesFile position: block.
				"ignore first fragment"
				changesFile nextChunk.
				[ changesFile position < prevBlock ]
					whileTrue: [
						| pos chunk |
						pos _ changesFile position.
						chunk _ changesFile nextChunk.
						((Smalltalk isQuitRecord: chunk) or: [ Smalltalk isSnapshotRecord: chunk ])
							ifTrue: [ positions add: pos ]].
				block = 0
					ifTrue: [done _ true]
					ifFalse: [
						prevBlock _ block.
						block _ block - 1024 max: 0]].
	].
	self browseRecentLogOn: origChangesFileEntry startingFrom: (positions isEmpty ifTrue: [0] ifFalse: [positions last])! !
!VersionsBrowser methodsFor: 'misc' stamp: 'jmv 4/28/2022 11:41:10' prior: 16978399 overrides: 16820451!
              addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream
	"Add an annotation detailing the prior versions count.  Specially handled here for the case of a selector no longer in the system, whose prior versions are seen in a versions browser -- in this case, the inherited version of this method will not work."

	(aClass includesSelector: aSelector) ifTrue:
		[^ super addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream].

	aStream nextPutAll: 
		((changeList notEmpty
			ifTrue:
				[changeList size = 1
					ifTrue:
						['deleted - one prior version']
					ifFalse:
						['deleted - ', changeList size printString, ' prior versions']]
			ifFalse:
				['surprisingly, no prior versions']))! !
!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 4/27/2022 11:18:31' prior: 16807250!
       rename
	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"

	self request: 'New name for this change set' initialAnswer: myChangeSet name do: [:newName|
		(newName = myChangeSet name or: [newName isEmpty])
			ifTrue: [Smalltalk beep]
			ifFalse:
				[(ChangeSet changeSetNamed: newName) notNil
					ifTrue: [self inform: 'Sorry that name is already used']
					ifFalse:
						[myChangeSet name: newName.
						self update.
						self changed: #mainButtonName.
						self changed: #relabel]]]! !
!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 4/28/2022 11:41:16' prior: 16807489!
       contents: aString notifying: aRequestor 
	"Compile the code in aString. Notify aRequestor of any syntax errors. 
	Create an error if the category of the selected message is unknown. 
	Answer false if the compilation fails. Otherwise, if the compilation 
	created a new method, deselect the current selection. Then answer true."
	| category selector class oldSelector |

	(class _ self selectedClassOrMetaClass) ifNil:
		[(myChangeSet preambleString == nil or: [aString isEmpty]) ifTrue: [ ^ false].
		(aString count: [:char | char == $"]) odd 
			ifTrue: [self inform: 'unmatched double quotes in preamble']
			ifFalse: [(Scanner new scanTokens: aString) notEmpty ifTrue: [
				self inform: 'Part of the preamble is not within double-quotes.
To put a double-quote inside a comment, type two double-quotes in a row.
(Ignore this warning if you are including a doIt in the preamble.)']].
		myChangeSet preambleString: aString.
		self currentSelector: nil.  "forces update with no 'unsubmitted chgs' feedback"
		^ true].
	oldSelector _ self selectedMessageName.
	category _ class organization categoryOfElement: oldSelector.
	selector _ class compile: aString
				classified: category
				notifying: aRequestor.
	selector ifNil: [^ false].
	(self messageList includes: selector)
		ifTrue: [self currentSelector: selector]
		ifFalse: [self currentSelector: oldSelector].
	self update.
	^ true! !
!Behavior methodsFor: 'accessing method dictionary' stamp: 'jmv 4/27/2022 11:16:48' prior: 50341894!
           firstCommentAt:  selector
	"Answer a string representing the first comment in the method associated with selector.  Return an empty string if the relevant source file is not available, or if the method's source code does not contain a comment.  Not smart enough to bypass quotes in string constants, but does map doubled quote into a single quote."

	| sourceString commentStart  pos nextQuotePos |

	sourceString _ (self sourceCodeAt: selector) asPlainString.
	sourceString isEmpty ifTrue: [^ ''].
	commentStart _ sourceString findString: '"' startingAt: 1.
	commentStart = 0 ifTrue: [^ ''].
	pos _ commentStart + 1.
	[(nextQuotePos _ sourceString findString: '"' startingAt: pos) = (sourceString findString: '""' startingAt: pos)]
		whileTrue:
			[pos _ nextQuotePos + 2].
	
	commentStart = nextQuotePos ifTrue: [^ ''].  "Must have been a quote in string literal"

	^ (sourceString copyFrom: commentStart + 1 to: nextQuotePos - 1) copyReplaceAll: '""' with: '"'


"Behavior firstCommentAt: #firstCommentAt:"! !
!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'jmv 4/28/2022 11:54:23' prior: 16813851!
removeUninstantiatedSubclassesSilently
	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"
	"Player removeUninstantiatedSubclassesSilently"

	| candidatesForRemoval  oldFree |

	oldFree _ Smalltalk garbageCollect.
	candidatesForRemoval _
		self subclasses select: [:c |
			(c instanceCount = 0) and: [c subclasses isEmpty]].
	candidatesForRemoval do: [:c | c removeFromSystem].
	^ Smalltalk garbageCollect - oldFree! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/27/2022 11:16:54' prior: 16814395!
                           classComment: aString stamp: aStamp
	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."

	| ptr header oldCommentRemoteStr |
	aString isRemote ifTrue: [
		SystemChangeNotifier uniqueInstance classCommented: self.
		^ self organization classComment: aString stamp: aStamp].

	oldCommentRemoteStr _ self organization commentRemoteStr.
	(aString isEmpty) & (oldCommentRemoteStr == nil) ifTrue: [^ self organization classComment: nil].
		"never had a class comment, no need to write empty string out"

	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].
	SourceFiles ifNotNil: [ | file |
		(file _ SourceFiles at: 2) ifNotNil: [
			file setToEnd; newLine; nextPut: $!!.	"directly"
			header _ String streamContents: [:strm | strm nextPutAll: self name;
				nextPutAll: ' commentStamp: '.
				aStamp storeOn: strm.
				strm nextPutAll: ' prior: '; nextPutAll: ptr printString].
			file nextChunkPut: header]].
	self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.
	Utilities logsUserChanges ifTrue: [
		Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
				stream newLine; nextPut: $!!.	"directly"
				header _ String streamContents: [:strm | strm nextPutAll: self name;
					nextPutAll: ' commentStamp: '.
					aStamp storeOn: strm.
					strm nextPutAll: ' prior: '; nextPutAll: ptr printString].
				stream nextChunkPut: header.
				stream newLine; nextChunkPut: aString.
			].
	].
	SystemChangeNotifier uniqueInstance classCommented: self! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/28/2022 11:41:33' prior: 16814778!
                  printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod overridesMethod: overridenMethod
	"Print a method category preamble.  This must have a category name.
	It may have an author/date stamp, and it may have a prior source link.
	If it has a prior source link, it MUST have a stamp, even if it is empty."

"The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."

	aFileStream newLine; nextPut: $!!.
	aFileStream nextChunkPut: (String streamContents: [ :strm |
		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.
		(changeStamp notNil and: [
			changeStamp notEmpty or: [priorMethod notNil]]) ifTrue: [
			strm nextPutAll: ' stamp: '; print: changeStamp].
		priorMethod notNil ifTrue: [
			strm nextPutAll: ' prior: '; print: priorMethod sourcePointer].
		overridenMethod notNil ifTrue: [
			strm nextPutAll: ' overrides: '; print: overridenMethod sourcePointer]
		]).
! !
!ClassDescription methodsFor: 'fileIn/Out' stamp: 'jmv 4/28/2022 11:41:36' prior: 50342018!
                             printMethodChunk: selector withPreamble: doPreamble on: outStream moveSource: moveSource toFile: fileIndex
	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."
	| preamble method oldPos newPos sourceFile endPos |
	doPreamble 
		ifTrue: [preamble _ self name , ' methodsFor: ' ,
					(self organization categoryOfElement: selector) asPlainString printString]
		ifFalse: [preamble _ ''].
	method _ self methodDict at: selector ifAbsent: [
		outStream nextPutAll: selector; newLine.
		outStream tab; nextPutAll: '** ERROR  -  THIS METHOD IS MISSING ** '; newLine; newLine.
		outStream nextPutAll: '  '.
		^ outStream].

	((method fileIndex = 0
		or: [(SourceFiles at: method fileIndex) == nil])
		or: [(oldPos _ method filePosition) = 0])
	ifTrue: [
		"The source code is not accessible.  We must decompile..."
		preamble size > 0 ifTrue: [ outStream newLine; nextPut: $!!; nextChunkPut: preamble; newLine].
		outStream nextChunkPut: method decompileString]
	ifFalse: [
		sourceFile _ SourceFiles at: method fileIndex.
		preamble size > 0
			ifTrue:    "Copy the preamble"
				[outStream copyPreamble: preamble from: sourceFile at: oldPos]
			ifFalse:
				[sourceFile position: oldPos].
		"Copy the method chunk"
		fileIndex = 0 ifFalse: [
			outStream padTo: SourceFiles pointerScaleForWriting put: $  ].
		newPos _ outStream position.
		outStream copyMethodChunkFrom: sourceFile.
		moveSource ifTrue: [    "Set the new method source pointer"
			endPos _ outStream position.
			method checkOKToAdd: endPos - newPos at: newPos in: method fileIndex.
			method setSourcePosition: newPos inFile: fileIndex]].
	preamble notEmpty ifTrue: [ outStream nextChunkPut: ' ' ].
	^ outStream newLine! !
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 4/28/2022 11:41:28' prior: 16815270!
                           chooseInstVarThenDo: aBlock
	"Put up a menu of all the instance variables in the receiver, and when
the user chooses one, evaluate aBlock with the chosen variable as its
parameter.  If the list is 6 or larger, then offer an alphabetical
formulation as an alternative. triggered by a 'show alphabetically' item
at the top of the list."

	| lines labelStream allVars index count offerAlpha |
	(count _ self allInstVarNames size) = 0 ifTrue: 
		[ ^ self inform: 'There are no\instance variables.' withNewLines ].

	allVars _ OrderedCollection new.
	lines _ OrderedCollection new.
	labelStream _ WriteStream on: (String new: 200).

	(offerAlpha _ count > 5)
		ifTrue: [
			lines add: 1.
			allVars add: 'show alphabetically'.
			labelStream nextPutAll: allVars first; newLine].
	self withAllSuperclasses reverseDo: [ :class | | vars |
		vars _ class instVarNames.
		vars do: [ :var |
			labelStream nextPutAll: var; newLine.
			allVars add: var].
		vars isEmpty ifFalse: [lines add: allVars size]].
	labelStream skip: -1 "cut last CR".
	(lines notEmpty and: [ lines last = allVars size ]) ifTrue: [
		lines removeLast ].  "dispense with inelegant line beneath last item"
	index _ (PopUpMenu labels: labelStream contents lines: lines)
startUpWithCaption: 'Instance variables in
', self name.
	index = 0 ifTrue: [^ self].
	(index = 1 and: [offerAlpha]) ifTrue: [
		^ self chooseInstVarAlphabeticallyThenDo: aBlock].
	aBlock value: (allVars at: index)! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:55:06' prior: 16800639!
  categories
	"Answer an Array of categories (names)."
	categoryArray ifNil: [^ nil].
	(categoryArray size = 1 
		and: [categoryArray first = Default & elementArray isEmpty])
		ifTrue: [^Array with: NullCategory].
	^categoryArray! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:56:23' prior: 16800761!
   classify: element under: heading suppressIfDefault: aBoolean
	"Store the argument, element, in the category named heading.   If aBoolean is true, then invoke special logic such that the classification is NOT done if the new heading is the Default and the element already had a non-Default classification -- useful for filein"

	| catName catIndex elemIndex realHeading |
	
	realHeading _ (heading = NullCategory or: [heading isNil])
		ifTrue: [Default]
		ifFalse: [heading withBlanksTrimmed ].
	
	"done if already under that category"
	(catName _ self categoryOfElement: element) = realHeading ifTrue: [^ self].  

	catName ifNotNil: [
		"return if non-Default category already assigned in memory"
		(aBoolean and: [realHeading = Default]) ifTrue: [^ self].	 
		"remove if in another category"
		self removeElement: element].

	(categoryArray indexOf: realHeading) = 0 ifTrue: [self addCategory: realHeading].

	catIndex _ categoryArray indexOf: realHeading.
	elemIndex _ catIndex > 1
		ifTrue: [categoryStops at: catIndex - 1]
		ifFalse: [0].
	[(elemIndex _ elemIndex + 1) <= (categoryStops at: catIndex) 
		and: [element >= (elementArray at: elemIndex)]] whileTrue.

	"elemIndex is now the index for inserting the element. Do the insertion before it."
	elementArray _ elementArray copyReplaceFrom: elemIndex to: elemIndex-1 with: (Array with: element).

	"add one to stops for this and later categories"
	catIndex to: categoryArray size do: [ :i |
		categoryStops at: i put: (categoryStops at: i) + 1].

	(self listAtCategoryNamed: Default) isEmpty ifTrue: [self removeCategory: Default]! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:57:18' prior: 16800936!
                 removeCategory: cat 
	"Remove the category named, cat. Create an error notificiation if the 
	category has any elements in it."

	| index lastStop |
	index _ categoryArray indexOf: cat ifAbsent: [^self].
	lastStop _ 
		index = 1
			ifTrue: [0]
			ifFalse: [categoryStops at: index - 1].
	(categoryStops at: index) - lastStop > 0 
		ifTrue: [^self error: 'cannot remove non-empty category'].
	categoryArray _ categoryArray copyReplaceFrom: index to: index with: #().
	categoryStops _ categoryStops copyReplaceFrom: index to: index with: #().
	categoryArray isEmpty
		ifTrue: [
			categoryArray _ Array with: Default.
			categoryStops _ Array with: 0]
! !
!Categorizer methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:57:31' prior: 16800989!
                            removeEmptyCategories
	"Remove empty categories."

	| categoryIndex currentStop keptCategories keptStops |
	keptCategories _ WriteStream on: (Array new: 16).
	keptStops _ WriteStream on: (Array new: 16).
	currentStop _ categoryIndex _ 0.
	[(categoryIndex _ categoryIndex + 1) <= categoryArray size]
		whileTrue: 
			[(categoryStops at: categoryIndex) > currentStop
				ifTrue: 
					[keptCategories nextPut: (categoryArray at: categoryIndex).
					keptStops nextPut: (currentStop _ categoryStops at: categoryIndex)]].
	categoryArray _ keptCategories contents.
	categoryStops _ keptStops contents.
	categoryArray isEmpty
		ifTrue: [
			categoryArray _ Array with: Default.
			categoryStops _ Array with: 0]

	"ClassOrganizer allInstancesDo: [:co | co removeEmptyCategories]."! !
!Categorizer methodsFor: 'testing' stamp: 'jmv 4/28/2022 11:54:54' prior: 16801129!
  hasAnyCategoriesSuchThat: aBlock
	"Answer an Array of categories (names)."
	categoryArray ifNil: [^ false].
	(categoryArray size = 1 
		and: [categoryArray first = Default & elementArray isEmpty])
		ifTrue: [^false].
	^categoryArray anySatisfy: aBlock! !
!BasicClassOrganizer methodsFor: 'accessing' stamp: 'jmv 4/27/2022 11:17:01' prior: 16784585!
   classComment: aString 
	"Store the comment, aString, associated with the object that refers to the 
	receiver."

	aString ifNil: [ ^classComment _ nil ].
	
	aString isRemote
		ifTrue: [classComment _ aString]
		ifFalse: [aString isEmpty
			ifTrue: [classComment _ nil]
			ifFalse: [
				self error: 'use aClass classComment:'.
				classComment _ RemoteString newString: aString onFileNumber: 2]]
				"Later add priorSource and date and initials?"! !
!BasicClassOrganizer methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:51:03' prior: 16784602!
classComment: aString  stamp: aStamp
	"Store the comment, aString, associated with the object that refers to the receiver."

	self commentStamp: aStamp.
	aString isRemote
		ifTrue: [classComment _ aString]
		ifFalse: [(aString isNil or: [aString isEmpty])
			ifTrue: [classComment _ nil]
			ifFalse:
				[self error: 'use aClass classComment:'.
				classComment _ RemoteString newString: aString onFileNumber: 2]]
				"Later add priorSource and date and initials?"! !
!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'jmv 4/28/2022 11:50:53' prior: 16958717!
                 fileOutCategory: category on: aFileStream initializing: aBool
	"Store on the file associated with aFileStream, all the classes associated 
	with the category and any requested shared pools."

	| first poolSet tempClass classes |
	classes _ (self superclassOrderIn: category).
	poolSet _ Set new.
	classes do: [ :class |
		class sharedPools do: [:eachPool | poolSet add: eachPool]].
	poolSet notEmpty ifTrue: [
		tempClass _ Class new.
		tempClass shouldFileOutPools ifTrue:
			[poolSet _ poolSet select: [:aPool | tempClass shouldFileOutPool: (Smalltalk keyAtIdentityValue: aPool)].
			poolSet do: [:aPool | tempClass fileOutPool: aPool onFileStream: aFileStream]]].
	first _ true.
	classes do: [ :class | 
		first
			ifTrue: [first _ false]
			ifFalse: [aFileStream newLine; nextPut: Character newPage; newLine].
		class
			fileOutOn: aFileStream
			moveSource: false
			toFile: 0
			initializing: false].
	aBool ifTrue: [classes do:[:cls| cls fileOutInitializerOn: aFileStream]].! !
!MessageTally methodsFor: 'collecting leaves' stamp: 'jmv 4/28/2022 11:57:41' prior: 16887320!
        leavesInto: leafDict fromSender: senderTally

	| rcvrs |
	rcvrs _ self sonsOver: 0.
	rcvrs isEmpty
		ifTrue: [ self into: leafDict fromSender: senderTally ]
		ifFalse: [
			rcvrs do: [ :node |
				node isPrimitives
					ifTrue: [ node leavesInto: leafDict fromSender: senderTally ]
					ifFalse: [ node leavesInto: leafDict fromSender: self ]]]! !
!MessageTally methodsFor: 'comparing' stamp: 'jmv 4/28/2022 11:57:47' prior: 16887361!
             sonsOver: threshold

	| hereTally sons |
	(receivers isNil or: [ receivers isEmpty ]) ifTrue: [ ^#() ].
	hereTally _ tally.
	sons _ receivers select: [ :son | "subtract subNode tallies for primitive hits here"
		hereTally _ hereTally - son tally.
		son tally > threshold ].
	hereTally > threshold
		ifTrue: [
			| last |
			last _ MessageTally new class: class method: method.
			^sons copyWith: (last primitives: hereTally)].
	^sons! !
!SequenceableCollection methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:31:06' prior: 16933587!
          first
	"Answer the first element of the receiver.
	Raise an error if the collection is empty."

	self isEmpty ifTrue: [self errorEmptyCollection].
	^ self at: 1! !
!String methodsFor: 'converting' stamp: 'jmv 4/27/2022 11:17:18' prior: 16948079!
          asIdentifier: shouldBeCapitalized
	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"

	| aString |
	aString _ self select: [ :el | el isValidInIdentifiers ].
	(aString isEmpty or: [aString first isValidStartOfIdentifiers not])
		ifTrue:	 [aString _ 'a', aString].
	^ shouldBeCapitalized ifTrue: [ aString capitalized ] ifFalse: [ aString uncapitalized ]

"
'234Fred987' asIdentifier: false
'235Fred987' asIdentifier: true
'' asIdentifier: true
'()87234' asIdentifier: false
'())z>=PPve889  U >' asIdentifier: false
"! !
!String methodsFor: 'converting' stamp: 'jmv 4/28/2022 11:58:20' prior: 16948492!
 initialIntegerOrNil
	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"
	| firstNonDigit |
	(self isEmpty or: [self first isDigit not]) ifTrue: [^ nil].
	firstNonDigit _ (self findFirst: [:m | m isDigit not]).
	firstNonDigit = 0 ifTrue: [firstNonDigit _ self size + 1].
	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber
"
'234Whoopie' initialIntegerOrNil
'wimpy' initialIntegerOrNil
'234' initialIntegerOrNil
'2N' initialIntegerOrNil
'2' initialIntegerOrNil
'  89Ten ' initialIntegerOrNil
'78 92' initialIntegerOrNil
"
! !
!String methodsFor: 'system primitives' stamp: 'jmv 4/28/2022 11:58:24' prior: 16949086!
              findSubstring: key in: body startingAt: start matchTable: matchTable
	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.

	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."
	| index |
	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>
	self var: #key declareC: 'unsigned char *key'.
	self var: #body declareC: 'unsigned char *body'.
	self var: #matchTable declareC: 'unsigned char *matchTable'.

	key isEmpty ifTrue: [^ 0].
	start to: body size - key size + 1 do:
		[:startIndex |
		index _ 1.
			[(matchTable at: (body at: startIndex+index-1) numericValue + 1)
				= (matchTable at: (key at: index) numericValue + 1)]
				whileTrue:
				[index = key size ifTrue: [^ startIndex].
				index _ index+1]].
	^ 0
"
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7
' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0
' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0
' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7
"! !
!String methodsFor: 'system primitives' stamp: 'jmv 4/28/2022 11:58:30' prior: 16949134!
   numArgs
	"Answer either the number of arguments that the receiver would take if considered a selector. 
	Answer -1 if it couldn't be a selector. 
		Note that currently this will answer -1 for anything begining with an uppercase letter even though 
		the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."
	| firstChar numColons start ix |
	self isEmpty ifTrue: [ ^ -1 ].
	"Binary messages"
	(self allSatisfy: [ :c | c isValidInBinarySelectors ])
		ifTrue: [ ^1 ].
	"Unary and keyword messages"
	firstChar _ self at: 1.
	firstChar isValidStartOfIdentifiers ifTrue: [
		"Fast reject if any chars are non-alphanumeric"
		(self
			findSubstring: '~'
			in: self
			startingAt: 1
			matchTable: Tokenish) > 0 ifTrue: [ ^ -1 ].
		"Fast colon count"
		numColons _ 0.
		start _ 1.
		[
		(ix _ self
			findSubstring: ':'
			in: self
			startingAt: start
			matchTable: CaseSensitiveOrder) > 0 ] whileTrue: [
			numColons _ numColons + 1.
			start _ ix + 1 ].
		^ numColons ].
	^ -1.! !
!Symbol methodsFor: 'accessing' stamp: 'jmv 4/28/2022 11:58:35' prior: 16950692!
precedence
	"Answer the receiver's precedence, assuming it is a valid Smalltalk
	message selector or 0 otherwise.  The numbers are 1 for unary,
	2 for binary and 3 for keyword selectors."

	| c |
	self isEmpty ifTrue: [^ 0].
	"Consider selectors starting with an underscore $_ as unary, even if Preferences allowUnderscoreSelectors is not set."
	c _ self first.
	c isValidInBinarySelectors ifTrue: [^ 2].
	self last = $: ifTrue: [^ 3].
	^ 1! !
!RunArray methodsFor: 'copying' stamp: 'jmv 4/28/2022 11:32:23' prior: 16928416 overrides: 16934134!
                               , aRunArray 
	"Answer a new RunArray that is a concatenation of the receiver and
	aRunArray."

	| new newRuns answer |
	(aRunArray isMemberOf: RunArray)
		ifFalse: [
			new _ self copy.
			"attempt to be sociable"
			aRunArray do: [:each | new addLast: each].
			^new].
	self isEmpty ifTrue: [^aRunArray copy].
	aRunArray isEmpty ifTrue: [^self copy].
	(self canJoin: (values at: values size) and: (aRunArray values at: 1))
		ifFalse: [ 
			answer _ RunArray
				runs: runs , aRunArray runs
				values: values , aRunArray values.
			answer canJoinMessage: canJoinMessage.
			^answer ].
	newRuns _ runs
					copyReplaceFrom: runs size
					to: runs size
					with: aRunArray runs.
	newRuns at: runs size put: (runs at: runs size) + (aRunArray runs at: 1).
	answer _ RunArray
		runs: newRuns
		values: 
			(values
				copyReplaceFrom: values size
				to: values size
				with: aRunArray values).
	answer canJoinMessage: canJoinMessage.
	^answer! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/27/2022 11:15:58' prior: 16963558!
                               rangeOf: attribute startingAt: index
	"Answer an interval that gives the range of attribute at index position  index. An empty interval with start value index is returned when the attribute is not present at position index."
	^ self isEmpty
		ifTrue: [ index to: index - 1 ]
		ifFalse: [
			runs
				rangeOf: attribute
				startingAt: index ].! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/27/2022 11:14:34' prior: 16963588 overrides: 16822799!
  size
	^runs size! !
!Text methodsFor: 'emphasis' stamp: 'jmv 4/27/2022 11:15:29' prior: 16963817!
                              addAttribute: att 
	self isEmpty ifTrue: [ ^self ].
	^ self addAttribute: att from: 1 to: self size! !
!Text methodsFor: 'emphasis' stamp: 'jmv 4/27/2022 10:36:29' prior: 16963844!
           attributesAt: characterIndex
	"Answer the code for characters in the run beginning at characterIndex."

	self isEmpty
		ifTrue: [^ #()].  "null text tolerates access"
	^runs at: characterIndex! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/28/2022 11:34:00' prior: 16954570!
 removeAllUnSentMessages
	"Smalltalk removeAllUnSentMessages"
	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]. 
	Smalltalk removeAllUnSentMessages > 0] whileTrue."
	"Remove all implementations of unsent messages."
	| sels n |
	sels _ self allUnSentMessages.
	self presumedSentMessages
		do: [:sel | sels
				remove: sel
				ifAbsent: nil].
	sels isEmpty
		ifTrue: [^ 0].
	n _ 0.
	Smalltalk
		allBehaviorsDo: [:x | n _ n + 1].
	'Removing ' , sels size printString , ' messages . . .'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: n
		during: [:barBlock | 
			n _ 0.
			self
				allBehaviorsDo: [:class | 
					barBlock value: (n _ n + 1).
					sels
						do: [:sel | class removeSelector: sel]]].
	^ sels size! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 4/28/2022 11:43:21' prior: 16956553!
                             browseClassesWithNamesContaining: aString caseSensitive: caseSensitive 
	"Smalltalk browseClassesWithNamesContaining: 'eMorph' caseSensitive: true "
	"Launch a class-list list browser on all classes whose names containg aString as a substring."

	| suffix aList |
	suffix _ caseSensitive
				ifTrue: [' (case-sensitive)']
				ifFalse: [' (use shift for case-sensitive)'].
	aList _ OrderedCollection new.
	Smalltalk allClassesDo: [ :class |
		(class name includesSubstring: aString caseSensitive: caseSensitive)
			ifTrue: [aList add: class name]].
	aList notEmpty
		ifTrue: [HierarchyBrowserWindow forClassesNamed: aList asSet sorted title: 'Classes whose names contain ' , aString , suffix]! !
!SmartRefStream methodsFor: 'class changed shape' stamp: 'jmv 4/28/2022 11:59:14' prior: 16942120!
      writeClassRenameMethod: sel was: oldName fromInstVars: oldList 
	"The class coming is unknown.  Ask the user for the existing class it maps to.  If got one, write a method, and restart the obj fileIn.  If none, write a dummy method and get the user to complete it later.  "

	| tell choice newName answ code oldVer newList newVer instSel |
	self flag: #bobconv.
	tell := 'Reading an instance of ' , oldName 
				, '.
Which modern class should it translate to?'.
	answ := (PopUpMenu 
				labels: 'Let me type the name now
Let me think about it
Let me find a conversion file on the disk') 
					startUpWithCaption: tell.
	answ = 1 
		ifTrue: [
			tell := 'Name of the modern class {1} should translate to:' format: {oldName}.
			choice := self request: tell initialAnswer: ''.	"class name"
			choice isEmpty 
				ifTrue: [answ := 'conversion method needed']
				ifFalse: [
					newName := choice.
					answ := Smalltalk at: newName asSymbol
								ifAbsent: ['conversion method needed'].
					answ class == String 
						ifFalse: [renamed at: oldName asSymbol put: answ name]]].
	answ = 3 | (answ = 0) 
		ifTrue: [
			byteStream close.
			^'conversion method needed'].
	answ = 2 ifTrue: [answ := 'conversion method needed'].
	answ = 'conversion method needed' 
		ifTrue: [
			byteStream close.
			newName := 'PutNewClassHere'].
	answ class == String 
		ifFalse: 
			[oldVer := self versionSymbol: (structures at: oldName).
			newList := (Array with: answ classVersion) , answ allInstVarNames.
			newVer := self versionSymbol: newList.
			instSel := 'convert' , oldVer , ':' , newVer , ':'].
	code := WriteStream on: (String new: 500).
	code
		nextPutAll: sel;
		newLine.
	answ class == String 
		ifFalse: [
			code
				newLine;
				tab;
				nextPutAll: 'reshaped at: #' , oldName , ' put: #' , instSel , '.'.
			code
				newLine;
				tab;
				tab;
				nextPutAll: '"Be sure to define that conversion method in class ' 
							, answ name , '"'].
	code
		newLine;
		tab;
		nextPutAll: '^ ' , newName.	"Return new class"
	self class compile: code contents classified: 'conversion'.
	newName = 'PutNewClassHere' 
		ifTrue: [
			self 
				inform: 'Please complete the following method and 
then read-in the object file again.'.
			Smalltalk browseAllImplementorsOf: sel asSymbol].
	self flag: #violateBasicLayerPrinciples.
	"SmartRefStream should not refer to UI!!!!!!!!!! (sd)"

	"The class version number only needs to change under one specific circumstance.  That is when the first letters of the instance variables have stayed the same, but their meaning has changed.  A conversion method is needed, but this system does not know it.  
	If this is true for class Foo, define classVersion in Foo class.  
	Beware of previous object fileouts already written after the change in meaning, but before bumping the version number.  They have the old (wrong) version number, say 2.  If this is true, your method must be able to test the data and successfully read files that say version 2 but are really 3."
	^answ! !
!SmartRefStream methodsFor: 'class changed shape' stamp: 'jmv 4/28/2022 12:00:17' prior: 16942217!
                            writeConversionMethod: sel class: newClass was: oldName fromInstVars: oldList to: newList
	"The method convertToCurrentVersion:refStream: was not found in newClass.  Write a default conversion method for the author to modify."

	| code newOthers oldOthers copied |

	code _ WriteStream on: (String new: 500).
	code nextPutAll: 'convertToCurrentVersion: varDict refStream: smartRefStrm'; newLine; tab.
	newOthers _ newList asOrderedCollection "copy".
	oldOthers _ oldList asOrderedCollection "copy".
	copied _ OrderedCollection new.
	newList do: [:instVar |
		(oldList includes: instVar) ifTrue: [
			instVar isInteger ifFalse: [copied add: instVar].
			newOthers remove: instVar.
			oldOthers remove: instVar]].
	code nextPutAll: '"These variables are automatically stored into the new instance '.
	code nextPutAll: copied asArray printString; nextPut: $. .
	code newLine; tab; nextPutAll: 'This method is for additional changes.'; 
		nextPutAll: ' Use statements like (foo _ varDict at: ''foo'')."'; newLine; newLine; tab.
	newOthers isEmpty & oldOthers isEmpty ifTrue: [^ self].
		"Instance variables are the same.  Only the order changed.  No conversion needed."
	newOthers notEmpty ifTrue: [
		code nextPutAll: '"New variables: ', newOthers asArray printString, '  If a non-nil value is needed, please assign it."\' withNewLines].
	oldOthers notEmpty ifTrue: [
		code nextPutAll: '	"These are going away ', oldOthers asArray printString, '.  Possibly store their info in some other variable?"'].

	code newLine; tab.
	code nextPutAll: '^ super convertToCurrentVersion: varDict refStream: smartRefStrm'.
	newClass compile: code contents classified: 'object fileIn'.


	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)
	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe."! !
!SmartRefStream methodsFor: 'class changed shape' stamp: 'jmv 4/28/2022 12:01:29' prior: 16942294!
                writeConversionMethodIn: newClass fromInstVars: oldList to: newList renamedFrom: oldName
	"The method convertToCurrentVersion:refStream: was not found in newClass.  Write a default conversion method for the author to modify.  If method exists, append new info into the end."

	| code newOthers oldOthers copied newCode |

	newOthers _ newList asOrderedCollection "copy".
	oldOthers _ oldList asOrderedCollection "copy".
	copied _ OrderedCollection new.
	newList do: [:instVar |
		(oldList includes: instVar) ifTrue: [
			instVar isInteger ifFalse: [copied add: instVar].
			newOthers remove: instVar.
			oldOthers remove: instVar]].
	code _ WriteStream on: (String new: 500).
	code newLine; newLine; tab; nextPutAll: '"From ', SystemVersion current version, ' [', Smalltalk lastUpdateString;
			nextPutAll: '] on ', Date today printString, '"'; newLine.
	code tab; nextPutAll: '"These variables are automatically stored into the new instance: '.
	code nextPutAll: copied asArray printString; nextPut: $.; newLine.
	code tab; nextPutAll: 'Test for this particular conversion.'; 
		nextPutAll: '  Get values using expressions like (varDict at: ''foo'')."'; newLine; newLine.
	newOthers isEmpty & oldOthers isEmpty & oldName isNil ifTrue: [^ self].
		"Instance variables are the same.  Only the order changed.  No conversion needed."
	newOthers notEmpty ifTrue: [
		code tab; nextPutAll: '"New variables: ', newOthers asArray printString, 
			'.  If a non-nil value is needed, please assign it."'; newLine].
	oldOthers notEmpty ifTrue: [
		code tab; nextPutAll: '"These are going away ', oldOthers asArray printString, 
			'.  Possibly store their info in some other variable?"'; newLine].
	oldName ifNotNil: [
		code tab; nextPutAll: '"Test for instances of class ', oldName, '.'; newLine.
		code tab; nextPutAll: 'Instance vars with the same name have been moved here."'; newLine.
		].
	code tab; nextPutAll: '"Move your code above the ^ super...  Delete extra comments."'; newLine. 

	(newClass includesSelector: #convertToCurrentVersion:refStream:) 
		ifTrue: ["append to old methods"
			newCode _ (newClass sourceCodeAt: #convertToCurrentVersion:refStream:),
				code contents]
		ifFalse: ["new method"
			newCode _ 'convertToCurrentVersion: varDict refStream: smartRefStrm',
				code contents, 
				'	^ super convertToCurrentVersion: varDict refStream: smartRefStrm'].
	newClass compile: newCode classified: 'object fileIn'.


	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)
	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe."! !
!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 4/27/2022 11:16:07' prior: 16967238!
                       setSearchString: aKeyboardEvent
	"Establish the current selection as the current search string."

	| aString |
	self lineSelectAndEmptyCheck: [^ true].
	aString _  self selectedString.
	aString isEmpty
		ifTrue: [ self flash ]
		ifFalse: [ self setSearch: aString ].
	^ true! !
!SmalltalkEditor methodsFor: 'explain' stamp: 'jmv 4/28/2022 12:02:31' prior: 16939767!
                  explainAnySel: symbol 
	"Is this any message selector?"

	| list reply |
	list _ Smalltalk allClassesImplementing: symbol.
	list isEmpty ifTrue: [^nil].
	list size < 12
		ifTrue: [reply _ ' is a message selector which is defined in these classes ' , list printString]
		ifFalse: [reply _ ' is a message selector which is defined in many classes'].
	^'#' , symbol , reply , '.\' withNewLines, 'Smalltalk browseAllImplementorsOf: #' , symbol! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 4/28/2022 12:02:24' prior: 16940388!
       explain
	"Try to shed some light on what kind of entity the current selection is. 
	The selection must be a single token or construct. Insert the answer after 
	the selection. Send private messages whose names begin with 'explain' 
	that return a string if they recognize the selection, else nil."

	| string tiVars cgVars selectors delimitors numbers sorry reply symbol provider |
	sorry _ 'Sorry, I can''t explain that.  Please select a single
token, construct, or special character.'.
	(string _ self selectedString) isEmpty
		ifTrue: [reply _ '']
		ifFalse: [
			string _ string withBlanksTrimmed.
			"Remove space, tab, cr"
			"Temps and Instance vars need only test strings that are all letters"
			(string detect: [:char | char isValidInIdentifiers not]
				ifNone: nil) ifNil: [
					tiVars _ (self explainTemp: string)
						ifNil: [self explainInst: string]].
					
			provider _ self codeProvider.
			(tiVars == nil and: [provider respondsTo: #explainSpecial:])
				ifTrue: [tiVars _ provider explainSpecial: string].
			tiVars _ tiVars
				ifNil: [ '']
				ifNotNil: [ tiVars , '\' withNewLines].
			"Context, Class, Pool, and Global vars, and Selectors need 
			only test symbols"
			(Symbol hasInterned: string ifTrue: [:s | symbol _ s])
				ifTrue: [
					cgVars _ (self explainCtxt: symbol) 
						ifNil: [ (self explainClass: symbol)
							ifNil: [ self explainGlobal: symbol]].
					"See if it is a Selector (sent here or not)"
					selectors _ (self explainMySel: symbol)
						ifNil: [(self explainPartSel: string)
							ifNil: [ self explainAnySel: symbol]]]
				ifFalse: [selectors _ self explainPartSel: string].
			cgVars _ cgVars
				ifNil: [ '']
				ifNotNil: [cgVars , '\' withNewLines].
			selectors _ selectors
				ifNil: [ '']
				ifNotNil: [ selectors , '\' withNewLines].
			delimitors _ string size = 1
				ifTrue: ["single special characters"
					self explainChar: string]
				ifFalse: ["matched delimitors"
					self explainDelimitor: string].
			numbers _ self explainNumber: string.
			numbers ifNil: [numbers _ ''].
			delimitors ifNil: [delimitors _ ''].
			reply _ tiVars , cgVars , selectors , delimitors , numbers].
	reply isEmpty ifTrue: [reply _ sorry].

	morph showBalloon: reply.
	self runningWorld ifNotNil: [ :w | w findATranscript ].
	reply print! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'jmv 4/27/2022 11:16:19' prior: 16940586!
    selectedSymbol
	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"

	| aString |
	self hasSelection ifFalse: [^ nil].
	aString _ self selectedString withoutSeparators.
	aString isEmpty ifTrue: [^ nil].
	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].

	^ nil! !
!AbstractFont methodsFor: 'measuring' stamp: 'jmv 4/28/2022 11:37:16' prior: 16777264!
                   approxWidthOfText: aText
	"Return the width of aText -- quickly, and a little bit dirty.
	Used by lists morphs containing Text objects to get a quick,
	fairly accurate measure of the width of a list item."
	| w |
	(aText isNil or: [ aText isEmpty ]) ifTrue: [ ^ 0 ].
	w _ self
		widthOfString: aText string
		from: 1
		to: aText size.
	"If the text has no emphasis, just return the string size.  If it is empasized, 
	just approximate the width by adding about 20% to the width"
	^ ((aText runLengthFor: 1) = aText size and: [ (aText emphasisAt: 1) = 0 ])
		ifTrue: [ w ]
		ifFalse: [ w * 6 // 5 ]! !
!Morph methodsFor: 'copying' stamp: 'jmv 4/27/2022 12:36:40' prior: 16891826 overrides: 50344903!
     copyForClipboard
	"The answer is used both for internal (Smalltalk) and external (Host OS) clipboard.
	Some subclasses might need specific behavior."

	self okayToDuplicate ifFalse: [ ^ nil ].
	^self copy! !
!Morph methodsFor: 'structure' stamp: 'jmv 4/28/2022 11:37:24' prior: 16894727!
veryLastLeaf
	"Answer the last submorph, recursively, i.e. the very last leaf of the morph tree"

	^submorphs isEmpty
		ifTrue: [ self ]
		ifFalse: [ submorphs last veryLastLeaf ]! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 4/28/2022 11:37:39' prior: 16869919 overrides: 16794207!
                              drawOn: aCanvas

	listItems isEmpty ifTrue: [ ^self ].
 
	self drawHighlightOn: aCanvas.
	self drawSelectionOn: aCanvas.

	(self topVisibleRowForCanvas: aCanvas)
		to: (self bottomVisibleRowForCanvas: aCanvas)
		do: [ :row |
			(owner itemSelectedAmongMultiple:  row) ifTrue: [
				self drawBackgroundForMulti: row on: aCanvas. ].
			self draw: (self item: row) displayStringOrText atRow: row on: aCanvas ]! !
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 4/28/2022 11:38:45' prior: 16822366!
             showUnreferencedClassVars
	"Search for all class variables known to the selected class, and put up a 
	list of those that have no references anywhere in the system. The 
	search includes superclasses, so that you don't need to navigate your 
	way to the class that defines each class variable in order to determine 
	whether it is unreferenced"
	| cls aList |
	(cls _ model selectedClass)
		ifNil: [^ self].
	aList _ cls allUnreferencedClassVariables.
	aList isEmpty
		ifTrue: [^ self inform: 'There are no unreferenced
class variables in
' , cls name].
	Transcript newLine; nextPutAll: 'Unreferenced class variable(s) in ', cls name; newLine.
	aList do: [:el | Transcript tab; nextPutAll: el; newLine].
	(SelectionMenu labels: aList selections: aList)
		startUpWithCaption: 'Unreferenced
class variables in 
' , cls name! !
!CodeWindow methodsFor: 'menu commands' stamp: 'jmv 4/28/2022 11:38:41' prior: 16822395!
              showUnreferencedInstVars
	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"

	| cls aList |
	(cls _ model selectedClassOrMetaClass) ifNil: [^ self].
	aList _ cls allUnreferencedInstanceVariables.
	aList isEmpty ifTrue: [^ self inform: 'There are no unreferenced
instance variables in
', cls name].
	Transcript newLine; nextPutAll: 'Unreferenced instance variable(s) in ', cls name; newLine.
	aList do: [ :el | Transcript tab; nextPutAll: el; newLine ].
	(SelectionMenu labels: aList selections: aList) startUpWithCaption: 'Unreferenced
instance variables in 
', cls name! !
!CodeWindow methodsFor: 'misc' stamp: 'jmv 4/28/2022 11:38:49' prior: 16822517!
           selectMessageAndEvaluate: aBlock
	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"

	| selector method messages |
	(selector _ model selectedMessageName) ifNil: [^ self].
	method _ (model selectedClassOrMetaClass ifNil: [^ self])
		compiledMethodAt: selector
		ifAbsent: nil.
	(method isNil or: [(messages _ method messages) isEmpty])
		 ifTrue: [^ aBlock value: selector].
	(messages size = 1 and: [messages includes: selector])
		ifTrue:
			[^ aBlock value: selector].  "If only one item, there is no choice"

	Smalltalk
		showMenuOf: messages
		withFirstItem: selector
		ifChosenDo: aBlock! !
!ChangeListWindow methodsFor: 'menu commands' stamp: 'jmv 4/28/2022 11:38:37' prior: 16802819!
               browseCurrentVersionsOfSelections
	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"
	| aList |

	aList _ model currentVersionsOfSelections.

	aList isEmpty ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].
	MessageSetWindow
		openMessageListUnsorted: aList 
		label: 'Current versions of selected methods in ', model file localName! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 4/28/2022 11:45:06' prior: 16805858!
        fileOut
	"File out the receiver, to a file whose name is a function of the  
	change-set name and either of the date & time or chosen to have a  
	unique numeric tag, depending on the preference  
	'changeSetVersionNumbers'"
	| slips nameToUse |
	nameToUse _ self name.
	nameToUse _ nameToUse copyReplaceAll: 'AuthorName' with: Utilities authorName asUnaccented asCamelCase.
	nameToUse _ Preferences changeSetVersionNumbers
				ifTrue: [
					DirectoryEntry currentDirectory
						nextNameFor: nameToUse coda: '-', Utilities authorInitials
						extension: 'cs.st' ]
				ifFalse: [ (nameToUse , '.' , Utilities dateTimeSuffix , '.cs.st') asFileName ].
		
	nameToUse asFileEntry writeStreamDo: [ :stream |
		stream timeStamp.
		self fileOutPreambleOn: stream.
		self fileOutOn: stream.
		self fileOutPostscriptOn: stream ].
	
	self hasUnsavedChanges: false.
	Preferences checkForSlips
		ifFalse: [^ self].
	slips _ self checkForSlips.
	(slips notEmpty
			and: [(PopUpMenu withCaption: 'Methods in this fileOut have halts
or references to the Transcript
or other ''slips'' in them.
Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')
					= 2])
		ifTrue: [ Smalltalk browseMessageList: slips name: 'Possible slips in ' , name ]! !
!TestResult methodsFor: 'testing' stamp: 'jmv 4/28/2022 11:45:14' prior: 16962189!
                 hasErrors

	^self errors notEmpty
			! !
!TestResult methodsFor: 'testing' stamp: 'jmv 4/28/2022 11:45:19' prior: 16962192!
    hasFailures

	^self failures notEmpty
			! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5121-isEmpty-notEmpty-JuanVuletich-2022Apr28-11h46m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5117] on 28 April 2022 at 1:02:03 pm'!
!Editor methodsFor: 'new selection' stamp: 'jmv 4/28/2022 13:00:57' prior: 16845824!
                       wordRangeLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters startingAt: pointIndex
	"Select delimited text or word--the result of double-clicking."

	| initialDelimiter finalDelimiter direction match level string here hereChar start stop sSize |
	string _ self privateCurrentString.
	sSize _ string size.
	sSize < 2 ifTrue: [^1 to: 1].
	here _ pointIndex min: sSize max: 2.
	initialDelimiter _ string at: here - 1.
	match _ leftDelimiters indexOf: initialDelimiter.
	match > 0
		ifTrue: [
			"delimiter is on left -- match to the right"
			start _ here.
			direction _ 1.
			here _ here - 1.
			finalDelimiter _ rightDelimiters at: match]
		ifFalse: [
			initialDelimiter _ string at: here.
			match _ rightDelimiters indexOf: initialDelimiter.
			match > 0
				ifTrue: [
					"delimiter is on right -- match to the left"
					stop _ here - 1.
					direction _ -1.
					finalDelimiter _ leftDelimiters at: match]
				ifFalse: [
					"no delimiters -- select a token"
					direction _ -1]].
	level _ 1.
	[level > 0 and: [direction > 0
			ifTrue: [here < sSize]
			ifFalse: [here > 1]]]
		whileTrue: [
			hereChar _ string at: (here _ here + direction).
			match = 0
				ifTrue: [
					"token scan goes left, then right"
					hereChar isValidInIdentifiers 	"Consider $: as a word separator"
						ifTrue: [
							here = 1
								ifTrue: [
									start _ 1.
									"go right if hit string start"
									direction _ 1]]
						ifFalse: [
							direction < 0
								ifTrue: [
									start _ here + 1.
									"go right if hit non-token"
									direction _ 1]
								ifFalse: [level _ 0]]]
				ifFalse: [
					"delimiter match just counts nesting level"
					hereChar = finalDelimiter
						ifTrue: [level _ level - 1"leaving nest"]
						ifFalse: [
							hereChar = initialDelimiter 
								ifTrue: [level _ level + 1"entering deeper nest"]]]].
	level > 0 ifTrue: [
		leftDelimiters size + rightDelimiters size = 0 ifFalse: [
			"If we failed to find final delimiter, then just select word."
			^self wordRangeLeftDelimiters: '' rightDelimiters: '' ].
		here _ here + direction ].
	^ direction > 0
		ifTrue: [
			"If a word ends with $: (a keyword), consider it part of the word"
			hereChar = $: ifTrue: [here _ here + 1].
			start to: here - 1]
		ifFalse: [
			"But if a word starts with $: (this is the argument to a keyword), then it is not part of the word."
			here + 1 to: stop]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5122-Tweak-JuanVuletich-2022Apr28-12h58m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5118] on 29 April 2022 at 10:44:57 am'!
!String methodsFor: 'converting' stamp: 'jmv 4/29/2022 09:52:23'!
                   fixLineEndings
	"Assume that CR, LF, and CRLF are all valid line endings. Replace each occurence with a single Lf.
	If possible, modify and answer the same instance. Create a new instance only if needed.
	Be quick and don't use extra memory if already using Character lf!!
	('Hello ', String crlfString, 'World') fixLineEndings
	('Hello ', String crString, 'World') fixLineEndings
	('Hello ', String lfString, 'World') fixLineEndings
	"
	(self includes: `Character cr`) ifFalse: [ ^self ].
	(self includesSubString: `String crlfString`) ifTrue: [ "A new instance is needed"
		^ self withLineEndings: `String newLineString` ].
	self replaceAll: `Character cr` with: `Character lf`.! !
!Text methodsFor: 'converting' stamp: 'jmv 4/29/2022 10:01:15'!
                    fixLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>.
	If possible, modify and answer the same instance. Create a new instance only if needed.
	Be quick and don't use extra memory if already using Character lf!!
	('Hello ', String crlfString, 'World') asText fixLineEndings
	('Hello ', String crString, 'World') asText fixLineEndings
	('Hello ', String lfString, 'World') asText fixLineEndings
	"

	| newText |
	(string includes: `Character cr`) ifFalse: [ ^self ].
	newText _ self.
	(string includesSubString: `String crlfString`) ifTrue: [ "A new instance is needed"
		newText _ self copyReplaceAll: `String crlfString` with: `String newLineString` asTokens: false ].
	newText string replaceAll: `Character cr` with: `Character lf`.
	^newText! !
!String methodsFor: 'converting' stamp: 'jmv 4/29/2022 10:07:10' prior: 16948729!
         withCuisLineEndings
	"Assume that CR, LF, and CRLF are all valid line endings.
	Answer a new instance, replacing each occurence with a single Lf.
	('aLine', String crlfString, 'anotherOne') withCuisLineEndings
	"

	^ self withLineEndings: `String newLineString`.! !
!Text methodsFor: 'converting' stamp: 'jmv 4/29/2022 10:07:03' prior: 50342278!
      withCuisLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>"

	| newText wrongLineEnd |
	wrongLineEnd _ `String crlfString detect: [ :char | (char = Character newLineCharacter) not ]`.
	(string includes: wrongLineEnd) ifFalse: [ ^self copy ].
	newText _ self copyReplaceAll: `String crlfString` with: `String newLineString` asTokens: false.
	newText string replaceAll: wrongLineEnd with: `Character newLineCharacter`.
	^newText! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5123-CuisLineEndings-tweaks-JuanVuletich-2022Apr29-10h42m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5121] on 29 April 2022 at 2:36:20 pm'!
!String methodsFor: 'accessing' stamp: 'jmv 4/26/2022 15:36:45' overrides: 16781630!
                        byteSize
	^self size! !
!String methodsFor: 'accessing' stamp: 'jmv 4/28/2022 15:10:55'!
       isLastLineSeparator
	^self last isLineSeparator! !
!String methodsFor: 'accessing' stamp: 'jmv 4/28/2022 15:51:10'!
            isLastSeparator
	^self last isSeparator! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/28/2022 15:10:09'!
                      isLastLineSeparator
	^string isLastLineSeparator! !
!Text methodsFor: 'accessing' stamp: 'jmv 4/28/2022 15:51:16'!
             isLastSeparator
	^string isLastSeparator! !
!TextComposer methodsFor: 'as yet unclassified' stamp: 'jmv 4/28/2022 17:14:48' prior: 16965367!
                   composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY text: argText extentForComposing: argExtentForComposing

	lines _ argLinesCollection.
	theText _ argText.
	extentForComposing _ argExtentForComposing.
	deltaCharIndex _ argDelta.
	currCharIndex _ startCharIndex _ argStart.
	stopCharIndex _ argStop.
	prevLines _ argPriorLines.
	currentY _ argStartY.
	maxRightX _ 0.
	possibleSlide _ stopCharIndex < theText size.
	nowSliding _ false.
	prevIndex _ 1.
	scanner _ CompositionScanner new text: theText.
	scanner defaultFont: self defaultFont.
	isFirstLine _ currCharIndex = 1 or: [
		 (theText at: currCharIndex-1) isLineSeparator ].
	anythingComposed _ false.
	self composeAllLines.
	(anythingComposed not or: [ theText isLastLineSeparator ])
		ifTrue: [
			self addEmptyTrailingLine: true ]
		ifFalse: [
			scanner lastLineBreakingSpace = theText size ifTrue: [
				self addEmptyTrailingLine: false ]].
	^ {lines asArray. maxRightX}

! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5124-String-Text-Tweaks-JuanVuletich-2022Apr29-14h34m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5120] on 29 April 2022 at 12:15:53 pm'!
!BitBlt methodsFor: 'private' stamp: 'jmv 4/26/2022 10:21:11'!
        primFaiDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta

	| ascii glyph |
	startIndex to: stopIndex do: [ :charIndex |
		ascii _ (aString at: charIndex) numericValue.
		glyph _ glyphMap at: ascii + 1.
		sourceX _ xTable at: glyph + 1.
		width _ (xTable at: glyph + 2) - sourceX.
		self copyBits.
		destX _ destX + width + kernDelta.
	].! !
!BitBlt methodsFor: 'private' stamp: 'jmv 4/26/2022 10:20:59' prior: 16788357!
           primDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta

	<primitive:'primitiveDisplayString' module:'BitBltPlugin'>
	self primFaiDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5125-BitBlt-tweak-JuanVuletich-2022Apr29-12h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5121] on 29 April 2022 at 5:08:17 pm'!
!Object methodsFor: 'testing' stamp: 'jmv 4/29/2022 11:22:00'!
       isStringLike
	"Overridden to return true in String, and StringUtf8."
	^ false! !
!String methodsFor: 'testing' stamp: 'jmv 4/29/2022 11:22:03' overrides: 50347215!
                            isStringLike
	^ true! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 11:25:37'!
    retrieveObject: stringClass
	"Answer whatever was last stored in the clipboard"
	| stringOrNil |

	"If the OS clipboard has the id for our contents, or the same characters, then answer the richer Smalltalk object.
	Note: if the (extended) clipboard contains a serialized object, it shouldn't contain an id, so
	it is deserialized even if ivar contents contains the object. This is done to guarantee consistency with pasting
	from another Cuis image."
	stringOrNil _ self retrieveIdOrStringFromOS: stringClass.
	(stringOrNil = (self idFor: contents) or: [ stringOrNil = contents or: [(contents is: #Text) and: [stringOrNil = contents string]]])
		ifTrue: [
			"We copy the object, because the result of each paste operation could be modified independently of the others afterwards
			(and the same clipboard contents might be pasted many times)"
			^contents copyForClipboard ].

	"If we have the ExtendedClipboardInterface, try to get an RTF or Form"
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface retrieveObject ifNotNil: [ :object | ^object ]].

	"Otherwise answer the string brought by clipboard primitives,
	but if they are not present or fail, use the internal clipboard."
	^stringOrNil ifNil: [ contents copyForClipboard ]! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 11:35:19'!
                     retrieveStringOrText: stringClass
	"Answer a Text or a String. Appropriate for a Text Editor."
	| answer |
	
	answer _ self retrieveObject: stringClass.
	
	"If clipboard contents is already a Text or String, answer it."
	(answer isStringLike or: [ answer is: #Text ]) ifTrue: [
		^answer ].
	
	"If clipboard contains a Morph, answer a TextAnchor incuding it..."
	(answer is: #Morph) ifTrue: [
		^ (Text string: (stringClass with: $*) attribute: (TextAnchor new anchoredFormOrMorph: answer)) ].
	
	"If clipboard contains a Form, prepare a Text including it."
	(answer is: #Form) ifTrue: [
		^Text withForm: answer ].
	
	"Answer some string..."
	^answer ifNil: [ stringClass new ] ifNotNil: [ answer printString ]! !
!Clipboard methodsFor: 'private' stamp: 'jmv 4/29/2022 11:20:20'!
                   retrieveIdOrStringFromOS: stringClass
	"Use a specific content type if ExtendedClipboard is active.
	Otherwise, use regular clipboard primitives"
	| utf8Bytes classForUtf8Bytes |
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			"Answer nil if no id was stored"
			^ interface retrieveId ]].

	utf8Bytes _ self primitiveClipboardString.

	"Clipboard primitives answer an empty string if there is no string in OS clipboard."
	utf8Bytes isEmpty ifTrue: [ ^nil ].

	"Clipboard primitive answers an instance of String containing the UTF-8 bytes.
	If not pure ASCII, contents are invalid!! Convert it ASAP into a reasonable ByteArray or StringUtf8."
	classForUtf8Bytes _ stringClass == String ifTrue: [ ByteArray ] ifFalse: [ stringClass ].
	utf8Bytes class format = classForUtf8Bytes format  												"True unless image is in 32bit V3 format"
		ifTrue: [ classForUtf8Bytes adoptInstance: utf8Bytes ]
		ifFalse: [ utf8Bytes _ classForUtf8Bytes withAll: utf8Bytes ].
	^ (stringClass fromUtf8: utf8Bytes) fixLineEndings.! !
!Clipboard class methodsFor: 'default clipboard' stamp: 'jmv 4/29/2022 10:51:54'!
        retrieveStringOrText: stringClass
	"Answer a Text or a String. Appropriate for a Text Editor."
	^self default retrieveStringOrText: stringClass! !
!String class methodsFor: 'instance creation' stamp: 'jmv 4/29/2022 11:09:47' prior: 16949926!
              fromUtf8: aByteArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf8:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm | | bytes codePoint |
		bytes _ aByteArray readStream.
		[ bytes atEnd ] whileFalse: [
			codePoint _ (Character nextUnicodeCodePointFromUtf8: bytes).
			codePoint ifNotNil: [
				"Add just one char if possible, or the apropriate sequence for the NCR"
				self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ]].
		(doTrimLastNullChar and: [ codePoint = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !
!Editor methodsFor: 'menu messages' stamp: 'jmv 4/29/2022 11:04:30' prior: 16845671!
       clipboardStringOrText

	| clipContents |
	clipContents _ Clipboard retrieveStringOrText: self privateCurrentString class.
	^ ((clipContents is: #Text) and: [ clipContents respondsTo: #asNonStyledText ])
		ifTrue: [ clipContents asNonStyledText ]
		ifFalse: [ clipContents ]! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 11:01:29' prior: 16816278!
                       retrieveMorph
	"Answer a Morph or nil."
	| answer |
	
	answer _ self retrieveObject: String.
	
	"If clipboard contents is already a Text or String, answer it."
	(answer is: #Morph) ifTrue: [
		^ answer ].

	"If clipboard contains a Form, prepare a Morph including it."
	(answer is: #Form) ifTrue: [
		^ ImageMorph new image: answer ].

	"If clipboard contents is already a Text or String, answer it."
	(answer isString or: [ answer is: #Text ]) ifTrue: [
		^ (TextModelMorph withText: answer asText)
			embeddedInMorphicWindowLabeled: 'Text editor' ].
	
	"No useful contents"
	^nil! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 17:06:14' prior: 16816299!
   retrieveObject
	"Answer whatever was last stored in the clipboard"
	^self retrieveObject: String! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 17:07:21' prior: 16816338!
        retrieveStringOrText
	"Answer a Text or a String. Appropriate for a Text Editor."
	^self retrieveStringOrText: String! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 12:18:43' prior: 16816361!
                   storeObject: anObject
	"Set new contents on the clipboard.  Also export to OS.
	anObject can be a:
		String
		Text
		Form
		Morph
		Object.
	OS clipboard supports String. Other formats might be supported if ExtendedClipboardInterface is present and operative."

	| primitiveFormat id |

	"Store a copy of the object. This is appropriate in case the original object is modified after being copied to the clipboard.
	Another copy must be made again when pasting, as the same object could be pasted many times.
	Besides, store the original object, but weakly (so we don't prevent it GCed). The original object might be used in workspaces."
	(anObject isStringLike or: [ anObject is: #Text])
		ifTrue: [
			contents _ anObject withCuisLineEndings.
			contentsOriginalObjectWeakly at: 1 put: nil ]
		ifFalse: [
			contents _ anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: anObject ].
	
	self noteRecentClipping: contents.

	"Store on OS clipboard using ExtendedClipboardInterface if present"
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			id _ self idFor: contents.
			contents isString
				ifTrue: [ ^interface storeString: contents id: id ].
			(contents is: #Text)
				ifTrue: [ ^interface storeText: contents id: id ].
			(contents is: #Form)
				ifTrue: [ ^interface storeForm: contents id: id ].
			(contents is: #Morph)
				ifTrue: [ ^interface storeForm: (contents imageForm: 32) id: id ].
			^interface storeString: contents asString id: id ]].

	"Otherwise use the clipboard primitives in the VM"
	"The VM uses UTF-8 for clipboard"
	primitiveFormat _ (self stringOrIdFor: contents) asUtf8: true.
	self primitiveClipboardString: primitiveFormat! !
!Clipboard methodsFor: 'private' stamp: 'jmv 4/29/2022 11:38:58' prior: 16816488!
                      stringOrIdFor: anObject
	"
	Clipboard default stringOrIdFor: Smalltalk
	"
	anObject isStringLike ifTrue: [ ^anObject ].
	(anObject is: #Text) ifTrue: [ ^anObject string ].
	^self idFor: anObject! !
!Clipboard class methodsFor: 'default clipboard' stamp: 'jmv 1/18/2011 23:40' prior: 16816541!
                           retrieveObject
	"Answer whatever was last stored in the clipboard"
	^self default retrieveObject! !
!Clipboard class methodsFor: 'default clipboard' stamp: 'jmv 4/29/2022 10:52:56' prior: 16816547!
                          retrieveStringOrText
	"Answer a Text or a String. Appropriate for a Text Editor.
	By default, use String class for Strings"

	^self retrieveStringOrText: String! !

Clipboard removeSelector: #retrieveIdOrStringFromOS!

!methodRemoval: Clipboard #retrieveIdOrStringFromOS stamp: 'Install-5126-Clipboard-StringClassAgnostic-JuanVuletich-2022Apr29-17h05m-jmv.001.cs.st 5/16/2022 10:22:24'!
retrieveIdOrStringFromOS
	"Use a specific content type if ExtendedClipboard is active.
	Otherwise, use regular clipboard primitives"
	| primitiveFormat |

	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			"Answer nil if no id was stored"
			^ interface retrieveId ]].
		
	primitiveFormat _ self primitiveClipboardString asByteArray.

	"Clipboard primitives answer an empty string if there is no string in OS clipboard.
	We prefer nil"
	primitiveFormat isEmpty ifTrue: [ ^nil ].

	"The VM uses UTF-8 for clipboard"
	^(String fromUtf8: primitiveFormat hex: false trimLastNull: true) withCuisLineEndings!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5126-Clipboard-StringClassAgnostic-JuanVuletich-2022Apr29-17h05m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5121] on 29 April 2022 at 2:45:16 pm'!
!Editor methodsFor: 'private' stamp: 'jmv 4/29/2022 11:43:42'!
      stringClassToUse
	^String! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 11:43:56' overrides: 50347536!
            stringClassToUse
	^self privateCurrentString class! !
!Editor methodsFor: 'menu messages' stamp: 'jmv 4/29/2022 11:44:02' prior: 50347374!
                     clipboardStringOrText

	| clipContents |
	clipContents _ Clipboard retrieveStringOrText: self stringClassToUse.
	^ ((clipContents is: #Text) and: [ clipContents respondsTo: #asNonStyledText ])
		ifTrue: [ clipContents asNonStyledText ]
		ifFalse: [ clipContents ]! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/29/2022 11:55:16' prior: 16846076!
                        newLine: aKeyboardEvent

	self addString: (self stringClassToUse with: Character newLineCharacter).
	^false! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/29/2022 11:48:32' prior: 50341338!
                    normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	self addString: (self stringClassToUse with: aKeyboardEvent keyCharacter).
	^false! !
!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/29/2022 12:00:04' prior: 16846089!
    returnKey: aKeyboardEvent
	"Return / Enter / key was pressed"
	"Process the various Return / Enter keystrokes"
	
	morph acceptOnCR ifTrue: [
		^ true].
	aKeyboardEvent commandAltKeyPressed ifTrue: [
		(aKeyboardEvent controlKeyPressed | aKeyboardEvent rawMacOptionKeyPressed) ifTrue: [
			self addString: self stringClassToUse crString.
			^false ].
		self addString: self stringClassToUse crlfString.
		^false ].
	^ self newLine: aKeyboardEvent! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 4/29/2022 12:00:22' prior: 16966542!
       enclose: aKeyboardEvent
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| left right startIndex stopIndex oldSelection which |
	startIndex _ self startIndex.
	stopIndex _ self stopIndex.
	oldSelection _ self selection.
	which _ '([<{"''`' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].
	left _ '([<{"''`' at: which.
	right _ ')]>}"''`' at: which.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) = left and: [(model actualContents at: stopIndex) = right]])
		ifTrue: [
			"already enclosed; strip off brackets"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection]
		ifFalse: [
			"not enclosed; enclose by matching brackets"
			self replaceSelectionWith:
				(Text string: (self stringClassToUse with: left) attributes: emphasisHere),
				oldSelection,
				(Text string: (self stringClassToUse with: right) attributes: emphasisHere).
			self selectFrom: startIndex+1 to: stopIndex].
	^ true! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 4/29/2022 12:00:54' prior: 16966598!
                            inOutdent: aKeyboardEvent delta: delta
	"Add/remove a tab at the front of every line occupied by the selection. 
	Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"
	"This is a user command, and generates undo"

	| realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |

	"Operate on entire lines, but remember the real selection for re-highlighting later"
	realStart _ self startIndex.
	realStop _ self stopIndex - 1.

	"Special case: the text cursor on a line of its own, including weird case at end of paragraph"
	(realStart > realStop and: [
				realStart < 2 or: [(self privateCurrentString at: realStart - 1) isLineSeparator ]])
		ifTrue: [
			delta < 0
				ifTrue: [
					morph flash]
				ifFalse: [
					self replaceSelectionWith: Character tab asSymbol.
					self deselectAndPlaceCursorAt: realStart + 1].
			^true].

	lines _ textComposition lines.
	startLine _ textComposition lineIndexFor: realStart.
	stopLine _ textComposition lineIndexFor: (realStart max: realStop).
	start _ (lines at: startLine) first.
	stop _ (lines at: stopLine) last.
	
	"Pin the start of highlighting unless the selection starts a line"
	adjustStart _ realStart > start.

	"Find the indentation of the least-indented non-blank line; never outdent more"
	indentation _ (startLine to: stopLine) inject: 1000 into: [ :previousValue :each |
		previousValue min: (textComposition indentationOfLineIndex: each ifBlank: [ :tabs | 1000 ])].			

	size _  stop + 1 - start.
	numLines _ stopLine + 1 - startLine.
	inStream _ ReadStream on: self privateCurrentString from: start to: stop.

	newString _ self stringClassToUse new: size + ((numLines * delta) max: 0).
	outStream _ ReadWriteStream on: newString.

	"This subroutine does the actual work"
	self indent: delta fromStream: inStream toStream: outStream.

	"Adjust the range that will be highlighted later"
	adjustStart ifTrue: [realStart _ (realStart + delta) max: start].
	realStop _ realStop + outStream position - size.

	"Prepare for another iteration"
	indentation _ indentation + delta.
	size _ outStream position.
	inStream _ outStream setFrom: 1 to: size.

	outStream
		ifNil: [ 	"tried to outdent but some line(s) were already left flush"
			morph flash]
		ifNotNil: [
			self selectInvisiblyFrom: start to: stop.
			size = newString size ifFalse: [newString _ outStream contents].
			self replaceSelectionWith: newString].
	self selectFrom: realStart to: realStop. 	"highlight only the original range"
	^ true! !
!TextEditor methodsFor: 'typing support' stamp: 'jmv 4/28/2022 17:10:31' prior: 16967347!
                 setEmphasisHereFromTextForward: f

	| i forward delta prevIsLineSeparator nextIsLineSeparator prevIsSeparator nextIsSeparator nextChar prevChar |
	i _ self pointIndex.
	"Try to set emphasisHere correctly after whitespace.
	Most important after a cr, i.e. at the start of a new line"
	prevIsLineSeparator _  i > 1 and: [ (prevChar _ model actualContents at: i-1) isLineSeparator ].
	nextIsLineSeparator _ i <= model textSize and: [ (nextChar _ model actualContents at: i) isLineSeparator ].
	prevIsSeparator _  i > 1 and: [ prevChar isSeparator ].
	nextIsSeparator _ i <= model textSize and: [ nextChar isSeparator ].
	prevIsLineSeparator & nextIsLineSeparator
		ifTrue: [
			"Empty paragraph: take emphasis from the newLine character"
			forward _ false ]
		ifFalse: [
			prevIsSeparator == nextIsSeparator
				ifTrue: [
					"Space at both sides, or non-space at both sides, take emphasis used where the cursor comes from"
					forward _ f ]
				ifFalse: [
					"Space at one side and non-space at the other, take emphasis from the non-space character"
					forward _ nextIsSeparator ]].
	delta _ forward ifTrue: [ 1 ] ifFalse: [ 0 ].
	emphasisHere _ (model actualContents attributesAt: (i - delta max: 1))
					select: [:att | att mayBeExtended].
	morph possiblyChanged! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 12:00:32' prior: 16967581!
                  firstOfBeginningOfLineOrEndOfIndentationLeftOf: position
	
	"Returns the first of beginning-of-line or end-of-indentation that appears to the left of the given position, wrapping around to the end of the line (i.e. the line is considered circular).
	This way, if the given position is beginning-of-line then end-of-indentation is returned."
	
	| currentLine beginningOfLine endOfIndentation stops |
	
	currentLine _ textComposition lines at: (textComposition lineIndexFor: position).
	beginningOfLine _ currentLine first.
	endOfIndentation _ self privateCurrentString
		skipDelimiters: (self stringClassToUse with: Character tab)
		startingAt: beginningOfLine.
		
	stops _ OrderedCollection with: endOfIndentation with: beginningOfLine.
	^ stops detect: [ :stop | stop < position ] ifNone: [endOfIndentation]! !
!SmalltalkEditor methodsFor: 'do-its' stamp: 'jmv 4/29/2022 12:01:03' prior: 16939450!
                             doItSourceCodeFor: aSourceCode in: anEvaluationContext

	^self stringClassToUse streamContents: [ :stream |
		Scanner doItSourceCodeHeaderWithContext: anEvaluationContext notNil into: stream.
		stream nextPutAll: aSourceCode ]! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/29/2022 11:48:00' prior: 16940869 overrides: 50347557!
newLine: aKeyboardEvent
	"Replace the current text selection with a newLine (i.e. LF) followed by as many tabs
	as there are leading tabs on the current line (+/- bracket count)."

	| char s i tabCount stopIndex newLineString |
	s _ self privateCurrentString.
	stopIndex _ self stopIndex.
	i _ stopIndex.
	tabCount _ 0.
	[ (i _ i-1) > 0 and: [ (char _ s at: i) isLineSeparator not ] ] whileTrue: [
		"Count brackets"
		char = $[ ifTrue: [tabCount _ tabCount + 1].
		char = $] ifTrue: [tabCount _ tabCount - 1]].
	[ (i _ i + 1) < stopIndex and: [ (char _ s at: i) isSeparator ] ] whileTrue: [
		"Count leading tabs"
		char = Character tab ifTrue: [ tabCount _ tabCount + 1 ]].
	"Now inject newline with tabCount tabs, generating a new undoable command"
	newLineString _ self stringClassToUse streamContents: [ :strm | strm newLineTab: tabCount ].
	model startNewUndoRedoCommand.
	self replaceSelectionWith: newLineString.
	^ false! !
!SmalltalkEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 4/29/2022 12:01:36' prior: 50341369 overrides: 50347564!
 normalCharacter: aKeyboardEvent 
	"A nonspecial character is to be added to the stream of characters."

	| stopIndex startIndex string key |
	aKeyboardEvent keyCharacter isLetter ifTrue: [^ super normalCharacter: aKeyboardEvent].
	"Allow to enter named (otherwise untypable) characters like the alpha greek letter as \alpha."
	string _ self privateCurrentString.
	stopIndex _ self pointIndex - 1.
	(stopIndex between: 2 and: string size)
		ifFalse: [^ super normalCharacter: aKeyboardEvent].
	startIndex _ stopIndex.
	"Look backwards and find a character that is not a letter (we want to find '\' just a few characters behind):"
	[startIndex > 0 and: [stopIndex - startIndex < 7 and: [(string at: startIndex) isLetter]]] whileTrue: [startIndex _ startIndex - 1].
	(startIndex > 0 and: [(string at: startIndex) = $\])
		ifFalse: [^ super normalCharacter: aKeyboardEvent].
	key _ string copyFrom: startIndex+1 to: stopIndex.
	(Character namedCharactersTable detect: [:one| key = one first] ifNone: [])
		ifNotNil: [:aPair| self selectFrom: startIndex to: stopIndex; replaceSelectionWith: (self stringClassToUse with: aPair second)].
	^ super normalCharacter: aKeyboardEvent! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5127-stringClassToUse-JuanVuletich-2022Apr29-14h43m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5123] on 29 April 2022 at 5:21:48 pm'!
!SequenceableCollection methodsFor: 'accessing' stamp: 'jmv 4/29/2022 16:42:11' prior: 16933908!
 replaceAll: oldObject with: newObject 
	"Replace all occurences of oldObject with newObject"
	| index |
	index _ self indexOf: oldObject startingAt: 1.
	[index = 0] whileFalse: [
		self at: index put: newObject.
		index _ self indexOf: oldObject startingAt: index + 1 ].! !
!String methodsFor: 'converting' stamp: 'jmv 4/29/2022 15:07:16' prior: 16948222!
                            asUtf8
	"Convert the given string to UTF-8 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a ByteArray.
	
	See #fromUtf8: "

	^self asUtf8: true.! !
!String methodsFor: 'converting' stamp: 'jmv 4/29/2022 16:20:22' prior: 50347084!
           withCuisLineEndings
	"Assume that CR, LF, and CRLF are all valid line endings.
	Answer a new instance, replacing each occurence with a single Lf.
	('aLine', String crlfString, 'anotherOne') withCuisLineEndings
	"
	^ self withLineEndings: `String newLineString`.! !
!String methodsFor: 'converting' stamp: 'jmv 4/29/2022 15:00:21' prior: 16948740!
     withDescriptiveLineEndings
	"
	('Hello', String newLineString, 'World') withDescriptiveLineEndings
	"
	^ self withLineEndings: '[enter]'! !
!Clipboard methodsFor: 'accessing' stamp: 'jmv 4/29/2022 16:36:42' prior: 50347420!
storeObject: anObject
	"Set new contents on the clipboard.  Also export to OS.
	anObject can be a:
		String
		Text
		Form
		Morph
		Object.
	OS clipboard supports String. Other formats might be supported if ExtendedClipboardInterface is present and operative."

	| primitiveFormat id |

	"Store a copy of the object. This is appropriate in case the original object is modified after being copied to the clipboard.
	Another copy must be made again when pasting, as the same object could be pasted many times.
	Besides, store the original object, but weakly (so we don't prevent it GCed). The original object might be used in workspaces."
	(anObject isStringLike or: [ anObject is: #Text])
		ifTrue: [
			contents _ anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: nil ]
		ifFalse: [
			contents _ anObject copyForClipboard.
			contentsOriginalObjectWeakly at: 1 put: anObject ].
	
	self noteRecentClipping: contents.

	"Store on OS clipboard using ExtendedClipboardInterface if present"
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			id _ self idFor: contents.
			contents isString
				ifTrue: [ ^interface storeString: contents id: id ].
			(contents is: #Text)
				ifTrue: [ ^interface storeText: contents id: id ].
			(contents is: #Form)
				ifTrue: [ ^interface storeForm: contents id: id ].
			(contents is: #Morph)
				ifTrue: [ ^interface storeForm: (contents imageForm: 32) id: id ].
			^interface storeString: contents asString id: id ]].

	"Otherwise use the clipboard primitives in the VM"
	"The VM uses UTF-8 for clipboard"
	primitiveFormat _ (self stringOrIdFor: contents) asUtf8: true.
	self primitiveClipboardString: primitiveFormat! !

Text removeSelector: #fixLineEndings!

!methodRemoval: Text #fixLineEndings stamp: 'Install-5128-Cleanup-n-tweaks-JuanVuletich-2022Apr29-17h19m-jmv.001.cs.st 5/16/2022 10:22:24'!
fixLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>.
	If possible, modify and answer the same instance. Create a new instance only if needed.
	Be quick and don't use extra memory if already using Character lf!!
	('Hello ', String crlfString, 'World') asText fixLineEndings
	('Hello ', String crString, 'World') asText fixLineEndings
	('Hello ', String lfString, 'World') asText fixLineEndings
	"

	| newText |
	(string includes: `Character cr`) ifFalse: [ ^self ].
	newText _ self.
	(string includesSubString: `String crlfString`) ifTrue: [ "A new instance is needed"
		newText _ self copyReplaceAll: `String crlfString` with: `String newLineString` asTokens: false ].
	newText string replaceAll: `Character cr` with: `Character lf`.
	^newText!

Text removeSelector: #withCuisLineEndings!

!methodRemoval: Text #withCuisLineEndings stamp: 'Install-5128-Cleanup-n-tweaks-JuanVuletich-2022Apr29-17h19m-jmv.001.cs.st 5/16/2022 10:22:24'!
withCuisLineEndings
	"Answer a copy of myself in which all sequences of <CR><LF> or <CF> have been changed to <LF>"

	| newText wrongLineEnd |
	wrongLineEnd _ `String crlfString detect: [ :char | (char = Character newLineCharacter) not ]`.
	(string includes: wrongLineEnd) ifFalse: [ ^self copy ].
	newText _ self copyReplaceAll: `String crlfString` with: `String newLineString` asTokens: false.
	newText string replaceAll: wrongLineEnd with: `Character newLineCharacter`.
	^newText!

Text removeSelector: #copyReplaceTokens:with:!

!methodRemoval: Text #copyReplaceTokens:with: stamp: 'Install-5128-Cleanup-n-tweaks-JuanVuletich-2022Apr29-17h19m-jmv.001.cs.st 5/16/2022 10:22:24'!
copyReplaceTokens: oldSubstring with: newSubstring 
	"Replace all occurrences of oldSubstring that are surrounded
	by non-alphanumeric characters"
	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true
	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'"!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5128-Cleanup-n-tweaks-JuanVuletich-2022Apr29-17h19m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5116] on 29 April 2022 at 11:09:13 pm'!

Editor subclass: #TextEditor
	instanceVariableNames: 'model textComposition markBlock pointBlock emphasisHere lastParenLocation selectionStartBlocks selectionStopBlocks initialSelectionStart initialSelectionStop doWordSelection doParagraphSelection defaultFont '
	classVariableNames: 'ChangeText FindText '
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #TextEditor category: #'System-Text' stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
Editor subclass: #TextEditor
	instanceVariableNames: 'model textComposition markBlock pointBlock emphasisHere lastParenLocation selectionStartBlocks selectionStopBlocks initialSelectionStart initialSelectionStop doWordSelection doParagraphSelection defaultFont'
	classVariableNames: 'ChangeText FindText'
	poolDictionaries: ''
	category: 'System-Text'!

Object subclass: #TextComposition
	instanceVariableNames: 'model extentForComposing lines maxRightX selectionStartBlocks selectionStopBlocks editor showTextCursor lastTextCursorRect selectionStopBlock selectionStartBlock '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Text Support'!

!classDefinition: #TextComposition category: #'Morphic-Text Support' stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
Object subclass: #TextComposition
	instanceVariableNames: 'model extentForComposing lines maxRightX selectionStartBlocks selectionStopBlocks editor showTextCursor lastTextCursorRect selectionStopBlock selectionStartBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Text Support'!
!TextComposition methodsFor: 'selection' stamp: 'jmv 4/29/2022 23:08:43'!
              selectionStartBlock: startBlock selectionStopBlock: stopBlockBlock
	selectionStartBlock _ startBlock.
	selectionStopBlock _ stopBlockBlock.! !
!TextEditor methodsFor: 'accessing' stamp: 'jmv 4/29/2022 21:27:07' prior: 16966134!
                            replaceSelectionWith: aTextOrString
	"Deselect, and replace the selection text by aText."
	"This is a user command, and generates undo"

	| start stop replacement |

	morph disablesEditing ifTrue: [
		^ self ].

	start _ self startIndex.
	stop _ self stopIndex.
	(aTextOrString isEmpty and: [stop > start]) ifTrue: [
		"If deleting, then set emphasisHere from 1st character of the deletion"
		emphasisHere _ (model actualContents attributesAt: start) select: [:att |
			att mayBeExtended]].

	(start = stop and: [ aTextOrString isEmpty ]) ifFalse: [
		replacement _ self addAttributesForPasting: aTextOrString.
		model logUndoAndReplaceFrom: start to: stop - 1 with: replacement.
		textComposition
			recomposeFrom: start
			to:  start + replacement size - 1
			delta: replacement size - (stop-start).
		self deselectAndPlaceCursorAt: start + replacement size.
		self userHasEdited  " -- note text now dirty" ].

	morph possiblyChanged! !
!TextEditor methodsFor: 'accessing' stamp: 'jmv 4/29/2022 21:11:48' prior: 16966168!
selectionRectangle
	"Answer a rectangle that encompasses selection.
	If no selection, answer a rectangle that includes cursor."
	^ markBlock quickMerge: pointBlock! !
!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 4/29/2022 21:19:42' prior: 16966211!
                          hasSelection
	^ markBlock ~= pointBlock! !
!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 4/29/2022 21:11:09' prior: 16966256!
                      selection
	"Answer the text that is currently selected."

	| t firstIndex lastIndex |
	t _ model actualContents.
	firstIndex _ self startIndex.
	lastIndex _ self stopIndex - 1.
	(firstIndex = 1 and: [ lastIndex = t size ])
		ifTrue: [ ^t copy ].
	^t copyFrom: firstIndex to: lastIndex! !
!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 4/29/2022 21:11:20' prior: 16966281!
 selectionAsStream
	"Answer a ReadStream on the text that is currently  selected."

	^ReadWriteStream
		on: self privateCurrentString
		from: self startIndex
		to: self stopIndex - 1! !
!TextEditor methodsFor: 'current selection' stamp: 'jmv 4/29/2022 21:24:19' prior: 16966445!
          recomputeSelection
	"The same characters are selected but their coordinates may have changed."

	self markIndex: self markIndex pointIndex: self pointIndex.! !
!TextEditor methodsFor: 'events' stamp: 'jmv 4/29/2022 21:09:43' prior: 16966785!
              mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	| b |

	initialSelectionStart _ nil.
	initialSelectionStop _ nil.
	doWordSelection _ false.
	doParagraphSelection _ false.

	b _ textComposition characterBlockAtPoint: localEventPosition.
	(textComposition clickAt: localEventPosition) ifTrue: [
		markBlock _ b.
		pointBlock _ b.
		aMouseButtonEvent hand releaseKeyboardFocus: self.
		^ self ].
	
	aMouseButtonEvent shiftPressed
		ifFalse: [
			markBlock _ b.
			pointBlock _ b.	
			self setEmphasisHereFromText ]! !
!TextEditor methodsFor: 'menu messages' stamp: 'jmv 4/29/2022 21:27:48' prior: 16966960!
             cut
	"Cut out the current selection and redisplay if necessary."
	"This is a user command, and generates undo"

	| selection |
	self lineSelectAndEmptyCheck: [^ self].
	selection _ self selection.
	self replaceSelectionWith: self nullText.
	self clipboardTextPut: selection.! !
!TextEditor methodsFor: 'new selection' stamp: 'jmv 4/29/2022 21:20:22' prior: 16967119 overrides: 16845686!
                             lineSelectAndEmptyCheck: returnBlock
	"If the current selection is empty, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."

	self selectLine.  "if current selection is empty, then first select the entire line in which occurs before proceeding"
	self hasSelection ifFalse: [morph flash.  ^ returnBlock value]! !
!TextEditor methodsFor: 'new selection' stamp: 'jmv 4/29/2022 21:09:06' prior: 16967139!
                        messageSendsRanges: aRanges
	"aRanges must be notEmpty"
	| lastRange |

	lastRange := nil.
	aRanges do: [ :range |
		( lastRange isNil or: [ range first > lastRange first ]) ifTrue: [
			lastRange _ range ]].

	self selectFrom: lastRange first to: lastRange last! !
!TextEditor methodsFor: 'new selection' stamp: 'jmv 4/29/2022 21:20:50' prior: 16967185!
                             selectLine
	"Make the receiver's selection, if currently empty, encompass the current line."
	self hasSelection ifTrue:[^self].
	self selectInterval: (model actualContents encompassLine: self selectionInterval)! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 21:23:52' prior: 16967462!
                       applyAttribute: aTextAttribute
	"The user selected aTextAttribute via shortcut, menu or other means.
	If there is a selection, apply the attribute to the selection.
	In any case use the attribute for the user input (emphasisHere)"
	"This generates undo"
	| anythingDone interval |

	morph disablesEditing ifTrue: [
		^ self ].

	anythingDone _ false.
	emphasisHere _ Text addAttribute: aTextAttribute toArray: emphasisHere.

	interval _ self selectionInterval.
	(interval notEmpty or: [ aTextAttribute isParagraphAttribute ])
		ifTrue: [
			anythingDone _ true.
			model logUndoAndAddAttribute: aTextAttribute from: interval first to: interval last.
			textComposition recomposeFrom: interval first to: interval last delta: 0 ].

	anythingDone ifTrue: [
		self recomputeSelection.	"Needed so visible selection is updated to reflect new visual extent of selection"
		self userHasEdited ].

	"Even if nothing done, emphasisHere might have changed"
	morph possiblyChanged.! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 21:25:57' prior: 16967513!
findAndReplaceMany: doMany
	"Subroutine of search: and again.  Use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."
	"jmvnote: We currently have no command for search&replace, but it is really easy to add, and this method supports it. See ChangeText"
	"This is a user command, and generates undo"

	|  indexStream |

	"Find and Change, recording start indices in the array"
	indexStream _ WriteStream on: (Array new: 20). "an array to store change locs"
	[(self findAndReplaceOnce: indexStream) & doMany] whileTrue. "<-- this does the work"
	"Answer whether something was found"
	^indexStream notEmpty! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 21:08:01' prior: 16967545!
                   findAndReplaceOnce: indexStream
	"Find the next occurrence of FindText.  If none, answer false.
	Append the start index of the occurrence to the stream indices, and, if
	ChangeText is not the same object as FindText, replace the occurrence by it.
	Note that the search is case-sensitive for replacements, otherwise not."
	"This is a user command, and generates undo"

	| where |
	where _ model actualContents
		findString: self class findText
		startingAt: self stopIndex
		caseSensitive: ((self class changeText ~~ self class findText) or: [Preferences caseSensitiveFinds]).
	where = 0 ifTrue: [^ false].

	self selectFrom: where to: where + self class findText size - 1.	"Repeat it here. Senders beware: only one of these should last"

	self class changeText ~~ self class findText ifTrue: [ self replaceSelectionWith: self class changeText ].
	indexStream nextPut: where.
	^ true! !
!TextEditor methodsFor: 'private' stamp: 'jmv 4/29/2022 23:00:53' prior: 16967741!
                       storeSelectionInComposition
	"for proper display of selected text"

	pointBlock ifNil: [ ^self ].
	textComposition
		selectionStartBlock: self startBlock
		selectionStopBlock: self stopBlock.! !
!TextEditor methodsFor: 'initialization' stamp: 'jmv 4/29/2022 21:27:58' prior: 16968037 overrides: 16920235!
               initialize
	initialSelectionStart _ nil.
	initialSelectionStop _ nil.
	doWordSelection _ false.
	doParagraphSelection _ false.
	defaultFont _ FontFamily defaultFamilyAndPointSize! !
!TextEditor methodsFor: 'initialization' stamp: 'jmv 4/29/2022 21:28:03' prior: 16968047!
                resetState
	"Establish the initial conditions for editing the paragraph: place text cursor 
	before first character and set the emphasis to that of the first character"

	markBlock _ textComposition defaultCharacterBlock.
	pointBlock _ markBlock.! !
!TextComposition methodsFor: 'display' stamp: 'jmv 4/29/2022 23:08:30' prior: 16965626!
              displaySelectionInLine: line on: aCanvas textTopLeft: textTopLeft  selectionColor: sc

	"textTopLeft is relative to the morph currently being drawn"
	selectionStartBlock ifNotNil: [
		self
			displaySelectionStartBlock: selectionStartBlock
			stopBlock: selectionStopBlock
			InLine: line
			on: aCanvas
			textTopLeft: textTopLeft
			selectionColor: sc ].! !
!TextComposition methodsFor: 'selection' stamp: 'jmv 4/29/2022 23:05:56' prior: 16965867!
                              selectionRects
	"Return an array of rectangles representing the selection regions."
	^ Array streamContents: [ :strm |
		selectionStartBlock ifNotNil: [
			self addSelectionRectsFrom: selectionStartBlock to: selectionStopBlock to: strm ]].! !
!TextComposition methodsFor: 'initialization' stamp: 'jmv 4/29/2022 23:08:39' prior: 16965971 overrides: 16920235!
                          initialize
	showTextCursor _ false.
	selectionStartBlock _ nil.
	selectionStopBlock _ nil.! !

TextComposition removeSelector: #selectionStartBlocks:selectionStopBlocks:!

!methodRemoval: TextComposition #selectionStartBlocks:selectionStopBlocks: stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selectionStartBlocks: startBlocks selectionStopBlocks: stopBlockBlocks
	selectionStartBlocks _ startBlocks.
	selectionStopBlocks _ stopBlockBlocks.!

SmalltalkEditor removeSelector: #selection!

!methodRemoval: SmalltalkEditor #selection stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selection
	"Answer the text that is currently selected.
	Redefined for Smalltalk code: if there's no regular selection, and all the selectionBlocks contain the same string,
	answer that string."
	| t regularSelection allPartsEqual samePart firstIndex |
	t _ model actualContents.
	firstIndex _ self startIndex.
	lastIndex _ self stopIndex - 1.

	(firstIndex = 1 and: [ lastIndex = t size ])
		ifTrue: [ ^t copy ].

	regularSelection _ ( t copyFrom: firstIndex to: lastIndex).
	allPartsEqual _ true.
	samePart _ nil.
	^Text streamContents: [ :strm |
		"Multiple selection"
		selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock | | toAppend |
			toAppend _ t copyFrom: startBlock stringIndex to: stopBlock stringIndex - 1.
			toAppend size > 0 ifTrue: [
				samePart
					ifNil: [ samePart _ toAppend ]
					ifNotNil: [
						allPartsEqual _ allPartsEqual and: [ samePart = toAppend ]].
				strm nextPutAll: toAppend.
				strm withAttributes: (toAppend attributesAt: toAppend size) do: [ strm newLine ]].
			].
		(allPartsEqual and: [ regularSelection isEmpty ]) ifTrue: [
			^samePart ifNil: [ '' asText ]].
		"Regular selection"
		strm nextPutAll: regularSelection ]!

TextEditor removeSelector: #zapMultiSelection!

!methodRemoval: TextEditor #zapMultiSelection stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
zapMultiSelection
	"This generates undo"

	| delta intervals mi pi start stop miAndPiUpdated |
	miAndPiUpdated _ false.
	mi _ self markIndex.
	pi _ self pointIndex.
	delta _ 0.
	intervals _ (selectionStartBlocks with: selectionStopBlocks
		collect: [ :strt :stp | strt stringIndex to: stp stringIndex ])
			sorted: [ :a :b | a first < b first ].
	intervals do: [ :interval |
		miAndPiUpdated not ifTrue: [
			interval first > mi
				ifTrue: [
					miAndPiUpdated _ true.
					mi _ mi + delta.
					pi _ pi + delta ]
				ifFalse: [
					interval last > mi ifTrue: [
						miAndPiUpdated _ true.
						mi _ interval first + delta.
						pi _ mi ]]].
		start _  interval first+delta.
		stop _ interval last - 1 + delta.
		model logUndoAndReplaceFrom: start to: stop with: ''.
		delta _ delta - (interval size-1).
		textComposition
			recomposeFrom: start
			to:  start - 1
			delta: delta ].

	miAndPiUpdated not ifTrue: [
		mi _ mi + delta.
		pi _ pi + delta ].
	selectionStartBlocks _ #().
	selectionStopBlocks _ #().
	self markIndex: mi pointIndex: pi!

TextEditor removeSelector: #selectInterval:!

!methodRemoval: TextEditor #selectInterval: stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selectInterval: anInterval
	"Deselect, then select the specified characters inclusive.
	 Be sure the selection is in view."

	selectionStartBlocks _ #().
	selectionStopBlocks _ #().
	super selectInterval: anInterval!

TextEditor removeSelector: #deselectAndPlaceCursorAt:!

!methodRemoval: TextEditor #deselectAndPlaceCursorAt: stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
deselectAndPlaceCursorAt: characterIndex 
	"Deselect, then place the text cursor before the character at characterIndex.
	 Be sure it is in view."

	selectionStartBlocks _ #().
	selectionStopBlocks _ #().
	super deselectAndPlaceCursorAt: characterIndex!

TextEditor removeSelector: #selectAll!

!methodRemoval: TextEditor #selectAll stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selectAll

	selectionStartBlocks _ #().
	selectionStopBlocks _ #().
	super selectAll!

TextEditor removeSelector: #selectionIntervalsDo:!

!methodRemoval: TextEditor #selectionIntervalsDo: stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selectionIntervalsDo: aBlock
	"Evaluate over all selections. For editors with a single selection, just evaluate over it.
	Subclasses with multi-selection redefine this method."

	"multi-selection"
	selectionStartBlocks with: selectionStopBlocks do: [ :startBlock :stopBlock |
		aBlock value: (startBlock stringIndex to: stopBlock stringIndex - 1) ].

	"Simple (i.e. last) selection"
	aBlock value: self selectionInterval!

Editor removeSelector: #selectionIntervalsDo:!

!methodRemoval: Editor #selectionIntervalsDo: stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:24'!
selectionIntervalsDo: aBlock
	"Evaluate over all selections. For editors with a single selection, just evaluate over it.
	Subclasses with multi-selection redefine this method."

	aBlock value: self selectionInterval!

Editor subclass: #TextEditor
	instanceVariableNames: 'model textComposition markBlock pointBlock emphasisHere lastParenLocation initialSelectionStart initialSelectionStop doWordSelection doParagraphSelection defaultFont'
	classVariableNames: 'ChangeText FindText'
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #TextEditor category: #'System-Text' stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:25'!
Editor subclass: #TextEditor
	instanceVariableNames: 'model textComposition markBlock pointBlock emphasisHere lastParenLocation initialSelectionStart initialSelectionStop doWordSelection doParagraphSelection defaultFont'
	classVariableNames: 'ChangeText FindText'
	poolDictionaries: ''
	category: 'System-Text'!

Object subclass: #TextComposition
	instanceVariableNames: 'model extentForComposing lines maxRightX editor showTextCursor lastTextCursorRect selectionStartBlock selectionStopBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Text Support'!

!classDefinition: #TextComposition category: #'Morphic-Text Support' stamp: 'Install-5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #TextComposition
	instanceVariableNames: 'model extentForComposing lines maxRightX editor showTextCursor lastTextCursorRect selectionStartBlock selectionStopBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Text Support'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5129-RemoveSupportForMultipleSelectionInEditors-JuanVuletich-2022Apr29-23h07m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5129] on 2 May 2022 at 1:16:16 pm'!
!CodePackage methodsFor: 'enumerating' stamp: 'jmv 5/2/2022 13:12:41' prior: 16818883!
                 coreMethodsOf: aClass do: aBlock
	"Evaluate aBlock with the actual method objects in this package."

	aClass organization categories do: [ :cat |
		(self isForeignClassExtension: cat) ifFalse: [
			(aClass organization listAtCategoryNamed: cat) do: [ :s |
				aBlock value: (self referenceForMethod: s ofClass: aClass) ]]].! !
!CodePackage methodsFor: 'saving' stamp: 'jmv 5/2/2022 13:14:07' prior: 16819349!
       writeOnStream: aStream

	| sortedClasses |
	aStream
		nextChunkPut: ('Description ', description) printString;
		newLine.
	self writeFeatureSpecOn: aStream.
	self writeSystemCategoriesOn: aStream.

	self codePackageClass ifNotNil: [ :codePackageClass |
		self
			write: {codePackageClass} classDefinitionsOn: aStream;
			write: {codePackageClass} classCommentsOn: aStream;
			write: {codePackageClass} methodsOn: aStream.
		aStream nextChunkPut: codePackageClass name, ' prePackageInstall'; newLine ].

	sortedClasses _ Array streamContents: [ :strm |
		self classesInSafeOrderDo: [ :cls |
			cls == self class ifFalse: [
				strm nextPut: cls ]]].
	self
		write: sortedClasses classDefinitionsOn: aStream;
		write: sortedClasses classCommentsOn: aStream;
		write: sortedClasses methodsOn: aStream.

	self
		sortedExtensionMethodsDo:  [ :methodReference |
			methodReference isValid ifTrue: [
				self writeMethod: methodReference on: aStream ]]
		displayingProgress: 'Saving extension methods...'.
	self write: sortedClasses initializersOn: aStream.

	self codePackageClass ifNotNil: [ :codePackageClass |
		self write: { codePackageClass } initializersOn: aStream.
		aStream nextChunkPut: codePackageClass name, ' postPackageInstall'; newLine ]! !

CodePackage removeSelector: #selectorNeededForFilein:!

!methodRemoval: CodePackage #selectorNeededForFilein: stamp: 'Install-5130-CodePackage-removeSpecialMethodsForFilein-JuanVuletich-2022May02-13h11m-jmv.001.cs.st 5/16/2022 10:22:25'!
selectorNeededForFilein: aSelector
	"Answer true if aSelector might be needed for proper filein of the remaing methods."

	^ Metaclass isScarySelector: aSelector!

CodePackage removeSelector: #coreMethodsForFileinOf:do:!

!methodRemoval: CodePackage #coreMethodsForFileinOf:do: stamp: 'Install-5130-CodePackage-removeSpecialMethodsForFilein-JuanVuletich-2022May02-13h11m-jmv.001.cs.st 5/16/2022 10:22:25'!
coreMethodsForFileinOf: aClass do: aBlock
	"Evaluate aBlock with the actual method objects in this package.
	Only enumerate those methods that might be needed for proper filein.
	such as #compilerClass."

	aClass organization categories do: [ :cat |
		(self isForeignClassExtension: cat) ifFalse: [
			(aClass organization listAtCategoryNamed: cat) do: [ :s |
				(self selectorNeededForFilein: s) ifTrue: [
					aBlock value: (self referenceForMethod: s ofClass: aClass) ]]]]!

CodePackage removeSelector: #write:methodsForFileinOn:!

!methodRemoval: CodePackage #write:methodsForFileinOn: stamp: 'Install-5130-CodePackage-removeSpecialMethodsForFilein-JuanVuletich-2022May02-13h11m-jmv.001.cs.st 5/16/2022 10:22:25'!
write: classes methodsForFileinOn: aStream

	classes
		do: [ :class |
			self 
				writeCoreMethodsForFileinOf: class class on: aStream;
				writeCoreMethodsForFileinOf: class on: aStream ]
		displayingProgress: 'Saving methods...'!

CodePackage removeSelector: #writeCoreMethodsForFileinOf:on:!

!methodRemoval: CodePackage #writeCoreMethodsForFileinOf:on: stamp: 'Install-5130-CodePackage-removeSpecialMethodsForFilein-JuanVuletich-2022May02-13h11m-jmv.001.cs.st 5/16/2022 10:22:25'!
writeCoreMethodsForFileinOf: aClass on: aStream

	self coreMethodsForFileinOf: aClass do: [ :methodReference |
		methodReference isValid
			ifTrue: [
				self writeMethod: methodReference on: aStream ]]!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5130-CodePackage-removeSpecialMethodsForFilein-JuanVuletich-2022May02-13h11m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5130] on 2 May 2022 at 3:23:08 pm'!
!String methodsFor: 'accessing' stamp: 'jmv 4/29/2022 20:21:29'!
                          findString: subString in: body startingAt: start
	"Answer the index of subString within the receiver, starting at start. If 
	the receiver does not contain subString, answer 0."

	^ self findSubstring: subString in: body startingAt: start matchTable: CaseSensitiveOrder.! !
!BitBlt methodsFor: 'private' stamp: 'jmv 9/2/2016 11:06:18' prior: 50347197!
primDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta
	| ascii glyph |
	<primitive:'primitiveDisplayString' module:'BitBltPlugin'>
	startIndex to: stopIndex do:[:charIndex|
		ascii _ (aString at: charIndex) numericValue.
		glyph _ glyphMap at: ascii + 1.
		sourceX _ xTable at: glyph + 1.
		width _ (xTable at: glyph + 2) - sourceX.
		self copyBits.
		destX _ destX + width + kernDelta.
	].! !

BitBlt removeSelector: #primFaiDisplayString:from:to:map:xTable:kern:!

!methodRemoval: BitBlt #primFaiDisplayString:from:to:map:xTable:kern: stamp: 'Install-5131-Tweaks-JuanVuletich-2022May02-15h22m-jmv.001.cs.st 5/16/2022 10:22:25'!
primFaiDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta

	| ascii glyph |
	startIndex to: stopIndex do: [ :charIndex |
		ascii _ (aString at: charIndex) numericValue.
		glyph _ glyphMap at: ascii + 1.
		sourceX _ xTable at: glyph + 1.
		width _ (xTable at: glyph + 2) - sourceX.
		self copyBits.
		destX _ destX + width + kernDelta.
	].!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5131-Tweaks-JuanVuletich-2022May02-15h22m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5131] on 2 May 2022 at 4:27:41 pm'!

BitBltCanvas removeSelector: #drawStringEmbossed:from:to:at:font:color:!

!methodRemoval: BitBltCanvas #drawStringEmbossed:from:to:at:font:color: stamp: 'Install-5132-Cleanup-JuanVuletich-2022May02-16h27m-jmv.001.cs.st 5/16/2022 10:22:25'!
drawStringEmbossed: aString from: firstIndex to: lastIndex at: aPoint font: font color: aColor
	"Answer position to place next glyph
	Answer nil if nothing was done"
	| p1 |
	p1 _ (currentTransformation transform: aPoint roundedHAFZ) roundedHAFZ.
	engine colorMap: nil.

	aColor = `Color black` ifFalse: [ | topColor |
		topColor _ aColor alphaMixed: 0.25 with: `Color black`.
		font
			onBitBltCanvasEngine: engine
			displayString: aString
			from: firstIndex
			to: lastIndex
			at: p1
			color: topColor ].
	aColor = `Color white` ifFalse: [ | bottomColor |
		bottomColor _ aColor alphaMixed: 0.22 with: `Color white`.
		font
			onBitBltCanvasEngine: engine
			displayString: aString
			from: firstIndex
			to: lastIndex
			at: p1 + `0@2`
			color: bottomColor ].
	^font
		onBitBltCanvasEngine: engine
		displayString: aString
		from: firstIndex
		to: lastIndex
		at: p1 + `0@1`
		color: aColor.!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5132-Cleanup-JuanVuletich-2022May02-16h27m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5132] on 3 May 2022 at 12:24:17 pm'!
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 5/3/2022 12:24:14' prior: 16869862!
                   draw: item atRow: row on: canvas
	"display the given item at row row"
	| f c |
	(item is: #Text)
		ifTrue: [
			f _ font emphasized: (item emphasisAt: 1).
			c _ (item colorAt: 1) ifNil: [Theme current text]]
		ifFalse: [ 
			f _ font.
			c _  Theme current text].
	canvas
		drawString: item string
		at: 0 @ (self drawYForRow: row)
		font: f
		color: c! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5133-InnerListMorph-Fix-JuanVuletich-2022May03-12h24m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5133] on 3 May 2022 at 1:10:58 pm'!
!TextEditor methodsFor: 'private' stamp: 'jmv 5/3/2022 13:08:48' prior: 50347540 overrides: 50347536!
               stringClassToUse
	^self privateCurrentString asPlainString class! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5134-TextEditor-fix-JuanVuletich-2022May03-13h10m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5134] on 3 May 2022 at 5:04:08 pm'!
!Character class methodsFor: 'converting' stamp: 'jmv 5/3/2022 15:51:49'!
                utfBytesAndCodePointAt: byteIndex in: utf8ByteArray into: bytesBlock into: codePointBlock
	"Find next UTF-8 encoded code point in utf8ByteArray starting at byte byteIndex.
	Evalueate bytesBlock (if not nil). Arguments are utf8 bytes for the codePoint found.
	Evaluate codePointBlock (if not nil) with codePoint found as argument.
	Answer the number of bytes that comprised this codePoint.
	If there is an invalid UTF-8 sequence, skip it. Also skip codePoint U+FEFF (BOM, unneededly added by Win clipboard).
	But in any case, answer the number of bytes of the invalid sequence, to allow senders to update an index in an iteration.
	See senders."

	| n byte1 byte2 byte3 byte4 codePoint |
	n _ 0.
	byte1 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	byte1 < 128 ifTrue: [	"single byte"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: nil value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: byte1 ].
		^ n ].
	
	"At least 2 bytes"
	byte2 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63).
			codePointBlock value: codePoint ].
		^n ].
	
	"At least 3 bytes"
	byte3 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
		codePoint = 16rFEFF ifTrue: [ ^n ].
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: codePoint ].
		^n ].

	"4 bytes"
	byte4 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: byte4 ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12)
					+ ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63).
			codePointBlock value: codePoint ].
		].
	^n! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/3/2022 17:03:05' prior: 16809138!
                            nextCodePointBytesFromUtf8: anUtf8Stream into: aBlock
	"anUtf8Stream can be over a ByteArray.
	See senders."
"Note: This method will be removed. Prefer
#utfBytesAndCodePointAt:in:into:into:
"
	| byte1 byte2 byte3 byte4 |
	byte1 _ anUtf8Stream next.
	byte1 < 128 ifTrue: [	"single byte"
		^ aBlock value: byte1 value: nil value: nil value: nil ].
	
	"At least 2 bytes"
	byte2 _ anUtf8Stream next.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		^ aBlock value: byte1 value: byte2 value: nil value: nil ].
	
	"At least 3 bytes"
	byte3 _ anUtf8Stream next.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: nil ].

	"4 bytes"
	byte4 _ anUtf8Stream next.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: byte4 ].

	^nil! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/3/2022 17:02:51' prior: 16809171!
                         nextUnicodeCodePointFromUtf8: anUtf8Stream
	"anUtf8Stream can be over a ByteArray
	Answer nil if conversion not possible, because of invalid UTF-8.
	Also answer nil for codePoint U+FEFF (BOM, unneededly added by Win clipboard)"
"Note: This method will be removed. Prefer
#utfBytesAndCodePointAt:in:into:into:
"
	^ self
		nextCodePointBytesFromUtf8: anUtf8Stream
		into: [ :byte1 :byte2 :byte3 :byte4 |
			byte4 notNil
				ifTrue: [ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12) + ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63) ]
				ifFalse: [
					byte3 notNil
						ifTrue: [ | codePoint |
							codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
							codePoint = 16rFEFF
								ifFalse: [ codePoint ]
								ifTrue: [ nil ]]
						ifFalse: [
							byte2 notNil
								ifTrue: [ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ]
								ifFalse: [ byte1 ]]]]! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/3/2022 17:01:56' prior: 16809201!
   unicodeCodePointOfUtf8Bytes: aByteArray

	Character utfBytesAndCodePointAt: 1 in: aByteArray
				into: nil
				into: [ :codePoint | ^ codePoint ].! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/3/2022 16:57:11' prior: 50347335!
            fromUtf8: aByteArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf8:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utfBytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					"Add just one char if possible, or the apropriate sequence for the NCR"
					self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
			byteIndex _ byteIndex + n
		].
		(doTrimLastNullChar and: [ aByteArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/3/2022 16:14:35' prior: 16950004!
                             utf32FromUtf8: aByteArray
	"Convert the given string from UTF-8 to UTF-32"

	^WordArray streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utfBytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					strm nextPut: codePoint ].
			byteIndex _ byteIndex + n
		]].! !
!Clipboard methodsFor: 'private' stamp: 'jmv 5/3/2022 14:49:59' prior: 50347291!
                 retrieveIdOrStringFromOS: stringClass
	"Use a specific content type if ExtendedClipboard is active.
	Otherwise, use regular clipboard primitives"
	| utf8Bytes |
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			"Answer nil if no id was stored"
			^ interface retrieveId ]].

	utf8Bytes _ self primitiveClipboardString.

	"Clipboard primitives answer an empty string if there is no string in OS clipboard."
	utf8Bytes isEmpty ifTrue: [ ^nil ].

	"Clipboard primitive answers an instance of String containing the UTF-8 bytes.
	If not pure ASCII, contents are invalid!! Convert it ASAP into a reasonable ByteArray."
	utf8Bytes class format = ByteArray format  												"True unless image is in 32bit V3 format"
		ifTrue: [ ByteArray adoptInstance: utf8Bytes ]
		ifFalse: [ utf8Bytes _ ByteArray withAll: utf8Bytes ].
	^ (stringClass fromUtf8: utf8Bytes) fixLineEndings.! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/3/2022 16:37:12' prior: 16809753!
                    scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value. Determine
	width of each character from xTable, indexed by map.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	sourceString from: startIndex to: stopIndex do: [ :char |
		"stops are only defined for the first 256 characters.
		For Character like objects beyond those in ISO-8859-15,
		#iso8859s15Code shound answer nil!!"
		char iso8859s15Code ifNotNil: [ :code |
			(stops at: code + 1) ifNotNil: [ :stop | ^stop ]].
		nextDestX _ destX + (font widthOf: char).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
		destX _ nextDestX.
		lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !

String class removeSelector: #fromUtf8:hex:!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5135-UTF8-Tweaks-JuanVuletich-2022May03-16h55m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5135] on 5 May 2022 at 9:32:49 am'!
!Character class methodsFor: 'converting' stamp: 'jmv 5/5/2022 09:31:43'!
           utf8BytesAndCodePointAt: byteIndex in: utf8ByteArray into: bytesBlock into: codePointBlock
	"Find next UTF-8 encoded code point in utf8ByteArray starting at byte byteIndex.
	Evalueate bytesBlock (if not nil). Arguments are utf8 bytes for the codePoint found.
	Evaluate codePointBlock (if not nil) with codePoint found as argument.
	Answer the number of bytes that comprised this codePoint.
	If there is an invalid UTF-8 sequence, skip it. Also skip codePoint U+FEFF (BOM, unneededly added by Win clipboard).
	But in any case, answer the number of bytes of the invalid sequence, to allow senders to update an index in an iteration.
	See senders."

	| n byte1 byte2 byte3 byte4 codePoint |
	n _ 0.
	byte1 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	byte1 < 128 ifTrue: [	"single byte"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: nil value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: byte1 ].
		^ n ].
	
	"At least 2 bytes"
	byte2 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63).
			codePointBlock value: codePoint ].
		^n ].
	
	"At least 3 bytes"
	byte3 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
		codePoint = 16rFEFF ifTrue: [ ^n ].
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: codePoint ].
		^n ].

	"4 bytes"
	byte4 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: byte4 ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12)
					+ ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63).
			codePointBlock value: codePoint ].
		].
	^n! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/5/2022 09:32:15' prior: 50348967!
                           nextCodePointBytesFromUtf8: anUtf8Stream into: aBlock
	"anUtf8Stream can be over a ByteArray.
	See senders."
"Note: This method will be removed. Prefer
#utf8BytesAndCodePointAt:in:into:into:
"
	| byte1 byte2 byte3 byte4 |
	byte1 _ anUtf8Stream next.
	byte1 < 128 ifTrue: [	"single byte"
		^ aBlock value: byte1 value: nil value: nil value: nil ].
	
	"At least 2 bytes"
	byte2 _ anUtf8Stream next.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		^ aBlock value: byte1 value: byte2 value: nil value: nil ].
	
	"At least 3 bytes"
	byte3 _ anUtf8Stream next.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: nil ].

	"4 bytes"
	byte4 _ anUtf8Stream next.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [^nil]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		^ aBlock value: byte1 value: byte2 value: byte3 value: byte4 ].

	^nil! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/5/2022 09:32:19' prior: 50349003!
                        nextUnicodeCodePointFromUtf8: anUtf8Stream
	"anUtf8Stream can be over a ByteArray
	Answer nil if conversion not possible, because of invalid UTF-8.
	Also answer nil for codePoint U+FEFF (BOM, unneededly added by Win clipboard)"
"Note: This method will be removed. Prefer
#utf8BytesAndCodePointAt:in:into:into:
"
	^ self
		nextCodePointBytesFromUtf8: anUtf8Stream
		into: [ :byte1 :byte2 :byte3 :byte4 |
			byte4 notNil
				ifTrue: [ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12) + ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63) ]
				ifFalse: [
					byte3 notNil
						ifTrue: [ | codePoint |
							codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
							codePoint = 16rFEFF
								ifFalse: [ codePoint ]
								ifTrue: [ nil ]]
						ifFalse: [
							byte2 notNil
								ifTrue: [ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ]
								ifFalse: [ byte1 ]]]]! !
!Character class methodsFor: 'converting' stamp: 'jmv 5/5/2022 09:31:56' prior: 50349036!
  unicodeCodePointOfUtf8Bytes: aByteArray

	Character utf8BytesAndCodePointAt: 1 in: aByteArray
				into: nil
				into: [ :codePoint | ^ codePoint ].! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 09:32:01' prior: 50349044!
           fromUtf8: aByteArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-8 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf8:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					"Add just one char if possible, or the apropriate sequence for the NCR"
					self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
			byteIndex _ byteIndex + n
		].
		(doTrimLastNullChar and: [ aByteArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 09:32:05' prior: 50349086!
                            utf32FromUtf8: aByteArray
	"Convert the given string from UTF-8 to UTF-32"

	^WordArray streamContents: [ :strm | | s byteIndex n |
		s _ aByteArray size.
		byteIndex _ 1.
		[  byteIndex <= s ] whileTrue: [
			n _ Character utf8BytesAndCodePointAt: byteIndex in: aByteArray
				into: nil
				into: [ :codePoint |
					strm nextPut: codePoint ].
			byteIndex _ byteIndex + n
		]].! !

Character class removeSelector: #utfBytesAndCodePointAt:in:into:into:!

!methodRemoval: Character class #utfBytesAndCodePointAt:in:into:into: stamp: 'Install-5136-TypoFix-JuanVuletich-2022May05-09h31m-jmv.001.cs.st 5/16/2022 10:22:25'!
utfBytesAndCodePointAt: byteIndex in: utf8ByteArray into: bytesBlock into: codePointBlock
	"Find next UTF-8 encoded code point in utf8ByteArray starting at byte byteIndex.
	Evalueate bytesBlock (if not nil). Arguments are utf8 bytes for the codePoint found.
	Evaluate codePointBlock (if not nil) with codePoint found as argument.
	Answer the number of bytes that comprised this codePoint.
	If there is an invalid UTF-8 sequence, skip it. Also skip codePoint U+FEFF (BOM, unneededly added by Win clipboard).
	But in any case, answer the number of bytes of the invalid sequence, to allow senders to update an index in an iteration.
	See senders."

	| n byte1 byte2 byte3 byte4 codePoint |
	n _ 0.
	byte1 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	byte1 < 128 ifTrue: [	"single byte"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: nil value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: byte1 ].
		^ n ].
	
	"At least 2 bytes"
	byte2 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: nil value: nil ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63).
			codePointBlock value: codePoint ].
		^n ].
	
	"At least 3 bytes"
	byte3 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"
		codePoint _  ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6) + (byte3 bitAnd: 63).
		codePoint = 16rFEFF ifTrue: [ ^n ].
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: nil ].
		codePointBlock ifNotNil: [
			codePointBlock value: codePoint ].
		^n ].

	"4 bytes"
	byte4 _ utf8ByteArray at: byteIndex + n.
	n _ n + 1.
	(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ ^n]. "invalid UTF-8"
	(byte1 bitAnd: 16rF8) = 240 ifTrue: [  "four bytes"
		bytesBlock ifNotNil: [
			bytesBlock value: byte1 value: byte2 value: byte3 value: byte4 ].
		codePointBlock ifNotNil: [
			codePoint _ ((byte1 bitAnd: 16r7) bitShift: 18) + ((byte2 bitAnd: 63) bitShift: 12)
					+ ((byte3 bitAnd: 63) bitShift: 6) + (byte4 bitAnd: 63).
			codePointBlock value: codePoint ].
		].
	^n!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5136-TypoFix-JuanVuletich-2022May05-09h31m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5136] on 5 May 2022 at 12:16:17 pm'!
!String methodsFor: 'converting' stamp: 'jmv 5/4/2022 17:38:46'!
               asUtf32
	"Convert the given string to UTF-32 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a WordArray.
	
	See #fromUtf32: "

	^self asUtf32: true.! !
!String methodsFor: 'converting' stamp: 'jmv 5/4/2022 17:38:55'!
                        asUtf32: convertEmbeddedNCRs
	"Convert the given string to UTF-32 from the internal encoding: ISO Latin 9 (ISO 8859-15)
	Answer a WordArray.
	
	If convertEmbeddedNCRs, then convert embedded NCRs such as '&#956;' (decimal) or '&#x03BC;' (hex) to CodePoints.
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	
	
	Note: The conversion of NCRs is reversible. See #fromUtf8:hex:trimLastNull:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it.

Copy the following and paste in your external text editor
&#913;&#945; 	Alpha 	
&#914;&#946; 	Beta 	
&#915;&#947; 	Gamma 	
&#916;&#948; 	Delta 	
&#917;&#949; 	Epsilon 	
&#918;&#950; 	Zeta 	
&#919;&#951; 	Eta 	
&#920;&#952; 	Theta 	
&#921;&#953; 	Iota 	
&#922;&#954; 	Kappa 	
&#923;&#955; 	Lambda 	
&#924;&#956; 	Mu 	
&#925;&#957; 	Nu
&#926;&#958; 	Xi
&#927;&#959; 	Omicron
&#928;&#960; 	Pi
&#929;&#961; 	Rho
&#931;&#963;&#962; 	Sigma
&#932;&#964; 	Tau
&#933;&#965; 	Upsilon
&#934;&#966; 	Phi
&#935;&#967; 	Chi
&#936;&#968; 	Psi
&#937;&#969; 	Omega
&# 937;&# 969; 	Not a NCR, just regular ASCII chars!!
	"

	| str |
	^WordArray streamContents: [ :outStream | | inStream nextChar prevPos maybeUnicodeNCR ncrEnd codePoint |
		inStream _ self readStream.
		[ inStream atEnd ] whileFalse: [
			nextChar _ inStream next.
			(convertEmbeddedNCRs and: [ nextChar = $& ])
				ifTrue: [
					prevPos _ inStream position.
					ncrEnd _ 0.
					maybeUnicodeNCR _ inStream next: 9.
					(maybeUnicodeNCR notEmpty and: [ maybeUnicodeNCR first = $# ]) ifTrue: [
						ncrEnd _ maybeUnicodeNCR indexOf: $; ].
					ncrEnd = 0
						ifFalse: [
							maybeUnicodeNCR second = $x
								ifTrue: [
									str _ (maybeUnicodeNCR copyFrom: 3 to: ncrEnd) asUppercase.
									(str first isDigit or: [ str first asciiValue between: $A asciiValue and: $F asciiValue])
										ifTrue: [ codePoint _  ('16r', str) asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]
								ifFalse: [
									str _ maybeUnicodeNCR copyFrom: 2 to: ncrEnd.
									str first isDigit
										ifTrue: [ codePoint _  codePoint _ str asNumber ]
										ifFalse: [ ncrEnd _ 0 ]]].
					ncrEnd = 0
						ifTrue: [
							"Not an NCR after all. Just add the $& and continue from there"
							codePoint _ nextChar codePoint ].
					outStream nextPut: codePoint.
					inStream position: prevPos + ncrEnd ]
				ifFalse: [
					codePoint _ nextChar codePoint.
					outStream nextPut: codePoint ]]]! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:19:08'!
                           fromUtf32: aWordArray
	"Convert the given bytes from UTF-32 to  the internal encoding: ISO Latin 9 (ISO 8859-15).
	See #asUtf32 "
	"For any unicode chars not in ISO Latin 9 (ISO 8859-15), embed an NCR.
	See http://en.wikipedia.org/wiki/Numeric_character_reference"

	^self fromUtf32: aWordArray hex: false trimLastNull: false! !
!String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:18:46'!
         fromUtf32: aWordArray hex: useHexForNCRs trimLastNull: doTrimLastNullChar
	"Convert the given string from UTF-32 to  the internal encoding: ISO Latin 9 (ISO 8859-15)"
	"For unicode chars not in ISO Latin 9 (ISO 8859-15), embed Decimal NCRs or Hexadecimal NCRs according to useHex.
	
	See http://en.wikipedia.org/wiki/Numeric_character_reference
	See http://rishida.net/tools/conversion/. Tests prepared there.
	
	Note: The conversion of NCRs is reversible. See #asUtf32:
	This allows handling the full Unicode in Cuis tools, that can only display the Latin alphabet, by editing the NCRs.
	The conversions can be done when reading / saving files, or when pasting from Clipboard and storing back on it."

	^String streamContents: [ :strm |
		aWordArray do: [ :codePoint |
			"Add just one char if possible, or the apropriate sequence for the NCR"
			self addUnicodeCodePoint: codePoint to: strm hex: useHexForNCRs ].
		(doTrimLastNullChar and: [ aWordArray last = 0 ]) ifTrue: [
			strm position: strm position - 1 ]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5137-UTF32-support-JuanVuletich-2022May05-12h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5136] on 5 May 2022 at 12:17:29 pm'!
!String methodsFor: 'character scanner support' stamp: 'jmv 5/5/2022 11:14:55'!
                  scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX stopConditions: stops
	"Double dispatch."

	^ aCharacterScanner scanStringCharsFrom: startIndex to: stopIndex in: self rightX: rightX stopConditions: stops! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/5/2022 11:19:09'!
    scanStringCharsFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	sourceString from: startIndex to: stopIndex do: [ :char |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil)."
		(stops at: char numericValue + 1) ifNotNil: [ :stop | ^stop ].
		nextDestX _ destX + (font widthOf: char).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/5/2022 11:15:21' prior: 50349133!
                           scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	^sourceString scanCharactersFrom: startIndex to: stopIndex with: self rightX: rightX stopConditions: stops! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5138-DoubleDispatch-JuanVuletich-2022May05-12h16m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5138] on 6 May 2022 at 6:57:22 am'!

WordArray removeSelector: #at:put:!

!methodRemoval: WordArray #at:put: stamp: 'Install-5139-WordArrayCleanUp-LucianoEstebanNotarfrancesco-2022May06-06h56m-len.001.cs.st 5/16/2022 10:22:25'!
at: x put: y
	^super at: x put: y!

WordArray removeSelector: #basicAt:put:!

!methodRemoval: WordArray #basicAt:put: stamp: 'Install-5139-WordArrayCleanUp-LucianoEstebanNotarfrancesco-2022May06-06h56m-len.001.cs.st 5/16/2022 10:22:25'!
basicAt: x put: y
	^super basicAt: x put: y!

WordArray removeSelector: #at:!

!methodRemoval: WordArray #at: stamp: 'Install-5139-WordArrayCleanUp-LucianoEstebanNotarfrancesco-2022May06-06h56m-len.001.cs.st 5/16/2022 10:22:25'!
at: x
	^super at: x!

WordArray removeSelector: #basicAt:!

!methodRemoval: WordArray #basicAt: stamp: 'Install-5139-WordArrayCleanUp-LucianoEstebanNotarfrancesco-2022May06-06h56m-len.001.cs.st 5/16/2022 10:22:25'!
basicAt: index 
	^super basicAt: index !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5139-WordArrayCleanUp-LucianoEstebanNotarfrancesco-2022May06-06h56m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5139] on 6 May 2022 at 10:34:55 am'!
!Parser methodsFor: 'scanning' stamp: 'jmv 5/6/2022 10:34:02' prior: 50343635!
       transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a serie of immediately following vertical bars, up arrows and a binary selector.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain."

	| toMakeBinary |
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].

	"Note: Also include #binary, to allow stuff like #+| where a special character comes after after a regular binary operator character. "
	toMakeBinary _ #(binary verticalBar upArrow colon).
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here := here asPlainString.
	hereType := #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			here := here , token asPlainString.
			hereEnd := hereEnd + 1.
			self scanToken ].
	(tokenType == #binary and: [hereMark + here size = mark])
		ifTrue: [
			here := here asPlainString , token.
			hereType := #binary.
			hereEnd := hereEnd + token size.
			self scanToken ].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5140-ParserFix-JuanVuletich-2022May06-10h28m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5139] on 6 May 2022 at 10:51:54 am'!
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 5/6/2022 10:51:14' prior: 50341449!
                           scanBinary
	| c d |
	c := self currentChar.
	currentTokenSourcePosition := sourcePosition.
	currentToken := String with: c.
	d := self nextChar.
	((self isBinarySelectorCharacter: c) or: [c == $:]) ifFalse: [^currentToken].
	(c == $: and: [d == $=]) 
		ifTrue: [" := assignment"
			currentToken := currentToken , (String with: d).
			self nextChar.
			^currentToken].
	"|| empty temp declaration"
	"This makes || colorize as an invalid method definition.
	It is better to allow #|| as valid selector, and mark an empty temp declaration as invalid instead!!"
	"(c == $| and: [d == $|])
		ifTrue: [^currentToken]."
	c _ d.
	[
		d _ self peekChar.
		c == $-
			ifTrue: [ d isDigit not ]
			ifFalse: [ self isBinarySelectorCharacter: c ]
	]
		whileTrue: [
			currentToken _ currentToken copyWith: c.
			c _ self nextChar ].
	^currentToken! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5141-CodeColorizer-fix-JuanVuletich-2022May06-10h34m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5138] on 5 May 2022 at 5:02:49 pm'!
!Character methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:26:23' prior: 16808252!
    isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	^self isAlphaNumeric or: [ self  = $_ ]! !
!Character methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:26:27' prior: 16808260!
                            isValidStartOfIdentifiers
	"Can I be the first character of an identifier? (unary or keyword selector, or variable name)"

	^self isLetter or: [ self  = $_ ]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5142-CharacterTweaks-JuanVuletich-2022May05-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5145] on 9 May 2022 at 12:02:54 pm'!
!Preferences class methodsFor: 'fonts' stamp: 'jmv 5/9/2022 12:02:27' prior: 16915702!
           loadOnlyLatinGlyphData
	^ self
		valueOfFlag: #loadOnlyLatinGlyphData
		ifAbsent: [false]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5143-LoadAllTrueType-JuanVuletich-2022May09-12h00m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5143] on 10 May 2022 at 3:48:54 pm'!
!Clipboard methodsFor: 'private' stamp: 'jmv 5/10/2022 15:48:42' prior: 50349101!
             retrieveIdOrStringFromOS: stringClass
	"Use a specific content type if ExtendedClipboard is active.
	Otherwise, use regular clipboard primitives"
	| utf8Bytes |
	self extendedClipboardInterface ifNotNil: [ :interface |
		interface canStore ifTrue: [
			"Answer nil if no id was stored"
			^ interface retrieveId ]].

	utf8Bytes _ self primitiveClipboardString.

	"Clipboard primitives answer an empty string if there is no string in OS clipboard."
	utf8Bytes isEmpty ifTrue: [ ^nil ].

	"Abuse the fact that the VM provides an instance of String (although it contains UTF-8 bytes)"
	utf8Bytes _ utf8Bytes fixLineEndings.

	"Clipboard primitive answers an instance of String containing the UTF-8 bytes.
	If not pure ASCII, contents are invalid!! Convert it ASAP into a reasonable ByteArray."
	utf8Bytes class format = ByteArray format  												"True unless image is in 32bit V3 format"
		ifTrue: [ ByteArray adoptInstance: utf8Bytes ]
		ifFalse: [ utf8Bytes _ ByteArray withAll: utf8Bytes ].
	^ stringClass fromUtf8: utf8Bytes.! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5144-Clipboard-fix-JuanVuletich-2022May10-15h48m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5143] on 10 May 2022 at 3:48:38 pm'!

Object subclass: #StringUtf32
	instanceVariableNames: 'codePoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #StringUtf32 category: #'System-Text' stamp: 'Install-5145-UnicodeStrings-JuanVuletich-2022May10-15h44m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #StringUtf32
	instanceVariableNames: 'codePoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!StringUtf32 commentStamp: 'jmv 5/10/2022 15:47:34' prior: 0!
 String like objects handling Unicode code points, encoded as UTF-32 bytes.

Install VectorGraphics / TrueType support, and play with the class side demo methods.!

Object subclass: #StringUtf8
	instanceVariableNames: 'bytes count index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #StringUtf8 category: #'System-Text' stamp: 'Install-5145-UnicodeStrings-JuanVuletich-2022May10-15h44m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #StringUtf8
	instanceVariableNames: 'bytes count index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!StringUtf8 commentStamp: 'jmv 5/10/2022 15:47:45' prior: 0!
String like objects handling Unicode code points, encoded as UTF-8 bytes.

Install VectorGraphics / TrueType support, and play with the class side demo methods.!

Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #UnicodeCodePoint category: #'System-Text' stamp: 'Install-5145-UnicodeStrings-JuanVuletich-2022May10-15h44m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #UnicodeCodePoint
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!UnicodeCodePoint commentStamp: 'jmv 5/10/2022 15:48:21' prior: 0!
 An Unicode Code Point can behave in a somewhat similar way to a Character.!
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/5/2022 12:08:53'!
           scanStringUtf32From: startIndex to: stopIndex in: aStringUtf32 rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	aStringUtf32 words from: startIndex to: stopIndex do: [ :code |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil)."
		code < 256 ifTrue: [
			(stops at: code + 1) ifNotNil: [ :stop | ^stop ]].
		nextDestX _ destX + (font widthOfCodePoint: code).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/5/2022 12:08:06'!
                scanStringUtf8From: startIndex to: stopIndex in: aStringUtf8 rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	aStringUtf8 from: startIndex to: stopIndex doWithUtf8Bytes: [ :byte1 :byte2 :byte3 :byte4 |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil).
		It is OK to just use the first byte in UTF-8"
		(stops at: byte1 + 1) ifNotNil: [ :stop | ^stop ].
		nextDestX _ destX + (font widthOfUtf8Byte1: byte1 b2: byte2 b3: byte3 b4: byte4).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:23:16' overrides: 16901507!
                at: codePointIndex
	"Answer the UnicodeCodePoint at codePointIndex"

	^UnicodeCodePoint codePoint: (codePoints at: codePointIndex)! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:45:00'!
                     isLastLineSeparator
	"
	(StringUtf8 withBytes: #[64 65 66]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 10]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 13]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 12]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 194 133]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 168 ]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 169 ]) isLastLineSeparator
	"
	| s |
	s _ codePoints size.
	s = 0 ifTrue: [ ^false ].
	(#(10 13 12 16r0085 16r2028 16r2029) statePointsTo: 	(codePoints at: s)) ifTrue: [ ^true ].
	^false.
	! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:47:44'!
    isLastSeparator
"A few more are missing!!"
	"
	(StringUtf8 withBytes: #[64 65 66]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 32]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 9]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 10]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 13]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 12]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 194 133]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 168 ]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 169 ]) isLastSeparator
	"
	| s |
	s _ codePoints size.
	s = 0 ifTrue: [ ^false ].
	(#(32 9) statePointsTo: 	(codePoints at: s)) ifTrue: [ ^true ].
	self isLastLineSeparator ifTrue: [ ^true ].
	^false.
	! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:48:00' overrides: 16901663!
                     size
	^codePoints size! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 19:22:10'!
 words
	^codePoints! !
!StringUtf32 methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:28:47'!
     words: aWordArray
	codePoints _ aWordArray! !
!StringUtf32 methodsFor: 'copying' stamp: 'jmv 5/4/2022 19:22:55'!
               , aStringUtf32
	^StringUtf32 withWords: codePoints, aStringUtf32 words.! !
!StringUtf32 methodsFor: 'copying' stamp: 'jmv 5/4/2022 15:34:58'!
                  copyFrom: startIndex to: endIndex 
	"Answer a copy of the receiver that contains elements from position
	startIndex to endIndex."
	
	^StringUtf32 withWords:
		(codePoints
			copyFrom: startIndex
			to: endIndex)! !
!StringUtf32 methodsFor: 'copying' stamp: 'jmv 5/4/2022 17:29:35'!
      copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| epilogFirstIndex prologLastIndex |
	prologLastIndex _ startIndex-1.
	epilogFirstIndex _ endIndex+1.
	^StringUtf32 withWords:
		(codePoints copyFrom: 1 to: prologLastIndex),
		replacement asUtf32,
		(codePoints
			copyFrom: epilogFirstIndex
			to: codePoints size)! !
!StringUtf32 methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:34:05' overrides: 16901772!
                              = aStringUtf32
	"Answer whether the receiver sorts equally as aStringUtf32.
	This means same characters in same order."

	"Any object is equal to itself"
	self == aStringUtf32 ifTrue: [ ^ true ].

	"If argument is not a aStringUtf32, maybe it is a Text?"
	aStringUtf32 class == StringUtf32 ifFalse: [
		(aStringUtf32 is: #Text) ifTrue: [ ^ self = aStringUtf32 string ].
		^ false].

	self size = aStringUtf32 size ifFalse: [
		^false ].
	
	self size > 256 ifTrue: [
		codePoints hashQuick = aStringUtf32 words hashQuick ifFalse: [ ^false ]].

	^ codePoints = aStringUtf32 words! !
!StringUtf32 methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:36:15' overrides: 16901788!
  hash
	"Hash is reimplemented because = is implemented."

	^codePoints hash! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:16'!
            asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8: self asUtf8! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/4/2022 19:06:03'!
                  asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:46' overrides: 16901837!
                    asString
	"Answer the receiver itself."
	^self! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/4/2022 15:19:36'!
        asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:28'!
         asUtf32
	"Answer a WordArray."

	^codePoints! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:07:15'!
          asUtf32: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a WordArray."

	^codePoints! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:03:25'!
     asUtf8
	"Answer a ByteArray."

	^String utf8FromUtf32: codePoints! !
!StringUtf32 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:03'!
                     asUtf8: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a ByteArray."

	^self asUtf8! !
!StringUtf32 methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 11:25:41'!
    from: start to: stop do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	start to: stop do: [ :index | aBlock value: (self at: index) ].! !
!StringUtf32 methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:28:36' overrides: 16903326!
                            is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol! !
!StringUtf32 methodsFor: 'testing' stamp: 'jmv 5/4/2022 15:19:54'!
                    isEmpty
	^codePoints isEmpty! !
!StringUtf32 methodsFor: 'testing' stamp: 'jmv 5/4/2022 15:19:36' overrides: 50347215!
         isStringLike

	^true! !
!StringUtf32 methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:56:56'!
                           encompassLine: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| left rightCr rightNull |
	left _ (codePoints lastIndexOf: `Character newLineCharacter numericValue` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr _ (codePoints indexOf: `Character newLineCharacter numericValue` startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	rightNull _ (codePoints indexOf: 0 startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	^left to: (rightCr min: rightNull)! !
!StringUtf32 methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 15:32:57'!
               encompassParagraph: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| left rightCr rightNull |
	left _ (codePoints lastIndexOf: `Character newLineCharacter numericValue` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr _ (codePoints indexOf: `Character newLineCharacter numericValue` startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size]).
	rightNull _ (codePoints indexOf: 0 startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	^left to: (rightCr min: rightNull)! !
!StringUtf32 methodsFor: 'character scanner support' stamp: 'jmv 5/5/2022 11:13:45'!
scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX stopConditions: stops
	"Double dispatch."

	^ aCharacterScanner scanStringUtf32From: startIndex to: stopIndex in: self rightX: rightX stopConditions: stops! !
!StringUtf32 methodsFor: 'as yet unclassified' stamp: 'jmv 5/10/2022 15:43:00' overrides: 50337880!
         doesNotUnderstand: aMessage

	{ 'StringUtf32 does not understand: '. aMessage} print! !
!StringUtf32 class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:19:26'!
                     fromUtf32: words

	^self withWords: words! !
!StringUtf32 class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:15:48'!
fromUtf8: aByteArray

	^self withWords: (String utf32FromUtf8: aByteArray).! !
!StringUtf32 class methodsFor: 'instance creation' stamp: 'jmv 5/4/2022 17:19:49'!
                              with: aCharacter 
	"Answer a new instance of me, containing utf bytes for aCharacter.
	StringUtf32 with: $a
	StringUtf32 with: $·
	StringUtf32 with: Character euro
	"
	^self withWords: (WordArray with: aCharacter codePoint).! !
!StringUtf32 class methodsFor: 'instance creation' stamp: 'jmv 5/4/2022 17:19:31'!
         with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter.
	StringUtf32 with: $a
	StringUtf32 with: $· with: Character euro
	"
	^self withWords: (WordArray with: aCharacter codePoint with: otherCharacter codePoint).! !
!StringUtf32 class methodsFor: 'instance creation' stamp: 'jmv 5/4/2022 15:49:33'!
   withWords: aWordArray
	^self new words: aWordArray ! !
!StringUtf8 methodsFor: 'accessing' stamp: 'jmv 5/6/2022 18:48:36' overrides: 16901507!
                 at: codePointIndex
	"Answer the UnicodeCodePoint at code point index codePointIndex (not a byte index!!)"

	| byteIndex |
	self boundsCheck: codePointIndex.
	self isAscii ifTrue: [ ^ UnicodeCodePoint codePoint: (bytes at: codePointIndex) ].
	byteIndex _ self byteIndexAt: codePointIndex.
	Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
		^UnicodeCodePoint codePoint: codePoint ].! !
!StringUtf8 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 19:22:50'!
                      bytes
	^bytes! !
!StringUtf8 methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:23:51'!
           bytes: aByteArray
	bytes _ aByteArray! !
!StringUtf8 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:46:34'!
                   isLastLineSeparator
	"
	(StringUtf8 withBytes: #[64 65 66]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 10]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 13]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 12]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 194 133]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 168 ]) isLastLineSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 169 ]) isLastLineSeparator
	"
	| s butButLastByte butLastByte lastByte |
	s _ bytes size.
	s = 0 ifTrue: [ ^false ].
	(#(10 13 12) statePointsTo: 	(bytes at: s)) ifTrue: [ ^true ].
	s = 1 ifTrue: [ ^false ].
	lastByte _ bytes at: s.
	butLastByte _ bytes at: s-1.
	(butLastByte = 16rC2 and: [ lastByte = 16r85 ]) ifTrue: [ ^true ]. "Next Line, NEL"
	s = 2 ifTrue: [ ^false ].
	butButLastByte _ bytes at: s-2.
	(butButLastByte = 16rE2 and: [butLastByte = 16r80 and: [ "Line Separator and Paragraph Separator"
		lastByte = 16rA8 or: [lastByte = 16rA9]]]) ifTrue: [ ^true ].
	^false.
	! !
!StringUtf8 methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:46:58'!
                             isLastSeparator
"A few more are missing!!"
	"
	(StringUtf8 withBytes: #[64 65 66]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 32]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 9]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 10]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 13]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 12]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 194 133]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 168 ]) isLastSeparator
	(StringUtf8 withBytes: #[64 65 66 226 128 169 ]) isLastSeparator
	"
	| s |
	s _ bytes size.
	s = 0 ifTrue: [ ^false ].
	(#(32 9) statePointsTo: 	(bytes at: s)) ifTrue: [ ^true ].
	self isLastLineSeparator ifTrue: [ ^true ].
	^false.
	! !
!StringUtf8 methodsFor: 'accessing' stamp: 'svc 5/5/2022 15:51:50' overrides: 16901663!
size
	"Return how many characters I contain"
	
	self isEmpty ifTrue: [ ^ 0 ].
	count ifNil: [ self computeCountAndIndex ].
	^ count! !
!StringUtf8 methodsFor: 'copying' stamp: 'jmv 5/4/2022 19:22:52'!
                       , aStringUtf8
	^StringUtf8 withBytes: bytes, aStringUtf8 bytes.! !
!StringUtf8 methodsFor: 'copying' stamp: 'svc 5/5/2022 16:25:23'!
                           copyFrom: startIndex to: stopIndex
	"Return a new string, a copy of me from startIndex to stopIndex, both character indices.
	Signal SubscriptOutOfBounds or CollectionIsEmpty in case of illegal indices."
	
	| startByteIndex stopByteIndex substring |
	startIndex = (self size+1) ifTrue: [ ^StringUtf8 empty ].
	stopIndex = 0 ifTrue: [ ^StringUtf8 empty ].
	self boundsCheck: startIndex. 
	self boundsCheck: stopIndex. 
	startByteIndex := self byteIndexAt: startIndex.
	stopByteIndex := self byteIndexAt: stopIndex.
	stopByteIndex := stopByteIndex + (self encodedByteCountAt: stopByteIndex) - 1.
	substring := StringUtf8 withBytes: (bytes copyFrom: startByteIndex to: stopByteIndex).
	self isAscii ifTrue: [ substring beAscii ].
	^ substring! !
!StringUtf8 methodsFor: 'copying' stamp: 'jmv 5/5/2022 16:57:30'!
                       copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| epilogFirstIndex prologLastIndex |
	prologLastIndex _ (self byteIndexAt: startIndex)-1.
	epilogFirstIndex _ self byteIndexAt: endIndex+1.
	^StringUtf8 withBytes:
		(bytes copyFrom: 1 to: prologLastIndex),
		replacement asUtf8,
		(bytes
			copyFrom: epilogFirstIndex
			to: bytes size)! !
!StringUtf8 methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:35:30' overrides: 16901772!
          = aStringUtf8
	"Answer whether the receiver sorts equally as aStringUtf8.
	This means same characters in same order."

	"Any object is equal to itself"
	self == aStringUtf8 ifTrue: [ ^ true ].

	"If argument is not a aStringUtf32, maybe it is a Text?"
	aStringUtf8 class == StringUtf8 ifFalse: [
		(aStringUtf8 is: #Text) ifTrue: [ ^ self = aStringUtf8 string ].
		^ false].

	bytes size = aStringUtf8 bytes size ifFalse: [
		^false ].
	
	bytes size > 256 ifTrue: [
		bytes hashQuick = aStringUtf8 bytes hashQuick ifFalse: [ ^false ]].

	^ bytes = aStringUtf8 bytes! !
!StringUtf8 methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:38:57' overrides: 16901788!
               hash
	"Hash is reimplemented because = is implemented."

	^bytes hash! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:03'!
                  asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8: bytes! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/4/2022 19:06:11'!
                         asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:44' overrides: 16901837!
                     asString
	"Answer the receiver itself."
	^self! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 3/13/2022 18:50:31'!
        asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:39'!
          asUtf32
	"Answer a WordArray."

	^String utf32FromUtf8: bytes! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:07:29'!
                          asUtf32: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a WordArray."

	^self asUtf32! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:03:32'!
    asUtf8
	"Answer a ByteArray."

	^bytes! !
!StringUtf8 methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:10'!
                 asUtf8: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-8 doesn't need them after all.
	Answer a ByteArray."

	^bytes! !
!StringUtf8 methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 16:57:33'!
            from: startIndex to: stopIndex do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex n cpIndex |
	byteIndex _ self byteIndexAt: startIndex.
	cpIndex _ startIndex.
	[ cpIndex <= stopIndex ] whileTrue: [
		n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (UnicodeCodePoint codePoint: codePoint).
			cpIndex _ cpIndex + 1 ].
		byteIndex _ byteIndex + n ].! !
!StringUtf8 methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 16:57:37'!
                 from: startIndex to: stopIndex doWithUtf8Bytes: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex n stopByteIndex |
	byteIndex _ self byteIndexAt: startIndex.
	stopByteIndex _ self byteIndexAt: stopIndex.
	[ byteIndex <= stopByteIndex ] whileTrue: [
		n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: aBlock into: nil.
		byteIndex _ byteIndex + n ].! !
!StringUtf8 methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:28:32' overrides: 16903326!
              is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol! !
!StringUtf8 methodsFor: 'testing' stamp: 'svc 5/5/2022 16:12:43'!
                     isAscii
	"Return true when I am pure 7-bit ASCII, which means each character is encoded as one byte."

	count ifNil: [ self computeCountAndIndex ].
	^ bytes size = count! !
!StringUtf8 methodsFor: 'testing' stamp: 'jmv 5/3/2022 12:12:52'!
                 isEmpty
	^bytes isEmpty! !
!StringUtf8 methodsFor: 'testing' stamp: 'jmv 4/29/2022 11:35:03' overrides: 50347215!
              isStringLike

	^true! !
!StringUtf8 methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:57:00'!
                            encompassLine: anCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte rightNullByte |
	argumentLeftByte _ self byteIndexAt: anCodePointInterval first.
	argumentRightByte _ self byteIndexAt: anCodePointInterval last.
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent:[0]) + 1.
	rightCrByte _ (bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	rightNullByte _ (bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	^(self codePointIndexAt: leftByte) to: (self codePointIndexAt: (rightCrByte min: rightNullByte))! !
!StringUtf8 methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:57:40'!
 encompassParagraph: anCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte rightNullByte |
	argumentLeftByte _ self byteIndexAt: anCodePointInterval first.
	argumentRightByte _ self byteIndexAt: anCodePointInterval last.
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent:[0]) + 1.
	rightCrByte _ (bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size]).
	rightNullByte _ (bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	^(self codePointIndexAt: leftByte) to: (self codePointIndexAt: (rightCrByte min: rightNullByte))! !
!StringUtf8 methodsFor: 'character scanner support' stamp: 'jmv 5/5/2022 11:13:55'!
                  scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX stopConditions: stops
	"Double dispatch."

	^ aCharacterScanner scanStringUtf8From: startIndex to: stopIndex in: self rightX: rightX stopConditions: stops! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:53:18'!
            beAscii
	"Mark me as being pure 7-bit ASCII, which means each character is encoded as one byte"
	
	count := bytes size.
	index := #().! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 16:04:35'!
                    boundsCheck: codePointIndex
	(codePointIndex between: 1 and: self size) 
		ifFalse: [ self errorSubscriptBounds: codePointIndex ]! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 16:25:57'!
                         byteIndexAt: codePointIndex
	| byteIndex |
	self isAscii ifTrue: [ ^ codePointIndex ].
	codePointIndex = (self size+1) ifTrue: [
		"The position a hypotetical extra code point would start at.
		Useful to find the last byte position for some codePointIndex. See senders."
		^bytes size+1 ].
	byteIndex := codePointIndex > self stride
		ifTrue: [
			index at: codePointIndex - 1 // self stride ]
		ifFalse: [ 1 ].
	codePointIndex - 1 \\ self stride timesRepeat: [ 
		byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ].
	^ byteIndex! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 16:46:33'!
                            codePointIndexAt: byteIndex
	| codePointIndex byteCursor |
	self isAscii ifTrue: [ ^ byteIndex ].
	codePointIndex := byteCursor := 1.
	index ifNil: [ self computeCountAndIndex ].
	index ifNotEmpty: [  
		index 
			findBinaryIndex: [ :x | byteIndex - x ] 
			do: [ :found | ^ (found * self stride) + 1 ] 
			ifNone: [ :lower :upper |
				lower = 0 
			 		ifFalse: [ 
						byteCursor := index at: lower. 
						codePointIndex := (lower * self stride) + 1 ] ] ].
	[ byteCursor <= bytes size ] whileTrue: [
		byteCursor = byteIndex 
			ifTrue: [ ^ codePointIndex ].
		byteCursor := byteCursor + (self encodedByteCountAt: byteCursor).
		codePointIndex := codePointIndex + 1 ].
	^ 0! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:45:39'!
                     computeCountAndIndex
	self isEmpty ifTrue: [ count := 0. ^ self ].
	"the number of characters cannot be larger than the byte size"
	bytes size <= self stride
		ifTrue: [ self computeCountNoIndex ]
		ifFalse: [ self computeCountAndIndexFull ]! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:46:55'!
         computeCountAndIndexFull
	count := 0.
	index := Array streamContents: [ :out | | byteIndex |
		byteIndex := 1.
		[ byteIndex <= bytes size ] whileTrue: [
			count := count + 1.
			(count > self stride and: [ (count - 1 \\ self stride) = 0 ]) 
				ifTrue: [ out nextPut: byteIndex ].
			byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ] ]! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:46:18'!
                           computeCountNoIndex
	| byteIndex |
	count := 0.
	index := #().
	byteIndex := 1.
	[ byteIndex <= bytes size ] whileTrue: [
		count := count + 1.
		byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ]! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:50:23'!
         encodedByteCountAt: byteIndex
	| byte |
	(byte := bytes at: byteIndex) < 128 ifTrue: [ ^ 1 ].
	(byte bitAnd: 2r11100000) = 2r11000000 ifTrue: [ ^ 2 ].
	(byte bitAnd: 2r11110000) = 2r11100000 ifTrue: [ ^ 3 ].
	(byte bitAnd: 2r11111000) = 2r11110000 ifTrue: [ ^ 4 ].
	self error: 'IllegalLeadingByte '! !
!StringUtf8 methodsFor: 'private' stamp: 'svc 5/5/2022 15:45:54'!
               stride
	"Return the stride, the constant I use internally to build my index"
	
	^ 32! !
!StringUtf8 methodsFor: 'as yet unclassified' stamp: 'jmv 5/10/2022 15:43:04' overrides: 50337880!
     doesNotUnderstand: aMessage

	{ 'StringUtf8 does not understand: '. aMessage} print! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'svc 5/5/2022 16:25:07'!
                       empty
	"Return the empty StringUtf8 instance.
	Since my instances are readonly, this could be cached."

	^ (self withBytes: #[]) beAscii; yourself! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:16:43'!
                        fromUtf32: aWordArray

	^self withBytes: (String utf8FromUtf32: aWordArray).! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:19:21'!
                              fromUtf8: bytes

	^self withBytes: bytes! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'jmv 4/29/2022 15:04:19'!
 with: aCharacter 
	"Answer a new instance of me, containing utf bytes for aCharacter.
	StringUtf8 with: $a
	StringUtf8 with: $·
	StringUtf8 with: Character euro
	"
	^self withBytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint).! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'jmv 4/29/2022 15:04:23'!
                     with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter.
	StringUtf8 with: $a
	StringUtf8 with: $· with: Character euro
	"
	^self withBytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint),
		(Character utf8BytesOfUnicodeCodePoint: otherCharacter codePoint).! !
!StringUtf8 class methodsFor: 'instance creation' stamp: 'jmv 5/3/2022 12:10:29'!
         withBytes: aByteArray
	^self new bytes: aByteArray ! !
!UnicodeCodePoint methodsFor: 'accessing' stamp: 'jmv 5/5/2022 15:20:14'!
                               codePoint
	^value! !
!UnicodeCodePoint methodsFor: 'accessing' stamp: 'jmv 5/4/2022 16:54:26'!
 codePoint: aNumber
	value _ aNumber! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:28:25' overrides: 16903326!
                             is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:24:25'!
               isAlphaNumeric
	"Answer whether the receiver is a letter or a digit."
	^self isLetter or: [self isDigit]! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:21:35'!
            isDigit
	"Answer whether the receiver is a digit."

	^ value between: 48 and: 57! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:23:34'!
    isLetter
	"Answer whether the receiver is a letter."
self flag: #unicodeNeedsImprovement.
	(Character codePoint: value) ifNotNil: [ :ch | ^ch isLetter ].
	^false! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 16:59:07'!
                   isLineSeparator
	"Answer whether the receiver is a line separator character:
	line feed, cr, or form feed."

	^ #(10 13 12) statePointsTo: value! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 16:59:12'!
    isSeparator
	"Answer whether the receiver is one of the separator characters
	space, tab, lf, cr, or form feed."

	^ #(32 9 10 13 12) statePointsTo: value! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:25:12'!
                          isValidInIdentifiers
	"Can I be part of an identifier? (unary or keyword selector, or variable name)"

	^self isAlphaNumeric or: [ $_ numericValue = value ]! !
!UnicodeCodePoint methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:25:50'!
                        isValidStartOfIdentifiers
	"Can I be the first character of an identifier? (unary or keyword selector, or variable name)"

	^self isLetter or: [ $_ numericValue = value ]! !
!UnicodeCodePoint methodsFor: 'as yet unclassified' stamp: 'jmv 5/10/2022 15:43:13' overrides: 50337880!
         doesNotUnderstand: aMessage

	{ 'UnicodeCodePoint does not understand: '. aMessage} print! !
!UnicodeCodePoint class methodsFor: 'instance creation' stamp: 'jmv 5/4/2022 16:53:51'!
           codePoint: aNumber
	^self new codePoint: aNumber! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5145-UnicodeStrings-JuanVuletich-2022May10-15h44m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5145] on 11 May 2022 at 10:34:39 am'!

Object subclass: #Utf32String
	instanceVariableNames: 'codePoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf32String category: #'System-Text' stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #Utf32String
	instanceVariableNames: 'codePoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!Utf32String commentStamp: 'jmv 5/10/2022 15:47:34' prior: 0!
              String like objects handling Unicode code points, encoded as UTF-32 bytes.

Install VectorGraphics / TrueType support, and play with the class side demo methods.!

Object subclass: #Utf8String
	instanceVariableNames: 'bytes count index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

!classDefinition: #Utf8String category: #'System-Text' stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #Utf8String
	instanceVariableNames: 'bytes count index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!
!Utf8String commentStamp: 'jmv 5/10/2022 15:47:45' prior: 0!
                         String like objects handling Unicode code points, encoded as UTF-8 bytes.

Install VectorGraphics / TrueType support, and play with the class side demo methods.!
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:23:16' overrides: 16901507!
     at: codePointIndex
	"Answer the UnicodeCodePoint at codePointIndex"

	^UnicodeCodePoint codePoint: (codePoints at: codePointIndex)! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/11/2022 10:10:53'!
                    isLastLineSeparator
	"
	(Utf32String withBytes: #[64 65 66]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 10]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 13]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 12]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 194 133]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 226 128 168 ]) isLastLineSeparator
	(Utf32String withBytes: #[64 65 66 226 128 169 ]) isLastLineSeparator
	"
	| s |
	s _ codePoints size.
	s = 0 ifTrue: [ ^false ].
	(#(10 13 12 16r0085 16r2028 16r2029) statePointsTo: 	(codePoints at: s)) ifTrue: [ ^true ].
	^false.
	! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/11/2022 10:11:11'!
                            isLastSeparator
"A few more are missing!!"
	"
	(Utf32String withBytes: #[64 65 66]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 32]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 9]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 10]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 13]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 12]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 194 133]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 226 128 168 ]) isLastSeparator
	(Utf32String withBytes: #[64 65 66 226 128 169 ]) isLastSeparator
	"
	| s |
	s _ codePoints size.
	s = 0 ifTrue: [ ^false ].
	(#(32 9) statePointsTo: 	(codePoints at: s)) ifTrue: [ ^true ].
	self isLastLineSeparator ifTrue: [ ^true ].
	^false.
	! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/4/2022 15:48:00' overrides: 16901663!
            size
	^codePoints size! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/4/2022 19:22:10'!
 words
	^codePoints! !
!Utf32String methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:28:47'!
     words: aWordArray
	codePoints _ aWordArray! !
!Utf32String methodsFor: 'copying' stamp: 'jmv 5/11/2022 10:02:48'!
              , anUtf32String
	^Utf32String withWords: codePoints, anUtf32String words.! !
!Utf32String methodsFor: 'copying' stamp: 'jmv 5/11/2022 09:57:56'!
               copyFrom: startIndex to: endIndex 
	"Answer a copy of the receiver that contains elements from position
	startIndex to endIndex."
	
	^Utf32String withWords:
		(codePoints
			copyFrom: startIndex
			to: endIndex)! !
!Utf32String methodsFor: 'copying' stamp: 'jmv 5/11/2022 09:57:56'!
     copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| epilogFirstIndex prologLastIndex |
	prologLastIndex _ startIndex-1.
	epilogFirstIndex _ endIndex+1.
	^Utf32String withWords:
		(codePoints copyFrom: 1 to: prologLastIndex),
		replacement asUtf32,
		(codePoints
			copyFrom: epilogFirstIndex
			to: codePoints size)! !
!Utf32String methodsFor: 'comparing' stamp: 'jmv 5/11/2022 10:07:38' overrides: 16901772!
                             = anUtf32String
	"Answer whether the receiver sorts equally as anUtf32String.
	This means same characters in same order."

	"Any object is equal to itself"
	self == anUtf32String ifTrue: [ ^ true ].

	"If argument is not a anUtf32String, maybe it is a Text?"
	anUtf32String class == Utf32String ifFalse: [
		(anUtf32String is: #Text) ifTrue: [ ^ self = anUtf32String string ].
		^ false].

	self size = anUtf32String size ifFalse: [
		^false ].

	self size > 256 ifTrue: [
		codePoints hashQuick = anUtf32String words hashQuick ifFalse: [ ^false ]].

	^ codePoints = anUtf32String words! !
!Utf32String methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:36:15' overrides: 16901788!
                         hash
	"Hash is reimplemented because = is implemented."

	^codePoints hash! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:16'!
            asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8: self asUtf8! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/4/2022 19:06:03'!
                  asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:46' overrides: 16901837!
                    asString
	"Answer the receiver itself."
	^self! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/4/2022 15:19:36'!
        asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:28'!
         asUtf32
	"Answer a WordArray."

	^codePoints! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:07:15'!
          asUtf32: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a WordArray."

	^codePoints! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:03:25'!
     asUtf8
	"Answer a ByteArray."

	^String utf8FromUtf32: codePoints! !
!Utf32String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:03'!
                     asUtf8: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a ByteArray."

	^self asUtf8! !
!Utf32String methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 11:25:41'!
    from: start to: stop do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	start to: stop do: [ :index | aBlock value: (self at: index) ].! !
!Utf32String methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:28:36' overrides: 16903326!
                            is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol! !
!Utf32String methodsFor: 'testing' stamp: 'jmv 5/4/2022 15:19:54'!
                    isEmpty
	^codePoints isEmpty! !
!Utf32String methodsFor: 'testing' stamp: 'jmv 5/4/2022 15:19:36' overrides: 50347215!
         isStringLike

	^true! !
!Utf32String methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:56:56'!
                           encompassLine: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| left rightCr rightNull |
	left _ (codePoints lastIndexOf: `Character newLineCharacter numericValue` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr _ (codePoints indexOf: `Character newLineCharacter numericValue` startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	rightNull _ (codePoints indexOf: 0 startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	^left to: (rightCr min: rightNull)! !
!Utf32String methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 15:32:57'!
               encompassParagraph: anInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| left rightCr rightNull |
	left _ (codePoints lastIndexOf: `Character newLineCharacter numericValue` startingAt: anInterval first - 1 ifAbsent:[0]) + 1.
	rightCr _ (codePoints indexOf: `Character newLineCharacter numericValue` startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size]).
	rightNull _ (codePoints indexOf: 0 startingAt: (anInterval last max: anInterval first) ifAbsent: [codePoints size+1])-1.
	^left to: (rightCr min: rightNull)! !
!Utf32String methodsFor: 'character scanner support' stamp: 'jmv 5/11/2022 10:05:52'!
                               scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX stopConditions: stops
	"Double dispatch."

	^ aCharacterScanner scanUtf32StringFrom: startIndex to: stopIndex in: self rightX: rightX stopConditions: stops! !
!Utf32String methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:15:37'!
  edit

	self editLabel: 'UTF-32 Text Editor'! !
!Utf32String methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:20:28'!
      editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !
!Utf32String methodsFor: 'as yet unclassified' stamp: 'jmv 5/11/2022 10:05:22' overrides: 50337880!
              doesNotUnderstand: aMessage

	{ 'Utf32String does not understand: '. aMessage} print! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:19:26'!
                     fromUtf32: words

	^self withWords: words! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:15:48'!
fromUtf8: aByteArray

	^self withWords: (String utf32FromUtf8: aByteArray).! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/11/2022 10:06:15'!
                             with: aCharacter 
	"Answer a new instance of me, containing utf words for aCharacter.
	Utf32String with: $a
	Utf32String with: $·
	Utf32String with: Character euro
	"
	^self withWords: (WordArray with: aCharacter codePoint).! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/11/2022 10:06:33'!
        with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf words for aCharacter.
	Utf32String with: $a
	Utf32String with: $· with: Character euro
	"
	^self withWords: (WordArray with: aCharacter codePoint with: otherCharacter codePoint).! !
!Utf32String class methodsFor: 'instance creation' stamp: 'jmv 5/4/2022 15:49:33'!
   withWords: aWordArray
	^self new words: aWordArray ! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/6/2022 18:48:36' overrides: 16901507!
                 at: codePointIndex
	"Answer the UnicodeCodePoint at code point index codePointIndex (not a byte index!!)"

	| byteIndex |
	self boundsCheck: codePointIndex.
	self isAscii ifTrue: [ ^ UnicodeCodePoint codePoint: (bytes at: codePointIndex) ].
	byteIndex _ self byteIndexAt: codePointIndex.
	Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
		^UnicodeCodePoint codePoint: codePoint ].! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/4/2022 19:22:50'!
                      bytes
	^bytes! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/5/2022 10:23:51'!
           bytes: aByteArray
	bytes _ aByteArray! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/11/2022 10:10:20'!
                  isLastLineSeparator
	"
	(Utf8String withBytes: #[64 65 66]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 10]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 13]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 12]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 194 133]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 226 128 168 ]) isLastLineSeparator
	(Utf8String withBytes: #[64 65 66 226 128 169 ]) isLastLineSeparator
	"
	| s butButLastByte butLastByte lastByte |
	s _ bytes size.
	s = 0 ifTrue: [ ^false ].
	(#(10 13 12) statePointsTo: 	(bytes at: s)) ifTrue: [ ^true ].
	s = 1 ifTrue: [ ^false ].
	lastByte _ bytes at: s.
	butLastByte _ bytes at: s-1.
	(butLastByte = 16rC2 and: [ lastByte = 16r85 ]) ifTrue: [ ^true ]. "Next Line, NEL"
	s = 2 ifTrue: [ ^false ].
	butButLastByte _ bytes at: s-2.
	(butButLastByte = 16rE2 and: [butLastByte = 16r80 and: [ "Line Separator and Paragraph Separator"
		lastByte = 16rA8 or: [lastByte = 16rA9]]]) ifTrue: [ ^true ].
	^false.
	! !
!Utf8String methodsFor: 'accessing' stamp: 'jmv 5/11/2022 10:10:34'!
                            isLastSeparator
"A few more are missing!!"
	"
	(Utf8String withBytes: #[64 65 66]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 32]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 9]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 10]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 13]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 12]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 194 133]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 226 128 168 ]) isLastSeparator
	(Utf8String withBytes: #[64 65 66 226 128 169 ]) isLastSeparator
	"
	| s |
	s _ bytes size.
	s = 0 ifTrue: [ ^false ].
	(#(32 9) statePointsTo: 	(bytes at: s)) ifTrue: [ ^true ].
	self isLastLineSeparator ifTrue: [ ^true ].
	^false.
	! !
!Utf8String methodsFor: 'accessing' stamp: 'svc 5/5/2022 15:51:50' overrides: 16901663!
size
	"Return how many characters I contain"
	
	self isEmpty ifTrue: [ ^ 0 ].
	count ifNil: [ self computeCountAndIndex ].
	^ count! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 5/11/2022 10:07:03'!
                      , anUtf8String
	^Utf8String withBytes: bytes, anUtf8String bytes.! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 5/11/2022 09:58:18'!
                        copyFrom: startIndex to: stopIndex
	"Return a new string, a copy of me from startIndex to stopIndex, both character indices.
	Signal SubscriptOutOfBounds or CollectionIsEmpty in case of illegal indices."
	
	| startByteIndex stopByteIndex substring |
	startIndex = (self size+1) ifTrue: [ ^Utf8String empty ].
	stopIndex = 0 ifTrue: [ ^Utf8String empty ].
	self boundsCheck: startIndex. 
	self boundsCheck: stopIndex. 
	startByteIndex := self byteIndexAt: startIndex.
	stopByteIndex := self byteIndexAt: stopIndex.
	stopByteIndex := stopByteIndex + (self encodedByteCountAt: stopByteIndex) - 1.
	substring := Utf8String withBytes: (bytes copyFrom: startByteIndex to: stopByteIndex).
	self isAscii ifTrue: [ substring beAscii ].
	^ substring! !
!Utf8String methodsFor: 'copying' stamp: 'jmv 5/11/2022 09:58:18'!
                      copyReplaceFrom: startIndex to: endIndex with: replacement
	"Answer a copy of the receiver with replacementCollection's elements in
	place of the receiver's start'th to stop'th elements. This does not expect
	a 1-1 map from replacementCollection to the start to stop elements, so it
	will do an insert or append."

	| epilogFirstIndex prologLastIndex |
	prologLastIndex _ (self byteIndexAt: startIndex)-1.
	epilogFirstIndex _ self byteIndexAt: endIndex+1.
	^Utf8String withBytes:
		(bytes copyFrom: 1 to: prologLastIndex),
		replacement asUtf8,
		(bytes
			copyFrom: epilogFirstIndex
			to: bytes size)! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 5/11/2022 10:08:06' overrides: 16901772!
         = anUtf8String
	"Answer whether the receiver sorts equally as anUtf8String.
	This means same characters in same order."

	"Any object is equal to itself"
	self == anUtf8String ifTrue: [ ^ true ].

	"If argument is not a anUtf32String, maybe it is a Text?"
	anUtf8String class == Utf8String ifFalse: [
		(anUtf8String is: #Text) ifTrue: [ ^ self = anUtf8String string ].
		^ false].

	bytes size = anUtf8String bytes size ifFalse: [
		^false ].

	bytes size > 256 ifTrue: [
		bytes hashQuick = anUtf8String bytes hashQuick ifFalse: [ ^false ]].

	^ bytes = anUtf8String bytes! !
!Utf8String methodsFor: 'comparing' stamp: 'jmv 5/5/2022 10:38:57' overrides: 16901788!
      hash
	"Hash is reimplemented because = is implemented."

	^bytes hash! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:03'!
                  asByteString
	"Answer an instance of the Byte oriented String class"

	^String fromUtf8: bytes! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/4/2022 19:06:11'!
                         asPlainString
	"Answer the receiver itself.
	Not a Symbol, not a Text."
	^self! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/5/2022 10:13:44' overrides: 16901837!
                     asString
	"Answer the receiver itself."
	^self! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 3/13/2022 18:50:31'!
        asText
	"Answer a Text whose string is the receiver."
	^Text fromString: self! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:39'!
          asUtf32
	"Answer a WordArray."

	^String utf32FromUtf8: bytes! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:07:29'!
                          asUtf32: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-32 doesn't need them after all.
	Answer a WordArray."

	^self asUtf32! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:03:32'!
    asUtf8
	"Answer a ByteArray."

	^bytes! !
!Utf8String methodsFor: 'converting' stamp: 'jmv 5/6/2022 19:04:10'!
                 asUtf8: convertEmbeddedNCRs
	"Assume that only String will contain NCRs. UTF-8 doesn't need them after all.
	Answer a ByteArray."

	^bytes! !
!Utf8String methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 16:57:33'!
            from: startIndex to: stopIndex do: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex n cpIndex |
	byteIndex _ self byteIndexAt: startIndex.
	cpIndex _ startIndex.
	[ cpIndex <= stopIndex ] whileTrue: [
		n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: nil into: [ :codePoint |
			aBlock value: (UnicodeCodePoint codePoint: codePoint).
			cpIndex _ cpIndex + 1 ].
		byteIndex _ byteIndex + n ].! !
!Utf8String methodsFor: 'enumerating' stamp: 'jmv 5/5/2022 16:57:37'!
                 from: startIndex to: stopIndex doWithUtf8Bytes: aBlock
	"Evaluate aBlock for all elements between start and stop (inclusive)."

	| byteIndex n stopByteIndex |
	byteIndex _ self byteIndexAt: startIndex.
	stopByteIndex _ self byteIndexAt: stopIndex.
	[ byteIndex <= stopByteIndex ] whileTrue: [
		n _ Character utf8BytesAndCodePointAt: byteIndex in: bytes into: aBlock into: nil.
		byteIndex _ byteIndex + n ].! !
!Utf8String methodsFor: 'testing' stamp: 'jmv 5/5/2022 15:28:32' overrides: 16903326!
              is: aSymbol
{ #is: . self class. aSymbol} print.
	^ super is: aSymbol! !
!Utf8String methodsFor: 'testing' stamp: 'svc 5/5/2022 16:12:43'!
                     isAscii
	"Return true when I am pure 7-bit ASCII, which means each character is encoded as one byte."

	count ifNil: [ self computeCountAndIndex ].
	^ bytes size = count! !
!Utf8String methodsFor: 'testing' stamp: 'jmv 5/3/2022 12:12:52'!
                 isEmpty
	^bytes isEmpty! !
!Utf8String methodsFor: 'testing' stamp: 'jmv 4/29/2022 11:35:03' overrides: 50347215!
              isStringLike

	^true! !
!Utf8String methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:57:00'!
                            encompassLine: anCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends before a newLine (or eventually at self size)
	See also encompassParagraph:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte rightNullByte |
	argumentLeftByte _ self byteIndexAt: anCodePointInterval first.
	argumentRightByte _ self byteIndexAt: anCodePointInterval last.
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent:[0]) + 1.
	rightCrByte _ (bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	rightNullByte _ (bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	^(self codePointIndexAt: leftByte) to: (self codePointIndexAt: (rightCrByte min: rightNullByte))! !
!Utf8String methodsFor: 'paragraph support' stamp: 'jmv 5/5/2022 16:57:40'!
 encompassParagraph: anCodePointInterval
	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.
	Answer starts at the position following a newLine (or eventually 1) and ends at a newLine (or eventually at self size).
	Look also for null characters. Never include null characters in the answer.
	See also #encompassLine:"
	| argumentLeftByte argumentRightByte leftByte rightCrByte rightNullByte |
	argumentLeftByte _ self byteIndexAt: anCodePointInterval first.
	argumentRightByte _ self byteIndexAt: anCodePointInterval last.
	leftByte _ (bytes lastIndexOf: `Character newLineCharacter numericValue` startingAt: argumentLeftByte - 1 ifAbsent:[0]) + 1.
	rightCrByte _ (bytes indexOf: `Character newLineCharacter numericValue` startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size]).
	rightNullByte _ (bytes indexOf: 0 startingAt: (argumentRightByte max: argumentLeftByte) ifAbsent: [bytes size+1])-1.
	^(self codePointIndexAt: leftByte) to: (self codePointIndexAt: (rightCrByte min: rightNullByte))! !
!Utf8String methodsFor: 'character scanner support' stamp: 'jmv 5/11/2022 10:07:59'!
                 scanCharactersFrom: startIndex to: stopIndex with: aCharacterScanner rightX: rightX stopConditions: stops
	"Double dispatch."

	^ aCharacterScanner scanUtf8StringFrom: startIndex to: stopIndex in: self rightX: rightX stopConditions: stops! !
!Utf8String methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:16:02'!
    edit

	self editLabel: 'UTF-8 Text Editor'! !
!Utf8String methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:20:31'!
        editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:53:18'!
                beAscii
	"Mark me as being pure 7-bit ASCII, which means each character is encoded as one byte"
	
	count := bytes size.
	index := #().! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 16:04:35'!
                    boundsCheck: codePointIndex
	(codePointIndex between: 1 and: self size) 
		ifFalse: [ self errorSubscriptBounds: codePointIndex ]! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 16:25:57'!
                         byteIndexAt: codePointIndex
	| byteIndex |
	self isAscii ifTrue: [ ^ codePointIndex ].
	codePointIndex = (self size+1) ifTrue: [
		"The position a hypotetical extra code point would start at.
		Useful to find the last byte position for some codePointIndex. See senders."
		^bytes size+1 ].
	byteIndex := codePointIndex > self stride
		ifTrue: [
			index at: codePointIndex - 1 // self stride ]
		ifFalse: [ 1 ].
	codePointIndex - 1 \\ self stride timesRepeat: [ 
		byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ].
	^ byteIndex! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 16:46:33'!
                            codePointIndexAt: byteIndex
	| codePointIndex byteCursor |
	self isAscii ifTrue: [ ^ byteIndex ].
	codePointIndex := byteCursor := 1.
	index ifNil: [ self computeCountAndIndex ].
	index ifNotEmpty: [  
		index 
			findBinaryIndex: [ :x | byteIndex - x ] 
			do: [ :found | ^ (found * self stride) + 1 ] 
			ifNone: [ :lower :upper |
				lower = 0 
			 		ifFalse: [ 
						byteCursor := index at: lower. 
						codePointIndex := (lower * self stride) + 1 ] ] ].
	[ byteCursor <= bytes size ] whileTrue: [
		byteCursor = byteIndex 
			ifTrue: [ ^ codePointIndex ].
		byteCursor := byteCursor + (self encodedByteCountAt: byteCursor).
		codePointIndex := codePointIndex + 1 ].
	^ 0! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:45:39'!
                     computeCountAndIndex
	self isEmpty ifTrue: [ count := 0. ^ self ].
	"the number of characters cannot be larger than the byte size"
	bytes size <= self stride
		ifTrue: [ self computeCountNoIndex ]
		ifFalse: [ self computeCountAndIndexFull ]! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:46:55'!
         computeCountAndIndexFull
	count := 0.
	index := Array streamContents: [ :out | | byteIndex |
		byteIndex := 1.
		[ byteIndex <= bytes size ] whileTrue: [
			count := count + 1.
			(count > self stride and: [ (count - 1 \\ self stride) = 0 ]) 
				ifTrue: [ out nextPut: byteIndex ].
			byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ] ]! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:46:18'!
                           computeCountNoIndex
	| byteIndex |
	count := 0.
	index := #().
	byteIndex := 1.
	[ byteIndex <= bytes size ] whileTrue: [
		count := count + 1.
		byteIndex := byteIndex + (self encodedByteCountAt: byteIndex) ]! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:50:23'!
         encodedByteCountAt: byteIndex
	| byte |
	(byte := bytes at: byteIndex) < 128 ifTrue: [ ^ 1 ].
	(byte bitAnd: 2r11100000) = 2r11000000 ifTrue: [ ^ 2 ].
	(byte bitAnd: 2r11110000) = 2r11100000 ifTrue: [ ^ 3 ].
	(byte bitAnd: 2r11111000) = 2r11110000 ifTrue: [ ^ 4 ].
	self error: 'IllegalLeadingByte '! !
!Utf8String methodsFor: 'private' stamp: 'svc 5/5/2022 15:45:54'!
               stride
	"Return the stride, the constant I use internally to build my index"
	
	^ 32! !
!Utf8String methodsFor: 'as yet unclassified' stamp: 'jmv 5/11/2022 10:10:04' overrides: 50337880!
     doesNotUnderstand: aMessage

	{ 'Utf8String does not understand: '. aMessage} print! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/11/2022 10:10:07'!
                      empty
	"Return the empty Utf8String instance.
	Since my instances are readonly, this could be cached."

	^ (self withBytes: #[]) beAscii; yourself! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:16:43'!
                        fromUtf32: aWordArray

	^self withBytes: (String utf8FromUtf32: aWordArray).! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/5/2022 10:19:21'!
                              fromUtf8: bytes

	^self withBytes: bytes! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/11/2022 10:11:25'!
 with: aCharacter 
	"Answer a new instance of me, containing utf bytes for aCharacter.
	Utf8String with: $a
	Utf8String with: $·
	Utf8String with: Character euro
	"
	^self withBytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint).! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/11/2022 10:11:36'!
                     with: aCharacter with: otherCharacter
	"Answer a new instance of me, containing utf bytes for aCharacter.
	Utf8String with: $a
	Utf8String with: $· with: Character euro
	"
	^self withBytes: (Character utf8BytesOfUnicodeCodePoint: aCharacter codePoint),
		(Character utf8BytesOfUnicodeCodePoint: otherCharacter codePoint).! !
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/3/2022 12:10:29'!
         withBytes: aByteArray
	^self new bytes: aByteArray ! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/11/2022 10:05:41'!
                               scanUtf32StringFrom: startIndex to: stopIndex in: anUtf32String rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	anUtf32String words from: startIndex to: stopIndex do: [ :code |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil)."
		code < 256 ifTrue: [
			(stops at: code + 1) ifNotNil: [ :stop | ^stop ]].
		nextDestX _ destX + (font widthOfCodePoint: code).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 5/11/2022 10:08:19'!
             scanUtf8StringFrom: startIndex to: stopIndex in: anUtf8String rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	anUtf8String from: startIndex to: stopIndex doWithUtf8Bytes: [ :byte1 :byte2 :byte3 :byte4 |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil).
		It is OK to just use the first byte in UTF-8"
		(stops at: byte1 + 1) ifNotNil: [ :stop | ^stop ].
		nextDestX _ destX + (font widthOfUtf8Byte1: byte1 b2: byte2 b3: byte3 b4: byte4).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode! !
!Object methodsFor: 'testing' stamp: 'jmv 5/11/2022 10:08:57' prior: 50347215!
                        isStringLike
	"Overridden to return true in String, Utf8String and Utf32String."
	^ false! !
!String methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:20:22' prior: 16949318!
             editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !
!Text methodsFor: 'user interface' stamp: 'jmv 5/11/2022 10:20:26' prior: 16964294!
                              editLabel: labelString

	(TextModel withText: self) openLabel: labelString! !

CharacterScanner removeSelector: #scanStringUtf8From:to:in:rightX:stopConditions:!

!methodRemoval: CharacterScanner #scanStringUtf8From:to:in:rightX:stopConditions: stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
scanStringUtf8From: startIndex to: stopIndex in: aStringUtf8 rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	aStringUtf8 from: startIndex to: stopIndex doWithUtf8Bytes: [ :byte1 :byte2 :byte3 :byte4 |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil).
		It is OK to just use the first byte in UTF-8"
		(stops at: byte1 + 1) ifNotNil: [ :stop | ^stop ].
		nextDestX _ destX + (font widthOfUtf8Byte1: byte1 b2: byte2 b3: byte3 b4: byte4).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode!

CharacterScanner removeSelector: #scanStringUtf32From:to:in:rightX:stopConditions:!

!methodRemoval: CharacterScanner #scanStringUtf32From:to:in:rightX:stopConditions: stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
scanStringUtf32From: startIndex to: stopIndex in: aStringUtf32 rightX: rightX stopConditions: stops
	"This is the inner loop of text display.
	March through source String from startIndex to stopIndex. If any character is flagged with a
	non-nil entry in stops, then return the corresponding value.
	Determine width of each character.
	If dextX would exceed rightX, then return stops at: 258.
	Advance destX by the width of the character. If stopIndex has been
	reached, then return stops at: 257."

	| nextDestX |
	lastIndex _ startIndex.
	aStringUtf32 words from: startIndex to: stopIndex do: [ :code |
		"stops are only defined for the first 128 characters
		(entries 128 to 255 are always nil)."
		code < 256 ifTrue: [
			(stops at: code + 1) ifNotNil: [ :stop | ^stop ]].
		nextDestX _ destX + (font widthOfCodePoint: code).
		nextDestX > rightX ifTrue: [
			^stops at: CharacterScanner crossedXCode ].
			destX _ nextDestX.
			lastIndex _ lastIndex + 1 ].
	lastIndex _ stopIndex.
	^ stops at: CharacterScanner endOfRunCode!

Smalltalk removeClassNamed: #StringUtf32!

!classRemoval: #StringUtf32 stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #StringUtf32
	instanceVariableNames: 'codePoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

Smalltalk removeClassNamed: #StringUtf8!

!classRemoval: #StringUtf8 stamp: 'Install-5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st 5/16/2022 10:22:25'!
Object subclass: #StringUtf8
	instanceVariableNames: 'bytes count index'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Text'!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5146-UnicodeStrings-tweaks-JuanVuletich-2022May11-10h32m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 10:27:09 am'!
!FontFamily class methodsFor: 'ui' stamp: 'jmv 5/12/2022 10:05:27'!
                               readIfNeeded: nameOrDirectory
	"Read from disk if not in memory"

	(FontFamily familyNamed: nameOrDirectory)
		ifNotNil: [ :it | ^it ].
	^FontFamily availableFamilies values
		detect: [ :any | any folderName = nameOrDirectory name ]
		ifNone: [
			FontFamily familyNamed: ((Smalltalk at: #TrueTypeFontFamily) read: nameOrDirectory) anyOne ]! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 5/12/2022 10:06:50' prior: 16860375!
                    promptUser
	"Present a menu of font families, answer selection.
	FontFamily promptUser
	"
	^self promptUserFolders ifNotNil: [ :selectedNameOrDirectory |
		self readIfNeeded: selectedNameOrDirectory ].! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 5/12/2022 10:12:56' prior: 50336229!
                               promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| fontFamily |
	self promptUserFolders ifNotNil: [ :selectedNameOrDirectory |
		(Feature require: 'VectorGraphics') ifTrue: [
			(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
				Feature require: 'VectorEngineInSmalltalk' ].
			UISupervisor whenUIinSafeState: [
				fontFamily _ self readIfNeeded: selectedNameOrDirectory.
				Preferences setDefaultFont: fontFamily familyName ]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5147-FontFamily-tweaks-JuanVuletich-2022May12-10h05m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5147] on 12 May 2022 at 10:40:53 am'!
!StrikeFontFamily methodsFor: 'testing' stamp: 'jmv 5/12/2022 10:36:05'!
       includesAscii
	"Answer true if we include the basic ASCII characters.
	If not, we are not suitable, for instance, for displaying Smalltalk code."
	^true! !
!FontFamily class methodsFor: 'ui' stamp: 'jmv 5/12/2022 10:37:23' prior: 50352036!
                promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| fontFamily |
	self promptUserFolders ifNotNil: [ :selectedNameOrDirectory |
		(Feature require: 'VectorGraphics') ifTrue: [
			(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
				Feature require: 'VectorEngineInSmalltalk' ].
			UISupervisor whenUIinSafeState: [
				fontFamily _ self readIfNeeded: selectedNameOrDirectory.
				fontFamily includesAscii
					ifTrue: [Preferences setDefaultFont: fontFamily familyName ]
					ifFalse: [self inform: 'Selected font does not include ASCII characters. Can not be set as default.' ]]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5148-DefaultFontMustIncludeASCII-JuanVuletich-2022May12-10h40m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5148] on 12 May 2022 at 2:53:39 pm'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 5/12/2022 14:53:09' prior: 16952849!
                     knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 						'Colin Putney')
	#('acg' 						'Andrew C. Greenberg')
	#('ads' 						'Adam Spitz')
	#('AFi' 						'Alain Fischer')
	#('ajh' 						'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 						'Andres Otaduy')
	#('apb' 						'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 						'Alejandro Magistrello')
	#('avi' 						'Avi Bryant')
	#('AY'						'Angel Yan')
	#('BenComan' 						'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 						'Boris Gaertner')
	#('bgs' 						'Boris G. Shingarov')
	#('BJP' 						'Bijan Parsia')
	#('bkv' 						'Brent Vukmer')
	#('bolot' 						'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 						'Brent Pinkney')
	#('cbc' 						'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 						'Chris Norton')
	#('cmm' 						'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 						'Colin Putney')
	#('das' 						'David A Smith')
	#('db' 						'Douglas Brebner')
	#('dc' 						'Damien Cassou')
	#('dew' 						'Doug Way')
	#('DF'						'David Faitelson')
	#('dgd' 						'Diego Gomez Deck')
	#('dkh'						'Dale Henrichs')
	#('dhn'	 					'Dan Norton')
	#('dhhi' 						'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 						'David J. Pennell')
	#('DKL'						'Daniel K Lyons')
	#('DM' 						'Duncan Mak')
	#('DSM' 						'Duane Maxwell')
	#('DSG'						'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf'	 					'Daniel Vainsencher')
	#('eat' 						'Eric Arseneau Tremblay')
	#('EB'						'Eric Brandwein')
	#('eem'						'Eliot Emilio Miranda')
	#('eliot'						'Eliot Emilio Miranda')
	#('efc' 						'Eddie Cottongim')
	#('em' 						'Ernest Micklei?')
	#('emm' 						'Ernest Micklei')
	#('fbs' 						'Frank Shearar')
	#('FBS' 						'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 						'Frank Sergeant')
	#('FernandoOlivero' 						'Fernando Olivero')
	#('FernanodOlivero' 						'Fernando Olivero')
	#('FGJ'						'Fernando Gasperi Jabalera')
	#('FJG'				 		'Facundo Javier Gelatti')
	#('GabrielOmarCotelli' 						'Gabriel Omar Cotelli')
	#('GC' 						'GastÛn Caruso')
	#('gera' 						'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 						'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 						'German Arduino')
	#('HAW' 						'Hernan Wilkinson')
	#('HB' 						'Hari Balaraman')
	#('hjh' 						'Hannes Hirzel')
	#('hlsf' 						'Hilaire Fernandes')
	#('hmm' 						'Hans-Martin Mosner')
	#('hsj' 						'Henrik Sperre Johansen')
	#('Igor.Stasenko' 						'Igor Stasenko')
	#('ikp' 						'Ian Piumarta')
	#('jar' 						'Jaromir Matas')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 						'Joshua Gargus')
	#('jdr' 						'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 						'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '						John Maloney')
	#('jmb' 						'Hans Baveco')
	#('JMG'						'Jeff Gonis')
	#('JMM' 						'John McIntosh')
	#('jmv' 						'Juan Vuletich')
	#('JMV' 						'Juan Vuletich')
	#('JO'						'Javier Olaechea')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 						'John-Reed Maffeo')
	#('jrp' 						'John Pierce')
	#('jsp' 						'Jeff Pierce')
	#('KenD' 						'Ken Dickey')
	#('kfr' 						'Karl Ramberg')
	#('KLC'			 			'Ken Causey')
	#('KLG'			 			'Gerald Klix')
	#('kph'						'Keith Hodges')
	#('KTT' 						'Kurt Thams')
	#('laza' 						'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 						'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 						'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 						'Marcus Denker')
	#('MarcusDenker' 						'Marcus Denker')
	#('marcus.denker' 						'Marcus Denker')
	#('mdr' 						'Mike Rutenberg')
	#('mga' 						'Markus Galli')
	#('mha' 						'Michael Haupt')
	#('mir' 						'Michael Rueger')
	#('mjg' 						'Mark Guzdial')
	#('mk'	 					'Matej Kosik')
	#('MM'	 					'Mariano Montone')
	#('MPH'	 					'Michael Hewner')
	#('mpw' 						'Marcel Weiher')
	#('MPW' 						'Marcel Weiher')
	#('mrm' 						'Martin McClure')
	#('mtf' 						'Matthew Fulmer')
	#('mu' 						'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'					 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('NM' 						'Nicola Mingotti')
	#('nop' 						'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 						'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('pmon'						'Paolo Montrasi')
	#('PHK' 						'Peter Keeler')
	#('Pmm' 						'Philippe Marschall')
	#('pnm' 						'Paul McDonough')
	#('r++' 						'Gerardo Richarte')
	#('raa' 						'Bob Arning')
	#('RAA' 						'Bob Arning')
	#('raok' 						'Richard A. O''Keefe')
	#('rca' 						'Russell Allen')
	#('reThink'				 		'Paul McDonough')
	#('rew' 						'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 						'Ron Teitelbaum')
	#('RNG' 						'Nahuel Garbezza')
	#('rr' 						'Romain Robbes')
	#('rss' 						'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 						'Robert Withers')
	#('Sames' 						'Samuel S. Shuster')
	#('sbw' 						'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 						'Stephane Ducasse')
	#('sge' 						'Steve Elkins')
	#('sjd' 						'Santiago Jose Dandois')
	#('SLD'						'Steve Davies')
	#('sma' 						'Stefan Matthias Aust')
	#('sps' 						'Steven Swerling')
	#('SqR' 						'Andres Valloud')
	#('sqr' 						'Andres Valloud')
	#('Squeak1.0'						'Squeak 1.0, September 20, 1996')
	#('Squeak1.1'						'Squeak 1.1, September 23, 1996')
	#('Squeak1.2'						'Squeak 1.2, June 29, 1997')
	#('Squeak1.3'						'Squeak 1.3, January 16, 1998')
	#('sr' 						'Stephan Rudlof')
	#('ss'						'Sebastian Sujarchuk')
	#('SSS' 						'Samuel S. Shuster')
	#('ST-80'						'Smalltalk-80, version 2, of April 1, 1983')
	#('stephane.ducasse' 						'Stephane Ducasse')
	#('stephaneducasse'	 					'Stephane Ducasse')
	#('stp' 						'Stephen Travis Pope')
	#('sumim' 						'Masato Sumi')
	#('svp' 						'Stephen Vincent Pair')
	#('sw' 						'Scott Wallace')
	#('TAG' 						'Travis Griggs')
	#('tak' 						'Takashi Yamamiya')
	#('tao' 						'Tim Olson')
	#('TBn' 						'Torsten Bergmann')
	#('tfei' 						'The Fourth Estate, Inc.')
	#('tfel' 						'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 						'Tim Rowledge')
	#('TPR' 						'Tim Rowledge')
	#('tsl' 						'Thiago da Silva Lino')
	#('tween' 						'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 						'Ward Cunningham')
	#('wiz' 						'Jerome Peace')
	#('wod' 						'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5149-Add-DavidFaitelson-asKnownAuthor-JuanVuletich-2022May12-14h53m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5141] on 9 May 2022 at 6:14:00 pm'!
!Fraction commentStamp: 'len 5/9/2022 18:06:15' prior: 16863542!
             Fraction provides methods for dealing with rational numbers like 1/3 as true fractions (not approximations as a Float 0.33333...). All public arithmetic operations answer reduced fractions, or Integers when the denominator is 1.

Examples: (note the parentheses required to get the right answers in Smalltalk):

(2/3) + (2/3)
(6/4)		 		"Fractions are reduced to the smallest numerator and denominator possible"
(1 / -3)			"Denominator is kept positive, the sign is always in the numerator"
(2/3) + (1/3)	"When the denominator reduces to 1, the answer is an Integer"
!
!BitBltCanvas commentStamp: '<historical>' prior: 16789070!
            origin is aPoint, and it is expressed relative to the form. Usually, the form doesn't cover the whole World, and origin is negative. For instance, if we just want to draw the part of the World in (100@100 extent: 50@50) to another form, then fom extent = 50@50, and origin = -100@ -100.

clipRect is relative to the form. For instance, if we only need to draw the part in (110@110 extent: 20@20) to the form above, then clipRect is (10@10 extent: 20@20)

All public protocol and drawing services is relative to World. The idea is that we only care about origin/form when we set them. Afterwards, we don't need to care about them. All the operations are done as if the whole World was drawn on Display.!
!Form methodsFor: 'transitions' stamp: 'len 5/9/2022 17:58:14' prior: 16862659!
                 slideImage: otherImage at: topLeft delta: delta
	"
	Display slideImage: (Form fromDisplay: (40@40 extent: 300@300)) reverse
		at: 40@40 delta: 3@ -4
	"
	| bb nSteps clipRect |
	bb _ otherImage boundingBox.
	clipRect _ topLeft extent: otherImage extent.
	nSteps _ 1.
	delta x = 0 ifFalse: [nSteps _ nSteps max: (bb width//delta x abs) + 1].
	delta y = 0 ifFalse: [nSteps _ nSteps max: (bb height//delta y abs) + 1].
	1 to: nSteps do: [ :i | 
			self 
				copyBits: bb from: otherImage
				at: delta*(i-nSteps) + topLeft
				clippingBox: clipRect rule: Form paint.
			Display forceToScreen.
		]! !
!Form methodsFor: 'transitions' stamp: 'len 5/9/2022 17:58:26' prior: 16862702!
                            wipeImage: otherImage at: topLeft delta: delta
	"Display wipeImage: (Form fromDisplay: (40@40 extent: 300@300)) reverse
		at: 40@40 delta: 0@ -2"

	self wipeImage: otherImage at: topLeft delta: delta clippingBox: nil.
! !
!Form class methodsFor: 'examples' stamp: 'len 5/9/2022 17:58:20' prior: 16863296!
               toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ `Color red wheel: 12`.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: `-40@ -40`].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!Form class methodsFor: 'examples' stamp: 'len 5/9/2022 17:58:33' prior: 16863333!
           xorHack: size  "Display restoreAfter: [Form xorHack: 256]"
	"Draw a smiley face or stick figure, and end with option-click.
	Thereafter image gets 'processed' as long as you have button down.
	If you stop at just the right time, you'll see you figure upside down,
	and at the end of a full cycle, you'll see it perfectly restored.
	Dude -- this works in color too!!"
	| rect form i bb |
	rect _ 5@5 extent: size@size.
	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.
	Display border: (rect topRight - (0@2) extent: rect extent*2 + 4) width: 2.
	Form exampleSketch.
	form _ Form fromDisplay: rect.
	bb _ form boundingBox.
	i _ 0.
	[Sensor isMouseButton2Pressed] whileFalse:
		[[Sensor isMouseButton1Pressed] whileTrue:
			[i _ i + 1.
			(Array with: 0@1 with: 0@ -1 with: 1@0 with: -1@0) do:
				[:d | form copyBits: bb from: form at: d
					clippingBox: bb rule: Form reverse ].
			form displayAt: rect topLeft.
			i+2\\size < 4 ifTrue: [(Delay forMilliseconds: 300) wait]].
		(form magnify: form boundingBox by: 2@2) displayAt: rect topRight + (2@0).
		Sensor waitButton].! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 17:58:38' prior: 16834435!
                               bottomLeftCursor
	^ Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1100000000000000
		2r1111111111111100
		2r1111111111111100
		2r0000000000000000
		2r0000000000000000)
	offset: `0@ -16`! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 17:58:43' prior: 16834451!
                        bottomRightCursor
	^  Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r1111111111111100
		2r1111111111111100
		2r0000000000000000
		2r0000000000000000)
	offset: `-16@ -16`! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 17:58:46' prior: 16834467!
                    cornerCursor
	"Answer the instance of me that is the shape of the bottom right corner 
	of a rectangle."
	^ Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r0000000000001100
		2r1111111111111100
		2r1111111111111100
		2r0000000000000000
		2r0000000000000000)
	offset: `-16@ -16`! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 17:58:50' prior: 16834486!
                              crossHairCursor
	"Answer the instance of me that is the shape of a cross."
	^ Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0111111111111100
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000100000000
		2r0000000000000000
		2r0000000000000000)
	offset: `-7@ -7`! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 17:58:53' prior: 16834617!
                              normalCursorWithMask
	"Cursor initNormalWithMask.  Cursor normal show"
	"Next two lines work simply for any cursor..."
	"
	self initNormal.
	NormalCursor _ CursorWithMask derivedFrom: NormalCursor.
	"
	"But for a good looking cursor, you have to tweak things..."
	^ ((CursorWithMask
		small1BitExtent: `16@16`
		pixelBits: #(
			2r0000000000000000
			2r0100000000000000
			2r0110000000000000
			2r0111000000000000
			2r0111100000000000
			2r0111110000000000
			2r0111111000000000
			2r0111111100000000
			2r0111111110000000
			2r0111110000000000
			2r0110110000000000
			2r0100011000000000
			2r0000011000000000
			2r0000001100000000
			2r0000001100000000
			2r0000000000000000)
		offset: `-1@ -1`)
	setMaskForm: 
		(Form
			small1BitExtent: `16@16`
			pixelBits: #(
				2r1100000000000000
				2r1110000000000000
				2r1111000000000000
				2r1111100000000000
				2r1111110000000000
				2r1111111000000000
				2r1111111100000000
				2r1111111110000000
				2r1111111111000000
				2r1111111111100000
				2r1111111000000000
				2r1110111100000000
				2r1100111100000000
				2r1000011110000000
				2r0000011110000000
				2r0000001110000000)
			offset: `0@0`))! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:20' prior: 16834728!
                            resizeLeftCursor
	^ `(Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000000000
		2r0000010010000000
		2r0000010010000000
		2r0000010010000000
		2r0001010010100000
		2r0011010010110000
		2r0111010010111000
		2r1111110011111100
		2r0111010010111000
		2r0011010010110000
		2r0001010010100000
		2r0000010010000000
		2r0000010010000000
		2r0000010010000000
		2r0000000000000000
		2r0000000000000000)
	offset: `-7@ -7`) withMask`.! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:24' prior: 16834750!
          resizeTopCursor
	^ `(Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000100000000
		2r0000001110000000
		2r0000011111000000
		2r0000111111100000
		2r0000000100000000
		2r0111111111111100
		2r0000000000000000
		2r0000000000000000
		2r0111111111111100
		2r0000000100000000
		2r0000111111100000
		2r0000011111000000
		2r0000001110000000
		2r0000000100000000
		2r0000000000000000
		2r0000000100000000)
	offset: `-7@ -7`) withMask`.! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:27' prior: 16834767!
           resizeTopLeftCursor
	^ `(Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000000000
		2r0111110000010000
		2r0111100000100000
		2r0111000001000100
		2r0110100010001000
		2r0100010100010000
		2r0000001000100000
		2r0000010001000000
		2r0000100010000000
		2r0001000101000100
		2r0010001000101100
		2r0000010000011100
		2r0000100000111100
		2r0000000001111100
		2r0000000000000000
		2r0000000000000000)
	offset: `-7@ -7`) withMask`.! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:31' prior: 16834784!
       resizeTopRightCursor
	^ `(Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000000000
		2r0001000001111100
		2r0000100000111100
		2r0100010000011100
		2r0010001000101100
		2r0001000101000100
		2r0000100010000000
		2r0000010001000000
		2r0000001000100000
		2r0100010100010000
		2r0110100010001000
		2r0111000001000000
		2r0111100000100000
		2r0111110000000000
		2r0000000000000000
		2r0000000000000000)
	offset: `-7@ -7`) withMask`.! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:35' prior: 16834820!
      squareCursor
	"Answer the instance of me that is the shape of a square."
	^ Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000001111000000
		2r0000001111000000
		2r0000001111000000
		2r0000001111000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000
		2r0000000000000000)
	offset: `-8@ -8`! !
!Cursor class methodsFor: 'instance creation' stamp: 'len 5/9/2022 18:03:38' prior: 16834838!
targetCursor
	"Answer the instance of me that is the shape of a gunsight."
	^ Cursor
	small1BitExtent: `16@16`
	pixelBits: #(
		2r0000011111000000
		2r0001100100110000
		2r0010000100001000
		2r0100000100000100
		2r0100001110000100
		2r1000000100000010
		2r1000100100100010
		2r1111111011111110
		2r1000100100100010
		2r1000000100000010
		2r0100001110000100
		2r0100000100000100
		2r0010000100001000
		2r0001100100110000
		2r0000011111000000
		2r0000000000000000)
	offset: `-7@ -7`! !
!CursorWithAlpha class methodsFor: 'constants' stamp: 'len 5/9/2022 18:03:43' prior: 16835014!
                             biggerNormal
	"
	CursorWithAlpha biggerNormal show
	"

	^self constants at: #biggerNormal ifAbsentPut: [
		| form cursor packName pack |
		packName _ #GUIFormsPack.
		pack _ (Smalltalk at: packName) new.
		form _ (pack decodeContentFrom: pack contentMap) at: 'biggerNormalCursor'.
		cursor _ CursorWithAlpha extent: form extent depth: 32.
		form displayOn: cursor.
		cursor offset: -2@ -1.
		cursor preMultiplyAlpha.
		cursor ]! !
!Point methodsFor: 'point functions' stamp: 'len 5/9/2022 18:03:53' prior: 16913054!
                            eightNeighbors
	^ (Array with: self + `1@0`
		with: self + `1@1`
		with: self + `0@1`
		with: self + `-1@1`) ,
	(Array with: self + `-1@0`
		with: self + `-1@ -1`
		with: self + `0@ -1`
		with: self + `1@ -1`)! !
!Point methodsFor: 'point functions' stamp: 'len 5/9/2022 18:03:57' prior: 16913075!
                      fourNeighbors
	^ Array with: self + `1@0`
		with: self + `0@1`
		with: self + `-1@0`
		with: self + `0@ -1`! !
!Morph methodsFor: 'drawing' stamp: 'len 5/9/2022 18:04:09' prior: 16891923!
    drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."

	aCanvas
		fillRectangle: `-75 @ -70 corner: 75 @ 70`
		color: `Color blue`! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5150-AtMinusFixes-LucianoEstebanNotarfrancesco-2022May09-17h58m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5150] on 12 May 2022 at 5:13:14 pm'!
!Number methodsFor: 'arithmetic' stamp: 'jmv 5/12/2022 16:59:55' prior: 16900122!
                 \\ divisor
	"Modulo operation. Remainder of the integer division #// (Floored division, truncated to minus infinity, a.k.a Knuth's division)
	Answer a Number with the same sign as divisor. 
	9\\4 = 1
	-9\\4 = 3
	9\\ -4 = -3
	0.9\\0.4 = 0.1
	See http://en.wikipedia.org/wiki/Modulo_operation
	See #\\, #rem: and #mod:
	See detailed discussion at http://mathforum.org/library/drmath/view/52343.html
	"

	^self - (self // divisor * divisor)

	"Evaluate the following:"
"
Compiler evaluate: '
	| g d |
	d _ 1.
	Feature require: ''Morphic-Widgets-Extras''.
	g _ FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x \\ d ] color: Color green.
	g addFunction: [ :x | x // d ] color: Color red.
	g openInWorld'
"
"
Compiler evaluate: '
	| g d |
	d _ -1.
	Feature require: ''Morphic-Widgets-Extras''.
	g _ FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x \\ d ] color: Color green.
	g addFunction: [ :x | x // d ] color: Color red.
	g openInWorld'
"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5151-BinaryMinusFix-JuanVuletich-2022May12-17h12m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5151] on 12 May 2022 at 5:34:51 pm'!
!Point methodsFor: 'printing' stamp: 'jmv 5/12/2022 17:24:12' prior: 16913255 overrides: 16902975!
printOn: aStream 
	"The receiver prints on aStream in terms of infix notation."

	x printOn: aStream.
	aStream nextPut: $@; space.
	y printOn: aStream! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5152-FixForDecompiledCode-JuanVuletich-2022May12-17h34m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5152] on 13 May 2022 at 4:26:43 pm'!

Object subclass: #PreferenceNG
	instanceVariableNames: 'name description category value type'
	classVariableNames: 'ThePreferences'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #PreferenceNG category: #'System-Support' stamp: 'Install-5153-PreferenceNG-HilaireFernandes-2022May13-16h26m-hlsf.001.cs.st 5/16/2022 10:22:26'!
Object subclass: #PreferenceNG
	instanceVariableNames: 'name description category value type'
	classVariableNames: 'ThePreferences'
	poolDictionaries: ''
	category: 'System-Support'!
!PreferenceNG commentStamp: '<historical>' prior: 0!
                    My instance is a Preference whose value is of a given class (type), or follow the description of the type instance

- name, category: symbol
- description: string
- type: a class (Boolean, String, Color, BlockClosure, etc.) or an instance (collection, intervale, etc.)
- value: an object whose class match type or the instance description of the type

Modus Operendi
- To create a Preference, invoke the instance creation class method (Preference name:description:category:type:value:). The new preference is automatically remembered. If a preference with same name already exist, its instance is updated with the new provided data and its instance returned.
- To access, invoke as dictionary (Preference at: #biggerCursors), a short cut exist (Preference biggerCursors)
- When a preference value is changed with its #value message, an event #preferenceChanged is triggered.
- Tools can listen to a specific #preferenceChanged event: 
	(Preference instanceAt: #guiElementSize) when: #preferenceChanged send: #shakeScreen: to: myTool
By default the Preference class listen to a few event to adjust the behavior of the image to some preference changes.	
!
!PreferenceNG methodsFor: 'printing' stamp: 'hlsf 5/5/2022 12:31:23' overrides: 16902975!
    printOn: aStream
	aStream nextPutAll: self class name ;
		nextPutAll: ' (#';
		nextPutAll: name ;
		nextPutAll: ' = ';
		nextPutAll: type printString;
		nextPutAll: '::';
		nextPutAll: value printString;
		nextPut: $)! !
!PreferenceNG methodsFor: 'initialization' stamp: 'hlsf 5/5/2022 12:21:27'!
                       name: nameSymbol description: aString category: categorySymbol type: aType value: aValue
	name _ nameSymbol.
	description _ aString.
	category _ categorySymbol.
	type _ aType ifNotNil: [aType] ifNil: [self class detectType: aValue ].
	value _ 	aValue! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/10/2022 19:34:21'!
                          accept: aVisitor
	| visitMethod |
	self isTypeAClass 
		ifTrue: [ visitMethod _ ('visit', type name, 'Preference:') asSymbol ]
		ifFalse: [visitMethod _ ('visit', type species, 'Preference:') asSymbol ].
	aVisitor perform: visitMethod with: self! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 14:25:45'!
                               category
	^ category ! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/2/2022 22:19:11'!
category: aSymbol
	aSymbol isNil ifFalse: [category _ aSymbol ]! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 14:25:57'!
                     description
	^ description! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/2/2022 22:18:30'!
                           description: aString
	aString isEmptyOrNil ifFalse: [description _ aString ]! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 14:26:02' overrides: 16903442!
                    name
	^ name! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/4/2022 23:32:57'!
         type
	^ type! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/3/2022 21:16:04' overrides: 16902254!
                     value
" If my type is closure without argument, return my value "
	^ (type == BlockClosure and: [value argumentCount = 0])
		ifTrue: [value value]
		ifFalse: [value]
	! !
!PreferenceNG methodsFor: 'accessing' stamp: 'hlsf 5/9/2022 22:01:23'!
              value: aValue	
	self isTypeAClass 
		ifTrue: [
			(aValue isKindOf: type) ifFalse: [self error: aValue printString, ' is not a ', type printString].
			value _ aValue ]
		ifFalse: [ "Should be handled somehow by the preference editor "
			value _ aValue].
	self triggerEvent: #preferenceChanged with: self! !
!PreferenceNG methodsFor: 'testing' stamp: 'hlsf 5/9/2022 22:01:40'!
      isTypeAClass
" is type a Class or an Instance "
	^ type class class == Metaclass ! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 21:11:22'!
                             all
	^ ThePreferences 
	! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 22:21:36' overrides: 16901507!
  at: symbolName
	^ (self instanceAt: symbolName) value! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 5/3/2022 20:47:15' overrides: 16901525!
      at: symbolName put: aValue
	| myPref |
	myPref _ self instanceAt: symbolName. 
	myPref value: aValue! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 14:28:57'!
          categories
	| categories |
	categories _ Set new.
	ThePreferences values do: [:aPreference | categories add: aPreference category].
	^ categories sorted! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 22:19:26'!
                      instanceAt: symbolName
	^ ThePreferences at: symbolName ifAbsent: [self error: 'Unknown preference ', symbolName ]! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 4/30/2022 14:29:56'!
                            select: aCategory
" I select the preferences of the given category "
	^ ThePreferences values select: [:aPreference | aPreference category == aCategory ]! !
!PreferenceNG class methodsFor: 'instance creation' stamp: 'hlsf 5/3/2022 19:16:59'!
              name: nameSymbol category: categorySymbol value: aValue
	self name: nameSymbol description: nil category: categorySymbol type: nil value: aValue 
! !
!PreferenceNG class methodsFor: 'instance creation' stamp: 'hlsf 5/3/2022 19:59:49'!
                     name: nameSymbol description: aString category: categorySymbol type: aType value: aValue
"If I exist, I am updated with the newer sent data "
	(nameSymbol isSymbol or: [categorySymbol isSymbol]) ifFalse: 
		[self error: 'Preference Name & Category are not valid symbol.'].
	^ ThePreferences 
		at: nameSymbol
		ifPresent: [:thePref |
			thePref 
				description: aString;
				category: categorySymbol;
				value: aValue;
				yourself]
		ifAbsent: [ | newPref |
			newPref _ self new ::
				name: nameSymbol 
				description: aString 
				category: categorySymbol 
				type: aType 
				value: aValue.
			ThePreferences at: nameSymbol put: newPref ].
	! !
!PreferenceNG class methodsFor: 'error handling' stamp: 'hlsf 4/30/2022 22:20:35' overrides: 50337880!
           doesNotUnderstand: aMessage
	aMessage hasArguments ifTrue: [^ super doesNotUnderstand: aMessage].
	^ self at: aMessage selector! !
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/7/2022 18:06:54' overrides: 16904184!
                 initialize
	ThePreferences _ Dictionary new.
	#(gui font programming system) do: [: category | 
		(self perform: (#pref, category capitalized) asSymbol) do: [:aPrefArray |
			self installDefault: aPrefArray in: category] ].
	self installHaloPreferencesWith: self iconicHaloSpecifications.
	self installMiscPreferences ! !
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/7/2022 00:47:32'!
      installDefault: anArray in: category
" Description of preference in Array: name - value - type (optional) - event handler (optional) "
	| myPref |
	myPref _ PreferenceNG name: anArray first 				description: '' category: category 
		type: (anArray at: 3 ifAbsent: [self detectType: anArray second]) value: anArray second.
	anArray size = 4 ifTrue: [ "fourth record is an event listener hooked to Preference"
		myPref when: #preferenceChanged send: anArray fourth to: PreferenceNG.
		myPref triggerEvent: #preferenceChanged with: myPref]
	! !
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/4/2022 16:10:52'!
           installHaloPreferencesWith: anArray
	| aColor |
	^ PreferenceNG 
		name: #haloSpecifications 
		description: 'Halo specifications describing which halos are to be used, what they should look like, and where they should be situated'
		category: #gui
		type: Array
		value: (anArray collect: [ :each |
			aColor _ Color.
			each fourth do: [ :sel | aColor _ aColor perform: sel].
			HaloSpec new 
				horizontalPlacement: each second
				verticalPlacement: each third 
				color: aColor
				iconSymbol: each fifth
				addHandleSelector: each first
				hoverHelp: each sixth])! !
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/12/2022 11:35:43'!
      installMiscPreferences
" Preference value defined with closure. We could insert in a dynamic array...
  Preference with event handler "
	PreferenceNG 
		name: #haloHandleSize category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 5 // 3 max: 16].
	PreferenceNG
		name: #roundedButtonRadius 	category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 8 // 14].
	PreferenceNG
		name: #roundedWindowRadius 	category: #gui value: [(PreferenceNG at: #standardListFont) pointSize].
	PreferenceNG
		name: #scrollbarThickness category: #gui 		value: [(PreferenceNG at: #windowTitleFont) pointSize + 2].
	PreferenceNG name: #classFinder category: #programming value: [ BrowserWindow findClass ].
	PreferenceNG name: #defaultAuthorName category: #programming value: [Utilities authorName].! !
!PreferenceNG class methodsFor: 'fileIn/Out' stamp: 'hlsf 5/6/2022 11:42:57'!
                               loadFrom: aFileEntry
" Load all preferences from file, update the existing preferences with the data from file "
	(SmartRefStream restoreFromFile: aFileEntry) do: [:aPref | 
		PreferenceNG 
			name: aPref name 
			description: aPref description 
			category: aPref category 
			type: aPref type 
			value: (aPref instVarNamed: #value)	 " We want the raw value "]! !
!PreferenceNG class methodsFor: 'fileIn/Out' stamp: 'hlsf 4/30/2022 22:20:56'!
   save: nameSymbol to: aFileEntry
" Save one preference to a file, even for a sole preference we save in a Dictionary"
	| myPref |
	myPref _ self instanceAt: nameSymbol.
	SmartRefStream 
		dumpOnFile: aFileEntry 
		object: {myPref name -> myPref} asDictionary! !
!PreferenceNG class methodsFor: 'fileIn/Out' stamp: 'hlsf 4/30/2022 21:58:19'!
            saveAllTo: aFileEntry
" Save all the preferences to a file "
	SmartRefStream dumpOnFile: aFileEntry object: ThePreferences! !
!PreferenceNG class methodsFor: 'fileIn/Out' stamp: 'hlsf 4/30/2022 21:57:59'!
                   saveCategory: categorySymbol to: aFileEntry
	| myPref |
	myPref _ self select: categorySymbol.
	SmartRefStream 
		dumpOnFile: aFileEntry 
		object: 	(myPref collect: [:aPref | aPref name -> aPref ]) asDictionary! !
!PreferenceNG class methodsFor: 'helpers' stamp: 'hlsf 5/12/2022 13:07:56'!
                             detectType: anObject
"When the type is not provided, we can try to deduce it "
	^ anObject class name
		caseOf: {
			[#True] -> [Boolean].
			[#False] -> [Boolean].
			[#StrikeFont] -> [AbstractFont].
			[#TrueTypeFont ] -> [AbstractFont]
		}
		otherwise: [anObject class]
! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/6/2022 23:07:40'!
   iconicHaloSpecifications
"Answer an array that characterizes the locations, colors, icons, and selectors of the halo handles 
that may be used in the iconic halo scheme"

^ #(	"selector					horiz			vert			color info				icon key"
(addDismissHandle:						left			top			(red)				haloDismissIcon 					'Remove')
(addMenuHandle:						leftCenter			top			(blue lighter)				haloMenuIcon 					'Menu')
(addGrabHandle:						center			top			(black)				haloGrabIcon 					'Pick up')
(addDragHandle:						rightCenter			top			(brown)				haloDragIcon 					'Move')
(addDupHandle:						right			top			(green)				haloDuplicateIcon     					'Duplicate')	
(addExploreHandle:						left			topCenter			(orange)				haloDebugIcon 					'Explore')
(addDebugHandle:						right			topCenter			(orange)				haloDebugIcon 					'Debug')
(addCollapseHandle:						left			center			(tan)				haloCollapseIcon 					'Collapse')
(addScaleHandle:						right			center			(blue)				haloScaleIcon 					'Change scale')
(addRotateHandle:						left			bottom			(blue)				haloRotateIcon 					'Rotate')
(addHelpHandle:						center			bottom			(lightBlue)				haloHelpIcon 					'Help')
(addResizeHandle:						right			bottom			(yellow)				haloResizeIcon 					'Change size')
	"FIXME - Currently non-functional...
	(addRecolorHandle:						right			bottomCenter			(magenta darker)						haloColorIcon 						'Change color')	"
)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/7/2022 17:54:36'!
      machineDefault
	^ #(
		#(drawKeyboardFocusIndicator true )
		#(balloonHelpEnabled true )
		#(biggerCursors false )
		#(browseWithPrettyPrint false )
		#(caseSensitiveFinds false )
		#(checkForSlips true )
		#(cmdDotEnabled true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(menuKeyboardControl true )
		#(optionalButtons true )
		#(extraDebuggerButtons true )
		#(subPixelRenderFonts true )
		#(thoroughSenders true )
		#(cheapWindowReframe false )
		#(syntaxHighlightingAsYouType true )
		#(tapAndHoldEmulatesButton2 true )
		#(clickGrabsMorphs false )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(wantsMenuIcons true )
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/7/2022 17:54:24'!
       machineSlow
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
		(methodAnnotations #(timeStamp messageCategory packages changeSets) )
		(classAnnotations  #(instanceMethodsCount classMethodsCount) )
		(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount) )
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/7/2022 17:54:51'!
                   machineSmalltalk80
	^ #(
		(drawKeyboardFocusIndicator false )
		(balloonHelpEnabled false)
		(browseWithPrettyPrint false)
		(caseSensitiveFinds true)
		(checkForSlips false)
		(cmdDotEnabled true)
		(diffsInChangeList true)
		(diffsWithPrettyPrint false)
		(menuKeyboardControl false)
		(optionalButtons false)
		(subPixelRenderFonts true)
		(thoroughSenders true)
		(cheapWindowReframe true)
		(syntaxHighlightingAsYouType false)
		(tapAndHoldEmulatesButton2 false)
		(clickGrabsMorphs true)
		(wantsMenuIcons false )
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 10:49:26'!
        prefFont
	^ #( 
		#(aaFontsColormapDepth 4)
		#(cacheTrueTypeGlyphs true )
		#(guiElementsSize standardFonts #(tinyFonts verySmallFonts smallFonts standardFonts largeFonts veryLargeFonts hugeFonts) defaultFontSize: )
		#(loadOnlyLatinGlyphData false )
		#(properDisplayAlphaForFonts false )	
		#(subPixelRenderColorFonts true )
		#(subPixelRenderFonts true )	
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 08:48:37'!
         prefGui
	^ #( 
		#(balloonHelpEnabled true )
		#(biggerCursors false )		
		#(cacheDisplayContentWhenMovingMorphs true )
		#(cheapWindowReframe false )		
		#(clickGrabsMorphs false )	
		#(ctrlArrowsScrollHorizontally false ) 
		#(drawKeyboardFocusIndicator true )
		#(focusFollowsMouse true )
		#(focusIndicatorWidth 1)
		#(fullScreenLeavesDeskMargins true )
		#(haloEnclosesFullBounds true )
		#(halosShowCoordinateSystem true )
		#(menuKeyboardControl true )
		#(optionalButtons true )		
		#(selectiveHalos true )
		#(tapAndHoldEmulatesButton2 true )
		#(tileResizerInWindowMenu true )
		#(wantsMenuIcons true )
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 12:05:02'!
            prefProgramming
	^ #(
		#(allowBlockArgumentAssignment false )
		#(alternativeBrowseIt false )
		#(assignmentGlyphSelector useLeftArrow #(useLeftArrow useAlwaysLeftArrow) assignmentGlyph: )
		#(backgroundColorFillsAllBackground true )
		#(browseWithPrettyPrint false )
		#(classAnnotations #(instanceMethodsCount classMethodsCount linesOfCode) )
		#(debugHaloHandle true )
		#(debugLogTimestamp true )
		#(debugShowDamage false )
		#(decorateBrowserButtons true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(extraDebuggerButtons true )
		#(fullPrintItInWorkspaces false )
		#(highlightBlockNesting true )
		#(italicsInShout true)
		#(leftArrowAssignmentsInGeneratedCode false )
		#(listClassesHierarchically true )
		#(logDebuggerStackToFile false )
		#(methodAnnotations #(timeStamp linesOfCode messageCategory implementorsCount sendersCount  packages changeSets) )	
		#(prettyPrintRectangularBlocks false )
		#(shiftClickShowsImplementors false )
		#(shoutInWorkspaces true )
		#(showAnnotations true )
		#(showLinesInHierarchyViews true )
		#(stylingWithEmphasisInWorkspaces false )
		#(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount linesOfCode) )
		#(syntaxHighlightingAsYouType true )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(thoroughSenders true )
		#(usePreDebugWindow false)
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 11:50:23'!
            prefSystem
	^ #( #(allowNonLocalReturnsInExceptionHandlers true )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges false )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #roots #(root image vm current) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
	)! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 5/7/2022 00:41:45'!
         assignmentGlyph: assignmentPref
" #assignmentGliphSelector changed "
	AbstractFont withAllSubclassesDo: [ :fontClass | fontClass assignmentGlyphSelectorPreferenceChanged ]! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 5/7/2022 00:41:12'!
                               defaultFontSize: guiElementSizePref
" #guiElementSize changed "
	| font titleFont pointSize |
	pointSize _ self fontSizes at: guiElementSizePref value.
	font _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize.
	PreferenceNG name: #standardListFont category: #font value: font.
	PreferenceNG name: #standardMenuFont category: #font value: font.
	PreferenceNG name: #standardCodeFont category: #font value: font.
	PreferenceNG name: #standardButtonFont category: #font value: font.
	FontFamily defaultFamilyName: font familyName defaultPointSize: pointSize.	
	titleFont _ FontFamily familyName: FontFamily defaultFamilyName pointSize: pointSize * 12//10.
	PreferenceNG name: #windowTitleFont category: #font value: titleFont.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].
	PreferenceNG at: #biggerCursors put: (pointSize > 14).
	Cursor defaultCursor activateCursor.
	^font! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 5/7/2022 18:08:45'!
                         machine: machinePref
" Update the preferences for this kind of machine (#default, #slow or #smalltalk80) "
	| prefArray |
	prefArray _ self perform: (#machine, machinePref value capitalized) asSymbol.
	prefArray do: [:array | 		PreferenceNG at: array first put: array second].
	machinePref value == #slow ifTrue: [		self runningWorld backgroundImageData: nil]
	! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 5/7/2022 01:09:27'!
 menuIcon: wantsMenuIconsPref
	Theme current class beCurrent! !
!PreferenceNG class methodsFor: 'event handlers' stamp: 'hlsf 5/7/2022 17:43:12'!
               pointer: pointerPref
	| enabled |
	enabled _ pointerPref value == #touch.
	#(tapAndHoldEmulatesButton2 clickGrabsMorphs) do: [:aPref | 		PreferenceNG at: aPref put: enabled]! !
!PreferenceNG class methodsFor: 'fonts' stamp: 'hlsf 5/3/2022 18:58:38'!
      fontSizes
	^ `{
		#tinyFonts -> 7 .
		#verySmallFonts -> 9 .
		#smallFonts ->11 .
		#standardFonts -> 14 .
		#largeFonts -> 18 .
		#veryLargeFonts -> 24 .
		#hugeFonts -> 32} asDictionary`
		! !
!PreferenceNG class methodsFor: 'fonts' stamp: 'hlsf 5/12/2022 11:53:18'!
                   setDefaultFont: aFontName
	"Change the font on the whole system without changing point sizes."
	FontFamily defaultFamilyName: aFontName.
	PreferenceNG
			setDefaultFont: FontFamily defaultFamilyName
			spec: {
				{#standardListFont. (PreferenceNG at: #standardListFont) pointSize.}.
				{#standardMenuFont. (PreferenceNG at: #standardMenuFont) pointSize.}.
				{#windowTitleFont. (PreferenceNG at: #windowTitleFont) pointSize.}.
				{#standardCodeFont. (PreferenceNG at: #standardCodeFont) pointSize.}.
				{#standardButtonFont. (PreferenceNG at: #standardButtonFont) pointSize.}.
			}.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].! !
!PreferenceNG class methodsFor: 'fonts' stamp: 'hlsf 5/3/2022 19:39:30'!
       setDefaultFont: fontFamilyName spec: defaultFontsSpec
	| font |
	defaultFontsSpec do: [ :triplet |
		font _ FontFamily familyName: fontFamilyName pointSize: triplet second.
		font ifNil: [ font _ FontFamily defaultFamilyAndPointSize ]. 
		triplet size > 2 ifTrue: [			font _ font emphasized: triplet third ].
		PreferenceNG at: triplet first put: font ].
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].! !
!PreferenceNG class methodsFor: 'obsolete' stamp: 'hlsf 5/4/2022 14:56:05'!
             desktopMenuTitle
"I have project to get rid of this one"
	^ 'World'   ! !

PreferenceNG initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5153-PreferenceNG-HilaireFernandes-2022May13-16h26m-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 9:07:39 am'!
!Theme class methodsFor: 'user interface' stamp: 'hlsf 5/12/2022 08:58:17'!
          useMenuIcons
	PreferenceNG at: #wantsMenuIcons put: true! !
!Theme class methodsFor: 'user interface' stamp: 'hlsf 5/12/2022 08:58:40'!
                        useNoMenuIcons
	PreferenceNG at: #wantsMenuIcons put: false! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'hlsf 5/12/2022 09:00:04' prior: 16954503!
     reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	WorldMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	PreferenceNG at: #wantsMenuIcons put: false.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally DynamicTypingSmalltalkCompleter).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!Cursor class methodsFor: 'accessing' stamp: 'hlsf 5/12/2022 08:31:36' prior: 16834391!
          defaultCursor
	"Answer the instance of me that is the shape of an arrow slanted left."
	^ (PreferenceNG at: #biggerCursors)
		ifTrue: [ CursorWithAlpha biggerNormal ]
		ifFalse: [ self cursorAt: #normalCursorWithMask ].! !
!Cursor class methodsFor: 'current cursor' stamp: 'hlsf 5/12/2022 08:31:28' prior: 16834417!
    currentCursor: aCursor 
	"Make the instance of cursor, aCursor, be the current cursor. Display it. 
	Create an error if the argument is not a Cursor."

	CurrentCursor _ aCursor.
	(PreferenceNG at: #biggerCursors)
		ifTrue: [
			[ ^aCursor asBigCursor installCursor] 
				on: Error do: nil  "fall through "].
	aCursor installCursor! !
!Morph methodsFor: 'events' stamp: 'hlsf 5/12/2022 08:36:15' prior: 16892320!
    mouseLeave: evt
	"Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed.
	Note: a Morph must answer true to #handlesMouseOver: in order to receive this message."

	(PreferenceNG at: #focusFollowsMouse)
		ifTrue: [evt hand releaseKeyboardFocus: self].
	"Allow instances to dynamically use properties for handling common events."
	self 
		valueOfProperty: #mouseLeave: 
		ifPresentDo: [ :handler | handler value: evt ].! !
!Morph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 08:39:43' prior: 16893013!
         displayBoundsForHalo
	"Answer the rectangle to be used as the inner dimension of my halos.
	Allow for showing either bounds or fullBounds, and compensate for the optional bounds rectangle."

	^ (PreferenceNG at: #haloEnclosesFullBounds)
		ifFalse: [ self displayBounds ]
		ifTrue: [ self displayFullBounds ]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 5/12/2022 09:06:30' prior: 16893803!
           addHandlesTo: aHaloMorph box: box
	"Add halo handles to the halo.  Apply the halo filter if appropriate"

	(PreferenceNG at: #haloSpecifications) do: [ :aSpec |
		(self
			wantsHaloHandleWithSelector: aSpec addHandleSelector
			inHalo: aHaloMorph) ifTrue: [
		aHaloMorph
			perform: aSpec addHandleSelector
			with: aSpec ]].
	aHaloMorph target
		addOptionalHandlesTo: aHaloMorph
		box: box! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 5/12/2022 08:45:19' prior: 16893882!
                        haloShowsCoordinateSystem

	^PreferenceNG at: #halosShowCoordinateSystem! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 5/12/2022 08:30:10' prior: 16894003!
                      wantsBalloon
	"Answer true if receiver wants to show a balloon help text is a few moments."

	^ (self balloonText notNil) and: [PreferenceNG at: #balloonHelpEnabled]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'hlsf 5/12/2022 08:47:56' prior: 16894015!
                         wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"

	(#(addRecolorHandle:) statePointsTo: aSelector)
		ifTrue: ["FIXME - hack to disable for non-functional halo items"
			^ false].

	(PreferenceNG at: #selectiveHalos) ifFalse: [
		^true ].

	(#(#addDismissHandle: ) includes: aSelector)
		ifTrue: [ ^ self resistsRemoval not ].
	(#(#addDragHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToBrownDragEasily ].
	(#(#addResizeHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToResizeEasily | self okayToScaleEasily ].
	(#(#addRotateHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToRotateEasily ].
	(#(#addScaleHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToScaleEasily ].
	(#(#addRecolorHandle: ) includes: aSelector)
		ifTrue: [ ^ self wantsRecolorHandle ].
	^ true! !
!HandMorph methodsFor: 'double click support' stamp: 'hlsf 5/12/2022 08:49:45' prior: 16865619!
         waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel

	"Wait until the difference between click, or drag gesture is known, then inform the given morph what transpired." 

	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: nil
			click: clkSel
			clickAndHalf: nil
			dblClick: nil
			dblClickAndHalf: nil
			tripleClick: nil
			event: evt
			sendMouseButton2Activity: (PreferenceNG at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'double click support' stamp: 'hlsf 5/12/2022 08:49:57' prior: 16865640!
           waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel clkNHalf: clkNHalfSel dblClkSel: dblClkSel dblClkNHalfSel: dblClkNHalfSel tripleClkSel: tripleClkSel

	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'drag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or drag: methods." 

	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: nil
			click: clkSel
			clickAndHalf: clkNHalfSel
			dblClick: dblClkSel
			dblClickAndHalf: dblClkNHalfSel
			tripleClick: tripleClkSel
			event: evt
			sendMouseButton2Activity: (PreferenceNG at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'double click support' stamp: 'hlsf 5/12/2022 08:50:06' prior: 16865687!
         waitForClicksOrDragOrSimulatedMouseButton2: aMorph event: evt clkSel: clkSel clkNHalf: clkNHalfSel dblClkSel: dblClkSel dblClkNHalfSel: dblClkNHalfSel tripleClkSel: tripleClkSel dragSel: dragSel
	
	mouseClickState _
		MouseClickState new
			client: aMorph
			drag: dragSel
			click: clkSel
			clickAndHalf: clkNHalfSel
			dblClick: dblClkSel
			dblClickAndHalf: dblClkNHalfSel
			tripleClick: tripleClkSel
			event: evt
			sendMouseButton2Activity: (PreferenceNG at: #tapAndHoldEmulatesButton2).

	"It seems the Mac VM may occasionally lose button up events triggering bogus activations.
	Hence Preferences tapAndHoldEmulatesButton2"! !
!HandMorph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 08:32:17' prior: 16866137 overrides: 16909517!
                           morphPosition: aPoint
	"Change the position of this morph. Argument is in owner's coordinates."

	| prevTranslation |
	prevTranslation _ location translation.
	location _ location withTranslation: aPoint.
	"Ask if translation effectively changed, after possible conversion to 32 bit Float in AffineTransformation. "
	location translation = prevTranslation ifFalse: [
		self isDrawnBySoftware
			ifTrue: [
				(PreferenceNG at: #cacheDisplayContentWhenMovingMorphs)
					ifTrue: [
						"We are caching whatever is in the Display below us. Thefore, there's no need
						to do an invalidation that would trigger the redraw of everything below us."
						self needsRedraw: true ]
					ifFalse:  [
						"No caching of stuff below us. Just invalidate and redraw."
						self redrawNeeded ]]
			ifFalse: [
				lastPosition _ nil.		"Not nil if carrying morphs at that moment"
				prevFullBounds _ nil "Any saved patch is no longer relevant"]].! !
!HandMorph methodsFor: 'private events' stamp: 'hlsf 5/12/2022 08:34:34' prior: 16866442!
                        generateKeyboardEvent: evtBuf
	"Generate the appropriate mouse event for the given raw event buffer"
	| buttons modifiers type keyValue pressType stamp mouseScrollDirection |
	stamp _ evtBuf second.
	stamp = 0 ifTrue: [ stamp _ Time millisecondClockValue ]. "VMs report events using #millisecondClockValue"
	(evtBuf sixth <= 0 or: [ (keyValue _ Character iso8859s15CodeForUnicodeCodePoint: evtBuf sixth) isNil ]) ifTrue: [ keyValue _ Character macRomanToLatin1: evtBuf third ].
	Sensor peekEvent ifNotNil: [ :nxt |
		"start: Combining diacritical marks (i.e. accents in the Linux VM)"
		(nxt fourth = EventSensor eventKeyDown and: [ nxt third > 255 ]) ifTrue: [
			keyValue _ ((Character numericValue: keyValue) withDiacriticalMark: nxt third) iso8859s15Code.
			Sensor
				nextEvent;
				nextEvent;
				nextEvent ].
		"end: Combining diacritical marks (i.e. accents in the Linux VM)"
		"start: Spurious LF after CR on Ctrl-Enter on Windows VM"
		((evtBuf fourth = EventSensor eventKeyChar and: [ evtBuf third = 13 ]) and: [
			nxt fourth = EventSensor eventKeyChar and: [ nxt third = 10 ]]) ifTrue: [ Sensor nextEvent
			"print " ]].
	modifiers _ evtBuf fifth.
	pressType _ evtBuf fourth.
	pressType = EventSensor eventKeyDown ifTrue: [
		type _ #keyDown.
		lastKeyDownValue _ keyValue ].
	pressType = EventSensor eventKeyUp ifTrue: [
		(keyValue = 9 and: [(modifiers anyMask: 1) and: [Smalltalk platformName = 'unix']])
			ifTrue: [
				"Linux VMs don't generate shift-tab keystroke. Turn #keyUp into #keystroke"
				pressType _ EventSensor eventKeyChar ]
			ifFalse: [type _ #keyUp ]].
	pressType = EventSensor eventKeyChar ifTrue: [
		type _ #keystroke.
		"If Control key pressed, and the VM answers a code below 27,
		 it means it did the translation, convert it back to regular character:
		We want to handle the meaning of ctrl ourselves."
		(modifiers anyMask: 2) ifTrue: [ 											"Control key pressed"
			keyValue < 27 ifTrue: [ 										"But we don't want to do it for Home/End/PgUp/PgDn, just for alphabetic keys"
				lastKeyDownValue = keyValue ifFalse: [   									"If equal, real Home/End/PgUp/PgDn in Windows => don't translate"
					(keyValue + 64 = lastKeyDownValue or: [ "If Equal, Ctrl-alphabetic in Windows => do translate"
						lastKeyDownValue < 47 ]) ifTrue: [ 			"Not on windows. If less (not sure about the bound, but do not translate 48: tab on Mac), alphabetic on Mac => do translate"
						keyValue _ (modifiers anyMask: 1)
							ifTrue: [ keyValue + 64 ]
							ifFalse: [ keyValue + 96   						"shift not pressed: conver to lowercase letter" ]]]].
			"On Windows, ctrl-backSpace is reported as ctrl-forwardDelete. But keyDown is ok, so we can know and fix."
			(keyValue = 127 and: [ lastKeyDownValue = 8 ])
				ifTrue: [ keyValue _ 8 ].
			"Act as if command/alt was pressed for some usual Windows ctrl-key combinations"
			(self shouldControlEmulateAltFor: keyValue) ifTrue: [ modifiers _ modifiers bitOr: 8 ]].
		(modifiers anyMask: 8) ifTrue: [ 									"CmdAlt key pressed (or Control key pressed, and #shouldControlEmulateAltFor: just answered true)"
			(modifiers anyMask: 1) ifTrue: [								"Shift pressed"
				| i |
				"It seems that for ctrl-shifted keys and cmd-shifted keys, the VM incorrectly reports the UNSHIFTED character.
				Correct this, at least for common cmd-shortcuts, and for the US keyboard... Sigh...
				(This has only been observed on Mac VMs, but seems harmless if proper shifted character is reported (as in Linux), as this wil be NOP)
				(On Windows, the situation is even worse: ctrl-{ is not even reported as a keystroke event. Only keyDown and keyUp.)"
				"#($' $, $. $9 $0 $[ $]) -> #($'' $< $> $( $) ${) $}"
				i _ #[39 44 46 57 48 91 93 ] indexOf: keyValue.
				i > 0 ifTrue: [
					keyValue _ #[34 60 62 40 41 123 125] at: i ]]]].
	buttons _ modifiers bitShift: 3.
	"Linux and Windows VM send keyboard ctrl-upArrow and ctrl-downArrow when the user tries to scroll using the mouse wheel
	Mac VM sends cmd-option-ctrl-shift-upArrow and cmd-option-ctrl-shift-downArrow for trackpad vertical scroll gestures,
		and cmd-option-ctrl-shift-leftArrow and cmd-option-ctrl-shift-rightArrow for horizontal scroll gestures.
	This way of reporting scroll events by the VM also enables scrolling using the keyboard (actually, we can't tell if user gesture was on Mouse, Trackpad or Keyboard).
	But ctrl-shift and cmdAlt-shift are needed used for selecting while moving by word, line, etc.
	Additionally, #ctrlArrowsScrollHorizontally allows chosing between keyboard horizontal scroll and moving word by word in text editors."
	mouseScrollDirection _ nil.
	"Ctrl for Keyboard or Mouse wheel gestures. All modifiers for Trackpad gestures."
	(buttons = InputSensor controlKey or: [buttons = InputSensor cmdAltOptionCtrlShiftModifierKeys]) ifTrue: [
		keyValue = 30
			ifTrue: [mouseScrollDirection _ #up]
		ifFalse: [keyValue = 31
			ifTrue: [mouseScrollDirection _ #down]]].
	"Ctrl for Keyboard or Mouse wheel gestures, only if preference is set. All modifiers for Trackpad gestures."
	((buttons = InputSensor controlKey and: [PreferenceNG at: #ctrlArrowsScrollHorizontally]) or: [buttons = InputSensor cmdAltOptionCtrlShiftModifierKeys]) ifTrue: [
		keyValue = 28
			ifTrue: [mouseScrollDirection _ #left]
		ifFalse: [keyValue = 29
			ifTrue: [mouseScrollDirection _ #right]]].
	mouseScrollDirection ifNotNil: [
		^ MouseScrollEvent new
			setType: #mouseScroll
			position: self morphPosition
			direction: mouseScrollDirection
			buttons: buttons
			hand: self
			stamp: stamp ].
	^ KeyboardEvent new
		setType: type
		buttons: buttons
		position: self morphPosition
		keyValue: keyValue
		hand: self
		stamp: stamp! !
!WorldMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 08:32:25' prior: 16981916!
                     displayWorld
	"Update this world's display."

	| deferredUpdateVMMode allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"

	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time. ?? revisar."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvas.

	"Restore world canvas under hands and their carried morphs"
	Preferences cacheDisplayContentWhenMovingMorphs ifTrue: [
		hands do: [ :h | h restoreSavedPatchOn: canvas ]].

	"Update #displayBounds for all dirty morphs (marked as such with #redrawNeeded).
	Also add the updated bounds to aDamageRecorder, and update bounds of morphs carried by hand."
	canvas boundsFinderCanvas updateBoundsIn: self addDamageTo: damageRecorder.

	"repair world's damage on canvas"
	allDamage _ canvas drawWorld: self repair: damageRecorder.
	"allDamage ifNotNil: [Display border: allDamage width: 3 fillColor: Color random].	 'Debugging Aid'."
	canvas newClipRect: nil.

	"Check which hands need to be drawn.
	(they are not the hardware mouse pointer and carry morphs)"
	self handsToDrawForDamage: allDamage do: [ :h |
		(PreferenceNG at: #cacheDisplayContentWhenMovingMorphs)
			ifTrue: [ allDamage _ (h savePatchFrom: canvas) quickMerge: allDamage ]
			ifFalse: [ allDamage _ h displayFullBoundsForPatch quickMerge: allDamage ].
		canvas fullDrawHand: h .
		h needsRedraw: false ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		allDamage ifNotNil: [
			"Drawing was done to off-Display canvas. Copy content to Display"
			canvas showAt: self viewBox origin invalidRect: allDamage ]].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	allDamage ifNotNil: [
		DisplayScreen isDisplayExtentOk ifTrue: [
			Display forceToScreen: allDamage ]].! !
!WindowEdgeAdjustingMorph methodsFor: 'adjusting' stamp: 'hlsf 5/12/2022 08:33:10' prior: 16981053 overrides: 16878712!
            adjustOwnerAt: aGlobalPoint millisecondSinceLast: millisecondSinceLast

	self basicAdjustOwnerAt: aGlobalPoint.

	"If UI is becoming slow or is optimized for slow systems, resize without
	showing window contents, but only edges. But don't do it for rotated Windows!!"
	(owner isOrAnyOwnerIsRotated not and: [
		(PreferenceNG at: #cheapWindowReframe) or: [millisecondSinceLast > 200]]) ifTrue: [
			owner displayBounds newRectFrom: [ :f |
				self basicAdjustOwnerAt: Sensor mousePoint.
				owner morphPosition extent: owner morphExtentInWorld ]].! !
!StringRequestMorph methodsFor: 'private' stamp: 'hlsf 5/12/2022 08:36:26' prior: 16950396!
                              getUserResponseOrCancel: aBlock
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."
	| w delay done canceled |
	w _ self world.
	w isNil ifTrue: [^ response asString].
	done _ false.
	canceled _ false.
	(PreferenceNG at: #focusFollowsMouse) ifFalse: [self textBox focusText].
	acceptBlock _ [:aString| done _ true].
	cancelBlock _ [done _ true. canceled _ true].
	delay _ Delay forMilliseconds: 10.
	[done not and: [self isInWorld]] whileTrue: [ w doOneMinimalCycleNow. delay wait ].
	self delete.
	w doOneMinimalCycleNow.
	canceled ifTrue: [^ aBlock value].
	^ response asString! !
!StringRequestMorph class methodsFor: 'instance creation' stamp: 'hlsf 5/12/2022 08:36:31' prior: 16950452!
                   request: queryString centeredAt: aPoint initialAnswer: defaultAnswer validationBlock: validationBlock acceptBlock: acceptBlock cancelBlock: cancelBlock
	| answer |
	answer _ self newColumn
		setQuery: queryString
		initialAnswer: defaultAnswer;
		validationBlock: validationBlock;
		acceptBlock: acceptBlock;
		cancelBlock: cancelBlock.
	self runningWorld addMorph: answer centeredNear: aPoint - self deltaToTextPane.
	(PreferenceNG at: #focusFollowsMouse) ifFalse: [answer textBox focusText].
	^ answer! !
!PluggableScrollPane methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 08:35:19' prior: 16912324 overrides: 16911743!
             initialize
	
	"initialize the state of the receiver"
	super initialize.
	hideScrollBars _ #showIfNeeded.

	"initialize the receiver's scrollBars"
	scrollBar _ ScrollBar new model: self setValueSelector: #vScrollBarValue:.
	hScrollBar _ ScrollBar new model: self setValueSelector: #hScrollBarValue:.
	drawKeyboardFocusIndicator _ PreferenceNG at: #drawKeyboardFocusIndicator.
	self addMorph: scrollBar.
	self addMorph: hScrollBar.
	self updateScrollBarsBounds.
	self innerMorphClass ifNotNil: [ :contentsClass |
		self scroller: contentsClass new ].! !
!HierarchicalListMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 08:38:18' prior: 16867289 overrides: 16794207!
     drawOn: aCanvas

	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle 
			borderWidth: (PreferenceNG at: #focusIndicatorWidth)
			color: Theme current focusIndicator ]! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'hlsf 5/12/2022 08:36:37' prior: 16867406 overrides: 16892287!
                              mouseEnter: event
	super mouseEnter: event.
	(PreferenceNG at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!PluggableListMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 08:38:23' prior: 16910553 overrides: 16794207!
          drawOn: aCanvas
	super drawOn: aCanvas.

	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle
			borderWidth: (PreferenceNG at: #focusIndicatorWidth)
			color: Theme current focusIndicator ].! !
!PluggableListMorph methodsFor: 'events' stamp: 'hlsf 5/12/2022 08:36:41' prior: 16910777 overrides: 16892287!
  mouseEnter: event
	super mouseEnter: event.
	(PreferenceNG at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!TextModelMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 08:38:32' prior: 16969029 overrides: 16794207!
              drawOn: aCanvas
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"
	| bw bc |
	self flag: #todo.
	"Integrate this method with the Theme system. --cbr"
	super drawOn: aCanvas.
	bw _ PreferenceNG at: #focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [ "Put up feedback showing that code cannot be submitted in this state"
				bc _ Color tan ]
			ifFalse: [
				scroller hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Color red ]
					ifFalse: [
						scroller hasUnacceptedEdits ifTrue: [ bc _ Color red ]]]].
	(drawKeyboardFocusIndicator and: [ scroller hasKeyboardFocus ])
		ifTrue: [ bc ifNil: [ bc _ Theme current focusIndicator ]]
		ifFalse: [
			bc ifNotNil: [
				bc _ bc
					alphaMixed: 0.4
					with: Color white ]].
	bc ifNotNil: [
		aCanvas
			frameRectangle: self focusIndicatorRectangle
			borderWidth: bw
			color: bc ].! !
!TextModelMorph methodsFor: 'events' stamp: 'hlsf 5/12/2022 08:36:45' prior: 16969138 overrides: 16892287!
                            mouseEnter: event
	super mouseEnter: event.
	(PreferenceNG at: #focusFollowsMouse)
		ifTrue: [ event hand newKeyboardFocus: scroller ]! !
!SystemWindow methodsFor: 'menu' stamp: 'hlsf 5/12/2022 08:53:35' prior: 50344299!
   addTileResizerMenuTo: aMenu
	"We can look at preferences here to decide what too do"
	(PreferenceNG at: #tileResizerInWindowMenu) ifFalse: [
		aMenu add: 'resize full' 		action: #resizeFull icon: #resizeFullIcon;
		add: 'resize top' 				action: #resizeTop icon: #resizeTopIcon;
		add: 'resize left' 				action: #resizeLeft icon: #resizeLeftIcon;
		add: 'resize bottom' 			action: #resizeBottom icon: #resizeBottomIcon;
		add: 'resize right' 				action: #resizeRight icon: #resizeRightIcon;
		add: 'resize top left' 			action: #resizeTopLeft icon: #resizeTopLeftIcon;
		add: 'resize top right' 		action: #resizeTopRight icon: #resizeTopRightIcon;
		add: 'resize bottom left' 		action: #resizeBottomLeft icon: #resizeBottomLeftIcon;
		add: 'resize bottom right' 	action: #resizeBottomRight icon: #resizeBottomRightIcon]
	ifTrue: [ |resizeMorph|
		"Use embedded resize morph"
		resizeMorph _ TileResizeMorph new
							selectionColor: (self widgetsColor adjustSaturation: -0.2 brightness: 0.25) ;
							action: [:resize | |resizeMsg|
								resizeMsg _ ('resize', resize asPlainString capitalized) asSymbol.
								self perform: resizeMsg.
								aMenu delete];
							yourself.
		aMenu addMorphBack: resizeMorph].
	^aMenu.! !
!CodeWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 08:46:47' prior: 16821715!
                           buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	Preferences showAnnotations ifFalse: [
		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 08:46:54' prior: 16796970 overrides: 50354311!
     buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations code comment separator |
	code _ self buildMorphicCodePane.
	comment _ self buildMorphicCommentPane.
	separator _ LayoutAdjustingMorph new.
	comment separator: separator code: code.
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: code proportionalHeight: 0.5;
		addMorph: separator fixedHeight: Theme current layoutAdjusterThickness;
		addMorph: comment proportionalHeight: 0.5.
	Preferences showAnnotations ifFalse: [
		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!MessageSetWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 08:47:00' prior: 16886978 overrides: 50354336!
            buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	Preferences showAnnotations ifFalse: [
		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 08:47:05' prior: 16839570 overrides: 50354311!
    buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations twoRowsOfButtons h |
	twoRowsOfButtons _ LayoutMorph newColumn.
	h _ self defaultButtonPaneHeight.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		h _ self defaultButtonPaneHeight * 2.
		twoRowsOfButtons
			addMorph: self optionalButtonRow proportionalHeight: 1.0;
			addAdjusterMorph ].
	twoRowsOfButtons
		addMorph: self customButtonRow proportionalHeight: 1.0.
	codeAndButtons _ LayoutMorph newColumn.
	codeAndButtons
		addMorph: twoRowsOfButtons fixedHeight: h;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	Preferences showAnnotations ifFalse: [
		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!MenuMorph methodsFor: 'construction' stamp: 'hlsf 5/12/2022 08:55:25' prior: 16882629!
                       addItemsFromDictionaries: dataForMenuDicts
	"A menu constructor utility that uses Dictionaries with elements:
		#label - the name that displays in the menu
		#object - the target object. If nil, use defaultTarget. If a Symbol, send it as message to defaultTarget to get real target.
		#selector - the selector called on object when the menu item is selected
		#arguments - optional collection of arguments passed to the selector
		#balloonText - optional 'tool tip' style help text
		#icon-	optional icon selector or Form

	note, nil elements will add a line."
	| item wantsIcons |
	wantsIcons _ PreferenceNG at: #wantsMenuIcons.
	dataForMenuDicts do: [ :dict |
		dict
			ifNil: [ self addLine ]
			ifNotNil: [ | realTarget |
				realTarget _ dict at: #object ifAbsent: [defaultTarget].
				realTarget isSymbol ifTrue: [ realTarget _ defaultTarget perform: realTarget ].
				item _ (dict at: #label) isSymbol
					ifTrue: [
						self
							addUpdating: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ]
					ifFalse: [
						self
							add: (dict at: #label)
							target: realTarget
							action: (dict at: #selector)
							argumentList:
								(dict
									at: #arguments
									ifAbsent: [ #() ]) ].
				wantsIcons ifTrue: [
					dict
						at: #icon
						ifPresent: [ :symbolOrFormOrNil |
							item setIcon: symbolOrFormOrNil ]].
				dict
					at: #balloonText
					ifPresent: [ :balloonText |
						item setBalloonText: balloonText ].
			]]! !
!MenuMorph methodsFor: 'construction' stamp: 'hlsf 5/12/2022 08:47:16' prior: 16882701!
                          addStayUpIcons
	| closeButton pinButton w buttonHW |
	(PreferenceNG at: #optionalButtons) ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	buttonHW _ Theme current titleBarButtonsExtent x.
	closeButton _ PluggableButtonMorph model: self action: #delete.
	closeButton iconDrawSelector: #drawCloseIcon; color: `Color transparent`.
	pinButton _ PluggableButtonMorph model: self action: #stayUp.
	pinButton iconDrawSelector: #drawPushPinIcon; color: `Color transparent`.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 60.
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: buttonHW);
			color: `Color transparent`;
			addMorph: closeButton fixedWidth: buttonHW;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//7;
			addMorph: pinButton fixedWidth: buttonHW;
			addMorph: (BoxedMorph new noBorder color: `Color transparent`) fixedWidth: buttonHW//3).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'control' stamp: 'hlsf 5/12/2022 08:46:05' prior: 16882917!
       popUpAt: aPoint forHand: hand in: aWorld
	"Present this menu at the given point under control of the given hand.  Allow keyboard input into the menu."

	^ self 
		popUpAt: aPoint 
		forHand: hand 
		in: aWorld 
		allowKeyboard: (PreferenceNG at: #menuKeyboardControl)! !
!MenuMorph methodsFor: 'modal control' stamp: 'hlsf 5/12/2022 08:45:49' prior: 16883281!
                        invokeModal
	"Invoke this menu and don't return until the user has chosen a value.
	See example below on how to use modal menu morphs."
	^ self invokeModal: (PreferenceNG at: #menuKeyboardControl)

	"
	| menu sub entry |
	menu _ MenuMorph new.
	1 to: 3 do: [:i |
		entry _ 'Line', i printString.
		sub _ MenuMorph new.
		menu add: entry subMenu: sub.
		#('Item A' 'Item B' 'Item C')  do:[:subEntry|
			sub add: subEntry target: menu 
				action: #modalSelection: argument: {entry. subEntry}]].
	menu invokeModal.
	"! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'hlsf 5/12/2022 08:33:59' prior: 16897631 overrides: 16896679!
       dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| aMorphHandlesIt grabAMorph handledByInner |
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchWith: aMorph ].

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^ #rejected ].

	"Install the prospective handler for the receiver"
	aMorphHandlesIt _ false.
	grabAMorph _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isWorldMorph or: [
					self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self) ifTrue: [
				eventHandler _ aMorph.
				aMorphHandlesIt _ true ].
			"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
			self mouseButton1Pressed ifTrue: [
				aMorph owner ifNotNil: [ :o |
					(o allowsSubmorphDrag and: [ aMorph isSticky not ]) ifTrue: [
						grabAMorph _ true ]]]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ (aMorph rejectsEvent: self) not and: [ aMorph fullIncludesPixel: position ] ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt
			ifTrue: [ ^self sendEventTo: aMorph ]
			ifFalse: [
				(grabAMorph and: [ handledByInner not ]) ifTrue: [
					self hand
						waitForClicksOrDrag: aMorph event: self
						dragSel: (Preferences clickGrabsMorphs ifFalse: [#dragEvent:localPosition:])
						clkSel: (Preferences clickGrabsMorphs ifTrue: [#dragEvent:localPosition:]).
					"false ifTrue: [ self hand grabMorph: aMorph ]."
					(PreferenceNG at: #clickGrabsMorphs) ifFalse: [
						self shiftPressed
							ifTrue: [ aMorph is: #SystemWindow :: ifTrue: [ aMorph sendToBack ] ]
							ifFalse: [ aMorph activateWindow ] ].
					self wasHandled: true.
					^ self ]]].

	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'hlsf 5/12/2022 08:33:20' prior: 16896183!
                  fullDraw: aMorph
	"Draw the full Morphic structure on us"
	"We are already set with a proper transformation from aMorph owner's coordinates to those of our target form."

	aMorph visible ifFalse: [^ self].
	self into: aMorph.

	currentMorph layoutSubmorphsIfNeeded.

	currentMorph isKnownFailing ifTrue: [
		self canvasToUse drawCurrentAsError.
		self outOfMorph.
		^ self].

	(currentMorph isOwnedByHand and: [
			(PreferenceNG at: #cheapWindowReframe) and: [currentMorph is: #SystemWindow]]) ifTrue: [
		self drawCurrentAsOutline.
		self outOfMorph.
		^ self].

	"Draw current Morph and submorphs"	
	self canvasToUse drawCurrentAndSubmorphs.

	self outOfMorph! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 08:39:10' prior: 16971018!
                  fullScreenDeskMargin
	^ (PreferenceNG at: #fullScreenLeavesDeskMargins) ifTrue: [22] ifFalse: [0]! !
!Theme class methodsFor: 'user interface' stamp: 'hlsf 5/12/2022 08:57:48' prior: 16972033!
                               changeIcons

	(MenuMorph new defaultTarget: self)
		addTitle: 'Menu Icons';
		addStayUpIcons;
		add: 'Use icons for menu entries' action: #useMenuIcons;
		add: 'Don''t use icons for menu entries' action: #useNoMenuIcons;
		popUpInWorld: self runningWorld! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'hlsf 5/12/2022 08:46:18' prior: 16913583!
                            startUpWithCaption: captionOrNil
	"Display the menu, slightly offset from the cursor,
	so that a slight tweak is required to confirm any action."
	^ self 
		startUpWithCaption: captionOrNil 
		at: Sensor mousePoint 
		allowKeyboard: (PreferenceNG at: #menuKeyboardControl)! !

TileResizeMorph class removeSelector: #initialize!

!methodRemoval: TileResizeMorph class #initialize stamp: 'Install-5154-CuisCorePreferences-p1-HilaireFernandes-2022May12-hlsf.004.cs.st 5/16/2022 10:22:26'!
initialize

	Preferences
		addPreference: #tileResizerInWindowMenu
		category: #gui 
		default: true
		balloonHelp: 'If enabled, a tile resizer morph is embedded in windows menus.' withNewLines!

HaloMorph class removeSelector: #initialize!

!methodRemoval: HaloMorph class #initialize stamp: 'Install-5154-CuisCorePreferences-p1-HilaireFernandes-2022May12-hlsf.004.cs.st 5/16/2022 10:22:26'!
initialize
	"HaloMorph initialize"
	
	Preferences preferenceAt: #haloEnclosesFullBounds ifAbsent: [
		Preferences addPreference: #haloEnclosesFullBounds
			category: #halos
			default: false
			balloonHelp: 'if true, halos will enclose the full bounds of the target Morph, rather than just the bounds'
	].
 
	Preferences resetHaloSpecifications!

HaloMorph initialize!

TileResizeMorph initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5154-CuisCorePreferences-p1-HilaireFernandes-2022May12-hlsf.004.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 10:02:08 am'!
!Workspace methodsFor: 'shout styling' stamp: 'hlsf 5/12/2022 09:38:27' prior: 16981474!
shouldStyle

	^shouldStyle ifNil: [ PreferenceNG at: #shoutInWorkspaces]! !
!Workspace methodsFor: 'user interface support' stamp: 'hlsf 5/12/2022 09:40:42' prior: 16981510 overrides: 16968885!
                              allowStylingWithEmphasis
	"Disabled by default for faster styling of large contents, as text metrics are not affected by styling."

	^ PreferenceNG at: #stylingWithEmphasisInWorkspaces! !
!Workspace methodsFor: 'user interface support' stamp: 'hlsf 5/12/2022 09:26:49' prior: 16981557 overrides: 16968910!
              fullPrintIt

	^fullPrintIt ifNil: [ PreferenceNG at: #fullPrintItInWorkspaces]! !
!CodeProvider methodsFor: 'annotation' stamp: 'hlsf 5/12/2022 09:21:23' prior: 16820499!
                     annotationForClassDefinitionFor: aClass
	"Provide a line of content for an annotation pane, given that the receiver is pointing at the class definition of the given class."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'Class definition for ';
			nextPutAll: aClass name.
		(PreferenceNG at: #classAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#instanceMethodsCount] -> [
					strm
						print: (aClass theNonMetaClass selectors size);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (aClass theMetaClass selectors size);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (aClass theNonMetaClass linesOfCode);
						nextPutAll: ' total lines of code' ]
			}]].! !
!CodeProvider methodsFor: 'annotation' stamp: 'hlsf 5/12/2022 09:35:20' prior: 50344911!
                               annotationForSelector: aSelector ofClass: aClass 
	"Provide a line of content for an annotation pane, representing  
	information about the given selector and class"

	aSelector == #Comment
		ifTrue: [^ self annotationForClassCommentFor: aClass].
	aSelector == #Definition
		ifTrue: [^ self annotationForClassDefinitionFor: aClass].

	^ String streamContents: [ :strm |
		(PreferenceNG at: #methodAnnotations)
			do: [ :each |
				each caseOf: {
					[#firstComment] -> [
						strm nextPutAll: (aClass firstCommentAt: aSelector) ].
					[#masterComment] -> [
						strm nextPutAll: ((aClass supermostPrecodeCommentFor: aSelector) ifNil: ['']) ].
					[#documentation] -> [
						strm nextPutAll: ((aClass precodeCommentOrInheritedCommentFor: aSelector) ifNil: ['']) ].
					[#timeStamp] -> [ | stamp |
						stamp _ self timeStamp.
						strm nextPutAll: (stamp size > 0 ifTrue: [stamp] ifFalse: ['no timestamp'])].
					[#linesOfCode] -> [
						strm
							print: ((aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm | cm linesOfCode]);
							nextPutAll: ' lines of code' ].
					[#messageCategory] -> [
						strm nextPutAll: (( aClass organization categoryOfElement: aSelector) ifNil: ['']) ].
					[#sendersCount] -> [ | sendersCount |
						sendersCount _ Smalltalk numberOfSendersOf: aSelector.
						sendersCount _ sendersCount = 1
								ifTrue: ['1 sender']
								ifFalse: [sendersCount printString , ' senders'].
						strm nextPutAll: sendersCount ].
					[#implementorsCount] -> [ | implementorsCount |
						implementorsCount _ Smalltalk numberOfImplementorsOf: aSelector.
						implementorsCount _ implementorsCount = 1
								ifTrue: ['1 implementor']
								ifFalse: [implementorsCount printString , ' implementors'].
						strm nextPutAll: implementorsCount ].
					[#priorVersionsCount] -> [
						self addPriorVersionsCountForSelector: aSelector ofClass: aClass to: strm].
					[#priorTimeStamp] -> [ | stamp |
						stamp _ VersionsBrowser
								timeStampFor: aSelector
								class: aClass
								reverseOrdinal: 2.
						strm nextPutAll: 'prior timestamp: '; nextPutAll: (stamp ifNil: ['None']) ].
					[#packages] -> [
						(aClass compiledMethodAt: aSelector ifAbsent: nil) ifNotNil: [ :cm |
							(CodePackage packageOfMethod: cm methodReference ifNone: nil)
								ifNil: [ strm nextPutAll: 'in no package' ]
								ifNotNil: [ :codePackage |
									strm nextPutAll: 'in package '; nextPutAll: codePackage packageName ]]].
					[#changeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allChangeSets] -> [ | aList |
						aList _ ChangeSet allChangeSetsWithClass: aClass selector: aSelector.
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in change set']
									ifFalse: [strm nextPutAll: 'in change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no change set']].
					[#allBaseSystemChangeSets] -> [ | aList |
						aList _ (ChangeSet allChangeSetsWithClass: aClass selector: aSelector) select: [ :it | it isForBaseSystem ].
						aList notEmpty
							ifTrue: [ aList size = 1
									ifTrue: [strm nextPutAll: 'only in base system change set']
									ifFalse: [strm nextPutAll: 'in base system change sets:'].
								aList
									do: [:aChangeSet | strm nextPut: Character space; nextPutAll: aChangeSet name ]
									separatedBy: [ strm nextPut: $, ]]
							ifFalse: [strm nextPutAll: 'in no base system change set']].
					[#closuresInfo] -> [
						strm nextPutAll: (aClass closuresInfoAt: aSelector)].
					
				}]
			separatedBy: [ strm nextPutAll: self annotationSeparator ] ].! !
!CodeProvider methodsFor: 'annotation' stamp: 'hlsf 5/12/2022 09:41:18' prior: 16820660!
                      annotationForSystemCategory: aCategory
	"Provide a line of content for an annotation pane, given that the receiver is pointing at a System Category (i.e. a group of classes)."

	^ String streamContents: [ :strm |
		strm
			nextPutAll: 'System Category: ';
			nextPutAll: aCategory.
		(PreferenceNG at: #systemCategoryAnnotations) do: [ :each |
			strm nextPutAll: self annotationSeparator.
			each caseOf: {
				[#classCount] -> [
					strm
						print: (SystemOrganization listAtCategoryNamed: aCategory) size;
						nextPutAll: ' classes' ].
				[#instanceMethodsCount] -> [
					strm
						print: (SystemOrganization instanceMethodCountOf: aCategory);
						nextPutAll: ' instance methods' ].
				[#classMethodsCount] -> [
					strm
						print: (SystemOrganization classMethodCountOf: aCategory);
						nextPutAll: ' class methods' ].
				[#linesOfCode] -> [
					strm
						print: (SystemOrganization linesOfCodeOf: aCategory);
						nextPutAll: ' total lines of code' ]
			}]].! !
!CodeProvider methodsFor: 'contents' stamp: 'hlsf 5/12/2022 09:17:20' prior: 16820815!
              contentsSymbol
	"Answer a symbol indicating what kind of content should be shown for the method; for normal showing of source code, this symbol is #source.  A nil value in the contentsSymbol slot will be set to #source by this method"

	^ contentsSymbol ifNil: [
		contentsSymbol _ (PreferenceNG at: #browseWithPrettyPrint)
					ifTrue:
						[#prettyPrint]
					ifFalse:
						[#source]]! !
!CodeProvider methodsFor: 'diffs' stamp: 'hlsf 5/12/2022 09:26:00' prior: 16820999!
    defaultDiffsSymbol
	"Answer the code symbol to use when generically switching to diffing"

	^ (PreferenceNG at: #diffsWithPrettyPrint)
		ifTrue: [
			#prettyLineDiffs]
		ifFalse: [
			#lineDiffs]! !
!Browser methodsFor: 'class functions' stamp: 'hlsf 5/12/2022 09:29:13' prior: 16795241!
createInstVarAccessors
	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"
	self selectedClassOrMetaClass ifNotNil: [ :aClass |
		aClass instVarNames do: [ :aName | | newMessage setter |
			(aClass canUnderstand: aName asSymbol) ifFalse: [
				newMessage _ aName , '
	"Answer the value of ' , aName , '"

	^ ' , aName.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ].
			(aClass canUnderstand: (setter _ aName , ':') asSymbol) ifFalse: [
				newMessage _ setter , ' anObject
	"Set the value of ' , aName , '"

	' , aName , ' ' ,
					((PreferenceNG at: #leftArrowAssignmentsInGeneratedCode)
						ifTrue: [ '_' ]
						ifFalse: [ ':=' ]) , ' anObject'.
				aClass
					compile: newMessage
					classified: 'accessing'
					notifying: nil ]]]! !
!Browser class methodsFor: 'class list' stamp: 'hlsf 5/12/2022 09:30:51' prior: 16796883!
                           disableListClassesHierarchically
	
	^PreferenceNG at: #listClassesHierarchically put: false! !
!Browser class methodsFor: 'class list' stamp: 'hlsf 5/12/2022 09:31:05' prior: 16796889!
       enableListClassesHierarchically
	
	^PreferenceNG at: #listClassesHierarchically put: true! !
!Browser class methodsFor: 'class list' stamp: 'hlsf 5/12/2022 09:31:17' prior: 16796894!
         listClassesHierarchically
	
	^PreferenceNG at: #listClassesHierarchically! !
!CodeFileBrowser methodsFor: 'edit pane' stamp: 'hlsf 5/12/2022 09:17:27' prior: 16817913 overrides: 16796178!
    selectedMessage
	"Answer a copy of the source code for the selected message selector."

	| class selector answer |
	class _ self selectedClassOrMetaClass.
	selector _ self selectedMessageName.
	answer _ class sourceCodeAt: selector.
	(self classOrMetaClassOrganizer isRemoved: selector) ifTrue: [
		^ Text
			string: answer
			attribute: TextColor red ].
	(PreferenceNG at: #browseWithPrettyPrint) ifTrue: [
		answer _ class compilerClass new
						format: answer in: class notifying: nil ].
	self showingAnyKindOfDiffs ifTrue: [
		answer _ self
			methodDiffFor: answer
			selector: self selectedMessageName ].
	^ answer! !
!ChangeList methodsFor: 'initialization-release' stamp: 'hlsf 5/12/2022 09:25:35' prior: 16801399 overrides: 16920235!
                        initialize
	"Initialize a blank ChangeList.  Set the contentsSymbol to reflect whether diffs will initally be shown or not"

	contentsSymbol _ (PreferenceNG at: #diffsInChangeList)
		ifTrue:
			[self defaultDiffsSymbol]
		ifFalse:
			[#source].
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	listIndex _ 0.
	super initialize! !
!Debugger class methodsFor: 'class initialization' stamp: 'hlsf 5/12/2022 09:32:24' prior: 16838869!
                             openContext: aContext label: aString contents: contentsStringOrNil
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."

	<primitive: 19> "Simulation guard"

	(self errorRecursion not and: [PreferenceNG at: #logDebuggerStackToFile]) ifTrue:
		[Smalltalk logError: aString inContext: aContext to: 'CuisDebug'].
	ErrorRecursion ifTrue: [
		ErrorRecursion _ false.
		contentsStringOrNil
			ifNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString]
			ifNotNil: [
				self primitiveError: 'Can not open debugger due to recursion error.', 
					String newLineString, aString, String newLineString, contentsStringOrNil ]].
	ErrorRecursion _ true.
	[self informExistingDebugger: aContext label: aString.
	(Debugger context: aContext)
		openNotifierContents: contentsStringOrNil
		label: aString.] ensure: [ ErrorRecursion _ false ].
	Processor activeProcess suspend.
! !
!Debugger class methodsFor: 'opening' stamp: 'hlsf 5/12/2022 09:32:58' prior: 16838977!
         openInterrupt: aString onProcess: interruptedProcess
	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."
	| debugger |
	<primitive: 19> "Simulation guard"
	debugger _ self new.
	debugger
		process: interruptedProcess
		context: interruptedProcess suspendedContext.
	debugger externalInterrupt: true.

	(PreferenceNG at: #logDebuggerStackToFile) ifTrue:
		[(aString includesSubString: 'Space') & 
			(aString includesSubString: 'low') ifTrue: [
				Smalltalk logError: aString inContext: debugger interruptedContext to: 'LowSpaceDebug']].

	^ debugger
		openNotifierContents: nil
		label: aString
! !
!Debugger class methodsFor: 'opening' stamp: 'hlsf 5/12/2022 09:33:28' prior: 50341792!
              openOn: process context: context label: title fullView: bool
	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."
	| w |
	(PreferenceNG at: #logDebuggerStackToFile) ifTrue: [
		Smalltalk
			logError: title
			inContext: context
			to: 'CuisDebug' ].
	w := UISupervisor newProcessIfUI: process.
	"schedule debugger in deferred UI message to address redraw
	problems after opening a debugger e.g. from the testrunner."
	UISupervisor whenUIinSafeState: [
		[ | debugger |
		"In case an error in Morphic code got us here, ensure mouse focus has been released"
		true runningWorld ifNotNil: [ :rWorld |
			rWorld activeHand ifNotNil: [ :aHand |
				aHand releaseMouseFocus ]].
		debugger := self new
			process: process
			context: context.
		debugger interruptedProcessUI: w.
		bool
			ifTrue: [ debugger openFullMorphicLabel: title ]
			ifFalse: [
				PreDebugWindow
					open: debugger
					label: title
					message: nil ]]
			on: UnhandledError
			do: [ :exOuter | | errorDescription |
				errorDescription := 'Error while trying to open Debugger' , String newLineString , 'Orginal error: ' , title asPlainString , '.' , String newLineString , '	Debugger error: ' ,
					([ exOuter description ]
						on: UnhandledError
						do: [ :exInner |
							exInner return: 'a ' , exInner class printString ]) , ':'.
				self primitiveError: errorDescription ]].
	process suspend.! !
!Behavior methodsFor: 'testing method dictionary' stamp: 'hlsf 5/12/2022 10:01:09' prior: 16786773!
                          whichSelectorsReferTo: literal special: specialFlag byte: specialByte
	"Answer a set of selectors whose methods access the argument as a literal."

	| who |

	(PreferenceNG at: #thoroughSenders)
		ifTrue: [ who _ self thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte ]
		ifFalse: [ 
			who _ Set new.
			self selectorsAndMethodsDo: [:sel :method |
				((method hasLiteral: literal) or: [specialFlag and: [method scanFor: specialByte]]) ifTrue: [
					((literal isVariableBinding) not or: [method sendsToSuper not
					"N.B. (method indexOfLiteral: literal) < method numLiterals copes with looking for
					Float bindingOf: #NaN, since (Float bindingOf: #NaN) ~= (Float bindingOf: #NaN)."
						or: [(method indexOfLiteral: literal) ~= 0]]) ifTrue: [who add: sel]]]].
		
	^self rejectSelectorsFrom: who thatReferenceTo: literal byte: specialByte ! !
!Message methodsFor: 'stub creation' stamp: 'hlsf 5/12/2022 09:29:21' prior: 16883614!
                           addSetterCodeOn: stream 
						
	stream
		newLine; tab;
		nextPutAll: selector allButLast;
		nextPutAll: ((PreferenceNG at: #leftArrowAssignmentsInGeneratedCode)
			ifTrue: [ ' _ ' ]
			ifFalse: [ ' := ' ]);
		nextPutAll: self arguments first argumentName ! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'hlsf 5/12/2022 09:23:05' prior: 16953421!
                            logError: errMsg inContext: aContext to: baseFilename
	"Log the error message and a stack trace to the given file.
	Smalltalk logError: 'test error message' inContext: thisContext to: 'testErr.txt'
	"

	| localFilename file |
	localFilename _ (PreferenceNG at: #debugLogTimestamp)
		ifTrue: [ baseFilename, '-', Utilities dateTimeSuffix, '.log' ]
		ifFalse: [ baseFilename, '.log' ].
	file _ DirectoryEntry smalltalkImageDirectory // localFilename.
	[
		file forceWriteStreamDo: [ :stream |
	 	 	stream nextPutAll: errMsg; newLine.
			aContext errorReportOn: stream ]
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"
	[
 	 	StdIOWriteStream stdout newLine; nextPutAll: errMsg.
		StdIOWriteStream stdout newLine; nextPutAll: 'See '; nextPutAll: file pathName.
		StdIOWriteStream stdout newLine.
		aContext shortErrorReportOn: StdIOWriteStream stdout.
		StdIOWriteStream stdout flush
	] on: UnhandledError do: [ :ex | ex return]. "avoid recursive errors"! !
!BlockNode methodsFor: 'printing' stamp: 'hlsf 5/12/2022 09:35:47' prior: 16793104 overrides: 16906201!
      printOn: aStream indent: level
	| separateLines |
	aStream nextPut: $[.
	self
		printArgumentsOn: aStream
		indent: level.
	separateLines _ (self
		printTemporaries: temporaries
		on: aStream
		doPrior: [ aStream space ]) or: [arguments notNil and: [arguments notEmpty] ].
	(PreferenceNG at: #prettyPrintRectangularBlocks)
		ifTrue: [
			"If args+temps > 0 and statements > 1 (or just one complex statement),
			put all statements on separate lines"
			separateLines
				ifTrue: [
					(statements size > 1 or: [
						statements size = 1 and: [ statements first isComplex ]])
							ifTrue: [ aStream newLineTab: (1 max: level) ]
							ifFalse: [ aStream space ] ]
				ifFalse: [
					(statements size = 1 and: [ statements first isComplex not ])
						ifTrue: [ aStream space ]]]
		ifFalse: [
			self isComplex
				ifTrue: [ aStream newLineTab: (1 max: level) ]
				ifFalse: [ aStream space ] ].
	((self printStatementsOn: aStream indent: level) > 0 and: [ aStream peekLast ~= $] ])
		ifTrue: [ aStream space ].
	aStream nextPut: $]! !
!BlockNode methodsFor: 'testing' stamp: 'hlsf 5/12/2022 09:35:57' prior: 16793360 overrides: 16906470!
          printsInNewLine
	"Used for pretty printing to determine whether to start a new line"

	(PreferenceNG at: #prettyPrintRectangularBlocks) ifFalse: [ ^false ].
	^super printsInNewLine! !
!TempVariableNode methodsFor: 'testing' stamp: 'hlsf 5/12/2022 09:13:14' prior: 16960577 overrides: 16977637!
                          assignmentCheck: encoder at: location
	^((self isBlockArg and: [(PreferenceNG at: #allowBlockArgumentAssignment) not])
	    or: [self isMethodArg])
			ifTrue: [location]
			ifFalse: [-1]! !
!SmalltalkEditor methodsFor: 'menu messages' stamp: 'hlsf 5/12/2022 09:14:00' prior: 16940352!
   browseIt
	"Launch a browser for the current selection, if appropriate"

	| aSymbol anEntry |
	(PreferenceNG at: #alternativeBrowseIt) ifTrue: [^ self browseClassFromIt].

	self wordSelectAndEmptyCheck: [^ self].
	aSymbol _ self selectedSymbol ifNil: [
		self
			evaluateSelectionAndDo: [ :result | result class name ]
			ifFail: [ ^morph flash ]
			profiled: false].

	aSymbol first isUppercase
		ifTrue: [
			anEntry _ (Smalltalk
				at: aSymbol
				ifAbsent: [
					Smalltalk browseAllImplementorsOf: aSymbol.
					^ nil]).
			anEntry ifNil: [^ morph flash].
			(anEntry isKindOf: Class)
				ifFalse: [anEntry _ anEntry class].
			BrowserWindow fullOnClass: anEntry selector: nil]
		ifFalse:
			[Smalltalk browseAllImplementorsOf: aSymbol]! !
!StrikeFont methodsFor: 'synthetic derivatives' stamp: 'hlsf 5/12/2022 09:14:51' prior: 16946857!
                     syntheticST80Glyphs
	"Build and answer a derivative that includes ST-80 glyphs:
	a left arrow instead of the underscore, and an up arrow instead of the caret."

	| derivative |
	derivative _ self copy.
	derivative
		name: self name , 'ST80';
		perform: (PreferenceNG at: #assignmentGlyphSelector).
	^ derivative! !
!MorphicScanner methodsFor: 'scanning' stamp: 'hlsf 5/12/2022 09:16:43' prior: 16896836!
            displayLine: textLine textTopLeft: textTopLeft leftInRun: leftInRun
	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."

	"textTopLeft is relative to the morph currently being drawn"
	| stopCondition nowLeftInRun startIndex string lastPos x1 |

	topLeft _ textTopLeft.
	line _ textLine.
	lineY _ line top + textTopLeft y.
	rightMargin _ line rightMargin + textTopLeft x.
	lastIndex _ line first.
	tabCount _ 0.
	leftInRun <= 0 ifTrue: [
		self setFont.
		self setStopConditions ].
	leftMargin _ (line leftMarginForAlignment: alignment) + textTopLeft x.
	destX _ leftMargin.
	destY _ lineY + line baseline - font ascent.

	textLine isEmptyLine ifTrue: [
		textLine paragraphStyle ifNotNil: [ :ps |
			ps = paragraphStyle ifFalse: [
				foregroundColor _ defaultColor.
				self setActualFont: ps font.
				ps color ifNotNil: [ :color | self textColor: color ].
				alignment _ ps alignment.
				paragraphStyle _ ps.
				spaceWidth _ font widthOf: Character space.
				self setStopConditions.
				text ifNotNil: [ destY _ lineY + line baseline - font ascent ]]].
		self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.
		^leftInRun ].

	self displayBulletIfAppropriateFor: textLine textLeft: textTopLeft x.

	leftInRun <= 0
		ifTrue: [nowLeftInRun _ text runLengthFor: lastIndex]
		ifFalse: [nowLeftInRun _ leftInRun].
	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.
	spaceCount _ 0.
	string _ text string.

	self placeEmbeddedObject.
	[
		startIndex _ lastIndex.
		lastPos _ destX@destY.
		stopCondition _ self
			scanCharactersFrom: lastIndex to: runStopIndex
			in: string rightX: rightMargin stopConditions: stopConditions.
		backgroundColor ifNotNil: [
			x1 _ destX.
			((PreferenceNG at: #backgroundColorFillsAllBackground) and: [startIndex > line last]) ifTrue: [
				x1 _ rightMargin ].
			canvas
				fillRectangle: (lastPos corner: x1 @ (line bottom + textTopLeft y))
				color: backgroundColor.
			((PreferenceNG at: #backgroundColorFillsAllBackground) and: [stopCondition = #tab]) ifTrue: [
				canvas
					fillRectangle: (destX @ lastPos y corner: self tabDestX @ (line bottom + textTopLeft y))
					color: backgroundColor ]].
		lastIndex >= startIndex ifTrue: [
			canvas  
				drawString: string
				from: startIndex
				to: lastIndex
				at: lastPos
				font: font
				color: foregroundColor ].
		"see setStopConditions for stopping conditions for displaying."
		(self perform: stopCondition) ifTrue: [
			"Number of characters remaining in the current run"
			^ runStopIndex - lastIndex ]
	] repeat! !
!HaloMorph methodsFor: 'handles' stamp: 'hlsf 5/12/2022 09:22:10' prior: 16864714!
                            addDebugHandle: handleSpec

	(PreferenceNG at: #debugHaloHandle) ifTrue: [
		(self addHandle: handleSpec)
			mouseDownSelector: #doDebug:with: ]
! !
!HaloMorph methodsFor: 'handles' stamp: 'hlsf 5/12/2022 09:22:18' prior: 16864741!
                        addExploreHandle: handleSpec

	(PreferenceNG at: #debugHaloHandle) ifTrue: [
		(self addHandle: handleSpec)
			mouseDownSelector: #doExplore:with: ]
! !
!InnerHierarchicalListMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 09:40:03' prior: 16869745 overrides: 16794207!
               drawOn: aCanvas

	(PreferenceNG at: #showLinesInHierarchyViews) ifTrue:[
		self drawLinesOn: aCanvas ]! !
!InnerTextMorph methodsFor: 'private' stamp: 'hlsf 5/12/2022 09:41:56' prior: 16870752!
                              installEditorAndTextComposition
	"Install an editor for my textComposition. Install also the textComposition."
	| e tc |
	
	"Editor and TextComposition are assigned here atomically."
	e _ model editorClass new morph: self.
	e model: model.
	tc _ TextComposition new.
	"Keep critical section short"
	self mutex critical: [
		editor _ e.
		textComposition _ tc.
		tc
			setModel: model;
			extentForComposing: self extentForComposing.
		e textComposition: tc.
		tc editor: e ].
	e setEmphasisHereFromText.
	tc composeAll.
	e resetState.
	self fit.
	self selectionChanged.

	"Add extras. Text Styler and Autocompleter"
	self stylerClass:
		((PreferenceNG at: #syntaxHighlightingAsYouType) ifTrue: [
			model textStylerClass ]).
	self autoCompleterClass:
		model autoCompleterClass! !
!CodeWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:39:05' prior: 50354311!
                          buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(PreferenceNG at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!CodeWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:38:07' prior: 50339704!
                     buildMorphicCodePane
	"Construct the pane that shows the code.
	Respect the Preference for standardCodeFont."
	
	| codePane |
	
	codePane := self createCodePaneMorph.	
	(PreferenceNG at: #shiftClickShowsImplementors)
		ifTrue: [ self addShiftClickEventHandlerFor: codePane ].
		
	^codePane! !
!CodeWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:24:33' prior: 50337705!
  optionalButtonTuples
	"Answer a tuple buttons, in the format:
			button label
			selector to send
			help message"

	| aList textConstructor |
	textConstructor _ [ :string :backgroundColor | 
		string asText addAttribute: (TextBackgroundColor color: backgroundColor) ].

	aList _ #(
		(10	'browse'			browseMethodFull							'view this method in a browser')
		(11	'senders' 			browseSendersOfMessages							'browse senders of...' 						browseSendersOfMethod)
		(16	'implementors'			browseMessages							'browse implementors of...' 						browseImplementors)
		(12	'versions'			browseVersions							'browse versions')), 

		((PreferenceNG at: #decorateBrowserButtons)
			ifTrue: [
				{{13	. 'inheritance'.	 #methodInheritance. 	'Browse Method Inheritance

', (textConstructor value: 'green' value: `Color green muchLighter`),': sends to super
', (textConstructor value: 'tan' value: `Color tan`), ': has override(s)
', (textConstructor value: 'mauve' value: `Color blue muchLighter`), ': both of the above
', (textConstructor value: 'pink' value: `Color red muchLighter`), ': is an override but doesn''t call super
', (textConstructor value: 'pinkish tan' value: `Color r: 0.94 g: 0.823 b: 0.673`), ': has override(s), also is an override but doesn''t call super
'}}]
			ifFalse: [
				{#(13	'inheritance'		 methodInheritance	 'browse method inheritance')}]),

		#(
		(12	'hierarchy'			browseHierarchy							'browse class hierarchy')
		(10	'inst vars'			browseInstVarRefs							'inst var refs...')
		(11	'class vars'			browseClassVarRefs							'class var refs...')
		(10	'show...'			offerWhatToShowMenu							'menu of what to show in lower pane')).

	^ aList! !
!CodeWindow methodsFor: 'updating' stamp: 'hlsf 5/12/2022 09:24:21' prior: 16821977!
                decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	(PreferenceNG at: #decorateBrowserButtons)
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm is: #CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		`Color tan`.							"no sends to super. there is an override in some subclass"
		`Color red`.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		`Color red`.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		`Color red muchLighter`.			"doesn't have sub; has super but doesn't call it"
		`Color r: 0.94 g: 0.823 b: 0.673`.		"has sub; has super but doesn't call it"
		`Color green muchLighter`.			"doesn't have sub; has super and callsl it"
		`Color blue muchLighter`.			"has sub; has super and callsl it"

	} at: flags + 1.
	Theme current useUniformColors
		ifTrue: [
			aButton color: (self buttonColor mixed: 0.8 with: aColor) ]
		ifFalse: [
			aButton color: aColor ]! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:39:16' prior: 50354336 overrides: 50355519!
                              buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations code comment separator |
	code _ self buildMorphicCodePane.
	comment _ self buildMorphicCommentPane.
	separator _ LayoutAdjustingMorph new.
	comment separator: separator code: code.
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: code proportionalHeight: 0.5;
		addMorph: separator fixedHeight: Theme current layoutAdjusterThickness;
		addMorph: comment proportionalHeight: 0.5.
	(PreferenceNG at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!MessageSetWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:39:24' prior: 50354370 overrides: 50355670!
     buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations |
	codeAndButtons _ LayoutMorph newColumn.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		codeAndButtons
			addMorph: self optionalButtonRow fixedHeight: self defaultButtonPaneHeight;
			addAdjusterMorph ].
	codeAndButtons
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(PreferenceNG at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 09:39:33' prior: 50354395 overrides: 50355519!
                             buildLowerPanes
	| codeAndButtons codeButtonsAndAnnotations twoRowsOfButtons h |
	twoRowsOfButtons _ LayoutMorph newColumn.
	h _ self defaultButtonPaneHeight.
	(PreferenceNG at: #optionalButtons) ifTrue: [
		h _ self defaultButtonPaneHeight * 2.
		twoRowsOfButtons
			addMorph: self optionalButtonRow proportionalHeight: 1.0;
			addAdjusterMorph ].
	twoRowsOfButtons
		addMorph: self customButtonRow proportionalHeight: 1.0.
	codeAndButtons _ LayoutMorph newColumn.
	codeAndButtons
		addMorph: twoRowsOfButtons fixedHeight: h;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	(PreferenceNG at: #showAnnotations) ifFalse: [		^codeAndButtons ].
	codeButtonsAndAnnotations _ LayoutMorph newColumn.
	codeButtonsAndAnnotations
		addMorph: self buildMorphicAnnotationsPane fixedHeight: self defaultAnnotationPaneHeight;
		addAdjusterMorph;
		addMorph: codeAndButtons proportionalHeight: 1.0.
	^codeButtonsAndAnnotations! !
!Theme methodsFor: 'private - shout mappings' stamp: 'hlsf 5/12/2022 09:27:37' prior: 16971285!
        italic
	^(PreferenceNG at: #italicsInShout)
		ifTrue: [ #italic ]
		ifFalse: [ #normal ]! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'hlsf 5/12/2022 09:57:15' prior: 16930863 overrides: 16930632!
                      privateFormatAndConvert
	"Perform any formatting of formattedText necessary and store or a formatted copy in formattedText"
	(PreferenceNG at: #syntaxHighlightingAsYouTypeAnsiAssignment) ifTrue: [
		self convertAssignmentsToAnsi ].
	(PreferenceNG at: #syntaxHighlightingAsYouTypeLeftArrowAssignment) ifTrue: [
		self convertAssignmentsToLeftArrow ]! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'hlsf 5/12/2022 09:27:08' prior: 16930876 overrides: 16930636!
                  privateStyle

	| alpha end start count startIndexes c hue |
	self parseSetWorkspace: true.
	parser ranges ifNotNil: [ :ranges |
		self setAttributesFromRanges: ranges ].

	(PreferenceNG at: #highlightBlockNesting) ifTrue: [
		startIndexes _ parser blockDepthsStartIndexes.
		count _ startIndexes size.
		parser blockDepths withIndexDo: [ :depth :idx |
			start _ startIndexes at: idx.
			end _ idx = count ifTrue: [formattedText size] ifFalse: [ (startIndexes at: idx+1)-1].
			alpha _ depth / 10.0 min: 1.0.
			hue _ depth * 60.
			c _ Color h: hue s: 0.2 v: 0.5 alpha: alpha.
			formattedText 
				addAttribute: (ShoutTextBackgroundColor color: c ) 
				from: start 
				to: end ]]! !
!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'hlsf 5/12/2022 09:54:06' prior: 16930973!
             ansiAssignmentPreferenceChanged
	"the user has changed the syntaxHighlightingAsYouTypeAnsiAssignment setting.
	If they have turned it on then force syntaxHighlightingAsYouTypeLeftArrowAssignment
	to be turned off"
	(PreferenceNG at: #syntaxHighlightingAsYouTypeAnsiAssignment) 		ifTrue: [
		PreferenceNG at: #syntaxHighlightingAsYouTypeLeftArrowAssignment put: false]! !
!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'hlsf 5/12/2022 09:56:26' prior: 16931068!
         leftArrowAssignmentPreferenceChanged
	"the user has changed the syntaxHighlightingAsYouTypeLeftArrowAssignment setting.
	If they have turned it on then force syntaxHighlightingAsYouTypeAnsiAssignment
	to be turned off"
	(PreferenceNG at: #syntaxHighlightingAsYouTypeLeftArrowAssignment) 		ifTrue:[
		PreferenceNG at: #syntaxHighlightingAsYouTypeAnsiAssignment put: false]! !
!SHTextStylerST80 class methodsFor: 'class initialization' stamp: 'hlsf 5/12/2022 09:58:59' prior: 16931138 overrides: 16904184!
        initialize  
	"Clear styleTable and textAttributesByPixelSize cache so that they will 
	reinitialize.	 

		SHTextStylerST80 initialize
	" 
	
	styleTable := nil.
	textAttributes := nil.	
	"We want to be  informed at preference changes"
	(PreferenceNG instanceAt: #syntaxHighlightingAsYouTypeAnsiAssignment)
		when: #preferenceChanged
		send: #ansiAssignmentPreferenceChanged
		to: self.
	(PreferenceNG instanceAt: #syntaxHighlightingAsYouTypeLeftArrowAssignment)
		when: #preferenceChanged
		send: #leftArrowAssignmentPreferenceChanged
		to: self! !
!ExtractToTemporary methodsFor: 'private - applying steps' stamp: 'hlsf 5/12/2022 09:29:32' prior: 16852533!
              preferredAssignmentOperator

	^ (PreferenceNG at: #leftArrowAssignmentsInGeneratedCode)
		ifTrue: [ '_' ]
		ifFalse: [ ':=' ]! !

SHTextStylerST80 class removeSelector: #initializeSyntaxHighlightingAsYouTypeLeftArrowAssignment!

!methodRemoval: SHTextStylerST80 class #initializeSyntaxHighlightingAsYouTypeLeftArrowAssignment stamp: 'Install-5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st 5/16/2022 10:22:26'!
initializeSyntaxHighlightingAsYouTypeLeftArrowAssignment

	^ (Preferences preferenceAt: #syntaxHighlightingAsYouTypeLeftArrowAssignment) ifNil:[
		Preferences 
			addPreference: #syntaxHighlightingAsYouTypeLeftArrowAssignment
		 	categories: #(browsing)
			default: false 
			balloonHelp: 'If true, and syntaxHighlightingAsYouType is enabled,  all ANSI format assignments ( := ) will be converted to left arrows ( _ ) when a method is selected in a Browser. Whilst editing a method, this setting has no effect - both the left arrow and the ansi format may be used'.
			
		(Preferences preferenceAt: #syntaxHighlightingAsYouTypeLeftArrowAssignment)
			changeInformee: self 
			changeSelector: #leftArrowAssignmentPreferenceChanged ]!

SHTextStylerST80 class removeSelector: #initializeSyntaxHighlightingAsYouType!

!methodRemoval: SHTextStylerST80 class #initializeSyntaxHighlightingAsYouType stamp: 'Install-5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st 5/16/2022 10:22:26'!
initializeSyntaxHighlightingAsYouType

	(Preferences preferenceAt: #syntaxHighlightingAsYouType) ifNil:[
		Preferences 
			disable: #browseWithPrettyPrint.
		Preferences 
			addPreference: #syntaxHighlightingAsYouType
			categories: #(browsing)
			default: true 
			balloonHelp: 'Enable, or disable, Shout - Syntax Highlighting As You Type. When enabled, code in Browsers and Workspaces is styled to reveal its syntactic structure. When the code is changed (by typing some characters, for example), the styling is changed so that it remains in sync with the modified code']!

SHTextStylerST80 class removeSelector: #initializePreferences!

!methodRemoval: SHTextStylerST80 class #initializePreferences stamp: 'Install-5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st 5/16/2022 10:22:26'!
initializePreferences
	
	self
		initializeSyntaxHighlightingAsYouType;
		initializeSyntaxHighlightingAsYouTypeAnsiAssignment;
		initializeSyntaxHighlightingAsYouTypeLeftArrowAssignment.!

SHTextStylerST80 class removeSelector: #initializeSyntaxHighlightingAsYouTypeAnsiAssignment!

!methodRemoval: SHTextStylerST80 class #initializeSyntaxHighlightingAsYouTypeAnsiAssignment stamp: 'Install-5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st 5/16/2022 10:22:26'!
initializeSyntaxHighlightingAsYouTypeAnsiAssignment

	(Preferences preferenceAt: #syntaxHighlightingAsYouTypeAnsiAssignment) ifNil:[
		Preferences 
			addPreference: #syntaxHighlightingAsYouTypeAnsiAssignment
			categories: #(browsing)
			default: false 
			balloonHelp: 'If true, and syntaxHighlightingAsYouType is enabled,  all left arrow assignments ( _ ) will be converted to the ANSI format ( := ) when a method is selected in a Browser. Whilst editing a method, this setting has no effect - both the left arrow and the ansi format may be used'.
			
		(Preferences preferenceAt: #syntaxHighlightingAsYouTypeAnsiAssignment)
			changeInformee: self
			changeSelector: #ansiAssignmentPreferenceChanged]!

Parser class removeSelector: #initialize!

!methodRemoval: Parser class #initialize stamp: 'Install-5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st 5/16/2022 10:22:26'!
initialize
	"
	Parser initialize
	"
	Preferences
		addPreference: #allowBlockArgumentAssignment 
		category: #compiler 
		default: false
		balloonHelp: 'If enabled, the compiler will allow assignment into block arguments.\This provides backward compatibility with the pre-closure compiler.' withNewLines!

Parser initialize!

SHTextStylerST80 initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5155-CuisCorePreferences-p2-HilaireFernandes-2022May12-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 10:40:55 am'!
!FileList methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 10:25:53' prior: 16855258!
                      initialDirectoryList

	| initialDirectoryListFromPreferences wrapperCreator |
	wrapperCreator _ [ :directoryEntry |
		FileDirectoryWrapper
			with: directoryEntry
			name: (directoryEntry name ifNil: [ '/' ])
			model: self ].
	(initialDirectoryListFromPreferences _ PreferenceNG at: #initialFileListDirectories) 
		caseOf: {
			[ #roots ] -> [ 	| dirList |
				dirList _ DirectoryEntry roots collect: wrapperCreator.
				dirList isEmpty ifTrue: [
					dirList _ Array with: (FileDirectoryWrapper 
						with: directory
						name: directory localName 
						model: self) ].
				^ dirList ].
			[ #image ] -> [ 
				^ { wrapperCreator value: DirectoryEntry smalltalkImageDirectory } ].
			[ #vm  ] -> [ 
				^ { wrapperCreator value: DirectoryEntry vmDirectory } ].
			[ #current ] -> [
				^ { wrapperCreator value: DirectoryEntry currentDirectory } ] }
		otherwise: [ ^ initialDirectoryListFromPreferences collect: wrapperCreator ]! !
!SystemDictionary methodsFor: 'miscellaneous' stamp: 'hlsf 5/12/2022 10:24:46' prior: 50335735!
                       handleUserInterrupt
	| p |
	"Shift can only be detected on the Mac, due to likely buggy kestroke reporting..."
	p _ UISupervisor newUIProcessIfNeeded.
	p ifNil: [
		p _ Sensor shiftPressed | (PreferenceNG at: #cmdDotInterruptTakesStatistics)
			ifTrue: [Utilities reportCPUandRAM]
			ifFalse: [Utilities processTakingMostCPU]].
	(PreferenceNG at: #cmdDotEnabled) ifTrue: [
		"The background process can't be interrupted, or Cuis will likely crash."
		p == Processor backgroundProcess ifTrue: [
			'Can not interrupt backgroundProcess' print.
			^self ].
		(p name beginsWith: '[system]') ifTrue: [
			 ('Process {', p printString, '} is critical for system stability. Can not interrupt it.') print.
			^self ].
		[
			EventSensor install.
			p isTerminated
				ifTrue: [ ('Process {', p printString, '} isTerminated. Can not interrupt it.') print ]
				ifFalse: [ UISupervisor userInterrupt: p ]] fork
		]! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'hlsf 5/12/2022 10:36:58' prior: 16954413!
                       abandonSources
	"
	Smalltalk abandonSources
	"
	 | m bTotal bCount |
	(self confirm:
'This method will detach the image fom source code.
A fresh changes file will be created to record further changes.
-- CAUTION --
If you have backed up your system and
are prepared to face the consequences of
abandoning source code files, choose Yes.
If you have any doubts, you may choose No
to back out with no harm done.')
		==  true ifFalse: [^ self inform: 'Okay - no harm done'].
	bTotal _ 0.  bCount _ 0.
	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].
'Doing #destroySourcePointer ...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: bTotal
	during: [ :barBlock |
		Smalltalk allBehaviorsDo: [ :cl |
		"for testing"
		"{ EllipseMorph } do: [ :cl |"
			barBlock value: (bCount _ bCount + 1).
			cl selectors do: [:selector |
				m _ cl compiledMethodAt: selector.
				m destroySourcePointer ]]].
	Smalltalk allBehaviorsDo: [:b | b zapOrganization].
	Smalltalk closeSourceFiles.
	PreferenceNG at: #warnIfNoChangesFile put: false.
	PreferenceNG at: #warnIfNoSourcesFile put: false! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'hlsf 5/12/2022 10:07:51' prior: 16954770!
                               askConfirmationOnQuit
	"Answer true unless the user cancels quitting because of some warning given.
	Smalltalk askConfirmationOnQuit
	"
	| baseCSdirty dirtyPackages |
	baseCSdirty _ ChangeSet allChangeSets anySatisfy: [ :any | any isForBaseSystem and: [ any hasUnsavedChanges ]].
	"dirtyPackages _ CodePackage installedPackages anySatisfy: [ :pck | pck hasUnsavedChanges ]."
	dirtyPackages _ ChangeSet allChangeSets anySatisfy: [ :any | any codePackage notNil and: [ any hasUnsavedChanges ]].
	baseCSdirty & dirtyPackages ifTrue: [
		^self confirm: 'There are both unsaved Packages', String newLineString,
			'and unsaved Changes to Cuis core.', String newLineString,
			'If you continue, all unsaved changes will be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	baseCSdirty ifTrue: [
		^self confirm: 'Some ChangeSet for Cuis core have unsaved changes.', String newLineString,
			'If you continue, they would be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	dirtyPackages ifTrue: [
		^self confirm: 'There are unsaved Packages.', String newLineString,
			'If you continue, their changes will be lost.', String newLineString,
			'Do you really want to exit Cuis without saving the image?' ].
	(PreferenceNG at: #askConfirmationOnQuit) ifTrue: [
		^self confirm: 'Do you really want to exit Cuis without saving the image?' ].
	^true! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'hlsf 5/12/2022 10:15:03' prior: 16955257!
                               setPlatformPreferences
	"Set some platform specific preferences on system startup"
	| platform specs |
	(PreferenceNG at: #automaticPlatformSettings) ifFalse:[^self].
	platform _ self platformName.
	specs _ 	#(	
					(soundStopWhenDone false)
					(soundQuickStart false)
			).
	platform = 'Win32' ifTrue:[
		specs _ #(	
					(soundStopWhenDone true)
					(soundQuickStart false)
				)].
	platform = 'Mac OS' ifTrue:[
		specs _ #(	
					(soundStopWhenDone false)
					(soundQuickStart true)
				)].
	specs do: [:tuple |
		PreferenceNG name: tuple first category: #system value: (tuple last == #true) 	]
! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'hlsf 5/12/2022 10:15:33' prior: 50342466!
                           assureStartupStampLogged
	"If there is a startup stamp not yet actually logged to disk, do it now."
	| changesFile directory oldUserChanges oldUserChangesName |
	StartupStamp ifNil: [^ self].
	(SourceFiles notNil and: [(changesFile _ SourceFiles at: 2) notNil]) ifTrue: [
		changesFile isReadOnly ifFalse: [
			changesFile setToEnd; newLine; newLine.
			changesFile nextChunkPut: StartupStamp; newLine.
			self forceChangesToDisk ]].
	(PreferenceNG at: #autoNumberUserChanges) ifTrue: [
		oldUserChanges _ Smalltalk defaultUserChangesName asFileEntry.
		oldUserChanges exists ifTrue: [
			directory _ oldUserChanges parent.
			oldUserChangesName _ directory nextNameFor: oldUserChanges nameWithoutExtension extension: 'changes'.
			oldUserChanges rename: oldUserChangesName ]].
	Smalltalk defaultUserChangesName asFileEntry appendStreamDo: [ :stream |
		stream newLine; newLine.
		stream nextChunkPut: StartupStamp; newLine ].
	StartupStamp _ nil! !
!SystemDictionary methodsFor: 'sources, change log' stamp: 'hlsf 5/12/2022 10:39:43' prior: 16955794!
    openSourcesAndChanges
	"Open the changes and sources files and install them in SourceFiles. Inform the user of problems regarding write permissions or Lf/CrLf mixups."
	"Note: SourcesName and imageName are full paths; changesName is a  
	local name."
	| sources changes msg wmsg entry |
	msg _ 'Cuis cannot locate XfileRef
Please check that the file is named properly and is in the
same directory as this image.'.
	wmsg _ 'Cuis cannot write to XfileRef.

Please check that you have write permission for this file.

You won''t be able to save this image correctly until you fix this.'.

	"Do not open source files if internalized (i.e. notNil)"
	sources _ SourceFiles at: 1.
	sources ifNil: [
		entry _ Smalltalk defaultSourcesName asFileEntry.
		entry exists ifFalse: [
			entry _ Smalltalk alternativeSourcesName asFileEntry ].
		entry exists ifTrue: [
			sources _ [ entry readStream ] on: FileDoesNotExistException do: [ nil ]]].
	(sources isNil and: [ PreferenceNG at: #warnIfNoSourcesFile ])
		ifTrue: [
			Smalltalk platformName = 'Mac OS' ifTrue: [
				msg _ msg , String newLineString, 'Make sure the sources file is not an Alias.'].
			self inform: (msg copyReplaceAll: 'XfileRef' with: 'the sources file named ' , entry pathName) ].

	"Do not open source files if internalized (i.e. notNil)"
	changes _ (SourceFiles at: 2) ifNil: [ 
		entry _ Smalltalk defaultChangesName asFileEntry.
		[ entry appendStream ] on: FileWriteError do: [ nil ] ].
	(changes isNil and: [PreferenceNG at: #warnIfNoChangesFile])
		ifTrue: [self inform: (wmsg copyReplaceAll: 'XfileRef' with: 'the changes file named ' , entry pathName)].
	ChangesInitialFileSize _ changes ifNotNil: [ changes position ].

	SourceFiles _ Array with: sources with: changes! !
!SystemDictionary methodsFor: 'startup - restore lost changes' stamp: 'hlsf 5/12/2022 10:21:15' prior: 16958056!
                               hasToRestoreChanges

	^(PreferenceNG at: #checkLostChangesOnStartUp) and: [ 
		self withChangesFileDo: [ :changesFile | self hasToRestoreChangesFrom: changesFile ]].
	! !
!Exception methodsFor: 'priv handling' stamp: 'hlsf 5/12/2022 10:36:08' prior: 16849940!
                            evaluateHandlerBlock: aBlock

	| handlerEx |
	handlerBlockNotCurtailed := false.
	^[
			| answer |
			answer _ [aBlock valueWithPossibleArgument: self] on: Exception do: [:ex | handlerEx _ ex.  ex pass].
			signalContext := nil.	"To enable recycling of exceptions, but only after handler block has finished execution."
			handlerBlockNotCurtailed _ true.
			answer
	] ifCurtailed:
		[
			signalContext := nil.	"To enable recycling of exceptions, but only after handler block has finished execution."
			(handlerBlockNotCurtailed not and: [handlerEx isNil or: [handlerEx handlerBlockNotCurtailed not]])
				ifTrue: [
					"Please see
					https://lists.cuis.st/mailman/archives/cuis-dev/2019-October/000800.html
					https://lists.cuis.st/mailman/archives/cuis-dev/2019-October/000809.html
					Also see the rest of the tread in detail.
					This is work in progress."
					(PreferenceNG at: #allowNonLocalReturnsInExceptionHandlers)
						ifFalse: [ self error: 'Exception handler blocks must not do non local returns' ]
						ifTrue: [
							(PreferenceNG at: #warnAboutNonLocalReturnsInExceptionHandlers)
								ifTrue: [ 'It is advisable to avoid method returns (non local returns) in exception handler blocks' print ].
							handlerBlockNotCurtailed _ true ].
					]
				ifFalse: [handlerBlockNotCurtailed _ true]
		]! !
!NegativePowerError methodsFor: 'exceptionDescription' stamp: 'hlsf 5/12/2022 10:11:31' prior: 16898872 overrides: 16780646!
                   defaultAction

	"Disable this preference to have Float nan answer (if Float receiver or argument) or Error message"
	| answer |
	(PreferenceNG at: #askToInstallComplexPackage) ifTrue: [
		answer _ PopUpMenu
			withCaption:
'Square (or even) Root of a negative Number:
Complex number support is not loaded
Would you like me to load it for you now?'
			chooseFrom: #(
				'Load Complex package'
				'Do not load Complex package'
				'Do not load Complex package and don''t ask again').
		answer = 1 ifTrue: [
			Feature require: #'Complex'.
			Smalltalk at: #Complex ifPresent: [ :cplx |
				^ (cplx basicReal: receiver imaginary: 0) perform: selector withArguments: arguments ]].
		answer = 3 ifTrue: [
			(PreferenceNG at: #askToInstallComplexPackage put: false)]].
	^ super defaultAction! !
!Editor methodsFor: 'private' stamp: 'hlsf 5/12/2022 10:33:01' prior: 16846270!
                        setIndices: shiftPressed forward: forward
	"Little helper method that sets the moving and fixed indices according to some flags."
	| indices |
	indices _ Dictionary new.
	(shiftPressed and:[PreferenceNG at: #selectionsMayShrink])
		ifTrue: [
			indices at: #moving put: self pointIndex.
			indices at: #fixed put: self markIndex
		] ifFalse: [
			forward
				ifTrue:[
					indices at: #moving put: self stopIndex.
					indices at: #fixed put: self startIndex.
				] ifFalse: [
					indices at: #moving put: self startIndex.
					indices at: #fixed put: self stopIndex.
				]
		].
	^indices! !
!TextEditor methodsFor: 'private' stamp: 'hlsf 5/12/2022 10:16:35' prior: 50348311!
                           findAndReplaceOnce: indexStream
	"Find the next occurrence of FindText.  If none, answer false.
	Append the start index of the occurrence to the stream indices, and, if
	ChangeText is not the same object as FindText, replace the occurrence by it.
	Note that the search is case-sensitive for replacements, otherwise not."
	"This is a user command, and generates undo"

	| where |
	where _ model actualContents
		findString: self class findText
		startingAt: self stopIndex
		caseSensitive: ((self class changeText ~~ self class findText) or: [PreferenceNG at: #caseSensitiveFinds]).
	where = 0 ifTrue: [^ false].

	self selectFrom: where to: where + self class findText size - 1.	"Repeat it here. Senders beware: only one of these should last"

	self class changeText ~~ self class findText ifTrue: [ self replaceSelectionWith: self class changeText ].
	indexStream nextPut: where.
	^ true! !
!WorldMorph methodsFor: 'update cycle' stamp: 'hlsf 5/12/2022 10:33:25' prior: 16982541!
           doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	"
	'Debugging Aid. Declare Delta either as a class variable or as a global variable. Declare delta and r as locals'.
	delta _ Time localMillisecondClock - lastCycleTime.
	r _ 15@1515 extent: 60@30.
	Delta _ Delta ifNil: [ delta ] ifNotNil: [ Delta * 0.9 + (delta * 0.1) ].
	Random next > 0.9 ifTrue: [
		Display fill: r fillColor: Color white.
		(Delta printStringFractionDigits: 1) displayAt: 20@1520.
		Display forceToScreen: r ].
	"
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	(lastCycleHadAnyEvent or: [ deferredUIMessages isEmpty not ])
		ifTrue: [
			pause _ 20.				"This value will only be used later, when there are no more events to serve or deferred UI messages to process."
			wait _ 0.				"Don't wait this time"]
		ifFalse: [
			"wait between 20 and 200 milliseconds"
			(hands anySatisfy: [ :h | h waitingForMoreClicks ])
				ifTrue: [ pause _ 20 ]
				ifFalse: [ pause < 200 ifTrue: [ pause _ pause * 21//20 ] ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].
			wait _ waitUntil - Time localMillisecondClock max: 0 ].
	(PreferenceNG at: #serverMode)
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait = 0
		ifTrue: [ Processor yield ]
		ifFalse: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow.! !
!SystemWindow methodsFor: 'events' stamp: 'hlsf 5/12/2022 10:34:28' prior: 16959177 overrides: 16892107!
                       wantsToBeDroppedInto: aMorph
	"Return true if it's okay to drop the receiver into aMorph"
	^aMorph isWorldMorph or:[PreferenceNG at: #systemWindowEmbedOK]! !
!SystemWindow methodsFor: 'open/close' stamp: 'hlsf 5/12/2022 10:25:09' prior: 16959667!
         closeBoxHit
	"The user clicked on the close-box control in the window title.  For Mac users only, the Mac convention of option-click-on-close-box is obeyed if the mac option key is down."

	(PreferenceNG at: #dismissAllOnOptionClose) ifTrue:
		[Sensor rawMacOptionKeyPressed ifTrue:
			[^ self world closeUnchangedWindows]].
	self delete
! !
!FileListWindow methodsFor: 'menu building' stamp: 'hlsf 5/12/2022 10:29:53' prior: 16856136!
            volumeMenu
	| aMenu initialDirectoriesMenu  |
	aMenu _ MenuMorph new defaultTarget: model.
	aMenu
		add: 'delete directory...'
		action: #deleteDirectory
		icon: #warningIcon :: setBalloonText: 'Delete the selected directory'.
	model currentDirectorySelected
		ifNil: [ aMenu add: 'initial directory' action: #yourself :: isEnabled: false ]
		ifNotNil: [ :selectedWrapper |
	aMenu 
		add: (Preferences isInitialFileListDirectory: selectedWrapper item)
			asMenuItemTextPrefix, 'initial directory'
		action: #toggleInitialDirectory ::
			setBalloonText: 'The selected directory is an initial director for new file list windows' ].
	initialDirectoriesMenu _ MenuMorph new.
	#(
		(roots  'default roots' 'Use the usual root directories. Drives on Windows; "/" on Unix')
	   	(image 'image directory' 'Use the directory with Smalltalk image')
		(vm 'VM directory' 'Use the virtual machine directory')
		(current 'current directory' 'Use the current directory; usually the directory the VM was started in')
	)
		do: [ :entry |
			initialDirectoriesMenu
				add: entry second
				target: PreferenceNG
				action: #at:put:
				argumentList: {#initialFileListDirectories . entry first} ::
					setBalloonText: entry third ].
	aMenu add: 'default initial directories' subMenu: initialDirectoriesMenu.
	^ aMenu! !
!MenuMorph methodsFor: 'control' stamp: 'hlsf 5/12/2022 10:34:41' prior: 16882980 overrides: 16892107!
 wantsToBeDroppedInto: aMorph
	"Return true if it's okay to drop the receiver into aMorph.  A single-item MenuMorph is in effect a button rather than a menu, and as such should not be reluctant to be dropped into another object."

	^ (aMorph isWorldMorph or: [submorphs size = 1]) or:
		[PreferenceNG at: #systemWindowEmbedOK]! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'hlsf 5/12/2022 10:18:30' prior: 50346889!
 fileOut
	"File out the receiver, to a file whose name is a function of the  
	change-set name and either of the date & time or chosen to have a  
	unique numeric tag, depending on the preference  
	'changeSetVersionNumbers'"
	| slips nameToUse |
	nameToUse _ self name.
	nameToUse _ nameToUse copyReplaceAll: 'AuthorName' with: Utilities authorName asUnaccented asCamelCase.
	nameToUse _ (PreferenceNG at: #changeSetVersionNumbers)
				ifTrue: [
					DirectoryEntry currentDirectory
						nextNameFor: nameToUse coda: '-', Utilities authorInitials
						extension: 'cs.st' ]
				ifFalse: [ (nameToUse , '.' , Utilities dateTimeSuffix , '.cs.st') asFileName ].
		
	nameToUse asFileEntry writeStreamDo: [ :stream |
		stream timeStamp.
		self fileOutPreambleOn: stream.
		self fileOutOn: stream.
		self fileOutPostscriptOn: stream ].
	
	self hasUnsavedChanges: false.
	(PreferenceNG at: #checkForSlips) 		ifFalse: [^ self].
	slips _ self checkForSlips.
	(slips notEmpty
			and: [(PopUpMenu withCaption: 'Methods in this fileOut have halts
or references to the Transcript
or other ''slips'' in them.
Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')
					= 2])
		ifTrue: [ Smalltalk browseMessageList: slips name: 'Possible slips in ' , name ]! !
!ChangeSet class methodsFor: 'services' stamp: 'hlsf 5/12/2022 10:35:05' prior: 16806870!
                          install: aFileEntry
	"File in the entire contents of the file specified by the name provided.
	Do not affect the user change sets, store changes in separate one"

	ChangeSet installing: aFileEntry name do: [ self fileIn: aFileEntry ].
	(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
		('Installed ChangeSet: ', aFileEntry name) print]! !
!CodeFile methodsFor: 'fileIn/fileOut' stamp: 'hlsf 5/12/2022 10:35:10' prior: 16817519!
                 fileIn
	| doitsMark |
	doitsMark := 1.
	doIts isEmpty ifFalse:[doitsMark := self askForDoits].
	doitsMark = 4 ifTrue: [^nil].
	doitsMark = 2 ifTrue:[self fileInDoits].
	classOrder do:[:cls|
		cls fileInDefinition.
	].
	classes do:[:cls|
		(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
			Transcript newLine; show:'Filing in ', cls name].
		cls fileInMethods.
		cls hasMetaclass ifTrue:[cls theMetaClass fileInMethods].
	].
	doitsMark = 3 ifTrue: [ self fileInDoits ]! !
!CodePackageFile methodsFor: 'services' stamp: 'hlsf 5/12/2022 10:35:17' prior: 16819656!
           install
	"Create, install and answer a (sub)instance of CodePackage
	Replace all existing code in the possibly existing CodePackage, removing any code that is not included in us."
	| localName newCodePackage pckClass currentCS |

	localName _ fullName asFileEntry name.
	ChangeSet installing: packageName do: [
		"This change set will capture a possible class definition for a subclass of CodePackage.
		If it only has that, then remove it after package install.
		One example needing this is 'Color-Extras.pck.st'"
		currentCS _ ChangeSet changeSetForBaseSystem.
		currentCS isEmpty ifFalse: [ currentCS _ nil ].
		pckClass _ CodePackage.
		classes do: [ :ee |
			(ee hasDefinition and: [ee superclassName = 'CodePackage']) ifTrue: [
				((self packageName asIdentifier: true), 'Package') = ee name ifTrue: [
					ee fileInDefinitionAndMetaclass.
					pckClass _ Smalltalk at: ee name ]]].
		newCodePackage _ pckClass
			named: packageName
			createIfAbsent: true
			registerIfNew: true.
		newCodePackage
			fullFileName: fullName;
			sourceSystem: sourceSystem;
			description: description;
			featureSpec: featureSpec.

		fullName asFileEntry readStreamDo: [ :stream | stream fileInAnnouncing: 'Installing ', localName, '...' ].
		methodsToRemove do: [ :methodReference | methodReference actualClass removeSelector: methodReference selector ].
		classesToRemove do: [ :className | (Smalltalk at: className) removeFromSystem ].
		currentCS ifNotNil: [ ChangeSet removeChangeSet: currentCS ]].

	newCodePackage hasUnsavedChanges: false; triggerEvent: #dirtyFlagChanged.
	DataStream initialize. "Just in case"
	"If we are installing an already installed package, zap the change set with possible changes done, 
	as they are irrelevant now: we have the package from disk"
	ChangeSet removeChangeSet: (ChangeSet existingOrNewChangeSetForPackage: newCodePackage).
	(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
		Transcript newLine; show: 'Package ', packageName, ' successfully installed'; newLine.
		Smalltalk cleanOutUndeclared.
		Undeclared notEmpty ifTrue: [
			('Undeclared: ', Undeclared printString) print ]].
	^newCodePackage! !
!TestResult methodsFor: 'logging' stamp: 'hlsf 5/12/2022 10:35:22' prior: 16962249!
                reportAboutToRun: aTestCase
	(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
		Transcript show: 'Will run: '; print: aTestCase; newLine]! !
!TestResult methodsFor: 'logging' stamp: 'hlsf 5/12/2022 10:35:27' prior: 16962261!
                             reportFailed: aTestCase because: anException
	(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
		Transcript print: anException; newLine].! !
!TestResult methodsFor: 'logging' stamp: 'hlsf 5/12/2022 10:35:31' prior: 16962268!
                             reportPassed: aTestCase
	(PreferenceNG at: #transcriptLogVerbose) ifTrue: [
		Transcript show: 'finished.'; newLine]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5156-CuisCorePreferences-p3-HilaireFernandes-2022May12-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 11:26:27 am'!
!PluggableTextModel methodsFor: 'misc' stamp: 'hlsf 5/12/2022 11:21:53' prior: 16912572 overrides: 16968693!
                 refetch
	"Answer true if actualContents was actually fetched."
	textGetter
		ifNil: [
			actualContents ifNil: [
				self actualContents: Text new ].
			^false ]
		ifNotNil: [
			self actualContents: (Text
				initialFont: (PreferenceNG at: #standardCodeFont)
				stringOrText: (textProvider perform: textGetter)).
			self changed: #refetched.
			^true ]! !
!TextProvider methodsFor: 'contents' stamp: 'hlsf 5/12/2022 11:21:57' prior: 16969572!
   acceptedContents
	^ Text
		initialFont: (PreferenceNG at: #standardCodeFont)
		stringOrText: self acceptedStringOrText! !
!Browser methodsFor: 'class functions' stamp: 'hlsf 5/12/2022 11:22:01' prior: 16795182!
             classCommentText
	"return the text to display for the comment of the currently selected class"
	| theClass |
	theClass _ self selectedClassOrMetaClass.
	^ Text
		initialFont: (PreferenceNG at: #standardCodeFont)
		stringOrText:
			((theClass notNil and: [ theClass hasComment ])
				ifTrue: [ theClass comment ]
				ifFalse: [ '' ]).! !
!ChangeList methodsFor: 'menu actions' stamp: 'hlsf 5/12/2022 11:22:06' prior: 50341736!
                      compareToCurrentVersion
	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"

	| change class s1 s2 differDesc diffWords |
	listIndex = 0
		ifTrue: [^ self].
	change _ changeList at: listIndex.
	((class _ change changeClass) notNil
			and: [class includesSelector: change methodSelector])
		ifTrue: [
			s1 _ (class sourceCodeAt: change methodSelector) asPlainString.
			s2 _ change string.
			s1 = s2
				ifTrue: [^ self inform: 'Exact Match'].
			diffWords _ self shouldDiffWords.
			differDesc _ diffWords
				ifTrue: [ 'Words']
				ifFalse: [ 'Lines'].
			(TextModel
				withText: (
					(DifferenceFinder
						displayPatchFrom: s1 to: s2
						tryWords: diffWords
						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))
							font: (PreferenceNG at: #standardCodeFont)))
				openLabel: 'Comparison to Current Version: ', differDesc, 
					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]
		ifFalse: [self flash]! !
!FileList methodsFor: 'volume list and pattern' stamp: 'hlsf 5/12/2022 11:18:05' prior: 16855494!
                    fileNameFormattedFrom: entry namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad
	"entry is a 5-element array of the form:
		(name creationTime modificationTime dirFlag fileSize)"
	| sizeStr nameStr paddedNameStr dateStr someSpaces sizeDigits sizeDigitsAndCommas spacesToAdd font spaceWidth |
	font _ PreferenceNG at: #standardListFont.
	spaceWidth _ font widthOf: $ .
	nameStr _ entry isDirectory
		ifTrue: [ entry name , self folderString ]
		ifFalse: [ entry name ].
	spacesToAdd _ namePad - (font widthOfString: nameStr) // spaceWidth.
	paddedNameStr _ nameStr ,
		(String
			new: spacesToAdd
			withAll: $ ).
	dateStr _ (entry modificationTime date printFormat: #(3 2 1 $/ 1 1 2 )) , '  ' ,
		(String streamContents: [ :s |
			entry modificationTime time
				print24: true
				showSeconds: true
				on: s ]).
	sizeDigits _ entry fileSize printString size.
	sizeStr _ entry fileSize printStringWithCommas.
	sizeDigitsAndCommas _ sizeStr size.
	spacesToAdd _ sizeWithCommasPad - sizeDigitsAndCommas.
	"Usually a space takes the same space as a comma, and half the space of a digit.
	Pad with 2 spaces for each missing digit and 1 space for each missing comma"
	(font widthOf: Character space) ~= (font widthOf: $, )
		ifTrue: [spacesToAdd _ spacesToAdd + sizePad - sizeDigits max: 0].
	sizeStr _ (String new: spacesToAdd withAll: $ ) , sizeStr.
	someSpaces _ String new: 6 withAll: $ .
	"
	sortMode = #name ifTrue: [ ^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' ].
	sortMode = #date ifTrue: [ ^ '( ' , dateStr , someSpaces , sizeStr , ' )' , someSpaces , nameStr ].
	sortMode = #size ifTrue: [ ^ '( ' , sizeStr , someSpaces , dateStr , ' )' , someSpaces , nameStr ].
	"
	^ paddedNameStr , someSpaces , '( ' , dateStr , someSpaces , sizeStr , ' )' .! !
!FileList methodsFor: 'volume list and pattern' stamp: 'hlsf 5/12/2022 11:18:32' prior: 16855553!
                 listForSelectingPatterns: patternsThatSelect rejectingPatterns: patternsThatReject
	"Make the list be those file names which match the patterns."

	| sizePad selected newList namePad sizeWithCommasPad font |
	directory ifNil: [^#()].
	selected _ Set new.
	patternsThatSelect do: [ :pat |
		directory childrenDo: [ :entry |
			(entry isDirectory
				ifTrue: [ showDirsInFileList ]
				ifFalse: [ self doesPattern: pat allow: entry])
					ifTrue: [ selected add: entry ]]].
	newList _ selected copy.
	patternsThatReject do: [ :pat |
		selected do: [ :entry |
			(entry isDirectory not and: [ pat match: entry name]) ifTrue: [
				newList remove: entry ]]].
		
	newList _ newList asArray sort: self sortBlock.
	font _ PreferenceNG at: #standardListFont.
	namePad _ newList inject: 0 into: [ :mx :entry | mx max: (font widthOfString: entry name)].
	sizePad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry fileSize)]) printString size.
	sizeWithCommasPad _ (newList inject: 0 into: [ :mx :entry | mx max: (entry fileSize)]) printStringWithCommas size.
	newList _ newList collect: [ :e |
		self fileNameFormattedFrom: e namePad: namePad sizePad: sizePad sizeWithCommasPad: sizeWithCommasPad ].
	^ newList! !
!Color class methodsFor: 'colormaps' stamp: 'hlsf 5/12/2022 10:51:53' prior: 16826660!
              computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: (PreferenceNG at: #aaFontsColormapDepth).
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Color
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: `Color white` ]]]
			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 10:49:26' prior: 50353279!
                               prefFont
	^ #( 
		#(aaFontsColormapDepth 4)
		#(cacheTrueTypeGlyphs true )
		#(guiElementsSize standardFonts #(tinyFonts verySmallFonts smallFonts standardFonts largeFonts veryLargeFonts hugeFonts) defaultFontSize: )
		#(loadOnlyLatinGlyphData false )
		#(properDisplayAlphaForFonts false )	
		#(subPixelRenderColorFonts true )
		#(subPixelRenderFonts true )	
	)! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'hlsf 5/12/2022 11:22:21' prior: 16922726!
       standardWindowExtent
	"Answer the standard default extent for new windows.  "

	| grid allowedArea maxLevel |
	"NOTE: following copied from strictlyStaggeredInitialFrameFor:"
	allowedArea _ self maximumUsableArea insetBy: (
		self scrollBarSetback @ self screenTopSetback extent: `0@0`
	).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel _ allowedArea area > 700000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid _ allowedArea area > 700000 ifTrue: [40] ifFalse: [20].
	^ ((allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) 
		min: `52@40` * (PreferenceNG at: #standardCodeFont) lineSpacing) rounded! !
!BitBltCanvasEngine methodsFor: 'private' stamp: 'hlsf 5/12/2022 10:50:53' prior: 16790430!
 setRuleAndMapFor: sourceDepth foregroundColor: foregroundColor

	| targetColor destDepth |
	destDepth _ destForm depth.
	halftoneForm _ nil.	"Don't use fillColor. Use a more powerful ColorMap"

	sourceDepth = 1 ifTrue: [
		self combinationRule: Form paint.
		"Set up color map for a different source depth (color font)"
		"Uses caching for reasonable efficiency"
		colorMap _ self cachedFontColormapFrom1BitTo: destDepth.
		colorMap at: 1 put: (destForm pixelValueFor: `Color transparent`).
		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]
	
	ifFalse: [
		"Enable subpixel rendering if requested, but never for translucent text:
		This technique always draws opaque text. This could be added, by using an extra colormap for the rgbMul phase...
		So far, no need arised for doing so."
		(sourceDepth > 8 and: [
			(PreferenceNG at: #subPixelRenderFonts) and: [ foregroundColor = `Color black` or: [ 
				(PreferenceNG at: #subPixelRenderColorFonts) and: [ foregroundColor isOpaque ]]]]) ifTrue: [
			destDepth > 8 ifTrue: [
				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"
				self combinationRule: 37.		"rgbMul"
				colorMap _ (foregroundColor ~= `Color black` or: [
						destDepth = 32 and: [ destForm ~~ Display or: [PreferenceNG at: #properDisplayAlphaForFonts] ]]) ifTrue: [
					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"
					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)
					See #displayString:from:to:at:strikeFont:color:"
					"Note: In 32bpp, if we want the correct alpha in the result, we need the second pass, as the destination could have transparent pixels, 
					and we need to add to the alpha channel"
					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
			ifFalse: [
				self combinationRule: 25.		"Paint"
				targetColor _ foregroundColor = `Color black` ifFalse: [ foregroundColor ].
				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
		ifFalse: [
			"Do not use rule 34 for 16bpp display."
			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).
			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]]! !
!StringRequestMorph methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 11:23:40' prior: 50342999!
              addTitle: aString
	| titleMorph s pp w |
	titleMorph _ BoxedMorph new noBorder.
	titleMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line |
		s _ LabelMorph new
			contents: line;
			font: (PreferenceNG at: #standardMenuFont) bold.
		titleMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphExtent: (w + 24) @ (pp y).
	self addMorphKeepMorphHeight: titleMorph.
	^titleMorph morphWidth! !
!StringRequestMorph class methodsFor: 'private' stamp: 'hlsf 5/12/2022 11:25:02' prior: 16950518!
                 deltaToTextPane
	"Answer a distance to translate an instance of the receiver by when it is opened in the world in order to have the hand be over the text pane (so the text pane has focus).
	Distance is relative to font size"
	| e |
	e _ (PreferenceNG at: #windowTitleFont) lineSpacing.
	^ (0)@(0.5 * e)! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 11:25:07' prior: 16960206!
                 defaultHeight

	^ ((PreferenceNG at: #windowTitleFont) lineSpacing * 2 * self scale) asInteger! !
!InnerListMorph methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 11:19:03' prior: 16869763 overrides: 16794195!
           initialize
	super initialize.
	self color: `Color black`.
	font _ PreferenceNG at: #standardListFont.
	listItems _ #().
	selectedRow _ nil.
	highlightedRow _ nil! !
!InnerListMorph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 11:18:54' prior: 16870053 overrides: 16893209!
              fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (PreferenceNG at: #standardListFont).! !
!IndentingListItemMorph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 11:19:08' prior: 16869398 overrides: 16893209!
 fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (PreferenceNG at: #standardListFont).! !
!IndentingListItemMorph methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 11:19:17' prior: 16869404!
               initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel

	| o |
	container _ hostList.
	complexContents _ anObject.
	self initWithContents: anObject asString font: (PreferenceNG at: #standardListFont) emphasis: nil.
	indentLevel _ 0.
	isExpanded _ false.
 	nextSibling _ firstChild _ nil.
	priorMorph ifNotNil: [
		priorMorph nextSibling: self.
	].
	o _ anObject withoutListWrapper.
	icon _ o ifNotNil: [ (o respondsTo: #icon) ifTrue: [ o icon ] ].
	icon isSymbol ifTrue: [ icon _ Theme current perform: icon ].
	indentLevel _ newLevel.
! !
!UpdatingLabelMorph class methodsFor: 'new-morph participation' stamp: 'hlsf 5/12/2022 11:25:12' prior: 16976224 overrides: 16895515!
initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (PreferenceNG at: #windowTitleFont)
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #value.
		
	^ newInst! !
!MenuItemMorph methodsFor: 'initialization' stamp: 'hlsf 5/12/2022 11:23:50' prior: 16882200 overrides: 16877690!
                            initialize
	"initialize the state of the receiver"
	super initialize.
	isEnabled _ true.
	subMenu _ nil.
	isSelected _ false.
	target _ nil.
	selector _ nil.
	arguments _ nil.
	font _ PreferenceNG at: #standardMenuFont.
	self contents: ''.! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 11:20:32' prior: 16910132!
               fontToUse
	| fontToUse |
	fontToUse := font ifNil: [PreferenceNG at: #standardButtonFont].
	"
	Could add emphasis...
	^(emphasis isNil or: [emphasis = 0]) 
		ifTrue: [fontToUse]
		ifFalse: [fontToUse emphasized: emphasis]
	"
	^fontToUse! !
!PluggableButtonMorph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 11:25:17' prior: 16910367 overrides: 16893272!
                             minimumExtent
	
	| unit |
	unit :=  (PreferenceNG at: #windowTitleFont) pointSize.
	^label 
		ifNil: [ (unit+2) @ (unit+2) ] "Assume title button"
		ifNotNil: [ (4 * unit) @ (3 * unit) ] "Assure some space for text."
! !
!PluggableListMorph methodsFor: 'geometry' stamp: 'hlsf 5/12/2022 11:19:23' prior: 16910815 overrides: 16912008!
                  fontPreferenceChanged

	super fontPreferenceChanged.
	self font: (PreferenceNG at: #standardListFont).! !
!SystemWindow methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 11:25:24' prior: 16959100!
drawLabelOn: aCanvas

	| x0 y0 f w availableW l |
	f _ PreferenceNG at: #windowTitleFont.
	x0 _  f lineSpacing * 5 + borderWidth.
	y0 _ borderWidth * 6 // 10.
	availableW _ extent x - x0.
	l _ labelString.
	w _ f widthOfString: l.
	[ w > availableW ] whileTrue: [
		l _ l squeezedTo: (1.0 * l size * availableW / w) truncated.
		l isEmpty ifTrue: [ ^self ].
		w _ f widthOfString: l ].
	aCanvas
		drawString: l
		at: x0@y0
		font: f
		color: Theme current windowLabel
		embossed: Theme current embossedTitles! !
!SystemWindow methodsFor: 'label' stamp: 'hlsf 5/12/2022 11:25:31' prior: 16959400!
            labelHeight
	"Answer the height for the window label."
	^ (PreferenceNG at: #windowTitleFont) lineSpacing+1! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:31' prior: 16820311 overrides: 16959689!
                         initialExtent

	^`540@400` * (PreferenceNG at: #standardCodeFont) lineSpacing // 14! !
!BrowserWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:37' prior: 16797138!
             buildNoSysCatMorphicWindow
	"A Browser without the class categories list"

	| mySingletonList upperPanes messageCatList messageList classColumn classList |
	mySingletonList _ PluggableListMorph
				model: model
				listGetter: #systemCategorySingleton
				indexGetter: #indexIsOne
				indexSetter: #indexIsOne:
				mainView: self
				menuGetter: #systemCatSingletonMenu
				keystrokeAction: #systemCatSingletonKey:from:.
	mySingletonList hideScrollBarsIndefinitely.

	classList _ self buildMorphicClassList.
	classColumn _ self buildMorphicClassColumnWith: classList.
	messageCatList _ self buildMorphicMessageCatList.
	messageList _ self buildMorphicMessageList.
	
	classList rightSibling: messageCatList.
	messageCatList leftSibling: classList rightSibling: messageList.
	messageList leftSibling: messageCatList.
	
	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: classColumn proportionalWidth: 0.3;
		addAdjusterAndMorph: messageCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: messageList proportionalWidth: 0.4.

	messageList makeItemsDraggable.
	messageCatList 
		acceptDropsFrom: messageList 
		performing: #categorizeUnderCategoryAt:selector: 
		whenOutsideList: #categorizeUnderNewCategorySelector:.

	self layoutMorph
		addMorph: mySingletonList fixedHeight: (PreferenceNG at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.

	model changed: #editSelection! !
!CodeFileBrowserWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:42' prior: 50334671 overrides: 50335981!
          buildMorphicWindow
	"Create a pluggable version of all the views for a Browser, using Morphic widgets."

	| sysCatList msgCatList upperPanes clsLayout clsList msgList |
	model setSelectedSystemCategory: model systemCategoryList first.
	sysCatList _ PluggableListMorph
			model: model 
			listGetter: #systemCategorySingleton
			indexGetter: #indexIsOne 
			indexSetter: #indexIsOne:
			mainView: self
			menuGetter: #codeFileListMenu
			keystrokeAction: #codeFileListKey:from:.
	sysCatList hideScrollBarsIndefinitely.
	
	msgCatList _ PluggableListMorph
			model: model 
			listGetter: #messageCategoryList
			indexGetter: #messageCategoryListIndex 
			indexSetter: #messageCategoryListIndex:
			mainView: self
			menuGetter: #messageCategoryMenu
			keystrokeAction: nil.

	clsList := self buildMorphicClassList.
	clsLayout := self buildMorphicClassColumnWith: clsList.
	msgList := self buildMorphicMessageList.
	sysCatList rightSibling: clsList.
	clsList leftSibling: sysCatList rightSibling: msgCatList.
	msgCatList leftSibling: clsList rightSibling: msgList.
	msgList leftSibling: msgCatList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: clsLayout proportionalWidth: 0.3;
		addAdjusterAndMorph: msgCatList proportionalWidth: 0.3;
		addAdjusterAndMorph: msgList proportionalWidth: 0.4.

	self layoutMorph
		addMorph: sysCatList fixedHeight: (PreferenceNG at: #standardCodeFont) lineSpacing + 10;
		addAdjusterAndMorph: upperPanes proportionalHeight: 0.3;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.7.
	model changed: #editSelection! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:47' prior: 16807698 overrides: 16959689!
      initialExtent
	^`540@300` * (PreferenceNG at: #standardCodeFont) lineSpacing // 14! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:52' prior: 16914984 overrides: 16959689!
                         initialExtent
	^ `640 @ 320` * (PreferenceNG at: #standardCodeFont) lineSpacing // 14! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:22:58' prior: 16872376 overrides: 16959689!
                     initialExtent

	^`600@325` * (PreferenceNG at: #standardCodeFont) lineSpacing // 14! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'hlsf 5/12/2022 11:23:04' prior: 16904430 overrides: 16959689!
                  initialExtent

	^`300@500` * (PreferenceNG at: #standardCodeFont) lineSpacing // 14! !
!MenuMorph methodsFor: 'construction' stamp: 'hlsf 5/12/2022 11:23:57' prior: 50343033!
                 addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w newMorph |
	
	newMorph _ BoxedMorph new noBorder.
	newMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asPlainString linesDo: [ :line | | font |
		font _ PreferenceNG at: #standardMenuFont.
		s _ LabelMorph new
			contents: line;
			font: (titleMorph
				ifNil: [ font bold ]
				ifNotNil: [ font italic ])..
		newMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ newMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	newMorph morphExtent: (w + 16) @ (pp y).
	titleMorph
		 ifNil: [
			titleMorph _ newMorph.
			self addMorphFront: titleMorph ]
		ifNotNil: [ self addMorphBack: newMorph ].
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!AutoCompleterMorph class methodsFor: 'preferences' stamp: 'hlsf 5/12/2022 11:19:30' prior: 16783186!
                    listFont

	^PreferenceNG at: #standardListFont! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:20:41' prior: 16971003!
                         buttonPaneHeight
	"Answer the user's preferred default height for button panes."

	^(PreferenceNG at: #standardButtonFont) lineSpacing * 14 // 8! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:19:41' prior: 16971024!
                       layoutAdjusterThickness

	self flag: #todo.  "Revisit this; consider moving proportional stuff out of Theme entirely."
	
	^ (PreferenceNG at: #standardListFont) pointSize // 3! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:25:37' prior: 16971067!
                        titleBarButtonsExtent
	"Answer the extent to use for close & other title bar buttons.  
	The label height is used to be proportional to the fonts preferences."
	| e |
	e _ (PreferenceNG at: #windowTitleFont) pointSize * 13 // 10.
	^e@e! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:19:49' prior: 16971112!
                            windowBorderWidth
	| w |
	w _ (PreferenceNG at: #standardListFont) pointSize / 11.
	w _ w * (self roundWindowCorners ifTrue: [4] ifFalse: [2]).
	^ w rounded max: 1! !
!Theme class methodsFor: 'user interface' stamp: 'hlsf 5/12/2022 11:08:20' prior: 50339177!
                             changeFontSizes

	| options menu preference  |
	preference _ PreferenceNG instanceAt: #guiElementsSize.
	options _ #(
		#('Huge' #hugeFonts)
		#('Very Large' #veryLargeFonts)
		#('Large' #largeFonts)
		#('Default Size' #standardFonts)
		#('Small' #smallFonts)
		#('Very Small' #verySmallFonts)
		#('Tiny' #tinyFonts)).
	menu _ MenuMorph new.
	menu
		addTitle: 'Make GUI elements';
		addStayUpIcons;
		stayUp: true.
	options do: [ :pair |
		(menu add: pair first target: preference action: #value: argument: pair second)
			isSelected: preference value == pair second  ].
	menu popUpInWorld: self runningWorld.! !
!PopUpMenu methodsFor: 'accessing' stamp: 'hlsf 5/12/2022 11:24:04' prior: 16913502!
      frameHeight
	"Designed to avoid the entire frame computation (includes MVC form),
	since the menu may well end up being displayed in Morphic anyway."
	| nItems |
	nItems _ 1 + labelString lineCount.
	^ (nItems * (PreferenceNG at: #standardMenuFont) lineSpacing) + 4 "border width"! !
!PopUpMenu methodsFor: 'basic control sequence' stamp: 'hlsf 5/12/2022 11:24:09' prior: 16913534!
  startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean
	"This menu is too big to fit comfortably on the screen.
	Break it up into smaller chunks, and manage the relative indices.
	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"

"
(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; newLine]. s skip: -1])
		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'.
"
	| nLines nLinesPer allLabels from to subset subLines index |
	allLabels := labelString lines.
	nLines _ allLabels size.
	lineArray ifNil: [lineArray _ Array new].
	nLinesPer _ segmentHeight // (PreferenceNG at: #standardMenuFont) lineSpacing - 5.
	from := 1.
	[ true ] whileTrue: [
		to := (from + nLinesPer) min: nLines.
		subset := (allLabels copyFrom: from to: to) asOrderedCollection.
		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])
			before: subset first.
		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].
		subLines _ (Array with: 1) , subLines.
		index := (PopUpMenu labels: subset printStringWithNewline lines: subLines)
					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.
		index = 1
			ifTrue: [from := to + 1.
					from > nLines ifTrue: [ from := 1 ]]
			ifFalse: [index = 0 ifTrue: [^ 0].
					^ from + index - 2]]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5157-CuisCorePreferences-p4-HilaireFernandes-2022May12-hlsf.002.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 11:44:21 am'!
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/12/2022 11:35:43' prior: 50353082!
            installMiscPreferences
" Preference value defined with closure. We could insert in a dynamic array...
  Preference with event handler "
	PreferenceNG 
		name: #haloHandleSize category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 5 // 3 max: 16].
	PreferenceNG
		name: #roundedButtonRadius 	category: #gui 
		value: [(PreferenceNG at: #standardListFont) pointSize * 8 // 14].
	PreferenceNG
		name: #roundedWindowRadius 	category: #gui value: [(PreferenceNG at: #standardListFont) pointSize].
	PreferenceNG
		name: #scrollbarThickness category: #gui 		value: [(PreferenceNG at: #windowTitleFont) pointSize + 2].
	PreferenceNG name: #classFinder category: #programming value: [ BrowserWindow findClass ].
	PreferenceNG name: #defaultAuthorName category: #programming value: [Utilities authorName].! !
!WorldMorph methodsFor: 'world menu' stamp: 'hlsf 5/12/2022 11:43:42' prior: 16982898!
                      invokeWorldMenu
	"Put up the world menu, triggered by the passed-in event.
	Perhaps a good place to disable it if needed"

	| menu |
	menu _ (TheWorldMenu new 
		world: self
		hand: self activeHand) buildWorldMenu.
	menu addTitle: PreferenceNG desktopMenuTitle.
	menu popUpInWorld: self! !
!HaloMorph methodsFor: 'private' stamp: 'hlsf 5/12/2022 11:36:53' prior: 16864851!
           addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient. Return the handle."

	| handle aPoint colorToUse form icon e |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	e _ (PreferenceNG at: #haloHandleSize) asPoint.
	handle morphPosition: aPoint-(e//2) extent: e.
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				form extent = e ifFalse: [ 
					": Non default size, scale that bugger!!"
					form _ form  ": Be as smooth as possible, these images are small."
						magnify: form boundingBox
						to: e
						smoothing: 2 ].
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: `0@0` ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^ handle! !
!HaloMorph methodsFor: 'private' stamp: 'hlsf 5/12/2022 11:36:59' prior: 16864922!
     addNameString: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph verticalNamePosition namePosition nameBackground |
	nameBackground _ BoxedMorph new noBorder
		color: ((target is: #SystemWindow)
			ifTrue: [target windowColor]
			ifFalse: [`Color lightBlue alpha: 0.9`]).
	nameMorph _ LabelMorph contents: aString.
	nameMorph color: `Color black`.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	verticalNamePosition _ haloBox bottom + (PreferenceNG at: #haloHandleSize).
	namePosition _ haloBox width - nameMorph morphWidth // 2 + haloBox left @ verticalNamePosition.
	self addMorph: nameBackground.
	nameBackground morphPosition: namePosition - 2.
	self addMorph: nameMorph.
	nameMorph morphPosition: namePosition.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'hlsf 5/12/2022 11:37:08' prior: 16865102!
      handlesBox
	"handlesBox is in local coordinates.
	We assume we are direct submorph of the world, without any scaling or rotation."

	| minSide hs c e box |
	hs _ PreferenceNG at: #haloHandleSize.
	minSide _ 4 * hs.
	e _ extent + (hs*2) max: minSide@minSide.
	c _ extent // 2 + self morphPosition.
	box _ Rectangle center: c extent: e.
	self world ifNotNil: [ :w | box _ box intersect: (w viewBox insetBy: (hs@hs corner: hs@(hs*3))) ].
	"Make it local"
	^box translatedBy: self morphPosition negated.
! !
!KeyboardEvent methodsFor: 'dispatching' stamp: 'hlsf 5/12/2022 11:41:12' prior: 16877331 overrides: 16896706!
                         sendEventTo: aMorph
	"Dispatch the receiver into anObject"
	type == #keystroke ifTrue: [
		self isFindClassShortcut
			ifTrue: [ ^ (PreferenceNG at: #classFinder) value ].
		self isCloseWindowShortcut
			ifTrue: [ ^ self closeCurrentWindowOf: aMorph ].
		^ aMorph processKeystroke: self ].
	type == #keyDown ifTrue: [
		^ aMorph processKeyDown: self ].
	type == #keyUp ifTrue: [ 
		^ aMorph processKeyUp: self ].
	^ super sendEventTo: aMorph.! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:36:17' prior: 16971044!
             roundedButtonRadius
	"Only effective if #roundButtons answers true.
	Provide a reasonable default for subclasses."
	^ PreferenceNG at: #roundedButtonRadius! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:39:14' prior: 16971051!
            roundedWindowRadius
	"Only effective if #roundWindowCorners answers true.
	Provide a reasonable default for subclasses."
	^PreferenceNG at: #roundedWindowRadius! !
!Theme methodsFor: 'other options' stamp: 'hlsf 5/12/2022 11:40:09' prior: 16971063!
       scrollbarThickness
	^ PreferenceNG at: #scrollbarThickness! !
!ChangeSet methodsFor: 'fileIn/Out' stamp: 'hlsf 5/12/2022 11:42:06' prior: 16806187!
            preambleTemplate
	"Answer a string that will form the default contents for a change set's preamble.
	Just a first stab at what the content should be."

	^ String streamContents: [:strm |
		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."
		strm tab;tab; nextPutAll: self name.
		strm newLine; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.
		strm newLine; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: (PreferenceNG at: #defaultAuthorName).
		strm newLine; newLine; nextPutAll: '<your descriptive text goes here>"']
"
ChangeSet changeSetForBaseSystem preambleTemplate
"! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5158-CuisCorePreferences-p5-HilaireFernandes-2022May12-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5146] on 12 May 2022 at 12:06:56 pm'!
!SystemDictionary methodsFor: 'image, changes name' stamp: 'hlsf 5/12/2022 11:52:14' prior: 16952409!
                 defaultUserChangesName
	"Answer the default full path to the changes file corresponding to the image file name."
	"
	Smalltalk defaultUserChangesName
	"
	^(FileIOAccessor default baseNameFor: self imageName), 
		(PreferenceNG at: #userChangesFileNameExtension)! !
!SystemDictionary methodsFor: 'ui' stamp: 'hlsf 5/12/2022 12:06:12' prior: 16956195!
   beep
	"
	Smalltalk beep
	"
	(PreferenceNG at: #soundsEnabled) ifTrue: [
		Smalltalk
			at: #SampledSound
			ifPresent: [ :cls | cls beep ]
			ifAbsent: [ self primitiveBeep ]]! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 12:05:02' prior: 50353315!
                    prefProgramming
	^ #(
		#(allowBlockArgumentAssignment false )
		#(alternativeBrowseIt false )
		#(assignmentGlyphSelector useLeftArrow #(useLeftArrow useAlwaysLeftArrow) assignmentGlyph: )
		#(backgroundColorFillsAllBackground true )
		#(browseWithPrettyPrint false )
		#(classAnnotations #(instanceMethodsCount classMethodsCount linesOfCode) )
		#(debugHaloHandle true )
		#(debugLogTimestamp true )
		#(debugShowDamage false )
		#(decorateBrowserButtons true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(extraDebuggerButtons true )
		#(fullPrintItInWorkspaces false )
		#(highlightBlockNesting true )
		#(italicsInShout true)
		#(leftArrowAssignmentsInGeneratedCode false )
		#(listClassesHierarchically true )
		#(logDebuggerStackToFile false )
		#(methodAnnotations #(timeStamp linesOfCode messageCategory implementorsCount sendersCount  packages changeSets) )	
		#(prettyPrintRectangularBlocks false )
		#(shiftClickShowsImplementors false )
		#(shoutInWorkspaces true )
		#(showAnnotations true )
		#(showLinesInHierarchyViews true )
		#(stylingWithEmphasisInWorkspaces false )
		#(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount linesOfCode) )
		#(syntaxHighlightingAsYouType true )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(thoroughSenders true )
		#(usePreDebugWindow false)
	)! !
!PreferenceNG class methodsFor: 'data' stamp: 'hlsf 5/12/2022 11:50:23' prior: 50353362!
                            prefSystem
	^ #( #(allowNonLocalReturnsInExceptionHandlers true )
		#(askConfirmationOnQuit true )
		#(askToInstallComplexPackage true )
		#(automaticPlatformSettings true )
		#(autoNumberUserChanges false )
		#(caseSensitiveFinds false )
		#(changeSetVersionNumbers true )
		#(checkForSlips true )
		#(checkLostChangesOnStartUp false )
		#(cmdDotEnabled true )
		#(cmdDotInterruptTakesStatistics false )
		#(dismissAllOnOptionClose false )
		#(initialFileListDirectories #roots #(root image vm current) )
		#(machine default #(default slow smalltalk80) machine: )
		#(pointer mouse #(touch mouse) pointer:)
		#(selectionsMayShrink true )
		#(serverMode false )
		#(systemWindowEmbedOK false )
		#(transcriptLogVerbose true )
		#(userChangesFileNameExtension '.user.changes' )
		#(warnAboutNonLocalReturnsInExceptionHandlers false )
		#(warnIfNoChangesFile true )
		#(warnIfNoSourcesFile true )
	)! !
!PreferenceNG class methodsFor: 'fonts' stamp: 'hlsf 5/12/2022 11:53:18' prior: 50353472!
 setDefaultFont: aFontName
	"Change the font on the whole system without changing point sizes."
	FontFamily defaultFamilyName: aFontName.
	PreferenceNG
			setDefaultFont: FontFamily defaultFamilyName
			spec: {
				{#standardListFont. (PreferenceNG at: #standardListFont) pointSize.}.
				{#standardMenuFont. (PreferenceNG at: #standardMenuFont) pointSize.}.
				{#windowTitleFont. (PreferenceNG at: #windowTitleFont) pointSize.}.
				{#standardCodeFont. (PreferenceNG at: #standardCodeFont) pointSize.}.
				{#standardButtonFont. (PreferenceNG at: #standardButtonFont) pointSize.}.
			}.
	MorphicCanvas allSubclassesDo: [ :c| c guiSizePreferenceChanged ].
	UISupervisor ui ifNotNil: [ :w | w fontPreferenceChanged ].! !
!FontFamily class methodsFor: 'ui' stamp: 'hlsf 5/12/2022 11:57:49' prior: 50352071!
                           promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| selectedNameOrDirectory fontFamily |
	selectedNameOrDirectory _ self promptUserFolders.
	selectedNameOrDirectory isNil ifTrue: [ ^nil ].
	(FontFamily familyNamed: selectedNameOrDirectory)
		ifNotNil: [ :it | ^PreferenceNG setDefaultFont: it familyName ].
	(Feature require: 'VectorGraphics') ifTrue: [
		(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
			Feature require: 'VectorEngineInSmalltalk' ].
		UISupervisor whenUIinSafeState: [
			fontFamily _ FontFamily availableFamilies values
				detect: [ :any | any folderName = selectedNameOrDirectory name ]
				ifNone: [
					FontFamily familyNamed: ((Smalltalk at: #TrueTypeFontFamily) read: selectedNameOrDirectory) anyOne ].
			PreferenceNG setDefaultFont: fontFamily familyName ]].! !
!WorldMorph methodsFor: 'drawing' stamp: 'hlsf 5/12/2022 11:58:44' prior: 50354030!
displayWorld
	"Update this world's display."

	| deferredUpdateVMMode allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"

	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time. ?? revisar."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvas.

	"Restore world canvas under hands and their carried morphs"
	(PreferenceNG at: #cacheDisplayContentWhenMovingMorphs) ifTrue: [
		hands do: [ :h | h restoreSavedPatchOn: canvas ]].

	"Update #displayBounds for all dirty morphs (marked as such with #redrawNeeded).
	Also add the updated bounds to aDamageRecorder, and update bounds of morphs carried by hand."
	canvas boundsFinderCanvas updateBoundsIn: self addDamageTo: damageRecorder.

	"repair world's damage on canvas"
	allDamage _ canvas drawWorld: self repair: damageRecorder.
	"allDamage ifNotNil: [Display border: allDamage width: 3 fillColor: Color random].	 'Debugging Aid'."
	canvas newClipRect: nil.

	"Check which hands need to be drawn.
	(they are not the hardware mouse pointer and carry morphs)"
	self handsToDrawForDamage: allDamage do: [ :h |
		(PreferenceNG at: #cacheDisplayContentWhenMovingMorphs)
			ifTrue: [ allDamage _ (h savePatchFrom: canvas) quickMerge: allDamage ]
			ifFalse: [ allDamage _ h displayFullBoundsForPatch quickMerge: allDamage ].
		canvas fullDrawHand: h .
		h needsRedraw: false ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		allDamage ifNotNil: [
			"Drawing was done to off-Display canvas. Copy content to Display"
			canvas showAt: self viewBox origin invalidRect: allDamage ]].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	allDamage ifNotNil: [
		DisplayScreen isDisplayExtentOk ifTrue: [
			Display forceToScreen: allDamage ]].! !
!PreDebugWindow class methodsFor: 'instance creation' stamp: 'hlsf 5/12/2022 12:00:41' prior: 16915070!
                    open: model label: aString message: messageString
	
	((PreferenceNG at: #usePreDebugWindow) or: [messageString notNil])
		ifTrue: [self forceOpen: model label: aString message: messageString]
		ifFalse: [model openFullMorphicLabel: aString ]! !
!MouseButtonEvent methodsFor: 'dispatching' stamp: 'hlsf 5/12/2022 12:02:28' prior: 50354563 overrides: 16896679!
                         dispatchWith: aMorph
	"Find the appropriate receiver for the event and let it handle it. Default rules:
	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.
	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.
	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.
	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event.
	"
	| aMorphHandlesIt grabAMorph handledByInner |
	"Only for MouseDown"
	self isMouseDown ifFalse: [
		^super dispatchWith: aMorph ].

	"Try to get out quickly"
	(aMorph fullIncludesPixel: position)
		ifFalse: [ ^ #rejected ].

	"Install the prospective handler for the receiver"
	aMorphHandlesIt _ false.
	grabAMorph _ false.
	self mouseButton3Pressed
		ifTrue: [
			(eventHandler isNil or: [ eventHandler isWorldMorph or: [
					self shiftPressed or: [ aMorph is: #HaloMorph ]]])
				ifTrue: [
					eventHandler _ aMorph.
					aMorphHandlesIt _ true ]]
		ifFalse: [
			(aMorph handlesMouseDown: self) ifTrue: [
				eventHandler _ aMorph.
				aMorphHandlesIt _ true ].
			"If button 1, and both aMorph and the owner allows grabbing with the hand (to initiate drag & drop), so be it."
			self mouseButton1Pressed ifTrue: [
				aMorph owner ifNotNil: [ :o |
					(o allowsSubmorphDrag and: [ aMorph isSticky not ]) ifTrue: [
						grabAMorph _ true ]]]].

	"Now give submorphs a chance to handle the event"
	handledByInner _ false.
	aMorph submorphsDo: [ :eachChild |
		handledByInner ifFalse: [
			(eachChild dispatchEvent: self) == #rejected ifFalse: [
				"Some child did contain the point so aMorph is part of the top-most chain."
				handledByInner _ true ]]].

	(handledByInner or: [ (aMorph rejectsEvent: self) not and: [ aMorph fullIncludesPixel: position ] ]) ifTrue: [
		"aMorph is in the top-most unlocked, visible morph in the chain."
		aMorphHandlesIt
			ifTrue: [ ^self sendEventTo: aMorph ]
			ifFalse: [
				(grabAMorph and: [ handledByInner not ]) ifTrue: [
					self hand
						waitForClicksOrDrag: aMorph event: self
						dragSel: ((PreferenceNG at: #clickGrabsMorphs) ifFalse: [#dragEvent:localPosition:])
						clkSel: ((PreferenceNG at: #clickGrabsMorphs) ifTrue: [#dragEvent:localPosition:]).
					"false ifTrue: [ self hand grabMorph: aMorph ]."
					(PreferenceNG at: #clickGrabsMorphs) ifFalse: [
						self shiftPressed
							ifTrue: [ aMorph is: #SystemWindow :: ifTrue: [ aMorph sendToBack ] ]
							ifFalse: [ aMorph activateWindow ] ].
					self wasHandled: true.
					^ self ]]].

	handledByInner ifTrue: [ ^ self ].
	"Mouse was not on aMorph nor any of its children"
	^ #rejected! !

PreferenceNG class removeSelector: #import!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5159-CuisCorePreferences-p6-HilaireFernandes-2022May12-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5159] on 13 May 2022 at 4:46:22 pm'!
!FontFamily class methodsFor: 'ui' stamp: 'hlsf 5/13/2022 16:45:46' prior: 50357876!
              promptUserAndSetDefault
	"Present a menu of available font families, and if one is chosen, change to it.
	FontFamily promptUserAndSetDefault
	"
	| fontFamily |
	self promptUserFolders ifNotNil: [ :selectedNameOrDirectory |
		(Feature require: 'VectorGraphics') ifTrue: [
			(Smalltalk at: #VectorEngineWithPlugin) isPluginAvailable ifFalse: [
				Feature require: 'VectorEngineInSmalltalk' ].
			UISupervisor whenUIinSafeState: [
				fontFamily _ self readIfNeeded: selectedNameOrDirectory.
				fontFamily includesAscii
					ifTrue: [PreferenceNG setDefaultFont: fontFamily familyName ]
					ifFalse: [self inform: 'Selected font does not include ASCII characters. Can not be set as default.' ]]]].! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5160-CuisCorePreferences-p7-HilaireFernandes-2022May13-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5160] on 13 May 2022 at 6:50:07 pm'!
!Bag methodsFor: 'enumerating' stamp: 'len 5/3/2022 06:51:53' overrides: 16823114!
      allSatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns false for any element return false.
	Otherwise return true."

	contents keysDo: [:each | (aBlock value: each) ifFalse: [^ false]].
	^ true! !
!Bag methodsFor: 'enumerating' stamp: 'len 5/3/2022 06:52:25' overrides: 16823124!
    anySatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns true for any element return true.
	Otherwise return false"

	contents keysDo: [:each| (aBlock value: each) ifTrue: [^ true]].
	^ false! !
!Bag methodsFor: 'statistics' stamp: 'len 5/3/2022 07:06:18' overrides: 16824037!
         max: aBlock
	"Answer the maximum of evaluating aBlock on all the elements of the receiver."
	| answer |
	self emptyCheck.
	contents keysDo: [:each| answer _ answer isNil ifTrue: [aBlock value: each] ifFalse: [answer max: (aBlock value: each)]].
	^ answer! !
!Bag methodsFor: 'statistics' stamp: 'len 5/3/2022 07:07:06' overrides: 16824056!
            min: aBlock
	"Answer the minimum of evaluating aBlock on all the elements of the receiver."
	| answer |
	self emptyCheck.
	contents keysDo: [:each| answer _ answer isNil ifTrue: [aBlock value: each] ifFalse: [answer min: (aBlock value: each)]].
	^ answer! !
!Bag methodsFor: 'statistics' stamp: 'len 5/3/2022 07:06:25' overrides: 16824073!
            product: aBlock
	| answer |
	self emptyCheck.
	self withOccurrencesDo: [:each :times| answer _ answer isNil ifTrue: [each raisedTo: times] ifFalse: [answer * (each raisedTo: times)]].
	^ answer! !
!Bag methodsFor: 'statistics' stamp: 'len 5/3/2022 07:22:21' overrides: 16824111!
         sum: aBlock ifEmpty: emptyBlockOrValue
	| answer |
	self isEmpty ifTrue: [^ emptyBlockOrValue value].
	self withOccurrencesDo: [:each :times| answer _ answer isNil ifTrue: [each * times] ifFalse: [each * times + answer]].
	^ answer! !
!Collection methodsFor: 'enumerating' stamp: 'len 5/3/2022 07:34:31' prior: 16823240!
                               detect: aBlock ifFound: foundBlock ifNone: exceptionBlock 
	"Evaluate aBlock with each of the receiver's elements as the argument.
	Answer the evaluation of foundBlock at the first element for which aBlock evaluates to true."
	^ foundBlock value: (self detect: aBlock ifNone: [^ exceptionBlock value])! !
!Collection methodsFor: 'statistics' stamp: 'len 5/3/2022 07:12:30' prior: 16824032!
                          max
	^ self max: [:each| each]! !
!Collection methodsFor: 'statistics' stamp: 'len 5/3/2022 07:12:17' prior: 16824051!
         min
	^ self min: [:each| each]! !
!Collection methodsFor: 'statistics' stamp: 'len 5/3/2022 07:11:30' prior: 16824067!
         product
	"Answer the product of all elements in the receiver."
	^ self product: [:each| each]! !
!Collection methodsFor: 'statistics' stamp: 'len 5/3/2022 07:11:43' prior: 16824089!
          sum
	"Answer the sum of all elements in the receiver."
	^ self sum: [:each| each]! !
!Collection methodsFor: 'statistics' stamp: 'len 5/3/2022 07:15:20' prior: 16824095!
                      sum: aBlock
	^ self sum: aBlock ifEmpty: [self errorEmptyCollection]! !

Bag removeSelector: #sum!

!methodRemoval: Bag #sum stamp: 'Install-5161-BagAndCollectionTweaks-LucianoEstebanNotarfrancesco-2022May13-18h47m-len.001.cs.st 5/16/2022 10:22:26'!
sum
	"Faster than the superclass implementation when you hold many instances of the same value (which you probably do, otherwise you wouldn't be using a Bag)."
	
	| sum first |
	first := true.
	contents keysAndValuesDo: [ :value :count |
		first 
			ifTrue: [ sum := value * count. first := false ]
			ifFalse: [ sum := sum + (value * count) ] ].
	first ifTrue: [ self errorEmptyCollection ].
	^sum!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5161-BagAndCollectionTweaks-LucianoEstebanNotarfrancesco-2022May13-18h47m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5141] on 9 May 2022 at 10:43:32 am'!
!Collection methodsFor: 'accessing' stamp: 'len 5/9/2022 07:50:44'!
                       atRandom: aGenerator 
	"Answer a random element of the receiver. Uses aGenerator which 
	should be kept by the user in a variable and used every time. Use 
	this instead of #atRandom for better uniformity of random numbers  
	because only you use the generator. Causes an error if self has no  
	elements."
	| n |
	n _ self size atRandom: aGenerator.
	self do: [:each| (n _ n - 1) = 0 ifTrue: [^ each]].
	self errorEmptyCollection! !
!Bag methodsFor: 'accessing' stamp: 'len 5/9/2022 10:34:52' overrides: 50358243!
                             atRandom: aGenerator 
	"Answer a random element of the receiver. Uses aGenerator which 
	should be kept by the user in a variable and used every time. Use 
	this instead of #atRandom for better uniformity of random numbers  
	because only you use the generator. Causes an error if self has no  
	elements."
	| n |
	n _ self size atRandom: aGenerator.
	self withOccurrencesDo: [:each :times| (n _ n - times) <= 0 ifTrue: [^ each]].
	self errorEmptyCollection! !
!Collection methodsFor: 'testing' stamp: 'len 5/9/2022 07:31:47' prior: 16823776!
 identityIncludes: anObject 
	"Answer whether anObject is one of the receiver's elements."

	^ self anySatisfy: [:any| any == anObject]! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5162-CollectionAtRandomAndIdentityIncludesTweaks-LucianoEstebanNotarfrancesco-2022May09-07h28m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5162] on 13 May 2022 at 8:38:50 pm'!
!Utf8String class methodsFor: 'instance creation' stamp: 'jmv 5/13/2022 20:37:37' prior: 50351805!
   withBytes: aByteArray
	"Remove a possible and useless BOM (byte order mark)"
	
	| bom bytesToUse |
	bom _ `Character utf8BytesOfUnicodeCodePoint: 16rFEFF`.
	bytesToUse _ (aByteArray beginsWith: bom)
		ifFalse: [aByteArray]
		ifTrue: [aByteArray copyFrom: bom size+1 to: aByteArray size].
	^self new bytes: bytesToUse ! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5163-Utf8String-withBytes-removePossibleBOM-JuanVuletich-2022May13-20h37m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5163] on 14 May 2022 at 9:12:38 am'!
!Collection methodsFor: 'accessing' stamp: 'len 5/14/2022 09:12:04' prior: 50358243!
               atRandom: aGenerator 
	"Answer a random element of the receiver.  Uses aGenerator which 
	should be kept by the user in a variable and used every time. Use 
	this instead of #atRandom for better uniformity of random numbers  
	because only you use the generator.  Causes an error if self has no  
	elements.
	WARNING: This implementation cannot guarantee reproducibility.
	Calling twice with generators setup with the same seed can produce
	different results (for example if the collection is rehashed between calls).
	If you need reproducibility, you should convert the collection to a sequenceable
	collection first."
	| n |
	self emptyCheck.
	n _ self size atRandom: aGenerator.
	self do: [:each| (n _ n - 1) = 0 ifTrue: [^ each]].
	self error: 'collection invariants broken'! !
!Bag methodsFor: 'accessing' stamp: 'len 5/14/2022 09:11:46' prior: 50358260 overrides: 50358314!
                atRandom: aGenerator 
	"Answer a random element of the receiver.  Uses aGenerator which 
	should be kept by the user in a variable and used every time. Use 
	this instead of #atRandom for better uniformity of random numbers  
	because only you use the generator.  Causes an error if self has no  
	elements.
	WARNING: This implementation cannot guarantee reproducibility.
	Calling twice with generators setup with the same seed can produce
	different results (for example if the collection is rehashed between calls).
	If you need reproducibility, you should convert the collection to a sequenceable
	collection first."
	| n |
	self emptyCheck.
	n _ self size atRandom: aGenerator.
	self withOccurrencesDo: [:each :times| (n _ n - times) <= 0 ifTrue: [^ each]].
	self error: 'collection invariants broken'! !
!Set methodsFor: 'accessing' stamp: 'len 5/14/2022 09:11:53' prior: 16935639 overrides: 50358314!
                     atRandom: aGenerator 
	"Answer a random element of the receiver.  Uses aGenerator which 
	should be kept by the user in a variable and used every time. Use 
	this instead of #atRandom for better uniformity of random numbers  
	because only you use the generator.  Causes an error if self has no  
	elements.
	WARNING: This implementation cannot guarantee reproducibility.
	Calling twice with generators setup with the same seed can produce
	different results (for example if the collection is rehashed between calls).
	If you need reproducibility, you should convert the collection to a sequenceable
	collection first."
	self emptyCheck.
	[(array atRandom: aGenerator) ifNotNil: [:element| ^ element]] repeat! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5164-RandomTweaks-LucianoEstebanNotarfrancesco-2022May14-08h19m-len.001.cs.st----!

'From Cuis 6.0 [latest update: #5163] on 14 May 2022 at 12:37:05 pm'!
!Class class methodsFor: 'instance creation' stamp: 'jmv 5/14/2022 12:36:35' prior: 50342113!
        templateForSubclassOf: priorClass category: systemCategoryName 
	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"

	^ priorClass name asPlainString, ' subclass: #NameOfSubclass
	instanceVariableNames: ''''
	classVariableNames: ''''
	poolDictionaries: ''''
	category: ''' , systemCategoryName asPlainString , ''''! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5165-newClassTemplate-fix-JuanVuletich-2022May14-12h36m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5160] on 13 May 2022 at 5:25:53 pm'!
!Parser methodsFor: 'scanning' stamp: 'jmv 5/13/2022 17:24:55' prior: 50349736!
             transformVerticalBarAndUpArrowIntoABinarySelector
	"Transform a vertical bar and or a up arrow into a binary selector.
	Eventually aggregate a series of consecutive vertical bars, up arrows, colons and regular binary selector characters.
	Note that this aggregation cannot occur at scan time, because a pair of vertical bars can be encountered in two valid constructs:
	- either as an empty temporaries specification,
	- or as a local temporaries specification in a block of arity > 0.
	Colon $: can be used as binary, but '::' means Chain.
	Another special case is binary selectors ending in $-, like in
	1@-2
	This could be interpreted as `1 @ -2` or `1 @- 2`. Preference #atMinusDigitMeaning tells what to do."

	| toMakeBinary |
	"Special case: '::' is not a binary selector but the Chain operator"
	(hereType = #colon and: [tokenType = #colon]) ifTrue: [^ self ].
	"Note: Also include #binary, to allow stuff like #+| where a special character comes after after a regular binary operator character. "
	toMakeBinary _ #(binary verticalBar upArrow colon).
	(toMakeBinary identityIncludes: hereType) ifFalse: [
		^ self ].
	here _ here asPlainString.
	hereType _ #binary.
	[(toMakeBinary identityIncludes: tokenType) and: [hereMark + here size = mark]]
		whileTrue: [
			(token == #- and: [source peekBack isDigit])
				ifTrue: [
					(PreferenceNG at: #atMinusDigitMeaning) == #disabled
						"Disallow `1@-2`. Insists on some whitespace to disambiguate."
						ifTrue: [ ^self expected: 'A space character after selector' ].
					(PreferenceNG at: #atMinusDigitMeaning) == #st80
						ifTrue: [ ^self ].				"interpret `1@-2` like `1 @ -2`"
					"Assume (PreferenceNG at: #atMinusDigitMeaning) == #ansiSmalltalk
					interpret `1@-2` like `1 @- 2`, i.e. consider #@- a valid binary selector"
					].
			here _ here , token asPlainString.
			hereEnd _ hereEnd + 1.
			self scanToken ].! !
!PreferenceNG class methodsFor: 'data' stamp: 'jmv 5/13/2022 17:15:11' prior: 50357771!
     prefProgramming
	^ #(
		#(atMinusDigitMeaning st80 #(st80 ansiSmalltalk disabled) )
		#(allowBlockArgumentAssignment false )
		#(alternativeBrowseIt false )
		#(assignmentGlyphSelector useLeftArrow #(useLeftArrow useAlwaysLeftArrow) assignmentGlyph: )
		#(backgroundColorFillsAllBackground true )
		#(browseWithPrettyPrint false )
		#(classAnnotations #(instanceMethodsCount classMethodsCount linesOfCode) )
		#(debugHaloHandle true )
		#(debugLogTimestamp true )
		#(debugShowDamage false )
		#(decorateBrowserButtons true )
		#(diffsInChangeList true )
		#(diffsWithPrettyPrint false )
		#(extraDebuggerButtons true )
		#(fullPrintItInWorkspaces false )
		#(highlightBlockNesting true )
		#(italicsInShout true)
		#(leftArrowAssignmentsInGeneratedCode false )
		#(listClassesHierarchically true )
		#(logDebuggerStackToFile false )
		#(methodAnnotations #(timeStamp linesOfCode messageCategory implementorsCount sendersCount  packages changeSets) )	
		#(prettyPrintRectangularBlocks false )
		#(shiftClickShowsImplementors false )
		#(shoutInWorkspaces true )
		#(showAnnotations true )
		#(showLinesInHierarchyViews true )
		#(stylingWithEmphasisInWorkspaces false )
		#(systemCategoryAnnotations #(classCount instanceMethodsCount classMethodsCount linesOfCode) )
		#(syntaxHighlightingAsYouType true )
		#(syntaxHighlightingAsYouTypeAnsiAssignment false )
		#(syntaxHighlightingAsYouTypeLeftArrowAssignment false )
		#(thoroughSenders true )
		#(usePreDebugWindow false)
	)! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
PreferenceNG name: #atMinusDigitMeaning description: 'Specifies behavior for code such as `@-2`.' category: #programming type: #(st80 ansiSmalltalk disabled) value: #st80!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5166-AtMinusDigit-inSmalltalkCode-defaultTo-st80-JuanVuletich-2022May13-17h15m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5166] on 15 May 2022 at 12:22:37 pm'!
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 5/14/2022 11:42:57'!
     allPreferences
	^ ThePreferences 
	! !
!PreferenceNG class methodsFor: 'accessing' stamp: 'hlsf 5/15/2022 12:17:37'!
           selectCategory: aCategory
" I select the preferences of the given category "
	^ ThePreferences values select: [:aPreference | aPreference category == aCategory ]! !
!PreferenceNG class methodsFor: 'class initialization' stamp: 'hlsf 5/15/2022 12:21:27' prior: 50353028 overrides: 16904184!
                              initialize
    	ThePreferences ifNil: [ThePreferences _ Dictionary new].
	#(gui font programming system) do: [: category | 
		(self perform: (#pref, category capitalized) asSymbol) do: [:aPrefArray |
			self installDefault: aPrefArray in: category] ].
	self installHaloPreferencesWith: self iconicHaloSpecifications.
	self installMiscPreferences.
	self defaultFontSize: #standardFonts.
	self setDefaultFont: FontFamily defaultFamilyName.! !
!PreferenceNG class methodsFor: 'fileIn/Out' stamp: 'hlsf 5/15/2022 12:21:53' prior: 50353143!
        saveCategory: categorySymbol to: aFileEntry
	| myPref |
	myPref _ self selectCategory: categorySymbol.
	SmartRefStream 
		dumpOnFile: aFileEntry 
		object: 	(myPref collect: [:aPref | aPref name -> aPref ]) asDictionary! !

PreferenceNG class removeSelector: #select:!

!methodRemoval: PreferenceNG class #select: stamp: 'Install-5167-TweaksFor-PreferenceNG-HilaireFernandes-2022May15-12h16m-hlsf.001.cs.st 5/16/2022 10:22:26'!
select: aCategory
" I select the preferences of the given category "
	^ ThePreferences values select: [:aPreference | aPreference category == aCategory ]!

PreferenceNG class removeSelector: #all!

!methodRemoval: PreferenceNG class #all stamp: 'Install-5167-TweaksFor-PreferenceNG-HilaireFernandes-2022May15-12h16m-hlsf.001.cs.st 5/16/2022 10:22:26'!
all
	^ ThePreferences 
	!

PreferenceNG initialize!

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5167-TweaksFor-PreferenceNG-HilaireFernandes-2022May15-12h16m-hlsf.001.cs.st----!

'From Cuis 6.0 [latest update: #5166] on 15 May 2022 at 8:34:54 pm'!
!WeakMessageSend methodsFor: 'private' stamp: 'jmv 5/15/2022 20:32:23' prior: 16980070!
                        collectArguments: anArgArray
	"Private"
    | staticArgs |
    staticArgs := self arguments.
    ^(anArgArray size = staticArgs size)
        ifTrue: [anArgArray]
        ifFalse:
            [(staticArgs isEmpty
                ifTrue: [ staticArgs := Array new: selector numArgs]
                ifFalse: [staticArgs asNewArray] )
                    replaceFrom: 1
                    to: (anArgArray size min: staticArgs size)
                    with: anArgArray
                    startingAt: 1]
! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5168-WeakMessageSend-fix-JuanVuletich-2022May15-20h27m-jmv.001.cs.st----!

'From Cuis 6.0 [latest update: #5168] on 16 May 2022 at 9:11:51 am'!
!Point methodsFor: 'printing' stamp: 'jmv 5/16/2022 09:05:30' prior: 50352797 overrides: 16902975!
                          printOn: aStream 
	"The receiver prints on aStream in terms of infix notation."

	x printOn: aStream.
	aStream nextPut: $@.
	y negative ifTrue: [ aStream space ].
	y printOn: aStream! !

----End fileIn of C:\Users\Juan Vuletich\Cuis-Smalltalk\Cuis-Smalltalk-Dev\CoreUpdates\5169-Point-printOn-NoExtraSpaceIfPositiveY-JuanVuletich-2022May16-09h11m-jmv.001.cs.st----!

----QUIT----(16 May 2022 10:22:34) Cuis6.0-5169.image priorSource: 147673!