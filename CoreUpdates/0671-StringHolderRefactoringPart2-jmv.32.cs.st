'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 25 November 2010 at 12:21:51 am'!!classDefinition: #Clipboard category: #'System-Support'!Object subclass: #Clipboard	instanceVariableNames: 'contents recent'	classVariableNames: 'Default'	poolDictionaries: ''	category: 'System-Support'!!classDefinition: #TextHolder category: #'System-Text'!Model subclass: #TextHolder	instanceVariableNames: 'actualContents'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!TextHolder commentStamp: '<historical>' prior: 0!I am a kind of Model that includes a piece of text.  In some cases, the text can be edited, and in some the text is a method.Categories 'code pane menu' and 'message list menu' are messages that may be called by my menus when the text is a method, and when some pane is a list of methods.  Other of my subclasses may ignore these two catagories altogether.See the comment in CodeHolder. When the Smalltalk code specific code in this class is moved down to CodeHolder, see inheritance of #paneMenu:shifted: and #editorClass. This method is redefined in subclasses that should perhaps be made subclasses of CodeHolder.!!classDefinition: #AcceptingTextHolder category: #'System-Text'!TextHolder subclass: #AcceptingTextHolder	instanceVariableNames: 'acceptedContentsCache'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!AcceptingTextHolder commentStamp: '<historical>' prior: 0!A TextHolder that can accept or discard typed text, like a browser on a method.!!classDefinition: #CodeHolder category: #'System-Text'!AcceptingTextHolder subclass: #CodeHolder	instanceVariableNames: 'currentCompiledMethod contentsSymbol '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!classDefinition: #FileList category: #'Tools-FileList'!AcceptingTextHolder subclass: #FileList	instanceVariableNames: 'fileName directory volList volListIndex list listIndex pattern sortMode brevityState sortAscending '	classVariableNames: 'FileReaderRegistry RecentDirs '	poolDictionaries: ''	category: 'Tools-FileList'!!classDefinition: #FillInTheBlank category: #'Tools-Menus'!TextHolder subclass: #FillInTheBlank	instanceVariableNames: 'acceptOnCR done responseUponCancel '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!!classDefinition: #Inspector category: #'Tools-Inspector'!AcceptingTextHolder subclass: #Inspector	instanceVariableNames: 'object selectionIndex timeOfLastListUpdate selectionUpdateTime context '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!classDefinition: #SyntaxError category: #'Tools-Debugger'!TextHolder subclass: #SyntaxError	instanceVariableNames: 'class selector category debugger doitFlag '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!!classDefinition: #Workspace category: #'System-Text'!TextHolder subclass: #Workspace	instanceVariableNames: 'bindings mustDeclareVariables shouldStyle '	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!FillInTheBlankMorph methodsFor: 'menu' stamp: 'jmv 11/24/2010 14:50'!paneMenu: aMenu shifted: shifted editorClass: anEditorClass	^ TextHolder new paneMenu: aMenu shifted: shifted editorClass: anEditorClass! !!ObjectExplorer methodsFor: 'accessing' stamp: 'jmv 11/24/2010 18:37'!explorerFor: anObject 	| window listMorph |	rootObject := anObject.	window := (SystemWindow labelled: (rootObject printStringLimitedTo: 64)) model: self.	window addMorph: (listMorph := SimpleHierarchicalListMorph 						model: self						listGetter: #getList						indexGetter: #getCurrentSelection						indexSetter: #noteNewSelection:						menuGetter: #genericMenu:						keystrokeAction: #explorerKey:from:)		frame: (0 @ 0 corner: 1 @ 0.8).	window 		addMorph: ((PluggableTextMorph 				model: self				editorClass: self editorClass				textGetter: nil				textSetter: nil				selectionGetter: nil				menuGetter: #paneMenu:shifted:editorClass:) askBeforeDiscardingEdits: false)		frame: (0 @ 0.8 corner: 1 @ 1).	listMorph autoDeselect: false.	^window! !!ObjectExplorer methodsFor: 'menus' stamp: 'jmv 11/24/2010 14:51'!paneMenu: aMenu shifted: shifted editorClass: anEditorClass	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ TextHolder basicNew paneMenu: aMenu shifted: shifted editorClass: anEditorClass! !!ObjectExplorer class methodsFor: 'as yet unclassified' stamp: 'jmv 11/24/2010 14:51'!about	TextHolder new contents: self comment; openLabel: 'about ',self asString! !!SmartRefStream class methodsFor: 'as yet unclassified' stamp: 'jmv 11/24/2010 14:51'!statsOfSubObjects: anObject	"Open a window with statistics on what objects would be written out with anObject.  Does not actually write on the disk.  Stats in the form:	ScriptEditorMorph 51		SortedCollection (21->LayoutMorph 15->SimpleButtonMorph 9->Array 4->CompoundTileMorph 2->StringMorph )"	| dummy printOut |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	"(dummy references) is the raw data"	printOut _ dummy statisticsOfRefs.	(TextHolder new contents: printOut) 		openLabel: 'ReferenceStream statistics'.! !!SmartRefStream class methodsFor: 'as yet unclassified' stamp: 'jmv 11/24/2010 14:51'!tallyOfSubObjects: anObject	"Open a window with statistics on what objects would be written out with anObject.  Does not actually write on the disk.  Stats are simply the number of instances of each class:	1450->Point   835->Rectangle   549->Array   300->String"	| dummy bag |	dummy _ ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	bag _ Bag new.	dummy references keysDo: [:key | bag add: key class name].	"(bag sortedCounts) is the SortedCollection"	(TextHolder new contents: bag sortedCounts printString) 		openLabel: 'ReferenceStream statistics'.! !!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 11/24/2010 14:51'!compareTallyIn: beforeFileName to: afterFileName	"SpaceTally new compareTallyIn: 'tally' to: 'tally2'"	| answer s beforeDict a afterDict allKeys before after diff |	beforeDict _ Dictionary new.	s _ FileDirectory default fileNamed: beforeFileName.	 [s atEnd ] whileFalse: [		a _ Array readFrom: s nextLine.		beforeDict at: a first put: a allButFirst.	].	s close.	afterDict _ Dictionary new.	s _ FileDirectory default fileNamed: afterFileName.	[ s atEnd ] whileFalse: [		a _ Array readFrom: s nextLine.		afterDict at: a first put: a allButFirst.	].	s close.	answer _ WriteStream on: String new.	allKeys _ (Set new addAll: beforeDict keys; addAll: afterDict keys; yourself) asArray sort.	allKeys do: [ :each |		before _ beforeDict at: each ifAbsent: [#(0 0 0)].		after _ afterDict at: each ifAbsent: [#(0 0 0)].		diff _ before with: after collect: [ :vBefore :vAfter | vAfter - vBefore].		diff = #(0 0 0) ifFalse: [			answer nextPutAll: each, '  ', diff printString; cr.		].	].	TextHolder new contents: answer contents; openLabel: 'space diffs'! !!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 11/24/2010 14:51'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text2'.		SpaceTally new printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f _ FileStream readOnlyFileNamed: fileName1.	coll1 _ OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: (f upTo: Character cr)].	f close.	f _ FileStream readOnlyFileNamed: fileName2.	coll2 _ OrderedCollection new.	[f atEnd] whileFalse:		[item _ (f upTo: Character cr).		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(TextHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!String methodsFor: 'user interface' stamp: 'jmv 11/24/2010 14:51'!edit	TextHolder new contents: self; openLabel: 'Text Editor'! !!Text methodsFor: 'user interface' stamp: 'jmv 11/24/2010 14:51'!edit	TextHolder new contents: self; openLabel: 'Text Editor'! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/24/2010 14:51'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 _ self clipboardText string.	s2 _ paragraph string.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(TextHolder new contents:		(DifferenceFinder displayPatchFrom: s1 to: s2 tryWords: true))			openLabel: 'Comparison to Clipboard Text'! !!TextHolder methodsFor: 'initialize-release' stamp: 'jmv 11/24/2010 18:01'!initialize	"Initialize the state of the receiver with its default contents."	actualContents _ '' asText! !!TextHolder methodsFor: 'initialize-release' stamp: 'jmv 11/24/2010 14:35'!openAsMorphLabel: labelString 	"Workspace new openAsMorphLabel: 'Workspace'"	self openInMorphicWindowLabeled: labelString wrap: true! !!TextHolder methodsFor: 'initialize-release' stamp: 'jmv 11/24/2010 18:32'!openInMorphicWindowLabeled: labelString wrap: aBoolean	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: ((PluggableTextMorph 		model: self 		editorClass: self editorClass		textGetter: #actualContents 		textSetter: nil		selectionGetter: nil 		menuGetter: #paneMenu:shifted:editorClass:)			wrapFlag: aBoolean)				frame: (0@0 corner: 1@1).	^ window openInWorld! !!TextHolder methodsFor: 'initialize-release' stamp: 'jmv 11/24/2010 14:35'!openLabel: aString 	"Create a standard system view of the model, me, a StringHolder and open it.  If in mvc, terminate the active controller so that the new window will immediately be activated."	self openAsMorphLabel: aString! !!TextHolder methodsFor: 'initialize-release' stamp: 'jmv 11/24/2010 14:35'!openLabel: aString wrap: aBoolean	"Create a standard system view of the model, me, a StringHolder and open it."	self openInMorphicWindowLabeled: aString wrap: aBoolean! !!TextHolder methodsFor: 'accessing' stamp: 'jmv 11/24/2010 18:29'!actualContents	^actualContents! !!TextHolder methodsFor: 'accessing' stamp: 'jmv 11/24/2010 23:42'!actualContents: aTextOrString	actualContents _ aTextOrString ifNotNil: [ aTextOrString asText ]! !!TextHolder methodsFor: 'accessing' stamp: 'jmv 11/24/2010 14:35'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^ 1 to: 0  "null selection"! !!TextHolder methodsFor: 'code pane menu' stamp: 'jmv 11/24/2010 14:35'!editorClass	^TextEditor! !!TextHolder methodsFor: 'code pane menu' stamp: 'jmv 11/24/2010 14:35'!paneMenu: aMenu shifted: shifted editorClass: anEditorClass	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| donorMenu |	donorMenu _ shifted		ifTrue: [			anEditorClass shiftedYellowButtonMenu]		ifFalse: [			anEditorClass yellowButtonMenu].	aMenu labels: donorMenu labelString lines: donorMenu lineArray selections: donorMenu selections.	aMenu addTitle: 'Text Editor'; addStayUpIcons.	^aMenu! !!TextHolder methodsFor: 'code pane menu' stamp: 'jmv 11/24/2010 14:35'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!TextHolder methodsFor: 'user edits' stamp: 'jmv 11/24/2010 14:35'!clearUserEditFlag	"Clear the hasUnacceptedEdits flag in all my dependent views."	self changed: #clearUserEdits! !!TextHolder methodsFor: 'user edits' stamp: 'jmv 11/24/2010 14:35'!okToChange	self canDiscardEdits ifTrue: [^ true].	self changed: #wantToChange.  "Solicit cancel from view"	^ self canDiscardEdits! !!TextHolder methodsFor: 'services' stamp: 'jmv 11/24/2010 14:35'!offerMenuFrom: menuRetriever shifted: aBoolean 	"Pop up, in morphic or mvc as the case may be, a menu whose target is the receiver and whose contents are provided by sending the menuRetriever to the receiver.  The menuRetriever takes two arguments: a menu, and a boolean representing the shift state."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.			self 				perform: menuRetriever				with: aMenu				with: aBoolean.			aMenu popUpInWorld! !!AcceptingTextHolder methodsFor: 'initialize-release' stamp: 'jmv 11/25/2010 00:10'!initialize	"Initialize the state of the receiver with its default contents."	super initialize.	acceptedContentsCache _ ''! !!AcceptingTextHolder methodsFor: 'contents' stamp: 'jmv 11/25/2010 00:04'!acceptedContents	^ Text		initialFont: Preferences standardCodeFont		stringOrText: self acceptedStringOrText! !!AcceptingTextHolder methodsFor: 'contents' stamp: 'jmv 11/24/2010 23:50'!acceptedContentsChanged	self changed: #acceptedContents! !!AcceptingTextHolder methodsFor: 'contents' stamp: 'jmv 11/25/2010 00:04'!acceptedStringOrText	^self subclassResponsibility! !!AcceptingTextHolder methodsFor: 'contents' stamp: 'jmv 11/24/2010 18:10'!copy	^super copy! !!CodeHolder methodsFor: 'contents' stamp: 'jmv 11/24/2010 14:53'!acceptedContentsChanged	self changed: #acceptedContents.	self changed: #annotation! !!CodeHolder methodsFor: 'contents' stamp: 'jmv 11/25/2010 00:04'!acceptedStringOrText	"Answer the source code or documentation for the selected method"	self showingByteCodes ifTrue: [		^ self selectedBytecodes].	self showingDocumentation ifTrue: [		^ self commentContents].	^ self selectedMessage! !!CodeHolder methodsFor: 'contents' stamp: 'jmv 11/24/2010 14:20'!contentsSymbol: aSymbol	"Set the contentsSymbol as indicated.  #source means to show source code, #comment means to show the first comment found in the source code"	contentsSymbol _ aSymbol.	self setContentsToForceRefetch.	self acceptedContentsChanged! !!CodeHolder methodsFor: 'commands' stamp: 'jmv 11/24/2010 14:33'!spawnToClass: aClass	"Used to copy down code from a superclass to a subclass in one easy step, if you know what you're doing.  Spawns a new message-category browser for the indicated class, populating it with the source code seen in the current tool."	| newBrowser org |		self categoryOfCurrentMethod		ifNil: [			self buildClassBrowserEditString: self acceptedContents]		ifNotNil: [ :category |			((org _ aClass organization) categories includes: category)				ifFalse:	[org addCategory: category].			newBrowser _ Browser new setClass: aClass selector: nil.			newBrowser selectMessageCategoryNamed: category.			Browser openBrowserView: (newBrowser openMessageCatEditString: self acceptedContents)				label: 'category "', category, '" in ', 					newBrowser selectedClassOrMetaClassName]! !!CodeHolder methodsFor: 'construction' stamp: 'jmv 11/24/2010 14:25'!buildMorphicCodePaneWith: editString	"Construct the pane that shows the code.	Respect the Preference for standardCodeFont."	| codePane |	codePane := PluggableTextMorph				model: self				editorClass: self editorClass				textGetter: #acceptedContents				textSetter: #contents:notifying:				selectionGetter: #contentsSelection				menuGetter: #paneMenu:shifted:editorClass:.	editString		ifNotNil: [			codePane editString: editString.			codePane hasUnacceptedEdits: true].	^ codePane! !!CodeHolder methodsFor: 'self-updating' stamp: 'jmv 11/24/2010 14:20'!updateCodePaneIfNeeded	"If the code for the currently selected method has changed underneath me, then update the contents of my code pane unless it holds unaccepted edits"	self didCodeChangeElsewhere		ifTrue: [			self hasUnacceptedEdits				ifFalse: [					self setContentsToForceRefetch.					self acceptedContentsChanged]				ifTrue: [					self changed: #codeChangedElsewhere]]! !!CodeHolder methodsFor: 'what to show' stamp: 'jmv 11/25/2010 00:12'!setContentsToForceRefetch	"Set the receiver's contents such that on the next update the contents will be formulated afresh.  This is a critical and obscure difference between Browsers on the one hand and MessageSets on the other, and has over the years been the source of much confusion and much difficulty.  By centralizing the different handling here, we don't need so many idiosyncratic overrides in MessageSet any more"	acceptedContentsCache _ nil! !!CodeHolder methodsFor: 'message list' stamp: 'jmv 11/25/2010 00:19'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			acceptedContentsCache _ (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [			tempNames := (class compilerClass new						parse: method getSourceFromFile asString						in: class						notifying: nil) tempNames.			acceptedContentsCache _ ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	acceptedContentsCache _ (acceptedContentsCache asText makeSelectorBoldIn: class).	^ acceptedContentsCache copy! !!CodeHolder methodsFor: 'message list' stamp: 'jmv 11/25/2010 00:18'!selectedMessage	"Answer a copy of the source code for the selected message.  This generic version is probably actually never reached, since every subclass probably reimplements and does not send to super.  In time, ideally, most, or all, reimplementors would vanish and all would defer instead to a universal version right here.  Everything in good time."	| class selector method |	acceptedContentsCache ifNotNil: [ :c | ^ c copy].	self showingDecompile ifTrue: [		^ self decompiledSourceIntoContentsWithTempNames: false ].	class _ self selectedClassOrMetaClass.	(class isNil or: [(selector _ self selectedMessageName) isNil]) ifTrue: [^ ''].	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	^ acceptedContentsCache _((self showComment		ifFalse: [self sourceStringPrettifiedAndDiffed]		ifTrue:	[ self commentContents])			copy asText makeSelectorBoldIn: class)! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 11/24/2010 14:20'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self acceptedContentsChanged! !!CodeHolder methodsFor: 'message list menu' stamp: 'jmv 11/24/2010 14:20'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [self changed: #flash.  ^ Beeper beep].	changeRecords second fileIn.	self acceptedContentsChanged! !!Browser methodsFor: 'accessing' stamp: 'jmv 11/25/2010 00:04'!acceptedStringOrText	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass _ self selectedClass)			ifNil: [				Class template: self selectedSystemCategoryName]			ifNotNil: [				Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue: [			^ self classDefinitionText ].	editSelection == #editComment 		ifTrue: [			(theClass _ self selectedClass) ifNil: [^ ''].			comment _ theClass comment.			currentCompiledMethod _ theClass organization commentRemoteStr.			^ comment size = 0				ifTrue: ['This class has not yet been commented.']				ifFalse: [comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue: [			^ (theClass _ self selectedClassOrMetaClass) 				ifNil: ['']				ifNotNil: [theClass sourceCodeTemplate]].	editSelection == #editMessage		ifTrue: [			self showingByteCodes ifTrue: [^ self selectedBytecodes].			currentCompiledMethod _ latestCompiledMethod.			^ self selectedMessage].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'class functions' stamp: 'jmv 11/24/2010 14:13'!editClass	"Retrieve the description of the class definition."	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	self editSelection: #editClass.	self acceptedContentsChanged.	self changed: #classCommentText.! !!Browser methodsFor: 'class functions' stamp: 'jmv 11/24/2010 14:19'!editComment	"Retrieve the description of the class comment."	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	metaClassIndicated _ false.	self editSelection: #editComment.	self changed: #classSelectionChanged.	self changed: #messageCategoryList.	self changed: #messageList.	self decorateButtons.	self acceptedContentsChanged! !!Browser methodsFor: 'class functions' stamp: 'jmv 11/24/2010 14:19'!hierarchy	"Display the inheritance hierarchy of the receiver's selected class."	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	self editSelection: #hierarchy.	self changed: #editComment.	self acceptedContentsChanged.	^ self! !!Browser methodsFor: 'class functions' stamp: 'jmv 11/24/2010 14:19'!makeNewSubclass	self selectedClassOrMetaClass ifNil: [^ self].	self okToChange ifFalse: [^ self].	self editSelection: #newClass.	self acceptedContentsChanged! !!Browser methodsFor: 'class functions' stamp: 'jmv 11/24/2010 14:19'!plusButtonHit	"Cycle among definition, comment, and hierachy"	editSelection == #editComment		ifTrue: [self hierarchy. ^ self].	editSelection == #hierarchy		ifTrue: [self editSelection: #editClass.			classListIndex = 0 ifTrue: [^ self].			self okToChange ifFalse: [^ self].			self changed: #editComment.			self acceptedContentsChanged.			^ self].	self editComment! !!Browser methodsFor: 'class list' stamp: 'jmv 11/25/2010 00:11'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className |	classListIndex _ anInteger.	self setClassOrganizer.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self classCommentIndicated		ifFalse: [self editSelection: (anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex = 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass])].	acceptedContentsCache _ nil.	self selectedClass		ifNotNil: [			className _ self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classCommentText.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self acceptedContentsChanged! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 11/25/2010 00:11'!systemOrganizer: aSystemOrganizer	"Initialize the receiver as a perspective on the system organizer, 	aSystemOrganizer. Typically there is only one--the system variable 	SystemOrganization."	acceptedContentsCache _ nil.	systemOrganizer _ aSystemOrganizer.	systemCategoryListIndex _ 0.	classListIndex _ 0.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	metaClassIndicated _ false.	self setClassOrganizer.	self editSelection: #none.! !!Browser methodsFor: 'message category functions' stamp: 'jmv 11/24/2010 14:19'!editMessageCategories	"Indicate to the receiver and its dependents that the message categories of 	the selected class have been changed."	self okToChange ifFalse: [^ self].	classListIndex ~= 0		ifTrue: [			self messageCategoryListIndex: 0.			self editSelection: #editMessageCategories.			self changed: #editMessageCategories.			self acceptedContentsChanged ]! !!Browser methodsFor: 'message category list' stamp: 'jmv 11/25/2010 00:11'!messageCategoryListIndex: anInteger	"Set the selected message category to be the one indexed by anInteger."	messageCategoryListIndex _ anInteger.	messageListIndex _ 0.	self changed: #messageCategorySelectionChanged.	self changed: #messageCategoryListIndex. "update my selection"	self changed: #messageList.	self editSelection: (anInteger > 0		ifTrue: [#newMessage]		ifFalse: [self classListIndex > 0			ifTrue: [#editClass]			ifFalse: [#newClass]]).	acceptedContentsCache _ nil.	self acceptedContentsChanged.! !!Browser methodsFor: 'message functions' stamp: 'jmv 11/25/2010 00:13'!defineMessageFrom: aString notifying: aController	"Compile the expressions in aString. Notify aController if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."	| selectedMessageName selector category oldMessageList |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	acceptedContentsCache _ nil.	selector _ (Smalltalk actualParserClass new parseSelector: aString).	(self metaClassIndicated		and: [(self selectedClassOrMetaClass includesSelector: selector) not		and: [Metaclass isScarySelector: selector]])		ifTrue: ["A frist-time definition overlaps the protocol of Metaclasses"				(self confirm: ((selector , ' is used in the existing class system.Overriding it could cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: selector size))				ifFalse: [^nil]].	selector _ self selectedClassOrMetaClass				compile: aString				classified: (category _ self selectedMessageCategoryName)				notifying: aController.	selector		ifNil: [^ nil].	acceptedContentsCache _ aString copy.	selector ~~ selectedMessageName		ifTrue: [			category = ClassOrganizer nullCategory				ifTrue: [self changed: #classSelectionChanged.						self changed: #classList.						self messageCategoryListIndex: 1].			self setClassOrganizer.  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self changed: #messageList].			self messageListIndex: (self messageList indexOf: selector)].	^ selector! !!Browser methodsFor: 'message list' stamp: 'jmv 11/24/2010 14:19'!messageListIndex: anInteger	"Set the selected message selector to be the one indexed by anInteger."	messageListIndex _ anInteger.	self editSelection: (anInteger > 0		ifTrue: [#editMessage]		ifFalse: [self messageCategoryListIndex > 0			ifTrue: [#newMessage]			ifFalse: [self classListIndex > 0				ifTrue: [#editClass]				ifFalse: [#newClass]]]).	self setContentsToForceRefetch.	self changed: #messageListIndex. "update my selection"	self acceptedContentsChanged.	self decorateButtons.! !!Browser methodsFor: 'message list' stamp: 'jmv 11/25/2010 00:18'!selectedMessage	"Answer a copy of the source code for the selected message."	| class selector method |	acceptedContentsCache ifNotNil: [ :c | ^ c copy].	self showingDecompile ifTrue: [		^ self decompiledSourceIntoContentsWithTempNames: false ].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	^ acceptedContentsCache _ ((self showingDocumentation		ifFalse: [ self sourceStringPrettifiedAndDiffed ]		ifTrue: [ self commentContents ])			copy asText makeSelectorBoldIn: class)! !!Browser methodsFor: 'metaclass' stamp: 'jmv 11/25/2010 00:11'!metaClassIndicated: trueOrFalse 	"Indicate whether browsing instance or class messages."	metaClassIndicated _ trueOrFalse.	self setClassOrganizer.	systemCategoryListIndex > 0 ifTrue:		[self editSelection: (classListIndex = 0			ifTrue: [metaClassIndicated				ifTrue: [#none]				ifFalse: [#newClass]]			ifFalse: [#editClass])].	messageCategoryListIndex _ 0.	messageListIndex _ 0.	acceptedContentsCache _ nil.	self changed: #classSelectionChanged.	self changed: #messageCategoryList.	self changed: #messageList.	self acceptedContentsChanged.	self decorateButtons! !!Browser methodsFor: 'system category functions' stamp: 'jmv 11/24/2010 14:19'!editSystemCategories	"Retrieve the description of the class categories of the system organizer."	self okToChange ifFalse: [^ self].	self systemCategoryListIndex: 0.	self editSelection: #editSystemCategories.	self changed: #editSystemCategories.	self acceptedContentsChanged! !!Browser methodsFor: 'system category list' stamp: 'jmv 11/25/2010 00:11'!systemCategoryListIndex: anInteger 	"Set the selected system category index to be anInteger. Update all other 	selections to be deselected."	systemCategoryListIndex _ anInteger.	classListIndex _ 0.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self editSelection: ( anInteger = 0 ifTrue: [#none] ifFalse: [#newClass]).	metaClassIndicated _ false.	self setClassOrganizer.	acceptedContentsCache _ nil.	self changed: #systemCategorySelectionChanged.	self changed: #systemCategoryListIndex.	"update my selection"	self changed: #classList.	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self acceptedContentsChanged! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 11/24/2010 14:25'!buildMorphicCodePaneWith: editString	| codePane |	codePane _ PluggableTextMorph		model: self		editorClass: self editorClass		textGetter: #acceptedContents 		textSetter: nil		selectionGetter: nil		menuGetter: #paneMenu:shifted:editorClass:.	editString ifNotNil: [		codePane editString: editString.		codePane hasUnacceptedEdits: true	].	^codePane! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 11/24/2010 23:39'!compareToCurrentVersion	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"	| change class s1 s2 differDesc diffWords |	listIndex = 0		ifTrue: [^ self].	change _ changeList at: listIndex.	((class _ change methodClass) notNil			and: [class includesSelector: change methodSelector])		ifTrue: [			s1 _ (class sourceCodeAt: change methodSelector) asString.			s2 _ change string.			s1 = s2				ifTrue: [^ self inform: 'Exact Match'].			diffWords _ self shouldDiffWords.			differDesc _ diffWords				ifTrue: [ 'Words']				ifFalse: [ 'Lines'].			(TextHolder new				actualContents: (					(DifferenceFinder						displayPatchFrom: s1 to: s2						tryWords: diffWords						prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [class]))							initialFont: Preferences standardCodeFont))				openLabel: 'Comparison to Current Version: ', differDesc, 					(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])]		ifFalse: [self flash]! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 11/24/2010 14:20'!deselectAll 	"Deselect all items in the list pane, and clear the code pane"	listIndex _ 0.	listSelections atAllPut: false.	self changed: #allSelections.	self acceptedContentsChanged! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 11/24/2010 14:20'!invertSelections	"Invert the selectedness of each item in the changelist"	listSelections _ listSelections collect: [ :ea | ea not].	listIndex _ 0.	self changed: #allSelections.	self acceptedContentsChanged! !!ChangeList methodsFor: 'viewing access' stamp: 'jmv 11/25/2010 00:04'!acceptedStringOrText	"Answer the contents string, obeying diffing directives if needed"	^ self showingAnyKindOfDiffs		ifFalse: [			self undiffedContents]		ifTrue: [			self showsVersions				ifTrue: [					self diffedVersionContents]				ifFalse: [					self contentsDiffedFromCurrent]]! !!ChangeList methodsFor: 'viewing access' stamp: 'jmv 11/24/2010 14:20'!toggleListIndex: newListIndex	listIndex ~= 0 ifTrue: [listSelections at: listIndex put: false].	newListIndex ~= 0 ifTrue: [listSelections at: newListIndex put: true].	listIndex _ newListIndex.	self changed: #listIndex.	self acceptedContentsChanged! !!ChangeSorter methodsFor: 'creation' stamp: 'jmv 11/25/2010 00:12'!openAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| csListHeight msgListHeight csMsgListHeight |	acceptedContentsCache _ ''.	csListHeight _ 0.25.	msgListHeight _ 0.25.	csMsgListHeight _ csListHeight + msgListHeight.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: ((PluggableListMorphByItem 				model: self				listGetter: #changeSetList				indexGetter: #currentCngSet				indexSetter: #showChangeSetNamed:				menuGetter: #changeSetMenu:shifted:				keystrokeAction: #changeSetListKey:from:)			autoDeselect: false)		frame: (((0@0 extent: 0.5@csListHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #classList				indexGetter: #currentClassName				indexSetter: #currentClassName:				menuGetter: #classListMenu:shifted:				keystrokeAction: #classListKey:from:)		frame: (((0.5@0 extent: 0.5@csListHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #messageList				indexGetter: #currentSelector				indexSetter: #currentSelector:				menuGetter: #messageMenu:shifted:				keystrokeAction: #messageListKey:from:)		frame: (((0@csListHeight extent: 1@msgListHeight)			scaleBy: rect extent) translateBy: rect origin).	 self addLowerPanesTo: window		at: (((0@csMsgListHeight corner: 1@1) scaleBy: rect extent) translateBy: rect origin)		with: nil.! !!ChangeSorter methodsFor: 'access' stamp: 'jmv 11/24/2010 14:20'!showChangeSet: chgSet	myChangeSet == chgSet ifFalse: [		myChangeSet _ chgSet.		currentClassName _ nil.		currentSelector _ nil].	self changed: #relabel.	self changed: #currentCngSet.	"new -- list of sets"	self changed: #mainButtonName.	"old, button"	self changed: #classList.	self changed: #messageList.	self setContents.	self acceptedContentsChanged.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 11/24/2010 14:20'!clearChangeSet	"Clear out the current change set, after getting a confirmation."	| message |	self okToChange ifFalse: [^ self].	myChangeSet isEmpty ifFalse:		[message _ 'Are you certain that you want to\forget all the changes in this set?' withCRs.		(self confirm: message) ifFalse: [^ self]].	myChangeSet clear.	self changed: #classList.	self changed: #messageList.	self setContents.	self acceptedContentsChanged.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jmv 11/24/2010 14:20'!uninstallChangeSet	"Attempt to uninstall the current change set, after confirmation."	self okToChange ifFalse: [^ self].	(self confirm: 'Uninstalling a changeSet is unreliable at best.It will only work if the changeSet consists only of singlechanges, additions and removals of methods, and ifno subsequent changes have been to any of them.No changes to classes will be undone.The changeSet will be cleared after uninstallation.Do you still wish to attempt to uninstall this changeSet?')	ifFalse: [^ self].	myChangeSet uninstall.	self changed: #relabel.	self changed: #classList.	self changed: #messageList.	self setContents.	self acceptedContentsChanged.! !!ChangeSorter methodsFor: 'class list' stamp: 'jmv 11/24/2010 14:20'!currentClassName: aString	currentClassName _ aString.	currentSelector _ nil.	"fix by wod"	self changed: #currentClassName.	self changed: #messageList.	self setContents.	self acceptedContentsChanged.! !!ChangeSorter methodsFor: 'message list' stamp: 'jmv 11/24/2010 14:20'!currentSelector: messageName	currentSelector _ messageName.	self changed: #currentSelector.	self setContents.	self acceptedContentsChanged.! !!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 11/25/2010 00:21'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ acceptedContentsCache _ (myChangeSet preambleString ifNil: [''])].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector)		ifNotNil: [			changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ acceptedContentsCache _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ acceptedContentsCache _ 'Added then removed (see versions)'].			class ifNil: [^ acceptedContentsCache _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ acceptedContentsCache _ 'Method was added, but cannot be found!!'].			acceptedContentsCache _  (class sourceCodeAt: sel).			(#(prettyPrint prettyLineDiffs prettyWordDiffs) includes: contentsSymbol) ifTrue: [				acceptedContentsCache _ (class compilerClass new						format: acceptedContentsCache						in: class 						notifying: nil)].			self showingAnyKindOfDiffs				ifTrue: [ acceptedContentsCache _ (self diffFromPriorSourceFor: acceptedContentsCache) ].			^ acceptedContentsCache _ (acceptedContentsCache asText makeSelectorBoldIn: class) ]		ifNil: [			strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ acceptedContentsCache _ strm contents].! !!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 11/24/2010 14:13'!toggleDiffing	"Toggle whether diffs should be shown in the code pane"	self okToChange ifTrue: [		super toggleDiffing.		self acceptedContentsChanged.		self update]! !!ChangeSetBrowser methodsFor: 'initialization' stamp: 'jmv 11/25/2010 00:11'!openAsMorphIn: window rect: rect	"Add a set of changeSetBrowser views to the given top view offset by the given amount"	| aHeight |	acceptedContentsCache _ ''.	aHeight _ 0.25.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #classList				indexGetter: #currentClassName				indexSetter: #currentClassName:				menuGetter: #classListMenu:shifted:				keystrokeAction: #classListKey:from:)		frame: (((0.0@0 extent: 0.5 @ aHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #messageList				indexGetter: #currentSelector				indexSetter: #currentSelector:				menuGetter: #messageMenu:shifted:				keystrokeAction: #messageListKey:from:)		frame: (((0.5@0 extent: 0.5 @ aHeight)			scaleBy: rect extent) translateBy: rect origin).	 self addLowerPanesTo: window		at: (((0@aHeight corner: 1@1) scaleBy: rect extent) translateBy: rect origin)		with: nil! !!Debugger methodsFor: 'initialize' stamp: 'jmv 11/24/2010 14:31'!openFullMorphicLabel: aLabelString	"Open a full morphic debugger with the given label"	| window aListMorph oldContextStackIndex |	oldContextStackIndex _ contextStackIndex.	self expandStack. "Sets contextStackIndex to zero."	window _ (SystemWindow labelled: aLabelString) model: self.	aListMorph _ PluggableListMorph		model: self 		listGetter: #contextStackList		indexGetter: #contextStackIndex		indexSetter: #toggleContextStackIndex:		menuGetter: #contextStackMenu:shifted:		keystrokeAction: #contextStackKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0@0 corner: 1@0.25).	self addLowerPanesTo: window at: (0@0.25 corner: 1@0.8) with: nil.	window addMorph: (		PluggableListMorph new			doubleClickSelector: #inspectSelection;			model: self receiverInspector			listGetter: #fieldList			indexGetter: #selectionIndex 			indexSetter: #toggleIndex:			menuGetter: #fieldListMenu: 			keystrokeAction: #inspectorKey:from:)		frame: (0@0.8 corner: 0.2@1).	window addMorph: (PluggableTextMorph 			model: self receiverInspector			editorClass: self receiverInspector editorClass			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection 			menuGetter: #paneMenu:shifted:editorClass:)		frame: (0.2@0.8 corner: 0.5@1).	window addMorph: (		PluggableListMorph new			doubleClickSelector: #inspectSelection;			model: self contextVariablesInspector 			listGetter: #fieldList			indexGetter: #selectionIndex 			indexSetter: #toggleIndex:			menuGetter: #fieldListMenu: 			keystrokeAction: #inspectorKey:from:)		frame: (0.5@0.8 corner: 0.7@1).	window addMorph: (PluggableTextMorph 			model: self contextVariablesInspector			editorClass: self contextVariablesInspector editorClass			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection 			menuGetter: #paneMenu:shifted:editorClass:)		frame: (0.7@0.8 corner: 1@1).	window openInWorld.	self toggleContextStackIndex: oldContextStackIndex.	^ window ! !!Debugger methodsFor: 'accessing' stamp: 'jmv 11/25/2010 00:18'!acceptedStringOrText 	"Depending on the current selection, different information is retrieved.	Answer a string description of that information.  This information is the	method in the currently selected context."	acceptedContentsCache ifNotNil: [ :c | ^ c copy ].	^ String new! !!Debugger methodsFor: 'accessing' stamp: 'jmv 11/25/2010 00:12'!contents: aText notifying: aController	"The retrieved information has changed and its source must now be updated.	 In this case, the retrieved information is the method of the selected context."	| result selector classOfMethod category h ctxt newMethod |	contextStackIndex = 0 ifTrue:		[^false].	self selectedContext isExecutingBlock ifTrue:		[h := self selectedContext activeHome.		 h ifNil:			[self inform: 'Method for block not found on stack, can''t edit and continue'.			 ^false].		 (self confirm: 'I will have to revert to the method from\which this block originated.  Is that OK?' withCRs) ifFalse:			[^false].		self resetContext: h.		result := self contents: aText notifying: aController.		self acceptedContentsChanged.		^result].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	(selector == self selectedMessageName	 or: [(self selectedMessageName beginsWith: 'DoIt')		and: [selector numArgs = self selectedMessageName numArgs]]) ifFalse:		[self inform: 'can''t change selector'.		 ^false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector ifNil: [^false]. "compile cancelled"	acceptedContentsCache _ aText.	newMethod := classOfMethod compiledMethodAt: selector.	newMethod isQuick ifTrue:		[self down.		 self selectedContext jump: (self selectedContext previousPc - self selectedContext pc)].	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext		ifFalse:			[self inform: 'Method saved, but current context unchanged\because of unwind error. Click OK to see error' withCRs]		ifTrue:			[newMethod isQuick ifFalse:				[interruptedProcess					restartTopWith: newMethod;				 	stepToSendOrReturn].			contextVariablesInspector object: nil].	self resetContext: ctxt.	World		addAlarm: #changed:		withArguments: #(contentsSelection)		for: self		at: (Time millisecondClockValue + 200).	^true! !!Debugger methodsFor: 'context stack (message list)' stamp: 'jmv 11/25/2010 00:13'!selectedMessage	"Answer the source code of the currently selected context."	^acceptedContentsCache _ self selectedContext debuggerMap sourceText asText makeSelectorBold! !!Debugger methodsFor: 'private' stamp: 'jmv 11/25/2010 00:13'!contextStackIndex: anInteger oldContextWas: oldContext 	"Change the context stack index to anInteger, perhaps in response to user selection."	| isNewMethod selectedContextSlotName index |	contextStackIndex := anInteger.	anInteger = 0 ifTrue: [		acceptedContentsCache _ nil.		currentCompiledMethod := nil.		self changed: #contextStackIndex.		self decorateButtons.		self acceptedContentsChanged.		contextVariablesInspector object: nil.		receiverInspector object: self receiver.		^self].	selectedContextSlotName := contextVariablesInspector selectedSlotName.	isNewMethod := oldContext == nil					or: [oldContext method ~~ (currentCompiledMethod := self selectedContext method)].	isNewMethod ifTrue: [		acceptedContentsCache _ self selectedMessage.		self acceptedContentsChanged.		self pcRange ].	self changed: #contextStackIndex.	self decorateButtons.	contextVariablesInspector object: self selectedContext.	((index := contextVariablesInspector fieldList indexOf: selectedContextSlotName) ~= 0	 and: [index ~= contextVariablesInspector selectionIndex]) ifTrue: [		contextVariablesInspector toggleIndex: index].	receiverInspector object: self receiver.	isNewMethod ifFalse: [		self changed: #contentsSelection]! !!Debugger methodsFor: 'private' stamp: 'jmv 11/25/2010 00:13'!process: aProcess controller: aController context: aContext	super initialize.	Smalltalk at: #MessageTally ifPresentAndInMemory: [ :c | c terminateTimerProcess ].	acceptedContentsCache _ nil. 	interruptedProcess _ aProcess.	contextStackTop _ aContext.	self newStack: (contextStackTop stackOfSize: 1).	contextStackIndex _ 1.	externalInterrupt _ false.	selectingPC _ true.	errorWasInUIProcess _ false! !!Debugger methodsFor: 'private' stamp: 'jmv 11/24/2010 14:20'!resetContext: aContext 	"Used when a new context becomes top-of-stack, for instance when the	method of the selected context is re-compiled, or the simulator steps or	returns to a new method. There is room for much optimization here, first	to save recomputing the whole stack list (and text), and secondly to avoid	recomposing all that text (by editing the paragraph instead of recreating it)."	| oldContext |	oldContext := self selectedContext.	contextStackTop := aContext.	self newStack: contextStackTop contextStack.	self changed: #contextStackList.	self contextStackIndex: 1 oldContextWas: oldContext.	self acceptedContentsChanged.! !!FileContentsBrowser methodsFor: 'accessing' stamp: 'jmv 11/25/2010 00:04'!acceptedStringOrText	self updateInfoView.	(editSelection == #newClass and: [ self selectedPackage notNil ])		ifTrue: [ ^self selectedPackage packageInfo ].	editSelection == #editClass		ifTrue:[ ^self modifiedClassDefinition ].	^super acceptedStringOrText! !!FileContentsBrowser methodsFor: 'edit pane' stamp: 'jmv 11/24/2010 18:16'!selectedBytecodes	"Not supported"	^''! !!FileContentsBrowser methodsFor: 'edit pane' stamp: 'jmv 11/25/2010 00:21'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	acceptedContentsCache _ (class sourceCodeAt: selector).	Preferences browseWithPrettyPrint ifTrue: [		acceptedContentsCache _ (Smalltalk actualCompilerClass new					format: acceptedContentsCache					in: class					notifying: nil)].	self showingAnyKindOfDiffs ifTrue: [		acceptedContentsCache _ (self			methodDiffFor: acceptedContentsCache			class: self selectedClass			selector: self selectedMessageName			meta: self metaClassIndicated)].	^ acceptedContentsCache asText makeSelectorBoldIn: class! !!FileContentsBrowser methodsFor: 'creation' stamp: 'jmv 11/24/2010 14:31'!addLowerPanesTo: window at: nominalFractions with: editString	| verticalOffset column codePane infoPane infoHeight divider |	column _ AlignmentMorph proportional.	codePane _ PluggableTextMorph 		model: self 		editorClass: self editorClass		textGetter: #acceptedContents 		textSetter: #contents:notifying:		selectionGetter: #contentsSelection 		menuGetter: #paneMenu:shifted:editorClass:.	infoPane _ PluggableTextMorph 		model: self 		editorClass: self editorClass		textGetter: #infoViewContents 		textSetter: nil		selectionGetter: nil 		menuGetter: nil.	infoPane askBeforeDiscardingEdits: false.	verticalOffset _ 0.	infoHeight _ 20.	column 		addMorph: (codePane borderWidth: 0)		fullFrame: (			LayoutFrame 				fractions: (0@0 corner: 1@1) 				offsets: (0@verticalOffset corner: 0@infoHeight negated)		).	divider _ BorderedSubpaneDividerMorph forTopEdge.	divider extent: 4@4; color: Color transparent; borderColor: #raised; borderWidth: 2.	column 		addMorph: divider		fullFrame: (			LayoutFrame 				fractions: (0@1 corner: 1@1) 				offsets: (0@infoHeight negated corner: 0@(1-infoHeight))		).	column 		addMorph: (infoPane borderWidth: 0; hideScrollBarsIndefinitely)		fullFrame: (			LayoutFrame 				fractions: (0@1 corner: 1@1) 				offsets: (0@(1-infoHeight) corner: 0@0)		).	window 		addMorph: column		frame: nominalFractions.	column on: #mouseEnter send: #paneTransition: to: window.	column on: #mouseLeave send: #paneTransition: to: window! !!FileList methodsFor: 'file list' stamp: 'jmv 11/24/2010 14:13'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self directory: nil]						ifFalse: [volListIndex = 1 ifTrue: [name _ name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := #needToGetBrief.	self changed: #fileListIndex.	self acceptedContentsChanged.	self updateButtonRow! !!FileList methodsFor: 'file menu action' stamp: 'jmv 11/24/2010 14:14'!get	"Get contents of file again, it may have changed. Do this by making the cancel string be the contents, and doing a cancel."	Cursor read showWhile: [		self okToChange ifFalse: [^ nil].		brevityState == #briefHex			ifTrue: [brevityState _ #needToGetFullHex]			ifFalse: [brevityState _ #needToGetFull].		self acceptedContentsChanged ]! !!FileList methodsFor: 'file menu action' stamp: 'jmv 11/24/2010 14:14'!getHex	"Get contents of file again, and display in Hex. Do this by making the cancel string be the contents, and doing a cancel."	Cursor read showWhile: [		brevityState _ #needToGetBriefHex.		self acceptedContentsChanged ]! !!FileList methodsFor: 'initialization' stamp: 'jmv 11/25/2010 00:14'!initialize	acceptedContentsCache _ self defaultContents! !!FileList methodsFor: 'initialization' stamp: 'jmv 11/24/2010 14:14'!setFileStream: aStream	"Used to initialize a spawned file editor.  Sets directory too."	self directory: aStream directory.	fileName _ aStream localName.	pattern _ '*'.	listIndex _ 1.  "pretend a file is selected"	aStream close.	brevityState _ #needToGetBrief.	self acceptedContentsChanged.! !!FileList methodsFor: 'volume list and pattern' stamp: 'jmv 11/24/2010 14:14'!volumeListIndex: index	"Select the volume name having the given index."	| delim path |	volListIndex := index.	index = 1 		ifTrue: [self directory: (FileDirectory on: '')]		ifFalse: [delim := directory pathNameDelimiter.				path := String streamContents: [:strm |					2 to: index do: [:i |						strm nextPutAll: (volList at: i) withBlanksTrimmed.						i < index ifTrue: [strm nextPut: delim]]].				self directory: (directory on: path)].	brevityState := #FileList.	self addPath: path.	self changed: #fileList.	self acceptedContentsChanged.	self updateButtonRow! !!FileList methodsFor: 'private' stamp: 'jmv 11/25/2010 00:19'!acceptedStringOrText	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [ ^ self defaultContents ].  "no file selected"	brevityState == #fullFile ifTrue: [ ^ acceptedContentsCache ].	brevityState == #fullHex ifTrue: [ ^ acceptedContentsCache ].	brevityState == #briefFile ifTrue: [ ^ acceptedContentsCache ].	brevityState == #briefHex ifTrue: [ ^ acceptedContentsCache ].	brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false ].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true ].	brevityState == #needToGetFull ifTrue:  [^ self readContentsBrief: false ].	brevityState == #needToGetBrief ifTrue: [ ^ self readContentsBrief: true ].  "default"	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'private' stamp: 'jmv 11/25/2010 00:19'!defaultContents	acceptedContentsCache _ (list		ifNil: [String new]		ifNotNil: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED' translated; cr.					s nextPutAll: '  -- Folder Summary --' translated; cr.					list do: [:item | s nextPutAll: item; cr]]]).	brevityState _ #FileList.	^ acceptedContentsCache! !!FileList methodsFor: 'private' stamp: 'jmv 11/25/2010 00:15'!put: aText	"Private - put the supplied text onto the file"	| ff type |	brevityState == #fullFile ifTrue:		[ff _ directory newFileNamed: self fullName.		Cursor write showWhile: [ff nextPutAll: aText asString; close].		fileName = ff localName 			ifTrue: [ acceptedContentsCache _ aText asString]			ifFalse: [self updateFileList].		"user renamed the file"		^ true  "accepted"].	listIndex = 0 ifTrue:		[self inform: 'No fileName is selected' translated.		^ false  "failed"].	type _ 'These'.	brevityState = #briefFile ifTrue: [type _ 'Abbreviated'].	brevityState = #briefHex ifTrue: [type _ 'Abbreviated'].	brevityState = #fullHex ifTrue: [type _ 'Hexadecimal'].	brevityState = #FileList ifTrue: [type _ 'Directory'].	self inform: ('{1} contents cannotmeaningfully be saved at present.' translated format:{type translated}).	^ false  "failed"! !!FileList methodsFor: 'private' stamp: 'jmv 11/25/2010 00:19'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	brevityFlag ifTrue: [		directory isRemoteDirectory ifTrue: [^ self readServerBrief]].	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read' translated].	(brevityFlag not or: [(fileSize := f size) <= 100000]) ifTrue: [		acceptedContentsCache _ f contentsOfEntireFile.		brevityState := #fullFile.   "don't change till actually read"		^ acceptedContentsCache ].	"if brevityFlag is true, don't display long files when first selected"	first5000 := f next: 5000.	f close.	acceptedContentsCache _ ('File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' translated format: {fileName. fileSize. first5000}).	brevityState := #briefFile.   "don't change till actually read"	^ acceptedContentsCache! !!FileList methodsFor: 'private' stamp: 'jmv 11/25/2010 00:15'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f := directory oldFileOrNoneNamed: self fullName. 	f ifNil: [^ 'For some reason, this file cannot be read' translated].	((size := f size)) > 5000 & brevity		ifTrue: [data := f next: 10000. f close. brevityState := #briefHex]		ifFalse: [data := f contentsOfEntireFile. brevityState := #fullHex].	s := WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData := s contents.	^ acceptedContentsCache _ ((size > 5000) & brevity		ifTrue: ['File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' translated format: {fileName. size. hexData}]		ifFalse: [hexData])! !!FileList methodsFor: 'private' stamp: 'jmv 11/25/2010 00:19'!readServerBrief	| lString sizeStr fsize ff first5000 parts |	"If file on server is known to be long, just read the beginning.  Cheat badly by reading the fileList string."	listIndex = 0 ifTrue: [^ self].	"Get size from file list entry"	lString := list at: listIndex.	parts := lString findTokens: '()'.	sortMode = #name ifTrue: [sizeStr := (parts second findTokens: ' ') third].	sortMode = #date ifTrue: [sizeStr := (parts first findTokens: ' ') third].	sortMode = #size ifTrue: [sizeStr := (parts first findTokens: ' ') first].	fsize := (sizeStr copyWithout: $,) asNumber.	fsize <= 50000 ifTrue:		[ff := directory oldFileOrNoneNamed: self fullName.		ff ifNil: [^ 'For some reason, this file cannot be read' translated].		acceptedContentsCache _ ff contentsOfEntireFile.		brevityState := #fullFile.   "don't change till actually read"		^ acceptedContentsCache ].	"if brevityFlag is true, don't display long files when first selected"	first5000 := directory getOnly: 3500 from: fileName.	acceptedContentsCache _ ('File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 3500 characters...------------------------------------------{3}------------------------------------------... end of the first 3500 characters.' translated format: {fileName. sizeStr. first5000}).	brevityState := #briefFile.   "don't change till actually read"	^ acceptedContentsCache! !!FileList methodsFor: 'private' stamp: 'jmv 11/24/2010 14:14'!resort: newMode	"Re-sort the list of files."	| name |	listIndex > 0		ifTrue: [name _ self fileNameFromFormattedItem: (list at: listIndex)].	sortAscending _ sortMode = newMode		ifTrue: [ sortAscending not ]		ifFalse: [ newMode = #name].	sortMode _ newMode.	self pattern: pattern.	name ifNotNil: [		fileName _ name.		listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = name. ].		self changed: #fileListIndex].	listIndex = 0 ifTrue: [		self acceptedContentsChanged ].	self updateButtonRow! !!FileList methodsFor: 'private' stamp: 'jmv 11/25/2010 00:16'!updateFileList	"Update my files list with file names in the current directory  	that match the pattern.	The pattern string may have embedded newlines or semicolons; these separate different patterns."	| patterns |	patterns _ OrderedCollection new.	Cursor wait showWhile: [	(pattern findTokens: (String with: Character cr with: Character lf with: $;))		do: [ :each |			(each includes: $*) | (each includes: $#)					ifTrue: [ patterns add: each]					ifFalse: [each isEmpty										ifTrue: [ patterns add: '*']										ifFalse: [ patterns add: '*' , each , '*']]].	list _ self listForPatterns: patterns.	listIndex _ 0.	volListIndex _ volList size.	fileName _ nil.	acceptedContentsCache _ ''.	self changed: #volumeListIndex.	self changed: #fileList.	self updateButtonRow]! !!FileList2 methodsFor: 'user interface' stamp: 'jmv 11/24/2010 15:09'!morphicFileContentsPane	^PluggableTextMorph 		model: self 		editorClass: self editorClass		textGetter: #acceptedContents 		textSetter: #put:		selectionGetter: #contentsSelection 		menuGetter: #fileContentsMenu:shifted:! !!FileList2 methodsFor: 'private' stamp: 'jmv 11/24/2010 14:14'!setSelectedDirectoryTo: aFileDirectoryWrapper	currentDirectorySelected _ aFileDirectoryWrapper.	self directory: aFileDirectoryWrapper withoutListWrapper.	brevityState := #FileList.	"self addPath: path."	self changed: #fileList.	self acceptedContentsChanged.	self changed: #currentDirectorySelected.! !!Inspector methodsFor: 'accessing' stamp: 'jmv 11/25/2010 00:20'!modelWakeUpIn: aWindow	| newText |	self updateListsAndCodeIn: aWindow.	newText _ self contentsIsString		ifTrue: [ newText _ self selection ]		ifFalse: [			"keep it short to reduce time to compute it"			self selectionPrintString ].	newText =acceptedContentsCache ifFalse: [		acceptedContentsCache _ newText.		self acceptedContentsChanged ]! !!Inspector methodsFor: 'accessing' stamp: 'jmv 11/24/2010 14:15'!object: anObject 	"Set anObject to be the object being inspected by the receiver."	| oldIndex |	anObject == object		ifTrue: [self update]		ifFalse:			[oldIndex := selectionIndex <= 2 ifTrue: [selectionIndex] ifFalse: [0].			self inspect: anObject.			oldIndex := oldIndex min: self fieldList size.			self changed: #inspectObject.			oldIndex > 0				ifTrue: [self toggleIndex: oldIndex].			self changed: #fieldList.			self acceptedContentsChanged ]! !!Inspector methodsFor: 'accessing' stamp: 'jmv 11/25/2010 00:16'!update	"Reshow contents, assuming selected value may have changed."	selectionIndex = 0		ifFalse: [			self contentsIsString				ifTrue: [ acceptedContentsCache _ self selection]				ifFalse: [ acceptedContentsCache _ self selectionPrintString].			self acceptedContentsChanged.			self changed: #selection.			self changed: #selectionIndex ]! !!Inspector methodsFor: 'selecting' stamp: 'jmv 11/25/2010 00:16'!accept: aString	| result |	result _ self doItReceiver class evaluatorClass new				evaluate: (ReadStream on: aString)				in: self doItContext				to: self doItReceiver				notifying: nil	"fix this"				ifFail:  [^ false].	result == #failedDoit ifFalse: [			acceptedContentsCache _ result printString.			self replaceSelectionValue: result.	"may put contents back"			self acceptedContentsChanged.			^ true].	^ false! !!Inspector methodsFor: 'selecting' stamp: 'jmv 11/25/2010 00:16'!toggleIndex: anInteger	"The receiver has a list of variables of its inspected object. One of these 	is selected. If anInteger is the index of this variable, then deselect it. 	Otherwise, make the variable whose index is anInteger be the selected 	item."	selectionUpdateTime _ 0.	selectionIndex = anInteger		ifTrue: [			"same index, turn off selection"			selectionIndex _ 0.			acceptedContentsCache _ '']		ifFalse: [			"different index, new selection"			selectionIndex _ anInteger.			self contentsIsString				ifTrue: [ acceptedContentsCache _ self selection]				ifFalse: [ acceptedContentsCache _ self selectionPrintString]].	self changed: #selection.	self acceptedContentsChanged.	self changed: #selectionIndex! !!Inspector methodsFor: 'stepping' stamp: 'jmv 11/25/2010 00:20'!stepAt: millisecondClockValue in: aWindow	| newText |	(Preferences smartUpdating and: [(millisecondClockValue - self timeOfLastListUpdate) > 8000]) "Not more often than once every 8 seconds"		ifTrue: [			self updateListsAndCodeIn: aWindow.			timeOfLastListUpdate := millisecondClockValue].	newText := self contentsIsString		ifTrue: [self selection]		ifFalse: ["keep it short to reduce time to compute it"			self selectionPrintString ].	newText = acceptedContentsCache ifFalse: [		acceptedContentsCache _ newText.		self acceptedContentsChanged ]! !!Inspector methodsFor: 'contents' stamp: 'jmv 11/25/2010 00:20'!acceptedStringOrText	^acceptedContentsCache! !!BasicInspector methodsFor: 'as yet unclassified' stamp: 'jmv 11/25/2010 00:10'!inspect: anObject 	"Initialize the receiver so that it is inspecting anObject. There is no 	current selection."	self initialize.	object _ anObject.	selectionIndex _ 0.	acceptedContentsCache _ ''! !!DictionaryInspector methodsFor: 'selecting' stamp: 'jmv 11/24/2010 14:13'!refreshView	| i |	i := selectionIndex.	self calculateKeyArray.	selectionIndex := i.	self changed: #fieldList.	self acceptedContentsChanged.! !!DictionaryInspector methodsFor: 'menu' stamp: 'jmv 11/25/2010 00:13'!removeSelection	selectionIndex = 0 ifTrue: [^ self changed: #flash].	object removeKey: (keyArray at: selectionIndex - self numberOfFixedFields).	selectionIndex := 0.	acceptedContentsCache _ ''.	self calculateKeyArray.	self changed: #inspectObject.	self changed: #selectionIndex.	self changed: #fieldList.	self changed: #selection.! !!MessageSet methodsFor: 'message list' stamp: 'jmv 11/24/2010 14:21'!messageListIndex: anInteger 	"Set the index of the selected item to be anInteger."	messageListIndex _ anInteger.	self setContentsToForceRefetch.	self changed: #messageListIndex.	 "update my selection"	self editSelection: #editMessage.	self acceptedContentsChanged.	(messageListIndex ~= 0 and: [autoSelectString notNil])		ifTrue: [self changed: #autoSelect].	self decorateButtons! !!MessageSet methodsFor: 'message functions' stamp: 'jmv 11/24/2010 14:21'!reformulateList	"The receiver's messageList has been changed; rebuild it"	super reformulateList.	self initializeMessageList: messageList.	self changed: #messageList.	self changed: #messageListIndex.	self acceptedContentsChanged! !!MessageSet methodsFor: 'contents' stamp: 'jmv 11/25/2010 00:20'!acceptedStringOrText	"Answer the contents of the receiver"	^ acceptedContentsCache		ifNil: [			currentCompiledMethod _ nil.			'' ]		ifNotNil: [			messageListIndex = 0 				ifTrue: [					currentCompiledMethod _ nil.					acceptedContentsCache ]				ifFalse: [					self showingByteCodes						ifTrue: [ self selectedBytecodes]						ifFalse: [ self selectedMessage]]]! !!MessageSet methodsFor: 'contents' stamp: 'jmv 11/25/2010 00:17'!setContentsToForceRefetch	"Set the receiver's contents such that on the next update the contents will be formulated afresh.  This is a critical and obscure difference between Browsers on the one hand and MessageSets on the other, and has over the years been the source of much confusion and much difficulty.  By centralizing the different handling here, we don't need so many idiosyncratic overrides in MessageSet any more"	acceptedContentsCache _ ''! !!MessageSet methodsFor: 'private' stamp: 'jmv 11/25/2010 00:17'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	self okayToAccept ifFalse: [^ false].	self setClassAndSelectorIn: [:c :os | class _ c.  oldSelector _ os].	class ifNil: [^ false].	(oldSelector notNil and: [oldSelector first isUppercase]) ifTrue:		[oldSelector = #Comment ifTrue:			[class comment: aString stamp: Utilities changeStamp.			self changed: #annotation. 			self clearUserEditFlag.			^ false].		oldSelector = #Definition ifTrue:			["self defineClass: aString notifying: aController."			class subclassDefinerClass				evaluate: aString				notifying: aController				logged: true.			self clearUserEditFlag. 			^ false].		oldSelector = #Hierarchy ifTrue:			[self inform: 'To change the hierarchy, edit the class definitions'. 			^ false]].	"Normal method accept"	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector		ifNil: [^ false].	selector == oldSelector ifFalse: [		self reformulateListNoting: selector].	acceptedContentsCache _ aString copy.	self changed: #annotation.	^ true! !!MessageSet methodsFor: 'private' stamp: 'jmv 11/25/2010 00:17'!initializeMessageList: anArray	| s |	messageList _ OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel |				class ifNotNil: [					s _ class name , ' ' , sel , ' {' , ((class organization categoryOfElement: sel) ifNil: ['']) , '}'.					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s) ]]].	messageListIndex _ messageList isEmpty ifTrue: [0 ] ifFalse: [1].	acceptedContentsCache _ ''! !!SetInspector methodsFor: 'menu' stamp: 'jmv 11/25/2010 00:17'!removeSelection	(selectionIndex <= object class instSize) ifTrue: [^ self changed: #flash].	object remove: self selection.	selectionIndex := 0.	acceptedContentsCache _ ''.	self changed: #inspectObject.	self changed: #fieldList.	self changed: #selection.	self changed: #selectionIndex.! !!SyntaxError methodsFor: 'initialization' stamp: 'jmv 11/24/2010 23:43'!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	| types printables badChar |	class _ aClass.	debugger _ aDebugger.	selector _ aClass parserClass new parseSelector: aString.	types _ Smalltalk actualScannerClass classPool at: #TypeTable.	"dictionary"	printables _ '!!@#$%&*-_=+<>{}?/\,`~`' asSet.	badChar := aString detect: [:aChar | (types at: aChar asciiValue ifAbsent: [#xLetter]) == #xBinary and: [			(printables includes: aChar) not]] ifNone: nil.	self actualContents: (badChar 		ifNil: [aString]		ifNotNil: ['<<<This string contains a character (ascii value ', 			badChar asciiValue printString,			') that is not normally used in code>>> ', aString]).	category ifNil: [category _ aClass organization categoryOfElement: selector].	category ifNil: [category _ ClassOrganizer default].	doitFlag _ flag! !!TextHolder class methodsFor: 'class initialization' stamp: 'jmv 11/24/2010 14:35'!initialize	"The class variables were initialized once, and subsequently filled with	information. Re-executing this method is therefore dangerous." 	 	"workSpace _ StringHolder new"	"StringHolder initialize"! !!TextHolder class methodsFor: 'instance creation' stamp: 'jmv 11/24/2010 14:35'!normal	| model |	model _ self new.	model contents: (Text initialStyle: (TextStyle named: 'Normal') string: '').	^model! !!TextHolder class methodsFor: 'instance creation' stamp: 'jmv 11/24/2010 14:35'!open	self new openLabel: 'Text Editor'! !!TextHolder class methodsFor: 'instance creation' stamp: 'jmv 11/24/2010 14:35'!openLabel: aString	self new openLabel: aString! !!TextHolder class methodsFor: 'window color' stamp: 'jmv 11/24/2010 14:35'!windowColor	^ ColorTheme current workspace! !!FileList class methodsFor: 'instance creation' stamp: 'jmv 11/24/2010 15:09'!openAsMorph	"Open a morphic view of a FileList on the default directory."	| dir aFileList window upperFraction offset |	dir := FileDirectory default.	aFileList := self new directory: dir.	window := (SystemWindow labelled: dir pathName) model: aFileList.	upperFraction := 0.3.	offset := 0.	self 		addVolumesAndPatternPanesTo: window		at: (0 @ 0 corner: 0.3 @ upperFraction)		plus: offset		forFileList: aFileList.	self 		addButtonsAndFileListPanesTo: window		at: (0.3 @ 0 corner: 1.0 @ upperFraction)		plus: offset		forFileList: aFileList.	window addMorph: (PluggableTextMorph 			model: aFileList			editorClass: aFileList editorClass			textGetter: #acceptedContents			textSetter: #put:			selectionGetter: #contentsSelection			menuGetter: #fileContentsMenu:shifted:)		frame: (0 @ 0.3 corner: 1 @ 1).	^window openInWorld! !!FileList class methodsFor: 'instance creation' stamp: 'jmv 11/24/2010 15:09'!openMorphOn: aFileStream editString: editString 	"Open a morphic view of a FileList on the given file."	| fileModel window fileContentsView |	fileModel _ FileList new setFileStream: aFileStream.	"closes the stream"	window _ (SystemWindow labelled: aFileStream fullName) model: fileModel.	window addMorph: (fileContentsView _ PluggableTextMorph 			model: fileModel 			editorClass: fileModel editorClass			textGetter: #acceptedContents 			textSetter: #put:			selectionGetter: #contentsSelection 			menuGetter: #fileContentsMenu:shifted:)		frame: (0@0 corner: 1@1).	editString ifNotNil: [fileContentsView editString: editString.			fileContentsView hasUnacceptedEdits: true].	^ window! !!Inspector class methodsFor: 'instance creation' stamp: 'jmv 11/24/2010 15:09'!openAsMorphOn: anObject withLabel: aLabel	" Inspector openAsMorphOn: SystemOrganization "	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: aLabel) model: inspector.	window addMorph: (		PluggableListMorph new			doubleClickSelector: #inspectSelection;			model: inspector 			listGetter: #fieldList			indexGetter: #selectionIndex			indexSetter: #toggleIndex:			menuGetter: #fieldListMenu:			keystrokeAction: #inspectorKey:from:)		frame: (0@0 corner: self horizontalDividerProportion @ self verticalDividerProportion).	window addMorph: (PluggableTextMorph			model: inspector 			editorClass: inspector editorClass 			textGetter: #acceptedContents 			textSetter: #accept:			selectionGetter: #contentsSelection 			menuGetter: #paneMenu:shifted:editorClass:)		frame: (self horizontalDividerProportion @0 corner: 1@self verticalDividerProportion).	window addMorph: ((PluggableTextMorph 			model: inspector 			editorClass: inspector editorClass			textGetter: nil 			textSetter: nil			selectionGetter: #contentsSelection 			menuGetter: #paneMenu:shifted:editorClass:)					askBeforeDiscardingEdits: false)		frame: (0@self verticalDividerProportion corner: 1@1).	window setUpdatablePanesFrom: #(fieldList).	^ window! !!SyntaxError class methodsFor: 'instance creation' stamp: 'jmv 11/24/2010 18:32'!buildMorphicViewOn: aSyntaxError	"Answer an Morphic view on the given SyntaxError."	| window |	window _ (SystemWindow labelled: 'Syntax Error') model: aSyntaxError.	window addMorph: (PluggableListMorph 			model: aSyntaxError 			listGetter: #list			indexGetter: #listIndex 			indexSetter: nil 			menuGetter: #listMenu:)		frame: (0@0 corner: 1@0.15).	window addMorph: (PluggableTextMorph 			model: aSyntaxError 			editorClass: aSyntaxError editorClass			textGetter: #actualContents			textSetter: #contents:notifying: 			selectionGetter: #contentsSelection			menuGetter: #paneMenu:shifted:editorClass:)		frame: (0@0.15 corner: 1@1).	^ window openInWorldExtent: 380@220! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 11/24/2010 14:51'!openTextEditor	TextHolder new openInMorphicWindowLabeled: 'Text Editor' wrap: true! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 11/24/2010 14:51'!vmStatistics	"Open a string view on a report of vm statistics"	(TextHolder new contents: Utilities vmStatisticsReportString)		openLabel: 'VM Statistics'! !!TheWorldMenu methodsFor: 'commands' stamp: 'jmv 11/24/2010 14:51'!worldMenuHelp	| aList aMenu cnts explanation |	"self currentWorld primaryHand worldMenuHelp"	aList _ OrderedCollection new.	#(helpMenu changesMenu openMenu debugMenu windowsMenu appearanceMenu) 		with:	#('help' 'changes' 'open' 'debug' 'windows' 'appearance' ) do:		[:sel :title | aMenu _ self perform: sel.			aMenu items do:				[:it | (((cnts _ it contents) = 'keep this menu up') or: [cnts isEmpty])					ifFalse: [aList add: (cnts, ' - ', title translated)]]].	aList _ aList asArray sort: [:a :b | a asLowercase < b asLowercase].	explanation _ String streamContents: [:aStream | aList do:		[:anItem | aStream nextPutAll: anItem; cr]].	(TextHolder new contents: explanation)		openLabel: 'Where in the world menu is...' translated! !!TimeProfileBrowser methodsFor: 'private' stamp: 'jmv 11/25/2010 00:17'!initializeMessageList: anArray	messageList _ anArray.	messageListIndex _ 0.	acceptedContentsCache _ ''! !!TimeProfileBrowser methodsFor: 'private' stamp: 'jmv 11/25/2010 00:18'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])  "	self flag: #mref.	"fix for faster references to methods"	^[		| string strm class sel parens |		string _ self selection asString.		string first == $* ifTrue: [ ^acceptedContentsCache _ nil ].		"Ignore lines starting with *"		parens := string includes: $(.					"Does it have open-paren?"		strm := ReadStream on: string.		parens			ifTrue: [				strm skipTo: $(.		"easy case"				class := strm upTo: $).				strm next: 2.				sel := strm upToEnd ]			ifFalse: [				strm position: (string findString: ' class>>').				strm position > 0					ifFalse: [strm position: (string findLast: [ :ch | ch == $ ])]					ifTrue: [						| subString |  "find the next to last space character"						subString := strm contents copyFrom: 1 to: (string findLast: [ :ch | ch == $ ]) - 1.						strm position: (subString findLast: [ :ch | ch == $ ])].				class := strm upTo: $>.				strm next.				sel := strm upToEnd ].		MessageSet parse: (class, ' ', sel) toClassAndSelector: csBlock	]		on: Error 		do: [ :ex | acceptedContentsCache _ nil ]! !!TranscriptStream methodsFor: 'model protocol' stamp: 'jmv 11/24/2010 14:51'!paneMenu: aMenu shifted: shifted editorClass: anEditorClass	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ TextHolder basicNew paneMenu: aMenu shifted: shifted editorClass: anEditorClass! !!Utilities class methodsFor: 'common requests' stamp: 'jmv 11/24/2010 14:51'!commonRequestStrings: aString	"Initialize the common request strings from aString.  "	CommonRequestStrings _ TextHolder new contents: aString! !!Utilities class methodsFor: 'common requests' stamp: 'jmv 11/24/2010 14:51'!initializeCommonRequestStrings	"Initialize the common request strings, a directly-editable list of expressions that can be evaluated from the 'do...' menu."	CommonRequestStrings _ TextHolder new contents: 'Utilities saveScreenshot.Utilities saveDisplay.Cursor normal show.Transcript clear.-Undeclared inspect.Undeclared removeUnreferencedKeys; inspect.-ChangeSorter removeEmptyUnnamedChangeSets.ChangeSorter reorderChangeSets.'"Utilities initializeCommonRequestStrings"! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jmv 11/24/2010 14:51'!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict _ Dictionary new.	report _ ReadWriteStream on: ''.	f _ FileStream readOnlyFileNamed: fileName1.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size = 4 or: [items size = 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f _ FileStream readOnlyFileNamed: fileName2.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size = 4 or: [items size = 5]) ifTrue:			[className _ items first.			newInstCount _ items third asNumber.			newSpace _ items fourth asNumber.			oldPair _ instCountDict at: className ifAbsent: nil.			oldInstCount _ oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace _ oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(TextHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!Utilities class methodsFor: 'support windows' stamp: 'jmv 11/24/2010 14:51'!openCommandKeyHelp	"Open a window giving command key help."	"Utilities openCommandKeyHelp"	(TextHolder new contents: self commandKeyMappings)		openLabel: 'Command Key Actions'! !!Utilities class methodsFor: 'support windows' stamp: 'jmv 11/24/2010 14:51'!openStandardWorkspace 	"Open up a throwaway workspace with useful expressions in it.  1/22/96 sw"	"Utilities openStandardWorkspace"	(TextHolder new contents: self standardWorkspaceContents)		openLabel: 'Useful Expressions ', Date today printString! !!VersionsBrowser methodsFor: 'init & update' stamp: 'jmv 11/24/2010 14:21'!reformulateList	| aMethod |	"Some uncertainty about how to deal with lost methods here"	aMethod _ classOfMethod compiledMethodAt: selectorOfMethod ifAbsent: [^ self].		self scanVersionsOf: aMethod class: classOfMethod theNonMetaClass meta: classOfMethod isMeta category: (classOfMethod whichCategoryIncludesSelector: selectorOfMethod) selector: selectorOfMethod.	self changed: #list. "for benefit of mvc"	listIndex _ 1.	self changed: #listIndex.	self acceptedContentsChanged! !!VersionsBrowser methodsFor: 'menu' stamp: 'jmv 11/24/2010 14:51'!compareToOtherVersion	"Prompt the user for a reference version, then spawn a window 	showing the diffs between the older and the newer of the current 	version and the reference version as text."	| change1 change2 s1 s2 differDesc diffWords |	change1 := changeList at: listIndex ifAbsent: [ ^self ].	change2 := ((SelectionMenu				labels: (list copyWithoutIndex: listIndex)				selections: (changeList copyWithoutIndex: listIndex)) startUp) ifNil: [ ^self ].		"compare earlier -> later"	"change1 timeStamp < change2 timeStamp		ifFalse: [ | temp | temp _ change1. change1 _ change2. change2 _ temp ]."	s1 := change1 string.	s2 := change2 string.	s1 = s2		ifTrue: [^ self inform: 'Exact Match' translated].	diffWords _ self shouldDiffWords.	differDesc _ diffWords		ifTrue: [ 'Words']		ifFalse: [ 'Lines'].	(TextHolder new		contents: (DifferenceFinder			displayPatchFrom: s1 to: s2			tryWords: diffWords			prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [classOfMethod])))		openLabel: 			(('Comparison from {1} to {2}: ', differDesc, 				(self showingAnyKindOfPrettyDiffs ifTrue: [', using prettyPrint'] ifFalse: [''])) 					format: { change1 stamp. change2 stamp })! !!VersionsBrowser methodsFor: 'menu' stamp: 'jmv 11/24/2010 14:51'!offerVersionsHelp	(TextHolder new contents: self versionsHelpString)		openLabel: 'Versions Browsers'! !!ClassCommentVersionsBrowser methodsFor: 'menu' stamp: 'jmv 11/24/2010 14:50'!compareToCurrentVersion	"If the current selection corresponds to a method in the system, then spawn a window showing the diffs as text"	| change s1 s2 differDesc diffWords |	listIndex = 0		ifTrue: [^ self].	change _ changeList at: listIndex.	s1 _ classOfMethod organization classComment.	s2 _ change string.	s1 = s2		ifTrue: [^ self inform: 'Exact Match'].	diffWords _ self shouldDiffWords.	differDesc _ diffWords		ifTrue: [ 'Words']		ifFalse: [ 'Lines'].	(TextHolder new		contents: (DifferenceFinder			displayPatchFrom: s1 to: s2			tryWords: diffWords))				openLabel: 'Comparison to Current Version: ', differDesc! !!ClassCommentVersionsBrowser methodsFor: 'menu' stamp: 'jmv 11/24/2010 14:50'!offerVersionsHelp	(TextHolder new contents: self versionsHelpString)		openLabel: 'Class Comment Versions Browsers'! !!ClassCommentVersionsBrowser methodsFor: 'basic function' stamp: 'jmv 11/24/2010 14:20'!reformulateList     classOfMethod organization classComment ifNil: [^ self].	self scanVersionsOf: classOfMethod.	self changed: #list. "for benefit of mvc"	listIndex _ 1.	self changed: #listIndex.	self acceptedContentsChanged! !!Workspace methodsFor: 'menu commands' stamp: 'jmv 11/24/2010 23:43'!appendContentsOfFile	"Prompt for a file, and if one is obtained, append its contents to the contents of the receiver.   Caution: as currently implemented this abandons any custom style information previously in the workspace.  Someone should fix this.  Also, for best results you should accept the contents of the workspace before requesting this."	| aFileStream |	(aFileStream _ FileList2 modalFileSelector) ifNil: [^ self].	self actualContents: (self actualContents ifNil: ['']), aFileStream contentsOfEntireFile.	aFileStream close.	self changed: #contents! !Workspace removeSelector: #acceptedContentsChanged!!classDefinition: #Workspace category: #'System-Text'!TextHolder subclass: #Workspace	instanceVariableNames: 'bindings mustDeclareVariables shouldStyle'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!Workspace reorganize!('initialize-release' initialize)('binding' bindingOf: hasBindingOf: hasBindingThatBeginsWith: initializeBindings)('accessing' setBindings:)('as yet unclassified' saveContentsInFile)('drag and drop' acceptDroppingMorph:event:inMorph:)('menu commands' addModelItemsToWindowMenu: appendContentsOfFile)('code pane menu' editorClass)('*Shout-Styling' shouldStyle shoutAboutToStyle: toggleStyling toggleStylingLabel)('variable declarations' mustDeclareVariableWording toggleVariableDeclarationMode)('contents')!TextHolder initialize!!classDefinition: #SyntaxError category: #'Tools-Debugger'!TextHolder subclass: #SyntaxError	instanceVariableNames: 'class selector category debugger doitFlag'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Debugger'!MessageSet removeSelector: #retrieveContents!MessageSet removeSelector: #stringContents!Inspector removeSelector: #acceptedContents!Inspector removeSelector: #acceptedContentsChanged!Inspector removeSelector: #retrieveContents!!classDefinition: #Inspector category: #'Tools-Inspector'!AcceptingTextHolder subclass: #Inspector	instanceVariableNames: 'object selectionIndex timeOfLastListUpdate selectionUpdateTime context'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!Inspector reorganize!('accessing' baseFieldList context: fieldList i1 i2 initialExtent modelWakeUpIn: noteSelectionIndex:for: object object: selectedClass selectedClassOrMetaClass stepTimeIn: timeOfLastListUpdate update wantsSteps)('selecting' accept: contentsIsString replaceSelectionValue: selectedSlotName selection selectionIndex selectionPrintString selectionUnmodifiable toggleIndex:)('code' doItContext doItReceiver)('menu commands' addCollectionItemsTo: chasePointers classOfSelection classVarRefs defsOfSelection explorePointers exploreSelection fieldListMenu: inspectBasic inspectElement inspectSelection inspectorKey:from: objectReferencesToSelection referencesToSelection spawnFullProtocol spawnProtocol)('code pane menu' editorClass)('updating' updateListsAndCodeIn:)('message list menu' browseClass browseClassRefs browseClassVarRefs browseClassVariables browseFullProtocol browseInstVarDefs browseInstVarRefs browseMethodFull classHierarchy copyName)('initialize-release' initialize inspect:)('object fileIn' convertToCurrentVersion:refStream:)('private' printStringErrorText)('stepping' stepAt:in:)('contents' acceptedStringOrText)!!classDefinition: #FillInTheBlank category: #'Tools-Menus'!TextHolder subclass: #FillInTheBlank	instanceVariableNames: 'acceptOnCR done responseUponCancel'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!FileList removeSelector: #acceptedContents!FileList removeSelector: #acceptedContentsChanged!FileList removeSelector: #retrieveContents!FileList removeSelector: #stringContents!!classDefinition: #FileList category: #'Tools-FileList'!AcceptingTextHolder subclass: #FileList	instanceVariableNames: 'fileName directory volList volListIndex list listIndex pattern sortMode brevityState sortAscending'	classVariableNames: 'FileReaderRegistry RecentDirs'	poolDictionaries: ''	category: 'Tools-FileList'!!FileList reorganize!('file list' fileList fileListIndex fileListIndex: fileName readOnlyStream)('file list menu' compressFile editorClass fileContentsMenu:shifted: fileListMenu: fileSelectedMenu: fullFileListMenu:shifted: itemsForAnyFile itemsForFile: itemsForNoFile myServicesForFile:suffix: noFileSelectedMenu: offerAllFileOptions suffixOfSelectedFile)('file menu action' addNew:byEvaluating: addNewDirectory addNewFile deleteFile get getHex renameFile sortByDate sortByName sortBySize)('initialization' buttonSelectorsToSuppress directory: dynamicButtonServices initialize labelString modelSleep modelWakeUp optionalButtonRow optionalButtonSpecs setFileStream: universalButtonServices updateButtonRow updateButtonRow:)('menu messages' copyName)('own services' serviceAddNewDirectory serviceAddNewFile serviceAllFileOptions serviceBrowseCodeFiles serviceCompressFile serviceCopyName serviceDeleteFile serviceGet serviceGetHex serviceRenameFile serviceSortByDate serviceSortByName serviceSortBySize serviceViewContentsInWorkspace servicesFromSelectorSpecs: viewContentsInWorkspace)('to be transformed in registration' perform:orSendTo: volumeMenu:)('updating' update:)('volume list and pattern' deleteDirectory directory fileNameFormattedFrom:namePad:sizePad:sizeWithCommasPad: pattern pattern: veryDeepFixupWith: volumeList volumeListIndex volumeListIndex:)('private' acceptedStringOrText addPath: defaultContents entriesMatching: fileNameFromFormattedItem: folderString fullName isFileSelected listForPatterns: put: readContentsBrief: readContentsHex: readServerBrief recentDirs registeredFileReaderClasses resort: sortBlock sortingByDate sortingByName sortingBySize updateFileList)('optional panes' wantsOptionalButtons)('contents')!FileContentsBrowser removeSelector: #retrieveContents!FileContentsBrowser removeSelector: #stringContents!Debugger removeSelector: #retrieveContents!Debugger removeSelector: #selectionInterval!Debugger removeSelector: #stringContents!ChangeList removeSelector: #retrieveContents!ChangeList removeSelector: #stringContents!Browser removeSelector: #retrieveContents!Browser removeSelector: #selectionInterval!Browser removeSelector: #stringContents!CodeHolder removeSelector: #acceptedContents!CodeHolder removeSelector: #changed:!CodeHolder removeSelector: #contents!CodeHolder removeSelector: #contentsChanged!CodeHolder removeSelector: #retrieveContents!CodeHolder removeSelector: #stringContents!!classDefinition: #CodeHolder category: #'System-Text'!AcceptingTextHolder subclass: #CodeHolder	instanceVariableNames: 'currentCompiledMethod contentsSymbol'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!AcceptingTextHolder removeSelector: #contents!AcceptingTextHolder removeSelector: #contents:!AcceptingTextHolder removeSelector: #prvtAcceptedContents!AcceptingTextHolder removeSelector: #prvtAcceptedContentsString!AcceptingTextHolder removeSelector: #prvtContents!AcceptingTextHolder removeSelector: #prvtSetAcceptedContents:!AcceptingTextHolder removeSelector: #prvtSetContents:!AcceptingTextHolder removeSelector: #retrieveContents!AcceptingTextHolder removeSelector: #stringContents!!AcceptingTextHolder reorganize!('initialize-release' initialize)('contents' acceptedContents acceptedContentsChanged acceptedStringOrText copy)!TextHolder removeSelector: #acceptContents:!TextHolder removeSelector: #actualContentsString!TextHolder removeSelector: #contents!TextHolder removeSelector: #contents:!TextHolder removeSelector: #prvtActualContents!TextHolder removeSelector: #prvtContents!TextHolder removeSelector: #prvtSetActualContents:!TextHolder removeSelector: #prvtSetContents:!TextHolder removeSelector: #selectionInterval!TextHolder removeSelector: #stringContents!ObjectExplorer removeSelector: #contentsSelection!Object removeSelector: #contentsChanged!Smalltalk removeClassNamed: #StringHolder!