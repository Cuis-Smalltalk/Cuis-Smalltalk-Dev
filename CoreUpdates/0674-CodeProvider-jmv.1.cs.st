'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 1 December 2010 at 3:46:17 pm'!!classDefinition: #CodeProvider category: #'System-Text'!Model subclass: #CodeProvider	instanceVariableNames: 'acceptedContentsCache currentCompiledMethod contentsSymbol'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!CodeProvider commentStamp: '<historical>' prior: 0!An ancestor class for all models which can show code.!!classDefinition: #Browser category: #'Tools-Browser'!CodeProvider subclass: #Browser	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer systemCategoryListIndex classListIndex messageCategoryListIndex messageListIndex editSelection metaClassIndicated '	classVariableNames: 'RecentClasses '	poolDictionaries: ''	category: 'Tools-Browser'!!classDefinition: #ChangeList category: #'Tools-Changes'!CodeProvider subclass: #ChangeList	instanceVariableNames: 'changeList list listIndex listSelections file lostMethodPointer '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!classDefinition: #ChangeSorter category: #'Tools-Changes'!CodeProvider subclass: #ChangeSorter	instanceVariableNames: 'parent myChangeSet currentClassName currentSelector priorChangeSetList changeSetCategory '	classVariableNames: 'AllChangeSets ChangeSetCategories PreviousSet '	poolDictionaries: ''	category: 'Tools-Changes'!!classDefinition: #Debugger category: #'Tools-Debugger'!CodeProvider subclass: #Debugger	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC savedCursor errorWasInUIProcess labelString '	classVariableNames: 'ContextStackKeystrokes ErrorRecursion '	poolDictionaries: ''	category: 'Tools-Debugger'!!classDefinition: #FileList category: #'Tools-FileList'!Model subclass: #FileList	instanceVariableNames: 'fileName directory volList volListIndex list listIndex pattern sortMode brevityState sortAscending acceptedContentsCache '	classVariableNames: 'FileReaderRegistry RecentDirs '	poolDictionaries: ''	category: 'Tools-FileList'!!classDefinition: #Inspector category: #'Tools-Inspector'!Model subclass: #Inspector	instanceVariableNames: 'object selectionIndex timeOfLastListUpdate selectionUpdateTime context acceptedContentsCache '	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!TextHolder commentStamp: 'jmv 11/25/2010 12:38' prior: 0!I am a kind of Model that includes a piece of text.Category 'pane menu' and 'message list menu' are messages that may be called by my menus.See also CodeProvider.!!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/25/2010 12:01'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript		ifNil: [			self postscriptString: '"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/25/2010 12:24'!assurePreambleExists	"Make sure there is a StringHolder holding the preamble; if it's found to have reverted to empty contents, put up the template"	(preamble == nil or: [preamble contents isEmptyOrNil])		ifTrue: [preamble _ TextHolder new actualContents: self preambleTemplate]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/25/2010 12:25'!postscriptString: aString	postscript _ TextHolder new actualContents: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/25/2010 12:24'!preambleString: aString	"Establish aString as the new contents of the preamble.  "	preamble _ TextHolder new actualContents: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 11/25/2010 12:24'!setPreambleToSay: aString	"Make aString become the preamble of this change set"	preamble _ TextHolder new actualContents: aString! !!CodeProvider methodsFor: 'initialize-release' stamp: 'jmv 11/25/2010 11:39'!initialize	"Initialize the state of the receiver with its default contents."	super initialize.	acceptedContentsCache _ ''! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 12/1/2010 15:44'!addOptionalAnnotationsTo: window at: fractions plus: verticalOffset	"Add an annotation pane to the window if preferences indicate a desire for it, and return the incoming verticalOffset plus the height of the added pane, if any"	| aTextMorph divider delta |	self wantsAnnotationPane ifFalse: [^ verticalOffset].	aTextMorph _ PluggableTextMorph 		model: self		editorClass: self editorClass		textGetter: #annotation 		textSetter: nil.	aTextMorph		askBeforeDiscardingEdits: false;		borderWidth: 0;		hideScrollBarsIndefinitely.	divider _ BorderedSubpaneDividerMorph forBottomEdge.	delta _ self defaultAnnotationPaneHeight.	window 		addMorph: aTextMorph 		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@verticalOffset corner: 0@(verticalOffset + delta - 1))).	window 		addMorph: divider		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@(verticalOffset + delta - 1) corner: 0@(verticalOffset + delta))).	^ verticalOffset + delta! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 11/25/2010 11:36'!addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream	"add an annotation detailing the prior versions count"	| versionsCount |	versionsCount _ VersionsBrowser versionCountForSelector: aSelector class: aClass.	aStream nextPutAll: 				((versionsCount > 1					ifTrue:						[versionsCount = 2 ifTrue:							['1 prior version']							ifFalse:								[versionsCount printString, ' prior versions']]					ifFalse:						['no prior versions']), self annotationSeparator)! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 11/25/2010 11:36'!annotation	"Provide a line of content for an annotation pane, representing information about the method associated with the selected class and selector in the receiver."	|  aSelector aClass |	((aSelector _ self selectedMessageName) == nil or: [(aClass _ self selectedClassOrMetaClass) == nil])		ifTrue: [^ '------'].	^ self annotationForSelector: aSelector ofClass: aClass! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 11/25/2010 11:36'!annotationForClassCommentFor: aClass	"Provide a line of content for an annotation pane, given that the receiver is pointing at the clas comment of the given class."	| aStamp nonMeta |	aStamp _  (nonMeta _ aClass theNonMetaClass) organization commentStamp.	^ aStamp		ifNil:			[nonMeta name, ' has no class comment']		ifNotNil:			['class comment for ', nonMeta name,				(aStamp = '<historical>'					ifFalse:						[' - ', aStamp]					ifTrue:						[''])]! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 11/25/2010 11:36'!annotationForClassDefinitionFor: aClass	"Provide a line of content for an annotation pane, given that the receiver is pointing at the class definition of the given class."	^ 'Class definition for ', aClass name! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 11/25/2010 11:36'!annotationForHierarchyFor: aClass	"Provide a line of content for an annotation pane, given that the receiver is pointing at the hierarchy of the given class."	^ 'Hierarchy for ', aClass name! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 11/25/2010 11:36'!annotationForSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing  	information about the given selector and class"	| stamp sendersCount implementorsCount aCategory separator aString aList aComment aStream requestList |	aSelector == #Comment		ifTrue: [^ self annotationForClassCommentFor: aClass].	aSelector == #Definition		ifTrue: [^ self annotationForClassDefinitionFor: aClass].	aSelector == #Hierarchy		ifTrue: [^ self annotationForHierarchyFor: aClass].	aStream _ ReadWriteStream on: ''.	requestList _ self annotationRequests.	separator _ requestList size > 1				ifTrue: [self annotationSeparator]				ifFalse: [''].	requestList		do: [:aRequest | 			aRequest == #firstComment				ifTrue: [aComment _ aClass firstCommentAt: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #masterComment				ifTrue: [aComment _ aClass supermostPrecodeCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #documentation				ifTrue: [aComment _ aClass precodeCommentOrInheritedCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #timeStamp				ifTrue: [stamp _ self timeStamp.					aStream						nextPutAll: (stamp size > 0								ifTrue: [stamp , separator]								ifFalse: ['no timeStamp' , separator])].			aRequest == #messageCategory				ifTrue: [aCategory _ aClass organization categoryOfElement: aSelector.					aCategory						ifNotNil: ["woud be nil for a method no longer present,  							e.g. in a recent-submissions browser"							aStream nextPutAll: aCategory , separator]].			aRequest == #sendersCount				ifTrue: [sendersCount _ (Smalltalk allCallsOn: aSelector) size.					sendersCount _ sendersCount = 1								ifTrue: ['1 sender']								ifFalse: [sendersCount printString , ' senders'].					aStream nextPutAll: sendersCount , separator].			aRequest == #implementorsCount				ifTrue: [implementorsCount _ Smalltalk numberOfImplementorsOf: aSelector.					implementorsCount _ implementorsCount = 1								ifTrue: ['1 implementor']								ifFalse: [implementorsCount printString , ' implementors'].					aStream nextPutAll: implementorsCount , separator].			aRequest == #priorVersionsCount				ifTrue: [self						addPriorVersionsCountForSelector: aSelector						ofClass: aClass						to: aStream].			aRequest == #priorTimeStamp				ifTrue: [stamp _ VersionsBrowser								timeStampFor: aSelector								class: aClass								reverseOrdinal: 2.					stamp						ifNotNil: [aStream nextPutAll: 'prior time stamp: ' , stamp , separator]].			aRequest == #recentChangeSet				ifTrue: [aString _ ChangeSorter mostRecentChangeSetWithChangeForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].			aRequest == #allChangeSets				ifTrue: [aList _ ChangeSorter allChangeSetsWithClass: aClass selector: aSelector.					aList size > 0						ifTrue: [aList size = 1								ifTrue: [aStream nextPutAll: 'only in change set ']								ifFalse: [aStream nextPutAll: 'in change sets: '].							aList								do: [:aChangeSet | aStream nextPutAll: aChangeSet name , ' ']]						ifFalse: [aStream nextPutAll: 'in no change set'].					aStream nextPutAll: separator].			aRequest == #closuresInfo				ifTrue: [aString _ Smalltalk closuresInfoStringForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].		].	^ aStream contents! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 11/25/2010 11:36'!annotationRequests	^ Preferences defaultAnnotationRequests! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 11/25/2010 11:36'!annotationSeparator	"Answer the separator to be used between annotations"	^ ' ° '! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 11/25/2010 11:36'!defaultAnnotationPaneHeight	"Answer the receiver's preferred default height for new annotation panes."	^ StrikeFont default height * 2 + 8! !!CodeProvider methodsFor: 'annotation' stamp: 'jmv 11/25/2010 11:36'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^Preferences standardButtonFont height * 8 // 5	! !!CodeProvider methodsFor: 'categories' stamp: 'jmv 11/25/2010 11:36'!categoryFromUserWithPrompt: aPrompt for: aClass	"self new categoryFromUserWithPrompt: 'testing' for: SystemDictionary"	|  labels myCategories reject lines newName menuIndex |	labels _ OrderedCollection with: 'new...'.	labels addAll: (myCategories _ aClass organization categories asArray sort:		[ :a :b | a asLowercase < b asLowercase ]).	reject _ myCategories asSet.	reject		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines _ OrderedCollection with: 1 with: (myCategories size + 1).	aClass allSuperclasses do:		[:cls | | cats |			cats _ cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse:				[lines add: labels size.				labels addAll: (cats asArray sort:					[:a :b | a asLowercase < b asLowercase]).				reject addAll: cats]].	newName _ (labels size = 1 or:		[menuIndex _ (PopUpMenu labelArray: labels lines: lines)		startUpWithCaption: aPrompt.		menuIndex = 0 ifTrue: [^ nil].		menuIndex = 1])			ifTrue:				[FillInTheBlank request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: 				[labels at: menuIndex].	^ newName ifNotNil: [newName asSymbol]! !!CodeProvider methodsFor: 'categories' stamp: 'jmv 11/25/2010 11:36'!categoryOfCurrentMethod	"Answer the category that owns the current method.  If unable to determine a category, answer nil."	^ self selectedClassOrMetaClass ifNotNil: [ :cls | 		self selectedMessageName ifNotNil: [ :sel |			cls whichCategoryIncludesSelector: sel]]! !!CodeProvider methodsFor: 'categories' stamp: 'jmv 11/25/2010 11:36'!changeCategory	"Present a menu of the categories of messages for the current class, 	and let the user choose a new category for the current message"	self selectedClassOrMetaClass ifNotNil: [ :cls |		self selectedMessageName ifNotNil: [ :sel |			(self letUserReclassify: sel in: cls) ifTrue: [				"ChangeSet current reorganizeClass: aClass."				"Decided on further review that the above, when present, could cause more                    unexpected harm than good"				self methodCategoryChanged]]]! !!CodeProvider methodsFor: 'categories' stamp: 'jmv 11/25/2010 11:36'!letUserReclassify: anElement in: aClass	"Put up a list of categories and solicit one from the user.  	Answer true if user indeed made a change, else false"		| currentCat newCat |	currentCat _ aClass organization categoryOfElement: anElement.	newCat _ self 				categoryFromUserWithPrompt: 'choose category (currently "', currentCat, '")' 				for: aClass.	(newCat notNil and: [newCat ~= currentCat])		ifTrue: [			aClass organization classify: anElement under: newCat suppressIfDefault: false.			^ true]		ifFalse: [			^ false]! !!CodeProvider methodsFor: 'categories' stamp: 'jmv 11/25/2010 11:36'!methodCategoryChanged	self changed: #annotation! !!CodeProvider methodsFor: 'categories' stamp: 'jmv 11/25/2010 11:36'!selectedMessageCategoryName	"Answer the name of the message category of the message of the currently selected context."	^ self selectedClass organization categoryOfElement: self selectedMessageName! !!CodeProvider methodsFor: 'contents' stamp: 'jmv 11/25/2010 11:38'!acceptedContents	^ Text		initialFont: Preferences standardCodeFont		stringOrText: self acceptedStringOrText! !!CodeProvider methodsFor: 'contents' stamp: 'jmv 11/25/2010 11:36'!acceptedContentsChanged	self changed: #acceptedContents.	self changed: #annotation! !!CodeProvider methodsFor: 'contents' stamp: 'jmv 11/25/2010 11:36'!acceptedStringOrText	"Answer the source code or documentation for the selected method"	self showingByteCodes ifTrue: [		^ self selectedBytecodes].	self showingDocumentation ifTrue: [		^ self commentContents].	^ self selectedMessage! !!CodeProvider methodsFor: 'contents' stamp: 'jmv 11/25/2010 11:36'!commentContents	"documentation for the selected method"	| poss aClass aSelector |	^ (poss _ (aClass _ self selectedClassOrMetaClass)						ifNil:							['----']						ifNotNil:							[(aSelector _ self selectedMessageName)								ifNil:									['---']								ifNotNil:									[(aClass precodeCommentOrInheritedCommentFor: aSelector)", String cr, String cr, self timeStamp""which however misses comments that are between the temps  declaration and the body of the method; those are picked up by [aClass commentOrInheritedCommentFor: aSelector] but that method will get false positives from comments *anywhere* in the method source"]])		isEmptyOrNil			ifTrue:				[aSelector					ifNotNil:						[((aClass methodHeaderFor: aSelector), 'Has no comment') asText makeSelectorBoldIn: aClass]					ifNil:						['Hamna']]			ifFalse:	[aSelector				ifNotNil: [((aClass methodHeaderFor: aSelector), '', poss) asText makeSelectorBoldIn: aClass]				ifNil: [poss]]! !!CodeProvider methodsFor: 'contents' stamp: 'jmv 11/25/2010 11:36'!contentsSymbol	"Answer a symbol indicating what kind of content should be shown for the method; for normal showing of source code, this symbol is #source.  A nil value in the contentsSymbol slot will be set to #source by this method"	^ contentsSymbol ifNil: [		contentsSymbol _ Preferences browseWithPrettyPrint					ifTrue:						[#prettyPrint]					ifFalse:						[#source]]! !!CodeProvider methodsFor: 'contents' stamp: 'jmv 11/25/2010 11:36'!contentsSymbol: aSymbol	"Set the contentsSymbol as indicated.  #source means to show source code, #comment means to show the first comment found in the source code"	contentsSymbol _ aSymbol.	self setContentsToForceRefetch.	self acceptedContentsChanged! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!adoptMessageInCurrentChangeset	"Add the receiver's method to the current change set if not already there"	self setClassAndSelectorIn: [:cl :sel |		cl ifNotNil:			[ChangeSet current adoptSelector: sel forClass: cl.			self changed: #annotation]]! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!browseImplementors	"Create and schedule a message set browser on all implementors of the currently selected message selector. Do nothing if no message is selected."	self selectedMessageName ifNotNil: [ :messageName |		Smalltalk browseAllImplementorsOf: messageName]! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!browseSenders	"Create and schedule a message set browser on all senders of the currently selected message selector.  Of there is no message currently selected, offer a type-in"	self sendQuery: #browseAllCallsOn: to: Smalltalk! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!copyUpOrCopyDown	"Used to copy down code from a superclass to a subclass or vice-versa in one easy step, if you know what you're doing.  Prompt the user for which class to copy down or copy up to, then spawn a fresh browser for that class, with the existing code planted in it, and with the existing method category also established."	| aClass aSelector allClasses implementors aMenu |	((aClass := self selectedClassOrMetaClass) isNil 		or: [(aSelector := self selectedMessageName) isNil]) 			ifTrue: [^Beeper beep].	allClasses := Utilities hierarchyOfClassesSurrounding: aClass.	implementors := Smalltalk hierarchyOfImplementorsOf: aSelector				forClass: aClass.	aMenu := MenuMorph new defaultTarget: self.	aMenu title: aClass name , '.' , aSelector 				, 'Choose where to insert a copy of this method(blue = current, black = available, red = other implementors'.	allClasses do: 			[:cl | | aColor |			aColor := cl == aClass 						ifTrue: [#blue]						ifFalse: [(implementors includes: cl) ifTrue: [#red] ifFalse: [#black]].			aColor == #red 				ifFalse: 					[aMenu 						add: cl name						selector: #spawnToClass:						argument: cl]				ifTrue: 					[aMenu 						add: cl name						selector: #spawnToCollidingClass:						argument: cl].			aMenu lastItem color: (Color colorFrom: aColor)].	aMenu popUpInWorld! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!makeSampleInstance	| aClass nonMetaClass anInstance |	(aClass _ self selectedClassOrMetaClass) ifNil: [^ self].	nonMetaClass _ aClass theNonMetaClass.	anInstance _ self sampleInstanceOfSelectedClass.	(anInstance isNil and: [nonMetaClass ~~ UndefinedObject]) ifTrue: 		[^ self inform: 'Sorry, cannot make an instance of ', nonMetaClass name].	(anInstance is: #Morph)		ifTrue: [			self currentHand attachMorph: anInstance]		ifFalse: [			anInstance inspectWithLabel: 'An instance of ', nonMetaClass name]! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!offerShiftedClassListMenu	"Offer the shifted class-list menu."	^ self offerMenuFrom: #classListMenu:shifted: shifted: true! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!offerUnshiftedClassListMenu	"Offer the shifted class-list menu."	^ self offerMenuFrom: #classListMenu:shifted: shifted: false! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!removeClass	"Remove the selected class from the system, at interactive user request.  Make certain the user really wants to do this, since it is not reversible.  Answer true if removal actually happened."	| message  className classToRemove result |	self okToChange ifFalse: [^ false].	classToRemove _ self selectedClassOrMetaClass ifNil: [Beeper beep. ^ false].	classToRemove _ classToRemove theNonMetaClass.	className _ classToRemove name.	message _ 'Are you certain that youwant to REMOVE the class ', className, 'from the system?'.	(result _ self confirm: message)		ifTrue: 			[classToRemove subclasses size > 0				ifTrue: [(self confirm: 'class has subclasses: ' , message)					ifFalse: [^ false]].			classToRemove removeFromSystem.			self changed: #classList.			true].	^ result! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!shiftedYellowButtonActivity	"Offer the shifted selector-list menu"	^ self offerMenuFrom: #messageListMenu:shifted: shifted: true! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!showUnreferencedClassVars	"Search for all class variables known to the selected class, and put up a 	list of those that have no references anywhere in the system. The 	search includes superclasses, so that you don't need to navigate your 	way to the class that defines each class variable in order to determine 	whether it is unreferenced"	| cls aList aReport |	(cls _ self selectedClass)		ifNil: [^ self].	aList _ cls allUnreferencedClassVariables.	aList size = 0		ifTrue: [^ self inform: 'There are no unreferencedclass variables in' , cls name].	aReport _ String				streamContents: [:aStream | 					aStream nextPutAll: 'Unreferenced class variable(s) in ' , cls name;						 cr.					aList						do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList)		startUpWithCaption: 'Unreferencedclass variables in ' , cls name! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!showUnreferencedInstVars	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"	| cls aList aReport |	(cls _ self selectedClassOrMetaClass) ifNil: [^ self].	aList _ cls allUnreferencedInstanceVariables.	aList size = 0 ifTrue: [^ self inform: 'There are no unreferencedinstance variables in', cls name].	aReport _ String streamContents:		[:aStream |			aStream nextPutAll: 'Unreferenced instance variable(s) in ', cls name; cr.			aList do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList) startUpWithCaption: 'Unreferencedinstance variables in ', cls name! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!spawnFullProtocol	"Create and schedule a new protocol browser on the currently selected class or meta."	self selectedClassOrMetaClass ifNotNil: [ :classOrMetaclass |       	ProtocolBrowser openFullProtocolForClass: classOrMetaclass]! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!spawnHierarchy	"Create and schedule a new hierarchy browser on the currently selected class or meta."	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |	(selectedClassOrMetaClass _ self selectedClassOrMetaClass)		ifNil: [^ self].	newBrowser _ HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.	((aSymbol _ self selectedMessageName) notNil and: [(MessageSet isPseudoSelector: aSymbol) not])		ifTrue:			[aBehavior _ selectedClassOrMetaClass.			messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.			newBrowser messageCategoryListIndex: messageCatIndex + 1.			newBrowser messageListIndex:				((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol)].	Browser		openBrowserView: (newBrowser openSystemCatEditString: nil)		label: newBrowser labelString.	newBrowser assureSelectionsShow! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!spawnProtocol	"Create and schedule a new protocol browser on the currently selected class or meta."	self selectedClassOrMetaClass ifNotNil: [ :classOrMetaclass |       	ProtocolBrowser openSubProtocolForClass: classOrMetaclass]! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!spawnToClass: aClass	"Used to copy down code from a superclass to a subclass in one easy step, if you know what you're doing.  Spawns a new message-category browser for the indicated class, populating it with the source code seen in the current tool."	| newBrowser org |		self categoryOfCurrentMethod		ifNil: [			self buildClassBrowserEditString: self acceptedContents]		ifNotNil: [ :category |			((org _ aClass organization) categories includes: category)				ifFalse:	[org addCategory: category].			newBrowser _ Browser new setClass: aClass selector: nil.			newBrowser selectMessageCategoryNamed: category.			Browser openBrowserView: (newBrowser openMessageCatEditString: self acceptedContents)				label: 'category "', category, '" in ', 					newBrowser selectedClassOrMetaClassName]! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!spawnToCollidingClass: aClass	"Potentially used to copy down code from a superclass to a subclass in one easy step, in the case where the given class already has its own version of code, which would consequently be clobbered if the spawned code were accepted."	self inform: 'That would be destructive ofsome pre-existing code already in thatclass for this selector.  For the moment,we will not let you do this to yourself.'! !!CodeProvider methodsFor: 'commands' stamp: 'jmv 11/25/2010 11:36'!unshiftedYellowButtonActivity	"Offer the unshifted shifted selector-list menu"	^ self offerMenuFrom: #messageListMenu:shifted: shifted: false! !!CodeProvider methodsFor: 'construction' stamp: 'jmv 11/25/2010 11:36'!buildClassBrowserEditString: aString 	"Create and schedule a new class browser for the current selection, with initial textual contents set to aString.  This is used specifically in spawning where a class is established but a method-category is not."	| newBrowser  |	newBrowser _ Browser new.	newBrowser setClass: self selectedClassOrMetaClass selector: nil.	newBrowser editSelection: #newMessage.	Browser openBrowserView: (newBrowser openOnClassWithEditString: aString)			label: 'Class Browser: ', self selectedClassOrMetaClass name! !!CodeProvider methodsFor: 'construction' stamp: 'jmv 11/25/2010 11:36'!buildMorphicCodePaneWith: editString	"Construct the pane that shows the code.	Respect the Preference for standardCodeFont."	| codePane |	codePane := PluggableTextMorph				model: self				editorClass: self editorClass				textGetter: #acceptedContents				textSetter: #contents:notifying:				selectionGetter: #contentsSelection				menuGetter: #paneMenu:shifted:editorClass:.	editString		ifNotNil: [			codePane editString: editString.			codePane hasUnacceptedEdits: true].	^ codePane! !!CodeProvider methodsFor: 'controls' stamp: 'jmv 12/1/2010 15:44'!addOptionalButtonsTo: window at: fractions plus: verticalOffset	"If the receiver wishes it, add a button pane to the window, and answer the verticalOffset plus the height added"	| delta buttons divider |	self wantsOptionalButtons ifFalse: [^verticalOffset].	delta _ self defaultButtonPaneHeight.	buttons _ self optionalButtonRow 		color: (ColorTheme current buttonColorFrom: self class windowColor).	divider _ BorderedSubpaneDividerMorph forBottomEdge.	window 		addMorph: buttons		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@verticalOffset corner: 0@(verticalOffset + delta - 1))).	window 		addMorph: divider		fullFrame: (LayoutFrame 				fractions: fractions 				offsets: (0@(verticalOffset + delta - 1) corner: 0@(verticalOffset + delta))).	^ verticalOffset + delta! !!CodeProvider methodsFor: 'controls' stamp: 'jmv 11/25/2010 11:36'!buttonWithSelector: aSelector 	"If receiver has a control button with the given action selector answer it, else answer nil.  morphic only at this point"	| aWindow |	((aWindow := self containingWindow) is: #SystemWindow) 		ifFalse: [^nil].	^aWindow 		findDeepSubmorphThat: 			[ :m | (m isKindOf: PluggableButtonMorph) and: [m actionSelector == aSelector]]		ifAbsent: [ ^nil ]! !!CodeProvider methodsFor: 'controls' stamp: 'jmv 11/25/2010 11:36'!contentsSymbolQuints	"Answer a list of quintuplets representing information on the alternative views available in the code pane		first element:	the contentsSymbol used		second element:	the selector to call when this item is chosen.		third element:	the selector to call to obtain the wording of the menu item.		fourth element:	the wording to represent this view		fifth element:	balloon help	A hypen indicates a need for a seperator line in a menu of such choices"	^ #((source				togglePlainSource 			showingPlainSourceString														'source'			'the textual source code as writen')(documentation		toggleShowDocumentation showingDocumentationString														'documentation'	'the first comment in the method')-(prettyPrint			togglePrettyPrint 			prettyPrintString														'prettyPrint'			'the method source presented in a standard text format')-(lineDiffs				toggleLineDiffing			showingLineDiffsString														'lineDiffs'			'the textual source lines diffed from its prior version')(wordDiffs			toggleWordDiffing			showingWordDiffsString														'wordDiffs'			'the textual source words diffed from its prior version')(prettyLineDiffs		togglePrettyLineDiffing	showingPrettyLineDiffsString														'prettyLineDiffs'		'formatted source lines diffed from formatted prior version')(prettyWordDiffs	togglePrettyWordDiffing	showingPrettyWordDiffsString														'prettyWordDiffs'	'formatted source words diffed from prior version')-(decompile			toggleDecompile			showingDecompileString														'decompile'			'source code decompiled from byteCodes')(byteCodes			toggleShowingByteCodes	showingByteCodesString														'byteCodes'		'the bytecodes that comprise the compiled method')	)! !!CodeProvider methodsFor: 'controls' stamp: 'jmv 11/25/2010 11:36'!decorateButtons	"Change screen feedback for any buttons in the UI of the receiver that may wish it.  Initially, it is only the Inheritance button that is decorated, but one can imagine others."	self decorateForInheritance ! !!CodeProvider methodsFor: 'controls' stamp: 'jmv 12/1/2010 15:45'!decorateForInheritance	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."	| aColor aButton flags buttonColor |	(aButton _ self inheritanceButton) ifNil: [^ self].	((currentCompiledMethod isKindOf: CompiledMethod) and: [Preferences decorateBrowserButtons])		ifFalse: [ ^aButton color: self class windowColor ].	"This table duplicates the old logic, but adds two new colors for the cases where there is a superclass definition, but this method doesn't call it."	flags _ 0.	self isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].	currentCompiledMethod sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].	self isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].	buttonColor _ ColorTheme current buttonColorFrom: self class windowColor.	aColor _ {		"This is NOTan override. There is no super implementation."		buttonColor.							"no sends to super. there is not an override"		Color tan.							"no sends to super. there is an override"		Color red.							"sends to super. there is not an override. Error: no super to call"		Color red.							"sends to super. there is  an override. Error: no super to call"		"This is an override. There is some super implementation"		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"		Color green muchLighter.			"doesn't have sub; has super and callsl it"		Color blue muchLighter.			"has sub; has super and callsl it"	} at: flags + 1.	aButton color: aColor! !!CodeProvider methodsFor: 'controls' stamp: 'jmv 11/25/2010 11:36'!inheritanceButton	"If receiver has an Inheritance button, answer it, else answer nil.  morphic only at this point"	^ self buttonWithSelector: #methodHierarchy! !!CodeProvider methodsFor: 'controls' stamp: 'jmv 11/25/2010 11:36'!optionalButtonRow	"Answer a row of control buttons"	| row buttons widths |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	self optionalButtonTuples do: [ :tuple | | button |		widths add: tuple first.		button _ PluggableButtonMorph 					model: self					stateGetter: nil					action: tuple third.		button label: tuple second asString.		tuple size > 3 ifTrue: [button setBalloonText: tuple fourth].		tuple size > 4 ifTrue: [button triggerOnMouseDown: tuple fifth].		buttons add: button ].	row _ AlignmentMorph proportional.	row addInRow: buttons widthProportionalTo: widths.	^row! !!CodeProvider methodsFor: 'controls' stamp: 'jmv 11/25/2010 11:36'!optionalButtonTuples	"Answer a tuple buttons, in the format:			button label			selector to send			help message"	| aList |	aList _ #(	(10	'browse'			browseMethodFull				'view this method in a browser')	(11	'senders' 			browseSendersOfMessages	'browse senders of...')	(16	'implementors'		browseMessages				'browse implementors of...')	(11	'versions'			browseVersions					'browse versions')), 	(Preferences decorateBrowserButtons		ifTrue:			[{#(13	'inheritance'		methodHierarchy 	'browse method inheritancegreen: sends to supertan: has override(s)mauve: both of the abovepink: is an override but doesn''t call superpinkish tan: has override(s), also is an override but doesn''t call super' )}]		ifFalse:			[{#(13	'inheritance'		methodHierarchy	'browse method inheritance')}]),	#(	(12	'hierarchy'			classHierarchy					'browse class hierarchy')	(11	'inst vars'			browseInstVarRefs				'inst var refs...')	(13	'class vars'			browseClassVarRefs			'class var refs...')	(9	'show...'				offerWhatToShowMenu		'menu of what to show in lower pane')).	^ aList! !!CodeProvider methodsFor: 'controls' stamp: 'jmv 11/25/2010 11:36'!sourceAndDiffsQuintsOnly	"Answer a list of quintuplets representing information on the alternative views available in the code pane for the case where the only plausible choices are showing source or either of the two kinds of diffs"	^ #((source				togglePlainSource 			showingPlainSourceString														'source'			'the textual source code as writen')(lineDiffs				toggleLineDiffing			showingLineDiffsString														'lineDiffs'			'the textual source diffed from its prior version')(wordDiffs			toggleWordDiffing			showingWordDiffsString														'wordDiffs'			'the textual source words diffed from its prior version')(prettyLineDiffs		togglePrettyLineDiffing	showingPrettyLineDiffsString														'linePrettyDiffs'		'formatted source diffed from formatted prior version')(prettyWordDiffs	togglePrettyWordDiffing	showingPrettyWordDiffsString														'linePrettyDiffs'		'formatted source words diffed from prior version')	)! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!defaultDiffsSymbol	"Answer the code symbol to use when generically switching to diffing"	^ Preferences diffsWithPrettyPrint 		ifTrue: [			#prettyLineDiffs]		ifFalse: [			#lineDiffs]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!diffFromPriorSourceFor: sourceCode 	"If there is a prior version of source for the selected method, return a diff, else just return the source code"	^ self priorSourceOrNil		ifNil: [ sourceCode ]		ifNotNil: [ :prior |			DifferenceFinder				displayPatchFrom: prior to: sourceCode				tryWords: self shouldDiffWords				prettyPrintedIn: (self showingAnyKindOfPrettyDiffs ifTrue: [self selectedClass])]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!lineDiffButton	"Return a checkbox that lets the user decide whether regular diffs should be shown or not"	| outerButton button |	outerButton _ AlignmentMorph proportional.	outerButton		 borderWidth: 2;		 borderColor: #raised.	outerButton color: Color transparent.	button _ UpdatingThreePhaseButtonMorph checkBox.	button		 target: self;		 actionSelector: #toggleLineDiffing;		 getSelector: #showingLineDiffs.	outerButton		addMorph: button		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (2 @ 3 corner: 18 @ 0));		addMorph: (StringMorph contents: 'lineDiffs' color: ColorTheme current buttonLabel) lock		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (18 @ 2 corner: 0 @ 0)).	outerButton setBalloonText: 'Show code differences from the previous version, line by line.'.	^ outerButton! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!prettyLineDiffButton	"Return a checkbox that lets the user decide whether prettyDiffs should be shown or not"	| outerButton button |	outerButton _ AlignmentMorph proportional.	outerButton		 borderWidth: 2;		 borderColor: #raised.	outerButton color: Color transparent.	button _ UpdatingThreePhaseButtonMorph checkBox.	button		 target: self;		 actionSelector: #togglePrettyLineDiffing;		 getSelector: #showingPrettyLineDiffs.	outerButton		addMorph: button		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (2 @ 3 corner: 18 @ 0));		addMorph: (StringMorph contents: 'linePrettyDiffs' color: ColorTheme current buttonLabel) lock		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (18 @ 2 corner: 0 @ 0)).	(self isKindOf: VersionsBrowser)		ifTrue: [ outerButton setBalloonText: 'Show pretty-printed code differences from the previous version, line by line.' ]		ifFalse: [ outerButton setBalloonText: 'Show pretty-printed code differences between the file-based method and the in-memory version, line by line.' ].	^ outerButton.! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!prettyWordDiffButton	"Return a checkbox that lets the user decide whether prettyDiffs should be shown or not"	| outerButton button |	outerButton _ AlignmentMorph proportional.	outerButton		 borderWidth: 2;		 borderColor: #raised.	outerButton color: Color transparent.	button _ UpdatingThreePhaseButtonMorph checkBox.	button		 target: self;		 actionSelector: #togglePrettyWordDiffing;		 getSelector: #showingPrettyWordDiffs.	outerButton		addMorph: button		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (2 @ 3 corner: 18 @ 0));		addMorph: (StringMorph contents: 'wordPrettyDiffs' color: ColorTheme current buttonLabel) lock		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (18 @ 2 corner: 0 @ 0)).	(self isKindOf: VersionsBrowser)		ifTrue: [ outerButton setBalloonText: 'Show pretty-printed code differences from the previous version, word by word.' ]		ifFalse: [ outerButton setBalloonText: 'Show pretty-printed code differences between the file-based method and the in-memory version, word by word.' ].	^ outerButton.! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!shouldDiffWords	"Answer whether the receiver is currently set to use the word based differ"	^ #(wordDiffs prettyWordDiffs) includes: contentsSymbol! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showDiffs: aBoolean	"Set whether I'm showing diffs as indicated; use the global preference to determine which kind of diffs to institute."	self showingAnyKindOfDiffs		ifFalse: [			aBoolean ifTrue: [				self contentsSymbol: self defaultDiffsSymbol]]		ifTrue: [			aBoolean ifFalse: [				self contentsSymbol: #source]]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showLineDiffs: aBoolean	"Set whether I'm showing regular diffs as indicated"	self showingLineDiffs		ifFalse: [			aBoolean ifTrue: [				self contentsSymbol: #lineDiffs]]		ifTrue: [			aBoolean ifFalse: [				self contentsSymbol: #source]]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showPrettyLineDiffs: aBoolean	"Set whether I'm showing pretty diffs as indicated"	self showingPrettyLineDiffs		ifFalse: [			aBoolean ifTrue: [				self contentsSymbol: #prettyLineDiffs]]		ifTrue: [			aBoolean ifFalse: [				self contentsSymbol: #source]]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showPrettyWordDiffs: aBoolean	"Set whether I'm showing pretty diffs as indicated"	self showingPrettyWordDiffs		ifFalse: [			aBoolean ifTrue: [				self contentsSymbol: #prettyWordDiffs]]		ifTrue: [			aBoolean ifFalse: [				self contentsSymbol: #source]]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showWordDiffs: aBoolean	"Set whether I'm showing regular diffs as indicated"	self showingWordDiffs		ifFalse: [			aBoolean ifTrue: [				self contentsSymbol: #wordDiffs]]		ifTrue: [			aBoolean ifFalse: [				self contentsSymbol: #source]]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showingAnyKindOfDiffs	"Answer whether the receiver is currently set to show any kind of diffs"	^ #(lineDiffs prettyLineDiffs wordDiffs prettyWordDiffs) includes: contentsSymbol! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showingAnyKindOfPrettyDiffs	"Answer whether the receiver is currently set to show any kind of pretty diffs"	^ #(prettyLineDiffs prettyWordDiffs) includes: contentsSymbol! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showingLineDiffs	"Answer whether the receiver is showing regular diffs of source code"	^ contentsSymbol == #lineDiffs! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showingLineDiffsString	"Answer a string representing whether I'm showing regular diffs"	^ (self showingLineDiffs		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'lineDiffs'! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showingPrettyLineDiffs	"Answer whether the receiver is showing pretty diffs of source code"	^ contentsSymbol == #prettyLineDiffs! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showingPrettyLineDiffsString	"Answer a string representing whether I'm showing pretty diffs"	^ (self showingPrettyLineDiffs		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'linePrettyDiffs'! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showingPrettyWordDiffs	"Answer whether the receiver is showing pretty diffs of source code"	^ contentsSymbol == #prettyWordDiffs! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showingPrettyWordDiffsString	"Answer a string representing whether I'm showing pretty diffs"	^ (self showingPrettyWordDiffs		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'wordPrettyDiffs'! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showingWordDiffs	"Answer whether the receiver is showing regular diffs (alternative algorithm) of source code"	^ contentsSymbol == #wordDiffs! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!showingWordDiffsString	"Answer a string representing whether I'm showing regular diffs"	^ (self showingWordDiffs		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'wordDiffs'! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!toggleDiffing	"Toggle whether diffs should be shown in the code pane.  If any kind of diffs were being shown, stop showing diffs.  If no kind of diffs were being shown, start showing whatever kind of diffs are called for by default."	self okToChange ifTrue: [		self showDiffs: self showingAnyKindOfDiffs not ]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!toggleLineDiffing	"Toggle whether regular-diffing should be shown in the code pane"	self okToChange ifTrue: [		self showLineDiffs: self showingLineDiffs not ]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!togglePlainSource	"Toggle whether plain source shown in the code pane"	self okToChange ifTrue: [		self showingPlainSource			ifTrue: [				self contentsSymbol: #documentation]			ifFalse: [				self contentsSymbol: #source]]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!togglePrettyLineDiffing	"Toggle whether pretty-diffing should be shown in the code pane"	self okToChange ifTrue: [		self showPrettyLineDiffs: self showingPrettyLineDiffs not ]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!togglePrettyPrint	"Toggle whether pretty-print is in effectin the code pane"	self okToChange ifTrue: [		self showingPrettyPrint			ifTrue: [				self contentsSymbol: #source]			ifFalse: [				self contentsSymbol: #prettyPrint]]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!togglePrettyWordDiffing	"Toggle whether pretty-diffing should be shown in the code pane"	self okToChange ifTrue: [		self showPrettyWordDiffs: self showingPrettyWordDiffs not ]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!toggleWordDiffing	"Toggle whether regular-diffing should be shown in the code pane"	self okToChange ifTrue: [		self showWordDiffs: self showingWordDiffs not ]! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!wantsDiffFeedback	"Answer whether the receiver is showing diffs of source code"	^ self showingAnyKindOfDiffs! !!CodeProvider methodsFor: 'diffs' stamp: 'jmv 11/25/2010 11:36'!wordDiffButton	"Return a checkbox that lets the user decide whether regular diffs should be shown or not"	| outerButton button |	outerButton _ AlignmentMorph proportional.	outerButton		 borderWidth: 2;		 borderColor: #raised.	outerButton color: Color transparent.	button _ UpdatingThreePhaseButtonMorph checkBox.	button		 target: self;		 actionSelector: #toggleWordDiffing;		 getSelector: #showingWordDiffs.	outerButton		addMorph: button		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 0 @ 1)				offsets: (2 @ 3 corner: 18 @ 0));		addMorph: (StringMorph contents: 'wordDiffs' color: ColorTheme current buttonLabel) lock		fullFrame:			(LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (18 @ 2 corner: 0 @ 0)).	outerButton setBalloonText: 'Show code differences (better algorithm) from the previous version.'.	^ outerButton.! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!addLowerPanesTo: window at: nominalFractions with: editString	| verticalOffset column innerFractions |	column _ AlignmentMorph proportional.	verticalOffset _ 0.	innerFractions _ 0@0 corner: 1@0.	verticalOffset _ self addOptionalAnnotationsTo: column at: innerFractions plus: verticalOffset.	verticalOffset _ self addOptionalButtonsTo: column  at: innerFractions plus: verticalOffset.	column 		addMorph: ((self buildMorphicCodePaneWith: editString) borderWidth: 0)		fullFrame: (			LayoutFrame 				fractions: (innerFractions withBottom: 1) 				offsets: (0@verticalOffset corner: 0@0)		).	window 		addMorph: column		frame: nominalFractions.	column on: #mouseEnter send: #paneTransition: to: window.	column on: #mouseLeave send: #paneTransition: to: window.	^column! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!getSelectorAndSendQuery: querySelector to: queryPerformer	"Obtain a selector relevant to the current context, and then send the querySelector to the queryPerformer with the selector obtained as its argument.  If no message is currently selected, then obtain a method name from a user type-in"	self getSelectorAndSendQuery: querySelector to: queryPerformer with: { }.! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!getSelectorAndSendQuery: querySelector to: queryPerformer with: queryArgs	"Obtain a selector relevant to the current context, and then send the querySelector to the queryPerformer with the selector obtained and queryArgs as its arguments.  If no message is currently selected, then obtain a method name from a user type-in"	| strm array |	strm _ WriteStream on: (array _ Array new: queryArgs size + 1).	strm nextPut: nil.	strm nextPutAll: queryArgs.	self selectedMessageName ifNil: [ | selector |		selector _ FillInTheBlank request: 'Type selector:' initialAnswer: 'flag:'.		^ selector isEmptyOrNil ifFalse: [			(Symbol hasInterned: selector				ifTrue: [ :aSymbol |					array at: 1 put: aSymbol.					queryPerformer perform: querySelector withArguments: array])				ifFalse: [ self inform: 'no such selector']		]	].	self selectMessageAndEvaluate: [:selector |		array at: 1 put: selector.		queryPerformer perform: querySelector withArguments: array	]! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!isThereAnOverride	"Answer whether any subclass of my selected class implements my 	selected selector"	| aName aClass |	aName := self selectedMessageName				ifNil: [^ false].	aClass := self selectedClassOrMetaClass ifNil: [ ^ false ].	aClass allSubclassesDo: [ :cls | (cls includesSelector: aName) ifTrue: [ ^true ]].	^ false! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!isThisAnOverride	"Answer whether any superclass of my selected class implements my selected selector"	| aName aClass |	aName _ self selectedMessageName ifNil: [^ false].	aClass _ self selectedClassOrMetaClass ifNil: [^false ].	aClass allSuperclassesDo: [ :cls | (cls includesSelector: aName) ifTrue: [ ^true ]].	^ false! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!modelWakeUp	"A window with me as model is being entered or expanded.  Default response is no-op" ! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!modelWakeUpIn: aWindow	"The window has been activated.  Respond to possible changes that may have taken place while it was inactive"	self updateListsAndCodeIn: aWindow.	self decorateButtons.	self refreshAnnotation.	super modelWakeUpIn: aWindow! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!okayToAccept	"Answer whether it is okay to accept the receiver's input"	self showingDocumentation ifTrue:		[self inform: 'Sorry, for the moment you canonly submit changes here whenyou are showing source.  Later, youwill be able to edit the isolated commenthere and save it back, but only if YOUimplement it!!.'.		^ false].	self showingAnyKindOfDiffs ifFalse:		[^ true]. 	^ SelectionMenu confirm: 'Caution!!  You are "showing diffs" here, so there is a danger that some of the text in thecode pane is contaminated by the "diff" display'	trueChoice: 'accept anyway -- I''ll take my chances' falseChoice: 'um, let me reconsider'! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!priorSourceOrNil	"If the currently-selected method has a previous version, return its source, else return nil"	| aClass aSelector  changeRecords |	(aClass _ self selectedClassOrMetaClass) ifNil: [^ nil].	(aSelector _ self selectedMessageName) ifNil: [^ nil].	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [^ nil].	^ (changeRecords at: 2) string ! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!refreshAnnotation	"If the receiver has an annotation pane that does not bear unaccepted edits, refresh it"	(self dependents		detect: [ :m | 			(m is: #HasTextSelector) and: [				m getTextSelector == #annotation]]		ifNone: nil)					ifNotNil: [ :aPane | 				aPane hasUnacceptedEdits ifFalse: [					aPane update: #annotation]]! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!refusesToAcceptCode	"Answer whether receiver, given its current contentsSymbol, could accept code happily if asked to"	^ (#(byteCodes documentation) includes: self contentsSymbol)! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!releaseCachedState	"Can always be found again.  Don't write on a file."	currentCompiledMethod _ nil.! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!sampleInstanceOfSelectedClass	| aClass |	"Return a sample instance of the class currently being pointed at"	(aClass _ self selectedClassOrMetaClass) ifNil: [^ nil].	^ aClass theNonMetaClass initializedInstance! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!sendQuery: querySelector to: queryPerformer	"Apply a query to the primary selector associated with the current context.  If no such selection exists, obtain one by user type-in. Then send querySelector to queryPerformer with the selector as its argument."	| aSelector aString |	aSelector _ self selectedMessageName ifNil:		[aString _FillInTheBlank request: 'Type selector:' initialAnswer: 'flag:'.		^ aString isEmptyOrNil ifFalse:			[(Symbol hasInterned: aString ifTrue:				[:aSymbol | queryPerformer perform: querySelector with: aSymbol])				ifFalse:					[self inform: 'no such selector']]].	queryPerformer perform: querySelector with: aSelector! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!setClassAndSelectorIn: csBlock	"Evaluate csBlock with my selected class and and selector as its arguments; provide nil arguments if I don't have a method currently selected"	self selectedMessageName		ifNil: [			csBlock value: nil value: nil]		ifNotNil: [ :n |			csBlock value: self selectedClassOrMetaClass value: n]! !!CodeProvider methodsFor: 'misc' stamp: 'jmv 11/25/2010 11:36'!useSelector: incomingSelector orGetSelectorAndSendQuery: querySelector to: queryPerformer	"If incomingSelector is not nil, use it, else obtain a selector from user type-in.   Using the determined selector, send the query to the performer provided."	| aSelector |	incomingSelector		ifNotNil:			[queryPerformer perform: querySelector with: incomingSelector]		ifNil:			[aSelector _FillInTheBlank request: 'Type selector:' initialAnswer: 'flag:'.			aSelector isEmptyOrNil ifFalse:				[(Symbol hasInterned: aSelector ifTrue:					[:aSymbol | queryPerformer perform: querySelector with: aSymbol])					ifFalse:						[self inform: 'no such selector']]]! !!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 11/25/2010 11:36'!didCodeChangeElsewhere	"Determine whether the code for the currently selected method and class has been changed somewhere else."	| aClass aSelector aCompiledMethod |	currentCompiledMethod ifNil: [^ false].	(aClass _ self selectedClassOrMetaClass) ifNil: [^ false].	(aSelector _ self selectedMessageName) ifNil: [^ false].	aSelector == #Comment ifTrue:		[^ currentCompiledMethod ~~ aClass organization commentRemoteStr].	^ ((aCompiledMethod _ aClass compiledMethodAt: aSelector ifAbsent: [^ false]) ~~ currentCompiledMethod)		and: [aCompiledMethod last ~= 0 "either not yet installed"				or: [currentCompiledMethod last = 0 "or these methods don't have source pointers"]]	! !!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 11/25/2010 11:36'!stepIn: aSystemWindow	self updateListsAndCodeIn: aSystemWindow! !!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 11/25/2010 11:36'!updateCodePaneIfNeeded	"If the code for the currently selected method has changed underneath me, then update the contents of my code pane unless it holds unaccepted edits"	self didCodeChangeElsewhere		ifTrue: [			self hasUnacceptedEdits				ifFalse: [					self setContentsToForceRefetch.					self acceptedContentsChanged]				ifTrue: [					self changed: #codeChangedElsewhere]]! !!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 11/25/2010 11:36'!updateListsAndCodeIn: aWindow	self canDiscardEdits ifTrue: [		aWindow updatablePanes do: [:aPane | aPane verifyContents]].	self updateCodePaneIfNeeded! !!CodeProvider methodsFor: 'self-updating' stamp: 'jmv 11/25/2010 11:36'!wantsStepsIn: aWindow	^ Preferences smartUpdating! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!addContentsTogglesTo: aMenu	"Add updating menu toggles governing contents to aMenu."	self contentsSymbolQuints do:		[:aQuint |			aQuint == #-				ifTrue:					[aMenu addLine]				ifFalse:					[aMenu addUpdating: aQuint third target: self action: aQuint second.					aMenu balloonTextForLastItem: aQuint fifth]]! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!addModelItemsToWindowMenu: aMenu	"Add model-related item to the window menu"	super addModelItemsToWindowMenu: aMenu. 	aMenu addLine.		aMenu add: 'what to show...' target: self action: #offerWhatToShowMenu! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!offerWhatToShowMenu	"Offer a menu governing what to show"	 | aMenu  |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addTitle: 'What to show'.	aMenu addStayUpIcons.	self addContentsTogglesTo: aMenu.	aMenu popUpInWorld ! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!prettyPrintString	"Answer whether the receiver is showing pretty-print"	^ ((contentsSymbol == #prettyPrint)		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'prettyPrint'! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!setContentsToForceRefetch	"Set the receiver's contents such that on the next update the contents will be formulated afresh.  This is a critical and obscure difference between Browsers on the one hand and MessageSets on the other, and has over the years been the source of much confusion and much difficulty.  By centralizing the different handling here, we don't need so many idiosyncratic overrides in MessageSet any more"	acceptedContentsCache _ nil! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showByteCodes: aBoolean	"Get into or out of bytecode-showoing mode"	self okToChange ifFalse: [^ self changed: #flash].	aBoolean		ifTrue: [			self contentsSymbol: #byteCodes]		ifFalse: [			contentsSymbol == #byteCodes ifTrue: [				self contentsSymbol: #source]]! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showComment	"Answer whether the receiver should show documentation rather than, say, source code"	^ self contentsSymbol == #documentation! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showDecompile: aBoolean	"Set the decompile toggle as indicated"	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#decompile])! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showDocumentation: aBoolean	"Set the showDocumentation toggle as indicated"	self contentsSymbol: (aBoolean ifFalse: [#source] ifTrue: [#documentation])! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showingByteCodes	"Answer whether the receiver is showing bytecodes"	^ contentsSymbol == #byteCodes! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showingByteCodesString	"Answer whether the receiver is showing bytecodes"	^ (self showingByteCodes		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'byteCodes'! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showingDecompile	"Answer whether the receiver should show decompile rather than, say, source code"	^ self contentsSymbol == #decompile! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showingDecompileString	"Answer a string characerizing whether decompilation is showing"	^ (self showingDecompile		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'decompile'! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showingDocumentation	"Answer whether the receiver should show documentation rather than, say, source code"	^ self contentsSymbol == #documentation! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showingDocumentationString	"Answer a string characerizing whether documentation is showing"	^ (self showingDocumentation		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'documentation'! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showingPlainSource	"Answer whether the receiver is showing plain source"	^ contentsSymbol == #source! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showingPlainSourceString	"Answer a string telling whether the receiver is showing plain source"	^ (self showingPlainSource		ifTrue:			['<yes>']		ifFalse:			['<no>']), 'source'! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showingPrettyPrint	"Answer whether the receiver is showing pretty-print"	^ contentsSymbol == #prettyPrint! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!showingSource	"Answer whether the receiver is currently showing source code"	^ self contentsSymbol == #source! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!toggleDecompile	"Toggle the setting of the showingDecompile flag, unless there are unsubmitted edits that the user declines to discard"	self okToChange ifTrue: [		self showDecompile: self showingDecompile not ]! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!toggleShowDocumentation	"Toggle the setting of the showingDocumentation flag, unless there are unsubmitted edits that the user declines to discard"	self okToChange ifTrue: [		self showDocumentation: self showingDocumentation not ]! !!CodeProvider methodsFor: 'what to show' stamp: 'jmv 11/25/2010 11:36'!toggleShowingByteCodes	"Toggle whether the receiver is showing bytecodes"	self showByteCodes: self showingByteCodes not! !!CodeProvider methodsFor: 'message list' stamp: 'jmv 11/25/2010 11:36'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			acceptedContentsCache _ (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [			tempNames := (class compilerClass new						parse: method getSourceFromFile asString						in: class						notifying: nil) tempNames.			acceptedContentsCache _ ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	acceptedContentsCache _ (acceptedContentsCache asText makeSelectorBoldIn: class).	^ acceptedContentsCache copy! !!CodeProvider methodsFor: 'message list' stamp: 'jmv 11/25/2010 11:36'!selectedBytecodes	"Answer text to show in a code pane when in showing-byte-codes mode"	^ (self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName ifAbsent: [^ '' asText]) symbolic asText! !!CodeProvider methodsFor: 'message list' stamp: 'jmv 11/25/2010 11:36'!selectedMessage	"Answer a copy of the source code for the selected message.  This generic version is probably actually never reached, since every subclass probably reimplements and does not send to super.  In time, ideally, most, or all, reimplementors would vanish and all would defer instead to a universal version right here.  Everything in good time."	| class selector method |	acceptedContentsCache ifNotNil: [ :c | ^ c copy].	self showingDecompile ifTrue: [		^ self decompiledSourceIntoContentsWithTempNames: false ].	class _ self selectedClassOrMetaClass.	(class isNil or: [(selector _ self selectedMessageName) isNil]) ifTrue: [^ ''].	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	^ acceptedContentsCache _((self showComment		ifFalse: [self sourceStringPrettifiedAndDiffed]		ifTrue:	[ self commentContents])			copy asText makeSelectorBoldIn: class)! !!CodeProvider methodsFor: 'message list' stamp: 'jmv 11/25/2010 11:36'!sourceStringPrettifiedAndDiffed	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"	| class selector sourceString |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	(class isNil or: [ selector isNil ]) ifTrue: [ ^ 'missing' ].	sourceString _ class		ultimateSourceCodeAt: selector		ifAbsent: [ ^ 'error' ].	self		validateMessageSource: sourceString		forSelector: selector		inClass: class.	(self showingPrettyPrint or: [ self showingAnyKindOfPrettyDiffs ]) ifTrue: [		sourceString _ class compilerClass new			format: sourceString			in: class			notifying: nil ].	self showingAnyKindOfDiffs ifTrue: [		sourceString _ self diffFromPriorSourceFor: sourceString ].	^ sourceString! !!CodeProvider methodsFor: 'message list' stamp: 'jmv 11/25/2010 11:36'!validateMessageSource: sourceString forSelector: aSelector inClass: theClass	"Check whether there is evidence that method source is invalid"	(theClass parserClass new parseSelector: sourceString asString) = aSelector		ifFalse: [			self inform: 'There may be a problem with your sources file!!The source code for every method should (usually) start with themethod selector but this is not the case with this method!! You mayproceed with caution but it is recommended that you get a new source file.'].! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseAllMessages	"Create and schedule a message set browser on all implementors of all the messages sent by the current method."	| aClass aName method filteredList |	(aName _ self selectedMessageName) ifNotNil: [		method _ (aClass _ self selectedClassOrMetaClass) compiledMethodAt: aName.		filteredList _ method messages reject: 			[:each | #(new initialize = ) includes: each].		Smalltalk browseAllImplementorsOfList: filteredList asArray sort			 title: 'All messages sent in ', aClass name, '.', aName]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseClass	"Open an class browser on this class and method"	self selectedClassOrMetaClass ifNotNil: [		Browser newOnClass: self selectedClassOrMetaClass 			selector: self selectedMessageName]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseClassRefs	| cls |	(cls _ self selectedClass) ifNotNil: [		Smalltalk browseAllCallsOnClass: cls theNonMetaClass]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseClassVarRefs	"1/17/96 sw: devolve responsibility to the class, so that the code that does the real work can be shared"	| cls |	cls _ self selectedClass.	cls ifNotNil: [cls browseClassVarRefs]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseClassVariables	"Browse the class variables of the selected class. 2/5/96 sw"	| cls |	cls _ self selectedClass.	cls		ifNotNil: [cls classPool inspectWithLabel: 'Class Variables in ', cls name]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.    If in mvc, an old-style protocol browser is opened instead.  Someone who still uses mvc might wish to make the protocol-category-browser work there too, thanks."	^ self spawnFullProtocol! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseInstVarDefs 	| cls |	(cls _ self selectedClassOrMetaClass) ifNotNil: [Smalltalk browseInstVarDefs: cls]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseInstVarRefs	"1/26/96 sw: real work moved to class, so it can be shared"	| cls |	cls _ self selectedClassOrMetaClass.	cls		ifNotNil: [Smalltalk browseInstVarRefs: cls]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseLocalImplementors	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:localTo:		to: Smalltalk		with: { self selectedClass }! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseLocalSendersOfMessages	"Present a menu of the currently selected message, as well as all	messages sent by it.  Open a message set browser of all implementors	of the message chosen in or below the selected class"	self getSelectorAndSendQuery: #browseAllCallsOn:localTo:		to: Smalltalk		with: { self selectedClass }! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseMessages	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseMethodFull	"Create and schedule a full Browser and then select the current class and message."	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[Browser fullOnClass: myClass selector: self selectedMessageName]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all senders of the selector chosen."	self getSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseUnusedMethods	| classes unsent messageList cls |	(cls _ self selectedClass) ifNil: [^ self].	classes _ Array with: cls with: cls class.	unsent _ Set new.	classes do: [:c | unsent addAll: c selectors].	unsent _ Smalltalk allUnSentMessagesIn: unsent.	messageList _ OrderedCollection new.	classes do: [:c | (c selectors select: [:s | unsent includes: s]) asArray sort					do: [:sel | messageList add: c name , ' ' , sel]].	Smalltalk browseMessageList: messageList name: 'Unsent Methods in ', cls name! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!browseVersions	"Create and schedule a Versions Browser, showing all versions of the 	currently selected message. Answer the browser or nil."	| selector class | 	(selector _ self selectedMessageName)		ifNil:[ self inform: 'Sorry, only actual methods have retrievable versions.'. ^nil ]		ifNotNil: [(MessageSet isPseudoSelector: selector)				ifTrue: ["Eliminates Definition and Hierarchy"					^ self classCommentIndicated						ifTrue: [ ClassCommentVersionsBrowser browseCommentOf: self selectedClass. nil ]].			class _ self selectedClassOrMetaClass.			^VersionsBrowser				browseVersionsOf: (class compiledMethodAt: selector)				class: self selectedClass				meta: class isMeta				category: (class organization categoryOfElement: selector)				selector: selector]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!classHierarchy	"Create and schedule a class list browser on the receiver's hierarchy."	Utilities spawnHierarchyForClass: self selectedClassOrMetaClass "OK if nil"		selector: self selectedMessageName! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!classListKey: aChar from: view 	"Respond to a Command key.  I am a model with a list of classes and a 	code pane, and I also have a listView that has a list of methods.  The 	view knows how to get the list and selection."	aChar == $f ifTrue: [^ self findMethod].	aChar == $r ifTrue: [^ self recent].	aChar == $h ifTrue: [^ self spawnHierarchy].	aChar == $x ifTrue: [^ self removeClass].	^ self messageListKey: aChar from: view! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!copyName	"Copy the current selector to the clipboard"	| selector |	(selector _ self selectedMessageName) ifNotNil:		[Clipboard clipboardText: selector asString ]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!copySelector	"Copy the selected selector to the clipboard"	| selector |	(selector _ self selectedMessageName) ifNotNil:		[Clipboard clipboardText: selector asString]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!fileOutMessage	"Put a description of the selected message on a file"	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName]]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!findMethodInChangeSets	"Find and open a changeSet containing the current method."	| aName |	(aName _ self selectedMessageName) ifNotNil: [		ChangeSorter browseChangeSetsWithClass: self selectedClassOrMetaClass					selector: aName]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!inspectInstances	"Inspect all instances of the selected class."	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[myClass theNonMetaClass inspectAllInstances]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!inspectSubInstances	"Inspect all instances of the selected class and all its subclasses"	| aClass |	(aClass _ self selectedClassOrMetaClass) ifNotNil: [		aClass theNonMetaClass inspectSubInstances]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also	have a listView that has a list of methods.  The view knows how to get	the list and selection."	| sel class |	aChar == $D ifTrue: [^ self toggleDiffing].	sel _ self selectedMessageName.	aChar == $m ifTrue:  "These next two put up a type in if no message selected"		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk].	aChar == $n ifTrue: 		[^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk].	"The following require a class selection"	(class _ self selectedClassOrMetaClass) ifNil: [^ self arrowKey: aChar from: view].	aChar == $b ifTrue: [^ Browser fullOnClass: class selector: sel].	aChar == $N ifTrue: [^ self browseClassRefs].	aChar == $i ifTrue: [^ self methodHierarchy].	aChar == $h ifTrue: [^ self classHierarchy].	aChar == $p ifTrue: [^ self browseFullProtocol].	"The following require a method selection"	sel ifNotNil: 		[aChar == $o ifTrue: [^ self fileOutMessage].		aChar == $c ifTrue: [^ self copySelector].		aChar == $v ifTrue: [^ self browseVersions].		aChar == $O ifTrue: [^ self openSingleMessageBrowser].		aChar == $x ifTrue: [^ self removeMessage]].	^ self arrowKey: aChar from: view! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!messageListSelectorTitle	| aSize |	^(self selectedMessageName)		ifNil:[			aSize _ self messageList size.			(aSize = 0 ifTrue: ['no'] ifFalse: [aSize printString]), ' message', (aSize = 1 ifTrue: [''] ifFalse: ['s'])]		ifNotNil:			[nil]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!methodHierarchy	"Create and schedule a method browser on the hierarchy of implementors."	Utilities methodHierarchyBrowserForClass: self selectedClassOrMetaClass 			selector: self selectedMessageName! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!openSingleMessageBrowser	| msgName mr |	"Create and schedule a message list browser populated only by the currently selected message"	(msgName _ self selectedMessageName) ifNil: [^ self].	mr _ MethodReference new		setStandardClass: self selectedClassOrMetaClass		methodSymbol: msgName.	Smalltalk 		browseMessageList: (Array with: mr)		name: mr asStringOrText		autoSelect: nil! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!packageListKey: aChar from: view	"Respond to a Command key in the package pane in the PackageBrowser"	aChar == $f ifTrue: [^ self findClass].	^ self classListKey: aChar from: view! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	ChangeSet current removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.	self changed: #annotation! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self acceptedContentsChanged! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [self changed: #flash.  ^ Beeper beep].	changeRecords second fileIn.	self acceptedContentsChanged! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!selectMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selector method messages |	(selector _ self selectedMessageName) ifNil: [^ self].	method _ (self selectedClassOrMetaClass ifNil: [^ self])		compiledMethodAt: selector		ifAbsent: nil.	(method isNil or: [(messages _ method messages) size = 0])		 ifTrue: [^ aBlock value: selector].	(messages size = 1 and: [messages includes: selector])		ifTrue:			[^ aBlock value: selector].  "If only one item, there is no choice"	Smalltalk		showMenuOf: messages		withFirstItem: selector		ifChosenDo: [:sel | aBlock value: sel]! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!systemCatListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."	aChar == $f ifTrue: [^ self findClass].	aChar == $x ifTrue: [^ self removeSystemCategory].	^ self classListKey: aChar from: view! !!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 11/25/2010 11:36'!timeStamp	"Answer the time stamp for the chosen class and method, if any, else an empty string"	|  selector  aMethod |	(selector _ self selectedMessageName) ifNotNil: [		self selectedClassOrMetaClass 			ifNil: [				^ String new]			ifNotNil: [				aMethod _ self selectedClassOrMetaClass compiledMethodAt: selector ifAbsent: nil.				aMethod ifNotNil: [^ Utilities timeStampForMethod: aMethod]]].	^ String new! !!CodeProvider methodsFor: 'message category functions' stamp: 'jmv 11/25/2010 11:36'!canShowMultipleMessageCategories	"Answer whether the receiver is capable of showing multiple message categories"	^ false! !!CodeProvider methodsFor: 'testing' stamp: 'jmv 11/25/2010 12:16'!is: aSymbol	^ aSymbol = #CodeProvider or: [ super is: aSymbol ]! !!CodeProvider methodsFor: 'code pane menu' stamp: 'jmv 11/25/2010 11:36'!editorClass	^SmalltalkEditor! !!CodeProvider methodsFor: '*Shout-Styling' stamp: 'jmv 11/25/2010 11:36'!isModeStyleable	"determine if Shout can style in the current mode"	^ self showingSource or: [self showingPrettyPrint]! !!CodeProvider methodsFor: '*Shout-Styling' stamp: 'jmv 11/25/2010 11:36'!shoutAboutToStyle: aSHTextStyler	"This is a notification that aSHTextStyler is about to re-style its text.	Answer false if showing difs, to veto the styling."		^self showingAnyKindOfDiffs not! !!CodeProvider methodsFor: 'accessing' stamp: 'jmv 11/25/2010 11:52'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^ 1 to: 0  "null selection"! !!CodeProvider methodsFor: 'accessing' stamp: 'jmv 11/25/2010 11:36'!selectedClass	^ nil! !!CodeProvider methodsFor: 'accessing' stamp: 'jmv 11/25/2010 11:36'!selectedClassOrMetaClass	^ self selectedClass	"I don't know any better"! !!CodeProvider methodsFor: 'accessing' stamp: 'jmv 11/25/2010 11:36'!selectedMessageName	^ nil! !!CodeProvider methodsFor: 'optional panes' stamp: 'jmv 11/25/2010 11:36'!wantsAnnotationPane	"Answer whether the receiver, seen in some browser window, would like to have the so-called  annotationpane included.  By default, various browsers defer to the global preference 'optionalButtons' -- but individual subclasses can insist to the contrary."	^ Preferences annotationPanes! !!CodeProvider methodsFor: 'optional panes' stamp: 'jmv 11/25/2010 11:36'!wantsOptionalButtons	"Answer whether the receiver, seen in some browser window, would like to have the so-called optional button pane included.  By default, various browsers defer to the global preference 'optionalButtons' -- but individual subclasses can insist to the contrary."	^ Preferences optionalButtons! !!CodeProvider methodsFor: 'evaluation' stamp: 'jmv 11/25/2010 11:36'!doItContext	"Answer the context in which a text selection can be evaluated."	^nil! !!CodeProvider methodsFor: 'user edits' stamp: 'jmv 11/25/2010 11:50'!clearUserEditFlag	"Clear the hasUnacceptedEdits flag in all my dependent views."	self changed: #clearUserEdits! !!CodeProvider methodsFor: 'user edits' stamp: 'jmv 11/25/2010 11:56'!okToChange	self canDiscardEdits ifTrue: [^ true].	self changed: #wantToChange.  "Solicit cancel from view"	^ self canDiscardEdits! !!CodeProvider methodsFor: 'services' stamp: 'jmv 11/25/2010 11:54'!offerMenuFrom: menuRetriever shifted: aBoolean 	"Pop up, in morphic or mvc as the case may be, a menu whose target is the receiver and whose contents are provided by sending the menuRetriever to the receiver.  The menuRetriever takes two arguments: a menu, and a boolean representing the shift state."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.			self 				perform: menuRetriever				with: aMenu				with: aBoolean.			aMenu popUpInWorld! !!CodeProvider methodsFor: 'services' stamp: 'jmv 11/25/2010 12:13'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!Browser methodsFor: 'class functions' stamp: 'jmv 11/25/2010 11:49'!defineClass: defString notifying: aController  	"The receiver's textual content is a request to define a new class. The	source code is defString. If any errors occur in compilation, notify	aController."	| oldClass class newClassName defTokens keywdIx envt |	oldClass _ self selectedClassOrMetaClass.	defTokens _ defString findTokens: Character separators.	keywdIx _ defTokens findFirst: [:x | x beginsWith: 'category'].	envt _ Smalltalk environmentForCategory: ((defTokens at: keywdIx+1) copyWithout: $').	keywdIx _ defTokens findFirst: [:x | '*subclass*' match: x].	newClassName _ (defTokens at: keywdIx+1) copyWithoutAll: '#()'.	((oldClass isNil or: [oldClass theNonMetaClass name asString ~= newClassName])		and: [envt includesKeyOrAbove: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	"ar 8/29/1999: Use oldClass superclass for defining oldClass	since oldClass superclass knows the definerClass of oldClass."	oldClass ifNotNil:[oldClass _ oldClass superclass].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: [self changed: #systemCategoryList.				self changed: #classList.				self changed: #clearUserEdits.				self setClass: class selector: nil.				"self clearUserEditFlag; editClass."				^ true]		ifFalse: [^ false]! !!Browser methodsFor: 'message category functions' stamp: 'jmv 11/25/2010 11:49'!alphabetizeMessageCategories	classListIndex = 0 ifTrue: [^ false].	self okToChange ifFalse: [^ false].	self classOrMetaClassOrganizer sortCategories.	self changed: #clearUserEdits.	self editClass.	self classListIndex: classListIndex.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'jmv 11/25/2010 11:49'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	self classOrMetaClassOrganizer changeFromString: aString.	self changed: #clearUserEdits.	self editClass.	self classListIndex: classListIndex.	^ true! !!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 11/25/2010 11:49'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self changed: #clearUserEdits.	currentClassName ifNil: [^ acceptedContentsCache _ (myChangeSet preambleString ifNil: [''])].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector)		ifNotNil: [			changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ acceptedContentsCache _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ acceptedContentsCache _ 'Added then removed (see versions)'].			class ifNil: [^ acceptedContentsCache _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ acceptedContentsCache _ 'Method was added, but cannot be found!!'].			acceptedContentsCache _  (class sourceCodeAt: sel).			(#(prettyPrint prettyLineDiffs prettyWordDiffs) includes: contentsSymbol) ifTrue: [				acceptedContentsCache _ (class compilerClass new						format: acceptedContentsCache						in: class 						notifying: nil)].			self showingAnyKindOfDiffs				ifTrue: [ acceptedContentsCache _ (self diffFromPriorSourceFor: acceptedContentsCache) ].			^ acceptedContentsCache _ (acceptedContentsCache asText makeSelectorBoldIn: class) ]		ifNil: [			strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ acceptedContentsCache _ strm contents].! !!FileList methodsFor: 'initialization' stamp: 'jmv 11/25/2010 12:33'!initialize	super initialize.	acceptedContentsCache _ self defaultContents! !!FileList methodsFor: 'contents' stamp: 'jmv 11/25/2010 12:31'!acceptedContents	^ Text		initialFont: Preferences standardCodeFont		stringOrText: self acceptedStringOrText! !!FileList methodsFor: 'contents' stamp: 'jmv 11/25/2010 12:32'!acceptedContentsChanged	self changed: #acceptedContents! !!FileList methodsFor: 'services' stamp: 'jmv 11/25/2010 11:54'!offerMenuFrom: menuRetriever shifted: aBoolean 	"Pop up, in morphic or mvc as the case may be, a menu whose target is the receiver and whose contents are provided by sending the menuRetriever to the receiver.  The menuRetriever takes two arguments: a menu, and a boolean representing the shift state."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.			self 				perform: menuRetriever				with: aMenu				with: aBoolean.			aMenu popUpInWorld! !!FileList methodsFor: 'accessing' stamp: 'jmv 11/25/2010 11:52'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^ 1 to: 0  "null selection"! !!FileList methodsFor: 'code pane menu' stamp: 'jmv 11/25/2010 12:13'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!FileList methodsFor: 'user edits' stamp: 'jmv 11/25/2010 11:52'!clearUserEditFlag	"Clear the hasUnacceptedEdits flag in all my dependent views."	self changed: #clearUserEdits! !!FileList methodsFor: 'user edits' stamp: 'jmv 11/25/2010 11:56'!okToChange	self canDiscardEdits ifTrue: [^ true].	self changed: #wantToChange.  "Solicit cancel from view"	^ self canDiscardEdits! !!Inspector methodsFor: 'accessing' stamp: 'jmv 11/25/2010 11:53'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^ 1 to: 0  "null selection"! !!Inspector methodsFor: 'code pane menu' stamp: 'jmv 11/25/2010 12:13'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!Inspector methodsFor: 'initialize-release' stamp: 'jmv 11/25/2010 12:33'!initialize	super initialize.	acceptedContentsCache _ ''.	selectionIndex := 0! !!Inspector methodsFor: 'contents' stamp: 'jmv 11/25/2010 12:32'!acceptedContents	^ Text		initialFont: Preferences standardCodeFont		stringOrText: self acceptedStringOrText! !!Inspector methodsFor: 'contents' stamp: 'jmv 11/25/2010 12:32'!acceptedContentsChanged	self changed: #acceptedContents! !!Inspector methodsFor: 'user edits' stamp: 'jmv 11/25/2010 11:51'!clearUserEditFlag	"Clear the hasUnacceptedEdits flag in all my dependent views."	self changed: #clearUserEdits! !!Inspector methodsFor: 'user edits' stamp: 'jmv 11/25/2010 11:56'!okToChange	self canDiscardEdits ifTrue: [^ true].	self changed: #wantToChange.  "Solicit cancel from view"	^ self canDiscardEdits! !!MessageSet methodsFor: 'private' stamp: 'jmv 11/25/2010 11:50'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	self okayToAccept ifFalse: [^ false].	self setClassAndSelectorIn: [:c :os | class _ c.  oldSelector _ os].	class ifNil: [^ false].	(oldSelector notNil and: [oldSelector first isUppercase]) ifTrue:		[oldSelector = #Comment ifTrue:			[class comment: aString stamp: Utilities changeStamp.			self changed: #annotation. 			self changed: #clearUserEdits.			^ false].		oldSelector = #Definition ifTrue:			["self defineClass: aString notifying: aController."			class subclassDefinerClass				evaluate: aString				notifying: aController				logged: true.			self changed: #clearUserEdits. 			^ false].		oldSelector = #Hierarchy ifTrue:			[self inform: 'To change the hierarchy, edit the class definitions'. 			^ false]].	"Normal method accept"	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector		ifNil: [^ false].	selector == oldSelector ifFalse: [		self reformulateListNoting: selector].	acceptedContentsCache _ aString copy.	self changed: #annotation.	^ true! !!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 11/25/2010 12:20'!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration	"Create a spy and spy on the given process at the specified rate."	| myDelay time0 endTime observedProcess sem |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	observedProcess _ aProcess.	myDelay _ Delay forMilliseconds: millisecs.	time0 _ Time millisecondClockValue.	endTime _ time0 + msecDuration.	sem _ Semaphore new.	gcStats _ Smalltalk getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer _ [			[				| startTime |				startTime _ Time millisecondClockValue.				myDelay wait.				self					tally: Processor preemptedProcess suspendedContext					in: (observedProcess == Processor preemptedProcess ifTrue: [ observedProcess ] ifFalse: [nil])					"tally can be > 1 if ran a long primitive"					by: (Time millisecondClockValue - startTime) // millisecs.				startTime < endTime			] whileTrue.			sem signal.		] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	"activate the probe and wait for it to finish"	sem wait.	"Collect gc statistics"	Smalltalk getVMParameters keysAndValuesDo: [ :idx :gcVal |		gcVal ifNotNil: [			gcStats at: idx put: (gcVal - (gcStats at: idx))]].	time _ Time millisecondClockValue - time0! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 11/25/2010 12:18'!spyAllOn: aBlock	"Spy on all the processes in the system		[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]		"	| node result |	node _ self new.	node reportOtherProcesses: true.	"Irrelevant in this case. All processes will be reported on their own."	result _ node spyAllEvery: self defaultPollPeriod on: aBlock.	(TextHolder new actualContents: (String streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 11/25/2010 12:18'!spyOn: aBlock reportOtherProcesses: aBoolean	"	Spy on aBlock, in the current process. Can include or not statistics on other processes in the report.	[1000 timesRepeat: [		100 timesRepeat: [120 factorial].		(Delay forMilliseconds: 10) wait		]] forkAt: 45 named: '45'.	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]] reportOtherProcesses: true	"	| node result |	node _ self new.	node reportOtherProcesses: aBoolean.	result _ node spyEvery: self defaultPollPeriod on: aBlock.	(TextHolder new actualContents: (String streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 11/25/2010 12:21'!spyOnProcess: aProcess forMilliseconds: msecDuration reportOtherProcesses: aBoolean	"	Spy on aProcess for a certain amount of time	| p1 p2 |  	p1 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.  	p2 _ [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.	p1 resume.	p2 resume.  	(Delay forMilliseconds: 100) wait.  	MessageTally spyOnProcess: p1 forMilliseconds: 1000 reportOtherProcesses: true	"	| node |	node _ self new.	node reportOtherProcesses: aBoolean.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	(TextHolder new actualContents: (String				streamContents: [:s | node report: s]))		openLabel: 'Spy Results' wrap: false! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 11/25/2010 12:21'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"	MessageTally tallySends: [3.14159 printString]	"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime _ Time millisecondClockValue.	tallies _ MessageTally new class: aBlock receiver class method: aBlock method.	tallies reportOtherProcesses: true.	"Do NOT filter nodes with nil process"	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep: [ :current |			current == prev ifFalse: [ "call or return"				prev sender ifNotNil: [ "call only"					(receiver == nil or: [ current receiver == receiver ])						ifTrue: [ tallies tally: current by: 1 ]].				prev _ current]].	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	(TextHolder new actualContents:		(String streamContents: [ :s |			s nextPutAll: 'This simulation took ' , totalTime printString, ' seconds.'; cr.			treeOption				ifTrue: [ tallies fullPrintExactOn: s ]				ifFalse: [ tallies leavesPrintExactOn: s ]]))		openLabel: 'Spy Results' wrap: false! !!PluggableTextMorph methodsFor: 'drawing' stamp: 'jmv 11/25/2010 12:16'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		((model is: #CodeProvider) and: [model refusesToAcceptCode])			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						self hasUnacceptedEdits							ifTrue: [								model wantsDiffFeedback									ifTrue: [										bw _ 4.										bc _ Color green]									ifFalse: [										bc _ Color red]]							ifFalse: [								model wantsDiffFeedback									ifTrue: [										bc _ Color green]									ifFalse: []]]]].	(drawKeyboardFocusIndicator and: [ textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ ColorTheme current focusIndicator ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle width: bw color: bc ]! !!PluggableTextMorph methodsFor: 'drawing' stamp: 'jmv 11/25/2010 12:16'!wantsFrameAdornments	"Answer whether the receiver wishes to have red borders, etc., used to show editing state"	"A 'long-term temporary workaround': a nonmodular, unsavory, but expedient way to get the desired effect, sorry.  Clean up someday."	(model is: #CodeProvider) ifFalse: [^false].	^ (#(annotation searchString infoViewContents) includes: getTextSelector) not! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'jmv 11/25/2010 12:16'!accept	"Inform the model of text to be accepted, and return true if OK."	"sps 8/13/2001 22:41: save selection and scroll info"	| textToAccept ok saveSelection saveScrollerOffset |	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' 						translated) 					ifFalse: [^self flash]].	textToAccept := textMorph text.	ok := setTextSelector isNil or: [					setTextSelector numArgs = 2 						ifTrue: [							model 								perform: setTextSelector								with: textToAccept								with: self]						ifFalse: [ model perform: setTextSelector with: textToAccept]].	ok == true 		ifTrue: [			self setText: self getText.			self hasUnacceptedEdits: false.			(model dependents				detect: [ :dep | 					(dep isKindOf: PluggableTextMorph) 						and: [ dep getTextSelector == #annotation ]]				ifNone: nil) ifNotNil: [ :aPane | model changed: #annotation ]].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			"(don't bother if there was an error during compile)"			(model is: #CodeProvider) ifTrue: [model updateCodePaneIfNeeded].			"jmv - moved this outside the deferred message.			See 'Re: [squeak-dev] scrambled input fields'			from Gary Chambers on Nov 14, 2008."			self selectFrom: saveSelection first to: saveSelection last.			WorldState addDeferredUIMessage: [					self currentHand newKeyboardFocus: textMorph.					scroller offset: saveScrollerOffset.					self setScrollDeltas.					"self selectFrom: saveSelection first to: saveSelection last"]]] 			on: Error			do: nil! !!TextHolder methodsFor: 'pane menu' stamp: 'jmv 11/25/2010 12:37'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	^(self respondsTo: selector)		ifTrue: [ self perform: selector]		ifFalse: [ otherTarget perform: selector]! !!classDefinition: #Inspector category: #'Tools-Inspector'!Model subclass: #Inspector	instanceVariableNames: 'acceptedContentsCache object selectionIndex timeOfLastListUpdate selectionUpdateTime context'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Inspector'!!classDefinition: #FileList category: #'Tools-FileList'!Model subclass: #FileList	instanceVariableNames: 'acceptedContentsCache fileName directory volList volListIndex list listIndex pattern sortMode brevityState sortAscending'	classVariableNames: 'FileReaderRegistry RecentDirs'	poolDictionaries: ''	category: 'Tools-FileList'!!classDefinition: #Debugger category: #'Tools-Debugger'!CodeProvider subclass: #Debugger	instanceVariableNames: 'interruptedProcess contextStack contextStackTop contextStackIndex contextStackList receiverInspector contextVariablesInspector externalInterrupt proceedValue selectingPC savedCursor errorWasInUIProcess labelString'	classVariableNames: 'ContextStackKeystrokes ErrorRecursion'	poolDictionaries: ''	category: 'Tools-Debugger'!!classDefinition: #ChangeSorter category: #'Tools-Changes'!CodeProvider subclass: #ChangeSorter	instanceVariableNames: 'parent myChangeSet currentClassName currentSelector priorChangeSetList changeSetCategory'	classVariableNames: 'AllChangeSets ChangeSetCategories PreviousSet'	poolDictionaries: ''	category: 'Tools-Changes'!!classDefinition: #ChangeList category: #'Tools-Changes'!CodeProvider subclass: #ChangeList	instanceVariableNames: 'changeList list listIndex listSelections file lostMethodPointer'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Changes'!!classDefinition: #Browser category: #'Tools-Browser'!CodeProvider subclass: #Browser	instanceVariableNames: 'systemOrganizer classOrganizer metaClassOrganizer systemCategoryListIndex classListIndex messageCategoryListIndex messageListIndex editSelection metaClassIndicated'	classVariableNames: 'RecentClasses'	poolDictionaries: ''	category: 'Tools-Browser'!Smalltalk removeClassNamed: #AcceptingTextHolder!Smalltalk removeClassNamed: #CodeHolder!