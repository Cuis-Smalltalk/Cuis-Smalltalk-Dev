'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 31 October 2011 at 11:22:06 pm'!!classDefinition: #AutoCompleter category: #UCompletion!Object subclass: #AutoCompleter	instanceVariableNames: 'model textMorph menuMorph position entries prefix'	classVariableNames: ''	poolDictionaries: ''	category: 'UCompletion'!!AutoCompleter commentStamp: '<historical>' prior: 0!A TextMorph (instance of BareTextMorph) can have an autocompleter in the same way it might have a styler. My instances implement autocompletion.!!classDefinition: #AutoCompleterMorph category: #UCompletion!BorderedMorph subclass: #AutoCompleterMorph	instanceVariableNames: 'completer selected firstVisible itemHeight lastActivity'	classVariableNames: ''	poolDictionaries: ''	category: 'UCompletion'!!AutoCompleterMorph commentStamp: '<historical>' prior: 0!I show the possible completions in a menu like appearance. The user may choose an entry from my list and complete the word he was typing in the editor. I'm showed with the Tab key and will be deleted when with ESC key or when a successful completion occurs. The following keystrokes are supported:Ctrl-Space or Tab: Open a new morph. Tab requires at least one character in front of the cursor. When already open complete the selected entry. Esc: Close meArrow Up: Move one entry up.Arrow Down: Move one entry downEnter: (like Ctrl-Space and Tab): Complete with the selected item and close the morphany letter or digit: Narrow the completion further!!classDefinition: 'AutoCompleterMorph class' category: #UCompletion!AutoCompleterMorph class	instanceVariableNames: 'messageFont titleFont'!!classDefinition: #BareTextMorph category: #'Morphic-Text Support'!Morph subclass: #BareTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking editView acceptOnCR hasUnacceptedEdits askBeforeDiscardingEdits styler autoCompletter autoCompleter '	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!classDefinition: #SmalltalkCompleter category: #UCompletion!AutoCompleter subclass: #SmalltalkCompleter	instanceVariableNames: 'parser'	classVariableNames: 'AccessLock Selectors'	poolDictionaries: ''	category: 'UCompletion'!!SmalltalkCompleter commentStamp: 'jmv 7/14/2011 14:25' prior: 0!An autocompleter specialized in Smalltalk code!!classDefinition: #SmalltalkCompleterTest category: #UCompletion!TestCase subclass: #SmalltalkCompleterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'UCompletion'!!classDefinition: #Trie category: #'System-Text'!Collection subclass: #Trie	instanceVariableNames: 'rootNode'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!Trie commentStamp: 'jmv 6/22/2011 14:29' prior: 0!I am an efficient collection of Strings. I behave a bit like a Dictionary, with the restriction that keys are instances of String.Notes:	- check for inclusion is extremely fast	- iteration is always done in collation order, contents are always sorted without performance cost	- Behaves both like a Set (#add:, #remove:, #includes, #do) and a Dictionary (#at:put:, #at:, #at:ifAbsent:)	| t |t _ Trie new.t add: 'car'.t at: 'car' put: Float pi.t at: 'cat' put: Date today.t explore.(t includesKey: 'car') print.(t includes: 'cat') print| t | t _ Trie new.Smalltalk allImplementedMessages do: [ :s | t add: s ].t explore!!classDefinition: #TrieLeaf category: #'System-Text'!Object subclass: #TrieLeaf	instanceVariableNames: 'keys values'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!TrieLeaf commentStamp: 'jmv 6/22/2011 14:33' prior: 0!My instances hold the key/value pairs for Tries.!!classDefinition: #TrieNode category: #'System-Text'!Object subclass: #TrieNode	instanceVariableNames: 'childrenFirstChars children segmentSize someKey'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Text'!!TrieNode commentStamp: 'jmv 6/22/2011 14:32' prior: 0!My instances form a Trie. They do path compression, meaning that they can represent a segment of seveal characters long.!!classDefinition: #TrieTest category: #'System-Tests'!TestCase subclass: #TrieTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-Tests'!!AutoCompleter methodsFor: 'accessing' stamp: 'jmv 7/14/2011 13:58'!setModel: aTextModel	model _ aTextModel! !!AutoCompleter methodsFor: 'accessing' stamp: 'jmv 7/14/2011 13:58'!textMorph: aBareTextMorph	textMorph _ aBareTextMorph! !!AutoCompleter methodsFor: 'menu morph' stamp: 'jmv 7/14/2011 13:58'!closeMenu	menuMorph ifNotNil: [		menuMorph delete.		menuMorph _ nil ]! !!AutoCompleter methodsFor: 'menu morph' stamp: 'jmv 7/14/2011 13:58'!menuClosed	menuMorph _ nil! !!AutoCompleter methodsFor: 'menu morph' stamp: 'jmv 7/14/2011 14:11'!openCompletionMenu	| theEditor |	theEditor _ textMorph editor.	position _ theEditor startIndex - 1.	self closeMenu.	self computeEntries.	entries notEmpty		ifTrue: [ 			menuMorph _  AutoCompleterMorph 				completer: self				position: theEditor startBlock bottomLeft + textMorph positionInWorld ]! !!AutoCompleter methodsFor: 'keyboard' stamp: 'jmv 7/14/2011 13:58'!autoCompletionAround: aBlock keyStroke: evt	(self handleKeystrokeBefore: evt)		ifTrue: [^ self].	aBlock value.	"Narrow the completion with any of the keys"	self handleKeystrokeAfter: evt! !!AutoCompleter methodsFor: 'keyboard' stamp: 'jmv 7/14/2011 13:58'!handleKeystrokeAfter: aKeyboardEvent	| newPos |	menuMorph ifNil: [^self].	newPos _ textMorph editor startIndex-1.	newPos = position ifTrue: [^self].	newPos < position		ifTrue: [			prefix _ prefix copyFrom: 1 to: prefix size+(newPos-position).			position _ newPos ]		ifFalse: [			position _ position + 1.			prefix _ prefix copyWith: (model actualContents at: position) ].	self computeEntries.	entries notEmpty		ifTrue: [ menuMorph resetMenu ]		ifFalse: [ self closeMenu ]! !!AutoCompleter methodsFor: 'keyboard' stamp: 'jmv 9/20/2011 08:44'!handleKeystrokeBefore: kbEvent	"I return a boolean. true when I have handled the event and no futher processing is needed by the caller."	| currentPos currentCharIsAlphaNumeric keyValue ctrl cmd tab colon alphanum backspace esc space enter keyChar  |	currentPos _ textMorph editor startIndex-1.	currentCharIsAlphaNumeric _ currentPos > 0 and: [ model textSize >= currentPos and: [			(model actualContents at: currentPos) isAlphaNumeric ]].	keyValue _ kbEvent keyValue.	keyChar _ kbEvent keyCharacter.	ctrl _ kbEvent controlKeyPressed.	cmd _ kbEvent commandAltKeyPressed.	tab _ keyChar = Character tab.	colon _keyChar = $:.	alphanum _ kbEvent keyCharacter isAlphaNumeric.	backspace _ keyValue = 8.	esc _ keyValue = 27.	space _ #(0 32 160) includes: keyValue.	enter _ keyValue = 13.	"Stuff to do if the menu is not open"	menuMorph ifNil: [		"Ctrl-Space or Tab for open"		"Mac specific note: Using option-space (actually option+160) effectively disables the non-breaking space character 160"		(space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [			(self opensWithTab and: [tab]) and: [ currentCharIsAlphaNumeric ]])				ifTrue: [ self openCompletionMenu. ^ true].		"Auto-open - currently deactivated""		(ctrl not & cmd not & alphanum) 			ifTrue: [ self openCompletionMenu ]."		^ false].	"Starting here, stuff to do if the menu is open"	menuMorph stillActive.	"Escape"	esc ifTrue: [ self closeMenu. ^ true].	"Backspace"	backspace ifTrue: [		currentCharIsAlphaNumeric ifFalse: [ self closeMenu ].		^ false].	"Home"	keyValue = 1 ifTrue: [ menuMorph home. ^ true ].	"End"	keyValue = 4 ifTrue: [ menuMorph end. ^ true].	"?"	keyChar = $? ifTrue: [ menuMorph help. ^true].	"Arrow up"	keyValue = 30 ifTrue: [ menuMorph moveUp. ^ true].	"Arrow down"	keyValue = 31 ifTrue: [ menuMorph moveDown. ^ true].	"Page up"	keyValue = 11 ifTrue: [ menuMorph pageUp. ^ true].	"Page down"	keyValue = 12 ifTrue: [ menuMorph pageDown. ^ true].	"Enter, Tab or Ctrl-Space"	(enter or: [ space & (ctrl | kbEvent rawMacOptionKeyPressed) or: [ tab]]) ifTrue: [		self insertSelected			ifTrue: [^ true]].	"All keys but the alphanumeric chars (without command and control ) 	and the backspace key do close the menu"	(ctrl not & cmd not and: [ alphanum | colon])		ifFalse: [ self closeMenu ].	^false! !!AutoCompleter methodsFor: 'entries' stamp: 'jmv 7/14/2011 13:58'!computeEntries	"This default implementation might be redefined of needed."	| prefixStart prefixStop string |	string _ model actualContents string.	prefixStop _ position.	prefixStart _ position.	[ prefixStart > 0 and: [ (string at: prefixStart) isSeparator not ]] whileTrue: [		prefixStart _ prefixStart - 1 ].	prefix _ string copyFrom: prefixStart+1 to: prefixStop.	entries _ Array streamContents: [ :strm |		self addEntriesTo: strm ]! !!AutoCompleter methodsFor: 'entries' stamp: 'jmv 7/14/2011 13:58'!entries	^entries! !!AutoCompleter methodsFor: 'entries' stamp: 'jmv 7/14/2011 13:58'!entryCount	^ entries size! !!AutoCompleter methodsFor: 'entries' stamp: 'jmv 9/19/2011 10:54'!insertSelected	| entry editor selEnd str |	entry _ self selectedEntry.	editor _ textMorph editor.	str _ model actualContents string.	selEnd _ position.	[selEnd < str size and: [ (str at: selEnd+1) tokenish ]] whileTrue: [ selEnd _ selEnd + 1 ].	(selEnd < str size and: [ (str at: selEnd+1) = $ ]) ifTrue: [ selEnd _ selEnd + 1].	editor selectFrom: position-prefix size+1 to: selEnd.	editor		replaceSelectionWith: entry;		selectAt: position - prefix size + 1 + (self newCursorPosition: entry).	textMorph redrawNeeded.	menuMorph delete.	menuMorph _ nil.	^ true! !!AutoCompleter methodsFor: 'entries' stamp: 'jmv 8/2/2011 15:33'!newCursorPosition: anEntry	^anEntry size! !!AutoCompleter methodsFor: 'entries' stamp: 'jmv 8/2/2011 15:32'!selectedEntry	^(self entries at: menuMorph selected), ' '! !!AutoCompleter methodsFor: 'testing' stamp: 'jmv 8/3/2011 09:41'!opensWithTab	"Some completers want to open completion with Tab in addition to Ctrl-Space"	^false! !!AutoCompleter class methodsFor: 'instance creation' stamp: 'jmv 7/14/2011 13:58'!withModel: aStringHolder	^self new setModel: aStringHolder! !!AutoCompleter class methodsFor: 'help text' stamp: 'jmv 7/14/2011 13:58'!helpText	"	self helpText edit	"^'open/close menu	ctrl-space or tab		open the completion menu	ESC		close menu	?, ctl-h		open this helpmenu navigation	Arrows up/down		move the selection up and down	Page up/down		page up and down	Home/End		move to first or last page of the menuchanging menu contents	alphanumeric character		filter the menu to the given input	backspace		delete an input character, adjust menu to the new input.inserting completion	ctrl-space or tab		close the menu and insert selected completion. if there only one item left in the menu this done automaticaly.'! !!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 7/14/2011 13:58'!end	self gotoPage: self pageCount.	self redrawNeeded! !!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 7/14/2011 13:59'!help	TextModel new contents: AutoCompleter helpText; openLabel: 'uCompletion Keyboard Help'! !!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 7/14/2011 13:58'!home	self gotoPage: 1.	self redrawNeeded! !!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 7/14/2011 14:22'!moveDown	self selected: self selected + 1.	(self selected > self lastVisible			and: [self selected <= completer entryCount])		ifTrue: [firstVisible := firstVisible + 1].	self redrawNeeded! !!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 7/14/2011 13:58'!moveUp	(self selected = 0			and: [self firstVisible = 1])		ifTrue: [^ self].	self selected: self selected - 1.	self selected < self firstVisible		ifTrue: [firstVisible := firstVisible - 1].	self redrawNeeded! !!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 7/14/2011 13:58'!pageDown	self gotoPage: self currentPage + 1.	self redrawNeeded! !!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 7/14/2011 13:58'!pageUp	self gotoPage: self currentPage - 1.	self redrawNeeded! !!AutoCompleterMorph methodsFor: 'actions' stamp: 'jmv 8/2/2011 15:36'!resetMenu	| w f |	firstVisible _ 1.	self selected: 1.	w _ 120.	f _ self class listFont.	1		to: completer entryCount		do: [ :index |			w _ w max: (f widthOfString: (completer entries at: index) asString)].	completer entryCount > self class itemsPerPage  ifTrue: [		w _ w + Preferences scrollbarThickness ].	self extent: w + 4 @ (self visibleItemsCount * self itemHeight+2)! !!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 7/19/2011 09:29'!initialize 	super initialize.	self color: (Theme current paneBackgroundFrom: Color gray).	self setBorderWidth: 1 borderColor: self class borderColor.	self startStepping! !!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 7/19/2011 09:01'!setCompleter: anAutoCompleter position: aPoint 	completer _ anAutoCompleter.	self position: aPoint.	self resetMenu.	self openInWorld! !!AutoCompleterMorph methodsFor: 'paging' stamp: 'jmv 7/19/2011 09:40'!currentPage	^(self selected - 1 // self class itemsPerPage ) + 1.! !!AutoCompleterMorph methodsFor: 'paging' stamp: 'jmv 7/19/2011 09:40'!gotoPage: anInteger	| item |	item := ((anInteger - 1) * self class itemsPerPage) + 1. 	item >= completer entryCount ifTrue: [^self].	item < 1 ifTrue: [item := 1].	firstVisible := item.	self selected: firstVisible. 	! !!AutoCompleterMorph methodsFor: 'paging' stamp: 'jmv 7/19/2011 09:40'!pageCount	| count |	completer entryCount = self class itemsPerPage		ifTrue: [^ 1].	count _ completer entryCount // self class itemsPerPage.	(completer entryCount \\ self class itemsPerPage) > 0 		ifTrue: [ count _ count + 1].	^count! !!AutoCompleterMorph methodsFor: 'private' stamp: 'jmv 7/14/2011 14:22'!firstVisible	^firstVisible min: completer entryCount! !!AutoCompleterMorph methodsFor: 'private' stamp: 'jmv 7/19/2011 09:40'!lastVisible	^ (self firstVisible + self class itemsPerPage - 1)  min: completer entryCount! !!AutoCompleterMorph methodsFor: 'private' stamp: 'jmv 7/14/2011 13:58'!visibleItemsCount.	^ self lastVisible - self firstVisible + 1! !!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 7/19/2011 14:15'!drawOn: aCanvas	| rectangle w x0 y0 h y1 y2 |	aCanvas frameAndFillRectangle: self bounds fillColor: self color borderWidth: 1 borderColor: self borderColor.	x0 _ bounds left+1.	y0 _ bounds top+1.	w _ bounds width-2.	completer entryCount > self class itemsPerPage  ifTrue: [		w _ bounds width-Preferences scrollbarThickness -2.		aCanvas			frameRectangle: (bounds topRight - (Preferences scrollbarThickness@0)				extent: Preferences scrollbarThickness @ bounds height)			borderWidth: 1			color: self borderColor.		aCanvas			image: (ScrollbarButton arrowOfDirection: #top)			at: bounds topRight - (Preferences scrollbarThickness@0).		aCanvas			image: (ScrollbarButton arrowOfDirection: #bottom)			at: bounds bottomRight - Preferences scrollbarThickness.		h _ bounds height - (2 * Preferences scrollbarThickness).		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + Preferences scrollbarThickness-1.		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + Preferences scrollbarThickness -1.		aCanvas fillRectangle: (bounds right - Preferences scrollbarThickness+2@y1 corner: bounds right-2 @ y2) colorOrInfiniteForm: Color veryLightGray.		aCanvas		].	self firstVisible		to: self lastVisible		do: [ :index |			rectangle _ x0@y0 extent: w@self class itemHeight.			index = self selected				ifTrue: [					aCanvas fillRectangle: rectangle colorOrInfiniteForm: (Theme current listHighlightFocused: true) ].			aCanvas				drawString: (completer entries at: index) asString				in: rectangle				font: self class listFont				color: Theme current text.			y0 _ y0 + self itemHeight ]! !!AutoCompleterMorph methodsFor: 'accessing' stamp: 'jmv 7/14/2011 13:58'!itemHeight	"cached to minimise recalculation"	^ itemHeight ifNil: [itemHeight := self class itemHeight]! !!AutoCompleterMorph methodsFor: 'accessing' stamp: 'jmv 7/14/2011 13:58'!selected	"Answer the value of selected"	selected ifNil: [ selected := self firstVisible ].	^ selected! !!AutoCompleterMorph methodsFor: 'accessing' stamp: 'jmv 7/14/2011 14:23'!selected: aNumber 	"Set the value of selected"	((aNumber between: 1 and: completer entryCount) and: [ aNumber ~= selected ])		ifTrue: [ selected _ aNumber ]! !!AutoCompleterMorph methodsFor: 'event handling' stamp: 'jmv 7/14/2011 13:58'!handlesMouseDown: evt	^ true! !!AutoCompleterMorph methodsFor: 'event handling' stamp: 'jmv 7/14/2011 14:22'!mouseUp: evt	(self containsPoint: evt position)		ifTrue: [			self selected: 				((evt position y - bounds top // self class itemHeight) + 					self firstVisible).			completer insertSelected ]		ifFalse: [ self delete. completer menuClosed ]! !!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'jmv 7/14/2011 13:58'!lastActivity 	lastActivity ifNil: [self stillActive].	^ lastActivity ! !!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'jmv 7/14/2011 14:23'!step	self timeOfLastActivity > self timeout		ifTrue: [ self delete. completer menuClosed ]		ifFalse: [self updateColor]! !!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'jmv 7/14/2011 13:58'!stepTime 	^ 100! !!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'jmv 7/14/2011 13:58'!stillActive	lastActivity := Time millisecondClockValue.! !!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'jmv 7/14/2011 13:58'!timeOfLastActivity	^ (Time millisecondClockValue - self lastActivity)   ! !!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'jmv 7/19/2011 14:13'!timeout	^ 5000! !!AutoCompleterMorph methodsFor: 'as yet unclassified' stamp: 'jmv 7/14/2011 13:58'!updateColor	| remaining alpha |	remaining := (self timeout - self timeOfLastActivity).	remaining < 1000 		ifTrue: [			alpha _ remaining / 1000.0.			self color: (self color alpha: alpha).			self borderColor: (self borderColor alpha: alpha)			]! !!AutoCompleterMorph class methodsFor: 'preferences' stamp: 'jmv 7/14/2011 13:58'!borderColor	^ Color gray! !!AutoCompleterMorph class methodsFor: 'preferences' stamp: 'jmv 7/14/2011 13:58'!itemHeight	"height must be forced to be even to allow the detail arrow to be drawn correctly"		^ (self listFont height + 2) roundUpTo: 2"14".! !!AutoCompleterMorph class methodsFor: 'preferences' stamp: 'jmv 7/19/2011 09:40'!itemsPerPage	^14! !!AutoCompleterMorph class methodsFor: 'preferences' stamp: 'jmv 7/14/2011 13:58'!listFont	^Preferences standardListFont! !!AutoCompleterMorph class methodsFor: 'instance creation' stamp: 'jmv 7/14/2011 14:12'!completer: anAutoCompleter position: aPoint 	| newObject |	newObject _ self new.	newObject setCompleter: anAutoCompleter position: aPoint.	^ newObject! !!BareTextMorph methodsFor: 'accessing' stamp: 'jmv 7/14/2011 14:23'!autoCompleter: anUCompleter	autoCompleter _ anUCompleter.	autoCompleter ifNotNil: [		autoCompleter textMorph: self ]! !!BareTextMorph methodsFor: 'event handling' stamp: 'jmv 7/14/2011 14:38'!keyStroke: evt	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].			"Maybe disable? Precludes the use of up and down arrows with control,	that are standard keystrokes in Windows to control the cursor.	Problem: At least Mac and Win VM generate ctrl-up and ctrl-down for	mouse wheel events.	I guess most people would prefer the mouse wheel to work properly..."	(editView scrollByKeyboard: evt)		ifTrue: [ ^self ].	autoCompleter 		ifNil: [ self processKeyStroke: evt ]		ifNotNil: [			autoCompleter				autoCompletionAround: [ self processKeyStroke: evt ]				keyStroke: evt ]! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 7/14/2011 14:09'!autoCompleterClass	^SmalltalkCompleter! !!ObjectExplorer methodsFor: 'accessing' stamp: 'jmv 7/14/2011 14:10'!autoCompleterClass	^SmalltalkCompleter! !!OneLineEditorMorph methodsFor: 'testing' stamp: 'jmv 8/3/2011 13:16'!hasVisibleCaret	^ self hasKeyboardFocus and: [editor notNil and: [editor hasCaret]]! !!ProcessBrowser methodsFor: 'views' stamp: 'jmv 7/14/2011 14:10'!autoCompleterClass	^SmalltalkCompleter! !!SHParserST80 methodsFor: 'testing' stamp: 'jmv 9/16/2011 10:40'!isMessage: aSymbol	^#(binary incompleteBinary keyword incompleteKeyword unary incompleteUnary) pointsTo: aSymbol! !!SmalltalkCompleter methodsFor: 'entries' stamp: 'jmv 9/16/2011 11:10'!computeEntries	| allSource contextClass id p range prevRange receiverClass |	allSource _ model actualContents string.	p _ (model is: #hasTextProvider)		ifTrue: [ model textProvider ]		ifFalse: [ model ].	contextClass _ (p respondsTo: #selectedClassOrMetaClass) ifTrue: [		p selectedClassOrMetaClass ].	"Instead of creating a new string, maybe we could pass the last position to parse to Shout..."	parser _ SHParserST80 new.	parser		workspace: ((model isMemberOf: Workspace) ifTrue: [ model ]);		classOrMetaClass: contextClass;		source: (allSource copyFrom: 1 to: position).	parser parse.	range _ parser lastRange.	range ifNil: [ ^entries _ #() ].	"If parsing breaks before position, then we don't know what to suggest, therefore don't open Completion"	range end = position ifFalse: [ ^entries _ #() ].	prefix _ allSource copyFrom: range start to: range end.		(parser isMessage: range type) ifTrue: [		"If previous range is a constant or a well known identifier, we might filter messages"		prevRange _ parser penultimateRange.		receiverClass _ prevRange ifNotNil: [			id _ (allSource copyFrom: prevRange start to: prevRange end).			prevRange type caseOf: {				[ #globalVar ] -> [ (Smalltalk at: id asSymbol) class ].				[ #self ] -> [ contextClass ].				[ #super ] -> [ contextClass superclass ].				[ #true ] -> [ True ].				[ #false ] -> [ False ].				[ #nil ] -> [ UndefinedObject ].				[ #character ] -> [ id first class ].				[ #number ] -> [ (Compiler evaluate: id) class ].				[ #string ] -> [ (Compiler evaluate: id) class ].				[ #symbol ] -> [ (Compiler evaluate: id) class ].				[ #stringSymbol ] -> [ (Compiler evaluate: id) class ].				"thisContext could mean ContextPart or BlockClosure..."				"[ #thisContext ] -> [ ContextPart ]"			} otherwise: [ nil ]].		^self computeMessageEntries: receiverClass ].	(parser isPartialOrFullIdentifier: range type) ifTrue: [		^self computeIdentifierEntries ].		"If we don't know what to do, do nothing"	entries _ #()! !!SmalltalkCompleter methodsFor: 'entries' stamp: 'jmv 7/14/2011 13:58'!computeIdentifierEntries	entries _ Array streamContents: [ :strm | 		parser namesBeginningWith: prefix do: [ :identifier | strm nextPut: identifier ]]! !!SmalltalkCompleter methodsFor: 'entries' stamp: 'jmv 9/16/2011 11:10'!computeMessageEntries: receiverClass	| s i |	s _ 400.	entries _ OrderedCollection new.	self class protected: [		Selectors forPrefix: prefix keysAndValuesDo: [ :key :value |			(receiverClass isNil or: [ receiverClass canUnderstand: key ]) ifTrue: [				entries size < s					ifTrue: [						entries add: { key . value }.						entries size = s ifTrue: [ entries _ entries asArray sort: [ :a :b | a second > b second ]]]					ifFalse: [						entries							findBinaryIndex: [ :ary | ary second < value ifTrue: [ -1 ] ifFalse: [ 1 ]]							do: [ :found | ]							ifNone: [ :a :b |								b > s ifFalse: [									i _ s.									[i > b] whileTrue: [										entries at: i put: (entries at: i-1).										i _ i - 1].									entries at: b put: { key . value } ]]]]]].	"Sort and make an Array, if it hasn't been done yet."	entries size < s ifTrue: [		entries _ entries asArray sort: [ :a :b | a second > b second ]].	" To see the timestamps in the menu (need to tweak #insertCompletion: to activate. Right now, just for debugging)	entries _ entries collect: [ :ary | ary first, '(', ((DateAndTime fromString: '01/01/1996 00:00') + ary second minutes) printString,')' ]	"	entries _ entries collect: [ :ary | ary first ]! !!SmalltalkCompleter methodsFor: 'entries' stamp: 'jmv 8/2/2011 15:34'!newCursorPosition: anEntry	^anEntry indexOf: $ ! !!SmalltalkCompleter methodsFor: 'entries' stamp: 'jmv 8/2/2011 15:32'!selectedEntry	^(self entries at: menuMorph selected) separateKeywords! !!SmalltalkCompleter methodsFor: 'testing' stamp: 'jmv 8/3/2011 10:06'!opensWithTab	"Some completers want to open completion with Tab in addition to Ctrl-Space"	^true! !!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'jmv 7/14/2011 13:58'!addSelector: aSymbol method: aCompiledMethod allImplemented: implemented	| sentValue value |	self protected: [		value _  aCompiledMethod dateSortingValue.		Selectors at: aSymbol put: (value  max: (Selectors at: aSymbol ifAbsent: [0])).		aCompiledMethod messages do: [ :sentMsg |			((Selectors includesKey: sentMsg) or: [ 				implemented					ifNotNil: [ implemented includes: sentMsg ]					ifNil: [ Smalltalk isThereAnImplementorOf: sentMsg ]])						ifTrue: [							sentValue _ value max: (Selectors at: sentMsg ifAbsent: [0]).							Selectors at: sentMsg put: sentValue ]]]! !!SmalltalkCompleter class methodsFor: 'class initialization' stamp: 'jmv 7/14/2011 14:27'!initialize	"	It takes about 6 seconds, mostly because of the time to fetch method stamps from source files...	[ SmalltalkCompleter initialize ]timeToRun	Selectors inspect	"	| maxSortValue allImplemented |	SystemChangeNotifier uniqueInstance		removeActionsWithReceiver: self; "avoid double registration"		notify: self ofSystemChangesOfItem: #method using: #methodChanged:.		self protected: [		allImplemented _ Smalltalk allImplementedMessages.		Selectors _ Trie new.		"		Smalltalk allBehaviorsDo: [:class |			class selectorsAndMethodsDo: [ :sel :method |				Selectors at: sel ifAbsentPut: [ 0 ].				method messages do: [ :sentMsg |					Selectors at: sentMsg put: (Selectors at: sentMsg ifAbsent: [ 0 ]) + 1 ]]].		"		Smalltalk allBehaviorsDo: [:class |			class selectorsAndMethodsDo: [ :sel :method |				self addSelector: sel method: method allImplemented: allImplemented]].		""			"The following might not be found in #messages. Give them maximum priority."		maxSortValue _ SmallInteger maxVal.		"From MessageNode>>#initialize"		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise:			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:) do: [ :sel |				Selectors at: sel put: maxSortValue ].			maxSortValue _ SmallInteger maxVal-1.		"From SystemDictionary >>#recreateSpecialObjectsArray"		(1 to: Smalltalk specialSelectorSize) do:  [ :i |				Selectors at: (Smalltalk specialSelectorAt: i) put: maxSortValue ]]! !!SmalltalkCompleter class methodsFor: 'notifications' stamp: 'jmv 7/14/2011 13:58'!methodChanged: anEvent	| method selector |	self protected: [		method _ anEvent item.		selector _ anEvent itemSelector.		anEvent isAdded | anEvent isModified			ifTrue: [ self addSelector: selector method: method allImplemented: nil ]			ifFalse: [				(anEvent isRemoved and: [(Smalltalk numberOfImplementorsOf: selector) = 0])					ifTrue: [ Selectors removeKey: selector ]]]! !!SmalltalkCompleter class methodsFor: 'services' stamp: 'jmv 7/14/2011 13:58'!isThereAnImplementorOf: aSymbol	| answer |	self protected: [		answer _ Selectors includesKey: aSymbol ].	^answer! !!SmalltalkCompleter class methodsFor: 'services' stamp: 'jmv 7/14/2011 13:58'!thatStartsCaseSensitive: prefix	self protected: [		Selectors forPrefix: prefix keysAndValuesDo: [ :key :value | ^key ] ].	^nil! !!SmalltalkCompleter class methodsFor: 'synchronization' stamp: 'jmv 7/14/2011 13:58'!protected: aBlock	^(AccessLock ifNil: [ AccessLock := Mutex new ]) critical: aBlock! !!SmalltalkCompleterTest methodsFor: 'testing' stamp: 'jmv 7/14/2011 14:26'!testMessages	"	SmalltalkCompleterTest new testMessages	"	| fromSmalltalk fromUCompleter |	fromSmalltalk _ Smalltalk allImplementedMessages.	fromUCompleter _ Symbol allInstances select: [ :s |		SmalltalkCompleter isThereAnImplementorOf: s].	self assert: fromSmalltalk = fromUCompleter asSet! !!Symbol class methodsFor: 'access' stamp: 'jmv 7/14/2011 14:37'!thatStartsCaseSensitive: leadingCharacters	"Same as thatStarts:skipping: but caseSensitive"	"Note: Only answers symbols for which there is some implementor"	| size firstMatch key |	"Use optimized implementation if available,"	Smalltalk at: #SmalltalkCompleter ifPresent: [ :cls | ^cls thatStartsCaseSensitive: leadingCharacters ].	size := leadingCharacters size.	size = 0 ifTrue: [^#''].	firstMatch := leadingCharacters at: 1.	size > 1 ifTrue: [ key _ leadingCharacters copyFrom: 2 to: size ].	self allSymbolTablesDo: [ :each |			each size >= size ifTrue: [				((each at: 1) == firstMatch and: [					key == nil or: [						(each findString: key startingAt: 2 caseSensitive: true) = 2]])							ifTrue: [								(Smalltalk isThereAnImplementorOf: each) ifTrue: [									^each]]]].	^nil! !!Symbol class methodsFor: 'services' stamp: 'jmv 7/14/2011 14:37'!hasInternedAndImplemented: aString	"Answer with false if aString hasnt been interned (into a Symbol), 	or if there are no implemetors of the selector."	"Use optimized implementation if available,"	Smalltalk at: #SmalltalkCompleter ifPresent: [ :cls | 		^self hasInterned: aString and: [ :symbol | cls isThereAnImplementorOf: symbol ]].	^self hasInterned: aString and: [ :symbol | Smalltalk isThereAnImplementorOf: symbol ]! !!TestRunner methodsFor: 'menus' stamp: 'jmv 7/14/2011 14:10'!autoCompleterClass	^nil! !!TextModel methodsFor: 'pane menu' stamp: 'jmv 7/14/2011 14:00'!autoCompleter	^nil! !!PluggableTextModel methodsFor: 'pane menu' stamp: 'jmv 7/14/2011 14:10'!autoCompleter	^textProvider autoCompleterClass ifNotNil: [ :cls |		cls withModel: self ]! !!TextModelMorph methodsFor: 'shout' stamp: 'jmv 7/14/2011 14:01'!autoCompleter: anUCompleter		textMorph autoCompleter: anUCompleter! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 7/14/2011 14:29'!textProvider: aTextProvider textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter	| newModel answer |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [  aTextProvider is: #ShoutEnabled ]) ifTrue: [		answer styler: SHTextStylerST80 new ].	newModel _ PluggableTextModel on: aTextProvider.	newModel textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter.	aTextProvider addDependent: newModel.	answer model: newModel.	answer autoCompleter: newModel autoCompleter.	^answer! !!TextModelMorph class methodsFor: 'instance creation' stamp: 'jmv 7/14/2011 14:29'!withModel: aTextModel	|  answer |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [ aTextModel is: #ShoutEnabled ]) ifTrue: [		answer styler: SHTextStylerST80 new ].	answer model: aTextModel.	answer autoCompleter: aTextModel autoCompleter.	^answer! !!BrowserCommentTextMorph class methodsFor: 'instance creation' stamp: 'jmv 7/14/2011 14:29'!textProvider: aTextProvider textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter	| newModel answer |	answer _ self new.	newModel _ PluggableTextModel on: aTextProvider.	newModel textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter.	aTextProvider addDependent: newModel.	answer model: newModel.	answer autoCompleter: newModel autoCompleter.	^answer! !!TextProvider methodsFor: 'accessing' stamp: 'jmv 7/14/2011 14:10'!autoCompleterClass	^nil! !!CodeProvider methodsFor: 'code pane menu' stamp: 'jmv 7/14/2011 14:09'!autoCompleterClass	^SmalltalkCompleter! !!FileList methodsFor: 'file list menu' stamp: 'jmv 7/14/2011 14:09'!autoCompleterClass	^SmalltalkCompleter! !!Inspector methodsFor: 'code pane menu' stamp: 'jmv 7/14/2011 14:10'!autoCompleterClass	^SmalltalkCompleter! !!Trie methodsFor: 'accessing' stamp: 'jmv 6/21/2011 13:56'!at: key 	"Answer the value associated with the key."	^ self at: key ifAbsent: [self errorKeyNotFound]! !!Trie methodsFor: 'accessing' stamp: 'jmv 6/21/2011 13:56'!at: aString ifAbsent: aBlock	rootNode ifNil: [ ^aBlock value ].	^ rootNode at: aString ifAbsent: aBlock characterIndex: 1! !!Trie methodsFor: 'accessing' stamp: 'jmv 6/22/2011 14:53'!at: key ifAbsentPut: aBlock 	"Return the value at the given key.	If key is not included in the receiver store the result	of evaluating aBlock as new value."	^self at: key ifAbsent:[self at: key put: aBlock value]! !!Trie methodsFor: 'accessing' stamp: 'jmv 6/22/2011 14:53'!at: key ifPresent: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| v |	v _ self at: key ifAbsent: [^ nil].	^ aBlock value: v! !!Trie methodsFor: 'accessing' stamp: 'jmv 6/21/2011 23:01'!at: aString put: aValue	rootNode ifNil: [		rootNode _ TrieNode someKey: aString segmentStart: 1].	^rootNode at: aString put: aValue characterIndex: 1! !!Trie methodsFor: 'adding' stamp: 'jmv 6/21/2011 13:56'!add: aString	self at: aString put: aString! !!Trie methodsFor: 'removing' stamp: 'jmv 6/22/2011 15:00'!remove: aString ifAbsent: exceptionBlock	"Consistent with Set"	self at: aString ifPresent: [ :v |		v = aString ifTrue: [			self removeKey: aString ifAbsent: exceptionBlock ]]! !!Trie methodsFor: 'removing' stamp: 'jmv 6/22/2011 15:04'!removeKey: aString 	"Remove key from the receiver.	If key is not in the receiver, notify an error."	^ self removeKey: aString ifAbsent: [self errorKeyNotFound]! !!Trie methodsFor: 'removing' stamp: 'jmv 6/22/2011 15:32'!removeKey: aString ifAbsent: aBlock	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| answer |	rootNode ifNil: [ ^aBlock value ].	answer _ rootNode removeKey: aString ifAbsent: aBlock characterIndex: 1.	rootNode isEmpty ifTrue: [		rootNode _ nil ].	^answer! !!Trie methodsFor: 'enumerating' stamp: 'jmv 6/21/2011 22:14'!do: aBlock	"Consistent both with Set (#add:) and Dictionary (#at:put:) protocols."	self valuesDo: aBlock! !!Trie methodsFor: 'enumerating' stamp: 'jmv 6/22/2011 12:07'!forPrefix: aString keysAndValuesDo: twoArgBlock	rootNode ifNotNil: [		rootNode forPrefix: aString keysAndValuesDo: twoArgBlock characterIndex: 1]! !!Trie methodsFor: 'enumerating' stamp: 'jmv 6/21/2011 22:07'!keysAndValuesDo: twoArgBlock	rootNode ifNotNil: [		rootNode keysAndValuesDo: twoArgBlock ]! !!Trie methodsFor: 'enumerating' stamp: 'jmv 6/21/2011 13:56'!keysDo: aBlock	rootNode ifNotNil: [		rootNode keysAndValuesDo: [ :k :v | aBlock value: k ]]! !!Trie methodsFor: 'enumerating' stamp: 'jmv 6/21/2011 13:56'!valuesDo: aBlock	rootNode ifNotNil: [		rootNode keysAndValuesDo: [ :k :v | aBlock value: v ]]! !!Trie methodsFor: 'testing' stamp: 'jmv 6/22/2011 14:59'!includes: aString	"Consistent with Set, but not with Dictionary,  as in Dictionary, #includes:	finds a value regardless of the key. To get this behavior, use #includesValue:"	self at: aString ifPresent: [ :v | ^v = aString ].	^false! !!Trie methodsFor: 'testing' stamp: 'jmv 6/21/2011 13:56'!includesKey: key		self at: key ifAbsent: [^false].	^true! !!Trie methodsFor: 'testing' stamp: 'jmv 6/21/2011 22:17'!includesValue: anObject	"Similar to Dictionary>>#includes:"	self do: [:each | anObject = each ifTrue: [^true]].	^false! !!Trie methodsFor: 'testing' stamp: 'jmv 6/22/2011 15:32'!isEmpty	^rootNode isNil! !!Trie methodsFor: 'private' stamp: 'jmv 6/21/2011 13:56'!errorKeyNotFound	self error: 'key not found'! !!Trie methodsFor: 'space analysis' stamp: 'jmv 6/21/2011 22:09'!usedMemory	^rootNode usedMemory + 12 "object header+ 1 ivar"! !!TrieLeaf methodsFor: 'accessing' stamp: 'jmv 6/22/2011 15:07'!at: aString ifAbsent: aBlock characterIndex: i	"Unused argument i is just for polymorphism with TrieNode"	| keyIndex |	keys isArray ifTrue: [		keyIndex _ keys indexOf: aString.		^ keyIndex = 0			ifTrue: [ aBlock value ]			ifFalse: [ values at: keyIndex ]].	keys = aString ifTrue: [ ^ values ].	^ aBlock value! !!TrieLeaf methodsFor: 'accessing' stamp: 'jmv 6/22/2011 15:07'!at: aString put: aValue characterIndex: i	"Unused argument i is just for polymorphism with TrieNode"	| keyIndex |	keys ifNil: [		keys _ aString.		values _ aValue.		^aValue ].	keys isArray ifFalse: [		keys = aString			ifFalse: [				keys _ {keys. aString }.				values _ {values. aValue}]			ifTrue: [ values _ aValue ].		^ aValue ].	keyIndex _ keys indexOf: aString.	keyIndex = 0		ifTrue: [			keys _ keys copyWith: aString.			values _ values copyWith: aValue ]		ifFalse: [ values at: keyIndex put: aValue ].	^ aValue! !!TrieLeaf methodsFor: 'removing' stamp: 'jmv 6/22/2011 15:46'!removeKey: aString ifAbsent: aBlock characterIndex: i	"Unused argument i is just for polymorphism with TrieNode"	| keyIndex answer |	keys isArray ifTrue: [		keyIndex _ keys indexOf: aString.		^ keyIndex = 0			ifTrue: [ aBlock value ]			ifFalse: [				answer _ values at: keyIndex.				keys size = 2					ifTrue: [						keys _ keys at: 3-keyIndex.						values _ values at: 3-keyIndex ]					ifFalse: [						keys _ (keys copyFrom: 1 to: keyIndex-1), (keys copyFrom: keyIndex+1 to: keys size).						values _ (values copyFrom: 1 to: keyIndex-1), (values copyFrom: keyIndex+1 to: values size) ].				answer]].	keys = aString ifTrue: [		answer _ values.		keys _ nil.		values _ nil.		^ answer ].	^ aBlock value! !!TrieLeaf methodsFor: 'enumerating' stamp: 'jmv 6/22/2011 15:51'!keysAndValuesDo: twoArgBlock	keys isArray		ifTrue: [ keys with: values do: twoArgBlock ]		ifFalse: [ twoArgBlock value: keys value: values ]! !!TrieLeaf methodsFor: 'testing' stamp: 'jmv 6/22/2011 15:17'!isEmpty	^keys isNil! !!TrieLeaf methodsFor: 'space analysis' stamp: 'jmv 6/21/2011 22:20'!usedMemory	| s |	s _ 4 "Object header for a compact class"		+ (2*4). "2 instance variables"	keys isArray ifTrue: [		"Array is a compact class of words"		s _ keys size * 4 + 4 + s.		s _ values size * 4 + 4 + s ].	^s! !!TrieNode methodsFor: 'accessing' stamp: 'jmv 6/22/2011 15:05'!at: aString ifAbsent: aBlock characterIndex: i	| child |	child _ self childFor: aString characterIndex: i orAdd: false.	child ifNil: [ ^aBlock value ].	^child at: aString ifAbsent: aBlock characterIndex: i + segmentSize! !!TrieNode methodsFor: 'accessing' stamp: 'jmv 6/21/2011 22:08'!at: aString put: aValue characterIndex: i	| child |	childrenFirstChars ifNotNil: [		self splitIfNeededFor: aString characterIndex: i ].	child _ self childFor: aString characterIndex: i orAdd: true.	^child at: aString put: aValue characterIndex: i + segmentSize! !!TrieNode methodsFor: 'removing' stamp: 'jmv 6/23/2011 11:02'!removeKey: aString ifAbsent: aBlock characterIndex: i	| child answer |	child _ self childFor: aString characterIndex: i orAdd: false.	child ifNil: [ ^aBlock value ].	answer _ child removeKey: aString ifAbsent: aBlock characterIndex: i + segmentSize.	child isEmpty ifTrue: [		self removeChildFor: aString characterIndex: i.		"If child is not needed anymore, compress the path"			children class = TrieNode ifTrue: [			someKey _ children getSomeKey.			segmentSize _ segmentSize + children getSegmentSize.			childrenFirstChars _ children getChildrenFirstChars.			children _ children getChildren ]].	^answer! !!TrieNode methodsFor: 'enumerating' stamp: 'jmv 6/23/2011 09:23'!forPrefix: aString keysAndValuesDo: twoArgBlock characterIndex: i	i + segmentSize > aString size		ifTrue: [			self keysAndValuesDo: twoArgBlock ]		ifFalse: [			(self childFor: aString characterIndex: i orAdd: false)				ifNotNil: [ :node |					node						forPrefix: aString						keysAndValuesDo: twoArgBlock						characterIndex: i + segmentSize ]]! !!TrieNode methodsFor: 'enumerating' stamp: 'jmv 6/22/2011 15:51'!keysAndValuesDo: twoArgBlock	children isArray ifFalse: [		^children keysAndValuesDo: twoArgBlock ].	children do: [ :child |		child ifNotNil: [ child keysAndValuesDo: twoArgBlock ]]! !!TrieNode methodsFor: 'testing' stamp: 'jmv 6/22/2011 15:18'!isEmpty	^childrenFirstChars isNil! !!TrieNode methodsFor: 'private' stamp: 'jmv 6/23/2011 10:22'!childFor1: aString characterIndex: i orAdd: doAdd	"Answer child at childCode.	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.		otherwise, just answer nil.	This method for the case where we currently have exactly one child."	| nextSegmentStart nextSegmentFirst answer |	nextSegmentStart _ i + segmentSize.	nextSegmentFirst _ nextSegmentStart > aString size		ifTrue: [TrieNode characterForLeaf]		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].	childrenFirstChars = nextSegmentFirst ifTrue: [ ^ children].	doAdd ifFalse: [ ^ nil ].		answer _ nextSegmentStart > aString size		ifTrue: [ TrieLeaf new ]		ifFalse: [ TrieNode someKey: aString segmentStart: nextSegmentStart ].	"Just one child, if adding, convert references to a collection"	nextSegmentFirst < childrenFirstChars		ifTrue: [			children _ {answer . children }.			childrenFirstChars _ String with: nextSegmentFirst with: childrenFirstChars ]		ifFalse: [			children _ {children . answer}.			childrenFirstChars _ String with: childrenFirstChars with: nextSegmentFirst ].	^answer! !!TrieNode methodsFor: 'private' stamp: 'jmv 6/23/2011 10:27'!childFor: aString characterIndex: i orAdd: doAdd	"Answer child at childCode.	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.		otherwise, just answer nil."	"No children yet"	childrenFirstChars ifNil: [		doAdd ifTrue: [			children _ TrieLeaf new.			childrenFirstChars _ TrieNode characterForLeaf ].		^children ].	"Just one child, if adding, convert references to a collection"	childrenFirstChars isString ifFalse: [		^ self childFor1: aString characterIndex: i orAdd: doAdd ].	"Already more than one child. If adding, convert to a bigger collection."	^self childForN: aString characterIndex: i orAdd: doAdd! !!TrieNode methodsFor: 'private' stamp: 'jmv 6/23/2011 10:25'!childForN: aString characterIndex: i orAdd: doAdd	"Answer child at childCode.	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.		otherwise, just answer nil.	This method for the case where we currently have more than one child."	| answer newChildren newFirstChars nextSegmentFirst nextSegmentStart s |	nextSegmentStart _ i + segmentSize.	nextSegmentFirst _ nextSegmentStart > aString size		ifTrue: [TrieNode characterForLeaf]		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].	childrenFirstChars		findBinaryIndex: [ :each |			each = nextSegmentFirst ifTrue: [ 0 ]				ifFalse: [each > nextSegmentFirst ifTrue: [-1] ifFalse: [1]]]		do: [ :found | ^ children at: found ]		ifNone: [ :a :b |			"Already more than one child. If adding, convert to a bigger collection."			doAdd				ifFalse: [ ^nil]				ifTrue: [					 answer _ nextSegmentStart > aString size						ifTrue: [ TrieLeaf new ]						ifFalse: [  TrieNode someKey: aString segmentStart: nextSegmentStart ].					s _ children size + 1.					newChildren _ Array new: s.					newChildren						replaceFrom: 1 to: a with: children startingAt: 1;						at: a+1 put: answer;						replaceFrom: a+2 to: s with: children startingAt: a+1.					newFirstChars _ String new: s.					newFirstChars						replaceFrom: 1 to: a with: childrenFirstChars startingAt: 1;						at: a+1 put: nextSegmentFirst;						replaceFrom: a+2 to: s with: childrenFirstChars startingAt: a+1.					children _ newChildren.					childrenFirstChars _ newFirstChars.					^answer ]]! !!TrieNode methodsFor: 'private' stamp: 'jmv 6/22/2011 15:45'!removeChildFor: aString characterIndex: i	"Answer child at childCode.	If it is not there,  and aBlockOrNil notNil, evaluate it to create it anew, add it, and answer it.		otherwise, just answer nil."	| nextSegmentStart nextSegmentFirst |	nextSegmentStart _ i + segmentSize.	nextSegmentFirst _ nextSegmentStart > aString size		ifTrue: [TrieNode characterForLeaf]		ifFalse: [(aString at: nextSegmentStart) asLowercase asUnaccented].	"Just one child, if adding, convert references to a collection"	childrenFirstChars isString ifFalse: [		childrenFirstChars = nextSegmentFirst			ifTrue: [ childrenFirstChars _ nil. children _ nil ].		^self ].		"Already more than one child."	childrenFirstChars		findBinaryIndex: [ :each |			each = nextSegmentFirst ifTrue: [ 0 ]				ifFalse: [each > nextSegmentFirst ifTrue: [-1] ifFalse: [1]]]		do: [ :found |			childrenFirstChars size = 2				ifTrue: [		"Two children: remove the arrays"					childrenFirstChars _ childrenFirstChars at: 3-found.					children _ children at: 3-found ]				ifFalse: [	"More than two children. condense the arrays"					childrenFirstChars _ (childrenFirstChars copyFrom: 1 to: found-1), 						(childrenFirstChars copyFrom: found+1 to: childrenFirstChars size).					children _ (children copyFrom: 1 to: found-1), (children copyFrom: found+1 to: children size) ]]		ifNone: [].! !!TrieNode methodsFor: 'private' stamp: 'jmv 6/23/2011 10:00'!splitIfNeededFor: aString characterIndex: segmentStart	"This method splits the self (the current node) into two nodes, such that the concatenation of their string segment equals our current string segment,	and such that the string segment of the first node (i.e. us) equals or is a prefix of aString.	If this latter condition is already met, do nothing."	| oldSegmentStop newSegmentStop newNode |	"Compute last index where both strings are equal"	oldSegmentStop _ segmentStart + segmentSize - 1.	newSegmentStop _ someKey commonPartWith: aString startAt: segmentStart stopAt: oldSegmentStop		applying: [ :c | c asLowercase asUnaccented ].				newSegmentStop = oldSegmentStop ifTrue: [		"No need to split: our segment is already a prefix of aString"		^self ].	"Split node"	newNode _ TrieNode someKey: someKey setSegmentSize: oldSegmentStop - newSegmentStop.	newNode setChildrenFirstChars: childrenFirstChars children: children.	"As this is a split point, these will be turned into arrays soon, when the new node addition (that called us) is done."	childrenFirstChars _ (someKey at: newSegmentStop+1) asLowercase asUnaccented.	children _ newNode.	"Update our segment"	segmentSize _ newSegmentStop - segmentStart + 1! !!TrieNode methodsFor: 'space analysis' stamp: 'jmv 6/21/2011 22:10'!usedMemory	| s |	s _ 4 "Object header for a compact class"		+ (4*4). "4 instance variables"	childrenFirstChars isString 		ifTrue: [			"String is a compact class of bytes"			s _  childrenFirstChars size + 4 + s.			"Array is a compact class of words"			s _ children size * 4 + 4 + s.			children do: [ :c | 				s _ c usedMemory + s ]]		ifFalse: [			children ifNotNil: [ s _ s + children usedMemory ]].	^s! !!TrieNode methodsFor: 'private accessors' stamp: 'jmv 6/23/2011 10:56'!getChildren	"Private. To be called only from parent node"	^children! !!TrieNode methodsFor: 'private accessors' stamp: 'jmv 6/23/2011 10:55'!getChildrenFirstChars	"Private. To be called only from parent node"	^childrenFirstChars! !!TrieNode methodsFor: 'private accessors' stamp: 'jmv 6/23/2011 10:55'!getSegmentSize	"Private. To be called only from parent node"	^segmentSize! !!TrieNode methodsFor: 'private accessors' stamp: 'jmv 6/23/2011 10:54'!getSomeKey	"Private. To be called only from parent node"	^someKey! !!TrieNode methodsFor: 'private accessors' stamp: 'jmv 6/23/2011 10:54'!setChildrenFirstChars: aString children: anArray	"Private. To be called only from parent node"	childrenFirstChars _ aString.	children _ anArray.! !!TrieNode methodsFor: 'private accessors' stamp: 'jmv 6/23/2011 10:54'!setSegmentSize: anInteger someKey: aString	"Private. To be called only from parent node"	segmentSize _ anInteger.	someKey _ aString! !!TrieNode class methodsFor: 'constants' stamp: 'jmv 6/21/2011 13:56'!characterForLeaf	"A special character to mean leaf node. Must have lower code than alphabetic chars,	so in the trie 'car' comes before 'cars'"	^Character value: 0! !!TrieNode class methodsFor: 'instance creation' stamp: 'jmv 6/21/2011 23:00'!someKey: aString segmentStart: i	^self new setSegmentSize: aString size - i + 1 someKey: aString! !!TrieNode class methodsFor: 'instance creation' stamp: 'jmv 6/21/2011 23:21'!someKey: aString setSegmentSize: s	^self new setSegmentSize: s someKey: aString! !!TrieTest methodsFor: 'testing' stamp: 'jmv 6/21/2011 22:14'!testAllMesssagesLikeDicionary	"	TrieTest new testAllMesssagesLikeDicionary	"	| subject  controlGroup allMessages copy c set1 set2 |	subject _ Trie new.	controlGroup _ Dictionary new.	allMessages _ Smalltalk allImplementedMessages.	c _ 0.	3 timesRepeat: [		allMessages do: [ :symbol |			subject at: symbol put: c.			controlGroup at: symbol put: c.			c _ c + 1 ]].	self assert: subject isEquivalentToDictionary: controlGroup.	copy _ Dictionary new.	set1 _ Set new.	subject keysAndValuesDo: [ :symbol :number |		copy at: symbol put: number.		set1 add: number ].	set2 _ Set new.	subject do: [ :number |		set2 add: number ].	self assert: subject isEquivalentToDictionary: copy.	self assert: copy isEquivalentToDictionary: controlGroup.	self assert: set1 = set2! !!TrieTest methodsFor: 'testing' stamp: 'jmv 6/21/2011 22:01'!testAllMesssagesLikeSet	"	TrieTest new testAllMesssagesLikeSet	"	| subject  controlGroup allMessages copy|	subject _ Trie new.	controlGroup _ Set new.	allMessages _ Smalltalk allImplementedMessages.	3 timesRepeat: [		allMessages do: [ :symbol |			subject add: symbol.			controlGroup add: symbol ]].	self assert: subject isEquivalentToSet: controlGroup.	copy _ Set new.	subject do: [ :symbol |		copy add: symbol ].	self assert: subject isEquivalentToSet: copy.	self assert: copy isEquivalentToSet: controlGroup.! !!TrieTest methodsFor: 'testing' stamp: 'jmv 6/22/2011 12:30'!testPrefixIteration	"	TrieTest new testPrefixIteration	"	| subject  controlGroup |	subject _ Trie new.	controlGroup _ Set new.	self assert: subject prefixSelection: '' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'c' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'ca' isEquivalentToSet: controlGroup.	subject add: 'car'.	controlGroup add: 'car'.	subject add: 'car'.	controlGroup add: 'car'.	subject add: 'cat'.	controlGroup add: 'cat'.	subject add: 'cart'.	controlGroup add: 'cart'.	self assert: subject prefixSelection: '' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'c' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'ca' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'car' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'cat' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'cart' isEquivalentToSet: controlGroup.	subject add: 'and'.	controlGroup add: 'and'.	subject add: 'andues'.	controlGroup add: 'andues'.	subject add: 'ANDSES'.	controlGroup add: 'ANDSES'.		self assert: subject prefixSelection: '' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'c' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'ca' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'car' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'cat' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'cart' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: '' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'an' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'andu' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'and' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: '' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'AND' isEquivalentToSet: controlGroup.! !!TrieTest methodsFor: 'testing' stamp: 'jmv 6/22/2011 12:50'!testPrefixIteration2	"	TrieTest new testPrefixIteration2	"	| subject  controlGroup allMsg toAvoid |	subject _ Trie new.	controlGroup _ Set new.	allMsg _ Smalltalk allImplementedMessages.	toAvoid _ (allMsg asArray collect: [ :each | each asLowercase asUnaccented ]) asBag.	allMsg do: [ :symbol |		(toAvoid occurrencesOf: symbol) = 1 ifTrue: [			subject add: symbol.			controlGroup add: symbol ]].		self assert: subject prefixSelection: '' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'a' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'at' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'at:' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'at:p' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'at:pu' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'at:put' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'at:put:' isEquivalentToSet: controlGroup.	self assert: subject prefixSelection: 'at:put:nonExistant:' isEquivalentToSet: controlGroup.! !!TrieTest methodsFor: 'testing' stamp: 'jmv 6/23/2011 11:02'!testRemoveLikeDicionary	"	TrieTest new testRemoveLikeDicionary	"	| subject  controlGroup allMessages copy c set1 set2 |	subject _ Trie new.	controlGroup _ Dictionary new.	allMessages _ Smalltalk allImplementedMessages.	subject at: 'doNotRemove' put: 'this'.	controlGroup at: 'doNotRemove' put: 'this'.		c _ 0.	3 timesRepeat: [		allMessages do: [ :symbol |			subject at: symbol put: c.			controlGroup at: symbol put: c.			c _ c + 1 ]].	subject at: 'doNotRemove2' put: 'this2'.	controlGroup at: 'doNotRemove2' put: 'this2'.	self assert: subject isEquivalentToDictionary: controlGroup.		allMessages do: [ :symbol |		subject removeKey: symbol.		controlGroup removeKey: symbol ].	copy _ Dictionary new.	set1 _ Set new.	subject keysAndValuesDo: [ :symbol :number |		copy at: symbol put: number.		set1 add: number ].	set2 _ Set new.	subject do: [ :number |		set2 add: number ].	self assert: subject isEquivalentToDictionary: copy.	self assert: copy isEquivalentToDictionary: controlGroup.	self assert: set1 = set2.	self assert: subject isEmpty = controlGroup isEmpty.	subject removeKey: 'doNotRemove'.	controlGroup removeKey: 'doNotRemove'.	self assert: subject isEquivalentToDictionary: controlGroup.	self deny: subject isEmpty.	self deny: controlGroup isEmpty.	subject removeKey: 'doNotRemove2'.	controlGroup removeKey: 'doNotRemove2'.	self assert: subject isEquivalentToDictionary: controlGroup.	self assert: subject isEmpty.	self assert: controlGroup isEmpty.! !!TrieTest methodsFor: 'testing' stamp: 'jmv 6/22/2011 15:54'!testRemoveLikeSet	"	TrieTest new testRemoveLikeSet	"	| subject  controlGroup allMessages copy |	subject _ Trie new.	controlGroup _ Set new.	allMessages _ Smalltalk allImplementedMessages.	subject add: 'doNotRemove'.	controlGroup add: 'doNotRemove'.		3 timesRepeat: [		allMessages do: [ :symbol |			subject add: symbol.			controlGroup add: symbol ]].	subject add: 'doNotRemove2'.	controlGroup add: 'doNotRemove2'.	self assert: subject isEquivalentToSet: controlGroup.		allMessages do: [ :symbol |		subject remove: symbol.		controlGroup remove: symbol ].	copy _ Set new.	subject do: [ :symbol |		copy add: symbol ].	self assert: subject isEquivalentToSet: copy.	self assert: copy isEquivalentToSet: controlGroup.	subject remove: 'doNotRemove'.	controlGroup remove: 'doNotRemove'.	self assert: subject isEquivalentToSet: controlGroup.	self deny: subject isEmpty.	self deny: controlGroup isEmpty.	subject remove: 'doNotRemove2'.	controlGroup remove: 'doNotRemove2'.	self assert: subject isEquivalentToSet: controlGroup.	self assert: subject isEmpty.	self assert: controlGroup isEmpty.! !!TrieTest methodsFor: 'testing' stamp: 'jmv 6/22/2011 15:42'!testSetProtocol	"	TrieTest new testSetProtocol	"	| subject  controlGroup |	subject _ Trie new.	controlGroup _ Set new.	self assert: subject isEquivalentToSet: controlGroup.		subject add: 'car'.	controlGroup add: 'car'.	self assert: subject isEquivalentToSet: controlGroup.	subject add: 'car'.	controlGroup add: 'car'.	self assert: subject isEquivalentToSet: controlGroup.	subject add: 'cat'.	controlGroup add: 'cat'.	self assert: subject isEquivalentToSet: controlGroup.	subject add: 'cart'.	controlGroup add: 'cart'.	self assert: subject isEquivalentToSet: controlGroup.	subject add: 'and'.	controlGroup add: 'and'.	self assert: subject isEquivalentToSet: controlGroup.	subject add: 'andu'.	controlGroup add: 'andu'.	self assert: subject isEquivalentToSet: controlGroup.	subject add: 'AND'.	controlGroup add: 'AND'.	self assert: subject isEquivalentToSet: controlGroup.! !!TrieTest methodsFor: 'aux' stamp: 'jmv 6/21/2011 22:05'!assert: subject isEquivalentToDictionary: controlGroup	"Test #size, #do:, "	| count subjectAsDictionary someRandomString |	self assert: subject isEmpty = controlGroup isEmpty.	self assert: subject size = controlGroup size.	controlGroup keysDo: [ :each |		self assert: (subject includesKey: each) ].	subject keysDo: [ :each |		self assert: (controlGroup includesKey: each) ].	controlGroup keysAndValuesDo: [ :k :v |		self assert: (subject at: k) = v ].	subject keysAndValuesDo: [ :k :v |		self assert: (controlGroup at: k) = v ].	someRandomString _ 'someRandomStringZZZ'.	self assert: (subject includesKey: someRandomString)		= (controlGroup includesKey: someRandomString).	subjectAsDictionary _ Dictionary new.	count _ 0.	subject keysAndValuesDo: [ :k :v |		subjectAsDictionary at: k put: v.		count _ count + 1 ].	self assert: subjectAsDictionary size = controlGroup size.	self assert: count = controlGroup size.	self assert: subjectAsDictionary = controlGroup.! !!TrieTest methodsFor: 'aux' stamp: 'jmv 6/15/2011 09:58'!assert: subject isEquivalentToSet: controlGroup	"Test #size, #do:, "	| count subjectAsSet someRandomString |	self assert: subject isEmpty = controlGroup isEmpty.	self assert: subject size = controlGroup size.	controlGroup do: [ :each |		self assert: (subject includes: each) ].	someRandomString _ 'someRandomStringZZZ'.	self assert: (subject includes: someRandomString)		= (controlGroup includes: someRandomString).	subjectAsSet _ Set new.	count _ 0.	subject do: [ :element |		subjectAsSet add: element.		count _ count + 1 ].	self assert: subjectAsSet size = controlGroup size.	self assert: count = controlGroup size.	self assert: subjectAsSet = controlGroup.! !!TrieTest methodsFor: 'aux' stamp: 'jmv 6/22/2011 12:51'!assert: subject prefixSelection: aString isEquivalentToSet: controlGroup	| selection1 selection2 |	selection1 _ OrderedCollection new.	subject forPrefix: aString keysAndValuesDo: [ :k :v |		selection1 add: k ].	selection2 _ (controlGroup select: [ :each |		aString isEmpty or: [			each asLowercase asUnaccented beginsWith: aString asLowercase asUnaccented]]) asOrderedCollection 				sort: [ :a :b | a asLowercase asUnaccented < b asLowercase asUnaccented ].	self assert: selection1 = selection2.! !!Workspace methodsFor: 'code pane menu' stamp: 'jmv 7/14/2011 14:15'!autoCompleter	^SmalltalkCompleter withModel: self! !SmalltalkCompleter initialize!BareTextMorph removeSelector: #autoCompletter:!!classDefinition: #BareTextMorph category: #'Morphic-Text Support'!Morph subclass: #BareTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking editView acceptOnCR hasUnacceptedEdits askBeforeDiscardingEdits styler autoCompleter'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."TrieNode indexIfCompact = 0 ifTrue: [ TrieNode becomeCompact ].TrieLeaf indexIfCompact = 0 ifTrue: [ TrieLeaf becomeCompact ].SmalltalkCompleter initialize.Editor initialize!