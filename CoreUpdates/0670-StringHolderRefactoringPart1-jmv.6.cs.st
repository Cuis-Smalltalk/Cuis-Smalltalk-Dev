'From Cuis 2.9 of 5 November 2010 [latest update: #634] on 24 November 2010 at 1:53:08 pm'!!StringHolder methodsFor: 'accessing' stamp: 'jmv 11/24/2010 11:53'!contents	"Answer the source code or documentation for the selected method"	^ Text		initialFont: Preferences standardCodeFont		stringOrText: self stringContents! !!StringHolder methodsFor: 'accessing' stamp: 'jmv 11/24/2010 10:59'!prvtContents	^contents! !!StringHolder methodsFor: 'accessing' stamp: 'jmv 11/24/2010 10:46'!prvtSetContents: z	^contents _ z! !!CodeHolder methodsFor: 'what to show' stamp: 'jmv 11/24/2010 10:44'!setContentsToForceRefetch	"Set the receiver's contents such that on the next update the contents will be formulated afresh.  This is a critical and obscure difference between Browsers on the one hand and MessageSets on the other, and has over the years been the source of much confusion and much difficulty.  By centralizing the different handling here, we don't need so many idiosyncratic overrides in MessageSet any more"	self prvtSetContents: nil! !!CodeHolder methodsFor: 'message list' stamp: 'jmv 11/24/2010 10:59'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			self prvtSetContents: (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [tempNames := (class compilerClass new						parse: method getSourceFromFile asString						in: class						notifying: nil) tempNames.			self prvtSetContents: ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	self prvtSetContents: (self prvtContents asText makeSelectorBoldIn: class).	^ self prvtContents copy! !!CodeHolder methodsFor: 'message list' stamp: 'jmv 11/24/2010 10:59'!selectedMessage	"Answer a copy of the source code for the selected message.  This generic version is probably actually never reached, since every subclass probably reimplements and does not send to super.  In time, ideally, most, or all, reimplementors would vanish and all would defer instead to a universal version right here.  Everything in good time."	| class selector method |	self prvtContents ifNotNil: [ :c | ^ c copy].	self showingDecompile ifTrue:		[^ self decompiledSourceIntoContentsWithTempNames: false ].	class _ self selectedClassOrMetaClass.	(class isNil or: [(selector _ self selectedMessageName) isNil]) ifTrue: [^ ''].	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	^ self prvtSetContents: ((self showComment		ifFalse: [self sourceStringPrettifiedAndDiffed]		ifTrue:	[ self commentContents])			copy asText makeSelectorBoldIn: class)! !!Browser methodsFor: 'class list' stamp: 'jmv 11/24/2010 10:45'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className |	classListIndex _ anInteger.	self setClassOrganizer.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self classCommentIndicated		ifFalse: [self editSelection: (anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex = 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass])].	self prvtSetContents: nil.	self selectedClass		ifNotNil: [			className _ self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classCommentText.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!Browser methodsFor: 'initialize-release' stamp: 'jmv 11/24/2010 10:45'!systemOrganizer: aSystemOrganizer	"Initialize the receiver as a perspective on the system organizer, 	aSystemOrganizer. Typically there is only one--the system variable 	SystemOrganization."	self prvtSetContents: nil.	systemOrganizer _ aSystemOrganizer.	systemCategoryListIndex _ 0.	classListIndex _ 0.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	metaClassIndicated _ false.	self setClassOrganizer.	self editSelection: #none.! !!Browser methodsFor: 'message category list' stamp: 'jmv 11/24/2010 10:45'!messageCategoryListIndex: anInteger	"Set the selected message category to be the one indexed by anInteger."	messageCategoryListIndex _ anInteger.	messageListIndex _ 0.	self changed: #messageCategorySelectionChanged.	self changed: #messageCategoryListIndex. "update my selection"	self changed: #messageList.	self editSelection: (anInteger > 0		ifTrue: [#newMessage]		ifFalse: [self classListIndex > 0			ifTrue: [#editClass]			ifFalse: [#newClass]]).	self prvtSetContents: nil.	self contentsChanged.! !!Browser methodsFor: 'message functions' stamp: 'jmv 11/24/2010 10:49'!defineMessageFrom: aString notifying: aController	"Compile the expressions in aString. Notify aController if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."	| selectedMessageName selector category oldMessageList |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	self prvtSetContents: nil.	selector _ (Smalltalk actualParserClass new parseSelector: aString).	(self metaClassIndicated		and: [(self selectedClassOrMetaClass includesSelector: selector) not		and: [Metaclass isScarySelector: selector]])		ifTrue: ["A frist-time definition overlaps the protocol of Metaclasses"				(self confirm: ((selector , ' is used in the existing class system.Overriding it could cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: selector size))				ifFalse: [^nil]].	selector _ self selectedClassOrMetaClass				compile: aString				classified: (category _ self selectedMessageCategoryName)				notifying: aController.	selector		ifNil: [^ nil].	self prvtSetContents: aString copy.	selector ~~ selectedMessageName		ifTrue: 			[category = ClassOrganizer nullCategory				ifTrue: [self changed: #classSelectionChanged.						self changed: #classList.						self messageCategoryListIndex: 1].			self setClassOrganizer.  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self changed: #messageList].			self messageListIndex: (self messageList indexOf: selector)].	^ selector! !!Browser methodsFor: 'message list' stamp: 'jmv 11/24/2010 10:59'!selectedMessage	"Answer a copy of the source code for the selected message."	| class selector method |	self prvtContents		ifNotNil: [ :c | ^ c copy].	self showingDecompile ifTrue: [		^ self decompiledSourceIntoContentsWithTempNames: false ].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector ifAbsent: [^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	^ self prvtSetContents: ((self showingDocumentation		ifFalse: [ self sourceStringPrettifiedAndDiffed ]		ifTrue: [ self commentContents ])			copy asText makeSelectorBoldIn: class)! !!Browser methodsFor: 'metaclass' stamp: 'jmv 11/24/2010 10:45'!metaClassIndicated: trueOrFalse 	"Indicate whether browsing instance or class messages."	metaClassIndicated _ trueOrFalse.	self setClassOrganizer.	systemCategoryListIndex > 0 ifTrue:		[self editSelection: (classListIndex = 0			ifTrue: [metaClassIndicated				ifTrue: [#none]				ifFalse: [#newClass]]			ifFalse: [#editClass])].	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self prvtSetContents: nil.	self changed: #classSelectionChanged.	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #contents.	self changed: #annotation.	self decorateButtons! !!Browser methodsFor: 'system category list' stamp: 'jmv 11/24/2010 10:45'!systemCategoryListIndex: anInteger 	"Set the selected system category index to be anInteger. Update all other 	selections to be deselected."	systemCategoryListIndex _ anInteger.	classListIndex _ 0.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self editSelection: ( anInteger = 0 ifTrue: [#none] ifFalse: [#newClass]).	metaClassIndicated _ false.	self setClassOrganizer.	self prvtSetContents: nil.	self changed: #systemCategorySelectionChanged.	self changed: #systemCategoryListIndex.	"update my selection"	self changed: #classList.	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!ChangeSorter methodsFor: 'creation' stamp: 'jmv 11/24/2010 10:48'!openAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| csListHeight msgListHeight csMsgListHeight |	self prvtSetContents: ''.	csListHeight _ 0.25.	msgListHeight _ 0.25.	csMsgListHeight _ csListHeight + msgListHeight.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: ((PluggableListMorphByItem 				model: self				listGetter: #changeSetList				indexGetter: #currentCngSet				indexSetter: #showChangeSetNamed:				menuGetter: #changeSetMenu:shifted:				keystrokeAction: #changeSetListKey:from:)			autoDeselect: false)		frame: (((0@0 extent: 0.5@csListHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #classList				indexGetter: #currentClassName				indexSetter: #currentClassName:				menuGetter: #classListMenu:shifted:				keystrokeAction: #classListKey:from:)		frame: (((0.5@0 extent: 0.5@csListHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #messageList				indexGetter: #currentSelector				indexSetter: #currentSelector:				menuGetter: #messageMenu:shifted:				keystrokeAction: #messageListKey:from:)		frame: (((0@csListHeight extent: 1@msgListHeight)			scaleBy: rect extent) translateBy: rect origin).	 self addLowerPanesTo: window		at: (((0@csMsgListHeight corner: 1@1) scaleBy: rect extent) translateBy: rect origin)		with: nil.! !!ChangeSorter methodsFor: 'code pane' stamp: 'jmv 11/24/2010 11:00'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ self prvtSetContents: (myChangeSet preambleString ifNil: [''])].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector)		ifNotNil: [			changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ self prvtSetContents: 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ self prvtSetContents: 'Added then removed (see versions)'].			class ifNil: [^ self prvtSetContents: 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ self prvtSetContents: 'Method was added, but cannot be found!!'].			self prvtSetContents:  (class sourceCodeAt: sel).			(#(prettyPrint prettyLineDiffs prettyWordDiffs) includes: contentsSymbol) ifTrue: [				self prvtSetContents: (class compilerClass new						format: self prvtContents 						in: class 						notifying: nil)].			self showingAnyKindOfDiffs				ifTrue: [ self prvtSetContents: (self diffFromPriorSourceFor: self prvtContents) ].			^ self prvtSetContents: (self prvtContents asText makeSelectorBoldIn: class) ]		ifNil: 			[strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ self prvtSetContents: strm contents].! !!ChangeSetBrowser methodsFor: 'initialization' stamp: 'jmv 11/24/2010 10:48'!openAsMorphIn: window rect: rect	"Add a set of changeSetBrowser views to the given top view offset by the given amount"	| aHeight |	self prvtSetContents: ''.	aHeight _ 0.25.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #classList				indexGetter: #currentClassName				indexSetter: #currentClassName:				menuGetter: #classListMenu:shifted:				keystrokeAction: #classListKey:from:)		frame: (((0.0@0 extent: 0.5 @ aHeight)			scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableListMorphByItem 				model: self				listGetter: #messageList				indexGetter: #currentSelector				indexSetter: #currentSelector:				menuGetter: #messageMenu:shifted:				keystrokeAction: #messageListKey:from:)		frame: (((0.5@0 extent: 0.5 @ aHeight)			scaleBy: rect extent) translateBy: rect origin).	 self addLowerPanesTo: window		at: (((0@aHeight corner: 1@1) scaleBy: rect extent) translateBy: rect origin)		with: nil! !!Debugger methodsFor: 'accessing' stamp: 'jmv 11/24/2010 10:54'!contents: aText notifying: aController	"The retrieved information has changed and its source must now be updated.	 In this case, the retrieved information is the method of the selected context."	| result selector classOfMethod category h ctxt newMethod |	contextStackIndex = 0 ifTrue:		[^false].	self selectedContext isExecutingBlock ifTrue:		[h := self selectedContext activeHome.		 h ifNil:			[self inform: 'Method for block not found on stack, can''t edit and continue'.			 ^false].		 (self confirm: 'I will have to revert to the method from\which this block originated.  Is that OK?' withCRs) ifFalse:			[^false].		self resetContext: h.		result := self contents: aText notifying: aController.		self contentsChanged.		^result].	classOfMethod := self selectedClass.	category := self selectedMessageCategoryName.	selector := self selectedClass parserClass new parseSelector: aText.	(selector == self selectedMessageName	 or: [(self selectedMessageName beginsWith: 'DoIt')		and: [selector numArgs = self selectedMessageName numArgs]]) ifFalse:		[self inform: 'can''t change selector'.		 ^false].	selector := classOfMethod				compile: aText				classified: category				notifying: aController.	selector ifNil: [^false]. "compile cancelled"	self prvtSetContents: aText.	newMethod := classOfMethod compiledMethodAt: selector.	newMethod isQuick ifTrue:		[self down.		 self selectedContext jump: (self selectedContext previousPc - self selectedContext pc)].	ctxt := interruptedProcess popTo: self selectedContext.	ctxt == self selectedContext		ifFalse:			[self inform: 'Method saved, but current context unchanged\because of unwind error. Click OK to see error' withCRs]		ifTrue:			[newMethod isQuick ifFalse:				[interruptedProcess					restartTopWith: newMethod;				 	stepToSendOrReturn].			contextVariablesInspector object: nil].	self resetContext: ctxt.	World		addAlarm: #changed:		withArguments: #(contentsSelection)		for: self		at: (Time millisecondClockValue + 200).	^true! !!Debugger methodsFor: 'accessing' stamp: 'jmv 11/24/2010 11:30'!stringContents 	"Depending on the current selection, different information is retrieved.	Answer a string description of that information.  This information is the	method in the currently selected context."	self prvtContents ifNotNil: [ :c | ^ c copy ].	^ String new! !!Debugger methodsFor: 'context stack (message list)' stamp: 'jmv 11/24/2010 10:51'!selectedMessage	"Answer the source code of the currently selected context."	^self prvtSetContents: self selectedContext debuggerMap sourceText asText makeSelectorBold! !!Debugger methodsFor: 'private' stamp: 'jmv 11/24/2010 10:55'!contextStackIndex: anInteger oldContextWas: oldContext 	"Change the context stack index to anInteger, perhaps in response to user selection."	| isNewMethod selectedContextSlotName index |	contextStackIndex := anInteger.	anInteger = 0 ifTrue: [		self prvtSetContents: nil.		currentCompiledMethod := nil.		self changed: #contextStackIndex.		self decorateButtons.		self contentsChanged.		contextVariablesInspector object: nil.		receiverInspector object: self receiver.		^self].	selectedContextSlotName := contextVariablesInspector selectedSlotName.	isNewMethod := oldContext == nil					or: [oldContext method ~~ (currentCompiledMethod := self selectedContext method)].	isNewMethod ifTrue: [		self prvtSetContents: self selectedMessage.		self contentsChanged.		 self pcRange].	self changed: #contextStackIndex.	self decorateButtons.	contextVariablesInspector object: self selectedContext.	((index := contextVariablesInspector fieldList indexOf: selectedContextSlotName) ~= 0	 and: [index ~= contextVariablesInspector selectionIndex]) ifTrue: [		contextVariablesInspector toggleIndex: index].	receiverInspector object: self receiver.	isNewMethod ifFalse: [		self changed: #contentsSelection]! !!Debugger methodsFor: 'private' stamp: 'jmv 11/24/2010 10:51'!process: aProcess controller: aController context: aContext	super initialize.	Smalltalk at: #MessageTally ifPresentAndInMemory: [ :c | c terminateTimerProcess ].	self prvtSetContents: nil. 	interruptedProcess _ aProcess.	contextStackTop _ aContext.	self newStack: (contextStackTop stackOfSize: 1).	contextStackIndex _ 1.	externalInterrupt _ false.	selectingPC _ true.	errorWasInUIProcess _ false! !!FileContentsBrowser methodsFor: 'edit pane' stamp: 'jmv 11/24/2010 11:00'!selectedBytecodes	"Compile the source code for the selected message selector and extract and return	the bytecode listing."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	self prvtSetContents: (class sourceCodeAt: selector).	self prvtSetContents: (Smalltalk actualCompilerClass new					parse: self prvtContents					in: class					notifying: nil).	self prvtSetContents: (self prvtContents generate: #(0 0 0 0)).	^ self prvtContents symbolic asText! !!FileContentsBrowser methodsFor: 'edit pane' stamp: 'jmv 11/24/2010 11:00'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	self prvtSetContents: (class sourceCodeAt: selector).	Preferences browseWithPrettyPrint ifTrue: [		self prvtSetContents: (Smalltalk actualCompilerClass new					format: self prvtContents					in: class					notifying: nil)].	self showingAnyKindOfDiffs ifTrue: [		self prvtSetContents: (self			methodDiffFor: self prvtContents			class: self selectedClass			selector: self selectedMessageName			meta: self metaClassIndicated)].	^ self prvtContents asText makeSelectorBoldIn: class! !!FileList methodsFor: 'initialization' stamp: 'jmv 11/24/2010 10:53'!initialize	self prvtSetContents: self defaultContents! !!FileList methodsFor: 'private' stamp: 'jmv 11/24/2010 11:02'!defaultContents	self prvtSetContents: (list		ifNil: [String new]		ifNotNil: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED' translated; cr.					s nextPutAll: '  -- Folder Summary --' translated; cr.					list do: [:item | s nextPutAll: item; cr]]]).	brevityState _ #FileList.	^ self prvtContents! !!FileList methodsFor: 'private' stamp: 'jmv 11/24/2010 10:54'!put: aText	"Private - put the supplied text onto the file"	| ff type |	brevityState == #fullFile ifTrue:		[ff _ directory newFileNamed: self fullName.		Cursor write showWhile: [ff nextPutAll: aText asString; close].		fileName = ff localName 			ifTrue: [ self prvtSetContents: aText asString]			ifFalse: [self updateFileList].		"user renamed the file"		^ true  "accepted"].	listIndex = 0 ifTrue:		[self inform: 'No fileName is selected' translated.		^ false  "failed"].	type _ 'These'.	brevityState = #briefFile ifTrue: [type _ 'Abbreviated'].	brevityState = #briefHex ifTrue: [type _ 'Abbreviated'].	brevityState = #fullHex ifTrue: [type _ 'Hexadecimal'].	brevityState = #FileList ifTrue: [type _ 'Directory'].	self inform: ('{1} contents cannotmeaningfully be saved at present.' translated format:{type translated}).	^ false  "failed"! !!FileList methodsFor: 'private' stamp: 'jmv 11/24/2010 11:03'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	brevityFlag ifTrue: [		directory isRemoteDirectory ifTrue: [^ self readServerBrief]].	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read' translated].	(brevityFlag not or: [(fileSize := f size) <= 100000]) ifTrue: [		self prvtSetContents: f contentsOfEntireFile.		brevityState := #fullFile.   "don't change till actually read"		^ self prvtContents].	"if brevityFlag is true, don't display long files when first selected"	first5000 := f next: 5000.	f close.	self prvtSetContents: ('File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' translated format: {fileName. fileSize. first5000}).	brevityState := #briefFile.   "don't change till actually read"	^ self prvtContents! !!FileList methodsFor: 'private' stamp: 'jmv 11/24/2010 10:55'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f := directory oldFileOrNoneNamed: self fullName. 	f ifNil: [^ 'For some reason, this file cannot be read' translated].	((size := f size)) > 5000 & brevity		ifTrue: [data := f next: 10000. f close. brevityState := #briefHex]		ifFalse: [data := f contentsOfEntireFile. brevityState := #fullHex].	s := WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData := s contents.	^ self prvtSetContents: ((size > 5000) & brevity		ifTrue: ['File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' translated format: {fileName. size. hexData}]		ifFalse: [hexData])! !!FileList methodsFor: 'private' stamp: 'jmv 11/24/2010 11:03'!readServerBrief	| lString sizeStr fsize ff first5000 parts |	"If file on server is known to be long, just read the beginning.  Cheat badly by reading the fileList string."	listIndex = 0 ifTrue: [^ self].	"Get size from file list entry"	lString := list at: listIndex.	parts := lString findTokens: '()'.	sortMode = #name ifTrue: [sizeStr := (parts second findTokens: ' ') third].	sortMode = #date ifTrue: [sizeStr := (parts first findTokens: ' ') third].	sortMode = #size ifTrue: [sizeStr := (parts first findTokens: ' ') first].	fsize := (sizeStr copyWithout: $,) asNumber.	fsize <= 50000 ifTrue:		[ff := directory oldFileOrNoneNamed: self fullName.		ff ifNil: [^ 'For some reason, this file cannot be read' translated].		self prvtSetContents: ff contentsOfEntireFile.		brevityState := #fullFile.   "don't change till actually read"		^ self prvtContents].	"if brevityFlag is true, don't display long files when first selected"	first5000 := directory getOnly: 3500 from: fileName.	self prvtSetContents: ('File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 3500 characters...------------------------------------------{3}------------------------------------------... end of the first 3500 characters.' translated format: {fileName. sizeStr. first5000}).	brevityState := #briefFile.   "don't change till actually read"	^ self prvtContents.! !!FileList methodsFor: 'private' stamp: 'jmv 11/24/2010 11:02'!stringContents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ self prvtContents].	brevityState == #fullHex ifTrue: [^ self prvtContents].	brevityState == #briefFile ifTrue: [^ self prvtContents].	brevityState == #briefHex ifTrue: [^ self prvtContents].	brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'private' stamp: 'jmv 11/24/2010 10:53'!updateFileList	"Update my files list with file names in the current directory  	that match the pattern.	The pattern string may have embedded newlines or semicolons; these separate different patterns."	| patterns |	patterns _ OrderedCollection new.	Cursor wait showWhile: [	(pattern findTokens: (String with: Character cr with: Character lf with: $;))		do: [ :each |			(each includes: $*) | (each includes: $#)					ifTrue: [ patterns add: each]					ifFalse: [each isEmpty										ifTrue: [ patterns add: '*']										ifFalse: [ patterns add: '*' , each , '*']]].	list _ self listForPatterns: patterns.	listIndex _ 0.	volListIndex _ volList size.	fileName _ nil.	self prvtSetContents: ''.	self changed: #volumeListIndex.	self changed: #fileList.	self updateButtonRow]! !!Inspector methodsFor: 'accessing' stamp: 'jmv 11/24/2010 11:02'!modelWakeUpIn: aWindow	| newText |	self updateListsAndCodeIn: aWindow.	newText _ self contentsIsString		ifTrue: [ newText _ self selection ]		ifFalse: [			"keep it short to reduce time to compute it"			self selectionPrintString ].	newText = self prvtContents ifFalse: [		self prvtSetContents: newText.		self changed: #contents]! !!Inspector methodsFor: 'accessing' stamp: 'jmv 11/24/2010 10:52'!update	"Reshow contents, assuming selected value may have changed."	selectionIndex = 0		ifFalse: [			self contentsIsString				ifTrue: [ self prvtSetContents: self selection]				ifFalse: [ self prvtSetContents: self selectionPrintString].			self changed: #contents.			self changed: #selection.			self changed: #selectionIndex]! !!Inspector methodsFor: 'selecting' stamp: 'jmv 11/24/2010 10:52'!accept: aString	| result |	result _ self doItReceiver class evaluatorClass new				evaluate: (ReadStream on: aString)				in: self doItContext				to: self doItReceiver				notifying: nil	"fix this"				ifFail:  [^ false].	result == #failedDoit ifFalse: [			self prvtSetContents: result printString.			self replaceSelectionValue: result.	"may put contents back"			self changed: #contents.			^ true].	^ false! !!Inspector methodsFor: 'selecting' stamp: 'jmv 11/24/2010 10:51'!toggleIndex: anInteger	"The receiver has a list of variables of its inspected object. One of these 	is selected. If anInteger is the index of this variable, then deselect it. 	Otherwise, make the variable whose index is anInteger be the selected 	item."	selectionUpdateTime _ 0.	selectionIndex = anInteger		ifTrue: [			"same index, turn off selection"			selectionIndex _ 0.			self prvtSetContents: '']		ifFalse: [			"different index, new selection"			selectionIndex _ anInteger.			self contentsIsString				ifTrue: [ self prvtSetContents:  self selection]				ifFalse: [ self prvtSetContents:  self selectionPrintString]].	self changed: #selection.	self changed: #contents.	self changed: #selectionIndex.! !!Inspector methodsFor: 'stepping' stamp: 'jmv 11/24/2010 11:02'!stepAt: millisecondClockValue in: aWindow	| newText |	(Preferences smartUpdating and: [(millisecondClockValue - self timeOfLastListUpdate) > 8000]) "Not more often than once every 8 seconds"		ifTrue: [			self updateListsAndCodeIn: aWindow.			timeOfLastListUpdate := millisecondClockValue].	newText := self contentsIsString		ifTrue: [self selection]		ifFalse: ["keep it short to reduce time to compute it"			self selectionPrintString ].	newText = self prvtContents ifFalse: [		self prvtSetContents: newText.		self changed: #contents]! !!BasicInspector methodsFor: 'as yet unclassified' stamp: 'jmv 11/24/2010 10:53'!inspect: anObject 	"Initialize the receiver so that it is inspecting anObject. There is no 	current selection."	self initialize.	object _ anObject.	selectionIndex _ 0.	self prvtSetContents: ''! !!DictionaryInspector methodsFor: 'menu' stamp: 'jmv 11/24/2010 10:52'!removeSelection	selectionIndex = 0 ifTrue: [^ self changed: #flash].	object removeKey: (keyArray at: selectionIndex - self numberOfFixedFields).	selectionIndex := 0.	self prvtSetContents: ''.	self calculateKeyArray.	self changed: #inspectObject.	self changed: #selectionIndex.	self changed: #fieldList.	self changed: #selection.! !!MessageSet methodsFor: 'contents' stamp: 'jmv 11/24/2010 10:48'!setContentsToForceRefetch	"Set the receiver's contents such that on the next update the contents will be formulated afresh.  This is a critical and obscure difference between Browsers on the one hand and MessageSets on the other, and has over the years been the source of much confusion and much difficulty.  By centralizing the different handling here, we don't need so many idiosyncratic overrides in MessageSet any more"	self prvtSetContents: ''! !!MessageSet methodsFor: 'contents' stamp: 'jmv 11/24/2010 11:00'!stringContents	"Answer the contents of the receiver"	^ self prvtContents		ifNil: [ currentCompiledMethod _ nil. '' ]		ifNotNil: [ messageListIndex = 0 			ifTrue: [ currentCompiledMethod _ nil. self prvtContents]			ifFalse: [ self showingByteCodes				ifTrue: [ self selectedBytecodes]				ifFalse: [ self selectedMessage]]]! !!MessageSet methodsFor: 'private' stamp: 'jmv 11/24/2010 10:47'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	self okayToAccept ifFalse: [^ false].	self setClassAndSelectorIn: [:c :os | class _ c.  oldSelector _ os].	class ifNil: [^ false].	(oldSelector notNil and: [oldSelector first isUppercase]) ifTrue:		[oldSelector = #Comment ifTrue:			[class comment: aString stamp: Utilities changeStamp.			self changed: #annotation. 			self clearUserEditFlag.			^ false].		oldSelector = #Definition ifTrue:			["self defineClass: aString notifying: aController."			class subclassDefinerClass				evaluate: aString				notifying: aController				logged: true.			self clearUserEditFlag. 			^ false].		oldSelector = #Hierarchy ifTrue:			[self inform: 'To change the hierarchy, edit the class definitions'. 			^ false]].	"Normal method accept"	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector		ifNil: [^ false].	selector == oldSelector ifFalse:		[self reformulateListNoting: selector].	self prvtSetContents: aString copy.	self changed: #annotation.	^ true! !!MessageSet methodsFor: 'private' stamp: 'jmv 11/24/2010 10:47'!initializeMessageList: anArray	| s |	messageList _ OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel |				class ifNotNil: [					s _ class name , ' ' , sel , ' {' , ((class organization categoryOfElement: sel) ifNil: ['']) , '}'.					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s) ]]].	messageListIndex _ messageList isEmpty ifTrue: [0 ] ifFalse: [1].	self prvtSetContents: ''! !!SetInspector methodsFor: 'menu' stamp: 'jmv 11/24/2010 10:53'!removeSelection	(selectionIndex <= object class instSize) ifTrue: [^ self changed: #flash].	object remove: self selection.	selectionIndex := 0.	self prvtSetContents: ''.	self changed: #inspectObject.	self changed: #fieldList.	self changed: #selection.	self changed: #selectionIndex.! !!SyntaxError methodsFor: 'initialization' stamp: 'jmv 11/24/2010 10:44'!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	| types printables badChar |	class _ aClass.	debugger _ aDebugger.	selector _ aClass parserClass new parseSelector: aString.	types _ Smalltalk actualScannerClass classPool at: #TypeTable.	"dictionary"	printables _ '!!@#$%&*-_=+<>{}?/\,•£¢§¶ªº–—“‘”’…ÚæÚ¯˘¿«»`~`' asSet.	badChar := aString detect: [:aChar | (types at: aChar asciiValue ifAbsent: [#xLetter]) == #xBinary and: [			(printables includes: aChar) not]] ifNone: nil.	self prvtSetContents: (badChar 		ifNil: [aString]		ifNotNil: ['<<<This string contains a character (ascii value ', 			badChar asciiValue printString,			') that is not normally used in code>>> ', aString]).	category ifNil: [category _ aClass organization categoryOfElement: selector].	category ifNil: [category _ ClassOrganizer default].	doitFlag _ flag! !!TimeProfileBrowser methodsFor: 'private' stamp: 'jmv 11/24/2010 10:48'!initializeMessageList: anArray	messageList _ anArray.	messageListIndex _ 0.	self prvtSetContents: ''! !!TimeProfileBrowser methodsFor: 'private' stamp: 'jmv 11/24/2010 10:49'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])  "	self flag: #mref.	"fix for faster references to methods"	^[		| string strm class sel parens |		string _ self selection asString.		string first == $* ifTrue: [ ^self prvtSetContents: nil ].		"Ignore lines starting with *"		parens := string includes: $(.					"Does it have open-paren?"		strm := ReadStream on: string.		parens			ifTrue: [				strm skipTo: $(.		"easy case"				class := strm upTo: $).				strm next: 2.				sel := strm upToEnd ]			ifFalse: [				strm position: (string findString: ' class>>').				strm position > 0					ifFalse: [strm position: (string findLast: [ :ch | ch == $ ])]					ifTrue: [						| subString |  "find the next to last space character"						subString := strm contents copyFrom: 1 to: (string findLast: [ :ch | ch == $ ]) - 1.						strm position: (subString findLast: [ :ch | ch == $ ])].				class := strm upTo: $>.				strm next.				sel := strm upToEnd ].		MessageSet parse: (class, ' ', sel) toClassAndSelector: csBlock	]		on: Error 		do: [ :ex | self prvtSetContents: nil ]! !!Workspace methodsFor: 'menu commands' stamp: 'jmv 11/24/2010 11:02'!appendContentsOfFile	"Prompt for a file, and if one is obtained, append its contents to the contents of the receiver.   Caution: as currently implemented this abandons any custom style information previously in the workspace.  Someone should fix this.  Also, for best results you should accept the contents of the workspace before requesting this."	| aFileStream |	(aFileStream _ FileList2 modalFileSelector) ifNil: [^ self].	self prvtSetContents: (self prvtContents ifNil: ['']) asString, aFileStream contentsOfEntireFile.	aFileStream close.	self changed: #contents! !Debugger removeSelector: #contents!CodeHolder removeSelector: #contents!