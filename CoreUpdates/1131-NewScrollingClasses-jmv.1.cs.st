'From Cuis 3.3 of 2 June 2011 [latest update: #1024] on 14 November 2011 at 3:18:30 pm'!!classDefinition: #InnerHierarchicalListMorph category: #'Morphic-Support'!Morph subclass: #InnerHierarchicalListMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!classDefinition: #InnerListMorph category: #'Morphic-Support'!Morph subclass: #InnerListMorph	instanceVariableNames: 'listItems font selectedRow selectedRows listSource'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Support'!!InnerListMorph commentStamp: '<historical>' prior: 0!                       The morph that displays the list in a PluggableListMorph.  It is "lazy" because it will only request the list items that it actually needs to display.!!classDefinition: #InnerTextMorph category: #'Morphic-Text Support'!Morph subclass: #InnerTextMorph	instanceVariableNames: 'model wrapFlag paragraph editor pauseBlinking editView acceptOnCR hasUnacceptedEdits askBeforeDiscardingEdits styler autoCompleter'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!!InnerTextMorph commentStamp: '<historical>' prior: 0!                            BareTextMorphs support display of text with emphasis.  They also support reasonable text-editing capabilities, as well as embedded hot links, and the ability to embed submorphs in the text. They are 'bare' in the sense that they can not clip contents to some window, or scroll it by themselves.Text display is clipped to the innerBounds of the rectangle, and text composition is normally performed within a rectangle which is innerBounds inset by the margins parameter.Comment about Shout specifics:-----------------------------------------Instances of me are usually created using my #on:text:accept:readSelection:menu: class method.In order to colour the text, I use an instance of SHTextStylerST80, which I store in my 'styler' instance variable.When my setText: method is called, I use my styler to ...	a) optionally set all assignments to ansi or leftArrow. 	b) Colour my text (immediately, if the text is less than 4096 chars in length, or in a backgroundProcess otherwise)	When my text is changed, my hasUnacceptedEdits: method is called with true, and I ask my styler to re-colour my text. This is performed in a background process so that typing remains responsive regardless of the length of the text.	Just before my styler is about to format/style the text, I send #stylerAboutToStyle:  to my model. This gives my model a chance to veto the styling (by answering false), or to initialize the styler with information it needs in order to parse the text correctly (e.g. the class to which a method belongs, or the workspace in which I am contained).	My styler informs me that it has finished styling by triggering the #stylerStyled: and #stylerStyledInBackground: events which I handle. I then update the textAttributes of my text and refresh the display. 	My 'unstyledAcceptText' instance variable is used in conjunction with my #acceptTextInModel and #correctFrom:to:with: methods to ensure that when my text is modified during a method compilation (removing unused vars etc), I do not lose those changes.!!classDefinition: #PluggableScrollPane category: #'Morphic-Views for Models'!PluggableMorph subclass: #PluggableScrollPane	instanceVariableNames: 'scrollBar scroller hScrollBar hideScrollBars currentScrollRange drawKeyboardFocusIndicator'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!PluggableScrollPane commentStamp: '<historical>' prior: 0!      The scroller (a transform) of a scrollPane is driven by the scrollBar. The scroll values vary from 0.0 to 1.0.!!classDefinition: #HierarchicalListMorph category: #'Morphic-Views for Models'!PluggableScrollPane subclass: #HierarchicalListMorph	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect columns sortingSelector getSelectionSelector setSelectionSelector lineColor menuGetter mainView'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!HierarchicalListMorph commentStamp: '<historical>' prior: 0!                         Display a hierarchical list of items.  Each item should be wrapped with a ListItemWrapper.For a simple example, look at submorphsExample.  For beefier examples, look at ObjectExplorer or FileList2.!!classDefinition: #PluggableListMorph2 category: #'Morphic-Views for Models'!PluggableScrollPane subclass: #PluggableListMorph2	instanceVariableNames: 'list getListSelector getListSizeSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes doubleClickSelector listMorph menuGetter mainView'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!PluggableListMorph2 commentStamp: '<historical>' prior: 0!      ...When a PluggableListMorph is in focus, type in a letter (or severalletters quickly) to go to the next item that begins with that letter.Special keys (up, down, home, etc.) are also supported.!!classDefinition: #PluggableListMorphByItem2 category: #'Morphic-Views for Models'!PluggableListMorph2 subclass: #PluggableListMorphByItem2	instanceVariableNames: 'itemList'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!classDefinition: #PluggableListMorphOfMany2 category: #'Morphic-Views for Models'!PluggableListMorph2 subclass: #PluggableListMorphOfMany2	instanceVariableNames: 'dragOnOrOff getSelectionListSelector setSelectionListSelector dragStartRow'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!PluggableListMorphOfMany2 commentStamp: '<historical>' prior: 0!        A variant of its superclass that allows multiple items to be selected simultaneously.  There is still a distinguished element which is selected, but each other element in the list may be flagged on or off.!!classDefinition: #PluggableMessageCategoryListMorph2 category: #'Morphic-Views for Models'!PluggableListMorph2 subclass: #PluggableMessageCategoryListMorph2	instanceVariableNames: 'getRawListSelector priorRawList'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!PluggableMessageCategoryListMorph2 commentStamp: '<historical>' prior: 0!                     A variant of PluggableListMorph designed specially for efficient handling of the --all-- feature in message-list panes.  In order to be able *quickly* to check whether there has been an external change to the list, we cache the raw list for identity comparison (the actual list is a combination of the --all-- element and the the actual list).!!classDefinition: #TextModelMorph2 category: #'Morphic-Views for Models'!PluggableScrollPane subclass: #TextModelMorph2	instanceVariableNames: 'textMorph hasEditingConflicts'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!TextModelMorph2 commentStamp: '<historical>' prior: 0!       The main morph for text editors!!classDefinition: #BrowserCommentTextMorph2 category: #'Morphic-Views for Models'!TextModelMorph2 subclass: #BrowserCommentTextMorph2	instanceVariableNames: 'separator separatorHeight proportionalHeight'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!BrowserCommentTextMorph2 commentStamp: '<historical>' prior: 0!                         I am a TextModelMorph that knows enough to make myself invisible when necessary.!!classDefinition: #LimitedHeightTextMorph2 category: #'Morphic-Views for Models'!TextModelMorph2 subclass: #LimitedHeightTextMorph2	instanceVariableNames: 'maxHeight'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Views for Models'!!LimitedHeightTextMorph2 commentStamp: '<historical>' prior: 0!              A TextMorph that will expand and contract vertically to adjust for the contents, but limited to a specific max height. If contents are larger, a scrollbar will be used.LimitedHeightTextMorph new	maxHeight: 48;	model: (TextModel new contents: 'This is some text to test the morph.');	openInWorld!!InnerHierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'jmv 11/14/2011 14:15'!                    adjustExtent"no aun... en un rato"self extent: (self desiredWidth @ self desiredHeight)! !!InnerHierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'jmv 11/14/2011 10:51'!     defaultColor	^Color transparent! !!InnerHierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'jmv 11/14/2011 10:54'!                              desiredHeight	"fulerote..."	self flag: #jmvVer.	(submorphs size > 0) ifFalse:[ ^0 ].	^submorphs last fullBounds bottom - bounds top! !!InnerHierarchicalListMorph methodsFor: 'as yet unclassified' stamp: 'jmv 11/14/2011 14:55'!                      desiredWidth	^submorphs inject: 0 into: [ :previousValue :each |		previousValue max: each desiredWidth ]! !!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 11/9/2011 17:56'!     initialize	super initialize.	self color: Color black.	font _ Preferences standardListFont.	listItems _ #().	selectedRow _ nil.	selectedRows _ Set new.	self adjustHeight.! !!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 11/9/2011 17:56'!listSource: aListSource	"set the source of list items -- typically a PluggableListMorph"	listSource := aListSource.	self listChanged! !!InnerListMorph methodsFor: 'list management' stamp: 'jmv 11/11/2011 11:05'!       drawBoundsForRow: row	"calculate the bounds that row should be drawn at.  This might be outside our bounds!!"	| topLeft drawBounds |self flag: #jmvVer.true & false ifTrue: [	topLeft _0 @ ( ((row - 1) * (font height))).] ifFalse: [	topLeft _ bounds left @ (bounds top + ((row - 1) * (font height))).].	drawBounds _ topLeft extent: bounds width @ font height.	^drawBounds! !!InnerListMorph methodsFor: 'list management' stamp: 'jmv 11/11/2011 11:03'!                   drawBoundsForRowEspantoso: row	"calculate the bounds that row should be drawn at.  This might be outside our bounds!!"	| topLeft drawBounds |self flag: #jmvVer.true ifTrue: [	topLeft _0 @ ( ((row - 1) * (font height))).] ifFalse: [	topLeft _ bounds left @ (bounds top + ((row - 1) * (font height))).].	drawBounds _ topLeft extent: bounds width @ font height.	^drawBounds! !!InnerListMorph methodsFor: 'list management' stamp: 'jmv 11/9/2011 17:56'!                   listChanged	"set newList to be the list of strings to display"	listItems _ Array new: self getListSize withAll: nil.	selectedRow _ nil.	selectedRows _ Set new.	self adjustHeight.	self adjustWidth.	self redrawNeeded! !!InnerListMorph methodsFor: 'list management' stamp: 'jmv 11/9/2011 17:56'!                  rowAtLocation: aPoint	"return the number of the row at aPoint"	| y y0 |	y0 _ bounds top.	y _ aPoint y.	y < y0 ifTrue: [ ^ 1 ].	^((y - y0 // (font height)) + 1) min: listItems size max: 0! !!InnerListMorph methodsFor: 'list management' stamp: 'jmv 11/9/2011 17:56'!               selectedRow	"return the currently selected row, or nil if none is selected"	^selectedRow! !!InnerListMorph methodsFor: 'list management' stamp: 'jmv 11/9/2011 17:56'!                     selectedRow: index	"select the index-th row.  if nil, remove the current selection"	selectedRow _ index.	self redrawNeeded! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 10:49'!                         adjustHeightself flag: #jmvVer. "bueno, no exactamente este metodo, pero pensar en que categoria de clases van los morphs de afuera y los de adentro..."	"private.  Adjust our height to match the length of the underlying list"	self height: (listItems size max: 1) * font height! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/10/2011 08:50'!                            adjustWidth	"private.  Adjust our height to match the length of the underlying list,	but make it wider if neccesary to fill the available width in our PluggableListMorph"self flag: #jmvVer."listSource es == owner. Quizas sacar la variable???"	self width: (listSource viewableWidth max: self hTotalScrollRange)! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:56'!                             bottomVisibleRowForCanvas: aCanvas        "return the bottom visible row in aCanvas's clip rectangle"        ^self rowAtLocation: aCanvas clipRect bottomLeft.! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:56'!                      colorForRow: row	^(selectedRow notNil and: [ row = selectedRow])		ifTrue: [ Theme current listSelectedRowText ]		ifFalse: [ Theme current listUnselectedRowText ].! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:56'!                  display: item  atRow: row on: canvas	"display the given item at row row"	| drawBounds f |	drawBounds _ self drawBoundsForRow: row.	drawBounds _ drawBounds intersect: bounds.	f _ (item is: #Text) ifTrue: [ font emphasized: (item emphasisAt: 1) ] ifFalse: [ font ].	canvas drawString: item in: drawBounds font: f color: (self colorForRow: row)! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:56'!                            drawBackgroundForMulti: row on: aCanvas	| selectionDrawBounds c |	"shade the background darker, if this row is selected"	selectionDrawBounds := self drawBoundsForRow: row.	selectionDrawBounds := selectionDrawBounds intersect: bounds.	c _ (selectedRow notNil and: [ row = selectedRow])		ifTrue: [ Theme current listHighlightFocused: listSource hasKeyboardFocus ]		ifFalse: [ Theme current listMultiHighlightFocused: listSource hasKeyboardFocus ].	aCanvas fillRectangle: selectionDrawBounds colorOrInfiniteForm: c! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:56'!               drawOn: aCanvas	| |	listItems size = 0 ifTrue: [ ^self ]. 	self drawSelectionOn: aCanvas.	(self topVisibleRowForCanvas: aCanvas) to: (self bottomVisibleRowForCanvas: aCanvas) do: [ :row |		(listSource itemSelectedAmongMultiple:  row) ifTrue: [			self drawBackgroundForMulti: row on: aCanvas. ].		self display: (self item: row) asStringOrText atRow: row on: aCanvas.	]! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:56'!                              drawSelectionOn: aCanvas	| selectionDrawBounds |	selectedRow ifNil: [ ^self ].	selectedRow = 0 ifTrue: [ ^self ].	selectionDrawBounds := self drawBoundsForRow: selectedRow.	selectionDrawBounds := selectionDrawBounds intersect: bounds.	aCanvas		fillRectangle: selectionDrawBounds		colorOrInfiniteForm: (Theme current listHighlightFocused: listSource hasKeyboardFocus)! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:56'! font	"return the font used for drawing.  The response is never nil"	^font! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:56'!            font: newFont	font _ (newFont ifNil: [ StrikeFont default ]).	self adjustHeight.	self redrawNeeded.! !!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:56'!                 topVisibleRowForCanvas: aCanvas        "return the top visible row in aCanvas's clip rectangle"        ^self rowAtLocation: aCanvas clipRect topLeft.! !!InnerListMorph methodsFor: 'list access' stamp: 'jmv 11/9/2011 17:56'!                           getListItem: index	"grab a list item directly from the model"	^listSource getListItem: index! !!InnerListMorph methodsFor: 'list access' stamp: 'jmv 11/9/2011 17:56'!                     getListSize	"return the number of items in the list"	listSource ifNil: [ ^0 ].	^listSource getListSize! !!InnerListMorph methodsFor: 'list access' stamp: 'jmv 11/9/2011 17:56'!          item: index	"return the index-th item, using the 'listItems' cache"	(index between: 1 and: listItems size)		ifFalse: [ "there should have been an update, but there wasn't!!"  ^self getListItem: index].	(listItems at: index) ifNil: [ 		listItems at: index put: (self getListItem: index). ].	^listItems at: index! !!InnerListMorph methodsFor: 'scroll range' stamp: 'jmv 11/9/2011 17:56'!                      hTotalScrollRange"Ok, this is a bit messed up. We need to return the width of the widest item in the list. If we grab every item in the list, it defeats the purpose of LazyListMorph. If we don't, then we don't know the size. This is a compromise -- if the list is less then 30 items, we grab them all. If not, we grab currently visible ones, until we've checked itemsToCheck of them, then take the max width out of that 'sampling', then double it. If you know a better way, please chime in."	| maxW count itemsToCheck item |	itemsToCheck _ 30.	maxW _ 0. 	count _ 0.	listItems do: 		[ :each |			each ifNotNil: 				[maxW _ maxW max: (self widthToDisplayItem: each contents)]].					(count < itemsToCheck) ifTrue:		[1 to: listItems size do: 			[:i | (listItems at: i) ifNil: 							[item _ self item: i.							maxW _ maxW max: (self widthToDisplayItem: item contents).							((count _ count + 1) > itemsToCheck) ifTrue:[ ^maxW * 2]]]].		^maxW ! !!InnerListMorph methodsFor: 'scroll range' stamp: 'jmv 11/9/2011 17:56'!                  widthToDisplayItem: item	^self font widthOfStringOrText: item	! !!InnerListMorph methodsFor: 'private' stamp: 'jmv 11/9/2011 17:56'!                       noSelection	selectedRow _ nil.	selectedRows _ Set new! !!InnerListMorph class methodsFor: 'new-morph participation' stamp: 'jmv 11/9/2011 17:56'!         includeInNewMorphMenu	^ false! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!                      askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits _ aBoolean! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!        autoCompleter: anUCompleter	autoCompleter _ anUCompleter.	autoCompleter ifNotNil: [		autoCompleter textMorph: self ]! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!                              contents: stringOrText	^ self contentsAsIs: stringOrText! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!                            contentsAsIs: stringOrText	"Accept new text contents with line breaks only as in the text.	Fit my width and height to the result."	wrapFlag _ false.	model basicActualContents: stringOrText! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!                     crAction	"Return the action to perform when encountering a CR in the input"	^self valueOfProperty: #crAction! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!       editor	"Return my current editor, or install a new one."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!                          isWrapped		^wrapFlag! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!                               model: aTextModel	model _ aTextModel.	styler ifNotNil: [ styler textModel: model ].	self releaseParagraph.	"So the model is properly set on the editor and the paragraph"! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!         model: aTextModel wrappedTo: width	"Accept new text contents.  Lay it out, wrapping to width.	Then fit my height to the result."	wrapFlag _ true.	self basicExtent: width truncated@self height.	self model: aTextModel! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!                         textColor	^ color! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!  textColor: aColor	color = aColor ifTrue: [^ self].	color _ aColor.	self redrawNeeded! !!InnerTextMorph methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:57'!                             wrapFlag: aBoolean	"Change whether contents are wrapped to the container."	aBoolean == wrapFlag ifTrue: [^ self].	wrapFlag _ aBoolean.	self composeToBounds! !!InnerTextMorph methodsFor: 'anchors' stamp: 'jmv 11/9/2011 17:57'!                       anchorMorph: aMorph at: aPoint	| relPt |	aMorph owner == self ifTrue: [ self removeMorph: aMorph ].	self addMorphFront: aMorph.	relPt _ self internalizePosition: aPoint from: self world.	editor insertMorph: aMorph at: relPt.	self fit.! !!InnerTextMorph methodsFor: 'caching' stamp: 'jmv 11/9/2011 17:57'!       releaseCachedState	super releaseCachedState.	self releaseParagraph.! !!InnerTextMorph methodsFor: 'classification' stamp: 'jmv 10/25/2011 17:16'!        is: aSymbolself flag: #jmvVer.	^ aSymbol == #BareTextMorph or: [ super is: aSymbol ]! !!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 11/11/2011 09:07'!debugDrawLineRectsOn: aCanvas	"Shows where text line rectangles are"	| tl |	tl _ bounds topLeft.	self paragraph lines do: [ :line |		aCanvas frameRectangle: (line rectangle translateBy: tl) borderWidth: 1 color: Color brown ]! !!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 11/11/2011 10:07'!               drawOn: aCanvas	"Draw the receiver on a canvas"	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"	aCanvas paragraphNEW: self paragraph bounds: self displayBounds color: color.	"Drawing the paragraph might change the #lastCaretRect, and therefore might	require a second update."	paragraph lastCaretRectNeedsRedraw ifTrue: [		paragraph lastCaretRect ifNotNil: [ :r | self invalidRect: r ]]! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/9/2011 17:57'!     acceptContents	"The message is sent when the user hits enter or Cmd-S.	Accept the current contents and end editing."	self updateFromParagraph.	editView accept.! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/9/2011 17:57'!                    acceptOnCR	"Answer whether the receiver wants to accept when the Return key is hit"	^ acceptOnCR == true! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/9/2011 17:57'!            cancelEdits	"The message is sent when the user hits enter or Cmd-L.	Cancel the current contents and end editing."	self releaseParagraph.	editView cancel! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/9/2011 17:57'!                           chooseAlignment	self editor changeAlignment.	self updateFromParagraph! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/9/2011 17:57'!                chooseEmphasisOrAlignment	self editor changeEmphasisOrAlignment.	self updateFromParagraph! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/9/2011 17:57'!                            chooseFont	self editor changeTextFont.	self updateFromParagraph.! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/9/2011 17:57'!                     enterClickableRegion: evt	| index isLink |	evt hand hasSubmorphs ifTrue: [ ^self ].	paragraph ifNotNil:[		index _ (paragraph characterBlockAtPoint: evt position) stringIndex.		isLink _ (model actualContents attributesAt: index) 					anySatisfy: [ :attr | attr mayActOnClick ].		isLink ifTrue: [ Cursor webLink show ] ifFalse: [ Cursor normal show ]]! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/9/2011 17:57'!                   handleEdit: editBlock	"Ensure that changed areas get suitably redrawn"	self selectionChanged.  "Note old selection"		editBlock value.	self selectionChanged.  "Note new selection"	self updateFromParagraph  "Propagate changes as necessary"! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/9/2011 17:57'!     handleInteraction: interactionBlock	"Perform the changes in interactionBlock, noting any change in selection	and possibly a change in the size of the paragraph (ar 9/22/2001 - added for TextPrintIts)"	"Also couple ParagraphEditor to Morphic keyboard events"	| oldEditor oldParagraph oldSize |	oldEditor _ editor.	oldParagraph _ paragraph.	oldSize _ model textSize.	self selectionChanged.  "Note old selection"	interactionBlock value.	(oldParagraph == paragraph) ifTrue:[		"this will not work if the paragraph changed"		editor _ oldEditor.     "since it may have been changed while in block"	].	self selectionChanged.  "Note new selection"	oldSize = model textSize		ifFalse: [ self updateFromParagraph ]! !!InnerTextMorph methodsFor: 'editing' stamp: 'jmv 11/9/2011 17:57'!      hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "	aBoolean == hasUnacceptedEdits ifFalse: [		hasUnacceptedEdits _ aBoolean.		editView redrawNeeded].	aBoolean ifFalse: [ editView hasEditingConflicts: false].	"shout:  re-style the text iff aBoolean is true	Do not apply any formatting (i.e. changes to the characters in the text),	just styling (i.e. TextAttributes)"	(aBoolean and: [self okToStyle])		ifTrue: [ styler styleInBackgroundProcess ]! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/9/2011 17:57'!         autoScrollView: evt	"This is kind of a hack because the PluggableTextMorph expects me to first expand the selection before auto scrolling will work."	| localEvt |	localEvt _ evt internalizedToOwnerOf: self from: editView.	super mouseMove: localEvt.	editView scrollSelectionIntoView: localEvt.! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2011 18:39'!      doubleClick: evt	self handleInteraction: [ editor doubleClick: (evt translatedBy: bounds topLeft negated) ].	editView scrollSelectionIntoView: evt.! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/9/2011 17:57'!                           handlesKeyboard	^self visible! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/9/2011 17:57'!                 handlesMouseDown: evt	^ true! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/9/2011 22:30'!                   keyStroke: evt	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].			"Maybe disable? Precludes the use of up and down arrows with control,	that are standard keystrokes in Windows to control the cursor.	Problem: At least Mac and Win VM generate ctrl-up and ctrl-down for	mouse wheel events.	I guess most people would prefer the mouse wheel to work properly..."	(editView scrollByKeyboard: evt)		ifTrue: [ ^self ].	autoCompleter 		ifNil: [ self processKeyStroke: evt ]		ifNotNil: [			autoCompleter				autoCompletionAround: [ self processKeyStroke: evt ]				keyStroke: evt ]! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/9/2011 17:57'!     keyboardFocusChange: aBoolean		"The message is sent to a morph when its keyboard focus changes.	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.	In this case, all we need to do is to redraw border feedback"	paragraph ifNotNil: [ paragraph focused: aBoolean ].	aBoolean		ifTrue: [			"A hand is wanting to send us characters..."			editor ifNil: [ self editor storeSelectionInParagraph ].	"Forces install"			self startBlinking ]		ifFalse: [ self stopBlinking ].	"Selection might be shown differently when focused"	"If (as usual) we are part of a TextModelMorph, invalidate it, to update the keyboard focus indicator"	owner ifNotNil: [ owner owner ifNotNil: [ :grandPa | ^ grandPa redrawNeeded ]].	self redrawNeeded! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2011 18:38'!            mouseDown: event	"Make this TextMorph be the keyboard input focus, if it isn't already,		and repond to the text selection gesture."	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	"If we don't focus, Get focus, and do nothing else (the user will need to click again to do further interaction)"	self hasKeyboardFocus ifFalse: [		^event hand newKeyboardFocus: self].	super mouseDown: event.	self handleInteraction: [editor mouseDown: (event translatedBy: bounds topLeft negated)].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		dblClkSel: #doubleClick:		tripleClkSel: #tripleClick:! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2011 18:38'!                              mouseMove: evt	| editEvt |	evt mouseButton1Pressed ifFalse: [^ self enterClickableRegion: evt].	self handleInteraction: [editor mouseMove: (evt translatedBy: bounds topLeft negated)].	editEvt _ evt externalizedFromOwnerOf: self to: editView.	(editEvt position y between: editView top and: editView bottom) ifFalse: [		"Start auto-scrolling"		self startStepping: #autoScrollView:			at: Time millisecondClockValue			arguments: (Array with: editEvt)			stepTime: 100. "fast enough"	] ifTrue: [		self stopSteppingSelector: #autoScrollView:.	]! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/11/2011 08:58'!         mouseUp: evt	super mouseUp: evt.	self pauseBlinking.	self handleInteraction: [editor mouseUp: (evt translatedBy: bounds topLeft negated)].	self stopSteppingSelector: #autoScrollView:.	editView scrollSelectionIntoView: evt! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/9/2011 17:57'!              processKeyStroke: evt	| action |	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	self pauseBlinking.	evt keyValue = 13 ifTrue: ["CR - check for special action"		action _ self crAction.		action ifNotNil: [			^action value]].	self handleInteraction: [ editor processKeyStroke: evt ].	self updateFromParagraph.	self eventHandler ifNotNil: [		"like'super keyStroke: evt'"		self eventHandler keyStroke: evt fromMorph: self].	editView scrollSelectionIntoView! !!InnerTextMorph methodsFor: 'event handling' stamp: 'jmv 11/10/2011 18:41'!                      tripleClick: evt	self handleInteraction: [ editor tripleClick: (evt translatedBy: bounds topLeft negated) ].	editView scrollSelectionIntoView: evt.! !!InnerTextMorph methodsFor: 'events-processing' stamp: 'jmv 11/9/2011 17:57'!                        handleKeystroke: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self].	self handlesKeyboard ifFalse:	[^ self].	anEvent wasHandled: true.	self keyStroke: anEvent! !!InnerTextMorph methodsFor: 'events-processing' stamp: 'jmv 11/9/2011 17:57'!                   handleMouseMove: anEvent	"Re-implemented to allow for mouse-up move events"	anEvent wasHandled ifTrue:[^self]. "not interested"	(anEvent hand hasSubmorphs) ifTrue:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].	(self handlesMouseStillDown: anEvent) ifTrue:[		"Step at the new location"		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue			arguments: {anEvent copy resetHandlerFields}			stepTime: 1].! !!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:57'! extent: aPoint	| newExtent priorEditor |	priorEditor _ editor.	"Resist changing the extent if no wordwrap.. this should be checked."	wrapFlag ifFalse: [ ^ self ].	newExtent _ aPoint truncated max: self minimumExtent.		"No change of wrap width"	newExtent x = bounds extent x ifTrue: [ ^ self ].	"invalidate the paragraph cache"	self releaseParagraph.		super extent: newExtent.	priorEditor		ifNil: [			"since the width has changed..." 			self fit ]		ifNotNil: [ self installEditorToReplace: priorEditor ].! !!InnerTextMorph methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:57'!             minimumExtent	^(9@(StrikeFont default height+2))! !!InnerTextMorph methodsFor: 'initialization' stamp: 'jmv 11/9/2011 17:57'!                              defaultColor	"Return the default fill style for the receiver"	^ Theme current text! !!InnerTextMorph methodsFor: 'initialization' stamp: 'jmv 11/9/2011 17:57'!                            initialize	super initialize.	wrapFlag _ true.	acceptOnCR _ false.	hasUnacceptedEdits _ false.	askBeforeDiscardingEdits _ true! !!InnerTextMorph methodsFor: 'menu' stamp: 'jmv 11/9/2011 17:57'!                        addCustomMenuItems: aCustomMenu hand: aHandMorph 	"Add text-related menu items to the menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu 		addUpdating: #wrapString		target: self		action: #wrapOnOff! !!InnerTextMorph methodsFor: 'menu' stamp: 'jmv 11/9/2011 17:57'!                       wrapOnOff	self wrapFlag: wrapFlag not! !!InnerTextMorph methodsFor: 'menu' stamp: 'jmv 11/9/2011 17:57'!                    wrapString	"Answer the string to put in a menu that will invite the user to 	switch word wrap mode"	^ (wrapFlag		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'text wrap to bounds'! !!InnerTextMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 11/9/2011 17:57'!                     addMorphFront: aMorph fromWorldPosition: wp 	"Overridden for more specific re-layout and positioning"	^self anchorMorph: aMorph at: wp! !!InnerTextMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 11/9/2011 17:57'!  styler: anSHTextStyler		styler _ anSHTextStyler.	anSHTextStyler ifNotNil: [ model ifNotNil: [ anSHTextStyler textModel: model ]]! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/9/2011 17:57'!                    composeToBounds	"Compose my text to fit my bounds.	If any text lies outside my bounds, it will be clipped,."	self releaseParagraph! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/9/2011 17:57'!                 extentForComposing	^wrapFlag		ifTrue: [ bounds width @ 9999999 ]		ifFalse: [ 9999999@9999999 ]! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/9/2011 17:57'!                      fit	"Adjust my bounds to fit the text.	Required after the text changes,	or if wrapFlag is true and the user attempts to change the extent."	| newExtent para |	newExtent := (self paragraph extent max: 9 @ StrikeFont default height) + (0 @ 2).	newExtent ~= bounds extent 		ifTrue: [			para := paragraph.	"Save para (layoutChanged smashes it)"			self basicExtent: newExtent.			paragraph := para].	"These statements should be pushed back into senders"	self redrawNeeded.	"Too conservative: only paragraph composition							should cause invalidation."	editView innerHeight: newExtent y! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/9/2011 17:57'!  installEditorToReplace: priorEditor 	"Install an editor for my paragraph. Install also the paragraph if not there.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [ stateArray _ priorEditor stateArray] .	editor _ model editorClass new morph: self.	editor model: model.	paragraph		ifNotNil: [			editor changeParagraph: paragraph.			editor resetState ]		ifNil: [			"...Code here to recreate the paragraph..."			paragraph _ Paragraph new.			paragraph focused: self hasKeyboardFocus.			paragraph setModel: model extentForComposing: self extentForComposing.			editor changeParagraph: paragraph.			editor setEmphasisHereFromText.			paragraph composeAll.			self fit.			editor resetState.		].	stateArray ifNotNil: [ editor stateArrayPut: stateArray ].	self selectionChanged.	^editor! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/9/2011 17:57'!                     mouseButton2Activity	^ editView mouseButton2Activity! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/9/2011 17:57'!  paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	"Installs both editor and paragraph."	self installEditorToReplace: editor.	^ paragraph! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/9/2011 17:57'!             releaseParagraph	"Paragraph instantiation is lazy -- it will be created only when needed"	"release editor too"	editor ifNotNil: [		self selectionChanged.		editor _ nil].	paragraph ifNotNil: [		paragraph selectionStartBlocks: #() selectionStopBlocks: #().	"most likely not needed"		paragraph _ nil]! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/9/2011 17:57'!     removedMorph: aMorph	editor removeMorph: aMorph.	self fit.	super removedMorph: aMorph! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/11/2011 09:04'!                             selectionChanged	self selectionRects do: [:r | self invalidRect: r ]! !!InnerTextMorph methodsFor: 'private' stamp: 'jmv 11/9/2011 17:57'!                  updateFromParagraph	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be released, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, and current typing emphasis."	| sel oldEditor |	paragraph ifNotNil: [		editor ifNotNil: [			oldEditor := editor.			sel := editor selectionInterval.			editor storeSelectionInParagraph].		self fit.		self layoutChanged.		sel ifNotNil: [			editor ifNil: [				"Reinstate selection after, eg, style change"				self installEditorToReplace: oldEditor]]].	editView setScrollDeltas! !!InnerTextMorph methodsFor: 'notifications' stamp: 'jmv 11/9/2011 17:57'!               possiblyChanged	editView ifNotNil: [ editView possiblyChanged ]! !!InnerTextMorph methodsFor: 'testing' stamp: 'jmv 11/9/2011 17:57'!                       canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ (hasUnacceptedEdits & askBeforeDiscardingEdits) not! !!InnerTextMorph methodsFor: 'testing' stamp: 'jmv 11/9/2011 17:57'!        hasUnacceptedEdits	^hasUnacceptedEdits! !!InnerTextMorph methodsFor: 'testing' stamp: 'jmv 11/9/2011 17:57'!                isOpaqueMorph	^false! !!InnerTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 11/9/2011 17:57'!                          onBlinkCursor	"Blink the cursor"	paragraph ifNil: [ ^nil ].	paragraph showCaret: paragraph showCaret not | pauseBlinking.	pauseBlinking _ false.	paragraph lastCaretRect ifNotNil: [ :r | self invalidRect: r].! !!InnerTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 11/9/2011 17:57'!                           pauseBlinking	"Show a solid cursor (non blinking) for a short while"	pauseBlinking _ true.	paragraph ifNotNil: [		"Show cursor right now if needed"		paragraph showCaret ifFalse: [			paragraph showCaret: true.			paragraph lastCaretRect ifNotNil: [ :r | self invalidRect: r ]]]! !!InnerTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 11/9/2011 17:57'!                     startBlinking	"And show the cursor"	pauseBlinking _ true.	"Start blinking in a short while"	paragraph ifNotNil: [ paragraph showCaret: true ].	self		startStepping: #onBlinkCursor		at: Time millisecondClockValue		arguments: nil		stepTime: 500.! !!InnerTextMorph methodsFor: 'blinking cursor' stamp: 'jmv 11/14/2011 10:05'!                   stopBlinking	"And do not show cursor anymore."	self stopSteppingSelector: #onBlinkCursor.	paragraph ifNotNil: [		"Hide cursor right now if needed"		paragraph showCaret ifTrue: [			paragraph showCaret: false.			paragraph lastCaretRect ifNotNil: [ :r |				self flag: #jmvVer.	"Have no idea why is this translate needed. But it IS needed."				"self invalidRect: (r translateBy: 1-1) "				"mhhhh. why is this needed at all?????"				]]]! !!InnerTextMorph methodsFor: 'accept/cancel' stamp: 'jmv 11/9/2011 17:57'!                       acceptOnCR: trueOrFalse	acceptOnCR _ trueOrFalse! !!InnerTextMorph methodsFor: 'edit view' stamp: 'jmv 11/9/2011 17:57'!    editView	^ editView! !!InnerTextMorph methodsFor: 'edit view' stamp: 'jmv 11/9/2011 17:57'! setEditView: editPane	editView _ editPane! !!InnerTextMorph methodsFor: 'macpal' stamp: 'jmv 11/9/2011 17:57'!              flash	^ editView flash! !!InnerTextMorph methodsFor: 'miscellaneous' stamp: 'jmv 11/9/2011 17:57'!                          clearSelection	"Tell my editor to select nothing"	self editor clearSelection.	self redrawNeeded! !!InnerTextMorph methodsFor: 'miscellaneous' stamp: 'jmv 11/9/2011 17:57'!              disregardUnacceptedEdits	^ self hasUnacceptedEdits: false! !!InnerTextMorph methodsFor: 'miscellaneous' stamp: 'jmv 11/9/2011 17:57'!                      selectAll	"Tell my editor to select all the text"	self editor selectAll.	self redrawNeeded! !!InnerTextMorph methodsFor: 'shout' stamp: 'jmv 11/9/2011 17:57'!                           formatAndStyleIfNeeded	"Apply both formatting (changes to the characters in the text, such as	preferred assignment operators), and styling (TextAttributes to make	Smalltalk code easier to understand)"	self okToStyle ifTrue: [		styler formatAndStyle ]! !!InnerTextMorph methodsFor: 'shout' stamp: 'jmv 11/9/2011 17:57'!                         okToStyle	styler ifNil: [ ^false ].	^model shoutAboutToStyle: styler! !!InnerTextMorph methodsFor: 'selection' stamp: 'jmv 11/11/2011 09:04'!              selectionRects	"Paragraph assumes its topLeft is 0@0. We don't"	| tl |	tl _ bounds topLeft.	^self paragraph selectionRects collect: [ :r | r translateBy: tl ]! !!InnerTextMorph class methodsFor: 'new-morph participation' stamp: 'jmv 11/9/2011 17:57'!                              includeInNewMorphMenu	^ false! !!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 11/10/2011 09:04'!                   addToScroller: aMorphself flag: #jmvVer."Solo usado para #inATwoWayScrollPane.Cuando todo lo demas ande, hacer andar esto tambien!!poner directamente el morph como scroller? yo creo que si..."aMorph position = (0@0) ifTrue: [	aMorph position: scroller position +15 ]."Ojo esa cte..."	scroller addMorph: aMorph! !!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 11/9/2011 17:58'!                     adoptWidgetsColor: paneColor	super adoptWidgetsColor: paneColor.	scrollBar adoptWidgetsColor: paneColor.	hScrollBar adoptWidgetsColor: paneColor.! !!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 11/9/2011 17:58'!                              drawKeyboardFocusIndicator: aBoolean	drawKeyboardFocusIndicator _ aBoolean! !!PluggableScrollPane methodsFor: 'access options' stamp: 'jmv 11/9/2011 17:58'!                               hideScrollBarsIndefinitely	hideScrollBars _ true.	self vHideScrollBar.	self hHideScrollBar.! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 11/9/2011 17:58'!            handlesMouseOver: evt	"subclasses implement #mouseEnter: and/or #mouseLeave:"	^true! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 11/10/2011 09:01'!                     keyStroke: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	( self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	super keyStroke: evt.	(self scrollByKeyboard: evt)		ifTrue: [ ^self ].	scroller keyStroke: evt! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 11/10/2011 08:53'!                  mouseDown: event	event mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"		scroller mouseDown:			(event "internalizedTo: scroller from: self").self flag: #jmvVer.	event hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		dblClkSel: #doubleClick:		tripleClkSel: #tripleClick:! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 11/10/2011 08:53'!           mouseUp: evt	super mouseUp: evt.	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"		scroller mouseUp: 			(evt "internalizedTo: scroller from: self").self flag: #jmvVer.! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 11/9/2011 17:58'!scrollByKeyboard: event	"If event is ctrl+up/down then scroll and answer true"	event controlKeyPressed ifFalse: [ ^ false ].	event keyValue = 30 ifTrue: [		scrollBar scrollUp: 3.		^ true ].	event keyValue = 31 ifTrue: [		scrollBar scrollDown: 3.		^ true ].	^ false.! !!PluggableScrollPane methodsFor: 'event handling' stamp: 'jmv 11/9/2011 17:58'!                         tripleClick: evt	"Some subclasses might do something"! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:58'!                           extent: newExtent		| oldW oldH wasHShowing wasVShowing minH minW |		oldW _ self width.	oldH _ self height.	wasHShowing _ self hIsScrollbarShowing.	wasVShowing _ self vIsScrollbarShowing.	"Figure out the minimum width and height for this pane so that scrollbars will appear"	hideScrollBars 		ifTrue: [ 			minH _ 1.			minW _ 1 ]		ifFalse: [			minH _ Preferences scrollbarThickness + 16.			minW _ minH + 4].	super extent: (newExtent max: (minW@minH)).	"Now reset widget sizes"	self resizeScroller; hideOrShowScrollBars.		"Now resetScrollDeltas where appropriate, first the vScrollBar..."	((self height ~= oldH) or: [ wasHShowing ~~ self hIsScrollbarShowing]) ifTrue: [		self vIsScrollbarShowing ifTrue: [			self vSetScrollDelta ]].				"...then the hScrollBar"	((self width ~= oldW) or: [wasVShowing ~~ self vIsScrollbarShowing]) ifTrue: [		self hIsScrollbarShowing ifTrue: [			self hSetScrollDelta ]].! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:58'!               focusIndicatorRectangle	| b topLeft bottomRight |	b _ self innerBounds.	topLeft _ b topLeft .	bottomRight _ b bottomRight.	self vIsScrollbarShowing ifTrue: [		bottomRight _ scrollBar left @ bottomRight y].	self hIsScrollbarShowing		ifTrue: [ bottomRight _ bottomRight x @ (bottomRight y - Preferences scrollbarThickness)].	^topLeft corner: bottomRight! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/10/2011 08:52'!       hLeftoverScrollRange	"Return the entire scrolling range minus the currently viewed area."self flag: #jmvVer. "volar, no?""	scroller hasSubmorphs ifFalse: [^0]."	^ (self hTotalScrollRange - self viewableWidth) max: 0! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:58'!                    hScrollBarWidth	"Return the width of the horizontal scrollbar"	| w |		w _ bounds width - (2 * borderWidth).	self vIsScrollbarShowing		ifTrue: [ w _ w - Preferences scrollbarThickness ].	^w! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/12/2011 22:41'!             hSetScrollDelta	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."	| range delta w |self flag: #jmvVer. "volar, no?""	scroller hasSubmorphs ifFalse:[scrollBar interval: 1.0. ^self]."		delta _ self scrollDeltaWidth.	range _ self hLeftoverScrollRange.	range = 0 ifTrue: [ hScrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; setValue: 0. ^self].	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."	w _ self viewableWidth.	hScrollBar scrollDelta: (delta / range) asFloat pageDelta: (w - delta / range) asFloat.	hScrollBar interval: (w / self hTotalScrollRange) asFloat."	hScrollBar setValue: ((scroller scrollerOffset x / range) min: 1.0) asFloat."	"este sI"	hScrollBar setValue: hScrollBar value.	"Parece que hace falta enviar esto... ver si realmente es asi"	"La verdad es que hace calls espureos al abrir... Por ahora lo saco (reponer?)"			self flag: #jmvVer.! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/10/2011 09:02'!                             hTotalScrollRange	"Return the width extent of the receiver's submorphs."self flag: #jmvVer."Ojo con la herencia!!!!!!!!!!"	^scroller width! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 10/25/2011 17:05'!  layoutChanged	| t topLeft |self flag: #jmvVer.	super layoutChanged.		hideScrollBars ifTrue: [^self]."Hace falta esto????Asegurarse que #setScrollDeltas se haga apropiadamente cuando corresponde...""	newScrollRange _ self hTotalScrollRange @ self vTotalScrollRange.	currentScrollRange = newScrollRange ifFalse: [		WorldState addDeferredUIMessage: [ self setScrollDeltas ].		currentScrollRange _ newScrollRange ]."	t _ Preferences scrollbarThickness.	topLeft _ bounds topRight + (0-t-borderWidth @ borderWidth).	scrollBar bounds: (topLeft extent: t @ self vScrollBarHeight).	topLeft _ bounds bottomLeft + (borderWidth @ (t + borderWidth) negated).	hScrollBar bounds: (topLeft extent: self hScrollBarWidth@ t)! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:58'!                        mightNeedHorizontalScrollBar	"If not sure, answer true. Only answer false when the horizontal scrollbar will not be needed, regardless of contents, for example, when showing wrapped text.	This method is called for deciding if a vertical scroll bar is needed. Therefore if the need of an horizontal scrollbar might depend on the vertical scrollbar being there (and taking space) or not, just answer true."	^true! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/10/2011 08:50'!                   resizeScrollerself flag: #jmvVer. "solo para subclases""	scroller bounds: self viewableBounds"! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:58'!                 scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled (normally a subclass responsibility)."	^ 10! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:58'!              scrollDeltaWidth	"Return the increment in pixels which this pane should be scrolled (normally a subclass responsibility)."		^10! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/10/2011 08:54'!             setScrollDeltas	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."self flag: #jmvVer. "volar, no?""	scroller hasSubmorphs ifFalse: 		[scrollBar interval: 1.0. 		hScrollBar interval: 1.0. 		^ self]."	"NOTE: fullbounds commented out now -- trying to find a case where this expensive step is necessary -- perhaps there is a less expensive way to handle that case."	"scroller fullBounds." "force recompute so that leftoverScrollRange will be up-to-date"	self hideOrShowScrollBars.		self vIsScrollbarShowing ifTrue: [ self vSetScrollDelta ].	self hIsScrollbarShowing ifTrue: [ self hSetScrollDelta ].! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/10/2011 08:54'!                        vLeftoverScrollRange	"Return the entire scrolling range minus the currently viewed area."	self flag: #jmvVer. "volar, no?""	scroller hasSubmorphs ifFalse: [^0]."	^ (self vTotalScrollRange - self viewableHeight) max: 0! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:58'!                  vScrollBarHeight	^bounds height - (2 * borderWidth)! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/12/2011 22:42'!                            vSetScrollDelta	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."	| range delta h |self flag: #jmvVer.self flag: #jmvVer. "volar, no?""	scroller hasSubmorphs ifFalse: [		^ scrollBar interval: 1.0 ]."		delta _ self scrollDeltaHeight.	range _ self vLeftoverScrollRange.	range = 0 ifTrue: [		^ scrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; setValue: 0].	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."	h _ self viewableHeight.	scrollBar scrollDelta: (delta / range) asFloat pageDelta: (h - delta / range) asFloat.	scrollBar interval: (h / self vTotalScrollRange) asFloat."	scrollBar setValue: (scroller scrollerOffset y / range min: 1.0) asFloat."	"este SI es necesario. Si scrollas hasta el final, y agrandas el pane, mantiene ei bottom del scrollable abajo."	scrollBar setValue: scrollBar value.	"Parece que hace falta enviar esto... ver si realmente es asi"	"La verdad es que hace calls espureos al abrir... Por ahora lo saco (reponer?)"! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/10/2011 09:05'!    vTotalScrollRange	"Return the height extent of the receiver's submorphs."self flag: #jmvVer."Ojo con la herencia!!!!!!"	^scroller height! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:58'!     viewableBounds	^self focusIndicatorRectangle insetBy: self xtraBorder! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:58'!          viewableHeight	"Viewable height.	Leave room for horizontal scrollbar if present"	^self viewableBounds height! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:58'! viewableWidth	"Viewable width.	Leave room for vertical scrollbar if present"	^self viewableBounds width! !!PluggableScrollPane methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:58'!      xtraBorder	"Answer the width of an extra white border to look nicer"	^3! !!PluggableScrollPane methodsFor: 'geometry testing' stamp: 'jmv 11/9/2011 17:58'!hIsScrollbarShowing	"Return true if a horizontal scroll bar is currently showing"	^hScrollBar owner == self! !!PluggableScrollPane methodsFor: 'geometry testing' stamp: 'jmv 11/9/2011 17:58'!                           vIsScrollbarShowing	"Return true if a retractable (or not) vertical scroll bar is currently showing"	^scrollBar owner == self! !!PluggableScrollPane methodsFor: 'initialization' stamp: 'jmv 11/9/2011 17:58'!           defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color black! !!PluggableScrollPane methodsFor: 'initialization' stamp: 'jmv 11/10/2011 09:20'!          initialize		"initialize the state of the receiver"	super initialize.	hideScrollBars _ false.			"initialize the receiver's scrollBars"self flag: #jmvVer.	scrollBar := ScrollBar new model: self setValueSelector: #vScrollBarValue:.	hScrollBar := ScrollBar new model: self setValueSelector: #hScrollBarValue:.		"	self extent: 150 @ 120."	drawKeyboardFocusIndicator _ true.! !!PluggableScrollPane methodsFor: 'scroll bar events' stamp: 'jmv 11/9/2011 17:58'!       mouseButton2Activity	"Invoke the menu"	self getMenu ifNotNil: [ :menu |		menu invokeModal ]! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/9/2011 22:50'!                 hHideScrollBar	self hIsScrollbarShowing ifFalse: [		^self scrollerOffset: 0@self scrollerOffset y ].	self removeMorph: hScrollBar.	self scrollerOffset: 0@self scrollerOffset y.	 self resizeScroller! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/10/2011 08:51'!     hIsScrollbarNeeded: havingVerticalScrollbar	"Return whether the horz scrollbar is needed"	| w |	"Don't show it if we were told not to."	hideScrollBars ifTrue: [^false].self flag: #jmvVer. "volar, no?""	scroller hasSubmorphs ifFalse: [^false]."	"If the contents of the pane are too small to scroll, return false."	w _ self innerBounds width - (2*self xtraBorder).	"Compute the need of the horizontal scrollbar honoring the havingVerticalScrollbar argument"	havingVerticalScrollbar ifTrue: [		w _ w - Preferences scrollbarThickness ].	^self hTotalScrollRange > w! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/10/2011 09:27'!                hScrollBarValue: scrollValue	| x |	self hIsScrollbarShowing ifFalse: [		^self scrollerOffset: 0@self scrollerOffset y ].	(x _ self hLeftoverScrollRange * scrollValue) <= 0		ifTrue: [ x _ 0 ].	self scrollerOffset: x@self scrollerOffset y! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/9/2011 17:58'!                             hShowScrollBar	self hIsScrollbarShowing ifTrue: [^self].	self privateAddMorph: hScrollBar atIndex: 1.	self resizeScroller! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/9/2011 17:58'!                   hideOrShowScrollBars	| wasHShowing wasVShowing useVerticalScrollbar useHorizontalScrollbar |	wasVShowing _ self vIsScrollbarShowing.	wasHShowing _ self hIsScrollbarShowing.	"Assume for a moment we don't need an horizontal scrollbar"	useHorizontalScrollbar _ false.	useVerticalScrollbar _ self vIsScrollbarNeeded: useHorizontalScrollbar.		"Avoid all this if we know for sure we won't need an horizontal scrollbar"	self mightNeedHorizontalScrollBar ifTrue: [				"We are cheating here. May be useVerticalScrollbar is false, and we later need it."		useHorizontalScrollbar _ self hIsScrollbarNeeded: useVerticalScrollbar.						"If horizontal scrollbar is needed, maybe vertical scrollbar will be needed too."		(useVerticalScrollbar not and: [ useHorizontalScrollbar ]) ifTrue: [						"In this case, there is no chance of modifying the need of horizontal scrollbar: it was already needed.			Therefore, there is no circularity here."			useVerticalScrollbar _ self vIsScrollbarNeeded: useHorizontalScrollbar ]].	wasVShowing = useVerticalScrollbar ifFalse: [		useVerticalScrollbar			ifTrue: [ self vShowScrollBar ]			ifFalse: [ self vHideScrollBar ]].	wasHShowing = useHorizontalScrollbar ifFalse: [		useHorizontalScrollbar			ifTrue: [ self hShowScrollBar ]			ifFalse: [ self hHideScrollBar ]]! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/9/2011 22:50'!            scrollBy: delta	"Move the contents in the direction delta."	| newYoffset r newXoffset |		"Set the offset on the scroller"	newYoffset _ self scrollerOffset y - delta y max: 0.	newXoffset _ self scrollerOffset x - delta x max: 0.		self scrollerOffset: newXoffset@ newYoffset.	"Update the scrollBars"	(r _ self vLeftoverScrollRange) = 0		ifTrue: [ scrollBar value: 0.0 ]		ifFalse: [ scrollBar value: newYoffset asFloat / r ].	(r _ self hLeftoverScrollRange) = 0		ifTrue: [ hScrollBar value: 0.0 ]		ifFalse: [ hScrollBar value: newXoffset asFloat / r ]! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/11/2011 14:55'!                          scrollToShow: aRectangle	"scroll to include as much of aRectangle as possible, where aRectangle is in the scroller's local space"	| range scrollValue |self flag: #jmvVer.	((aRectangle top - self scrollerOffset y) >= 0 and: [		(aRectangle bottom - self scrollerOffset y) <= self viewableHeight ])		ifTrue: [			"already visible"			^self ].	range _ self vLeftoverScrollRange.	scrollValue _ range > 0		ifTrue: [			(((aRectangle top + aRectangle bottom / 2.0) - (self viewableHeight/2.0) / range) min: 1.0) max: 0.0.			]		ifFalse: [ 0 ].	scrollBar setValue: scrollValue! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/9/2011 22:51'!            vHideScrollBar	self vIsScrollbarShowing ifFalse: [^self].	self removeMorph: scrollBar.	self scrollerOffset: self scrollerOffset x@ 0.	self resizeScroller! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/10/2011 08:54'!                  vIsScrollbarNeeded: havingHorizontalScrollbar	"Return whether the vertical scrollbar is needed"	| h |		"Don't show it if we were told not to."	hideScrollBars ifTrue: [^false].		self flag: #jmvVer. "volar, no?""	scroller hasSubmorphs ifFalse: [^false].	"	"If the contents of the pane are too small to scroll, return false."	h _ self innerBounds height - (2*self xtraBorder).	"Compute the need of the vertical scrollbar honoring the havingHorizontalScrollbar argument"	havingHorizontalScrollbar ifTrue: [		h _ h - Preferences scrollbarThickness ].	^ self vTotalScrollRange > h! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/10/2011 09:27'!  vScrollBarValue: scrollValueself flag: #jmvVer."	scroller hasSubmorphs ifFalse: [^ self]."	self scrollerOffset: (self scrollerOffset x @ (self vLeftoverScrollRange * scrollValue) rounded)! !!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 11/9/2011 17:58'!                 vShowScrollBar	self vIsScrollbarShowing ifTrue: [^ self].	self privateAddMorph: scrollBar atIndex: 1.	self resizeScroller! !!PluggableScrollPane methodsFor: 'pane events' stamp: 'jmv 11/9/2011 17:58'!                handlesMouseDown: evt	^ true! !!PluggableScrollPane methodsFor: 'pane events' stamp: 'jmv 11/10/2011 08:53'!                mouseMove: evt	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"		scroller  mouseMove: 			(evt "internalizedTo: scroller from: self").self flag: #jmvVer.! !!PluggableScrollPane methodsFor: 'change reporting' stamp: 'jmv 11/9/2011 17:58'!              invalidateBorderFeedback	| r |	drawKeyboardFocusIndicator ifTrue: [		r _ self focusIndicatorRectangle.		(r areasOutside: (r insetBy: Preferences focusIndicatorWidth))			do: [ :rect | self invalidRect: rect ]]! !!PluggableScrollPane methodsFor: 'drawing' stamp: 'jmv 10/25/2011 17:09'!                           clipsSubmorphs	^true! !!PluggableScrollPane methodsFor: 'as yet unclassified' stamp: 'jmv 11/10/2011 09:27'!                scrollerOffset"	^scroller position - self position"^self viewableBounds topLeft - scroller position"-3""^self position - scroller position"! !!PluggableScrollPane methodsFor: 'as yet unclassified' stamp: 'jmv 11/10/2011 09:28'!                      scrollerOffset: newOffsetself flag: #jmvVer."Ah, ademas ver #resizeScroller. Parece que con el disenio viejo, el scroller esta limitado en size a lo visible. Ahora, como el que clippea es el owner, el scroller debe ser tan grande como el contenido!!""	scroller position: self position - newOffset"	scroller position: self viewableBounds topLeft - newOffset"'' print.('#scrollerOffset: ', newOffset printString) print.Este es el codigo que habia puesto antes en TransformMorph2... Revivirlo?	txOffset = newOffset ifFalse: [		delta _ txOffset - newOffset.		txOffset _ newOffset.		delta print.		submorphs do: [ :m |			m bounds print.			m privateFullMoveBy: delta.			m bounds print ].		self redrawNeeded ].thisContext printStack: 5"! !!HierarchicalListMorph methodsFor: 'accessing' stamp: 'jmv 11/14/2011 10:40'!                              columns	^columns! !!HierarchicalListMorph methodsFor: 'accessing' stamp: 'jmv 11/14/2011 10:40'!                           lineColor	"One line color for the whole system."		lineColor ifNotNil: [ ^lineColor ].	^ Theme current line! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 10:40'! drawLinesOn: aCanvas 	| lColor |	lColor _ self lineColor.	scroller submorphs do: [ :submorph | 		(submorph isExpanded or: [			(aCanvas isVisible: submorph fullBounds) or: [		"needs #fullBounds 'in Owner'"self flag: #jmvVer.				"strange!! #isVisible expects a rectangle, and #nextSibling answers a Morph... Looks like it never gets here!! (jmv)				well, most likely it does. #isVisible accepts anything that responds to #left, #right, #top, #bottom..."				submorph nextSibling notNil and: [ aCanvas isVisible: submorph nextSibling ] ] ]) ifTrue: [			submorph				drawLinesOn: aCanvas				lineColor: lColor ] ]! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 10:40'!     drawOn: aCanvas	super drawOn: aCanvas.	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [		aCanvas			frameRectangle: self focusIndicatorRectangle 			borderWidth: Preferences focusIndicatorWidth			color: Theme current focusIndicator ].	selectedMorph  ifNotNil: [		aCanvas			fillRectangle: ((selectedMorph bounds: selectedMorph bounds in: self)				intersect: scroller bounds)			colorOrInfiniteForm: (Theme current listHighlightFocused: self hasKeyboardFocus)].	Preferences showLinesInHierarchyViews ifTrue:[		self drawLinesOn: aCanvas ]! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 10:40'!                     expandedForm	^ScrollbarButton arrowOfDirection: #bottom! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 10:40'!                      highlightSelection	selectedMorph ifNotNil: [selectedMorph highlight]! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 10:40'!         notExpandedForm	^ScrollbarButton arrowOfDirection: #right! !!HierarchicalListMorph methodsFor: 'drawing' stamp: 'jmv 11/14/2011 10:40'!                    unhighlightSelection	selectedMorph ifNotNil: [selectedMorph unhighlight]! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 10:40'!                               handlesKeyboard	^self visible! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 10:40'!         itemFromPoint: aPoint	"Return the list element (morph) at the given point or nil if outside"	| ptY |	self flag: #jmvVer. "Pensar, creo que en estas si vamos a agregar un morph nuevo para reem al scroller. Sera una nueve clase. ver"	scroller hasSubmorphs ifFalse:[^nil].	(scroller fullBounds containsPoint: aPoint) ifFalse:[^nil].	ptY _ (scroller firstSubmorph internalizePositionToOwner: aPoint from: self) y.	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"	scroller firstSubmorph top > ptY ifTrue:[^nil].	scroller lastSubmorph bottom < ptY ifTrue:[^nil].	"now use binary search"	^scroller 		findSubmorphBinary:[:item|			(item top <= ptY and:[item bottom >= ptY])				ifTrue:[0] "found"				ifFalse:[ (item top + item bottom // 2) > ptY ifTrue:[-1] ifFalse:[1]]]! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 10:40'!                             keyStroke: event 	"Process potential command keys"	| args aCharacter |	(self focusKeyboardFor: event)		ifTrue: [ ^ self ].	(self scrollByKeyboard: event)		ifTrue: [ ^self ].	aCharacter _ event keyCharacter.	(self arrowKey: aCharacter)		ifTrue: [ ^self ].	keystrokeActionSelector ifNil: [^self].	(args _ keystrokeActionSelector numArgs) = 1 		ifTrue: [^mainView perform: keystrokeActionSelector with: aCharacter].	args = 2 		ifTrue: [			^mainView 				perform: keystrokeActionSelector				with: aCharacter				with: self].	^self error: 'The keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 10:40'!  keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus changes.	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.	In this case, all we need to do is to redraw border feedback"	"No. Selection might also be shown differently. Invalidate everything"	false		ifTrue: [ self invalidateBorderFeedback ]		ifFalse: [ self redrawNeeded ]! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 10:40'!              mouseDown: evt	| aMorph |	evt hand newKeyboardFocus: self.	aMorph _ self itemFromPoint: evt position.	(aMorph notNil and:[aMorph inToggleArea: (aMorph internalizePositionToOwner: evt position from: self)])		ifTrue:[^self toggleExpandedState: aMorph event: evt]. 	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	aMorph ifNil:[^super mouseDown: evt].	aMorph highlightForMouseDown.	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self 		event: evt 		clkSel: #click:		dblClkSel: nil		tripleClkSel: nil! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 10:40'!         mouseEnter: event	super mouseEnter: event.	Preferences focusFollowsMouse		ifTrue: [ event hand newKeyboardFocus: self ]! !!HierarchicalListMorph methodsFor: 'event handling' stamp: 'jmv 11/14/2011 10:40'!              mouseUp: event 	| aMorph |	aMorph := self itemFromPoint: event position.	aMorph ifNil: [^self].	aMorph highlightedForMouseDown ifFalse: [^self].	aMorph highlightForMouseDown: false.	"No change if model is locked"	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |		w okToChange ifFalse: [^ self]].	((autoDeselect isNil or: [autoDeselect]) and: [aMorph == selectedMorph]) 		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].	Cursor normal show! !!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 11/14/2011 10:40'!             expandAll	(selectedMorph isNil		or: [selectedMorph isExpanded])		ifTrue: [^self].	self expandAll: selectedMorph.	self adjustSubmorphPositions! !!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 11/14/2011 10:40'!                              expandAll: aMorph	| allChildren |	aMorph toggleExpandedState.	allChildren _ OrderedCollection new: 10.	aMorph recursiveAddTo: allChildren.	allChildren do: [:each | 		(each canExpand and: [each isExpanded not])			ifTrue: [self expandAll: each]].! !!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 11/14/2011 10:40'!                    toggleExpandedState: aMorph event: event	| oldState |	"self setSelectedMorph: aMorph."	event mouseButton2Pressed ifTrue: [		oldState _ aMorph isExpanded.		scroller submorphs copy do: [ :each |			(each canExpand and: [each isExpanded = oldState]) ifTrue: [				each toggleExpandedState.			].		].	] ifFalse: [		aMorph toggleExpandedState.	].	self adjustSubmorphPositions.	! !!HierarchicalListMorph methodsFor: 'events-processing' stamp: 'jmv 11/14/2011 10:40'!      handleMouseMove: anEvent	"Reimplemented because we really want #mouseMove when a morph is dragged around"	anEvent wasHandled ifTrue:[^self]. "not interested"	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.	(self handlesMouseStillDown: anEvent) ifTrue:[		"Step at the new location"		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue			arguments: {anEvent copy resetHandlerFields}			stepTime: 1].! !!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 10:40'!        scrollDeltaHeight	self flag: #jmvVer. "Pensar, creo que en estas si vamos a agregar un morph nuevo para reem al scroller. Sera una nueve clase. ver"	scroller hasSubmorphs ifFalse: [ ^1].	^ scroller firstSubmorph height! !!HierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 11/14/2011 10:40'!                 scrollDeltaWidth"A guess -- assume that the width of a char is approx 1/2 the height of the font"	^ self scrollDeltaHeight // 2! !!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 10:40'!    autoDeselect: trueOrFalse	"Enable/disable autoDeselect (see class comment)"	autoDeselect _ trueOrFalse.! !!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 10:40'!                               currentlyExpanded	^(scroller submorphs select: [ :each | each isExpanded]) collect: [ :each |		each complexContents	].	! !!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 10:40'!            indentingItemClass		^IndentingListItemMorph! !!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 10:50'!                           initialize	super initialize.	self on: #mouseMove send: #mouseStillDown:onItem: to: self.	scroller _ InnerHierarchicalListMorph new.	self addMorph: scroller.	"ira aca..."	self scrollerOffset: 0@ 0! !!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 10:40'!                              list: aCollection	| wereExpanded morphList |	wereExpanded _ self currentlyExpanded.	scroller removeAllMorphs.	(aCollection isNil or: [aCollection isEmpty]) ifTrue: [^ self selectedMorph: nil].	morphList _ OrderedCollection new.	self 		addMorphsTo: morphList		from: aCollection 		allowSorting: false		withExpandedItems: wereExpanded		atLevel: 0.	self insertNewMorphs: morphList.! !!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 10:40'!  listItemHeight	"This should be cleaned up.  The list should get spaced by this parameter."	^ 12! !!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 11/14/2011 10:40'!       model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel	self model: anObject.	getListSelector _ getListSel.	getSelectionSelector _ getSelectionSel.	setSelectionSelector _ setSelectionSel.	mainView _ aMainView.	menuGetter _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self list: self getList.! !!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 11/14/2011 10:40'!       arrowKey: aChar	"Handle a keyboard navigation character. Answer true if handled, false if not."	| keyEvent |	keyEvent _ aChar asciiValue.     keyEvent = 31 ifTrue: [ "down"		self setSelectionIndex: self getSelectionIndex+1.		^true].     keyEvent = 30 ifTrue: [ "up"		self setSelectionIndex: (self getSelectionIndex-1 max: 1).		^true].     keyEvent = 1  ifTrue: [ "home"		self setSelectionIndex: 1.		^true].     keyEvent = 4  ifTrue: [ "end"		self setSelectionIndex: scroller submorphs size.		^true].      keyEvent = 11 ifTrue: [ "page up"		self setSelectionIndex: (self getSelectionIndex - self numSelectionsInView max: 1).		^true].     keyEvent = 12  ifTrue: [ "page down"		self setSelectionIndex: self getSelectionIndex + self numSelectionsInView.		^true].	keyEvent = 29 ifTrue: [ "right"		selectedMorph ifNotNil:[			(selectedMorph canExpand and:[selectedMorph isExpanded not])				ifTrue:[self toggleExpandedState: selectedMorph]				ifFalse:[self setSelectionIndex: self getSelectionIndex+1].		].		^true].	keyEvent = 28 ifTrue: [ "left"		selectedMorph ifNotNil:[			(selectedMorph isExpanded)				ifTrue:[self toggleExpandedState: selectedMorph]				ifFalse:[self setSelectionIndex: (self getSelectionIndex-1 max: 1)].		].		^true].	^false! !!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 11/14/2011 10:40'!          getSelectionIndex	^scroller submorphs indexOf: selectedMorph! !!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 11/14/2011 10:40'!      setSelectionIndex: idx	"Called internally to select the index-th item."	| theMorph index |	idx ifNil: [^ self].	index := idx min: scroller submorphs size max: 0.	theMorph _ index = 0 ifTrue: [nil] ifFalse: [scroller submorphs at: index].	self setSelectedMorph: theMorph.! !!HierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'jmv 11/14/2011 10:40'!               toggleExpandedState: aMorph	aMorph toggleExpandedState.	self adjustSubmorphPositions.! !!HierarchicalListMorph methodsFor: 'model access' stamp: 'jmv 11/14/2011 10:40'!                  getList 	"Answer the list to be displayed."	^(model perform: (getListSelector ifNil: [^#()])) ifNil: [#()]! !!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 10:40'!                              getCurrentSelectionItem	^model perform: (getSelectionSelector ifNil: [^nil])	! !!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 10:40'!                             maximumSelection	^ scroller submorphs size! !!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 10:40'!minimumSelection	^ 1! !!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 10:40'!                        numSelectionsInView	^ self viewableHeight // self listItemHeight! !!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 13:54'!            scrollSelectionIntoViewself flag: #jmvVer. "mhhhh"selectedMorph ifNotNil: [	self scrollToShow: (selectedMorph bounds translateBy: ( scroller bounds topLeft negated)) ]! !!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 10:40'!   selectedMorph: aMorph	self unhighlightSelection.	selectedMorph _ aMorph.	self highlightSelection! !!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 10:40'!         selection: item	"Called from outside to request setting a new selection.	Assumes scroller submorphs is exactly our list.	Note: MAY NOT work right if list includes repeated items"	| i |	item ifNil: [^self selectionIndex: 0].	i _ scroller submorphs findFirst: [:m | m complexContents == item].	i > 0 ifTrue: [^self selectionIndex: i].	i _ scroller submorphs findFirst: [:m | m withoutListWrapper = item withoutListWrapper].	self selectionIndex: i! !!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 13:47'!       selectionIndex: idx	"Called internally to select the index-th item."	| theMorph index |	idx ifNil: [^ self].	index := idx min: scroller submorphs size max: 0.	theMorph _ index = 0 ifTrue: [nil] ifFalse: [scroller submorphs at: index].	self selectedMorph: theMorph.	"Scroll into view -- should be elsewhere"	"	theMorph ifNotNil: [		((theMorph bounds top - self scrollerOffset y) >= 0			and: [(theMorph bounds bottom - self scrollerOffset y) <= self viewableHeight]) ifFalse: [			range _ self vTotalScrollRange.			scrollBar value: (range > 0				ifTrue: [((index-1 * theMorph height) / self vTotalScrollRange)									truncateTo: scrollBar scrollDelta]				ifFalse: [0]).			self scrollerOffset: -3 @ (range * scrollBar value)]].	"	self scrollSelectionIntoView! !!HierarchicalListMorph methodsFor: 'selection' stamp: 'jmv 11/14/2011 13:43'!       setSelectedMorph: aMorph	model 		perform: (setSelectionSelector ifNil: [^self]) 		with: aMorph complexContents	"leave last wrapper in place" ! !!HierarchicalListMorph methodsFor: 'updating' stamp: 'jmv 11/14/2011 10:40'!                            update: aSymbol	super update: aSymbol.	aSymbol == getSelectionSelector 		ifTrue: [			self selection: self getCurrentSelectionItem.			^self].	aSymbol == getListSelector 		ifTrue: [			self list: self getList.			^self].	((aSymbol isKindOf: Array) 		and: [ aSymbol notEmpty and: [aSymbol first == #openPath]]) 			ifTrue: [				^(scroller submorphs at: 1 ifAbsent: [^self]) 					openPath: aSymbol allButFirst]! !!HierarchicalListMorph methodsFor: 'private' stamp: 'jmv 11/14/2011 10:40'!              addMorphsTo: morphList from: aCollection allowSorting: sortBoolean withExpandedItems: expandedItems atLevel: newIndent	| priorMorph newCollection firstAddition |	priorMorph _ nil.	newCollection _ (sortBoolean and: [sortingSelector notNil]) ifTrue: [		aCollection asOrderedCollection sort: [ :a :b | 			(a perform: sortingSelector) <= (b perform: sortingSelector)]	] ifFalse: [		aCollection	].	firstAddition _ nil.	newCollection do: [:item | 		priorMorph _ self indentingItemClass basicNew 			initWithContents: item 			prior: priorMorph 			forList: self			indentLevel: newIndent.		firstAddition ifNil: [firstAddition _ priorMorph].		morphList add: priorMorph.		((item hasEquivalentIn: expandedItems) or: [priorMorph isExpanded]) ifTrue: [			priorMorph isExpanded: true.			priorMorph 				addChildrenForList: self 				addingTo: morphList				withExpandedItems: expandedItems.		].	].	^firstAddition	! !!HierarchicalListMorph methodsFor: 'private' stamp: 'jmv 11/14/2011 10:40'!                    addSubmorphsAfter: parentMorph fromCollection: aCollection allowSorting: sortBoolean	| priorMorph morphList newCollection |	priorMorph _ nil.	newCollection _ (sortBoolean and: [sortingSelector notNil]) ifTrue: [		aCollection asOrderedCollection sort: [ :a :b | 			(a perform: sortingSelector) <= (b perform: sortingSelector)]	] ifFalse: [		aCollection	].	morphList _ OrderedCollection new.	newCollection do: [:item | 		priorMorph _ self indentingItemClass basicNew 			initWithContents: item 			prior: priorMorph 			forList: self			indentLevel: parentMorph indentLevel + 1.		morphList add: priorMorph.	].	scroller addAllMorphs: morphList after: parentMorph.	^morphList	! !!HierarchicalListMorph methodsFor: 'private' stamp: 'jmv 11/14/2011 14:13'!                             adjustSubmorphPositions	| p h w p0 |	w _ self hTotalScrollRange.	p0 _ scroller bounds topLeft..	p _ 0@0.	scroller submorphsDo: [ :each |		h _ each height.		each privateBounds: (p+p0 extent: w@h).		p _ p + (0@h) ].		self flag: #jmvVer. "feo... bueno, ya fue mejorando un poco..."	scroller extent: w@p y.	self 		redrawNeeded;		layoutChanged;		setScrollDeltas! !!HierarchicalListMorph methodsFor: 'private' stamp: 'jmv 11/14/2011 10:40'!                           insertNewMorphs: morphList	scroller addAllMorphs: morphList.	self adjustSubmorphPositions.	self selection: self getCurrentSelectionItem.	self setScrollDeltas.! !!HierarchicalListMorph methodsFor: 'private' stamp: 'jmv 11/14/2011 10:40'!           noteRemovalOfAll: aCollection	scroller removeAllMorphsIn: aCollection.	(aCollection includes: selectedMorph) ifTrue: [self setSelectedMorph: nil].! !!HierarchicalListMorph methodsFor: 'scrolling' stamp: 'jmv 11/14/2011 14:57'!                        hTotalScrollRange"Return the width of the widest item in the list"self flag: #jmvVer.	"Esto ya era feote en la implementacion original...""Ademas, ver implementors. Acomodar. Lo hace el morph de afuera o el de adentro?Lo mismo puede preguntarse por muchos metodos...Por aqui ibamos... Creo que estabamos pensando en que cada morph conozca y tenga su ancho, etc...Pequea disgresin:Lo ideal seria que solo quede ScrollablePane, y que TODO el comportamientoo actualmente en las subclases migre al morph de adentro. Eso ademas complaceria a Bernhard: Siempre le molesto que haya 2 textMorphs...En definitiva, deberia leerse	^scroller width	"	^scroller desiredWidth! !!HierarchicalListMorph methodsFor: 'scrolling' stamp: 'jmv 11/14/2011 13:36'!       vTotalScrollRange""self flag: #jmvVer.	"revisar"	(scroller submorphs size > 0) ifFalse:[ ^0 ].	^scroller submorphs last fullBounds bottom - scroller bounds top! !!HierarchicalListMorph methodsFor: 'menu' stamp: 'jmv 11/14/2011 10:40'!              getMenu	"Answer the menu for this view"	menuGetter ifNil: [^ nil].	(menuGetter is: #MessageSend) ifTrue: [		^menuGetter value ].	menuGetter numArgs = 0 ifTrue: [		^ mainView perform: menuGetter ].	^ self error: 'The menuGetter has an unsupported number of arguments'! !!HierarchicalListMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 10:40'!            model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors."	^ self new		model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel! !!PluggableListMorph2 methodsFor: 'accessing' stamp: 'jmv 11/10/2011 09:07'!         rowAtLocation: aPoint	"Return the row at the given point or 0 if outside"	| pointInListMorphCoords |self flag: #jmvVer. "Cuanda haya verdaderos cambios de sistCoord!!"	pointInListMorphCoords _ scroller internalizePosition: aPoint from: self.	^self listMorph rowAtLocation: pointInListMorphCoords.! !!PluggableListMorph2 methodsFor: 'as yet unclassified' stamp: 'jmv 11/10/2011 09:13'!                        initialize	super initialize.	scroller _ InnerListMorph new.	scroller listSource: self.	scroller width: self width.	"mhhhh"	scroller color: self textColor.	self addMorph: scroller.self flag: #jmvVer.	"O mejor hacer		scrollBar setValue: 0.0.	o algo asi?	De cualquier manera, toda esta basura deberia ponerse a cero en los initialize (del scroller y del scrollBar), no?"	self scrollerOffset: 0@ 0! !!PluggableListMorph2 methodsFor: 'as yet unclassified' stamp: 'jmv 11/10/2011 09:14'!              listMorphself flag: #jmvVer."Podemos reemplazar los senders locales por accesos directos (el doble encapsulamiento es tonto) una vez que quede definido el shape de la clase!!"	^scroller! !!PluggableListMorph2 methodsFor: 'drawing' stamp: 'jmv 11/9/2011 18:00'!                      drawOn: aCanvas	super drawOn: aCanvas.	(drawKeyboardFocusIndicator and: [ self hasKeyboardFocus ]) ifTrue: [		aCanvas			frameRectangle: self focusIndicatorRectangle			borderWidth: Preferences focusIndicatorWidth			color: Theme current focusIndicator ].! !!PluggableListMorph2 methodsFor: 'drawing' stamp: 'jmv 11/9/2011 18:00'!               highlightSelection! !!PluggableListMorph2 methodsFor: 'drawing' stamp: 'jmv 11/9/2011 18:00'!unhighlightSelection! !!PluggableListMorph2 methodsFor: 'event handling' stamp: 'jmv 11/9/2011 18:00'!                      handlesKeyboard	^self visible! !!PluggableListMorph2 methodsFor: 'event handling' stamp: 'jmv 11/9/2011 18:00'!            keyStroke: event 	"Process keys"		| aCharacter |	(self focusKeyboardFor: event)		ifTrue: [ ^ self ].	(self scrollByKeyboard: event) 		ifTrue: [ ^self ].	aCharacter _ event keyCharacter.	(self arrowKey: aCharacter)		ifTrue: [ ^self ].	aCharacter asciiValue = 27 ifTrue: [	" escape key"		^ self mouseButton2Activity].	event anyModifierKeyPressed		ifTrue: [			(self keystrokeAction: aCharacter)				ifTrue: [ ^self ]].	^ self keyboardSearch: aCharacter! !!PluggableListMorph2 methodsFor: 'event handling' stamp: 'jmv 11/9/2011 18:00'!                          keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus changes.	The given argument indicates that the receiver is gaining (versus losing) the keyboard focus.	In this case, all we need to do is to redraw border feedback"	"No. Selection might also be shown differently. Invalidate everything"	false		ifTrue: [ self invalidateBorderFeedback ]		ifFalse: [ self redrawNeeded ]! !!PluggableListMorph2 methodsFor: 'event handling' stamp: 'jmv 11/9/2011 18:00'!                 mouseEnter: event	super mouseEnter: event.	Preferences focusFollowsMouse		ifTrue: [ event hand newKeyboardFocus: self ]! !!PluggableListMorph2 methodsFor: 'events' stamp: 'jmv 11/9/2011 18:00'!                         doubleClick: event	| index |	doubleClickSelector ifNil: [^super doubleClick: event].	index _ self rowAtLocation: event position.	index = 0 ifTrue: [^super doubleClick: event].	"selectedMorph ifNil: [self setSelectedMorph: aMorph]."	^ self model perform: doubleClickSelector! !!PluggableListMorph2 methodsFor: 'events' stamp: 'jmv 11/9/2011 18:00'!                            mouseDown: evt	| row |	evt mouseButton2Pressed  "First check for option (menu) click"		ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		evt hand newKeyboardFocus: self.		"If we are focusing, deselect, so that later selection doesn't result in deselect."		self listMorph noSelection].	row _ self rowAtLocation: evt position.	row = 0  ifTrue: [^super mouseDown: evt].	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."	evt hand 		waitForClicksOrDragOrSimulatedMouseButton2: self		event: evt		clkSel: #click:		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick: ])		tripleClkSel: nil! !!PluggableListMorph2 methodsFor: 'events' stamp: 'jmv 11/9/2011 18:00'!                        mouseUp: event	"The mouse came up within the list; take appropriate action"	| row |	row _ self rowAtLocation: event position.	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |		w okToChange ifFalse: [^ self]].	(autoDeselect == false and: [row = 0]) ifTrue: [^ self].  "work-around the no-mans-land bug"	"No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [row == self selectionIndex])		ifTrue: [self changeModelSelection: 0]		ifFalse: [self changeModelSelection: row].	Cursor normal show.! !!PluggableListMorph2 methodsFor: 'events-processing' stamp: 'jmv 11/9/2011 18:00'!                        handleMouseMove: anEvent	"Reimplemented because we really want #mouseMove when a morph is dragged around"	anEvent wasHandled ifTrue:[^self]. "not interested"	(anEvent anyButtonPressed and:[anEvent hand mouseFocus == self]) ifFalse:[^self].	anEvent wasHandled: true.	self mouseMove: anEvent.	(self handlesMouseStillDown: anEvent) ifTrue:[		"Step at the new location"		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue			arguments: {anEvent copy resetHandlerFields}			stepTime: 1].! !!PluggableListMorph2 methodsFor: 'geometry' stamp: 'jmv 11/9/2011 18:00'!           resizeScroller	super resizeScroller.		"Change listMorph's bounds to the new width. It is either the size	of the widest list item, or the size of self, whatever is bigger"	self listMorph adjustWidth! !!PluggableListMorph2 methodsFor: 'geometry' stamp: 'jmv 11/9/2011 18:00'!       scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled."	^ self font height! !!PluggableListMorph2 methodsFor: 'geometry' stamp: 'jmv 11/9/2011 18:00'!      scrollDeltaWidth"A guess -- assume that the width of a char is approx 1/2 the height of the font"	^ self scrollDeltaHeight // 2! !!PluggableListMorph2 methodsFor: 'initialization' stamp: 'jmv 11/9/2011 18:00'!        autoDeselect: trueOrFalse	"Enable/disable autoDeselect (see class comment)"	autoDeselect _ trueOrFalse.! !!PluggableListMorph2 methodsFor: 'initialization' stamp: 'jmv 11/9/2011 18:00'!  font	^ self listMorph font! !!PluggableListMorph2 methodsFor: 'initialization' stamp: 'jmv 11/9/2011 18:00'!              font: aFontOrNil	self listMorph font: aFontOrNil.! !!PluggableListMorph2 methodsFor: 'initialization' stamp: 'jmv 11/9/2011 18:00'!                        initForKeystrokes	lastKeystrokeTime _ 0.	lastKeystrokes _ ''! !!PluggableListMorph2 methodsFor: 'initialization' stamp: 'jmv 11/9/2011 18:00'!             listItemHeight	"This should be cleaned up.  The list should get spaced by this parameter."	^ 12! !!PluggableListMorph2 methodsFor: 'initialization' stamp: 'jmv 10/25/2011 17:13'!         model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSelself flag: #jmvVer.	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	mainView _ aMainView.	menuGetter _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self		updateList;"		selectionIndex: self getCurrentSelectionIndex;"		"No se acaba de hacer en #updateList???"		initForKeystrokes! !!PluggableListMorph2 methodsFor: 'initialization' stamp: 'jmv 11/9/2011 18:00'!                        textColor	""	^ Theme current text! !!PluggableListMorph2 methodsFor: 'menu' stamp: 'jmv 11/9/2011 18:00'!                  getMenu	"Answer the menu for this view"	menuGetter ifNil: [^ nil].	(menuGetter is: #MessageSend) ifTrue: [		^menuGetter value ].	menuGetter numArgs = 0 ifTrue: [		^ mainView perform: menuGetter ].	^ self error: 'The menuGetter has an unsupported number of arguments'! !!PluggableListMorph2 methodsFor: 'menus' stamp: 'jmv 11/9/2011 18:00'!  addCustomMenuItems:  aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	aMenu add: 'list font...' target: self action: #setListFont.	aMenu add: 'copy list to clipboard' target: self action: #copyListToClipboard.	aMenu add: 'copy selection to clipboard' target: self action: #copySelectionToClipboard! !!PluggableListMorph2 methodsFor: 'menus' stamp: 'jmv 11/9/2011 18:00'!                   copyListToClipboard	"Copy my items to the clipboard as a multi-line string"	| stream |	stream _ WriteStream on: (String new: list size * 40).	list do: [:ea | stream nextPutAll: ea asString] separatedBy: [stream nextPut: Character cr].	Clipboard storeObject: stream contents! !!PluggableListMorph2 methodsFor: 'menus' stamp: 'jmv 11/9/2011 18:00'!                             copySelectionToClipboard	"Copy my selected item to the clipboard as a string"	self selection		ifNotNil:			[Clipboard storeObject: self selection asString]		ifNil:			[self flash]! !!PluggableListMorph2 methodsFor: 'menus' stamp: 'jmv 11/9/2011 18:00'!                            setListFont	"set the font for the list"	Preferences chooseFontWithPrompt: 'choose the font for this list' andSendTo: self withSelector: #font: highlight: self listMorph font! !!PluggableListMorph2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:00'!                             changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	setIndexSelector ifNotNil:		[model perform: setIndexSelector with: anInteger].! !!PluggableListMorph2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:00'! getCurrentSelectionIndex	"Answer the index of the current selection."	getIndexSelector ifNil: [^0].	^model perform: getIndexSelector! !!PluggableListMorph2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:00'!     getList	"Answer the list to be displayed.  Caches the returned list in the 'list' ivar"	getListSelector		ifNil: [^ #()].	list _ model perform: getListSelector.	list		ifNil: [^ #()].	list _ list collect: [ :item | item asStringOrText ].	^ list! !!PluggableListMorph2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:00'!                   getListItem: index	"get the index-th item in the displayed list"	list ifNotNil: [ ^list at: index ].	^self getList at: index! !!PluggableListMorph2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:00'!              getListSize	"return the current number of items in the displayed list"	getListSizeSelector ifNotNil: [ ^model perform: getListSizeSelector ].	^self getList size! !!PluggableListMorph2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:00'!          itemSelectedAmongMultiple: index	"return whether the index-th row is selected.  Always false in PluggableListMorph, but sometimes true in PluggableListMorphOfMany"	^false! !!PluggableListMorph2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:00'! keyboardSearch: aChar 	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	max _ self maximumSelection.	milliSeconds _ Time millisecondClockValue.	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"		lastKeystrokes _ ''].	lastKeystrokes _ lastKeystrokes , aChar asLowercase asString.	lastKeystrokeTime _ milliSeconds.	nextSelectionList _ OrderedCollection newFrom: (self getList copyFrom: oldSelection + 1 to: max).	nextSelectionList addAll: (self getList copyFrom: 1 to: oldSelection).	"Get rid of blanks and style used in some lists"	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]				ifNone: [^ self flash"match not found"].	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |		w okToChange ifFalse: [^ self]].	nextSelection _ self getList findFirst: [:a | a == nextSelectionText].	"No change if model is locked"	oldSelection == nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!PluggableListMorph2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:00'!                     keystrokeAction: aChar 	| args |	keystrokeActionSelector ifNil: [^false].	args _ keystrokeActionSelector numArgs.	args = 1 ifTrue: [		mainView perform: keystrokeActionSelector with: aChar.		^true ].	args = 2 		ifTrue: [			mainView 				perform: keystrokeActionSelector				with: aChar				with: self.			^true ].	^self error: 'keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!PluggableListMorph2 methodsFor: 'scrolling' stamp: 'jmv 11/9/2011 18:00'!      hTotalScrollRange"Return the width of the widest item in the list"	^self listMorph hTotalScrollRange! !!PluggableListMorph2 methodsFor: 'scrolling' stamp: 'jmv 11/10/2011 09:06'!       vTotalScrollRange	"Return the height extent of the receiver's submorphs."		"	(scroller submorphs size > 0) ifFalse:[ ^0 ].	^(scroller submorphs last fullBounds bottom)"self flag: #jmvVer. "Cualquier banana. Dejo el de super"^super vTotalScrollRange! !!PluggableListMorph2 methodsFor: 'selection' stamp: 'jmv 11/9/2011 18:00'!                getListSelector	^ getListSelector! !!PluggableListMorph2 methodsFor: 'selection' stamp: 'jmv 11/9/2011 18:00'!              maximumSelection	^ self getListSize! !!PluggableListMorph2 methodsFor: 'selection' stamp: 'jmv 11/9/2011 18:00'!            minimumSelection	^ 1! !!PluggableListMorph2 methodsFor: 'selection' stamp: 'jmv 11/9/2011 18:00'!                           numSelectionsInView	^ self viewableHeight // self listItemHeight! !!PluggableListMorph2 methodsFor: 'selection' stamp: 'jmv 11/12/2011 22:28'!              scrollSelectionIntoView	"make sure that the current selection is visible"	| row |	row _ self getCurrentSelectionIndex.	row = 0 ifTrue: [		^ scrollBar setValue: scrollBar value ].	self scrollToShow: (self listMorph drawBoundsForRowEspantoso: row)! !!PluggableListMorph2 methodsFor: 'selection' stamp: 'jmv 11/9/2011 18:00'!                     selectedMorph: aMorph"this shouldn't be used any longer""self isThisEverCalled ."Smalltalk beep.true ifTrue: [ ^self ].! !!PluggableListMorph2 methodsFor: 'selection' stamp: 'jmv 11/9/2011 18:00'!                    selection 	self selectionIndex = 0 ifTrue: [ ^nil ].	list ifNotNil: [ ^list at: self selectionIndex ].	^ self getListItem: self selectionIndex! !!PluggableListMorph2 methodsFor: 'selection' stamp: 'jmv 11/9/2011 18:00'!                               selection: item	"Called from outside to request setting a new selection."	self selectionIndex: (self getList indexOf: item)! !!PluggableListMorph2 methodsFor: 'selection' stamp: 'jmv 11/9/2011 18:00'!                  selectionIndex	"return the index we have currently selected, or 0 if none"	^self listMorph selectedRow ifNil: [ 0 ]! !!PluggableListMorph2 methodsFor: 'selection' stamp: 'jmv 11/11/2011 15:02'!                          selectionIndex: index	"Called internally to select the index-th item."	| row |	self unhighlightSelection.	row _ index ifNil: [ 0 ].	row _ row min: self getListSize.  "make sure we don't select past the end"	self listMorph selectedRow: row.	self highlightSelection.	"Do it once all extents and positions are set"	WorldState addDeferredUIMessage: [		self scrollSelectionIntoView ]! !!PluggableListMorph2 methodsFor: 'updating' stamp: 'jmv 11/9/2011 18:00'!             update: aSymbol 	"Refer to the comment in View|update:."	super update: aSymbol.	aSymbol == getListSelector ifTrue: [		self updateList.		^ self].	aSymbol == getIndexSelector ifTrue: [		self selectionIndex: self getCurrentSelectionIndex ]! !!PluggableListMorph2 methodsFor: 'updating' stamp: 'jmv 10/25/2011 17:14'!                            updateList	| index |	"the list has changed -- update from the model"	self listMorph listChanged.	self setScrollDeltas.self flag: #jmvVer."	scrollBar setValue: 0.0."	"Creo que #selectionIndex: siempre termina ajustando el scrollbar. En todo caso revisar. Detesto hacer basura de mas todo el tiempo!!"	index _ self getCurrentSelectionIndex.	self selectionIndex: index.! !!PluggableListMorph2 methodsFor: 'updating' stamp: 'jmv 11/9/2011 18:00'!                          verifyContents	"Verify the contents of the receiver, reconstituting if necessary.  Called whenever window is reactivated, to react to possible structural changes.  Also called periodically in morphic if the smartUpdating preference is true"	"This is done because our model is not the real one (i.e. Smalltalk). Some other browser might change our contents, without our model knowing it."	| newList oldList |	oldList _ list ifNil: [ #() ].	newList _ self getList.	((oldList == newList) "fastest" or: [ oldList = newList ]) ifTrue: [ ^ self ].	self updateList.! !!PluggableListMorph2 methodsFor: 'keyboard navigation' stamp: 'jmv 11/9/2011 18:00'!                 arrowKey: aChar	"Process the up and down arrows in a list pane.  Note that the listView tells us what index variable, how to get the list, and how to move the index."	| keyEvent oldSelection nextSelection max min howMany answer w |	answer _ false.	keyEvent _ aChar asciiValue.	oldSelection _ self getCurrentSelectionIndex.	nextSelection _ oldSelection.	max _ self maximumSelection.	min _ self minimumSelection.	howMany _ self numSelectionsInView.	"get this exactly??"	keyEvent = 31 ifTrue: [		"down-arrow; move down one, wrapping to top if needed"		nextSelection _ oldSelection + 1.		nextSelection > max ifTrue: [ nextSelection _ 1 ]].	keyEvent = 30 ifTrue: [		"up arrow; move up one, wrapping to bottom if needed"		nextSelection _ oldSelection - 1.		nextSelection < 1 ifTrue: [ nextSelection _ max ]].	keyEvent = 1 ifTrue: [ nextSelection _ 1 ].			"home"	keyEvent = 4 ifTrue: [ nextSelection _ max ].		"end"	keyEvent = 11 ifTrue: [ nextSelection _ min max: oldSelection - howMany ].		"page up"	keyEvent = 12 ifTrue: [ nextSelection _ oldSelection + howMany min: max ].		"page down"	nextSelection = oldSelection ifFalse: [		w _ self ownerThatIsA: SystemWindow.		(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"			self changeModelSelection: nextSelection.			answer _ true ]].	^answer! !!PluggableListMorph2 class methodsFor: 'instance creation' stamp: 'jmv 11/9/2011 18:00'!          model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors."	^self model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: nil menuGetter: nil keystrokeAction: nil! !!PluggableListMorph2 class methodsFor: 'instance creation' stamp: 'jmv 11/9/2011 18:00'!    model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors."	^ self new		model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel! !!PluggableListMorphByItem2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:00'! changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setIndexSelector ifNotNil: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setIndexSelector with: item].	self update: getIndexSelector.! !!PluggableListMorphByItem2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:00'!                               getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getIndexSelector ifNil: [^ 0].	item _ model perform: getIndexSelector.	^ list findFirst: [ :x | x = item]! !!PluggableListMorphByItem2 methodsFor: 'as yet unclassified' stamp: 'jmv 11/9/2011 18:00'!  getList	"cache the raw items in itemList"	itemList := getListSelector ifNil: [ #() ] ifNotNil: [ model perform: getListSelector ].	^super getList! !!PluggableListMorphOfMany2 methodsFor: 'drawing' stamp: 'jmv 11/9/2011 18:01'!                       listSelectionAt: index	getSelectionListSelector ifNil:[^false].	^model perform: getSelectionListSelector with: index! !!PluggableListMorphOfMany2 methodsFor: 'drawing' stamp: 'jmv 11/9/2011 18:01'!                      listSelectionAt: index put: value	setSelectionListSelector ifNil:[^false].	^model perform: setSelectionListSelector with: index with: value! !!PluggableListMorphOfMany2 methodsFor: 'event handling' stamp: 'jmv 11/9/2011 18:01'!                        mouseDown: event	| oldIndex oldVal row w |	event mouseButton2Pressed ifTrue: [^ self mouseButton2Activity].	self hasKeyboardFocus ifFalse: [		event hand newKeyboardFocus: self ].	row _ self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	w _ self ownerThatIsA: SystemWindow.	(w isNil or: [ w okToChange ]) ifTrue: [ "No change if model is locked"		"Set meaning for subsequent dragging of selection"		dragOnOrOff _ (self listSelectionAt: row) not.		dragStartRow _ row.		oldIndex _ self getCurrentSelectionIndex.		oldIndex ~= 0 ifTrue: [oldVal _ self listSelectionAt: oldIndex].		"Set or clear new primary selection (listIndex)"		dragOnOrOff			ifTrue: [self changeModelSelection: row]			ifFalse: [self changeModelSelection: 0].		"Need to restore the old one, due to how model works, and set new one."		oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].		self listSelectionAt: row put: dragOnOrOff.		"event hand releaseMouseFocus: aMorph."		"aMorph changed"	].	event hand		waitForClicksOrDragOrSimulatedMouseButton2: self		event: event		clkSel: nil		dblClkSel: #doubleClick:		tripleClkSel: nil! !!PluggableListMorphOfMany2 methodsFor: 'event handling' stamp: 'jmv 11/10/2011 09:09'!                  mouseMove: event 	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| oldIndex oldVal row |self flag: #jmvVer. "Entender. Revisar uso scroller..."	event position y < bounds top 		ifTrue: [			scrollBar scrollUp: 1.			row _ self rowAtLocation: scroller bounds topLeft + (1 @ 1)]		ifFalse: [			row _ event position y > bounds bottom 				ifTrue: [					scrollBar scrollDown: 1.					self rowAtLocation: scroller bounds bottomLeft + (1 @ -1)]				ifFalse: [ self rowAtLocation: event position]].	row = 0 ifTrue: [^super mouseDown: event].	"No change if model is locked"	(self ownerThatIsA: SystemWindow) ifNotNil: [ :w |		w okToChange ifFalse: [^ self]].	dragOnOrOff ifNil: [			"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"			dragOnOrOff _ (self listSelectionAt: row) not].	"Set meaning for subsequent dragging of selection"	oldIndex _ self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].	"Set or clear new primary selection (listIndex)"	dragOnOrOff 		ifTrue: [ self changeModelSelection: row ]		ifFalse: [ self changeModelSelection: 0 ].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].		"Select all in between if drag was too fast"	"self listSelectionAt: row put: dragOnOrOff."	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |		self listSelectionAt: r put: dragOnOrOff]! !!PluggableListMorphOfMany2 methodsFor: 'event handling' stamp: 'jmv 11/9/2011 18:01'!          mouseUp: event	dragOnOrOff _ nil.  "So improperly started drags will have not effect"	dragStartRow _ nil! !!PluggableListMorphOfMany2 methodsFor: 'initialization' stamp: 'jmv 11/9/2011 18:01'!                          model: anObject listGetter: listSel primarySelectionGetter: getSelectionSel primarySelectionSetter: setSelectionSel listSelectionGetter: getListSel listSelectionSetter: setListSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel	"setup a whole load of pluggability options"	getSelectionListSelector _ getListSel.	setSelectionListSelector _ setListSel.	self 		model: anObject		listGetter: listSel		indexGetter: getSelectionSel		indexSetter: setSelectionSel		mainView: aMainView		menuGetter: getMenuSel		keystrokeAction: keyActionSel! !!PluggableListMorphOfMany2 methodsFor: 'updating' stamp: 'jmv 11/9/2011 18:01'!                     update: aSymbol 	super update: aSymbol.	aSymbol == #allSelections ifTrue: [		self selectionIndex: self getCurrentSelectionIndex.		self redrawNeeded]! !!PluggableListMorphOfMany2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:01'!               itemSelectedAmongMultiple: index	^self listSelectionAt: index! !!PluggableListMorphOfMany2 class methodsFor: 'instance creation' stamp: 'jmv 11/9/2011 18:01'!                             model: anObject listGetter: listSel primarySelectionGetter: getSelectionSel primarySelectionSetter: setSelectionSel listSelectionGetter: getListSel listSelectionSetter: setListSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel	^self new model: anObject listGetter: listSel primarySelectionGetter: getSelectionSel primarySelectionSetter: setSelectionSel listSelectionGetter: getListSel listSelectionSetter: setListSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel! !!PluggableMessageCategoryListMorph2 methodsFor: 'as yet unclassified' stamp: 'jmv 11/9/2011 18:01'!                  model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel rawListGetter: getRawSel	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	mainView _ aMainView.	menuGetter _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	getRawListSelector _ getRawSel.	self updateList.	self selectionIndex: self getCurrentSelectionIndex.	self initForKeystrokes! !!PluggableMessageCategoryListMorph2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 18:01'!            getList	"Differs from the generic in that here we obtain and cache the raw list, then cons it together with the special '-- all --' item to produce the list to be used in the browser.  This special handling is done in order to avoid excessive and unnecessary reformulation of the list in the step method"	getRawListSelector ifNil: ["should not happen!!" priorRawList _ nil.  ^ #()].	model classListIndex = 0 ifTrue: [^ priorRawList _ list _ Array new].	priorRawList _ model perform: getRawListSelector.	list := (Array with: ClassOrganizer allCategory), priorRawList.	^list! !!PluggableMessageCategoryListMorph2 methodsFor: 'updating' stamp: 'jmv 11/9/2011 18:01'!                               verifyContents	"This is done because our model is not the real one (i.e. Smalltalk). Some other browser might change our contents, without our model knowing it."	| newList newRawList |	(model editSelection == #editComment) ifTrue: [^ self].	model classListIndex = 0 ifTrue: [^ self].	newRawList _ model perform: getRawListSelector.	newRawList == priorRawList ifTrue: [^ self].  "The usual case; very fast"	priorRawList _ newRawList.	newList _ (Array with: ClassOrganizer allCategory), priorRawList.	list = newList ifTrue: [^ self].	self updateList! !!PluggableMessageCategoryListMorph2 class methodsFor: 'as yet unclassified' stamp: 'jmv 11/9/2011 18:01'!   model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel rawListGetter: getRawSel	^ self new model: anObject listGetter: getListSel indexGetter: getSelectionSel indexSetter: setSelectionSel mainView: aMainView menuGetter: getMenuSel keystrokeAction: keyActionSel rawListGetter: getRawSel! !!TextModelMorph2 methodsFor: 'accessing' stamp: 'jmv 11/10/2011 08:41'! editor	^self textMorph editor! !!TextModelMorph2 methodsFor: 'accessing' stamp: 'jmv 11/10/2011 09:14'!                     textMorphself flag: #jmvVer."Podemos reemplazar los senders locales por accesos directos (el doble encapsulamiento es tonto) una vez que quede definido el shape de la clase!!"	^ scroller! !!TextModelMorph2 methodsFor: 'accessing' stamp: 'jmv 11/10/2011 08:39'!                      wrapFlag: aBoolean	self textMorph wrapFlag: aBoolean! !!TextModelMorph2 methodsFor: 'dependents access' stamp: 'jmv 11/10/2011 08:46'!                      canDiscardEdits	"Return true if this view either has no text changes or does not care."	^ self textMorph canDiscardEdits! !!TextModelMorph2 methodsFor: 'drawing' stamp: 'jmv 11/10/2011 08:44'!                          drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	| bw bc |	super drawOn: aCanvas.	bw _ Preferences focusIndicatorWidth.	bc _ nil.	self wantsFrameAdornments ifTrue: [		model refusesToAccept			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"				bc _ Color tan]			ifFalse: [				self hasEditingConflicts					ifTrue: [						bw _ 3.						bc _ Color red ] 					ifFalse: [						self textMorph hasUnacceptedEdits							ifTrue: [								bc _ Color red]]]].	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [		bc ifNil: [			bc _ Theme current focusIndicator ]]	ifFalse: [		bc ifNotNil: [			bc _ bc alphaMixed: 0.4 with: Color white ]].	bc ifNotNil: [		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !!TextModelMorph2 methodsFor: 'drawing' stamp: 'jmv 11/9/2011 17:55'!          wantsFrameAdornments	^model wantsFrameAdornments! !!TextModelMorph2 methodsFor: 'editor access' stamp: 'jmv 11/10/2011 08:45'!                              clearSelection	"Tell my textMorph's editor to select nothing"	self textMorph clearSelection! !!TextModelMorph2 methodsFor: 'editor access' stamp: 'jmv 11/10/2011 08:39'!                 handleEdit: editBlock	| result |	self textMorph handleEdit: [ result _ editBlock value ].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!TextModelMorph2 methodsFor: 'editor access' stamp: 'jmv 11/9/2011 17:55'!            scrollSelectionIntoView	"Scroll my text into view if necessary and return true, else return false"	^ self scrollSelectionIntoView: nil! !!TextModelMorph2 methodsFor: 'editor access' stamp: 'jmv 11/11/2011 09:06'!       scrollSelectionIntoView: event	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest cpHere |	selRects _ self textMorph selectionRects.	selRects isEmpty ifTrue: [ ^ false ].	rectToTest _ selRects first merge: selRects last.	(event notNil and: [ event anyButtonPressed ]) ifTrue: [  "Check for autoscroll"self flag: #jmvVer. "Revisar"		cpHere _ scroller externalizePosition: event position to: self.		cpHere y <= bounds top			ifTrue:  [ rectToTest _ selRects first topLeft extent: 2@2 ]			ifFalse: [				cpHere y >= bounds bottom					ifTrue: [ rectToTest _ selRects last bottomRight extent: 2@2 ]					ifFalse: [ ^ false ]]].	selRect _ self textMorph bounds: rectToTest in: self.	selRect height > bounds height		ifTrue: [ ^ false ].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self viewableBounds) y ~= 0 ifTrue: [		"Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true ].	^ false! !!TextModelMorph2 methodsFor: 'editor access' stamp: 'jmv 11/10/2011 08:45'!          selectAll	"Tell my textMorph's editor to select all"	self textMorph selectAll! !!TextModelMorph2 methodsFor: 'event handling' stamp: 'jmv 11/10/2011 08:45'!                              doubleClick: event	self textMorph doubleClick: event! !!TextModelMorph2 methodsFor: 'event handling' stamp: 'jmv 11/9/2011 17:55'!                          handlesKeyboard	self flag: #jmv.	"Not answering true helps not hitting pluggable texts twice during navigation. Only the internal text morph will receive it.	If some problem is found, introduce a new selector, that answers ^self handlesKeyboard in morph (and LW) 	and only in this class it will answer false""	^self visible" 	^ super handlesKeyboard! !!TextModelMorph2 methodsFor: 'event handling' stamp: 'jmv 11/10/2011 08:45'!          keyStroke: evt	"A keystroke was hit while the receiver had keyboard focus.  Pass the keywtroke on to my textMorph, and and also, if I have an event handler, pass it on to that handler"	(self focusKeyboardFor: evt)		ifTrue: [ ^ self ].	self textMorph keyStroke: evt.	self eventHandler ifNotNil: [		self eventHandler keyStroke: evt fromMorph: self ]! !!TextModelMorph2 methodsFor: 'event handling' stamp: 'jmv 11/10/2011 08:45'!           mouseEnter: event	super mouseEnter: event.	Preferences focusFollowsMouse		ifTrue: [ event hand newKeyboardFocus: self textMorph ]! !!TextModelMorph2 methodsFor: 'event handling' stamp: 'jmv 11/10/2011 08:44'!          tripleClick: event	self textMorph tripleClick: event! !!TextModelMorph2 methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:55'!bottom	^bounds bottom! !!TextModelMorph2 methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:55'!                               innerHeight: aNumber	"Adjust height and scrollbar to the new contents height.	Nothing to do here: TextModelMorph height does not depend on contents height."! !!TextModelMorph2 methodsFor: 'geometry' stamp: 'jmv 11/10/2011 08:42'!                      resizeScroller	super resizeScroller.	self textMorph extent = self viewableBounds extent		ifFalse: [			self textMorph extent: self viewableBounds extent ]! !!TextModelMorph2 methodsFor: 'geometry' stamp: 'jmv 11/10/2011 08:55'!                       scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled."self flag: #jmvVer. "volar, no?""	scroller hasSubmorphs ifFalse: [ ^1]."	^ StrikeFont default height! !!TextModelMorph2 methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:55'!                     top	^bounds top! !!TextModelMorph2 methodsFor: 'initialization' stamp: 'jmv 11/10/2011 08:39'!                              acceptOnCR: aBoolean	self textMorph acceptOnCR: aBoolean! !!TextModelMorph2 methodsFor: 'initialization' stamp: 'jmv 11/10/2011 09:14'!                     initialize	super initialize.	hasEditingConflicts _ false.	scroller _ InnerTextMorph new.	scroller setEditView: self.	self addMorph: scroller.self flag: #jmvVer.	"O mejor hacer		scrollBar setValue: 0.0.	o algo asi?	De cualquier manera, toda esta basura deberia ponerse a cero en los initialize (del scroller y del scrollBar), no?"	self scrollerOffset: 0@ 0! !!TextModelMorph2 methodsFor: 'initialization' stamp: 'jmv 11/10/2011 08:45'!                              model: aTextModel	super model: aTextModel.	self textMorph model: model wrappedTo: self viewableWidth.	model refetch! !!TextModelMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/9/2011 17:55'!            correctFrom: start to: stop with: aString	^ self handleEdit: [ self editor correctFrom: start to: stop with: aString ]! !!TextModelMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/9/2011 17:55'!            correctSelectionWithString: aString	| result newPosition sel |	sel _ self editor selectionInterval.	result _ self correctFrom: sel first to: sel last with: aString.	newPosition _ sel first + aString size.	self setSelection: (newPosition to: newPosition - 1).	^ result! !!TextModelMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/9/2011 17:55'!                 nextTokenFrom: start direction: dir	^ self editor nextTokenFrom: start direction: dir! !!TextModelMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/9/2011 17:55'!             notify: aString at: anInteger in: aStream	^ self editor notify: aString at: anInteger in: aStream! !!TextModelMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/9/2011 17:55'! selectFrom: start to: stop	^ self editor selectFrom: start to: stop! !!TextModelMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/9/2011 17:55'!                               selectInvisiblyFrom: start to: stop	^ self editor selectInvisiblyFrom: start to: stop! !!TextModelMorph2 methodsFor: 'interactive error protocol' stamp: 'jmv 11/9/2011 17:55'!             selectionInterval	^ self editor selectionInterval! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/14/2011 09:28'!                             accept	"Inform the model of text to be accepted, and return true if OK."	| ok prevSelection prevScrollValue |	prevSelection _ self selectionInterval copy.	prevScrollValue _ scrollBar value.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) 		ifTrue: [^self flash].	self hasEditingConflicts 		ifTrue: [			(self 				confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' ) 					ifFalse: [^self flash]].	ok := model acceptFrom: self.	ok == true ifTrue: [		model refetch ].	"sps 8/13/2001 22:41: restore selection and scroll info"		["During the step for the browser, updatePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok 		ifTrue: [			self selectFrom: prevSelection first to: prevSelection last.			WorldState addDeferredUIMessage: [					World activeHand  newKeyboardFocus: self textMorph.					self setScrollDeltas.					scrollBar setValue: prevScrollValue ]]] 			on: Error			do: nil! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!     browseIt	self handleEdit: [ self editor browseIt ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                             cancel	model refetch! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                           chooseAlignment	self handleEdit: [ self editor changeAlignment ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!               classCommentsContainingIt	self handleEdit: [ self editor classCommentsContainingIt ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                           copySelection	self handleEdit: [ self editor copySelection ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                   cut	self handleEdit: [ self editor cut ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!       debugIt	self handleEdit: [ self editor debugIt ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                               doIt	self handleEdit: [ self editor evaluateSelectionAndDo: nil ifFail: nil ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!  explain	self handleEdit: [ self editor explain ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                               exploreIt	self handleEdit: [ self editor exploreIt ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                          fileItIn	self handleEdit: [ self editor fileItIn ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                             find	self handleEdit: [ self editor find ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!     findAgain	self handleEdit: [ self editor findAgain ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                           implementorsOfIt	self handleEdit: [ self editor implementorsOfIt ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!             inspectIt	self handleEdit: [ self editor inspectIt ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                           methodSourceContainingIt	self handleEdit: [ self editor methodSourceContainingIt ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                             methodStringsContainingit	self handleEdit: [ self editor methodStringsContainingit ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                           offerFontMenu	self handleEdit: [ self editor changeTextFont ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                  offerUndoHistory	self handleEdit: [ self editor offerUndoHistory ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!             paste	self handleEdit: [ self editor paste ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!   pasteRecent	"Paste an item chosen from RecentClippings."	| clipping |	(clipping _ Clipboard chooseRecentClipping) ifNil: [^ self].	self editor clipboardTextPut: clipping.	^ self handleEdit: [ self editor paste ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                       pasteString	self handleEdit: [ self editor pasteString ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/10/2011 08:39'!                      printIt	| result oldEditor |	self textMorph handleEdit: [		result _ (oldEditor _ self textMorph editor)			evaluateSelectionAndDo: [ :r | r]			ifFail: [^self flash]].	self textMorph installEditorToReplace: oldEditor.	self textMorph handleEdit: [oldEditor afterSelectionInsertAndSelect: result printString].	self scrollSelectionIntoView.! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                       redo	self handleEdit: [ self editor redo ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!     referencesToIt	self handleEdit: [ self editor referencesToIt ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                 sendersOfIt	self handleEdit: [ self editor sendersOfIt ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!                       setSearchString	self handleEdit: [ self editor setSearchString ]! !!TextModelMorph2 methodsFor: 'menu commands' stamp: 'jmv 11/9/2011 17:55'!               undo	self handleEdit: [ self editor undo ]! !!TextModelMorph2 methodsFor: 'model access' stamp: 'jmv 11/10/2011 09:09'!     setSelection: sel	self editor selectFrom: sel first to: sel last.		self flag: #jmvVer.	"hace falta? esta bien?"	self scrollSelectionIntoView ifFalse: [ scroller redrawNeeded ]! !!TextModelMorph2 methodsFor: 'model access' stamp: 'jmv 11/10/2011 08:45'!                             setTextColor: aColor	"Set the color of my text to the given color"	self textMorph color: aColor! !!TextModelMorph2 methodsFor: 'model access' stamp: 'jmv 11/9/2011 17:55'!               text	"The returned object should be treated as read-only, and never modified"	^ model actualContents! !!TextModelMorph2 methodsFor: 'transcript' stamp: 'jmv 11/9/2011 17:55'!             replaceSelectionWith: aText	^ self editor replaceSelectionWith: aText! !!TextModelMorph2 methodsFor: 'unaccepted edits' stamp: 'jmv 11/10/2011 08:41'!      askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	self textMorph askBeforeDiscardingEdits: aBoolean! !!TextModelMorph2 methodsFor: 'unaccepted edits' stamp: 'jmv 11/9/2011 17:55'!                  hasEditingConflicts	"Return true if a conflicting edit to the same code (typically) is known to have occurred after the current contents started getting edited"	^ hasEditingConflicts == true! !!TextModelMorph2 methodsFor: 'unaccepted edits' stamp: 'jmv 11/9/2011 17:55'!            hasEditingConflicts: aBoolean	hasEditingConflicts _ aBoolean! !!TextModelMorph2 methodsFor: 'unaccepted edits' stamp: 'jmv 11/10/2011 08:46'!              hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag in my morph."	self textMorph hasUnacceptedEdits: aBoolean! !!TextModelMorph2 methodsFor: 'updating' stamp: 'jmv 11/10/2011 08:45'!                           update: aSymbol	super update: aSymbol.	aSymbol ifNil: [^self].	aSymbol == #flash ifTrue: [^self flash].	aSymbol == #actualContents ifTrue: [		"Some day, it would be nice to keep objects and update them		instead of throwing them away all the time for no good reason..."		self textMorph releaseParagraph.		self textMorph formatAndStyleIfNeeded.		^self].	aSymbol == #acceptedContents ifTrue: [		self textMorph hasUnacceptedEdits ifTrue: [			self hasEditingConflicts: true.				^self redrawNeeded ].		model refetch.		^self].	aSymbol == #refetched ifTrue: [		self setSelection: model getSelection.		self hasUnacceptedEdits: false.		^self].	aSymbol == #initialSelection ifTrue: [		^self setSelection: model getSelection].	aSymbol == #autoSelect ifTrue: [		self handleEdit: [			TextEditor abandonChangeText.	"no replacement!!"			self editor				setSearch: model autoSelectString;				findAndReplaceMany: true ]].	"Quite ugly"	aSymbol == #clearUserEdits ifTrue: [^self hasUnacceptedEdits: false].	aSymbol == #shoutStyle ifTrue: [		self stylerStyled.		^self redrawNeeded ].! !!TextModelMorph2 methodsFor: 'scrolling' stamp: 'jmv 11/10/2011 09:03'!              hTotalScrollRange"Return the width of the widest item in the list"	self textMorph isWrapped ifTrue: [ ^0 ].	^super hTotalScrollRange! !!TextModelMorph2 methodsFor: 'scrolling' stamp: 'jmv 11/10/2011 08:44'!         mightNeedHorizontalScrollBar	self textMorph isWrapped ifTrue: [ ^false ].	^super mightNeedHorizontalScrollBar! !!TextModelMorph2 methodsFor: 'focus handling' stamp: 'jmv 11/10/2011 08:44'!                            focusText	self activeHand newKeyboardFocus: self textMorph! !!TextModelMorph2 methodsFor: 'menu' stamp: 'jmv 11/9/2011 17:55'!                             getMenu	| menu |	menu _ MenuMorph new defaultTarget: self.	^model editorClass paneMenu: menu! !!TextModelMorph2 methodsFor: 'shout' stamp: 'jmv 11/10/2011 08:44'!                       autoCompleter: anUCompleter		self textMorph autoCompleter: anUCompleter! !!TextModelMorph2 methodsFor: 'shout' stamp: 'jmv 11/10/2011 08:45'!              styler: anSHTextStyler		self textMorph styler: anSHTextStyler! !!TextModelMorph2 methodsFor: 'shout' stamp: 'jmv 11/10/2011 08:44'!                        stylerStyled	self textMorph paragraph composeAll.	self editor recomputeSelection.		self textMorph updateFromParagraph.	self editor setEmphasisHereFromText.	self editor blinkParen.	self scrollSelectionIntoView! !!TextModelMorph2 methodsFor: 'notifications' stamp: 'jmv 11/9/2011 17:55'!                         possiblyChanged	"A hook for notificating possible interested parties	Not used in base system"! !!TextModelMorph2 methodsFor: 'testing' stamp: 'jmv 10/25/2011 17:29'!                      is: aSymbol	self flag: #jmvVer.	^ aSymbol == #TextModelMorph or: [ super is: aSymbol ]! !!BrowserCommentTextMorph2 methodsFor: 'displaying' stamp: 'jmv 11/9/2011 17:56'!                 hidePane	self hide.	separator visible ifTrue: [		proportionalHeight _ self layoutSpec proportionalHeight.		separatorHeight _ separator layoutSpec fixedHeight ].	separator layoutSpec fixedHeight: 0.	self layoutSpec proportionalHeight: 0.	separator ifNotNil: [ separator hide ]! !!BrowserCommentTextMorph2 methodsFor: 'displaying' stamp: 'jmv 11/9/2011 17:56'!               showPane	self show.	proportionalHeight ifNotNil: [		self layoutSpec proportionalHeight: proportionalHeight ].	separator ifNotNil: [		separatorHeight ifNotNil: [			separator layoutSpec fixedHeight: separatorHeight ].		separator show ]! !!BrowserCommentTextMorph2 methodsFor: 'updating' stamp: 'jmv 11/9/2011 17:56'!                           update: anAspect	super update: anAspect.	anAspect == #editSelection ifFalse: [ ^self ].	(model textProvider editSelection == #editClass)		ifTrue: [ self showPane ]		ifFalse: [ self hidePane ]! !!BrowserCommentTextMorph2 methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:56'!       separator: aMorph	separator _ aMorph! !!LimitedHeightTextMorph2 methodsFor: 'accessing' stamp: 'jmv 11/9/2011 17:59'!      maxHeight: aNumber	maxHeight _ aNumber! !!LimitedHeightTextMorph2 methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:59'!      extent: aPoint	maxHeight _ aPoint y.	super extent: aPoint.! !!LimitedHeightTextMorph2 methodsFor: 'geometry' stamp: 'jmv 11/9/2011 17:59'!                 innerHeight: aNumber	"Adjust height and scrollbar to the new contents height."	self height: (aNumber + 10 min: maxHeight)! !!LimitedHeightTextMorph2 methodsFor: 'initialization' stamp: 'jmv 11/10/2011 08:35'!           initialize	super initialize.	self basicExtent: 200 @ 120.! !!TextModelMorph2 class methodsFor: 'instance creation' stamp: 'jmv 11/9/2011 17:55'!          textProvider: aTextProvider	^ self		textProvider: aTextProvider		textGetter: nil		textSetter: nil		selectionGetter: nil! !!TextModelMorph2 class methodsFor: 'instance creation' stamp: 'jmv 11/9/2011 17:55'!          textProvider: aTextProvider textGetter: getTextSel	^ self		textProvider: aTextProvider		textGetter: getTextSel		textSetter: nil		selectionGetter: nil! !!TextModelMorph2 class methodsFor: 'instance creation' stamp: 'jmv 11/9/2011 17:55'!            textProvider: aTextProvider textGetter: getTextSel textSetter: setTextSel	^ self		textProvider: aTextProvider		textGetter: getTextSel		textSetter: setTextSel		selectionGetter: nil! !!TextModelMorph2 class methodsFor: 'instance creation' stamp: 'jmv 11/9/2011 17:55'!              textProvider: aTextProvider textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter	| newModel answer |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [  aTextProvider is: #ShoutEnabled ]) ifTrue: [		answer styler: SHTextStylerST80 new ].	newModel _ PluggableTextModel on: aTextProvider.	newModel textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter.	aTextProvider addDependent: newModel.	answer model: newModel.	answer autoCompleter: newModel autoCompleter.	^answer! !!TextModelMorph2 class methodsFor: 'instance creation' stamp: 'jmv 11/9/2011 17:55'!withModel: aTextModel	|  answer |	answer _ self new.	(Preferences syntaxHighlightingAsYouType 			and: [ aTextModel is: #ShoutEnabled ]) ifTrue: [		answer styler: SHTextStylerST80 new ].	answer model: aTextModel.	answer autoCompleter: aTextModel autoCompleter.	^answer! !!TextModelMorph2 class methodsFor: 'instance creation' stamp: 'jmv 11/9/2011 17:55'!                 withText: aTextOrString	^self withModel: (TextModel withText: aTextOrString)! !!BrowserCommentTextMorph2 class methodsFor: 'instance creation' stamp: 'jmv 11/9/2011 17:56'!               textProvider: aTextProvider textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter	| newModel answer |	answer _ self new.	newModel _ PluggableTextModel on: aTextProvider.	newModel textGetter: textGetter textSetter: textSetter selectionGetter: selectionGetter.	aTextProvider addDependent: newModel.	answer model: newModel.	answer autoCompleter: newModel autoCompleter.	^answer! !!LimitedHeightTextMorph2 class methodsFor: 'instance creation' stamp: 'jmv 11/9/2011 17:59'!   initializedInstance	^LimitedHeightTextMorph new		maxHeight: 48;		model: (TextModel new contents: 'This is some text to test the morph.')! !