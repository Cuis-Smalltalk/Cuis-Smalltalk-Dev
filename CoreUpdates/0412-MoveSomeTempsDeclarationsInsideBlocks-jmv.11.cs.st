'From Cuis 2.0 of 4 January 2010 [latest update: #393] on 12 February 2010 at 9:56:54 am'!!Archive methodsFor: 'archive operations' stamp: 'jmv 2/6/2010 08:31'!addTree: aFileNameOrDirectory removingFirstCharacters: n	| dir fullPath relativePath |	dir _ (aFileNameOrDirectory isString)		ifTrue: [ FileDirectory on: aFileNameOrDirectory ]		ifFalse: [ aFileNameOrDirectory ].	fullPath _ dir fullNameFor: ''.	"this could be a bug..."	relativePath _ fullPath copyFrom: n + 1 to: fullPath size.	dir entries do: [ :ea | | fullName newMember |		fullName _ fullPath, ea name.		newMember _ ea isDirectory				ifTrue: [ self memberClass newFromDirectory: fullName ]				ifFalse: [ self memberClass newFromFile: fullName ].		newMember localFileName: relativePath, ea name.		self addMember: newMember.		ea isDirectory ifTrue: [ self addTree: fullName removingFirstCharacters: n ].	].! !!AsyncFile methodsFor: 'as yet unclassified' stamp: 'jmv 2/6/2010 08:33'!readByteCount: byteCount fromFilePosition: fPosition onCompletionDo: aBlock	"Start a read operation to read byteCount's from the given position in this file. and fork a process to await its completion. When the operation completes, evaluate the given block. Note that, since the completion block may run asynchronous, the client may need to use a SharedQueue or a semaphore for synchronization."	| buffer |	buffer _ String new: byteCount.	self primReadStart: fileHandle fPosition: fPosition count: byteCount.	"here's the process that awaits the results:"	[		| n |		[	semaphore wait.		  	n _ self primReadResult: fileHandle intoBuffer: buffer at: 1 count: byteCount.		  	n = Busy.		] whileTrue.  "loop while busy in case the semaphore had excess signals"		n = Error ifTrue: [^ self error: 'asynchronous read operation failed'].		aBlock value: buffer.	] forkAt: Processor userInterruptPriority.! !!AsyncFile methodsFor: 'as yet unclassified' stamp: 'jmv 2/6/2010 08:33'!writeBuffer: buffer atFilePosition: fPosition onCompletionDo: aBlock	"Start an operation to write the contents of the buffer at given position in this file, and fork a process to await its completion. When the write completes, evaluate the given block. Note that, since the completion block runs asynchronously, the client may need to use a SharedQueue or a semaphore for synchronization."	self primWriteStart: fileHandle		fPosition: fPosition		fromBuffer: buffer		at: 1		count: buffer size.	"here's the process that awaits the results:"	[		| n |		[	semaphore wait.		  	n _ self primWriteResult: fileHandle.		  	n = Busy.		] whileTrue.  "loop while busy in case the semaphore had excess signals"		n = Error ifTrue: [^ self error: 'asynchronous write operation failed'].		n = buffer size ifFalse: [^ self error: 'did not write the entire buffer'].		aBlock value.	] forkAt: Processor userInterruptPriority.! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'jmv 2/7/2010 00:05'!selectorAtMethod: method setClass: classResultBlock 	"Answer both the message selector associated with the compiled method 	and the class in which that selector is defined."	| sel |	sel _ self methodDict keyAtIdentityValue: method				ifAbsent: [ | sel2 |					superclass == nil						ifTrue: [							classResultBlock value: self.							^method defaultSelector].					sel2 _ superclass selectorAtMethod: method setClass: classResultBlock.					"Set class to be self, rather than that returned from superclass. "					sel2 == method defaultSelector ifTrue: [ classResultBlock value: self ].					^sel2].	classResultBlock value: self.	^sel! !!Behavior methodsFor: 'testing method dictionary' stamp: 'jmv 2/7/2010 00:09'!whichSelectorsReferTo: literal 	"Answer a Set of selectors whose methods access the argument as a literal."	| special byte |	special _ Smalltalk hasSpecialSelector: literal ifTrueSetByte: [:b | byte _ b].	^self whichSelectorsReferTo: literal special: special byte: byte	"Rectangle whichSelectorsReferTo: #+."! !!Behavior methodsFor: 'user interface' stamp: 'jmv 2/6/2010 20:51'!allLocalCallsOn: aSymbol	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."	| aSet special byte cls |	aSet _ Set new.	cls _ self theNonMetaClass.	special _ Smalltalk 		hasSpecialSelector: aSymbol		ifTrueSetByte: [ :b | byte _ b ].	cls withAllSuperAndSubclassesDoGently: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte)			do: [:sel |				sel ~~ #DoIt ifTrue: [aSet add: class name , ' ', sel]]].	cls class withAllSuperAndSubclassesDoGently: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte)			do: [:sel |				sel ~~ #DoIt ifTrue: [aSet add: class name , ' ', sel]]].	^aSet! !!Behavior methodsFor: 'private' stamp: 'jmv 2/7/2010 00:08'!spaceUsed	"Answer a rough estimate of number of bytes used by this class and its metaclass. Does not include space used by class variables."	| space |	space _ 0.	self selectorsDo: [ :sel | | method |		space _ space + 16.  "dict and org'n space"		method _ self compiledMethodAt: sel.		space _ space + (method size + 6 "hdr + avg pad").		method literals do: [ :lit |			(lit isMemberOf: Array) ifTrue: [ space _ space + ((lit size + 1) * 4)].			(lit isMemberOf: Float) ifTrue: [ space _ space + 12].			(lit isMemberOf: String) ifTrue: [ space _ space + (lit size + 6)].			(lit isMemberOf: LargeNegativeInteger) ifTrue: [ space _ space + ((lit size + 1) * 4)].			(lit isMemberOf: LargePositiveInteger) ifTrue: [ space _ space + ((lit size + 1) * 4)]]].	^ space! !!Behavior methodsFor: '*system-support' stamp: 'jmv 2/6/2010 20:50'!allCallsOn: aSymbol	"Answer a SortedCollection of all the methods that call on aSymbol."	| aSortedCollection special byte |	aSortedCollection _ SortedCollection new.	special _ Smalltalk hasSpecialSelector: aSymbol ifTrueSetByte: [ :b | byte _ b ].	self withAllSubclassesDo: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte) do: [ :sel |			sel == #DoIt ifFalse: [				aSortedCollection add: (					MethodReference new						setStandardClass: class 						methodSymbol: sel				)			]		]	].	^aSortedCollection! !!BorderedMorph methodsFor: 'menu' stamp: 'jmv 2/7/2010 00:15'!changeBorderWidth: evt 	| handle origin aHand |	aHand := evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin := aHand position.	handle := HandleMorph new.	handle forEachPointDo: [ :newPoint | | newWidth |					handle removeAllMorphs.					handle addMorph: (LineMorph 								from: origin								to: newPoint								color: Color black								width: 1).					newWidth := (newPoint - origin) r asInteger // 5.					self borderWidth: newWidth]			lastPointDo: [ :newPoint | 					handle deleteBalloon.					self halo ifNotNil: [ :halo | halo addHandles]].	aHand attachMorph: handle.	handle 		showBalloon: 'Move cursor farther fromthis point to increase border width.Click when done.'		hand: evt hand.	handle startStepping! !!AlignmentMorph methodsFor: 'construction' stamp: 'jmv 2/6/2010 08:30'!addInRow: morphs widthProportionalTo: widths	"Widths can be in any arbitrary unit. The actual widths will be proportional to them."	| fractions totalWidth |	totalWidth _ widths sum * 1.0.	fractions _ OrderedCollection new.	widths inject: 0.0 into: [  :previousValue :w  |		fractions add: previousValue.		w / totalWidth + previousValue ].	fractions add: 1.0.	self addInRow: morphs atFractions: fractions! !!Browser methodsFor: 'class functions' stamp: 'jmv 2/7/2010 09:41'!copyClass	| originalName copysName oldDefinition newDefinition |		classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	originalName _ self selectedClass name.	copysName _ self request: 'Please type new class name' initialAnswer: originalName.	copysName = '' ifTrue: [^ self].  " Cancel returns '' "	copysName _ copysName asSymbol.	copysName = originalName ifTrue: [^ self].	(Smalltalk includesKey: copysName)		ifTrue: [^ self error: copysName , ' already exists'].	oldDefinition _ self selectedClass definition.	newDefinition _ oldDefinition copyReplaceAll: '#' , originalName asString with: '#' , copysName asString.	Cursor wait 		showWhile: [			| class |			class _ Smalltalk actualCompilerClass evaluate: newDefinition logged: true.			class copyAllCategoriesFrom: (Smalltalk at: originalName).			class class copyAllCategoriesFrom: (Smalltalk at: originalName) class ].	self classListIndex: 0.	self changed: #classList! !!Browser methodsFor: 'class functions' stamp: 'jmv 2/7/2010 09:43'!createInstVarAccessors	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"	| aClass |	(aClass _ self selectedClassOrMetaClass) ifNotNil: [		aClass instVarNames do: [ :aName | | newMessage setter |				(aClass canUnderstand: aName asSymbol)					ifFalse: [						newMessage _ aName, '	"Answer the value of ', aName, '"	^ ', aName.						aClass compile: newMessage classified: 'accessing' notifying: nil].				(aClass canUnderstand: (setter _ aName, ':') asSymbol)					ifFalse: [						newMessage _ setter, ' anObject	"Set the value of ', aName, '"	', aName, ' _ anObject'.						aClass compile: newMessage classified: 'accessing' notifying: nil]]]! !!Browser methodsFor: 'message category functions' stamp: 'jmv 2/7/2010 09:40'!addCategory	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"	| labels reject lines menuIndex oldIndex newName |	self okToChange ifFalse: [^ self].	classListIndex = 0 ifTrue: [^ self].	labels _ OrderedCollection with: 'new...'.	reject _ Set new.	reject		addAll: self selectedClassOrMetaClass organization categories;		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines _ OrderedCollection new.	self selectedClassOrMetaClass allSuperclasses do: [:cls | | cats |		cls = Object ifFalse: [			cats _ cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse: [				lines add: labels size.				labels addAll: cats asSortedCollection.				reject addAll: cats]]].	newName _ (labels size = 1 or: [		menuIndex _ (PopUpMenu labelArray: labels lines: lines)		startUpWithCaption: 'Add Category'.		menuIndex = 0 ifTrue: [^ self].		menuIndex = 1])			ifTrue: [				self request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: [				labels at: menuIndex].	oldIndex _ messageCategoryListIndex.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	self classOrMetaClassOrganizer		addCategory: newName		before: (messageCategoryListIndex = 0				ifTrue: [nil]				ifFalse: [self selectedMessageCategoryName]).	self changed: #messageCategoryList.	self messageCategoryListIndex:		(oldIndex = 0			ifTrue: [self classOrMetaClassOrganizer categories size + 1]			ifFalse: [oldIndex]).	self changed: #messageCategoryList.! !!CascadeNode methodsFor: 'code generation (new scheme)' stamp: 'jmv 2/7/2010 09:46'!sizeCodeForValue: encoder	^messages		inject: (receiver sizeCodeForValue: encoder)			 + (messages size - 1 * (encoder sizeDup + encoder sizePop)) 		into: [ :prevSize :aMessage | prevSize + (aMessage sizeCodeForValue: encoder) ]! !!CascadeNode methodsFor: 'code generation' stamp: 'jmv 2/7/2010 09:47'!sizeForValue: encoder	^messages		inject: (receiver sizeForValue: encoder) + (messages size - 1 * 2)		into: [ :prevSize :aMessage | prevSize + (aMessage sizeForValue: encoder) ]! !!ChangeList methodsFor: 'scanning' stamp: 'jmv 2/7/2010 23:39'!scanFile: aFile from: startPosition to: stopPosition	file _ aFile.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	file position: startPosition.	'Scanning ', aFile localName, '...'		displayProgressAt: Sensor cursorPoint		from: startPosition to: stopPosition		during: [:bar |			[file position < stopPosition] whileTrue: [ | prevChar |				bar value: file position.				[file atEnd not and: [file peek isSeparator]]					whileTrue: [prevChar _ file next].				(file peekFor: $!!)					ifTrue: [						(prevChar = Character cr or: [prevChar = Character lf])							ifTrue: [self scanCategory]]					ifFalse: [						| itemPosition item |						itemPosition _ file position.						item _ file nextChunk.						file skipStyleChunk.						item size > 0 ifTrue: [							self addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)								text: 'do it: ' , (item contractTo: 160)]]]].	listSelections _ Array new: list size withAll: false! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/12/2010 09:56'!optionalButtonRow	"Answer a row of buttons to occur in a tool pane"	| row buttons widths |	buttons _ OrderedCollection new.	widths _ OrderedCollection new.	self buttonSpecs do: [ :tuple | | button |		widths add: tuple first.		button _ PluggableButtonMorph 					model: self					stateGetter: nil					action: tuple third.		button			label: tuple second asString;			askBeforeChanging: true.		buttons add: button.		button setBalloonText: tuple fourth].	buttons add: self regularDiffButton.	widths add: 14.	buttons add: self regularDiffButton2.	widths add: 16.	self wantsPrettyDiffOption ifTrue: [		buttons add:  self prettyDiffButton.		widths add: 21.		buttons add:  self prettyDiffButton2.		widths add: 23 ].	row _ AlignmentMorph proportional.	row addInRow: buttons widthProportionalTo: widths.	^row! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/7/2010 23:29'!removeDoIts	"Remove doits from the receiver, other than initializes. 1/26/96 sw"	Cursor wait showWhile: [		| newChangeList newList |		newChangeList _ OrderedCollection new.		newList _ OrderedCollection new.		changeList with: list do: [ :chRec :str |			(chRec type ~~ #doIt or: [str endsWith: 'initialize'])				ifTrue: [					newChangeList add: chRec.					newList add: str]].		newChangeList size < changeList size			ifTrue: [				changeList _ newChangeList.				list _ newList.				listIndex _ 0.				listSelections _ Array new: list size withAll: false].	].	self changed: #list.	! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/7/2010 23:31'!removeEmptyClassComments	Cursor wait showWhile: [		| newChangeList newList |		newChangeList _ OrderedCollection new.		newList _ OrderedCollection new.		changeList with: list do: [ :chRec :strNstamp | | keep |			keep _ true.			(chRec type == #classComment and: [					Smalltalk includesKey: chRec methodClassName]) ifTrue: [				keep _ chRec text notEmpty			].			keep ifTrue:[				newChangeList add: chRec.				newList add: strNstamp]].		newChangeList size < changeList size ifTrue: [			changeList _ newChangeList.			list _ newList.			listIndex _ 0.			listSelections _ Array new: list size withAll: false].	].	self changed: #list! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/7/2010 23:34'!removeExistingMethodVersions	"Remove all up to date version of entries from the receiver"	"Modified to also remove up to date classDefinitions and classComments"	Cursor wait showWhile: [		| newChangeList newList |		newChangeList _ OrderedCollection new.		newList _ OrderedCollection new.		changeList with: list do: [ :chRec :strNstamp | | keep cls name |			keep _ true.			(cls _ chRec methodClass) ifNotNil: [ | sel str |				str _ chRec string.				sel _ cls parserClass new parseSelector: str.				keep _ (cls sourceCodeAt: sel ifAbsent:['']) asString ~= str.			].			(chRec type == #classComment and: [					name _ chRec methodClassName.					Smalltalk includesKey: name]) ifTrue: [				cls _ Smalltalk at: name.				keep _ cls organization classComment ~= chRec text.			].			(chRec type == #classDefinition and: [					name _ chRec methodClassName.					Smalltalk includesKey: name]) ifTrue: [				cls _ Smalltalk at: name.				chRec isMetaClassChange ifTrue: [ cls _ cls class ].				keep _ cls definition ~= chRec text.			].			keep ifTrue:[				newChangeList add: chRec.				newList add: strNstamp]].		newChangeList size < changeList size ifTrue: [			changeList _ newChangeList.			list _ newList.			listIndex _ 0.			listSelections _ Array new: list size withAll: false].	].	self changed: #list! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/7/2010 23:36'!removeOlderMethodVersions	"Remove older versions of entries from the receiver."	Cursor wait showWhile: [		| newChangeList newList found |		newChangeList _ OrderedCollection new.		newList _ OrderedCollection new.		found _ OrderedCollection new.		changeList reverseWith: list do: [ :chRec :strNstamp | | str |			str _ strNstamp copyUpTo: $;.			(found includes: str) ifFalse: [				found add: str.				newChangeList add: chRec.				newList add: strNstamp]].		newChangeList size < changeList size ifTrue: [			changeList _ newChangeList reversed.			list _ newList reversed.			listIndex _ 0.			listSelections _ Array new: list size withAll: false].	].	self changed: #list! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/7/2010 23:40'!selectAllConflicts	"Selects all method definitions in the receiver which are also in any existing change set in the system.  This makes no statement about whether the content of the methods differ, only whether there is a change represented."	Cursor read showWhile: [		|  aClass aChange |		1 to: changeList size do: [ :i | 			aChange _ changeList at: i.			listSelections at: i put:				(aChange type = #method				and: [(aClass _ aChange methodClass) notNil				and: [ChangeSorter doesAnyChangeSetHaveClass: aClass andSelector:  aChange methodSelector]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/7/2010 23:41'!selectConflicts	"Selects all method definitions for which there is ALSO an entry in changes"	Cursor read showWhile: [		| change class  |		1 to: changeList size do: [ :i | 			change _ changeList at: i.			listSelections at: i put:				(change type = #method				and: [(class _ change methodClass) notNil				and: [(ChangeSet current atSelector: change methodSelector						class: class) ~~ #none]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/7/2010 23:42'!selectConflicts: changeSetOrList	"Selects all method definitions for which there is ALSO an entry in the specified changeSet or changList"	Cursor read showWhile: [		| change class systemChanges |		(changeSetOrList isKindOf: ChangeSet) ifTrue: [			1 to: changeList size do: [ :i | 				change _ changeList at: i.				listSelections at: i put:					(change type = #method					and: [(class _ change methodClass) notNil					and: [(changeSetOrList atSelector: change methodSelector						class: class) ~~ #none]])]]			ifFalse: ["a ChangeList"			1 to: changeList size do: [ :i | 				change _ changeList at: i.				listSelections at: i put:					(change type = #method					and: [(class _ change methodClass) notNil					and: [changeSetOrList list includes: (list at: i)]])]]	].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/7/2010 23:46'!selectEquivalentMethods	"Selects all method definitions for which there is already an equivalent method in the current image, 	(meaning that the difference is cosmetic and not in behavior)"	Cursor wait showWhile: [		1 to: changeList size do: [ :i | 			| change class |			change _ changeList at: i.			listSelections at: i put:				((change type = #method and: [					(class _ change methodClass) notNil]) and: [						(class includesSelector: change methodSelector) and: [							| cmWithNode |							cmWithNode _ [class basicCompile: change string notifying: nil trailer: class defaultMethodTrailer ifFail: [nil]] 								on: SyntaxErrorNotification do: [ :ex | ex return ].							(cmWithNode notNil and: [								| current inChange |								current _ (class compiledMethodAt: change methodSelector) copyWithTrailerBytes: #(0).								inChange _cmWithNode method copyWithTrailerBytes: #(0).								current = inChange or: [									| currentCmWithNode |									currentCmWithNode _ [class basicCompile: (class decompilerClass new decompile: change methodSelector in: class) decompileString											notifying: nil trailer: class defaultMethodTrailer ifFail: [nil]] on: SyntaxErrorNotification do: [ :ex | ex return ].									(currentCmWithNode notNil and: [										current _ currentCmWithNode method copyWithTrailerBytes: #(0).										current = inChange])								]							])						]]				)]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/7/2010 23:46'!selectNewMethods	"Selects all method definitions for which there is no counterpart method in the current image"	Cursor read showWhile: [		| change class |		1 to: changeList size do: [ :i | 			change _ changeList at: i.			listSelections at: i put:				((change type = #method and:					[((class _ change methodClass) isNil) or:						[(class includesSelector: change methodSelector) not]]))]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/7/2010 23:47'!selectRemovalsOfSent	"Selects all method removal for sent methods"	Cursor read showWhile: [		| change |		1 to: changeList size do: [ :i |			change _ changeList at: i.			listSelections at: i put:				(change type = #doIt and: [					change string includesSubString: 'removeSelector: #' ] and: [						(Smalltalk allCallsOn: (change string copyAfterLast: $#) asSymbol) size > 0 ]) ]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'jmv 2/7/2010 23:48'!selectUnchangedMethods	"Selects all method definitions for which there is already a method in the current image, whose source is exactly the same.  9/18/96 sw"	Cursor read showWhile: [		| change class |		1 to: changeList size do: [ :i | 			change _ changeList at: i.			listSelections at: i put:				((change type = #method and:					[(class _ change methodClass) notNil]) and:						[(class includesSelector: change methodSelector) and:							[change string withBlanksCondensed = (class sourceCodeAt: change methodSelector) asString withBlanksCondensed ]])]].	self changed: #allSelections! !!ChangeRecord methodsFor: 'access' stamp: 'jmv 2/7/2010 23:50'!timeStamp	"Answer a TimeStamp that corresponds to my (text) stamp"	| tokens |	tokens := self stamp findTokens: Character separators.	^ tokens size > 2		ifTrue: [			[				| date time |				date := Date fromString: (tokens at: tokens size - 1).				time := Time fromString: tokens last.				TimeStamp date: date time: time]					on: Error					do: [:ex | ex						return: (TimeStamp fromSeconds: 0)]]		ifFalse: [TimeStamp fromSeconds: 0]! !!ChangeRecord methodsFor: 'initialization' stamp: 'jmv 2/7/2010 23:49'!fileIn	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it."	Cursor read showWhile: [		| methodClass s aSelector |		(methodClass _ self methodClass) notNil ifTrue: [			methodClass compile: self text classified: category withStamp: stamp notifying: nil.			(aSelector _ self methodSelector) ifNotNil:				[Utilities noteMethodSubmission: aSelector forClass: methodClass]].		(type == #doIt) ifTrue:			[((s _ self string) beginsWith: '----') ifFalse: [Smalltalk actualCompilerClass evaluate: s]].		(type == #classDefinition) ifTrue: [			Smalltalk actualCompilerClass evaluate: self string].		(type == #classComment) ifTrue:			[ | cls | (cls _ Smalltalk at: class asSymbol) comment: self text stamp: stamp.			Utilities noteMethodSubmission: #Comment forClass: cls ]]! !!ChangeSet methodsFor: 'accessing' stamp: 'jmv 2/8/2010 00:08'!methodChanges	| methodChangeDict |	methodChangeDict _ Dictionary new.	changeRecords associationsDo: [ :assn | | changeTypes |		changeTypes _ assn value methodChangeTypes.		changeTypes isEmpty ifFalse: [methodChangeDict at: assn key put: changeTypes]].	^ methodChangeDict! !!ChangeSet methodsFor: 'testing' stamp: 'jmv 2/8/2010 00:10'!methodsWithoutClassifications	"Return a collection representing methods in the receiver which have not been categorized"	| slips notClassified |	notClassified _ {'as yet unclassified' asSymbol. #all}.	slips _ OrderedCollection new.	self changedClasses do: [ :aClass |		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | aSelector |			(aClass selectors includes:  (aSelector _ mAssoc key)) ifTrue: [				(notClassified includes: (aClass organization categoryOfElement: aSelector))					ifTrue: [slips add: aClass name , ' ' , aSelector]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutClassifications) name: 'unclassified methods'"! !!ChangeSet methodsFor: 'method changes' stamp: 'jmv 2/7/2010 23:56'!changedMessageList	"Used by a message set browser to access the list view information."	| messageList |	messageList _ OrderedCollection new.	changeRecords associationsDo: [ :clAssoc | | classNameInFull classNameInParts |		classNameInFull _ clAssoc key asString.		classNameInParts _ classNameInFull findTokens: ' '.		(clAssoc value allChangeTypes includes: #comment) ifTrue: [			messageList add:				(MethodReference new					setClassSymbol: classNameInParts first asSymbol					classIsMeta: false 					methodSymbol: #Comment 					stringVersion: classNameInFull, ' Comment')].		clAssoc value methodChangeTypes associationsDo: [ :mAssoc |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse: [				messageList add:					(MethodReference new						setClassSymbol: classNameInParts first asSymbol						classIsMeta: classNameInParts size > 1 						methodSymbol: mAssoc key 						stringVersion: classNameInFull, ' ' , mAssoc key)]]].	^ messageList asSortedArray! !!ChangeSet methodsFor: 'moving changes' stamp: 'jmv 2/8/2010 00:09'!methodsWithAnyInitialsOtherThan: myInits	"Return a collection of method refs whose author appears to be different from the given one, even historically"	| slips |	slips _ Set new.	self changedClasses do: [:aClass |		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | method |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse: [				method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].				method ifNotNil: [					(aClass changeRecordsAt: mAssoc key) do: [ :chg | | aTimeStamp |						aTimeStamp _ chg stamp.						(aTimeStamp notNil and: [(aTimeStamp beginsWith: myInits) not])							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]]].	^ slips! !!ChangeSet methodsFor: 'moving changes' stamp: 'jmv 2/8/2010 00:10'!methodsWithInitialsOtherThan: myInits	"Return a collection of method refs whose author appears to be different from the given one"	| slips |	slips _ OrderedCollection new.	self changedClasses do: [ :aClass |		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc | | method |				(#(remove addedThenRemoved) includes: mAssoc value) ifFalse: [					method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil: [ | aTimeStamp |						((aTimeStamp _ Utilities timeStampForMethod: method) notNil and: [							(aTimeStamp beginsWith: myInits) not])								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithInitialsOtherThan: 'sw') name: 'authoring problems'"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 2/7/2010 23:51'!askAddedInstVars: classList	| pairList pairClasses index pls |	"Ask the author whether these newly added inst vars need to be non-nil"	pairList _ OrderedCollection new.	pairClasses _ OrderedCollection new.	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."	classList do: [ :cls |		| newStruct oldStruct |		newStruct _ (cls allInstVarNames).		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.		newStruct do: [ :instVarName |			(oldStruct includes: instVarName) ifFalse: [				pairList add: cls name, ' ', instVarName.				pairClasses add: cls]]].	pairList isEmpty ifTrue: [^ #()].	[		index _ PopUpMenu withCaption: 'These instance variables were added.When an old project comes in, newly added instance variables will have the value nil.Click on items to remove them from the list.Click on any for which nil is an OK value.'			chooseFrom: pairList, #('all of these need a non-nil value'						'all of these are OK with a nil value').		(index <= (pls _ pairList size)) & (index > 0) ifTrue: [			pairList removeAt: index.			pairClasses removeAt: index].		index = (pls + 2) ifTrue: ["all are OK" ^ #()].		pairList isEmpty | (index = (pls + 1)) "all need conversion, exit"] whileFalse.	^ pairClasses asSet asArray	"non redundant"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 2/7/2010 23:52'!askRemovedInstVars: classList	| pairList pairClasses index pls |	"Ask the author whether these newly removed inst vars need to have their info saved"	pairList _ OrderedCollection new.	pairClasses _ OrderedCollection new.	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."	classList do: [ :cls |		| newStruct oldStruct |		newStruct _ (cls allInstVarNames).		oldStruct _ (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.		oldStruct do: [:instVarName |			(newStruct includes: instVarName) ifFalse: [				pairList add: cls name, ' ', instVarName.				pairClasses add: cls]]].	pairList isEmpty ifTrue: [^ #()].	[		index _ PopUpMenu withCaption: 'These instance variables were removed.When an old project comes in, instance variables that have been removed will lose their contents.Click on items to remove them from the list.Click on any whose value is unimportant and need not be saved.'			chooseFrom: pairList, #('all of these need a conversion method'						'all of these have old values that can be erased').		(index <= (pls _ pairList size)) & (index > 0) ifTrue: [			pairList removeAt: index.			pairClasses removeAt: index].		index = (pls + 2) ifTrue: ["all are OK" ^ #()].		pairList isEmpty | (index = (pls + 1))  "all need conversion, exit"] whileFalse.	^ pairClasses asSet asArray	"non redundant"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 2/7/2010 23:53'!askRenames: renamed addTo: msgSet using: smart	| list |	"Go through the renamed classes.  Ask the user if it could be in a project.  Add a method in SmartRefStream, and a conversion method in the new class."	list _ OrderedCollection new.	renamed do: [ :cls | | rec |		rec _ changeRecords at: cls name.		rec priorName ifNotNil: [			| ans |			ans _ PopUpMenu withCaption: 'You renamed class ', rec priorName, 				' to be ', rec thisName,				'.\Could an instance of ', rec priorName, 				' be in a project on someone''s disk?'			chooseFrom: #('Yes, write code to convert those instances'				'No, no instances are in projects').			ans = 1 ifTrue: [				| oldStruct newStruct  |				oldStruct _ structures at: rec priorName ifAbsent: [nil].				newStruct _ (Array with: cls classVersion), (cls allInstVarNames).				oldStruct ifNotNil: [					smart writeConversionMethodIn: cls fromInstVars: oldStruct 							to: newStruct renamedFrom: rec priorName.					smart writeClassRename: cls name was: rec priorName.					list add: cls name, ' convertToCurrentVersion:refStream:']]			ifFalse: [structures removeKey: rec priorName ifAbsent: []]]].	list isEmpty ifTrue: [^ msgSet].	msgSet messageList ifNil: [msgSet initializeMessageList: list]		ifNotNil: [list do: [:item | msgSet addItem: item]].	^ msgSet! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 2/8/2010 00:00'!checkForConversionMethods	"See if any conversion methods are needed"	| tell choice list smart restore renamed listAdd listDrop msgSet |	Preferences conversionMethodsAtFileOut ifFalse: [^ self].	"Check preference"	structures ifNil: [^ self].	list _ OrderedCollection new.	renamed _ OrderedCollection new.	self changedClasses do: [ :class | | oldStruct newStruct need sel rec |		need _ (self atClass: class includes: #new) not.		need ifTrue: ["Renamed classes."			(self atClass: class includes: #rename) ifTrue: [				rec _ changeRecords at: class name.				rec priorName ifNotNil: [					(structures includesKey: rec priorName) ifTrue: [						renamed add: class.  need _ false]]]].		need ifTrue: [need _ (self atClass: class includes: #change)].		need ifTrue: [oldStruct _ structures at: class name 									ifAbsent: [need _ false.  #()]].		need ifTrue: [			newStruct _ (Array with: class classVersion), (class allInstVarNames).			need _ (oldStruct ~= newStruct)].		need ifTrue: [sel _ #convertToCurrentVersion:refStream:.			(#(add change) includes: (self atSelector: sel class: class)) ifFalse: [				list add: class]].		].	list isEmpty & renamed isEmpty ifTrue: [^ self].	"Ask user if want to do this"	tell _ 'If there might be instances of ', (list asArray, renamed asArray) printString,		'\in a project (.pr file) on someone''s disk, \please ask to write a conversion method.\'			withCRs,		'After you edit the conversion method, you''ll need to fileOut again.\' withCRs,		'The preference conversionMethodsAtFileOut in category "fileout" controls this feature.'.	choice _ (PopUpMenu labels: 'Write a conversion method by editing a prototypeThese classes are not used in any object file.  fileOut my changes now.I''m too busy.  fileOut my changes now.Don''t ever ask again.  fileOut my changes now.') startUpWithCaption: tell. 	choice = 4 ifTrue: [Preferences disable: #conversionMethodsAtFileOut].	choice = 2 ifTrue: ["Don't consider this class again in the changeSet"			list do: [:cls | structures removeKey: cls name ifAbsent: []].			renamed do: [:cls | | nn |				nn _ (changeRecords at: cls name) priorName.				structures removeKey: nn ifAbsent: []]].	choice ~= 1 ifTrue: [^ self].	"exit if choice 2,3,4"	listAdd _ self askAddedInstVars: list.	"Go through each inst var that was added"	listDrop _ self askRemovedInstVars: list.	"Go through each inst var that was removed"	list _ (listAdd, listDrop) asSet asArray.	smart _ SmartRefStream on: (RWBinaryOrTextStream on: '12345').	smart structures: structures.	smart superclasses: superclasses.	(restore _ self class current) == self ifFalse: [		self class  newChanges: self].	"if not current one"	msgSet _ smart conversionMethodsFor: list.		"each new method is added to self (a changeSet).  Then filed out with the rest."	self askRenames: renamed addTo: msgSet using: smart.	"renamed classes, add 2 methods"	restore == self ifFalse: [self class newChanges: restore].	msgSet messageList isEmpty ifTrue: [^ self].	self inform: 'Remember to fileOut again after modifying these methods.'.	MessageSet open: msgSet name: 'Conversion methods for ', self name.! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 2/8/2010 00:03'!checkForSlips	"Return a collection of method refs with possible debugging code in them."	| slips |	slips _ OrderedCollection new.	self changedClasses do: [ :aClass |		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc |  | method |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse: [				method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].				method ifNotNil: [					method hasReportableSlip						ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 2/8/2010 00:07'!fileOut	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| slips nameToUse |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: 'cs']				ifFalse: [(self name , FileDirectory dot , Utilities dateTimeSuffix , FileDirectory dot , 'cs') asFileName].	Cursor write		showWhile: [			| file |			file := self defaultChangeSetDirectory newFileNamed: nameToUse.			[				file timeStamp.				self fileOutPreambleOn: file.				self fileOutOn: file.				self fileOutPostscriptOn: file]					ensure: [file close]].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(PopUpMenu withCaption: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')					= 2])		ifTrue: [Smalltalk browseMessageList: slips name: 'Possible slips in ' , name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 2/8/2010 00:08'!fileOutPSFor: class on: stream 	"Write out removals and initialization for this class."	| dict classRecord currentDef |	classRecord _ changeRecords at: class name ifAbsent: [^ self].	dict _ classRecord methodChangeTypes.	dict keysSortedSafely do: [ :key | | changeType |		changeType _ dict at: key.		(#(remove addedThenRemoved) includes: changeType)			ifTrue: [stream nextChunkPut: class name,						' removeSelector: ', key storeString; cr]			ifFalse: [(key = #initialize and: [class isMeta]) ifTrue:						[stream nextChunkPut: class soleInstance name, ' initialize'; cr]]].	((classRecord includesChangeType: #change)			and: [(currentDef _ class definition) ~= (self fatDefForClass: class)]) ifTrue: [		stream nextPut: $!!; nextChunkPut: class definitionPreamble; cr;			nextChunkPut: currentDef; cr].	(classRecord includesChangeType: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jmv 2/8/2010 00:12'!summaryStringDelta: delta	"Answer the string summarizing this changeSet"	^ String streamContents: [ :s | | intName ps |		intName _ self name splitInteger.		intName first isNumber			ifTrue: [s nextPutAll: (intName first + delta) printString , intName last]			ifFalse: [s nextPutAll: intName first  "weird convention of splitInteger"].		(ps _ self preambleString)			ifNil: [s cr]			ifNotNil: [ | s2 date author |				s2 _ ReadStream on: ps.				s2 match: 'Date:'; skipSeparators.  date _ s2 upTo: Character cr.				s2 match: 'Author:'; skipSeparators.  author _ s2 upTo: Character cr.				s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.				[s2 atEnd] whileFalse: [ | line |					line _ s2 upTo: Character cr.					(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]].! !!Class methodsFor: 'initialize-release' stamp: 'jmv 2/8/2010 00:24'!sharing: poolString 	"Set up sharedPools. Answer whether recompilation is advisable."	| oldPools |	oldPools _ self sharedPools.	sharedPools _ OrderedCollection new.	(Smalltalk actualScannerClass new scanFieldNames: poolString) do: 		[:poolName | 		sharedPools add: (Smalltalk at: poolName asSymbol ifAbsent:[			(self confirm: 'The pool dictionary ', poolName,' does not exist.',						'\Do you want it automatically created?' withCRs)				ifTrue:[Smalltalk at: poolName asSymbol put: Dictionary new]				ifFalse:[^self error: poolName,' does not exist']])].	sharedPools isEmpty ifTrue: [sharedPools _ nil].	^oldPools anySatisfy: [ :pool |		self sharedPools noneSatisfy: [ :p | p == pool ]]! !!Class methodsFor: 'compiling' stamp: 'jmv 2/8/2010 00:17'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol |	aSymbol := varName asSymbol.	"First look in classVar dictionary."	(self classPool bindingOf: aSymbol) ifNotNil: [ : binding | ^binding ].	"Next look in shared pools."	self sharedPools do: [ :pool | 		(pool bindingOf: aSymbol) ifNotNil: [ :binding | ^binding ].	].	"Next look in declared environment."	(Smalltalk bindingOf: aSymbol) ifNotNil: [ :binding | ^binding ].	"Finally look higher up the superclass chain and fail at the end."	^superclass ifNotNil: [superclass bindingOf: aSymbol]! !!Class methodsFor: 'compiling' stamp: 'jmv 2/8/2010 00:19'!possibleVariablesFor: misspelled continuedFrom: oldResults	| results |	results _ misspelled correctAgainstDictionary: self classPool continuedFrom: oldResults.	self sharedPools do: [:pool | 		results _ misspelled correctAgainstDictionary: pool continuedFrom: results ].	^superclass == nil		ifTrue: 			[ misspelled correctAgainstDictionary: Smalltalk continuedFrom: results ]		ifFalse:			[ superclass possibleVariablesFor: misspelled continuedFrom: results ]! !!Class methodsFor: 'fileIn/Out' stamp: 'jmv 2/8/2010 00:18'!fileOutPool: aPool onFileStream: aFileStream 	| aPoolName |	(aPool  isKindOf: SharedPool class) ifTrue:[^self notify: 'we do not fileout SharedPool type shared pools for now'].	aPoolName _ Smalltalk keyAtIdentityValue: aPool.	Transcript cr; show: aPoolName.	aFileStream nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!!'; cr.	aFileStream nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!!'; cr.	aPool keys asSortedCollection do: [ :aKey | | aValue |		aValue _ aPool at: aKey.		aFileStream nextPutAll: aPoolName , ' at: #''' , aKey asString , '''', ' put:  '.		(aValue isKindOf: Number)			ifTrue: [aValue printOn: aFileStream]			ifFalse: [aFileStream nextPutAll: '('.					aValue printOn: aFileStream.					aFileStream nextPutAll: ')'].		aFileStream nextPutAll: '!!'; cr].	aFileStream cr! !!AbstractFont class methodsFor: 'user interface' stamp: 'jmv 2/6/2010 20:20'!fontMenuForFamily: familyName target: target selector: selector highlight: currentSize 	"Offer a font menu for the given font family. If one is selected, pass that font to target with a call to selector. The fonts will be displayed in that font."	| menu |	menu _ MenuMorph entitled: familyName.	(self pointSizesFor: familyName) do: [ :p | | font |			font _ self familyName: familyName pointSize: p.			menu 				add: p asString , ' Point'				target: target				selector: selector				argument: font.			menu lastItem font: font.			p = currentSize ifTrue: [menu lastItem color: Color blue darker]].	^menu! !!AbstractFont class methodsFor: 'user interface' stamp: 'jmv 2/6/2010 20:27'!promptForFont: aPrompt andSendTo: aTarget withSelector: aSelector highlight: currentFont	"Morphic Only!! prompt for a font and if one is provided, send it to aTarget using a message with selector aSelector."	"	AbstractFont promptForFont: 'Choose system font:' andSendTo: Preferences withSelector: #setSystemFontTo: highlight: nil	"	| menu currentFamilyName |	currentFamilyName _ currentFont ifNotNil: [ currentFont familyName ].	menu _ MenuMorph entitled: aPrompt.	AbstractFont familyNames do: [ :familyName | | subMenu currentSize |		currentSize _  (familyName = currentFamilyName ifTrue: [ currentFont pointSize ]).		subMenu _ self fontMenuForFamily: familyName target: aTarget selector: aSelector highlight: currentSize.		menu add: familyName subMenu: subMenu.		familyName = currentFamilyName ifTrue: [menu lastItem color: Color blue darker]].	menu popUpInWorld: self currentWorld! !!AbstractSound class methodsFor: 'utilities' stamp: 'jmv 2/6/2010 20:32'!pitchForName: aString	"AbstractSound pitchForName: 'c2'"	"#(c 'c#' d eb e f fs g 'g#' a bf b) collect: [ :s | AbstractSound pitchForName: s, '4']"	| s modifier octave i j noteName p |	s _ ReadStream on: aString.	modifier _ $n.	noteName _ s next.	(s atEnd not and: [ s peek isDigit ]) ifFalse: [ modifier _ s next ].	octave _ s atEnd		ifTrue: [ 4 ]		ifFalse: [ Integer readFrom: s ].	octave < 0 ifTrue: [ self error: 'cannot use negative octave number' ].	i _ 'cdefgab' indexOf: noteName.	i = 0 ifTrue: [ self error: 'bad note name: ', noteName asString ].	i _ #(2 4 6 7 9 11 13) at: i.	j _ 's#fb' indexOf: modifier.	j = 0 ifFalse: [ i _ i + (#(1 1 -1 -1) at: j) ].  "i is now in range: [1..14]"	"Table generator: (1 to: 14) collect: [ :i | 16.3516 * (2.0 raisedTo: (i - 2) asFloat / 12.0)]"	p _ #(15.4339 16.3516 17.3239 18.354 19.4454 20.6017 21.8268 23.1247 24.4997 25.9565 27.5 29.1352 30.8677 32.7032) at: i.	p _ p * (2.0 raisedToInteger: octave).	^ p! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jmv 2/6/2010 20:25'!fileInSoundLibraryNamed: fileName	"File in the sound library with the given file name, and add its contents to the current sound library."	| s newSounds |	s _ FileStream oldFileNamed: fileName.	newSounds _ [ s fileInObjectAndCode ]		ensure: [ s close ].	newSounds associationsDo: [ :assoc | 		self storeFiledInSound: assoc value named: assoc key].	AbstractSound updateScorePlayers.	Smalltalk garbageCollect.  "Large objects may have been released"! !!ActiveModel class methodsFor: 'initialize-release' stamp: 'jmv 2/6/2010 08:25'!flushEvents	"Object flushEvents"	self actionMaps keysAndValuesDo: [ :rcvr :evtDict | 		rcvr ifNotNil:[			"make sure we don't modify evtDict while enumerating"			evtDict keys do: [ :evtName | | msgSet |				msgSet _ evtDict at: evtName ifAbsent:[nil].				msgSet ifNil: [ rcvr removeActionsForEvent: evtName]]]].	ActiveModel actionMaps finalizeValues. ! !!ChangeList class methodsFor: 'public access' stamp: 'jmv 2/7/2010 23:20'!browseRecent: charCount on: origChangesFile 	"Opens a changeList on the end of the specified changes log file"		| changeList end changesFile |	changesFile _ origChangesFile readOnlyCopy.	end _ changesFile size.	changeList _ Cursor read showWhile: [		self new			scanFile: changesFile			from: (0 max: end - charCount)			to: end ].	changesFile close.	self		open: changeList		name: 'Recent changes'		multiSelect: true! !!ChangeList class methodsFor: 'public access' stamp: 'jmv 2/7/2010 23:25'!browseRecentLogOn: origChangesFile 	"figure out where the last snapshot or quit was, then browse the recent entries."	| end done block changesFile positions prevBlock |	changesFile _ origChangesFile readOnlyCopy.	positions _ SortedCollection new.	end _ changesFile size.	prevBlock _ end.	block _ end - 1024 max: 0.	done _ false.	[ done or: [ positions size > 0 ]]		whileFalse: [			changesFile position: block.			"ignore first fragment"			changesFile nextChunk.			[ changesFile position < prevBlock ]				whileTrue: [					| pos chunk |					pos _ changesFile position.					chunk _ changesFile nextChunk.					((chunk indexOfSubCollection: '----' startingAt: 1) = 1) ifTrue: [						({ '----QUIT'. '----SNAPSHOT' } anySatisfy: [ :str |							chunk beginsWith: str ])								ifTrue: [ positions add: pos ]]].			block = 0				ifTrue: [done _ true]				ifFalse: [					prevBlock _ block.					block _ block - 1024 max: 0]].	changesFile close.	positions isEmpty		ifTrue: [self inform: 'File ' , changesFile name , ' does not appear to be a changes file']		ifFalse: [self browseRecentLogOn: origChangesFile startingFrom: positions last]! !!ChangeList class methodsFor: 'public access' stamp: 'jmv 2/7/2010 23:26'!browseStream: changesFile	"Opens a changeList on a fileStream"	| changeList charCount |	changesFile readOnly.	charCount _ changesFile size.	charCount > 1000000 ifTrue:		[(self confirm: 'The file ', changesFile name , 'is really long (' , charCount printString , ' characters).Would you prefer to view only the last million characters?')			ifTrue: [charCount _ 1000000]].	changeList _ Cursor read showWhile: [		self new			scanFile: changesFile from: changesFile size-charCount to: changesFile size].	changesFile close.	self open: changeList name: changesFile localName , ' log' multiSelect: true! !!ChangeSet class methodsFor: 'fileIn/Out' stamp: 'jmv 2/8/2010 00:03'!superclassOrder: classes	"Arrange the classes in the collection, classes, in superclass order so the 	classes can be properly filed in. Do it in sets instead of ordered collections.	SqR 4/12/2000 22:04"	| all list inclusionSet cache |	list _ classes copy. "list is indexable"	inclusionSet _ list asSet. cache _ Dictionary new.	all _ OrderedCollection new: list size.	list size timesRepeat:		[			| aClassIndex aClass |			aClassIndex _ list findFirst: [:one | one isNil not and: 				[self doWeFileOut: one given: inclusionSet cache: cache]].			aClass _ list at: aClassIndex.			all addLast: aClass.			inclusionSet remove: aClass.			list at: aClassIndex put: nil		].	^all! !!ChangeSorter class methodsFor: 'enumerating' stamp: 'jmv 2/8/2010 00:12'!gatherChangeSets		"ChangeSorter gatherChangeSets"	"Collect any change sets created in other projects"	| allChangeSets |	allChangeSets _ AllChangeSets asSet.	ChangeSet allSubInstances do: [ :each | | obsolete |		(allChangeSets includes: each) == (obsolete _ each isMoribund) ifTrue:[			obsolete				ifTrue: ["Was included and is obsolete."						AllChangeSets remove: each]				ifFalse: ["Was not included and is not obsolete."						AllChangeSets add: each]]].	^ AllChangeSets! !!Character class methodsFor: 'class initialization' stamp: 'jmv 2/8/2010 00:13'!initializeClassificationTable	"Initialize the classification table. The classification table is a	compact encoding of upper and lower cases of characters with		- bits 0-7: The lower case value of this character.		- bits 8-15: The upper case value of this character.		- bit 16: lowercase bit (e.g., isLowercase == true)		- bit 17: uppercase bit (e.g., isUppercase == true)"	LowercaseBit := 1 bitShift: 16.	UppercaseBit := 1 bitShift: 17.	"Initialize the letter bits (e.g., isLetter == true)"	LetterBits := LowercaseBit bitOr: UppercaseBit.	ClassificationTable := Array new: 256.	"Initialize the defaults (neither lower nor upper case)"	0 to: 255 do:[:i|		ClassificationTable at: i+1 put: (i bitShift: 8) + i.	].	"Initialize character pairs (upper-lower case)"	#(		"Basic roman"		($A $a) 	($B $b) 	($C $c) 	($D $d) 		($E $e) 	($F $f) 	($G $g) 	($H $h) 		($I $i) 		($J $j) 		($K $k) 	($L $l) 		($M $m)	($N $n)	($O $o)	($P $p) 		($Q $q) 	($R $r) 	($S $s) 	($T $t) 		($U $u)	($V $v)	($W $w)	($X $x)		($Y $y)	($Z $z)		"International"		($ $)	($ $)	($ $)	($ $)		($ $)	($ $)	($ $)	($ $)		($ $)	($ $)	($ $)	($ $)		"International - Spanish"		($ $)	($ $)		($ $)	($ $)		"International - PLEASE CHECK"		($ $)	($ $)		($ $)	($ $)		($ $)	($ $)		($ $)	($ $)	($ $)	($ $)	($ $)	) do: [ :pair | | ch1 ch2 |		ch1 := pair first asciiValue.		ch2 := pair last asciiValue.		ClassificationTable at: ch1+1 put: (ch1 bitShift: 8) + ch2 + UppercaseBit.		ClassificationTable at: ch2+1 put: (ch1 bitShift: 8) + ch2 + LowercaseBit.	].	"Initialize a few others for which we only have lower case versions."	#($ $ $ $) do: [ :char | | ch1 |		ch1 := char asciiValue.		ClassificationTable at: ch1+1 put: (ch1 bitShift: 8) + ch1 + LowercaseBit.	].! !!Collection methodsFor: 'converting' stamp: 'jmv 2/7/2010 23:54'!asSortedArray	"Return a copy of the receiver in sorted order, as an Array.  6/10/96 sw"	^ self asArray sort! !!Bag methodsFor: 'accessing' stamp: 'jmv 2/6/2010 20:46'!cumulativeCounts	"Answer with a collection of cumulative percents covered by elements so far."	| s n |	s _ self size / 100.0. n _ 0.	^ self sortedCounts asArray collect: [ :a |		n _ n + a key.		(n / s roundTo: 0.1) -> a value]! !!MessageTally methodsFor: 'comparing' stamp: 'jmv 2/6/2010 10:23'!sonsOver: threshold	| hereTally sons |	(receivers isNil or: [ receivers size = 0 ]) ifTrue: [ ^#() ].	hereTally _ tally.	sons _ receivers select: [ :son | "subtract subNode tallies for primitive hits here"		hereTally _ hereTally - son tally.		son tally > threshold ].	hereTally > threshold		ifTrue: [			| last |			last _ MessageTally new class: class method: method.			last process: process.			last reportOtherProcesses: reportOtherProcesses.			^sons copyWith: (last primitives: hereTally)].	^sons! !!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 2/6/2010 10:25'!spyAllEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy all the system processes"	| myDelay time0 |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats _ Smalltalk getVMParameters.	Timer ifNotNil: [ Timer terminate ].	Timer _ [		[true] whileTrue: [			| startTime observedProcess |			startTime := Time millisecondClockValue.			myDelay wait.			observedProcess := Processor preemptedProcess.			self				tally: observedProcess suspendedContext				in: observedProcess				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"Collect gc statistics"		Smalltalk getVMParameters keysAndValuesDo: [ :idx :gcVal | 			gcStats at: idx put: (gcVal - (gcStats at: idx))].		"cancel the probe and return the value"		Timer terminate.		Timer _ nil.		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 2/6/2010 10:27'!spyEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy only on the active process (in which aBlock is run)"	| myDelay time0 observedProcess |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	observedProcess _ Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats _ Smalltalk getVMParameters.	Timer ifNotNil: [ Timer terminate ].	Timer _ [		[ true ] whileTrue: [			| startTime |			startTime := Time millisecondClockValue.			myDelay wait.			self				tally: Processor preemptedProcess suspendedContext				in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"Collect gc statistics"		Smalltalk getVMParameters keysAndValuesDo: [ :idx :gcVal | 			gcStats at: idx put: (gcVal - (gcStats at: idx))].		"cancel the probe and return the value"		Timer terminate.		Timer _ nil.		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 2/6/2010 10:28'!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration 	"Create a spy and spy on the given process at the specified rate."	| myDelay time0 endTime observedProcess sem |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	observedProcess _ aProcess.	myDelay _ Delay forMilliseconds: millisecs.	time0 _ Time millisecondClockValue.	endTime _ time0 + msecDuration.	sem _ Semaphore new.	gcStats _ Smalltalk getVMParameters.	Timer ifNotNil: [ Timer terminate ].	Timer _ [			[				| startTime |				startTime _ Time millisecondClockValue.				myDelay wait.				self					tally: Processor preemptedProcess suspendedContext					in: (observedProcess == Processor preemptedProcess ifTrue: [ observedProcess ] ifFalse: [nil])					"tally can be > 1 if ran a long primitive"					by: (Time millisecondClockValue - startTime) // millisecs.				startTime < endTime			] whileTrue.			sem signal.		] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	"activate the probe and wait for it to finish"	sem wait.	"Collect gc statistics"	Smalltalk getVMParameters keysAndValuesDo: [ :idx :gcVal | 		gcStats at: idx put: (gcVal - gcStats at: idx)].	time _ Time millisecondClockValue - time0! !!MessageTally methodsFor: 'printing' stamp: 'jmv 2/6/2010 10:04'!printOn: aStream total: total totalTime: totalTime tallyExact: isExact 	isExact 		ifTrue: [			| myTally |			myTally := tally.			receivers == nil 				ifFalse: [receivers do: [:r | myTally := myTally - r tally]].			aStream				print: myTally;				space]		ifFalse: [			| percentage |			percentage := tally asFloat / total * 100.0 roundTo: 0.1.			aStream				print: percentage;				nextPutAll: '% {';				print: (percentage * totalTime / 100) rounded;				nextPutAll: 'ms} '].	receivers == nil 		ifTrue: [			aStream				nextPutAll: 'primitives';				cr]		ifFalse: [			| className aSelector aClass |			aSelector := class selectorAtMethod: method setClass: [ :c | aClass := c].			className := aClass name contractTo: self maxClassNameSize.			aStream				nextPutAll: class name;				nextPutAll: (aClass = class 							ifTrue: ['>>']							ifFalse: ['(' , aClass name , ')>>']);				nextPutAll: (aSelector 							contractTo: self maxClassPlusSelectorSize - className size);				cr]! !!MessageTally methodsFor: 'printing' stamp: 'jmv 2/6/2010 10:09'!printSenderCountsOn: aStream	| mergedSenders |	mergedSenders _ IdentityDictionary new.	senders do: [ :node | | mergedNode |		mergedNode _ mergedSenders at: node method ifAbsent: [ nil ].		mergedNode			ifNil: [ mergedSenders at: node method put: node ]			ifNotNil: [ mergedNode bump: node tally ]].	mergedSenders asSortedCollection do: [ :node | 		10 to: node tally printString size by: -1 do: [ :i | aStream space].		node printOn: aStream total: tally totalTime: nil tallyExact: true]! !!MessageTally methodsFor: 'printing' stamp: 'jmv 2/6/2010 10:19'!rootPrintOn: aStream total: total totalTime: totalTime threshold: threshold	| groups |	groups _ (self sonsOver: threshold) groupBy: [ :aTally | aTally process] having: [ :g | true ].	groups do: [ :g |		| sons p |		sons _ g asArray sort.		p _ g anyOne process.		(reportOtherProcesses or: [ p notNil ]) ifTrue: [			aStream nextPutAll: '--------------------------------'; cr.			aStream nextPutAll: 'Process: ',  (p ifNil: [ 'other processes'] ifNotNil: [ p browserPrintString]); cr.			aStream nextPutAll: '--------------------------------'; cr.			sons do: [ :son |				son					treePrintOn: aStream					tabs: OrderedCollection new					thisTab: ''					total: total					totalTime: totalTime					tallyExact: false					orThreshold: threshold]].	]! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 2/6/2010 09:55'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"	MessageTally tallySends: [3.14159 printString]	"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime _ Time millisecondClockValue.	tallies _ MessageTally new class: aBlock receiver class method: aBlock method.	tallies reportOtherProcesses: true.	"Do NOT filter nodes with nil process"	prev _ aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep: [ :current |			current == prev ifFalse: [ "call or return"				prev sender == nil ifFalse: [ "call only"					(receiver == nil or: [ current receiver == receiver ])						ifTrue: [ tallies tally: current by: 1 ]].				prev _ current]].	totalTime _ Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	(CodeHolder new contents:		(String streamContents: [ :s |			s nextPutAll: 'This simulation took ' , totalTime printString, ' seconds.'; cr.			treeOption				ifTrue: [ tallies fullPrintExactOn: s ]				ifFalse: [ tallies leavesPrintExactOn: s ].			tallies close ]))		openLabel: 'Spy Results' wrap: false! !ChangeSet removeSelector: #convertApril2000:using:!