'From Cuis 5.0 [latest update: #4045] on 20 February 2020 at 1:40:23 pm'!
'Description '!
!provides: 'History-VectorGraphics' 1 3!
SystemOrganization addCategory: #'History-VectorGraphics-Kernel'!


!classDefinition: #VectorEngine01 category: #'History-VectorGraphics-Kernel'!
Object subclass: #VectorEngine01
	instanceVariableNames: 'targetForm targetWidth targetHeight antiAliasingWidth antiAliasingWidthScaledInverse subPixelDelta strokeWidth strokeWidthDilatedHalf strokeWidthDilatedHalfSquared strokeWidthErodedHalf strokeWidthErodedHalfSquared strokeAlpha strokeRed strokeGreen strokeBlue fillAlpha fillRed fillGreen fillBlue doStroke doFill clipLeft clipTop clipRight clipBottom currentMorph currentOwnerIfClips morphAtPixel morphBoundsLeft morphBoundsRight morphBoundsTop morphBoundsBottom mask edgeCountPerPixel blendBoundsLeft blendBoundsTop blendBoundsRight blendBoundsBottom maskBoundsLeft maskBoundsTop maskBoundsRight maskBoundsBottom hopsPerPixel auxBitBlt firstX firstY currentX currentY trajectoryPoints prevYTruncated geometryTransformation lastClientX lastClientY lastControlX lastControlY'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'History-VectorGraphics-Kernel'!
!classDefinition: 'VectorEngine01 class' category: #'History-VectorGraphics-Kernel'!
VectorEngine01 class
	instanceVariableNames: ''!

!classDefinition: #VectorEngine02 category: #'History-VectorGraphics-Kernel'!
Object subclass: #VectorEngine02
	instanceVariableNames: 'targetForm targetWidth targetHeight antiAliasingWidth antiAliasingWidthScaledInverse subPixelDelta strokeWidth strokeWidthDilatedHalf strokeWidthDilatedHalfSquared strokeWidthErodedHalf strokeWidthErodedHalfSquared strokeAlpha strokeRed strokeGreen strokeBlue fillAlpha fillRed fillGreen fillBlue doStroke doFill clipLeft clipTop clipRight clipBottom currentMorph currentOwnerIfClips morphAtPixel morphBoundsLeft morphBoundsRight morphBoundsTop morphBoundsBottom mask edgeCountPerPixel blendBoundsLeft blendBoundsTop blendBoundsRight blendBoundsBottom maskBoundsLeft maskBoundsTop maskBoundsRight maskBoundsBottom hopsPerPixel auxBitBlt firstX firstY currentX currentY trajectoryPoints prevYTruncated geometryTransformation lastClientX lastClientY lastControlX lastControlY'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'History-VectorGraphics-Kernel'!
!classDefinition: 'VectorEngine02 class' category: #'History-VectorGraphics-Kernel'!
VectorEngine02 class
	instanceVariableNames: ''!

!classDefinition: #VectorEngine03 category: #'History-VectorGraphics-Kernel'!
Object subclass: #VectorEngine03
	instanceVariableNames: 'targetForm targetWidth targetHeight antiAliasingWidth antiAliasingWidthScaledInverse subPixelDelta strokeWidth strokeWidthDilatedHalf strokeWidthDilatedHalfSquared strokeWidthErodedHalf strokeWidthErodedHalfSquared strokeAlpha strokeRed strokeGreen strokeBlue fillAlpha fillRed fillGreen fillBlue doStroke doFill clipLeft clipTop clipRight clipBottom currentMorph currentOwnerIfClips morphAtPixel morphBoundsLeft morphBoundsRight morphBoundsTop morphBoundsBottom mask edgeCountPerPixel blendBoundsLeft blendBoundsTop blendBoundsRight blendBoundsBottom maskBoundsLeft maskBoundsTop maskBoundsRight maskBoundsBottom hopsPerPixel auxBitBlt firstX firstY currentX currentY trajectoryPoints prevYTruncated geometryTransformation lastClientX lastClientY lastControlX lastControlY'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'History-VectorGraphics-Kernel'!
!classDefinition: 'VectorEngine03 class' category: #'History-VectorGraphics-Kernel'!
VectorEngine03 class
	instanceVariableNames: ''!

!classDefinition: #VectorEngine04 category: #'History-VectorGraphics-Kernel'!
Object subclass: #VectorEngine04
	instanceVariableNames: 'targetForm targetWidth targetHeight antiAliasingWidth antiAliasingWidthScaledInverse subPixelDelta strokeWidth strokeWidthDilatedHalf strokeWidthDilatedHalfSquared strokeWidthErodedHalf strokeWidthErodedHalfSquared strokeAlpha strokeRed strokeGreen strokeBlue fillAlpha fillRed fillGreen fillBlue doStroke doFill clipLeft clipTop clipRight clipBottom currentMorph currentOwnerIfClips morphAtPixel morphBoundsLeft morphBoundsRight morphBoundsTop morphBoundsBottom mask edgeCountPerPixel blendBoundsLeft blendBoundsTop blendBoundsRight blendBoundsBottom hopsPerPixel auxBitBlt firstX firstY currentX currentY trajectoryPoints prevYTruncated geometryTransformation lastClientX lastClientY lastControlX lastControlY'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'History-VectorGraphics-Kernel'!
!classDefinition: 'VectorEngine04 class' category: #'History-VectorGraphics-Kernel'!
VectorEngine04 class
	instanceVariableNames: ''!

!classDefinition: #VectorEngine05 category: #'History-VectorGraphics-Kernel'!
Object subclass: #VectorEngine05
	instanceVariableNames: 'targetForm targetWidth targetHeight antiAliasingWidth antiAliasingWidthScaledInverse subPixelDelta strokeWidth strokeWidthDilatedHalf strokeWidthDilatedHalfSquared strokeWidthErodedHalf strokeWidthErodedHalfSquared openCLKernelWidth openCLKernelHeight strokeAlpha strokeRed strokeGreen strokeBlue fillAlpha fillRed fillGreen fillBlue doStroke doFill clipLeft clipTop clipRight clipBottom currentMorph currentOwnerIfClips morphAtPixel morphBoundsLeft morphBoundsRight morphBoundsTop morphBoundsBottom mask edgeCountPerPixel blendBoundsLeft blendBoundsTop blendBoundsRight blendBoundsBottom hopsPerPixel auxBitBlt firstX firstY currentX currentY trajectoryPoints prevYTruncated geometryTransformation lastClientX lastClientY lastControlX lastControlY'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'History-VectorGraphics-Kernel'!
!classDefinition: 'VectorEngine05 class' category: #'History-VectorGraphics-Kernel'!
VectorEngine05 class
	instanceVariableNames: ''!

!classDefinition: #VectorEngine06 category: #'History-VectorGraphics-Kernel'!
Object subclass: #VectorEngine06
	instanceVariableNames: 'targetForm targetWidth targetHeight antiAliasingWidth antiAliasingWidthScaledInverse subPixelDelta strokeWidth strokeWidthDilatedHalf strokeWidthDilatedHalfSquared strokeWidthErodedHalf strokeWidthErodedHalfSquared openCLKernelWidth openCLKernelHeight strokeAlpha strokeRed strokeGreen strokeBlue fillAlpha fillRed fillGreen fillBlue doStroke doFill clipLeft clipTop clipRight clipBottom currentMorph currentOwnerIfClips morphAtPixel morphBoundsLeft morphBoundsRight morphBoundsTop morphBoundsBottom mask edgeCountPerPixel blendBoundsLeft blendBoundsTop blendBoundsRight blendBoundsBottom hopsPerPixel auxBitBlt firstX firstY currentX currentY prevYTruncated geometryTransformation lastClientX lastClientY lastControlX lastControlY jj ii pixY pixX z_pixelIndex z_alphaWord z_redAlpha z_greenAlpha z_blueAlpha z_previousRedAlpha z_previousGreenAlpha z_previousBlueAlpha'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'History-VectorGraphics-Kernel'!
!classDefinition: 'VectorEngine06 class' category: #'History-VectorGraphics-Kernel'!
VectorEngine06 class
	instanceVariableNames: ''!

!classDefinition: #VectorEngine07 category: #'History-VectorGraphics-Kernel'!
Object subclass: #VectorEngine07
	instanceVariableNames: 'targetForm targetWidth targetHeight antiAliasingWidth antiAliasingWidthScaledInverse subPixelDelta strokeWidth strokeWidthDilatedHalf strokeWidthDilatedHalfSquared strokeWidthErodedHalf strokeWidthErodedHalfSquared openCLKernelWidth openCLKernelHeight strokeAlpha strokeRed strokeGreen strokeBlue fillAlpha fillRed fillGreen fillBlue doStroke doFill clipLeft clipTop clipRight clipBottom currentMorph currentOwnerIfClips morphAtPixel morphBoundsLeft morphBoundsRight morphBoundsTop morphBoundsBottom mask edgeCountPerPixel blendBoundsLeft blendBoundsTop blendBoundsRight blendBoundsBottom hopsPerPixel auxBitBlt firstX firstY currentX currentY prevYTruncated geometryTransformation lastClientX lastClientY lastControlX lastControlY jj ii pixY pixX z_pixelIndex z_alphaWord z_redAlpha z_greenAlpha z_blueAlpha z_previousRedAlpha z_previousGreenAlpha z_previousBlueAlpha'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'History-VectorGraphics-Kernel'!
!classDefinition: 'VectorEngine07 class' category: #'History-VectorGraphics-Kernel'!
VectorEngine07 class
	instanceVariableNames: ''!


!VectorEngine01 commentStamp: '<historical>' prior: 0!
01 es la bolita adentro de cada pixel.

A Vector Graphics rasterizer for Morphic 3.
Supports most SVG primitives.
Gives exceptional quality.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen!

!VectorEngine02 commentStamp: '<historical>' prior: 0!
02 es la paralelizacion guaranga en todos los pixels.

A Vector Graphics rasterizer for Morphic 3.
Supports most SVG primitives.
Gives exceptional quality.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen!

!VectorEngine03 commentStamp: '<historical>' prior: 0!
Un primer corte de la idea de paralelizar en la bolita. Quedan varios desafios.
Lo proximo que quiero hacer es eliminar trajectoryPoints.
Un problema que veo es que la busqueda de bounds quedaria paralelizada. Es ineficiente e inutil. Lo mismo para la actualizacion de EdgeCounts. Quizás necesite una solucion general. En el peor de los casos un if que solo de true para el 1er elemento del kernel, o no se...

A Vector Graphics rasterizer for Morphic 3.
Supports most SVG primitives.
Gives exceptional quality.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen!

!VectorEngine04 commentStamp: '<historical>' prior: 0!
Un primer corte de la idea de paralelizar en la bolita. 
Acabo de eliminar los MaskBounds.
Quedan varios desafios.
Lo proximo que quiero hacer es eliminar trajectoryPoints.
Un problema que veo es que la busqueda de bounds quedaria paralelizada. Es ineficiente e inutil. Lo mismo para la actualizacion de EdgeCounts. Quizás necesite una solucion general. En el peor de los casos un if que solo de true para el 1er elemento del kernel, o no se...

A Vector Graphics rasterizer for Morphic 3.
Supports most SVG primitives.
Gives exceptional quality.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen!

!VectorEngine05 commentStamp: '<historical>' prior: 0!
Un primer corte de la idea de paralelizar en la bolita. 
Acabo de poner la bolita como vars de instancia para que no sean parametros y simplificar el refactoring que viene.
Quedan varios desafios.
Lo proximo que quiero hacer es eliminar trajectoryPoints.
Un problema que veo es que la busqueda de bounds quedaria paralelizada. Es ineficiente e inutil. Lo mismo para la actualizacion de EdgeCounts. Quizás necesite una solucion general. En el peor de los casos un if que solo de true para el 1er elemento del kernel, o no se...

A Vector Graphics rasterizer for Morphic 3.
Supports most SVG primitives.
Gives exceptional quality.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen!

!VectorEngine06 commentStamp: '<historical>' prior: 0!
Un primer corte de la idea de paralelizar en la bolita. 
Acabo de eliminar trajectoryPoints.
Hay que probar y revisar cómo quedó esto...
Un problema que veo es que la busqueda de bounds quedaria paralelizada. Es ineficiente e inutil. Lo mismo para la actualizacion de EdgeCounts. Quizás necesite una solucion general. En el peor de los casos un if que solo de true para el 1er elemento del kernel, o no se...

A Vector Graphics rasterizer for Morphic 3.
Supports most SVG primitives.
Gives exceptional quality.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen!

!VectorEngine07 commentStamp: '<historical>' prior: 0!
Aca es donde estoy trabajando. En las numeradas guardo snapshots.

A Vector Graphics rasterizer for Morphic 3.
Supports most SVG primitives.
Gives exceptional quality.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.

(VectorEngine onForm: Display)
	fillColor: Color red do: [ :engine |
		engine abs_EllipseCenterX: 100 y: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen!

!VectorEngine01 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:09:59'!
antiAliasingWidth: aNumber

	antiAliasingWidth _ aNumber.
	antiAliasingWidthScaledInverse _ 127.0 / antiAliasingWidth! !

!VectorEngine01 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:09:59'!
clipRect: aRectangle 
	"by convention, aRectangle includes left and top but does not include right and bottom.
	We do draw clipRight and clipBottom but not beyond.
	"
	"In targetForm coordinates"
	clipLeft _ aRectangle left.
	clipTop _ aRectangle top.
	clipRight _ aRectangle right - 1.
	clipBottom _ aRectangle bottom - 1! !

!VectorEngine01 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:09:59'!
clippingRectForCurrentMorph
	"In targetForm coordinates.
	Only valid _after_ drawing currentMorph."

	^morphBoundsLeft @ morphBoundsTop corner: morphBoundsRight @ morphBoundsBottom! !

!VectorEngine01 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:09:59'!
currentMorph: aMorph
	currentMorph _ aMorph! !

!VectorEngine01 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:09:59'!
currentOwnerIfClips: currentMorphOwnerOrNil
	currentOwnerIfClips _ currentMorphOwnerOrNil! !

!VectorEngine01 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:09:59'!
geometryTransformation
	^geometryTransformation! !

!VectorEngine01 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:09:59'!
geometryTransformation: aGeometryTransformation
	geometryTransformation _ aGeometryTransformation! !

!VectorEngine01 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 10:09:59'!
fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	doStroke _ false.
	doFill _ true.
	self pvtStrokeWidth: 0.0.
	hopsPerPixel _ 8.										"See #experimentHopsPerPixel3"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ nil. strokeRed _ nil. strokeGreen _ nil. strokeBlue _ nil.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine01 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 10:09:59'!
strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke."

	| strokeAlphaFactor aStrokeWidth |
	doStroke _ true.
	doFill _ false.
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.

	"Strokes we want to show. They are not too thin, or maybe they are, but there's no fill. Make them wide enough to be properly sampled."
	self pvtStrokeWidth: (aStrokeWidth max: antiAliasingWidth).
	strokeAlphaFactor _ aStrokeWidth / strokeWidth.
	hopsPerPixel _ 10.0 / strokeWidth + 1.		"See #experimentHopsPerPixel2"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ nil. fillRed _ nil. fillGreen _ nil. fillBlue _ nil.
	strokeAlpha _ (aStrokeColor alpha * 255.0 * strokeAlphaFactor) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine01 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 10:09:59'!
strokeWidth: clientStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	| aStrokeWidth |

	aStrokeColor ifNil: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	clientStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aFillColor ifNil: [ ^ self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock.
		^ self ].

	doStroke _ true.
	doFill _ true.
	self pvtStrokeWidth: aStrokeWidth.
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"Strokes are really thin, but strokeColor is same as fillColor, so there's no problem sampling them."
			hopsPerPixel _ 8 ]								"See #experimentHopsPerPixel1"
		ifFalse: [
			hopsPerPixel _ 10.0 / strokeWidth + 1 max: 2 ].		"See #experimentHopsPerPixel2. Additionally, fills require at least 2."

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ (aStrokeColor alpha * 255.0) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:09:59'!
abs_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.2 position: 200@100);
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcToX: center x y: center y radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:09:59'!
abs_CircleCenterX: cx y: cy radius: mr
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_CircleCenterX: 200 y: 150 radius: 80].
Display forceToScreen
"

	| center r |
	center _ geometryTransformation externalizePosition: cx@cy.
	r _ geometryTransformation externalizeScalar: mr.
	self
		basicArcCenterX: center x centerY: center y radiusX: r radiusY: r rotationAngle: 0.0 start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:09:59'!
abs_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 150 y: 300 radius: 10.
		engine abs_CircleCenterX: 600 y: 400 radius: 6.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 600 y: -200 radius: 10.
		engine abs_CircleCenterX: 100 y: -100 radius: 6.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_CubicBezierToX: 300 y: 100 control1X: 600 y: -200 control2X: 100 y: -100
			].
Display forceToScreen.
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 100 control2X: 100 y: -100
			].
Display forceToScreen
	"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_CubicBezierToX: x3 y: y3 control1X: mirroredContolX y: mirroredContolY control2X: x2 y: y2! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:09:59'!
abs_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"
	| p1 p2 p3 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	p3 _ geometryTransformation externalizePosition: x3@y3.
	self basicCubicBezierToX: p3 x y: p3 y control1X: p1 x y: p1 y control2X: p2 x y: p2 y.
	lastClientX _ x3.
	lastClientY _ y3.
	lastControlX _ x2.
	lastControlY _ y2! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:09:59'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta start: startAngle sweep: sweepAngle
	"Currently draws a line from currentX@currentY to start (if startAngle ~= 0.0 or sweepAngle ~= Float twoPi).
	This could be useful for proper fills. But might not be what is desired in some cases.
	Implement desired behavior when clear."
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.0 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6].
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 350 radiusX: 100 radiusY: 50 rotationAngle: 0.5 start: 0.1 sweep: 6 ].
Display forceToScreen.
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: startAngle sweep:  sweepAngle! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
abs_LineToX: x2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: x2 y: lastClientY! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
abs_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p2 |
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicLineToX: p2 x y: p2 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
abs_LineToY: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToY: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToY: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX y: y2! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
abs_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p |
	p _ geometryTransformation externalizePosition: x@y.
	self basicMoveToX: p x y: p y.
	lastClientX _ x.
	lastClientY _ y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
abs_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 450 y: 300 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 750 y: -100 radius: 10.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_QuadraticBezierToX: 300 y: 100 controlX: 750 y: -100
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			abs_QuadraticBezierSmoothToX: 300 y: 100
			].
Display forceToScreen
"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_QuadraticBezierToX: x2 y: y2 controlX: mirroredContolX y: mirroredContolY! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
abs_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| p1 p2 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicQuadraticBezierToX: p2 x y: p2 y controlX: p1 x y: p1 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ x1.
	lastControlY _ y1! !

!VectorEngine01 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
do_ClosePath
	"abs/rel meaningless here"
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200;
			abs_CubicBezierToX: 300 y: 120 control1X: 310 y: 110 control2X: 200 y: 200;
			do_ClosePath;
			abs_LineToX: 150 y: 300 ].
Display forceToScreen
"
	| p2 |
	self basicClosePath.

	p2 _ geometryTransformation internalizePosition: currentX@currentY.
	lastClientX _ p2 x.
	lastClientY _ p2 y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine01 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
rel_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			rel_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false;
			do_ClosePath ].
"
	self abs_ArcToX: lastClientX + cx y: lastClientY + cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine01 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
rel_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierToX: 300 y: 300 control1X: 0 y: 0 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierSmoothToX: 600 y: 100 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"

	self
		abs_CubicBezierSmoothToX: lastClientX + x3 y: lastClientY + y3
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine01 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
rel_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ];
	strokeWidth: 1.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ];
	strokeWidth: 10 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	self
		abs_CubicBezierToX: lastClientX + x3 y: lastClientY + y3
		control1X: lastClientX + x1 y: lastClientY + y1
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine01 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
rel_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine01 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
rel_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_MoveToX: lastClientX + x y: lastClientY + y! !

!VectorEngine01 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
rel_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 550 y: 350 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 850 y: -50 radius: 10.
		engine abs_MoveToX: 700 y: 150.
		engine
			rel_QuadraticBezierToX: -300 y: -50 controlX: 150 y: -200
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			rel_QuadraticBezierSmoothToX: -300 y: -50
			].
Display forceToScreen
"
	self
		abs_QuadraticBezierSmoothToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine01 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
rel_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ];
	strokeWidth: 3.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ];
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color green alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	self
		abs_QuadraticBezierToX: lastClientX + x2 y: lastClientY + y2
		controlX: lastClientX + x1 y: lastClientY + y1! !

!VectorEngine01 methodsFor: 'text' stamp: 'jmv 2/9/2020 10:10:00'!
displayString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aFont color: aColor canvas: aCanvas
	"geometryTransformation is already set to honor font pointSize
	Use as little of aFont as possible!!"
	| glyph destX destY loc |

	self antiAliasingWidth: VectorEngine antiAliasingWidthForOutlineFonts.
	loc _ geometryTransformation.
	self fillColor: aColor do: [
		destY _ aPoint y.
		destX _ aPoint x.
		startIndex to: stopIndex do: [ :charIndex |
			glyph _ aFont ttGlyphAt: (aString at: charIndex).
			glyph isComposite
				ifFalse: [
					glyph contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ].
					]]
				ifTrue: [
					glyph txAndContoursDo: [ :tx :contours |contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ (loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated) composedWith: tx.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ]]]
					].
			destX _ destX + glyph advanceWidth.
		]
	].
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:00'!
addPenPositionX: x y: y

"
Inlinear en senders. Extraer afectar bounds si es posible (linea, circulo)
"

	trajectoryPoints add: x@y.

	maskBoundsTop _ maskBoundsTop min: y.
	maskBoundsBottom _ maskBoundsBottom max: y.
	maskBoundsLeft _ maskBoundsLeft min: x.
	maskBoundsRight _ maskBoundsRight max: x.

	"Compute edges intersecting with this horizontal line, for fills."
	doFill ifTrue: [
		self updateEdgeCountAtX: x y: y ].! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:00'!
finishPath
	"Blend stroke and/or fill over background, according to the just computed pen alphas (distance from pixel to center of stroke)"
	
	"If we are doing a fill, and caller forgot to close the trajectory, then do it anyway."
	doFill ifTrue: [
		(firstX = currentX and: [ firstY = currentY ]) ifFalse: [
			"This is actually an error condition. If we are asked to fill, then the path should be closed.
			This is a workaround. If width > 0.0, we'll be adding a visible edge to the path."
			self basicClosePath ]].

	doFill ifTrue: [
		doStroke
			ifTrue: [ self blendStrokeAndFill ]
			ifFalse: [ self blendFillOnly ]]
		ifFalse: [
		self blendStrokeOnly ].
	morphBoundsTop _ morphBoundsTop min: blendBoundsTop.
	morphBoundsBottom _ morphBoundsBottom max: blendBoundsBottom.
	morphBoundsLeft _ morphBoundsLeft min: blendBoundsLeft.
	morphBoundsRight _ morphBoundsRight max: blendBoundsRight.

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.

	Display forceToScreen! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:00'!
initialize
	geometryTransformation _ MorphicTranslation new. "Identity"! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:00'!
initializePath

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.
	trajectoryPoints _ OrderedCollection new.
	prevYTruncated _ nil.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."

	blendBoundsTop _ targetHeight.			"drawable bottom. Will later be refined."
	blendBoundsBottom _ 0.						"drawable top. Will later be refined."
	blendBoundsLeft _ targetWidth.			"drawable right. Will later be refined."
	blendBoundsRight _ 0.						"drawable left. Will later be refined."! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:00'!
pvtStrokeWidth: aNumber
	strokeWidth _ aNumber.
	strokeWidthDilatedHalf _ strokeWidth + antiAliasingWidth * 0.5.
	strokeWidthDilatedHalfSquared _ strokeWidthDilatedHalf * strokeWidthDilatedHalf.
	strokeWidthErodedHalf _ strokeWidth - antiAliasingWidth * 0.5.
	strokeWidthErodedHalfSquared _ strokeWidthErodedHalf * strokeWidthErodedHalf * strokeWidthErodedHalf sign! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:00'!
resetMorphBounds

	morphBoundsTop _ targetHeight - 1.
	morphBoundsBottom _ 0.
	morphBoundsLeft _ targetWidth - 1.
	morphBoundsRight _ 0! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:00'!
setForm: aForm
	"
	World extent: World extent
	"
	| hack s |
	targetForm _ aForm.
	targetWidth _ aForm width.
	targetHeight _ aForm height.
	self resetMorphBounds.
	self clipRect: (0@0 corner: targetWidth@targetHeight).
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth.
	subPixelDelta _ 0.25. "Values closer to 0.333 might produce a bit of coloring on some displays. Used to be 0.28"
	s _ aForm bits size.
	(mask isNil or: [ mask size ~= s ])
		ifTrue: [
			mask _ WordArray new: s.
			edgeCountPerPixel _ WordArray new: s.
			morphAtPixel _ Array new: s.
			hack _ Form extent: targetWidth@targetHeight depth: 32 bits: mask.
			auxBitBlt _ BitBlt toForm: hack.
			auxBitBlt fillBitmap: (Bitmap with: 16rFF000000).
			auxBitBlt combinationRule: Form over ].

	"Perhaps this should be done in an ifCurtailed: block in case of Morphic drawing failure..."
	auxBitBlt destRect: targetForm boundingBox.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	morphAtPixel atAllPut: 0! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:00'!
updateEdgeCountAtX: x y: y
	| thisYTruncated pixelY pixelIndexBase redPixelIndex greenPixelIndex bluePixelIndex increment countWord redCount greenCount blueCount redOffset greenOffest blueOffset |

	thisYTruncated _ (y truncated max: clipTop-1) min: clipBottom-1.
	prevYTruncated ifNil: [ 
		^ prevYTruncated _ thisYTruncated ].
	thisYTruncated = prevYTruncated ifTrue: [
		^ prevYTruncated _ thisYTruncated ].

	thisYTruncated > prevYTruncated
		ifTrue: [
			pixelY _ thisYTruncated.
			increment _ 1 ]
		ifFalse: [
			pixelY _ prevYTruncated.
			increment _ -1 ].

	"All edge count at the left of the clipRect are added there (at the left of the clipRect).
	The effect is the same, and we need to clean up less stuff afterwards.
	More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses."
	pixelIndexBase _ pixelY * targetWidth + 1.
	redOffset _ (x+subPixelDelta) truncated + 1 max: clipLeft.
	greenOffest _ x truncated + 1 max: clipLeft.
	blueOffset _ (x-subPixelDelta) truncated + 1 max: clipLeft.
	redPixelIndex _ pixelIndexBase + redOffset.
	greenPixelIndex _ pixelIndexBase + greenOffest.
	bluePixelIndex _ pixelIndexBase + blueOffset.

	"Three possible cases here: RGB in one word (pixel); RG in one, and G in another; R in one, GB in another"
	redPixelIndex = bluePixelIndex
		ifTrue: [						"First case: RGB in the same word"
			redOffset <= clipRight ifTrue: [
				countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
				redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
				countWord at: 3 put: redCount.
				greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
				countWord at: 2 put: greenCount.
				blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
				countWord at: 1 put: blueCount.
				edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].
		]
		ifFalse: [
			redPixelIndex = greenPixelIndex
				ifTrue: [				"Second case: RG in one word, B in following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
				ifFalse: [			"Third case: R in one word, GB in the following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
		].
	prevYTruncated _ thisYTruncated! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:14:08'!
updateMask
	"Apdate alpha (transparency) mask using trajectoryPoints."

	maskBoundsTop _ (maskBoundsTop - strokeWidthDilatedHalf) truncated +1.
	maskBoundsBottom _ (maskBoundsBottom + strokeWidthDilatedHalf) truncated.
	maskBoundsLeft _ (maskBoundsLeft - strokeWidthDilatedHalf - subPixelDelta) truncated +1.
	maskBoundsRight _ (maskBoundsRight + strokeWidthDilatedHalf + subPixelDelta) truncated.
	maskBoundsTop < clipTop ifTrue: [ maskBoundsTop _ clipTop ].
	maskBoundsBottom > clipBottom ifTrue: [ maskBoundsBottom _ clipBottom ].
	maskBoundsLeft< clipLeft ifTrue: [ maskBoundsLeft _ clipLeft ].
	maskBoundsRight > clipRight ifTrue: [ maskBoundsRight _ clipRight ].

	"Paralelizar en displayX@displayY"
	"Esto es lo de antes, iterar puntos y ahi adentro la bolita.
	Punto de partida para la bolita que avanza rodando que quiero hacer ahora."
	trajectoryPoints do: [ :p | self updateMaskForX: p x y: p y ].
	trajectoryPoints _ OrderedCollection new.

	"Include updated mask in area to blend."
	blendBoundsTop _ blendBoundsTop min: maskBoundsTop.
	blendBoundsBottom _ blendBoundsBottom max: maskBoundsBottom.
	blendBoundsLeft _ blendBoundsLeft min: maskBoundsLeft.
	blendBoundsRight _ blendBoundsRight max: maskBoundsRight.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:20:41'!
updateMaskForX: x y: y

	"slight optimization possible when we know width = 0... perhaps implement:
		-we know palpha is never 127
		- we know distanceToEdge is always > erodedHalfWidth.
	In smalltalk, performance icrease 1.5%. Perhaps in c/asm it is more than that...
	Mas importante:
		Cuando width es medio grande, entonces dibujar la bolita rellena de entrada es importante... en los casos en que no necesito calcular la distancia"
	| dilatedHalfWidth erodedHalfWidth distanceToAxis alpha t b l r constant1 alphaWord doUpdate dySquared dx dxSquared dy pixelIndex dxp |

	dilatedHalfWidth _ strokeWidth + antiAliasingWidth * 0.5.			"Podria ir como ivar... o al menos como arg"
	erodedHalfWidth _ strokeWidth - antiAliasingWidth * 0.5.			"Podria ir como ivar... o al menos como arg"
	constant1 _ 127.0 / antiAliasingWidth.

	"Compute affected rect. Honor clipRect"
	t _ (y -dilatedHalfWidth) truncated +1.
	t < clipTop ifTrue: [ t _ clipTop ].
	b _ (y +dilatedHalfWidth) truncated.
	b > clipBottom ifTrue: [ b _ clipBottom ].
	l _ (x -dilatedHalfWidth -subPixelDelta) truncated +1.
	l < clipLeft ifTrue: [ l _ clipLeft ].
	r _ (x +dilatedHalfWidth +subPixelDelta) truncated.
	r > clipRight ifTrue: [ r _ clipRight ].

	t to: b do: [ :displayY |
		pixelIndex _ displayY * targetWidth +  l.
		l to: r do: [ :displayX |
			pixelIndex _ pixelIndex + 1.
			alphaWord _ mask bytesAt: pixelIndex.
			alphaWord = "16rFF7F7F7F" #[16r7F 16r7F 16r7F 16rFF] ifFalse: [
				doUpdate _ false.
				dy _ displayY - y.
				dySquared _ dy * dy.
				dx _ displayX - x.
				"Red"
				dxp _ dx - subPixelDelta.
				dxSquared _ dxp * dxp.
				distanceToAxis _ (dxSquared + dySquared) sqrt.
				distanceToAxis < dilatedHalfWidth
					ifTrue: [
						alpha _ distanceToAxis <= erodedHalfWidth
							ifTrue: [ 16r7F ]
							ifFalse: [ (dilatedHalfWidth - distanceToAxis * constant1) rounded ].
						alpha > (alphaWord at: 3) ifTrue: [
							alphaWord at: 3 put: alpha.
							doUpdate _ true ]].
				"Green"
				dxSquared _ dx * dx.
				distanceToAxis _ (dxSquared + dySquared) sqrt.
				distanceToAxis < dilatedHalfWidth
					ifTrue: [
						alpha _ distanceToAxis <= erodedHalfWidth
							ifTrue: [ 16r7F ]
							ifFalse: [ (dilatedHalfWidth - distanceToAxis * constant1) rounded ].
						alpha > (alphaWord at: 2) ifTrue: [
							alphaWord at: 2 put: alpha.
							doUpdate _ true ]].
				"Blue"
				dxp _ dx + subPixelDelta.
				dxSquared _ dxp * dxp.
				distanceToAxis _ (dxSquared + dySquared) sqrt.
				distanceToAxis < dilatedHalfWidth
					ifTrue: [
						alpha _ distanceToAxis <= erodedHalfWidth
							ifTrue: [ 16r7F ]
							ifFalse: [ (dilatedHalfWidth - distanceToAxis * constant1) rounded ].
						alpha > (alphaWord at: 1) ifTrue: [
							alphaWord at: 1 put: alpha.
							doUpdate _ true ]].
				doUpdate ifTrue: [
					mask bytesAt: pixelIndex put: alphaWord ]]]]! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:00'!
updateMaskForXDistanceToAxis: distanceToAxisR g: distanceToAxisG b: distanceToAxisB displayX: displayX displayY: displayY
	| alpha alphaWord pixelIndex |

	pixelIndex _ displayY * targetWidth +  displayX.
	pixelIndex _ pixelIndex + 1.
	alphaWord _ mask bytesAt: pixelIndex.

	"Red"
	distanceToAxisR < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxisR <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisR * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 3) ifTrue: [
				alphaWord at: 3 put: alpha ]].
	"Green"
	distanceToAxisG < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxisG <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisG * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 2) ifTrue: [
				alphaWord at: 2 put: alpha ]].
	"Blue"
	distanceToAxisB < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxisB <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisB * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 1) ifTrue: [
				alphaWord at: 1 put: alpha ]].
	mask bytesAt: pixelIndex put: alphaWord! !

!VectorEngine01 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:00'!
updateMaskForYDistanceToAxis: distanceToAxis displayX: displayX displayY: displayY
	| alpha alphaWord pixelIndex |

	pixelIndex _ displayY * targetWidth +  displayX.
	pixelIndex _ pixelIndex + 1.
	alphaWord _ mask bytesAt: pixelIndex.
	distanceToAxis < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxis <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxis * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 3) ifTrue: [
				alphaWord at: 3 put: alpha ].
			alpha > (alphaWord at: 2) ifTrue: [
				alphaWord at: 2 put: alpha ].
			alpha > (alphaWord at: 1) ifTrue: [
				alphaWord at: 1 put: alpha ].
			mask bytesAt: pixelIndex put: alphaWord ]! !

!VectorEngine01 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:00'!
basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: theta start: startAngle sweep: sweepAngle
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black fillColor: Color red do: [ :engine |
		engine basicArcCenterX: 100 centerY: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.
"
	| d hops angle thetaCos thetaSin xp yp x0 y0 x y |
	
	"Por supuesto probar tambien rx no igual a ry, y uno (o ambos) menor que el ancho de trazo..."
	thetaCos _ theta cos.
	thetaSin _ theta sin.
	angle _ startAngle.
	xp _ angle cos * rx.
	yp _ angle sin * ry.
	x0 _ thetaCos * xp - (thetaSin * yp) + cx.
	y0 _ thetaSin * xp + (thetaCos * yp) + cy.
	(startAngle ~= 0.0 or: [ sweepAngle ~= Float twoPi ])
		ifTrue: [ self basicLineToX: x0 y: y0 ]	"Draw a line. There are cases where we want to join an arc. For example, window frames"
		ifFalse: [
			"trajectory starts here. Eventually, #closePath should draw a line to here"
			"Next point will be first in a new trajectory fragment"
			prevYTruncated _ nil.
			firstX _ x0.
			firstY _ y0.
			self addPenPositionX: x0 y: y0 ].
	hops _ ((rx+ry * 4 * sweepAngle abs / (2*Float pi)) * hopsPerPixel) truncated + 1.
	d _ sweepAngle / hops.
	hops timesRepeat: [
		angle _ angle + d.
		xp _ angle cos * rx.
		yp _ angle sin * ry.
		x _ thetaCos * xp - (thetaSin * yp) + cx.
		y _ thetaSin * xp + (thetaCos * yp) + cy.
		self addPenPositionX: x y: y ].

	currentX _ x.
	currentY _ y.

	self updateMask! !

!VectorEngine01 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:01'!
basicArcToX: x2 y: y2 radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"
	"Calcular: cx, cy, rx, ry, phi, theta1, deltaTheta"
	| x1 y1 cosPhi sinPhi x12hd y12hd x1p y1p rxSq rySq x1pSq y1pSq bigSqR bigSqRNumerator bigSqRDenominator sign cxp cyp cx cy theta1 theta2 deltaTheta scaleSq scale newRx newRy |
	x1 _ currentX.
	y1 _ currentY.
	"Handle out of range parameters as requested by the w3 implementation notes"
	(x2 = x1 and: [ y2 = y1 ]) ifTrue: [ ^self ].
	(rx = 0.0 or: [ ry = 0.0 ]) ifTrue: [ ^self basicLineToX: x2 y: y2 ].
	rx < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: 0.0 -rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	ry < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: rx radiusY: 0.0-ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	
	cosPhi _ phi cos.
	sinPhi _ phi sin.
	"step 1 in http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes"
	x12hd _ (x1-x2) * 0.5.
	y12hd _ (y1-y2) * 0.5.
	x1p _ (cosPhi * x12hd) + (sinPhi * y12hd).
	y1p _ (cosPhi * y12hd) - (sinPhi * x12hd).

	"step 2"
	rxSq _ rx * rx.
	rySq _ ry * ry.
	x1pSq _ x1p * x1p.
	y1pSq _ y1p * y1p.
	"ensure radii are large enough"
	scaleSq _ (x1pSq / rxSq) + (y1pSq / rySq).
	scaleSq > 1 ifTrue: [
		scale _ scaleSq sqrt.
		newRx _ scale * rx.
		newRy _ scale * ry.
		(newRx = rx or: [ newRy = ry ]) ifTrue: [		"This happens when scaleSq is so close to 1, that the multiplication rounds to the same numbers"
			newRx _ scaleSq * rx.
			newRy _ scaleSq * ry ].
		^self basicArcToX: x2 y: y2 radiusX: newRx radiusY: newRy angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
		].
	bigSqRNumerator _ (rxSq * rySq) - (rxSq * y1pSq)-(rySq * x1pSq).
	bigSqRDenominator _ (rxSq * y1pSq) + (rySq * x1pSq).
	sign _ doLargerArc = useIncreasingAngles ifTrue: [ -1 ] ifFalse: [ 1 ].
	bigSqR _ (bigSqRNumerator / bigSqRDenominator max: 0.0) sqrt * sign.		"This only can be < 0.0 because of rounding errors. Take 0.0 in such cases."
	cxp _ bigSqR * rx * y1p / ry.
	cyp _ 0.0 - (bigSqR * ry * x1p / rx).

	"step 3"
	cx _ (cosPhi * cxp) - (sinPhi * cyp) + ((x1+x2) * 0.5).
	cy _ (sinPhi * cxp) + (cosPhi * cyp) + ((y1+y2) * 0.5).
	
"
| u v a |
Transcript clear.
u _ 1@4. v _ 7@2.
a _ ((u dotProduct: v) / (u r * v r) ) arcCos.
a _ a * (((u x * v y) - (u y * v x)) sign).
a print.
(v theta - u theta) print.
Ojo al primitivizar. Para ellos, el theta va entre -pi y pi. Para Squeak va entre cero y 2pi...
"

	"step 4"
	"Ojo signo del angulo y del eje y!!!!!!!!!!"
	theta1 _ (((x1p - cxp) / rx) @ ((y1p - cyp) / ry)) theta.
	theta2 _ (((0 - x1p - cxp) / rx) @ (( 0 -y1p - cyp) / ry)) theta.
	deltaTheta _ theta2 - theta1.
	useIncreasingAngles = (deltaTheta > 0) ifFalse: [
		deltaTheta > 0
			ifTrue: [ deltaTheta _ deltaTheta - Float pi - Float pi ]
			ifFalse: [ deltaTheta _ deltaTheta + Float pi + Float pi ]
		].
	"Y aca calcular como dar vuelta deltaTheta, ver."


	"Finalmente, estudiar la correccion de valores fuera de rango"
	

	self basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: phi start: theta1 sweep: deltaTheta! !

!VectorEngine01 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:01'!
basicClosePath
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			do_ClosePath ].
Display forceToScreen
"
	self basicLineToX: firstX y: firstY! !

!VectorEngine01 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:01'!
basicCubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	| dx dy hops increment t x0 y0 oneLessT f2 f3 f1 f23 f4 x y |

	dx _ (x1-currentX) abs + (x2-x1) abs + (x3-x2) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs + (y3-y2) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	"en muchos casos, secuencias de estos,  repetimos puntos, el ultimo de la curva anterior... pensar, etc"
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT * oneLessT.
		f23 _ 3 * oneLessT * t.
		f2 _ f23 * oneLessT.
		f3 _ f23 * t.
		f4 _ t * t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2) + (f4 * x3).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2) + (f4 * y3).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x3 y: y3.

	currentX _ x3.
	currentY _ y3.

	self updateMask! !

!VectorEngine01 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:01'!
basicHorizontalLineToX: x2
	| distanceToAxis |	

	maskBoundsTop _ (currentY - strokeWidthDilatedHalf) truncated +1.
	maskBoundsBottom _ (currentY + strokeWidthDilatedHalf) truncated.
	maskBoundsLeft _ (currentX min: x2) truncated +1.
	maskBoundsRight _ (currentX max: x2) truncated.
	maskBoundsTop < clipTop ifTrue: [ maskBoundsTop _ clipTop ].
	maskBoundsBottom > clipBottom ifTrue: [ maskBoundsBottom _ clipBottom ].
	maskBoundsLeft< clipLeft ifTrue: [ maskBoundsLeft _ clipLeft ].
	maskBoundsRight > clipRight ifTrue: [ maskBoundsRight _ clipRight ].

	"Paralelizar en displayX@displayY"
	maskBoundsTop to: maskBoundsBottom do: [ :displayY |
		distanceToAxis _ (displayY - currentY) abs.
		maskBoundsLeft to: maskBoundsRight do: [ :displayX |
			self updateMaskForYDistanceToAxis: distanceToAxis displayX: displayX displayY: displayY ]].

	"Include updated mask in area to blend."
	blendBoundsTop _ blendBoundsTop min: maskBoundsTop.
	blendBoundsBottom _ blendBoundsBottom max: maskBoundsBottom.
	blendBoundsLeft _ blendBoundsLeft min: maskBoundsLeft.
	blendBoundsRight _ blendBoundsRight max: maskBoundsRight.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."! !

!VectorEngine01 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:01'!
basicLineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 300 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 25.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 500 y: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 30 y: 15.
		engine abs_LineToX: 45 y: 90.
		engine abs_LineToX: 180 y: 30 ].
Display forceToScreen
"
	| dx dy hops incrementX incrementY x y |
	dy _ y2 - currentY.
	dx _ x2 - currentX.
	dx * dy = 0.0
		ifTrue: [
			self addPenPositionX: currentX y: currentY.
			self updateMask.
			dy = 0.0  	"or else it means dx = 0.0"
				ifTrue: [ self basicHorizontalLineToX: x2 ]
				ifFalse: [ self basicVerticalLineToY: y2 ]]
		ifFalse: [
			maskBoundsTop _ maskBoundsTop min: currentY.
			maskBoundsBottom _ maskBoundsBottom max: currentY.
			maskBoundsLeft _ maskBoundsLeft min: currentX.
			maskBoundsRight _ maskBoundsRight max: currentX.
			x _ currentX.
			y _ currentY.
			hops _ ((dx abs max: dy abs) * hopsPerPixel) truncated + 1.
			incrementX _ dx *1.0 / hops.
			incrementY _ dy *1.0 / hops.
			doFill
				ifTrue: [
					hops timesRepeat: [
						trajectoryPoints add: x@y.
						self updateEdgeCountAtX: x y: y.
						x _ x + incrementX.
						y _ y + incrementY ]]
				ifFalse: [
					hops timesRepeat: [
						trajectoryPoints add: x@y.
						x _ x + incrementX.
						y _ y + incrementY ]]
		].
	currentX _ x2.
	currentY _ y2.
	self addPenPositionX: currentX y: currentY.
	self updateMask! !

!VectorEngine01 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:01'!
basicMoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150;
			abs_MoveToX: 210 y: 150;
			abs_LineToX: 300 y: 200 ].
Display forceToScreen
"

	"A discontinuity in the trajectory"

	"We are starting a new trajectory, or at a discontinuity in trajectory.
	Eventually #closeTrajectory should draw a line to here"

	"Next point will be first in a new trajectory fragment"
	prevYTruncated _ nil.
	firstX _ x.
	firstY _ y.
	currentX _ x.
	currentY _ y.! !

!VectorEngine01 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:01'!
basicQuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| dx dy hops increment t x0 y0 oneLessT f1 f3 f2 x y |
	dx _ (x1-currentX) abs + (x2-x1) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT.
		f2 _ 2* oneLessT * t.
		f3 _ t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x2 y: y2.

	currentX _ x2.
	currentY _ y2.

	self updateMask! !

!VectorEngine01 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:01'!
basicVerticalLineToY: y2
	| distanceToAxisB distanceToAxisG distanceToAxisR |	

	doFill ifTrue: [
		currentY to: y2 by: (y2-currentY) sign do: [ :y |
			self updateEdgeCountAtX: currentX y: y ]].

	maskBoundsTop _ (currentY min: y2) truncated +1.
	maskBoundsBottom _ (currentY max: y2) truncated.
	maskBoundsLeft _ (currentX - strokeWidthDilatedHalf - subPixelDelta) truncated +1.
	maskBoundsRight _ (currentX + strokeWidthDilatedHalf + subPixelDelta) truncated.
	maskBoundsTop < clipTop ifTrue: [ maskBoundsTop _ clipTop ].
	maskBoundsBottom > clipBottom ifTrue: [ maskBoundsBottom _ clipBottom ].
	maskBoundsLeft< clipLeft ifTrue: [ maskBoundsLeft _ clipLeft ].
	maskBoundsRight > clipRight ifTrue: [ maskBoundsRight _ clipRight ].

	"Paralelizar en displayX@displayY"
	maskBoundsLeft to: maskBoundsRight do: [ :displayX |
		distanceToAxisR _ (displayX - subPixelDelta - currentX) abs.
		distanceToAxisG _ (displayX - currentX) abs.
		distanceToAxisB _ (displayX + subPixelDelta - currentX) abs.
		maskBoundsTop to: maskBoundsBottom do: [ :displayY |
			self updateMaskForXDistanceToAxis: distanceToAxisR g: distanceToAxisG b: distanceToAxisB displayX: displayX displayY: displayY ]].

	"Include updated mask in area to blend."
	blendBoundsTop _ blendBoundsTop min: maskBoundsTop.
	blendBoundsBottom _ blendBoundsBottom max: maskBoundsBottom.
	blendBoundsLeft _ blendBoundsLeft min: maskBoundsLeft.
	blendBoundsRight _ blendBoundsRight max: maskBoundsRight.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."! !

!VectorEngine01 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:01'!
blendFillOnly

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.

			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendFillOnlyAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine01 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:01'!
blendFillOnlyAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends fill over background. Despite method selector, there might be a very thin stroke of the same color as the fill. Handle this by adjusting antiAliasAlphas.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	"In this method, antiAliasAlphas are not used to blend stroke, but fill. This means that in the inside of the shape, and away from the stroke, they must be 1.0 (not 0.0)."
	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	isRedInside ifTrue: [ antiAliasRedAlpha _ 1.0 - antiAliasRedAlpha ].
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	isGreenInside ifTrue: [ antiAliasGreenAlpha _ 1.0 - antiAliasGreenAlpha ].
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	isBlueInside ifTrue: [ antiAliasBlueAlpha _ 1.0 - antiAliasBlueAlpha ].
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * fillAlphaToUse.
	resultR _ alpha * fillRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * fillAlphaToUse.
	resultG _ alpha * fillGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * fillAlphaToUse.
	resultB _ alpha * fillBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine01 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:01'!
blendStrokeAndFill

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.
			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendStrokeAndFillAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine01 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:01'!
blendStrokeAndFillAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Do an appropriate (anti aliased) mix between stoke and fill (or pick just stroke or just fill). Blend this over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha foreComponent strokeAlphaToUse fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	isRedInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse.
			foreComponent _ strokeRed ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse + ((1-antiAliasRedAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasRedAlpha * strokeRed + ((1-antiAliasRedAlpha) * fillRed) ].
	resultR _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	isGreenInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
			foreComponent _ strokeGreen ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse + ((1-antiAliasGreenAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasGreenAlpha * strokeGreen + ((1-antiAliasGreenAlpha) * fillGreen) ].
	resultG _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	isBlueInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
			foreComponent _ strokeBlue ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse + ((1-antiAliasBlueAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasBlueAlpha * strokeBlue + ((1-antiAliasBlueAlpha) * fillBlue) ].
	resultB _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine01 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:01'!
blendStrokeOnly

	| pixelIndex m |
	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.
				(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
					self blendStrokeOnlyAtX: displayX y: displayY pixelIndex: pixelIndex ]]].

	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine01 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:01'!
blendStrokeOnlyAtX: x y: y pixelIndex: pixelIndex

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends stroke over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha strokeAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		^self].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.

	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * strokeAlphaToUse.
	resultR _ alpha * strokeRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
	resultG _ alpha * strokeGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
	resultB _ alpha * strokeBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine01 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:01'!
experLinesAndShapes
	"
	self experLinesAndShapes
	"
	| engine y1 yy2 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		yy2 _ y2 >= 1 ifTrue: [ VectorEngine defaultAntiAliasingWidth * 0.5 ] ifFalse: [0].
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1+yy2; abs_LineToX: 530 y: y1+yy2+dy;
				abs_LineToX: 530 y: y1+y2-yy2+dy; abs_LineToX: 431 y: y1+y2-yy2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1+yy2 y: 431; abs_LineToX: y1+yy2+dy y: 530;
				abs_LineToX: y1+y2-yy2+dy y: 530; abs_LineToX: y1+y2-yy2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill."
		engine fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		"solo stroke, no fill"
		engine strokeWidth: y2 color: Color black do: [
			engine
				abs_MoveToX: y2*0.5+731 y: y2*0.5 + y1+dy+dy+dy; abs_LineToX: 830 y: y2 * 0.5 + y1  + dy + dy+dy+dy.
			engine
				abs_MoveToX: y2*0.5 + y1+dy+dy+dy y: y2*0.5+731; abs_LineToX: y2 * 0.5 + y1  + dy + dy+dy+dy y: 830 ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine01 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:01'!
experLinesAndShapes2
	"
	self experLinesAndShapes2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth*4*2.
	15 timesRepeat: [
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 1.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 131 y: y1; abs_LineToX: 230 y: y1+dy;
				abs_LineToX: 230 y: y1+y2+dy; abs_LineToX: 131 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX: y1 y: 131; abs_LineToX: y1+dy y: 230;
				abs_LineToX: y1+y2+dy y: 230; abs_LineToX: y1+y2 y: 131;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.8 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 231 y: y1+dy; abs_LineToX: 330 y: y1+dy+dy;
				abs_LineToX: 330 y: y1+y2+dy+dy; abs_LineToX: 231 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 231; abs_LineToX: y1+dy+dy y: 330;
				abs_LineToX: y1+y2+dy+dy y: 330; abs_LineToX: y1+y2+dy y: 231;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.6 color: Color green fillColor: Color red do: [.
			engine
				abs_MoveToX: 331 y: y1+dy+dy; abs_LineToX: 430 y: y1+dy+dy+dy;
				abs_LineToX: 430 y: y1+y2+dy+dy+dy; abs_LineToX: 331 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 331; abs_LineToX: y1+dy+dy+dy y: 430;
				abs_LineToX: y1+y2+dy+dy+dy y: 430; abs_LineToX: y1+y2+dy+dy y: 331;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.4 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 431 y: y1+dy+dy+dy; abs_LineToX: 530 y: y1+dy+dy+dy+dy;
				abs_LineToX: 530 y: y1+y2+dy+dy+dy+dy; abs_LineToX: 431 y: y1+y2+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy+dy y: 431;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.2 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 531 y: y1+dy+dy+dy+dy; abs_LineToX: 630 y: y1+dy+dy+dy+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy+dy+dy+dy; abs_LineToX: 531 y: y1+y2+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy y: 531; abs_LineToX: y1+dy+dy+dy+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 630; abs_LineToX: y1+y2+dy+dy+dy+dy y: 531;
				do_ClosePath ].
		"Solo fill. w chico. Preferimos ya usarlo para definir mejor el shape (se transparentaria demasiado)"
		engine strokeWidth: 0.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy+dy+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 print.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine01 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:01'!
experLinesAndShapes3
	"
	self experLinesAndShapes3
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.4 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine01 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:01'!
experLinesAndShapes4
	"
	self experLinesAndShapes4
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*1.5 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine01 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:01'!
experLinesAndShapesx
	"
	self experLinesAndShapesx
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		y2 print.
		"Solo fill. w =0"
		engine strokeWidth: 0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy y: 431;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.! !

!VectorEngine01 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:01'!
experLinesAndShapesx2
	"
	self experLinesAndShapesx2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	y1 _ 10.
	dy _ 3.
	y2 _ 0.1.
	y2 print.
	"Solo fill. w =0"
	engine strokeWidth: 0.5 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 10 y: y1+dy+dy; abs_LineToX: 200 y: y1+dy+dy+dy;
			abs_LineToX: 200 y: y1+y2+dy+dy+dy; abs_LineToX: 10 y: y1+y2+dy+dy;
			do_ClosePath.
		engine
			abs_MoveToX: y1+dy+dy y: 10; abs_LineToX: y1+dy+dy+dy y: 200;
			abs_LineToX: y1+y2+dy+dy+dy y: 200; abs_LineToX: y1+y2+dy+dy y: 10;
			do_ClosePath ].
	Display forceToScreen.
! !

!VectorEngine01 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:02'!
experimentHopsPerPixel1
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 1: Very thin stroke, the same color as fill
	VectorEngine experimentHopsPerPixel1
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) *10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine01 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:02'!
experimentHopsPerPixel2
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 2: Stroke of various widths, no fill
	VectorEngine experimentHopsPerPixel2
	"
	| d engine f1 f2 hops1 hops2 strokeWidth |
	hops1 _ 200.
	hops1 _ 20.
	"
	strokeWidth -> hops2
	1.3 -> 8
	1.5 -> 6
	2 -> 4
	4 -> 3
	6 -> 2
	16 -> 1
	Maybe 10 / strokeWidth + 1 is ok?
	"
	strokeWidth _ 16*2.
	hops2 _ 8*0+1.
	hops2 _ 10.0 / strokeWidth + 1.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f2 displayAt: 220@0.

Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine01 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:02'!
experimentHopsPerPixel3
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 3: No stroke, just fill
	VectorEngine experimentHopsPerPixel3
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine01 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:10:02'!
experiment1
	"
	No perfecto aun, pero se puede empezar a comparar con
	http://www.hpl.hp.com/research/mmsl/projects/graphics/antialiasing/figure21.htm
	Ni que hablar que es mucho mas rapido...
	self experiment1
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 e f |
engine _ self onForm: Display.
h _ 300.
h _ 490.
h _ 280.
bottom _ 200.
bottom _ 0.
centerX _ 400.
centerX _ 250.
w0 _ 120.0.
hf _ 1.0.
hf _ 1.73.
hf _ 1.71.
y _ nil.
delta _ nil.
	e _ 500@500.
	f _ Form extent: e depth: 32.
	f fillColor: Color transparent..
"	canvas _  self on: f.
	canvas useComponentAlphas."
1 to: "400" 150 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-3 // delta to: 3 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color black ] ifFalse: [ Color white ].
"			color _ color alpha: (((prevY-y) min: (x1-x2)) min: 1)."
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
"
	canvas removeSpuriousTranslucencyFloatAndBlendOver: Color red.
	f writePNGfileNamed: 'pp17.png'
"! !

!VectorEngine01 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:10:02'!
experiment2
	"
	self experiment2
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 |
engine _ self onForm: Display.
h _ 300.
h _ 600.
bottom _ 200.
centerX _ 400.
w0 _ 60.0.
hf _ 1.0.
y _ nil.
delta _ nil.
1 to: 400 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-6 // delta to: 6 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color white ] ifFalse: [ Color black ].
			color _ color alpha: (((prevY-y) min: (x1-x2)) "* 0.3" min: 1).
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
! !

!VectorEngine01 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:10:02'!
experiment3
	"
	self experiment3
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	100 timesRepeat: [
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
		r _ r + w.
		w _ w * 0.8.
		r _ r + w.

	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine01 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:10:02'!
experiment4
	"
	self experiment4
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	1 to: 100 do: [ :i |
		r _ r + w.
		w _ 20.0 / i.
		r _ r + w.
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine01 class methodsFor: 'samples' stamp: 'jmv 2/20/2020 12:29:47'!
siemensStar
	"
	self siemensStar display
	"
	| angle backColor canvas count extent foreColor form location offsetFromCenter |
	count _ 32.
	angle _ Float twoPi / count / 2.
	extent _ 512.
	offsetFromCenter _ 0.
	backColor _ `Color gray: 50/255`.
	foreColor _ `Color gray: 200/255`.
	form _ Form extent: extent asPoint depth: 32.
	form fillColor: backColor.
	canvas _ VectorCanvas onForm: form.
	1 to: count do: [ :i |
		location _ AffineTransformation withRadians: i * angle * 2+0.02 scale: extent*0.45 position: extent-1/2.0 + offsetFromCenter.
		canvas engine geometryTransformation: location.
		canvas fillColor: foreColor do: [
			canvas
				moveToX: 0 y: 0;
				lineToX: 1 y: 0;
				lineToX: angle cos y: angle sin;
				lineToX: 0 y: 0.
		].
	].
	^form! !

!VectorEngine01 class methodsFor: 'instance creation' stamp: 'jmv 2/9/2020 10:10:02'!
onForm: aForm

	^ self new setForm: aForm! !

!VectorEngine01 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:02'!
antiAliasingWidthForOutlineFonts
	^1.4! !

!VectorEngine01 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:02'!
antiAliasingWidthForStrokeFonts
	^1.1! !

!VectorEngine01 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:02'!
defaultAntiAliasingWidth
	^1.3. "default for graphics"! !

!VectorEngine02 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:13'!
antiAliasingWidth: aNumber

	antiAliasingWidth _ aNumber.
	antiAliasingWidthScaledInverse _ 127.0 / antiAliasingWidth! !

!VectorEngine02 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:13'!
clipRect: aRectangle 
	"by convention, aRectangle includes left and top but does not include right and bottom.
	We do draw clipRight and clipBottom but not beyond.
	"
	"In targetForm coordinates"
	clipLeft _ aRectangle left.
	clipTop _ aRectangle top.
	clipRight _ aRectangle right - 1.
	clipBottom _ aRectangle bottom - 1! !

!VectorEngine02 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:13'!
clippingRectForCurrentMorph
	"In targetForm coordinates.
	Only valid _after_ drawing currentMorph."

	^morphBoundsLeft @ morphBoundsTop corner: morphBoundsRight @ morphBoundsBottom! !

!VectorEngine02 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:13'!
currentMorph: aMorph
	currentMorph _ aMorph! !

!VectorEngine02 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:13'!
currentOwnerIfClips: currentMorphOwnerOrNil
	currentOwnerIfClips _ currentMorphOwnerOrNil! !

!VectorEngine02 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:13'!
geometryTransformation
	^geometryTransformation! !

!VectorEngine02 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:13'!
geometryTransformation: aGeometryTransformation
	geometryTransformation _ aGeometryTransformation! !

!VectorEngine02 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 10:10:13'!
fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	doStroke _ false.
	doFill _ true.
	self pvtStrokeWidth: 0.0.
	hopsPerPixel _ 8.										"See #experimentHopsPerPixel3"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ nil. strokeRed _ nil. strokeGreen _ nil. strokeBlue _ nil.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine02 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 10:10:13'!
strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke."

	| strokeAlphaFactor aStrokeWidth |
	doStroke _ true.
	doFill _ false.
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.

	"Strokes we want to show. They are not too thin, or maybe they are, but there's no fill. Make them wide enough to be properly sampled."
	self pvtStrokeWidth: (aStrokeWidth max: antiAliasingWidth).
	strokeAlphaFactor _ aStrokeWidth / strokeWidth.
	hopsPerPixel _ 10.0 / strokeWidth + 1.		"See #experimentHopsPerPixel2"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ nil. fillRed _ nil. fillGreen _ nil. fillBlue _ nil.
	strokeAlpha _ (aStrokeColor alpha * 255.0 * strokeAlphaFactor) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine02 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 10:10:13'!
strokeWidth: clientStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	| aStrokeWidth |

	aStrokeColor ifNil: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	clientStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aFillColor ifNil: [ ^ self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock.
		^ self ].

	doStroke _ true.
	doFill _ true.
	self pvtStrokeWidth: aStrokeWidth.
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"Strokes are really thin, but strokeColor is same as fillColor, so there's no problem sampling them."
			hopsPerPixel _ 8 ]								"See #experimentHopsPerPixel1"
		ifFalse: [
			hopsPerPixel _ 10.0 / strokeWidth + 1 max: 2 ].		"See #experimentHopsPerPixel2. Additionally, fills require at least 2."

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ (aStrokeColor alpha * 255.0) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.2 position: 200@100);
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcToX: center x y: center y radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_CircleCenterX: cx y: cy radius: mr
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_CircleCenterX: 200 y: 150 radius: 80].
Display forceToScreen
"

	| center r |
	center _ geometryTransformation externalizePosition: cx@cy.
	r _ geometryTransformation externalizeScalar: mr.
	self
		basicArcCenterX: center x centerY: center y radiusX: r radiusY: r rotationAngle: 0.0 start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 150 y: 300 radius: 10.
		engine abs_CircleCenterX: 600 y: 400 radius: 6.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 600 y: -200 radius: 10.
		engine abs_CircleCenterX: 100 y: -100 radius: 6.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_CubicBezierToX: 300 y: 100 control1X: 600 y: -200 control2X: 100 y: -100
			].
Display forceToScreen.
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 100 control2X: 100 y: -100
			].
Display forceToScreen
	"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_CubicBezierToX: x3 y: y3 control1X: mirroredContolX y: mirroredContolY control2X: x2 y: y2! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"
	| p1 p2 p3 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	p3 _ geometryTransformation externalizePosition: x3@y3.
	self basicCubicBezierToX: p3 x y: p3 y control1X: p1 x y: p1 y control2X: p2 x y: p2 y.
	lastClientX _ x3.
	lastClientY _ y3.
	lastControlX _ x2.
	lastControlY _ y2! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta start: startAngle sweep: sweepAngle
	"Currently draws a line from currentX@currentY to start (if startAngle ~= 0.0 or sweepAngle ~= Float twoPi).
	This could be useful for proper fills. But might not be what is desired in some cases.
	Implement desired behavior when clear."
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.0 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6].
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 350 radiusX: 100 radiusY: 50 rotationAngle: 0.5 start: 0.1 sweep: 6 ].
Display forceToScreen.
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: startAngle sweep:  sweepAngle! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_LineToX: x2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: x2 y: lastClientY! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p2 |
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicLineToX: p2 x y: p2 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_LineToY: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToY: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToY: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX y: y2! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p |
	p _ geometryTransformation externalizePosition: x@y.
	self basicMoveToX: p x y: p y.
	lastClientX _ x.
	lastClientY _ y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 450 y: 300 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 750 y: -100 radius: 10.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_QuadraticBezierToX: 300 y: 100 controlX: 750 y: -100
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			abs_QuadraticBezierSmoothToX: 300 y: 100
			].
Display forceToScreen
"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_QuadraticBezierToX: x2 y: y2 controlX: mirroredContolX y: mirroredContolY! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
abs_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| p1 p2 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicQuadraticBezierToX: p2 x y: p2 y controlX: p1 x y: p1 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ x1.
	lastControlY _ y1! !

!VectorEngine02 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
do_ClosePath
	"abs/rel meaningless here"
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200;
			abs_CubicBezierToX: 300 y: 120 control1X: 310 y: 110 control2X: 200 y: 200;
			do_ClosePath;
			abs_LineToX: 150 y: 300 ].
Display forceToScreen
"
	| p2 |
	self basicClosePath.

	p2 _ geometryTransformation internalizePosition: currentX@currentY.
	lastClientX _ p2 x.
	lastClientY _ p2 y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine02 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
rel_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			rel_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false;
			do_ClosePath ].
"
	self abs_ArcToX: lastClientX + cx y: lastClientY + cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine02 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
rel_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierToX: 300 y: 300 control1X: 0 y: 0 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierSmoothToX: 600 y: 100 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"

	self
		abs_CubicBezierSmoothToX: lastClientX + x3 y: lastClientY + y3
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine02 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
rel_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ];
	strokeWidth: 1.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ];
	strokeWidth: 10 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	self
		abs_CubicBezierToX: lastClientX + x3 y: lastClientY + y3
		control1X: lastClientX + x1 y: lastClientY + y1
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine02 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
rel_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine02 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
rel_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_MoveToX: lastClientX + x y: lastClientY + y! !

!VectorEngine02 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
rel_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 550 y: 350 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 850 y: -50 radius: 10.
		engine abs_MoveToX: 700 y: 150.
		engine
			rel_QuadraticBezierToX: -300 y: -50 controlX: 150 y: -200
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			rel_QuadraticBezierSmoothToX: -300 y: -50
			].
Display forceToScreen
"
	self
		abs_QuadraticBezierSmoothToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine02 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:10:13'!
rel_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ];
	strokeWidth: 3.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ];
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color green alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	self
		abs_QuadraticBezierToX: lastClientX + x2 y: lastClientY + y2
		controlX: lastClientX + x1 y: lastClientY + y1! !

!VectorEngine02 methodsFor: 'text' stamp: 'jmv 2/9/2020 10:10:13'!
displayString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aFont color: aColor canvas: aCanvas
	"geometryTransformation is already set to honor font pointSize
	Use as little of aFont as possible!!"
	| glyph destX destY loc |

	self antiAliasingWidth: VectorEngine antiAliasingWidthForOutlineFonts.
	loc _ geometryTransformation.
	self fillColor: aColor do: [
		destY _ aPoint y.
		destX _ aPoint x.
		startIndex to: stopIndex do: [ :charIndex |
			glyph _ aFont ttGlyphAt: (aString at: charIndex).
			glyph isComposite
				ifFalse: [
					glyph contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ].
					]]
				ifTrue: [
					glyph txAndContoursDo: [ :tx :contours |contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ (loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated) composedWith: tx.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ]]]
					].
			destX _ destX + glyph advanceWidth.
		]
	].
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:13'!
addPenPositionX: x y: y

"
Inlinear en senders. Extraer afectar bounds si es posible (linea, circulo)
"

	trajectoryPoints add: x@y.

	maskBoundsTop _ maskBoundsTop min: y.
	maskBoundsBottom _ maskBoundsBottom max: y.
	maskBoundsLeft _ maskBoundsLeft min: x.
	maskBoundsRight _ maskBoundsRight max: x.

	"Compute edges intersecting with this horizontal line, for fills."
	doFill ifTrue: [
		self updateEdgeCountAtX: x y: y ].! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:14'!
finishPath
	"Blend stroke and/or fill over background, according to the just computed pen alphas (distance from pixel to center of stroke)"
	
	"If we are doing a fill, and caller forgot to close the trajectory, then do it anyway."
	doFill ifTrue: [
		(firstX = currentX and: [ firstY = currentY ]) ifFalse: [
			"This is actually an error condition. If we are asked to fill, then the path should be closed.
			This is a workaround. If width > 0.0, we'll be adding a visible edge to the path."
			self basicClosePath ]].

	doFill ifTrue: [
		doStroke
			ifTrue: [ self blendStrokeAndFill ]
			ifFalse: [ self blendFillOnly ]]
		ifFalse: [
		self blendStrokeOnly ].
	morphBoundsTop _ morphBoundsTop min: blendBoundsTop.
	morphBoundsBottom _ morphBoundsBottom max: blendBoundsBottom.
	morphBoundsLeft _ morphBoundsLeft min: blendBoundsLeft.
	morphBoundsRight _ morphBoundsRight max: blendBoundsRight.

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.

	Display forceToScreen! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:14'!
initialize
	geometryTransformation _ MorphicTranslation new. "Identity"! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:14'!
initializePath

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.
	trajectoryPoints _ OrderedCollection new.
	prevYTruncated _ nil.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."

	blendBoundsTop _ targetHeight.			"drawable bottom. Will later be refined."
	blendBoundsBottom _ 0.						"drawable top. Will later be refined."
	blendBoundsLeft _ targetWidth.			"drawable right. Will later be refined."
	blendBoundsRight _ 0.						"drawable left. Will later be refined."! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:14'!
pvtStrokeWidth: aNumber
	strokeWidth _ aNumber.
	strokeWidthDilatedHalf _ strokeWidth + antiAliasingWidth * 0.5.
	strokeWidthDilatedHalfSquared _ strokeWidthDilatedHalf * strokeWidthDilatedHalf.
	strokeWidthErodedHalf _ strokeWidth - antiAliasingWidth * 0.5.
	strokeWidthErodedHalfSquared _ strokeWidthErodedHalf * strokeWidthErodedHalf * strokeWidthErodedHalf sign! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:14'!
resetMorphBounds

	morphBoundsTop _ targetHeight - 1.
	morphBoundsBottom _ 0.
	morphBoundsLeft _ targetWidth - 1.
	morphBoundsRight _ 0! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:14'!
setForm: aForm
	"
	World extent: World extent
	"
	| hack s |
	targetForm _ aForm.
	targetWidth _ aForm width.
	targetHeight _ aForm height.
	self resetMorphBounds.
	self clipRect: (0@0 corner: targetWidth@targetHeight).
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth.
	subPixelDelta _ 0.25. "Values closer to 0.333 might produce a bit of coloring on some displays. Used to be 0.28"
	s _ aForm bits size.
	(mask isNil or: [ mask size ~= s ])
		ifTrue: [
			mask _ WordArray new: s.
			edgeCountPerPixel _ WordArray new: s.
			morphAtPixel _ Array new: s.
			hack _ Form extent: targetWidth@targetHeight depth: 32 bits: mask.
			auxBitBlt _ BitBlt toForm: hack.
			auxBitBlt fillBitmap: (Bitmap with: 16rFF000000).
			auxBitBlt combinationRule: Form over ].

	"Perhaps this should be done in an ifCurtailed: block in case of Morphic drawing failure..."
	auxBitBlt destRect: targetForm boundingBox.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	morphAtPixel atAllPut: 0! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:14'!
updateEdgeCountAtX: x y: y
	| thisYTruncated pixelY pixelIndexBase redPixelIndex greenPixelIndex bluePixelIndex increment countWord redCount greenCount blueCount redOffset greenOffest blueOffset |

	thisYTruncated _ (y truncated max: clipTop-1) min: clipBottom-1.
	prevYTruncated ifNil: [ 
		^ prevYTruncated _ thisYTruncated ].
	thisYTruncated = prevYTruncated ifTrue: [
		^ prevYTruncated _ thisYTruncated ].

	thisYTruncated > prevYTruncated
		ifTrue: [
			pixelY _ thisYTruncated.
			increment _ 1 ]
		ifFalse: [
			pixelY _ prevYTruncated.
			increment _ -1 ].

	"All edge count at the left of the clipRect are added there (at the left of the clipRect).
	The effect is the same, and we need to clean up less stuff afterwards.
	More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses."
	pixelIndexBase _ pixelY * targetWidth + 1.
	redOffset _ (x+subPixelDelta) truncated + 1 max: clipLeft.
	greenOffest _ x truncated + 1 max: clipLeft.
	blueOffset _ (x-subPixelDelta) truncated + 1 max: clipLeft.
	redPixelIndex _ pixelIndexBase + redOffset.
	greenPixelIndex _ pixelIndexBase + greenOffest.
	bluePixelIndex _ pixelIndexBase + blueOffset.

	"Three possible cases here: RGB in one word (pixel); RG in one, and G in another; R in one, GB in another"
	redPixelIndex = bluePixelIndex
		ifTrue: [						"First case: RGB in the same word"
			redOffset <= clipRight ifTrue: [
				countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
				redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
				countWord at: 3 put: redCount.
				greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
				countWord at: 2 put: greenCount.
				blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
				countWord at: 1 put: blueCount.
				edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].
		]
		ifFalse: [
			redPixelIndex = greenPixelIndex
				ifTrue: [				"Second case: RG in one word, B in following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
				ifFalse: [			"Third case: R in one word, GB in the following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
		].
	prevYTruncated _ thisYTruncated! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:14:42'!
updateMask
	"Apdate alpha (transparency) mask using trajectoryPoints."

	maskBoundsTop _ (maskBoundsTop - strokeWidthDilatedHalf) truncated +1.
	maskBoundsBottom _ (maskBoundsBottom + strokeWidthDilatedHalf) truncated.
	maskBoundsLeft _ (maskBoundsLeft - strokeWidthDilatedHalf - subPixelDelta) truncated +1.
	maskBoundsRight _ (maskBoundsRight + strokeWidthDilatedHalf + subPixelDelta) truncated.
	maskBoundsTop < clipTop ifTrue: [ maskBoundsTop _ clipTop ].
	maskBoundsBottom > clipBottom ifTrue: [ maskBoundsBottom _ clipBottom ].
	maskBoundsLeft< clipLeft ifTrue: [ maskBoundsLeft _ clipLeft ].
	maskBoundsRight > clipRight ifTrue: [ maskBoundsRight _ clipRight ].

	"Paralelizar en displayX@displayY"
	"Intento de paralelizar en absolutamente todos los pixels. una guarangada"
	maskBoundsTop to: maskBoundsBottom do: [ :displayY |
		maskBoundsLeft to: maskBoundsRight do: [ :displayX |
			self updateMaskAtdisplayX: displayX displayY: displayY ]].
	trajectoryPoints _ OrderedCollection new.

	"Include updated mask in area to blend."
	blendBoundsTop _ blendBoundsTop min: maskBoundsTop.
	blendBoundsBottom _ blendBoundsBottom max: maskBoundsBottom.
	blendBoundsLeft _ blendBoundsLeft min: maskBoundsLeft.
	blendBoundsRight _ blendBoundsRight max: maskBoundsRight.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:14'!
updateMaskAtdisplayX: displayX displayY: displayY

	"slight optimization possible when we doStroke = false ... perhaps implement:
		-we know palpha is never 127
		- we know distanceToEdge is always > strokeWidthErodedHalf.
	In smalltalk, performance icrease 1.5%. Perhaps in c/asm it is more than that...
	
	Use a separated method to be called when only fill
	"

	| distanceToAxisSquared alpha alphaWord dySquared dx dxSquared dy pixelIndex dxp blueAlpha greenAlpha redAlpha previousBlueAlpha previousGreenAlpha previousRedAlpha |

	pixelIndex _ displayY * targetWidth +  displayX.
	pixelIndex _ pixelIndex + 1.
	alphaWord _ mask bytesAt: pixelIndex.
	alphaWord = "16rFF7F7F7F" #[16r7F 16r7F 16r7F 16rFF] ifFalse: [

		redAlpha _ alphaWord at: 3.
		greenAlpha _ alphaWord at: 2.
		blueAlpha _ alphaWord at: 1.
		
		previousRedAlpha _ redAlpha.
		previousGreenAlpha _ greenAlpha.
		previousBlueAlpha _ blueAlpha.

		trajectoryPoints do: [ :p |
			dy _ displayY - p y.
			dySquared _ dy * dy.
			dx _ displayX - p x.
			"Red"
			dxp _ dx - subPixelDelta.
			dxSquared _ dxp * dxp.
			distanceToAxisSquared _ dxSquared + dySquared.
			distanceToAxisSquared < strokeWidthDilatedHalfSquared
				ifTrue: [
					alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
						ifTrue: [ 16r7F ]
						ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
					alpha > redAlpha ifTrue: [
						redAlpha _ alpha ]].
			"Green"
			dxSquared _ dx * dx.
			distanceToAxisSquared _ dxSquared + dySquared.
			distanceToAxisSquared < strokeWidthDilatedHalfSquared
				ifTrue: [
					alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
						ifTrue: [ 16r7F ]
						ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
					alpha > greenAlpha ifTrue: [
						greenAlpha _ alpha ]].
			"Blue"
			dxp _ dx + subPixelDelta.
			dxSquared _ dxp * dxp.
			distanceToAxisSquared _ dxSquared + dySquared.
			distanceToAxisSquared < strokeWidthDilatedHalfSquared
				ifTrue: [
					alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
						ifTrue: [ 16r7F ]
						ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
					alpha > blueAlpha ifTrue: [
						blueAlpha _ alpha ]].	
		].

		(previousRedAlpha ~= redAlpha or: [
		previousGreenAlpha ~= greenAlpha or: [
		previousBlueAlpha ~= blueAlpha ]]) ifTrue: [
			alphaWord at: 3 put: redAlpha.
			alphaWord at: 2 put: greenAlpha.
			alphaWord at: 1 put: blueAlpha.
			mask bytesAt: pixelIndex put: alphaWord ]
	]! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:14'!
updateMaskForXDistanceToAxis: distanceToAxisR g: distanceToAxisG b: distanceToAxisB displayX: displayX displayY: displayY
	| alpha alphaWord pixelIndex |

	pixelIndex _ displayY * targetWidth +  displayX.
	pixelIndex _ pixelIndex + 1.
	alphaWord _ mask bytesAt: pixelIndex.

	"Red"
	distanceToAxisR < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxisR <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisR * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 3) ifTrue: [
				alphaWord at: 3 put: alpha ]].
	"Green"
	distanceToAxisG < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxisG <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisG * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 2) ifTrue: [
				alphaWord at: 2 put: alpha ]].
	"Blue"
	distanceToAxisB < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxisB <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisB * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 1) ifTrue: [
				alphaWord at: 1 put: alpha ]].
	mask bytesAt: pixelIndex put: alphaWord! !

!VectorEngine02 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:10:14'!
updateMaskForYDistanceToAxis: distanceToAxis displayX: displayX displayY: displayY
	| alpha alphaWord pixelIndex |

	pixelIndex _ displayY * targetWidth +  displayX.
	pixelIndex _ pixelIndex + 1.
	alphaWord _ mask bytesAt: pixelIndex.
	distanceToAxis < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxis <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxis * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 3) ifTrue: [
				alphaWord at: 3 put: alpha ].
			alpha > (alphaWord at: 2) ifTrue: [
				alphaWord at: 2 put: alpha ].
			alpha > (alphaWord at: 1) ifTrue: [
				alphaWord at: 1 put: alpha ].
			mask bytesAt: pixelIndex put: alphaWord ]! !

!VectorEngine02 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:14'!
basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: theta start: startAngle sweep: sweepAngle
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black fillColor: Color red do: [ :engine |
		engine basicArcCenterX: 100 centerY: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.
"
	| d hops angle thetaCos thetaSin xp yp x0 y0 x y |
	
	"Por supuesto probar tambien rx no igual a ry, y uno (o ambos) menor que el ancho de trazo..."
	thetaCos _ theta cos.
	thetaSin _ theta sin.
	angle _ startAngle.
	xp _ angle cos * rx.
	yp _ angle sin * ry.
	x0 _ thetaCos * xp - (thetaSin * yp) + cx.
	y0 _ thetaSin * xp + (thetaCos * yp) + cy.
	(startAngle ~= 0.0 or: [ sweepAngle ~= Float twoPi ])
		ifTrue: [ self basicLineToX: x0 y: y0 ]	"Draw a line. There are cases where we want to join an arc. For example, window frames"
		ifFalse: [
			"trajectory starts here. Eventually, #closePath should draw a line to here"
			"Next point will be first in a new trajectory fragment"
			prevYTruncated _ nil.
			firstX _ x0.
			firstY _ y0.
			self addPenPositionX: x0 y: y0 ].
	hops _ ((rx+ry * 4 * sweepAngle abs / (2*Float pi)) * hopsPerPixel) truncated + 1.
	d _ sweepAngle / hops.
	hops timesRepeat: [
		angle _ angle + d.
		xp _ angle cos * rx.
		yp _ angle sin * ry.
		x _ thetaCos * xp - (thetaSin * yp) + cx.
		y _ thetaSin * xp + (thetaCos * yp) + cy.
		self addPenPositionX: x y: y ].

	currentX _ x.
	currentY _ y.

	self updateMask! !

!VectorEngine02 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:14'!
basicArcToX: x2 y: y2 radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"
	"Calcular: cx, cy, rx, ry, phi, theta1, deltaTheta"
	| x1 y1 cosPhi sinPhi x12hd y12hd x1p y1p rxSq rySq x1pSq y1pSq bigSqR bigSqRNumerator bigSqRDenominator sign cxp cyp cx cy theta1 theta2 deltaTheta scaleSq scale newRx newRy |
	x1 _ currentX.
	y1 _ currentY.
	"Handle out of range parameters as requested by the w3 implementation notes"
	(x2 = x1 and: [ y2 = y1 ]) ifTrue: [ ^self ].
	(rx = 0.0 or: [ ry = 0.0 ]) ifTrue: [ ^self basicLineToX: x2 y: y2 ].
	rx < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: 0.0 -rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	ry < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: rx radiusY: 0.0-ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	
	cosPhi _ phi cos.
	sinPhi _ phi sin.
	"step 1 in http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes"
	x12hd _ (x1-x2) * 0.5.
	y12hd _ (y1-y2) * 0.5.
	x1p _ (cosPhi * x12hd) + (sinPhi * y12hd).
	y1p _ (cosPhi * y12hd) - (sinPhi * x12hd).

	"step 2"
	rxSq _ rx * rx.
	rySq _ ry * ry.
	x1pSq _ x1p * x1p.
	y1pSq _ y1p * y1p.
	"ensure radii are large enough"
	scaleSq _ (x1pSq / rxSq) + (y1pSq / rySq).
	scaleSq > 1 ifTrue: [
		scale _ scaleSq sqrt.
		newRx _ scale * rx.
		newRy _ scale * ry.
		(newRx = rx or: [ newRy = ry ]) ifTrue: [		"This happens when scaleSq is so close to 1, that the multiplication rounds to the same numbers"
			newRx _ scaleSq * rx.
			newRy _ scaleSq * ry ].
		^self basicArcToX: x2 y: y2 radiusX: newRx radiusY: newRy angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
		].
	bigSqRNumerator _ (rxSq * rySq) - (rxSq * y1pSq)-(rySq * x1pSq).
	bigSqRDenominator _ (rxSq * y1pSq) + (rySq * x1pSq).
	sign _ doLargerArc = useIncreasingAngles ifTrue: [ -1 ] ifFalse: [ 1 ].
	bigSqR _ (bigSqRNumerator / bigSqRDenominator max: 0.0) sqrt * sign.		"This only can be < 0.0 because of rounding errors. Take 0.0 in such cases."
	cxp _ bigSqR * rx * y1p / ry.
	cyp _ 0.0 - (bigSqR * ry * x1p / rx).

	"step 3"
	cx _ (cosPhi * cxp) - (sinPhi * cyp) + ((x1+x2) * 0.5).
	cy _ (sinPhi * cxp) + (cosPhi * cyp) + ((y1+y2) * 0.5).
	
"
| u v a |
Transcript clear.
u _ 1@4. v _ 7@2.
a _ ((u dotProduct: v) / (u r * v r) ) arcCos.
a _ a * (((u x * v y) - (u y * v x)) sign).
a print.
(v theta - u theta) print.
Ojo al primitivizar. Para ellos, el theta va entre -pi y pi. Para Squeak va entre cero y 2pi...
"

	"step 4"
	"Ojo signo del angulo y del eje y!!!!!!!!!!"
	theta1 _ (((x1p - cxp) / rx) @ ((y1p - cyp) / ry)) theta.
	theta2 _ (((0 - x1p - cxp) / rx) @ (( 0 -y1p - cyp) / ry)) theta.
	deltaTheta _ theta2 - theta1.
	useIncreasingAngles = (deltaTheta > 0) ifFalse: [
		deltaTheta > 0
			ifTrue: [ deltaTheta _ deltaTheta - Float pi - Float pi ]
			ifFalse: [ deltaTheta _ deltaTheta + Float pi + Float pi ]
		].
	"Y aca calcular como dar vuelta deltaTheta, ver."


	"Finalmente, estudiar la correccion de valores fuera de rango"
	

	self basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: phi start: theta1 sweep: deltaTheta! !

!VectorEngine02 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:14'!
basicClosePath
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			do_ClosePath ].
Display forceToScreen
"
	self basicLineToX: firstX y: firstY! !

!VectorEngine02 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:14'!
basicCubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	| dx dy hops increment t x0 y0 oneLessT f2 f3 f1 f23 f4 x y |

	dx _ (x1-currentX) abs + (x2-x1) abs + (x3-x2) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs + (y3-y2) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	"en muchos casos, secuencias de estos,  repetimos puntos, el ultimo de la curva anterior... pensar, etc"
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT * oneLessT.
		f23 _ 3 * oneLessT * t.
		f2 _ f23 * oneLessT.
		f3 _ f23 * t.
		f4 _ t * t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2) + (f4 * x3).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2) + (f4 * y3).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x3 y: y3.

	currentX _ x3.
	currentY _ y3.

	self updateMask! !

!VectorEngine02 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:14'!
basicHorizontalLineToX: x2
	| distanceToAxis |	

	maskBoundsTop _ (currentY - strokeWidthDilatedHalf) truncated +1.
	maskBoundsBottom _ (currentY + strokeWidthDilatedHalf) truncated.
	maskBoundsLeft _ (currentX min: x2) truncated +1.
	maskBoundsRight _ (currentX max: x2) truncated.
	maskBoundsTop < clipTop ifTrue: [ maskBoundsTop _ clipTop ].
	maskBoundsBottom > clipBottom ifTrue: [ maskBoundsBottom _ clipBottom ].
	maskBoundsLeft< clipLeft ifTrue: [ maskBoundsLeft _ clipLeft ].
	maskBoundsRight > clipRight ifTrue: [ maskBoundsRight _ clipRight ].

	"Paralelizar en displayX@displayY"
	maskBoundsTop to: maskBoundsBottom do: [ :displayY |
		distanceToAxis _ (displayY - currentY) abs.
		maskBoundsLeft to: maskBoundsRight do: [ :displayX |
			self updateMaskForYDistanceToAxis: distanceToAxis displayX: displayX displayY: displayY ]].

	"Include updated mask in area to blend."
	blendBoundsTop _ blendBoundsTop min: maskBoundsTop.
	blendBoundsBottom _ blendBoundsBottom max: maskBoundsBottom.
	blendBoundsLeft _ blendBoundsLeft min: maskBoundsLeft.
	blendBoundsRight _ blendBoundsRight max: maskBoundsRight.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."! !

!VectorEngine02 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:14'!
basicLineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 300 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 25.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 500 y: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 30 y: 15.
		engine abs_LineToX: 45 y: 90.
		engine abs_LineToX: 180 y: 30 ].
Display forceToScreen
"
	| dx dy hops incrementX incrementY x y |
	dy _ y2 - currentY.
	dx _ x2 - currentX.
	dx * dy = 0.0
		ifTrue: [
			self addPenPositionX: currentX y: currentY.
			self updateMask.
			dy = 0.0  	"or else it means dx = 0.0"
				ifTrue: [ self basicHorizontalLineToX: x2 ]
				ifFalse: [ self basicVerticalLineToY: y2 ]]
		ifFalse: [
			maskBoundsTop _ maskBoundsTop min: currentY.
			maskBoundsBottom _ maskBoundsBottom max: currentY.
			maskBoundsLeft _ maskBoundsLeft min: currentX.
			maskBoundsRight _ maskBoundsRight max: currentX.
			x _ currentX.
			y _ currentY.
			hops _ ((dx abs max: dy abs) * hopsPerPixel) truncated + 1.
			incrementX _ dx *1.0 / hops.
			incrementY _ dy *1.0 / hops.
			doFill
				ifTrue: [
					hops timesRepeat: [
						trajectoryPoints add: x@y.
						self updateEdgeCountAtX: x y: y.
						x _ x + incrementX.
						y _ y + incrementY ]]
				ifFalse: [
					hops timesRepeat: [
						trajectoryPoints add: x@y.
						x _ x + incrementX.
						y _ y + incrementY ]]
		].
	currentX _ x2.
	currentY _ y2.
	self addPenPositionX: currentX y: currentY.
	self updateMask! !

!VectorEngine02 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:14'!
basicMoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150;
			abs_MoveToX: 210 y: 150;
			abs_LineToX: 300 y: 200 ].
Display forceToScreen
"

	"A discontinuity in the trajectory"

	"We are starting a new trajectory, or at a discontinuity in trajectory.
	Eventually #closeTrajectory should draw a line to here"

	"Next point will be first in a new trajectory fragment"
	prevYTruncated _ nil.
	firstX _ x.
	firstY _ y.
	currentX _ x.
	currentY _ y.! !

!VectorEngine02 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:14'!
basicQuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| dx dy hops increment t x0 y0 oneLessT f1 f3 f2 x y |
	dx _ (x1-currentX) abs + (x2-x1) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT.
		f2 _ 2* oneLessT * t.
		f3 _ t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x2 y: y2.

	currentX _ x2.
	currentY _ y2.

	self updateMask! !

!VectorEngine02 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:10:14'!
basicVerticalLineToY: y2
	| distanceToAxisB distanceToAxisG distanceToAxisR |	

	doFill ifTrue: [
		currentY to: y2 by: (y2-currentY) sign do: [ :y |
			self updateEdgeCountAtX: currentX y: y ]].

	maskBoundsTop _ (currentY min: y2) truncated +1.
	maskBoundsBottom _ (currentY max: y2) truncated.
	maskBoundsLeft _ (currentX - strokeWidthDilatedHalf - subPixelDelta) truncated +1.
	maskBoundsRight _ (currentX + strokeWidthDilatedHalf + subPixelDelta) truncated.
	maskBoundsTop < clipTop ifTrue: [ maskBoundsTop _ clipTop ].
	maskBoundsBottom > clipBottom ifTrue: [ maskBoundsBottom _ clipBottom ].
	maskBoundsLeft< clipLeft ifTrue: [ maskBoundsLeft _ clipLeft ].
	maskBoundsRight > clipRight ifTrue: [ maskBoundsRight _ clipRight ].

	"Paralelizar en displayX@displayY"
	maskBoundsLeft to: maskBoundsRight do: [ :displayX |
		distanceToAxisR _ (displayX - subPixelDelta - currentX) abs.
		distanceToAxisG _ (displayX - currentX) abs.
		distanceToAxisB _ (displayX + subPixelDelta - currentX) abs.
		maskBoundsTop to: maskBoundsBottom do: [ :displayY |
			self updateMaskForXDistanceToAxis: distanceToAxisR g: distanceToAxisG b: distanceToAxisB displayX: displayX displayY: displayY ]].

	"Include updated mask in area to blend."
	blendBoundsTop _ blendBoundsTop min: maskBoundsTop.
	blendBoundsBottom _ blendBoundsBottom max: maskBoundsBottom.
	blendBoundsLeft _ blendBoundsLeft min: maskBoundsLeft.
	blendBoundsRight _ blendBoundsRight max: maskBoundsRight.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."! !

!VectorEngine02 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:14'!
blendFillOnly

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.

			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendFillOnlyAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine02 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:14'!
blendFillOnlyAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends fill over background. Despite method selector, there might be a very thin stroke of the same color as the fill. Handle this by adjusting antiAliasAlphas.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	"In this method, antiAliasAlphas are not used to blend stroke, but fill. This means that in the inside of the shape, and away from the stroke, they must be 1.0 (not 0.0)."
	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	isRedInside ifTrue: [ antiAliasRedAlpha _ 1.0 - antiAliasRedAlpha ].
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	isGreenInside ifTrue: [ antiAliasGreenAlpha _ 1.0 - antiAliasGreenAlpha ].
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	isBlueInside ifTrue: [ antiAliasBlueAlpha _ 1.0 - antiAliasBlueAlpha ].
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * fillAlphaToUse.
	resultR _ alpha * fillRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * fillAlphaToUse.
	resultG _ alpha * fillGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * fillAlphaToUse.
	resultB _ alpha * fillBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine02 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:14'!
blendStrokeAndFill

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.
			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendStrokeAndFillAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine02 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:15'!
blendStrokeAndFillAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Do an appropriate (anti aliased) mix between stoke and fill (or pick just stroke or just fill). Blend this over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha foreComponent strokeAlphaToUse fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	isRedInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse.
			foreComponent _ strokeRed ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse + ((1-antiAliasRedAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasRedAlpha * strokeRed + ((1-antiAliasRedAlpha) * fillRed) ].
	resultR _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	isGreenInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
			foreComponent _ strokeGreen ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse + ((1-antiAliasGreenAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasGreenAlpha * strokeGreen + ((1-antiAliasGreenAlpha) * fillGreen) ].
	resultG _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	isBlueInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
			foreComponent _ strokeBlue ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse + ((1-antiAliasBlueAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasBlueAlpha * strokeBlue + ((1-antiAliasBlueAlpha) * fillBlue) ].
	resultB _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine02 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:15'!
blendStrokeOnly

	| pixelIndex m |
	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.
				(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
					self blendStrokeOnlyAtX: displayX y: displayY pixelIndex: pixelIndex ]]].

	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine02 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:10:15'!
blendStrokeOnlyAtX: x y: y pixelIndex: pixelIndex

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends stroke over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha strokeAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		^self].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.

	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * strokeAlphaToUse.
	resultR _ alpha * strokeRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
	resultG _ alpha * strokeGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
	resultB _ alpha * strokeBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine02 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:15'!
experLinesAndShapes
	"
	self experLinesAndShapes
	"
	| engine y1 yy2 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		yy2 _ y2 >= 1 ifTrue: [ VectorEngine defaultAntiAliasingWidth * 0.5 ] ifFalse: [0].
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1+yy2; abs_LineToX: 530 y: y1+yy2+dy;
				abs_LineToX: 530 y: y1+y2-yy2+dy; abs_LineToX: 431 y: y1+y2-yy2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1+yy2 y: 431; abs_LineToX: y1+yy2+dy y: 530;
				abs_LineToX: y1+y2-yy2+dy y: 530; abs_LineToX: y1+y2-yy2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill."
		engine fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		"solo stroke, no fill"
		engine strokeWidth: y2 color: Color black do: [
			engine
				abs_MoveToX: y2*0.5+731 y: y2*0.5 + y1+dy+dy+dy; abs_LineToX: 830 y: y2 * 0.5 + y1  + dy + dy+dy+dy.
			engine
				abs_MoveToX: y2*0.5 + y1+dy+dy+dy y: y2*0.5+731; abs_LineToX: y2 * 0.5 + y1  + dy + dy+dy+dy y: 830 ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine02 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:15'!
experLinesAndShapes2
	"
	self experLinesAndShapes2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth*4*2.
	15 timesRepeat: [
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 1.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 131 y: y1; abs_LineToX: 230 y: y1+dy;
				abs_LineToX: 230 y: y1+y2+dy; abs_LineToX: 131 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX: y1 y: 131; abs_LineToX: y1+dy y: 230;
				abs_LineToX: y1+y2+dy y: 230; abs_LineToX: y1+y2 y: 131;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.8 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 231 y: y1+dy; abs_LineToX: 330 y: y1+dy+dy;
				abs_LineToX: 330 y: y1+y2+dy+dy; abs_LineToX: 231 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 231; abs_LineToX: y1+dy+dy y: 330;
				abs_LineToX: y1+y2+dy+dy y: 330; abs_LineToX: y1+y2+dy y: 231;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.6 color: Color green fillColor: Color red do: [.
			engine
				abs_MoveToX: 331 y: y1+dy+dy; abs_LineToX: 430 y: y1+dy+dy+dy;
				abs_LineToX: 430 y: y1+y2+dy+dy+dy; abs_LineToX: 331 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 331; abs_LineToX: y1+dy+dy+dy y: 430;
				abs_LineToX: y1+y2+dy+dy+dy y: 430; abs_LineToX: y1+y2+dy+dy y: 331;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.4 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 431 y: y1+dy+dy+dy; abs_LineToX: 530 y: y1+dy+dy+dy+dy;
				abs_LineToX: 530 y: y1+y2+dy+dy+dy+dy; abs_LineToX: 431 y: y1+y2+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy+dy y: 431;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.2 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 531 y: y1+dy+dy+dy+dy; abs_LineToX: 630 y: y1+dy+dy+dy+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy+dy+dy+dy; abs_LineToX: 531 y: y1+y2+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy y: 531; abs_LineToX: y1+dy+dy+dy+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 630; abs_LineToX: y1+y2+dy+dy+dy+dy y: 531;
				do_ClosePath ].
		"Solo fill. w chico. Preferimos ya usarlo para definir mejor el shape (se transparentaria demasiado)"
		engine strokeWidth: 0.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy+dy+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 print.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine02 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:15'!
experLinesAndShapes3
	"
	self experLinesAndShapes3
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.4 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine02 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:15'!
experLinesAndShapes4
	"
	self experLinesAndShapes4
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*1.5 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine02 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:15'!
experLinesAndShapesx
	"
	self experLinesAndShapesx
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		y2 print.
		"Solo fill. w =0"
		engine strokeWidth: 0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy y: 431;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.! !

!VectorEngine02 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:15'!
experLinesAndShapesx2
	"
	self experLinesAndShapesx2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	y1 _ 10.
	dy _ 3.
	y2 _ 0.1.
	y2 print.
	"Solo fill. w =0"
	engine strokeWidth: 0.5 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 10 y: y1+dy+dy; abs_LineToX: 200 y: y1+dy+dy+dy;
			abs_LineToX: 200 y: y1+y2+dy+dy+dy; abs_LineToX: 10 y: y1+y2+dy+dy;
			do_ClosePath.
		engine
			abs_MoveToX: y1+dy+dy y: 10; abs_LineToX: y1+dy+dy+dy y: 200;
			abs_LineToX: y1+y2+dy+dy+dy y: 200; abs_LineToX: y1+y2+dy+dy y: 10;
			do_ClosePath ].
	Display forceToScreen.
! !

!VectorEngine02 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:15'!
experimentHopsPerPixel1
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 1: Very thin stroke, the same color as fill
	VectorEngine experimentHopsPerPixel1
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) *10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine02 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:15'!
experimentHopsPerPixel2
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 2: Stroke of various widths, no fill
	VectorEngine experimentHopsPerPixel2
	"
	| d engine f1 f2 hops1 hops2 strokeWidth |
	hops1 _ 200.
	hops1 _ 20.
	"
	strokeWidth -> hops2
	1.3 -> 8
	1.5 -> 6
	2 -> 4
	4 -> 3
	6 -> 2
	16 -> 1
	Maybe 10 / strokeWidth + 1 is ok?
	"
	strokeWidth _ 16*2.
	hops2 _ 8*0+1.
	hops2 _ 10.0 / strokeWidth + 1.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f2 displayAt: 220@0.

Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine02 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:10:15'!
experimentHopsPerPixel3
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 3: No stroke, just fill
	VectorEngine experimentHopsPerPixel3
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine02 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:10:15'!
experiment1
	"
	No perfecto aun, pero se puede empezar a comparar con
	http://www.hpl.hp.com/research/mmsl/projects/graphics/antialiasing/figure21.htm
	Ni que hablar que es mucho mas rapido...
	self experiment1
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 e f |
engine _ self onForm: Display.
h _ 300.
h _ 490.
h _ 280.
bottom _ 200.
bottom _ 0.
centerX _ 400.
centerX _ 250.
w0 _ 120.0.
hf _ 1.0.
hf _ 1.73.
hf _ 1.71.
y _ nil.
delta _ nil.
	e _ 500@500.
	f _ Form extent: e depth: 32.
	f fillColor: Color transparent..
"	canvas _  self on: f.
	canvas useComponentAlphas."
1 to: "400" 150 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-3 // delta to: 3 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color black ] ifFalse: [ Color white ].
"			color _ color alpha: (((prevY-y) min: (x1-x2)) min: 1)."
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
"
	canvas removeSpuriousTranslucencyFloatAndBlendOver: Color red.
	f writePNGfileNamed: 'pp17.png'
"! !

!VectorEngine02 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:10:15'!
experiment2
	"
	self experiment2
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 |
engine _ self onForm: Display.
h _ 300.
h _ 600.
bottom _ 200.
centerX _ 400.
w0 _ 60.0.
hf _ 1.0.
y _ nil.
delta _ nil.
1 to: 400 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-6 // delta to: 6 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color white ] ifFalse: [ Color black ].
			color _ color alpha: (((prevY-y) min: (x1-x2)) "* 0.3" min: 1).
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
! !

!VectorEngine02 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:10:15'!
experiment3
	"
	self experiment3
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	100 timesRepeat: [
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
		r _ r + w.
		w _ w * 0.8.
		r _ r + w.

	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine02 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:10:15'!
experiment4
	"
	self experiment4
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	1 to: 100 do: [ :i |
		r _ r + w.
		w _ 20.0 / i.
		r _ r + w.
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine02 class methodsFor: 'samples' stamp: 'jmv 2/20/2020 12:30:15'!
siemensStar
	"
	self siemensStar display
	"
	| angle backColor canvas count extent foreColor form location offsetFromCenter |
	count _ 32.
	angle _ Float twoPi / count / 2.
	extent _ 512.
	offsetFromCenter _ 0.
	backColor _ `Color gray: 50/255`.
	foreColor _ `Color gray: 200/255`.
	form _ Form extent: extent asPoint depth: 32.
	form fillColor: backColor.
	canvas _ VectorCanvas onForm: form.
	1 to: count do: [ :i |
		location _ AffineTransformation withRadians: i * angle * 2+0.02 scale: extent*0.45 position: extent-1/2.0 + offsetFromCenter.
		canvas engine geometryTransformation: location.
		canvas fillColor: foreColor do: [
			canvas
				moveToX: 0 y: 0;
				lineToX: 1 y: 0;
				lineToX: angle cos y: angle sin;
				lineToX: 0 y: 0.
		].
	].
	^form! !

!VectorEngine02 class methodsFor: 'instance creation' stamp: 'jmv 2/9/2020 10:10:16'!
onForm: aForm

	^ self new setForm: aForm! !

!VectorEngine02 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:16'!
antiAliasingWidthForOutlineFonts
	^1.4! !

!VectorEngine02 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:16'!
antiAliasingWidthForStrokeFonts
	^1.1! !

!VectorEngine02 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:10:16'!
defaultAntiAliasingWidth
	^1.3. "default for graphics"! !

!VectorEngine03 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:27:01'!
antiAliasingWidth: aNumber

	antiAliasingWidth _ aNumber.
	antiAliasingWidthScaledInverse _ 127.0 / antiAliasingWidth! !

!VectorEngine03 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:27:01'!
clipRect: aRectangle 
	"by convention, aRectangle includes left and top but does not include right and bottom.
	We do draw clipRight and clipBottom but not beyond.
	"
	"In targetForm coordinates"
	clipLeft _ aRectangle left.
	clipTop _ aRectangle top.
	clipRight _ aRectangle right - 1.
	clipBottom _ aRectangle bottom - 1! !

!VectorEngine03 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:27:01'!
clippingRectForCurrentMorph
	"In targetForm coordinates.
	Only valid _after_ drawing currentMorph."

	^morphBoundsLeft @ morphBoundsTop corner: morphBoundsRight @ morphBoundsBottom! !

!VectorEngine03 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:27:01'!
currentMorph: aMorph
	currentMorph _ aMorph! !

!VectorEngine03 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:27:01'!
currentOwnerIfClips: currentMorphOwnerOrNil
	currentOwnerIfClips _ currentMorphOwnerOrNil! !

!VectorEngine03 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:27:01'!
geometryTransformation
	^geometryTransformation! !

!VectorEngine03 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:27:01'!
geometryTransformation: aGeometryTransformation
	geometryTransformation _ aGeometryTransformation! !

!VectorEngine03 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 10:27:01'!
fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	doStroke _ false.
	doFill _ true.
	self pvtStrokeWidth: 0.0.
	hopsPerPixel _ 8.										"See #experimentHopsPerPixel3"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ nil. strokeRed _ nil. strokeGreen _ nil. strokeBlue _ nil.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine03 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 10:27:01'!
strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke."

	| strokeAlphaFactor aStrokeWidth |
	doStroke _ true.
	doFill _ false.
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.

	"Strokes we want to show. They are not too thin, or maybe they are, but there's no fill. Make them wide enough to be properly sampled."
	self pvtStrokeWidth: (aStrokeWidth max: antiAliasingWidth).
	strokeAlphaFactor _ aStrokeWidth / strokeWidth.
	hopsPerPixel _ 10.0 / strokeWidth + 1.		"See #experimentHopsPerPixel2"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ nil. fillRed _ nil. fillGreen _ nil. fillBlue _ nil.
	strokeAlpha _ (aStrokeColor alpha * 255.0 * strokeAlphaFactor) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine03 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 10:27:01'!
strokeWidth: clientStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	| aStrokeWidth |

	aStrokeColor ifNil: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	clientStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aFillColor ifNil: [ ^ self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock.
		^ self ].

	doStroke _ true.
	doFill _ true.
	self pvtStrokeWidth: aStrokeWidth.
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"Strokes are really thin, but strokeColor is same as fillColor, so there's no problem sampling them."
			hopsPerPixel _ 8 ]								"See #experimentHopsPerPixel1"
		ifFalse: [
			hopsPerPixel _ 10.0 / strokeWidth + 1 max: 2 ].		"See #experimentHopsPerPixel2. Additionally, fills require at least 2."

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ (aStrokeColor alpha * 255.0) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.2 position: 200@100);
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcToX: center x y: center y radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_CircleCenterX: cx y: cy radius: mr
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_CircleCenterX: 200 y: 150 radius: 80].
Display forceToScreen
"

	| center r |
	center _ geometryTransformation externalizePosition: cx@cy.
	r _ geometryTransformation externalizeScalar: mr.
	self
		basicArcCenterX: center x centerY: center y radiusX: r radiusY: r rotationAngle: 0.0 start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 150 y: 300 radius: 10.
		engine abs_CircleCenterX: 600 y: 400 radius: 6.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 600 y: -200 radius: 10.
		engine abs_CircleCenterX: 100 y: -100 radius: 6.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_CubicBezierToX: 300 y: 100 control1X: 600 y: -200 control2X: 100 y: -100
			].
Display forceToScreen.
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 100 control2X: 100 y: -100
			].
Display forceToScreen
	"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_CubicBezierToX: x3 y: y3 control1X: mirroredContolX y: mirroredContolY control2X: x2 y: y2! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"
	| p1 p2 p3 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	p3 _ geometryTransformation externalizePosition: x3@y3.
	self basicCubicBezierToX: p3 x y: p3 y control1X: p1 x y: p1 y control2X: p2 x y: p2 y.
	lastClientX _ x3.
	lastClientY _ y3.
	lastControlX _ x2.
	lastControlY _ y2! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta start: startAngle sweep: sweepAngle
	"Currently draws a line from currentX@currentY to start (if startAngle ~= 0.0 or sweepAngle ~= Float twoPi).
	This could be useful for proper fills. But might not be what is desired in some cases.
	Implement desired behavior when clear."
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.0 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6].
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 350 radiusX: 100 radiusY: 50 rotationAngle: 0.5 start: 0.1 sweep: 6 ].
Display forceToScreen.
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: startAngle sweep:  sweepAngle! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_LineToX: x2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: x2 y: lastClientY! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p2 |
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicLineToX: p2 x y: p2 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_LineToY: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToY: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToY: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX y: y2! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p |
	p _ geometryTransformation externalizePosition: x@y.
	self basicMoveToX: p x y: p y.
	lastClientX _ x.
	lastClientY _ y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 450 y: 300 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 750 y: -100 radius: 10.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_QuadraticBezierToX: 300 y: 100 controlX: 750 y: -100
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			abs_QuadraticBezierSmoothToX: 300 y: 100
			].
Display forceToScreen
"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_QuadraticBezierToX: x2 y: y2 controlX: mirroredContolX y: mirroredContolY! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
abs_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| p1 p2 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicQuadraticBezierToX: p2 x y: p2 y controlX: p1 x y: p1 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ x1.
	lastControlY _ y1! !

!VectorEngine03 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
do_ClosePath
	"abs/rel meaningless here"
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200;
			abs_CubicBezierToX: 300 y: 120 control1X: 310 y: 110 control2X: 200 y: 200;
			do_ClosePath;
			abs_LineToX: 150 y: 300 ].
Display forceToScreen
"
	| p2 |
	self basicClosePath.

	p2 _ geometryTransformation internalizePosition: currentX@currentY.
	lastClientX _ p2 x.
	lastClientY _ p2 y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine03 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
rel_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			rel_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false;
			do_ClosePath ].
"
	self abs_ArcToX: lastClientX + cx y: lastClientY + cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine03 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
rel_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierToX: 300 y: 300 control1X: 0 y: 0 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierSmoothToX: 600 y: 100 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"

	self
		abs_CubicBezierSmoothToX: lastClientX + x3 y: lastClientY + y3
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine03 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
rel_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ];
	strokeWidth: 1.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ];
	strokeWidth: 10 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	self
		abs_CubicBezierToX: lastClientX + x3 y: lastClientY + y3
		control1X: lastClientX + x1 y: lastClientY + y1
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine03 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
rel_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine03 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
rel_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_MoveToX: lastClientX + x y: lastClientY + y! !

!VectorEngine03 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
rel_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 550 y: 350 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 850 y: -50 radius: 10.
		engine abs_MoveToX: 700 y: 150.
		engine
			rel_QuadraticBezierToX: -300 y: -50 controlX: 150 y: -200
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			rel_QuadraticBezierSmoothToX: -300 y: -50
			].
Display forceToScreen
"
	self
		abs_QuadraticBezierSmoothToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine03 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
rel_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ];
	strokeWidth: 3.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ];
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color green alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	self
		abs_QuadraticBezierToX: lastClientX + x2 y: lastClientY + y2
		controlX: lastClientX + x1 y: lastClientY + y1! !

!VectorEngine03 methodsFor: 'text' stamp: 'jmv 2/9/2020 10:27:01'!
displayString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aFont color: aColor canvas: aCanvas
	"geometryTransformation is already set to honor font pointSize
	Use as little of aFont as possible!!"
	| glyph destX destY loc |

	self antiAliasingWidth: VectorEngine antiAliasingWidthForOutlineFonts.
	loc _ geometryTransformation.
	self fillColor: aColor do: [
		destY _ aPoint y.
		destX _ aPoint x.
		startIndex to: stopIndex do: [ :charIndex |
			glyph _ aFont ttGlyphAt: (aString at: charIndex).
			glyph isComposite
				ifFalse: [
					glyph contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ].
					]]
				ifTrue: [
					glyph txAndContoursDo: [ :tx :contours |contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ (loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated) composedWith: tx.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ]]]
					].
			destX _ destX + glyph advanceWidth.
		]
	].
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
addPenPositionX: x y: y

"
Inlinear en senders. Extraer afectar bounds si es posible (linea, circulo)
"

	trajectoryPoints add: x@y.

	maskBoundsTop _ maskBoundsTop min: y.
	maskBoundsBottom _ maskBoundsBottom max: y.
	maskBoundsLeft _ maskBoundsLeft min: x.
	maskBoundsRight _ maskBoundsRight max: x.

	"Compute edges intersecting with this horizontal line, for fills."
	doFill ifTrue: [
		self updateEdgeCountAtX: x y: y ].! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
finishPath
	"Blend stroke and/or fill over background, according to the just computed pen alphas (distance from pixel to center of stroke)"
	
	"If we are doing a fill, and caller forgot to close the trajectory, then do it anyway."
	doFill ifTrue: [
		(firstX = currentX and: [ firstY = currentY ]) ifFalse: [
			"This is actually an error condition. If we are asked to fill, then the path should be closed.
			This is a workaround. If width > 0.0, we'll be adding a visible edge to the path."
			self basicClosePath ]].

	doFill ifTrue: [
		doStroke
			ifTrue: [ self blendStrokeAndFill ]
			ifFalse: [ self blendFillOnly ]]
		ifFalse: [
		self blendStrokeOnly ].
	morphBoundsTop _ morphBoundsTop min: blendBoundsTop.
	morphBoundsBottom _ morphBoundsBottom max: blendBoundsBottom.
	morphBoundsLeft _ morphBoundsLeft min: blendBoundsLeft.
	morphBoundsRight _ morphBoundsRight max: blendBoundsRight.

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.

	Display forceToScreen! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
initialize
	geometryTransformation _ MorphicTranslation new. "Identity"! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
initializePath

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.
	trajectoryPoints _ OrderedCollection new.
	prevYTruncated _ nil.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."

	blendBoundsTop _ targetHeight.			"drawable bottom. Will later be refined."
	blendBoundsBottom _ 0.						"drawable top. Will later be refined."
	blendBoundsLeft _ targetWidth.			"drawable right. Will later be refined."
	blendBoundsRight _ 0.						"drawable left. Will later be refined."! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
pvtStrokeWidth: aNumber
	strokeWidth _ aNumber.
	strokeWidthDilatedHalf _ strokeWidth + antiAliasingWidth * 0.5.
	strokeWidthDilatedHalfSquared _ strokeWidthDilatedHalf * strokeWidthDilatedHalf.
	strokeWidthErodedHalf _ strokeWidth - antiAliasingWidth * 0.5.
	strokeWidthErodedHalfSquared _ strokeWidthErodedHalf * strokeWidthErodedHalf * strokeWidthErodedHalf sign! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
resetMorphBounds

	morphBoundsTop _ targetHeight - 1.
	morphBoundsBottom _ 0.
	morphBoundsLeft _ targetWidth - 1.
	morphBoundsRight _ 0! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
setForm: aForm
	"
	World extent: World extent
	"
	| hack s |
	targetForm _ aForm.
	targetWidth _ aForm width.
	targetHeight _ aForm height.
	self resetMorphBounds.
	self clipRect: (0@0 corner: targetWidth@targetHeight).
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth.
	subPixelDelta _ 0.25. "Values closer to 0.333 might produce a bit of coloring on some displays. Used to be 0.28"
	s _ aForm bits size.
	(mask isNil or: [ mask size ~= s ])
		ifTrue: [
			mask _ WordArray new: s.
			edgeCountPerPixel _ WordArray new: s.
			morphAtPixel _ Array new: s.
			hack _ Form extent: targetWidth@targetHeight depth: 32 bits: mask.
			auxBitBlt _ BitBlt toForm: hack.
			auxBitBlt fillBitmap: (Bitmap with: 16rFF000000).
			auxBitBlt combinationRule: Form over ].

	"Perhaps this should be done in an ifCurtailed: block in case of Morphic drawing failure..."
	auxBitBlt destRect: targetForm boundingBox.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	morphAtPixel atAllPut: 0! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
updateEdgeCountAtX: x y: y
	| thisYTruncated pixelY pixelIndexBase redPixelIndex greenPixelIndex bluePixelIndex increment countWord redCount greenCount blueCount redOffset greenOffest blueOffset |

	thisYTruncated _ (y truncated max: clipTop-1) min: clipBottom-1.
	prevYTruncated ifNil: [ 
		^ prevYTruncated _ thisYTruncated ].
	thisYTruncated = prevYTruncated ifTrue: [
		^ prevYTruncated _ thisYTruncated ].

	thisYTruncated > prevYTruncated
		ifTrue: [
			pixelY _ thisYTruncated.
			increment _ 1 ]
		ifFalse: [
			pixelY _ prevYTruncated.
			increment _ -1 ].

	"All edge count at the left of the clipRect are added there (at the left of the clipRect).
	The effect is the same, and we need to clean up less stuff afterwards.
	More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses."
	pixelIndexBase _ pixelY * targetWidth + 1.
	redOffset _ (x+subPixelDelta) truncated + 1 max: clipLeft.
	greenOffest _ x truncated + 1 max: clipLeft.
	blueOffset _ (x-subPixelDelta) truncated + 1 max: clipLeft.
	redPixelIndex _ pixelIndexBase + redOffset.
	greenPixelIndex _ pixelIndexBase + greenOffest.
	bluePixelIndex _ pixelIndexBase + blueOffset.

	"Three possible cases here: RGB in one word (pixel); RG in one, and G in another; R in one, GB in another"
	redPixelIndex = bluePixelIndex
		ifTrue: [						"First case: RGB in the same word"
			redOffset <= clipRight ifTrue: [
				countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
				redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
				countWord at: 3 put: redCount.
				greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
				countWord at: 2 put: greenCount.
				blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
				countWord at: 1 put: blueCount.
				edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].
		]
		ifFalse: [
			redPixelIndex = greenPixelIndex
				ifTrue: [				"Second case: RG in one word, B in following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
				ifFalse: [			"Third case: R in one word, GB in the following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
		].
	prevYTruncated _ thisYTruncated! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
updateMask
	"Apdate alpha (transparency) mask using trajectoryPoints."

	maskBoundsTop _ (maskBoundsTop - strokeWidthDilatedHalf) truncated +1.
	maskBoundsBottom _ (maskBoundsBottom + strokeWidthDilatedHalf) truncated.
	maskBoundsLeft _ (maskBoundsLeft - strokeWidthDilatedHalf - subPixelDelta) truncated +1.
	maskBoundsRight _ (maskBoundsRight + strokeWidthDilatedHalf + subPixelDelta) truncated.
	maskBoundsTop < clipTop ifTrue: [ maskBoundsTop _ clipTop ].
	maskBoundsBottom > clipBottom ifTrue: [ maskBoundsBottom _ clipBottom ].
	maskBoundsLeft< clipLeft ifTrue: [ maskBoundsLeft _ clipLeft ].
	maskBoundsRight > clipRight ifTrue: [ maskBoundsRight _ clipRight ].

	"Paralelizar en displayX@displayY"
	"Esto es lo que estoy haciendo ahora. Paralelizar en la bolita, lo mas afuera posible"
	self updateMaskToto.
	trajectoryPoints _ OrderedCollection new.

	"Include updated mask in area to blend."
	blendBoundsTop _ blendBoundsTop min: maskBoundsTop.
	blendBoundsBottom _ blendBoundsBottom max: maskBoundsBottom.
	blendBoundsLeft _ blendBoundsLeft min: maskBoundsLeft.
	blendBoundsRight _ blendBoundsRight max: maskBoundsRight.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
updateMaskForXDistanceToAxis: distanceToAxisR g: distanceToAxisG b: distanceToAxisB displayX: displayX displayY: displayY
	| alpha alphaWord pixelIndex |

	pixelIndex _ displayY * targetWidth +  displayX.
	pixelIndex _ pixelIndex + 1.
	alphaWord _ mask bytesAt: pixelIndex.

	"Red"
	distanceToAxisR < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxisR <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisR * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 3) ifTrue: [
				alphaWord at: 3 put: alpha ]].
	"Green"
	distanceToAxisG < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxisG <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisG * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 2) ifTrue: [
				alphaWord at: 2 put: alpha ]].
	"Blue"
	distanceToAxisB < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxisB <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisB * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 1) ifTrue: [
				alphaWord at: 1 put: alpha ]].
	mask bytesAt: pixelIndex put: alphaWord! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
updateMaskForYDistanceToAxis: distanceToAxis displayX: displayX displayY: displayY
	| alpha alphaWord pixelIndex |

	pixelIndex _ displayY * targetWidth +  displayX.
	pixelIndex _ pixelIndex + 1.
	alphaWord _ mask bytesAt: pixelIndex.
	distanceToAxis < strokeWidthDilatedHalf
		ifTrue: [
			alpha _ distanceToAxis <= strokeWidthErodedHalf
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxis * antiAliasingWidthScaledInverse) rounded ].
			alpha > (alphaWord at: 3) ifTrue: [
				alphaWord at: 3 put: alpha ].
			alpha > (alphaWord at: 2) ifTrue: [
				alphaWord at: 2 put: alpha ].
			alpha > (alphaWord at: 1) ifTrue: [
				alphaWord at: 1 put: alpha ].
			mask bytesAt: pixelIndex put: alphaWord ]! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
updateMaskToto



	"Compute affected rect. Honor clipRect!!!!!!"

| altoBolita anchoBolita |
altoBolita _ (strokeWidthDilatedHalf * 2) truncated + 1.
anchoBolita _ ((strokeWidthDilatedHalf + subPixelDelta) * 2) truncated + 1.
{anchoBolita. altoBolita} print.
0 to: altoBolita do: [ :i |
	0 to: anchoBolita do: [ :j |
		self updateMaskTotoI: i j: j altoBolita: altoBolita anchoBolita: anchoBolita
		]]! !

!VectorEngine03 methodsFor: 'private' stamp: 'jmv 2/9/2020 10:27:01'!
updateMaskTotoI: i j: j altoBolita: altoBolita anchoBolita: anchoBolita
	
	| pixY pixX writePrev distanceToAxisSquared alpha alphaWord dySquared dx dxSquared dy pixelIndex dxp blueAlpha greenAlpha redAlpha previousBlueAlpha previousGreenAlpha previousRedAlpha |

	pixY _ (trajectoryPoints first y / (altoBolita+1)) truncated * (altoBolita+1) + i.
	pixX _ (trajectoryPoints first x / (anchoBolita+1)) truncated * (anchoBolita+1) + j.
	trajectoryPoints first y - pixY > (altoBolita/2) ifTrue: [ pixY _ pixY + altoBolita+1].
	pixY - trajectoryPoints first y > (altoBolita/2) ifTrue: [ pixY _ pixY - altoBolita-1].
	trajectoryPoints first x - pixX > (anchoBolita/2) ifTrue: [ pixX _ pixX + anchoBolita+1].
	pixX - trajectoryPoints first x > (anchoBolita/2) ifTrue: [ pixX _ pixX - anchoBolita-1].
	
	"Leer el 1ro"
	pixelIndex _ pixY * targetWidth +  pixX.
	pixelIndex _ pixelIndex + 1.
	alphaWord _ mask bytesAt: pixelIndex.
	redAlpha _ alphaWord at: 3.
	greenAlpha _ alphaWord at: 2.
	blueAlpha _ alphaWord at: 1.
	previousRedAlpha _ redAlpha.
	previousGreenAlpha _ greenAlpha.
	previousBlueAlpha _ blueAlpha.
	
	trajectoryPoints do: [ :p |
		
		writePrev _ false.
		p y - pixY > (altoBolita/2) ifTrue: [ pixY _ pixY + altoBolita+1. writePrev _ true].
		pixY - p y > (altoBolita/2) ifTrue: [ pixY _ pixY - altoBolita-1. writePrev _ true].
		p x - pixX > (anchoBolita/2) ifTrue: [ pixX _ pixX + anchoBolita+1. writePrev _ true].
		pixX - p x > (anchoBolita/2) ifTrue: [ pixX _ pixX - anchoBolita-1. writePrev _ true].
		
		writePrev ifTrue: [
			"escribir el anterior"
			(previousRedAlpha ~= redAlpha or: [
			previousGreenAlpha ~= greenAlpha or: [
			previousBlueAlpha ~= blueAlpha ]]) ifTrue: [
				alphaWord at: 3 put: redAlpha.
				alphaWord at: 2 put: greenAlpha.
				alphaWord at: 1 put: blueAlpha.
				mask bytesAt: pixelIndex put: alphaWord ].

			"leer el nuevo" 
			pixelIndex _ pixY * targetWidth +  pixX.
			pixelIndex _ pixelIndex + 1.
			alphaWord _ mask bytesAt: pixelIndex.
			redAlpha _ alphaWord at: 3.
			greenAlpha _ alphaWord at: 2.
			blueAlpha _ alphaWord at: 1.
			previousRedAlpha _ redAlpha.
			previousGreenAlpha _ greenAlpha.
			previousBlueAlpha _ blueAlpha.
			].
		
		"Minimizar"
		dy _ pixY - p y.
		dySquared _ dy * dy.
		dx _ pixX - p x.
		"Red"
		dxp _ dx - subPixelDelta.
		dxSquared _ dxp * dxp.
		distanceToAxisSquared _ dxSquared + dySquared.
		distanceToAxisSquared < strokeWidthDilatedHalfSquared
			ifTrue: [
				alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
					ifTrue: [ 16r7F ]
					ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
				alpha > redAlpha ifTrue: [
					redAlpha _ alpha ]].
		"Green"
		dxSquared _ dx * dx.
		distanceToAxisSquared _ dxSquared + dySquared.
		distanceToAxisSquared < strokeWidthDilatedHalfSquared
			ifTrue: [
				alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
					ifTrue: [ 16r7F ]
					ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
				alpha > greenAlpha ifTrue: [
					greenAlpha _ alpha ]].
		"Blue"
		dxp _ dx + subPixelDelta.
		dxSquared _ dxp * dxp.
		distanceToAxisSquared _ dxSquared + dySquared.
		distanceToAxisSquared < strokeWidthDilatedHalfSquared
			ifTrue: [
				alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
					ifTrue: [ 16r7F ]
					ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
				alpha > blueAlpha ifTrue: [
					blueAlpha _ alpha ]].
	].

	"escribir el ultimo"
	(previousRedAlpha ~= redAlpha or: [
	previousGreenAlpha ~= greenAlpha or: [
	previousBlueAlpha ~= blueAlpha ]]) ifTrue: [
		alphaWord at: 3 put: redAlpha.
		alphaWord at: 2 put: greenAlpha.
		alphaWord at: 1 put: blueAlpha.
		mask bytesAt: pixelIndex put: alphaWord ]! !

!VectorEngine03 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: theta start: startAngle sweep: sweepAngle
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black fillColor: Color red do: [ :engine |
		engine basicArcCenterX: 100 centerY: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.
"
	| d hops angle thetaCos thetaSin xp yp x0 y0 x y |
	
	"Por supuesto probar tambien rx no igual a ry, y uno (o ambos) menor que el ancho de trazo..."
	thetaCos _ theta cos.
	thetaSin _ theta sin.
	angle _ startAngle.
	xp _ angle cos * rx.
	yp _ angle sin * ry.
	x0 _ thetaCos * xp - (thetaSin * yp) + cx.
	y0 _ thetaSin * xp + (thetaCos * yp) + cy.
	(startAngle ~= 0.0 or: [ sweepAngle ~= Float twoPi ])
		ifTrue: [ self basicLineToX: x0 y: y0 ]	"Draw a line. There are cases where we want to join an arc. For example, window frames"
		ifFalse: [
			"trajectory starts here. Eventually, #closePath should draw a line to here"
			"Next point will be first in a new trajectory fragment"
			prevYTruncated _ nil.
			firstX _ x0.
			firstY _ y0.
			self addPenPositionX: x0 y: y0 ].
	hops _ ((rx+ry * 4 * sweepAngle abs / (2*Float pi)) * hopsPerPixel) truncated + 1.
	d _ sweepAngle / hops.
	hops timesRepeat: [
		angle _ angle + d.
		xp _ angle cos * rx.
		yp _ angle sin * ry.
		x _ thetaCos * xp - (thetaSin * yp) + cx.
		y _ thetaSin * xp + (thetaCos * yp) + cy.
		self addPenPositionX: x y: y ].

	currentX _ x.
	currentY _ y.

	self updateMask! !

!VectorEngine03 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
basicArcToX: x2 y: y2 radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"
	"Calcular: cx, cy, rx, ry, phi, theta1, deltaTheta"
	| x1 y1 cosPhi sinPhi x12hd y12hd x1p y1p rxSq rySq x1pSq y1pSq bigSqR bigSqRNumerator bigSqRDenominator sign cxp cyp cx cy theta1 theta2 deltaTheta scaleSq scale newRx newRy |
	x1 _ currentX.
	y1 _ currentY.
	"Handle out of range parameters as requested by the w3 implementation notes"
	(x2 = x1 and: [ y2 = y1 ]) ifTrue: [ ^self ].
	(rx = 0.0 or: [ ry = 0.0 ]) ifTrue: [ ^self basicLineToX: x2 y: y2 ].
	rx < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: 0.0 -rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	ry < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: rx radiusY: 0.0-ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	
	cosPhi _ phi cos.
	sinPhi _ phi sin.
	"step 1 in http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes"
	x12hd _ (x1-x2) * 0.5.
	y12hd _ (y1-y2) * 0.5.
	x1p _ (cosPhi * x12hd) + (sinPhi * y12hd).
	y1p _ (cosPhi * y12hd) - (sinPhi * x12hd).

	"step 2"
	rxSq _ rx * rx.
	rySq _ ry * ry.
	x1pSq _ x1p * x1p.
	y1pSq _ y1p * y1p.
	"ensure radii are large enough"
	scaleSq _ (x1pSq / rxSq) + (y1pSq / rySq).
	scaleSq > 1 ifTrue: [
		scale _ scaleSq sqrt.
		newRx _ scale * rx.
		newRy _ scale * ry.
		(newRx = rx or: [ newRy = ry ]) ifTrue: [		"This happens when scaleSq is so close to 1, that the multiplication rounds to the same numbers"
			newRx _ scaleSq * rx.
			newRy _ scaleSq * ry ].
		^self basicArcToX: x2 y: y2 radiusX: newRx radiusY: newRy angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
		].
	bigSqRNumerator _ (rxSq * rySq) - (rxSq * y1pSq)-(rySq * x1pSq).
	bigSqRDenominator _ (rxSq * y1pSq) + (rySq * x1pSq).
	sign _ doLargerArc = useIncreasingAngles ifTrue: [ -1 ] ifFalse: [ 1 ].
	bigSqR _ (bigSqRNumerator / bigSqRDenominator max: 0.0) sqrt * sign.		"This only can be < 0.0 because of rounding errors. Take 0.0 in such cases."
	cxp _ bigSqR * rx * y1p / ry.
	cyp _ 0.0 - (bigSqR * ry * x1p / rx).

	"step 3"
	cx _ (cosPhi * cxp) - (sinPhi * cyp) + ((x1+x2) * 0.5).
	cy _ (sinPhi * cxp) + (cosPhi * cyp) + ((y1+y2) * 0.5).
	
"
| u v a |
Transcript clear.
u _ 1@4. v _ 7@2.
a _ ((u dotProduct: v) / (u r * v r) ) arcCos.
a _ a * (((u x * v y) - (u y * v x)) sign).
a print.
(v theta - u theta) print.
Ojo al primitivizar. Para ellos, el theta va entre -pi y pi. Para Squeak va entre cero y 2pi...
"

	"step 4"
	"Ojo signo del angulo y del eje y!!!!!!!!!!"
	theta1 _ (((x1p - cxp) / rx) @ ((y1p - cyp) / ry)) theta.
	theta2 _ (((0 - x1p - cxp) / rx) @ (( 0 -y1p - cyp) / ry)) theta.
	deltaTheta _ theta2 - theta1.
	useIncreasingAngles = (deltaTheta > 0) ifFalse: [
		deltaTheta > 0
			ifTrue: [ deltaTheta _ deltaTheta - Float pi - Float pi ]
			ifFalse: [ deltaTheta _ deltaTheta + Float pi + Float pi ]
		].
	"Y aca calcular como dar vuelta deltaTheta, ver."


	"Finalmente, estudiar la correccion de valores fuera de rango"
	

	self basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: phi start: theta1 sweep: deltaTheta! !

!VectorEngine03 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
basicClosePath
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			do_ClosePath ].
Display forceToScreen
"
	self basicLineToX: firstX y: firstY! !

!VectorEngine03 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
basicCubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	| dx dy hops increment t x0 y0 oneLessT f2 f3 f1 f23 f4 x y |

	dx _ (x1-currentX) abs + (x2-x1) abs + (x3-x2) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs + (y3-y2) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	"en muchos casos, secuencias de estos,  repetimos puntos, el ultimo de la curva anterior... pensar, etc"
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT * oneLessT.
		f23 _ 3 * oneLessT * t.
		f2 _ f23 * oneLessT.
		f3 _ f23 * t.
		f4 _ t * t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2) + (f4 * x3).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2) + (f4 * y3).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x3 y: y3.

	currentX _ x3.
	currentY _ y3.

	self updateMask! !

!VectorEngine03 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
basicHorizontalLineToX: x2
	| distanceToAxis |	

	maskBoundsTop _ (currentY - strokeWidthDilatedHalf) truncated +1.
	maskBoundsBottom _ (currentY + strokeWidthDilatedHalf) truncated.
	maskBoundsLeft _ (currentX min: x2) truncated +1.
	maskBoundsRight _ (currentX max: x2) truncated.
	maskBoundsTop < clipTop ifTrue: [ maskBoundsTop _ clipTop ].
	maskBoundsBottom > clipBottom ifTrue: [ maskBoundsBottom _ clipBottom ].
	maskBoundsLeft< clipLeft ifTrue: [ maskBoundsLeft _ clipLeft ].
	maskBoundsRight > clipRight ifTrue: [ maskBoundsRight _ clipRight ].

	"Paralelizar en displayX@displayY"
	maskBoundsTop to: maskBoundsBottom do: [ :displayY |
		distanceToAxis _ (displayY - currentY) abs.
		maskBoundsLeft to: maskBoundsRight do: [ :displayX |
			self updateMaskForYDistanceToAxis: distanceToAxis displayX: displayX displayY: displayY ]].

	"Include updated mask in area to blend."
	blendBoundsTop _ blendBoundsTop min: maskBoundsTop.
	blendBoundsBottom _ blendBoundsBottom max: maskBoundsBottom.
	blendBoundsLeft _ blendBoundsLeft min: maskBoundsLeft.
	blendBoundsRight _ blendBoundsRight max: maskBoundsRight.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."! !

!VectorEngine03 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
basicLineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 300 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 25.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 500 y: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 30 y: 15.
		engine abs_LineToX: 45 y: 90.
		engine abs_LineToX: 180 y: 30 ].
Display forceToScreen
"
	| dx dy hops incrementX incrementY x y |
	dy _ y2 - currentY.
	dx _ x2 - currentX.
	dx * dy = 0.0
		ifTrue: [
			self addPenPositionX: currentX y: currentY.
			self updateMask.
			dy = 0.0  	"or else it means dx = 0.0"
				ifTrue: [ self basicHorizontalLineToX: x2 ]
				ifFalse: [ self basicVerticalLineToY: y2 ]]
		ifFalse: [
			maskBoundsTop _ maskBoundsTop min: currentY.
			maskBoundsBottom _ maskBoundsBottom max: currentY.
			maskBoundsLeft _ maskBoundsLeft min: currentX.
			maskBoundsRight _ maskBoundsRight max: currentX.
			x _ currentX.
			y _ currentY.
			hops _ ((dx abs max: dy abs) * hopsPerPixel) truncated + 1.
			incrementX _ dx *1.0 / hops.
			incrementY _ dy *1.0 / hops.
			doFill
				ifTrue: [
					hops timesRepeat: [
						trajectoryPoints add: x@y.
						self updateEdgeCountAtX: x y: y.
						x _ x + incrementX.
						y _ y + incrementY ]]
				ifFalse: [
					hops timesRepeat: [
						trajectoryPoints add: x@y.
						x _ x + incrementX.
						y _ y + incrementY ]]
		].
	currentX _ x2.
	currentY _ y2.
	self addPenPositionX: currentX y: currentY.
	self updateMask! !

!VectorEngine03 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
basicMoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150;
			abs_MoveToX: 210 y: 150;
			abs_LineToX: 300 y: 200 ].
Display forceToScreen
"

	"A discontinuity in the trajectory"

	"We are starting a new trajectory, or at a discontinuity in trajectory.
	Eventually #closeTrajectory should draw a line to here"

	"Next point will be first in a new trajectory fragment"
	prevYTruncated _ nil.
	firstX _ x.
	firstY _ y.
	currentX _ x.
	currentY _ y.! !

!VectorEngine03 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:27:01'!
basicQuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| dx dy hops increment t x0 y0 oneLessT f1 f3 f2 x y |
	dx _ (x1-currentX) abs + (x2-x1) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT.
		f2 _ 2* oneLessT * t.
		f3 _ t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x2 y: y2.

	currentX _ x2.
	currentY _ y2.

	self updateMask! !

!VectorEngine03 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 10:27:02'!
basicVerticalLineToY: y2
	| distanceToAxisB distanceToAxisG distanceToAxisR |	

	doFill ifTrue: [
		currentY to: y2 by: (y2-currentY) sign do: [ :y |
			self updateEdgeCountAtX: currentX y: y ]].

	maskBoundsTop _ (currentY min: y2) truncated +1.
	maskBoundsBottom _ (currentY max: y2) truncated.
	maskBoundsLeft _ (currentX - strokeWidthDilatedHalf - subPixelDelta) truncated +1.
	maskBoundsRight _ (currentX + strokeWidthDilatedHalf + subPixelDelta) truncated.
	maskBoundsTop < clipTop ifTrue: [ maskBoundsTop _ clipTop ].
	maskBoundsBottom > clipBottom ifTrue: [ maskBoundsBottom _ clipBottom ].
	maskBoundsLeft< clipLeft ifTrue: [ maskBoundsLeft _ clipLeft ].
	maskBoundsRight > clipRight ifTrue: [ maskBoundsRight _ clipRight ].

	"Paralelizar en displayX@displayY"
	maskBoundsLeft to: maskBoundsRight do: [ :displayX |
		distanceToAxisR _ (displayX - subPixelDelta - currentX) abs.
		distanceToAxisG _ (displayX - currentX) abs.
		distanceToAxisB _ (displayX + subPixelDelta - currentX) abs.
		maskBoundsTop to: maskBoundsBottom do: [ :displayY |
			self updateMaskForXDistanceToAxis: distanceToAxisR g: distanceToAxisG b: distanceToAxisB displayX: displayX displayY: displayY ]].

	"Include updated mask in area to blend."
	blendBoundsTop _ blendBoundsTop min: maskBoundsTop.
	blendBoundsBottom _ blendBoundsBottom max: maskBoundsBottom.
	blendBoundsLeft _ blendBoundsLeft min: maskBoundsLeft.
	blendBoundsRight _ blendBoundsRight max: maskBoundsRight.

	maskBoundsTop _ targetHeight.				"drawable bottom. Will later be refined."
	maskBoundsBottom _ 0.						"drawable top. Will later be refined."
	maskBoundsLeft _ targetWidth.				"drawable right. Will later be refined."
	maskBoundsRight _ 0.							"drawable left. Will later be refined."! !

!VectorEngine03 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:27:02'!
blendFillOnly

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.

			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendFillOnlyAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine03 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:27:02'!
blendFillOnlyAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends fill over background. Despite method selector, there might be a very thin stroke of the same color as the fill. Handle this by adjusting antiAliasAlphas.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	"In this method, antiAliasAlphas are not used to blend stroke, but fill. This means that in the inside of the shape, and away from the stroke, they must be 1.0 (not 0.0)."
	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	isRedInside ifTrue: [ antiAliasRedAlpha _ 1.0 - antiAliasRedAlpha ].
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	isGreenInside ifTrue: [ antiAliasGreenAlpha _ 1.0 - antiAliasGreenAlpha ].
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	isBlueInside ifTrue: [ antiAliasBlueAlpha _ 1.0 - antiAliasBlueAlpha ].
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * fillAlphaToUse.
	resultR _ alpha * fillRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * fillAlphaToUse.
	resultG _ alpha * fillGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * fillAlphaToUse.
	resultB _ alpha * fillBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine03 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:27:02'!
blendStrokeAndFill

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.
			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendStrokeAndFillAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine03 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:27:02'!
blendStrokeAndFillAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Do an appropriate (anti aliased) mix between stoke and fill (or pick just stroke or just fill). Blend this over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha foreComponent strokeAlphaToUse fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	isRedInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse.
			foreComponent _ strokeRed ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse + ((1-antiAliasRedAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasRedAlpha * strokeRed + ((1-antiAliasRedAlpha) * fillRed) ].
	resultR _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	isGreenInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
			foreComponent _ strokeGreen ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse + ((1-antiAliasGreenAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasGreenAlpha * strokeGreen + ((1-antiAliasGreenAlpha) * fillGreen) ].
	resultG _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	isBlueInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
			foreComponent _ strokeBlue ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse + ((1-antiAliasBlueAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasBlueAlpha * strokeBlue + ((1-antiAliasBlueAlpha) * fillBlue) ].
	resultB _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine03 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:27:02'!
blendStrokeOnly

	| pixelIndex m |
	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.
				(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
					self blendStrokeOnlyAtX: displayX y: displayY pixelIndex: pixelIndex ]]].

	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine03 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 10:27:02'!
blendStrokeOnlyAtX: x y: y pixelIndex: pixelIndex

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends stroke over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha strokeAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		^self].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.

	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * strokeAlphaToUse.
	resultR _ alpha * strokeRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
	resultG _ alpha * strokeGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
	resultB _ alpha * strokeBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine03 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:27:02'!
experLinesAndShapes
	"
	self experLinesAndShapes
	"
	| engine y1 yy2 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		yy2 _ y2 >= 1 ifTrue: [ VectorEngine defaultAntiAliasingWidth * 0.5 ] ifFalse: [0].
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1+yy2; abs_LineToX: 530 y: y1+yy2+dy;
				abs_LineToX: 530 y: y1+y2-yy2+dy; abs_LineToX: 431 y: y1+y2-yy2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1+yy2 y: 431; abs_LineToX: y1+yy2+dy y: 530;
				abs_LineToX: y1+y2-yy2+dy y: 530; abs_LineToX: y1+y2-yy2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill."
		engine fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		"solo stroke, no fill"
		engine strokeWidth: y2 color: Color black do: [
			engine
				abs_MoveToX: y2*0.5+731 y: y2*0.5 + y1+dy+dy+dy; abs_LineToX: 830 y: y2 * 0.5 + y1  + dy + dy+dy+dy.
			engine
				abs_MoveToX: y2*0.5 + y1+dy+dy+dy y: y2*0.5+731; abs_LineToX: y2 * 0.5 + y1  + dy + dy+dy+dy y: 830 ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine03 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:27:02'!
experLinesAndShapes2
	"
	self experLinesAndShapes2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth*4*2.
	15 timesRepeat: [
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 1.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 131 y: y1; abs_LineToX: 230 y: y1+dy;
				abs_LineToX: 230 y: y1+y2+dy; abs_LineToX: 131 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX: y1 y: 131; abs_LineToX: y1+dy y: 230;
				abs_LineToX: y1+y2+dy y: 230; abs_LineToX: y1+y2 y: 131;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.8 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 231 y: y1+dy; abs_LineToX: 330 y: y1+dy+dy;
				abs_LineToX: 330 y: y1+y2+dy+dy; abs_LineToX: 231 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 231; abs_LineToX: y1+dy+dy y: 330;
				abs_LineToX: y1+y2+dy+dy y: 330; abs_LineToX: y1+y2+dy y: 231;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.6 color: Color green fillColor: Color red do: [.
			engine
				abs_MoveToX: 331 y: y1+dy+dy; abs_LineToX: 430 y: y1+dy+dy+dy;
				abs_LineToX: 430 y: y1+y2+dy+dy+dy; abs_LineToX: 331 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 331; abs_LineToX: y1+dy+dy+dy y: 430;
				abs_LineToX: y1+y2+dy+dy+dy y: 430; abs_LineToX: y1+y2+dy+dy y: 331;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.4 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 431 y: y1+dy+dy+dy; abs_LineToX: 530 y: y1+dy+dy+dy+dy;
				abs_LineToX: 530 y: y1+y2+dy+dy+dy+dy; abs_LineToX: 431 y: y1+y2+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy+dy y: 431;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.2 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 531 y: y1+dy+dy+dy+dy; abs_LineToX: 630 y: y1+dy+dy+dy+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy+dy+dy+dy; abs_LineToX: 531 y: y1+y2+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy y: 531; abs_LineToX: y1+dy+dy+dy+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 630; abs_LineToX: y1+y2+dy+dy+dy+dy y: 531;
				do_ClosePath ].
		"Solo fill. w chico. Preferimos ya usarlo para definir mejor el shape (se transparentaria demasiado)"
		engine strokeWidth: 0.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy+dy+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 print.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine03 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:27:02'!
experLinesAndShapes3
	"
	self experLinesAndShapes3
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.4 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine03 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:27:02'!
experLinesAndShapes4
	"
	self experLinesAndShapes4
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*1.5 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine03 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:27:02'!
experLinesAndShapesx
	"
	self experLinesAndShapesx
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		y2 print.
		"Solo fill. w =0"
		engine strokeWidth: 0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy y: 431;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.! !

!VectorEngine03 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:27:02'!
experLinesAndShapesx2
	"
	self experLinesAndShapesx2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	y1 _ 10.
	dy _ 3.
	y2 _ 0.1.
	y2 print.
	"Solo fill. w =0"
	engine strokeWidth: 0.5 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 10 y: y1+dy+dy; abs_LineToX: 200 y: y1+dy+dy+dy;
			abs_LineToX: 200 y: y1+y2+dy+dy+dy; abs_LineToX: 10 y: y1+y2+dy+dy;
			do_ClosePath.
		engine
			abs_MoveToX: y1+dy+dy y: 10; abs_LineToX: y1+dy+dy+dy y: 200;
			abs_LineToX: y1+y2+dy+dy+dy y: 200; abs_LineToX: y1+y2+dy+dy y: 10;
			do_ClosePath ].
	Display forceToScreen.
! !

!VectorEngine03 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:27:02'!
experimentHopsPerPixel1
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 1: Very thin stroke, the same color as fill
	VectorEngine experimentHopsPerPixel1
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) *10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine03 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:27:02'!
experimentHopsPerPixel2
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 2: Stroke of various widths, no fill
	VectorEngine experimentHopsPerPixel2
	"
	| d engine f1 f2 hops1 hops2 strokeWidth |
	hops1 _ 200.
	hops1 _ 20.
	"
	strokeWidth -> hops2
	1.3 -> 8
	1.5 -> 6
	2 -> 4
	4 -> 3
	6 -> 2
	16 -> 1
	Maybe 10 / strokeWidth + 1 is ok?
	"
	strokeWidth _ 16*2.
	hops2 _ 8*0+1.
	hops2 _ 10.0 / strokeWidth + 1.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f2 displayAt: 220@0.

Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine03 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 10:27:02'!
experimentHopsPerPixel3
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 3: No stroke, just fill
	VectorEngine experimentHopsPerPixel3
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine03 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:27:02'!
experiment1
	"
	No perfecto aun, pero se puede empezar a comparar con
	http://www.hpl.hp.com/research/mmsl/projects/graphics/antialiasing/figure21.htm
	Ni que hablar que es mucho mas rapido...
	self experiment1
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 e f |
engine _ self onForm: Display.
h _ 300.
h _ 490.
h _ 280.
bottom _ 200.
bottom _ 0.
centerX _ 400.
centerX _ 250.
w0 _ 120.0.
hf _ 1.0.
hf _ 1.73.
hf _ 1.71.
y _ nil.
delta _ nil.
	e _ 500@500.
	f _ Form extent: e depth: 32.
	f fillColor: Color transparent..
"	canvas _  self on: f.
	canvas useComponentAlphas."
1 to: "400" 150 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-3 // delta to: 3 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color black ] ifFalse: [ Color white ].
"			color _ color alpha: (((prevY-y) min: (x1-x2)) min: 1)."
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
"
	canvas removeSpuriousTranslucencyFloatAndBlendOver: Color red.
	f writePNGfileNamed: 'pp17.png'
"! !

!VectorEngine03 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:27:02'!
experiment2
	"
	self experiment2
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 |
engine _ self onForm: Display.
h _ 300.
h _ 600.
bottom _ 200.
centerX _ 400.
w0 _ 60.0.
hf _ 1.0.
y _ nil.
delta _ nil.
1 to: 400 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-6 // delta to: 6 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color white ] ifFalse: [ Color black ].
			color _ color alpha: (((prevY-y) min: (x1-x2)) "* 0.3" min: 1).
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
! !

!VectorEngine03 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:27:02'!
experiment3
	"
	self experiment3
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	100 timesRepeat: [
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
		r _ r + w.
		w _ w * 0.8.
		r _ r + w.

	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine03 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 10:27:02'!
experiment4
	"
	self experiment4
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	1 to: 100 do: [ :i |
		r _ r + w.
		w _ 20.0 / i.
		r _ r + w.
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine03 class methodsFor: 'samples' stamp: 'jmv 2/20/2020 12:30:22'!
siemensStar
	"
	self siemensStar display
	"
	| angle backColor canvas count extent foreColor form location offsetFromCenter |
	count _ 32.
	angle _ Float twoPi / count / 2.
	extent _ 512.
	offsetFromCenter _ 0.
	backColor _ `Color gray: 50/255`.
	foreColor _ `Color gray: 200/255`.
	form _ Form extent: extent asPoint depth: 32.
	form fillColor: backColor.
	canvas _ VectorCanvas onForm: form.
	1 to: count do: [ :i |
		location _ AffineTransformation withRadians: i * angle * 2+0.02 scale: extent*0.45 position: extent-1/2.0 + offsetFromCenter.
		canvas engine geometryTransformation: location.
		canvas fillColor: foreColor do: [
			canvas
				moveToX: 0 y: 0;
				lineToX: 1 y: 0;
				lineToX: angle cos y: angle sin;
				lineToX: 0 y: 0.
		].
	].
	^form! !

!VectorEngine03 class methodsFor: 'instance creation' stamp: 'jmv 2/9/2020 10:27:02'!
onForm: aForm

	^ self new setForm: aForm! !

!VectorEngine03 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:27:02'!
antiAliasingWidthForOutlineFonts
	^1.4! !

!VectorEngine03 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:27:02'!
antiAliasingWidthForStrokeFonts
	^1.1! !

!VectorEngine03 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 10:27:02'!
defaultAntiAliasingWidth
	^1.3. "default for graphics"! !

!VectorEngine04 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:09:49'!
antiAliasingWidth: aNumber

	antiAliasingWidth _ aNumber.
	antiAliasingWidthScaledInverse _ 127.0 / antiAliasingWidth! !

!VectorEngine04 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:09:49'!
clipRect: aRectangle 
	"by convention, aRectangle includes left and top but does not include right and bottom.
	We do draw clipRight and clipBottom but not beyond.
	"
	"In targetForm coordinates"
	clipLeft _ aRectangle left.
	clipTop _ aRectangle top.
	clipRight _ aRectangle right - 1.
	clipBottom _ aRectangle bottom - 1! !

!VectorEngine04 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:09:49'!
clippingRectForCurrentMorph
	"In targetForm coordinates.
	Only valid _after_ drawing currentMorph."

	^morphBoundsLeft @ morphBoundsTop corner: morphBoundsRight @ morphBoundsBottom! !

!VectorEngine04 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:09:49'!
currentMorph: aMorph
	currentMorph _ aMorph! !

!VectorEngine04 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:09:49'!
currentOwnerIfClips: currentMorphOwnerOrNil
	currentOwnerIfClips _ currentMorphOwnerOrNil! !

!VectorEngine04 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:09:49'!
geometryTransformation
	^geometryTransformation! !

!VectorEngine04 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:09:49'!
geometryTransformation: aGeometryTransformation
	geometryTransformation _ aGeometryTransformation! !

!VectorEngine04 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 19:09:49'!
fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	doStroke _ false.
	doFill _ true.
	self pvtStrokeWidth: 0.0.
	hopsPerPixel _ 8.										"See #experimentHopsPerPixel3"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ nil. strokeRed _ nil. strokeGreen _ nil. strokeBlue _ nil.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine04 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 19:09:49'!
strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke."

	| strokeAlphaFactor aStrokeWidth |
	doStroke _ true.
	doFill _ false.
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.

	"Strokes we want to show. They are not too thin, or maybe they are, but there's no fill. Make them wide enough to be properly sampled."
	self pvtStrokeWidth: (aStrokeWidth max: antiAliasingWidth).
	strokeAlphaFactor _ aStrokeWidth / strokeWidth.
	hopsPerPixel _ 10.0 / strokeWidth + 1.		"See #experimentHopsPerPixel2"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ nil. fillRed _ nil. fillGreen _ nil. fillBlue _ nil.
	strokeAlpha _ (aStrokeColor alpha * 255.0 * strokeAlphaFactor) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine04 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 19:09:49'!
strokeWidth: clientStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	| aStrokeWidth |

	aStrokeColor ifNil: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	clientStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aFillColor ifNil: [ ^ self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock.
		^ self ].

	doStroke _ true.
	doFill _ true.
	self pvtStrokeWidth: aStrokeWidth.
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"Strokes are really thin, but strokeColor is same as fillColor, so there's no problem sampling them."
			hopsPerPixel _ 8 ]								"See #experimentHopsPerPixel1"
		ifFalse: [
			hopsPerPixel _ 10.0 / strokeWidth + 1 max: 2 ].		"See #experimentHopsPerPixel2. Additionally, fills require at least 2."

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ (aStrokeColor alpha * 255.0) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.2 position: 200@100);
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcToX: center x y: center y radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_CircleCenterX: cx y: cy radius: mr
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_CircleCenterX: 200 y: 150 radius: 80].
Display forceToScreen
"

	| center r |
	center _ geometryTransformation externalizePosition: cx@cy.
	r _ geometryTransformation externalizeScalar: mr.
	self
		basicArcCenterX: center x centerY: center y radiusX: r radiusY: r rotationAngle: 0.0 start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 150 y: 300 radius: 10.
		engine abs_CircleCenterX: 600 y: 400 radius: 6.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 600 y: -200 radius: 10.
		engine abs_CircleCenterX: 100 y: -100 radius: 6.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_CubicBezierToX: 300 y: 100 control1X: 600 y: -200 control2X: 100 y: -100
			].
Display forceToScreen.
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 100 control2X: 100 y: -100
			].
Display forceToScreen
	"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_CubicBezierToX: x3 y: y3 control1X: mirroredContolX y: mirroredContolY control2X: x2 y: y2! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"
	| p1 p2 p3 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	p3 _ geometryTransformation externalizePosition: x3@y3.
	self basicCubicBezierToX: p3 x y: p3 y control1X: p1 x y: p1 y control2X: p2 x y: p2 y.
	lastClientX _ x3.
	lastClientY _ y3.
	lastControlX _ x2.
	lastControlY _ y2! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta start: startAngle sweep: sweepAngle
	"Currently draws a line from currentX@currentY to start (if startAngle ~= 0.0 or sweepAngle ~= Float twoPi).
	This could be useful for proper fills. But might not be what is desired in some cases.
	Implement desired behavior when clear."
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.0 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6].
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 350 radiusX: 100 radiusY: 50 rotationAngle: 0.5 start: 0.1 sweep: 6 ].
Display forceToScreen.
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: startAngle sweep:  sweepAngle! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_LineToX: x2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: x2 y: lastClientY! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p2 |
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicLineToX: p2 x y: p2 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_LineToY: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToY: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToY: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX y: y2! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p |
	p _ geometryTransformation externalizePosition: x@y.
	self basicMoveToX: p x y: p y.
	lastClientX _ x.
	lastClientY _ y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 450 y: 300 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 750 y: -100 radius: 10.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_QuadraticBezierToX: 300 y: 100 controlX: 750 y: -100
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			abs_QuadraticBezierSmoothToX: 300 y: 100
			].
Display forceToScreen
"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_QuadraticBezierToX: x2 y: y2 controlX: mirroredContolX y: mirroredContolY! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
abs_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| p1 p2 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicQuadraticBezierToX: p2 x y: p2 y controlX: p1 x y: p1 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ x1.
	lastControlY _ y1! !

!VectorEngine04 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
do_ClosePath
	"abs/rel meaningless here"
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200;
			abs_CubicBezierToX: 300 y: 120 control1X: 310 y: 110 control2X: 200 y: 200;
			do_ClosePath;
			abs_LineToX: 150 y: 300 ].
Display forceToScreen
"
	| p2 |
	self basicClosePath.

	p2 _ geometryTransformation internalizePosition: currentX@currentY.
	lastClientX _ p2 x.
	lastClientY _ p2 y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine04 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
rel_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			rel_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false;
			do_ClosePath ].
"
	self abs_ArcToX: lastClientX + cx y: lastClientY + cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine04 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
rel_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierToX: 300 y: 300 control1X: 0 y: 0 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierSmoothToX: 600 y: 100 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"

	self
		abs_CubicBezierSmoothToX: lastClientX + x3 y: lastClientY + y3
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine04 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
rel_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ];
	strokeWidth: 1.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ];
	strokeWidth: 10 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	self
		abs_CubicBezierToX: lastClientX + x3 y: lastClientY + y3
		control1X: lastClientX + x1 y: lastClientY + y1
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine04 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
rel_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine04 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
rel_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_MoveToX: lastClientX + x y: lastClientY + y! !

!VectorEngine04 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
rel_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 550 y: 350 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 850 y: -50 radius: 10.
		engine abs_MoveToX: 700 y: 150.
		engine
			rel_QuadraticBezierToX: -300 y: -50 controlX: 150 y: -200
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			rel_QuadraticBezierSmoothToX: -300 y: -50
			].
Display forceToScreen
"
	self
		abs_QuadraticBezierSmoothToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine04 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:09:49'!
rel_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ];
	strokeWidth: 3.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ];
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color green alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	self
		abs_QuadraticBezierToX: lastClientX + x2 y: lastClientY + y2
		controlX: lastClientX + x1 y: lastClientY + y1! !

!VectorEngine04 methodsFor: 'text' stamp: 'jmv 2/9/2020 19:09:49'!
displayString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aFont color: aColor canvas: aCanvas
	"geometryTransformation is already set to honor font pointSize
	Use as little of aFont as possible!!"
	| glyph destX destY loc |

	self antiAliasingWidth: VectorEngine antiAliasingWidthForOutlineFonts.
	loc _ geometryTransformation.
	self fillColor: aColor do: [
		destY _ aPoint y.
		destX _ aPoint x.
		startIndex to: stopIndex do: [ :charIndex |
			glyph _ aFont ttGlyphAt: (aString at: charIndex).
			glyph isComposite
				ifFalse: [
					glyph contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ].
					]]
				ifTrue: [
					glyph txAndContoursDo: [ :tx :contours |contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ (loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated) composedWith: tx.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ]]]
					].
			destX _ destX + glyph advanceWidth.
		]
	].
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth! !

!VectorEngine04 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:09:49'!
addPenPositionX: x y: y

"
Inlinear en senders. Extraer afectar bounds si es posible (linea, circulo)
"

	trajectoryPoints add: x@y.

	blendBoundsTop _ blendBoundsTop min: y.
	blendBoundsBottom _ blendBoundsBottom max: y.
	blendBoundsLeft _ blendBoundsLeft min: x.
	blendBoundsRight _ blendBoundsRight max: x.

	"Compute edges intersecting with this horizontal line, for fills."
	doFill ifTrue: [
		self updateEdgeCountAtX: x y: y ].! !

!VectorEngine04 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:09:49'!
finishPath
	"Blend stroke and/or fill over background, according to the just computed pen alphas (distance from pixel to center of stroke)"

	blendBoundsTop _ (blendBoundsTop - strokeWidthDilatedHalf) truncated +1.
	blendBoundsBottom _ (blendBoundsBottom + strokeWidthDilatedHalf) truncated.
	blendBoundsLeft _ (blendBoundsLeft - strokeWidthDilatedHalf - subPixelDelta) truncated +1.
	blendBoundsRight _ (blendBoundsRight + strokeWidthDilatedHalf + subPixelDelta) truncated.
	blendBoundsTop < clipTop ifTrue: [ blendBoundsTop _ clipTop ].
	blendBoundsBottom > clipBottom ifTrue: [ blendBoundsBottom _ clipBottom ].
	blendBoundsLeft< clipLeft ifTrue: [ blendBoundsLeft _ clipLeft ].
	blendBoundsRight > clipRight ifTrue: [ blendBoundsRight _ clipRight ].
	
	"If we are doing a fill, and caller forgot to close the trajectory, then do it anyway."
	doFill ifTrue: [
		(firstX = currentX and: [ firstY = currentY ]) ifFalse: [
			"This is actually an error condition. If we are asked to fill, then the path should be closed.
			This is a workaround. If width > 0.0, we'll be adding a visible edge to the path."
			self basicClosePath ]].

	doFill ifTrue: [
		doStroke
			ifTrue: [ self blendStrokeAndFill ]
			ifFalse: [ self blendFillOnly ]]
		ifFalse: [
		self blendStrokeOnly ].
	morphBoundsTop _ morphBoundsTop min: blendBoundsTop.
	morphBoundsBottom _ morphBoundsBottom max: blendBoundsBottom.
	morphBoundsLeft _ morphBoundsLeft min: blendBoundsLeft.
	morphBoundsRight _ morphBoundsRight max: blendBoundsRight.

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.

	Display forceToScreen! !

!VectorEngine04 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:09:49'!
initialize
	geometryTransformation _ MorphicTranslation new. "Identity"! !

!VectorEngine04 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:09:49'!
initializePath

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.
	trajectoryPoints _ OrderedCollection new.
	prevYTruncated _ nil.

	blendBoundsTop _ targetHeight.			"drawable bottom. Will later be refined."
	blendBoundsBottom _ 0.						"drawable top. Will later be refined."
	blendBoundsLeft _ targetWidth.			"drawable right. Will later be refined."
	blendBoundsRight _ 0.						"drawable left. Will later be refined."! !

!VectorEngine04 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:09:49'!
pvtStrokeWidth: aNumber
	strokeWidth _ aNumber.
	strokeWidthDilatedHalf _ strokeWidth + antiAliasingWidth * 0.5.
	strokeWidthDilatedHalfSquared _ strokeWidthDilatedHalf * strokeWidthDilatedHalf.
	strokeWidthErodedHalf _ strokeWidth - antiAliasingWidth * 0.5.
	strokeWidthErodedHalfSquared _ strokeWidthErodedHalf * strokeWidthErodedHalf * strokeWidthErodedHalf sign! !

!VectorEngine04 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:09:49'!
resetMorphBounds

	morphBoundsTop _ targetHeight - 1.
	morphBoundsBottom _ 0.
	morphBoundsLeft _ targetWidth - 1.
	morphBoundsRight _ 0! !

!VectorEngine04 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:09:49'!
setForm: aForm
	"
	World extent: World extent
	"
	| hack s |
	targetForm _ aForm.
	targetWidth _ aForm width.
	targetHeight _ aForm height.
	self resetMorphBounds.
	self clipRect: (0@0 corner: targetWidth@targetHeight).
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth.
	subPixelDelta _ 0.25. "Values closer to 0.333 might produce a bit of coloring on some displays. Used to be 0.28"
	s _ aForm bits size.
	(mask isNil or: [ mask size ~= s ])
		ifTrue: [
			mask _ WordArray new: s.
			edgeCountPerPixel _ WordArray new: s.
			morphAtPixel _ Array new: s.
			hack _ Form extent: targetWidth@targetHeight depth: 32 bits: mask.
			auxBitBlt _ BitBlt toForm: hack.
			auxBitBlt fillBitmap: (Bitmap with: 16rFF000000).
			auxBitBlt combinationRule: Form over ].

	"Perhaps this should be done in an ifCurtailed: block in case of Morphic drawing failure..."
	auxBitBlt destRect: targetForm boundingBox.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	morphAtPixel atAllPut: 0! !

!VectorEngine04 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:09:49'!
updateEdgeCountAtX: x y: y
	| thisYTruncated pixelY pixelIndexBase redPixelIndex greenPixelIndex bluePixelIndex increment countWord redCount greenCount blueCount redOffset greenOffest blueOffset |

	thisYTruncated _ (y truncated max: clipTop-1) min: clipBottom-1.
	prevYTruncated ifNil: [ 
		^ prevYTruncated _ thisYTruncated ].
	thisYTruncated = prevYTruncated ifTrue: [
		^ prevYTruncated _ thisYTruncated ].

	thisYTruncated > prevYTruncated
		ifTrue: [
			pixelY _ thisYTruncated.
			increment _ 1 ]
		ifFalse: [
			pixelY _ prevYTruncated.
			increment _ -1 ].

	"All edge count at the left of the clipRect are added there (at the left of the clipRect).
	The effect is the same, and we need to clean up less stuff afterwards.
	More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses."
	pixelIndexBase _ pixelY * targetWidth + 1.
	redOffset _ (x+subPixelDelta) truncated + 1 max: clipLeft.
	greenOffest _ x truncated + 1 max: clipLeft.
	blueOffset _ (x-subPixelDelta) truncated + 1 max: clipLeft.
	redPixelIndex _ pixelIndexBase + redOffset.
	greenPixelIndex _ pixelIndexBase + greenOffest.
	bluePixelIndex _ pixelIndexBase + blueOffset.

	"Three possible cases here: RGB in one word (pixel); RG in one, and G in another; R in one, GB in another"
	redPixelIndex = bluePixelIndex
		ifTrue: [						"First case: RGB in the same word"
			redOffset <= clipRight ifTrue: [
				countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
				redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
				countWord at: 3 put: redCount.
				greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
				countWord at: 2 put: greenCount.
				blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
				countWord at: 1 put: blueCount.
				edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].
		]
		ifFalse: [
			redPixelIndex = greenPixelIndex
				ifTrue: [				"Second case: RG in one word, B in following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
				ifFalse: [			"Third case: R in one word, GB in the following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
		].
	prevYTruncated _ thisYTruncated! !

!VectorEngine04 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:09:49'!
updateMask
	"Apdate alpha (transparency) mask using trajectoryPoints."

	| altoBolita anchoBolita |

	"Paralelizar en displayX@displayY"
	"Esto es lo que estoy haciendo ahora. Paralelizar en la bolita, lo mas afuera posible"
"NO OLVIDARSE DE RESPETAR Los clipping bounds!!!!!!"
	altoBolita _ (strokeWidthDilatedHalf * 2) truncated + 1.
	anchoBolita _ ((strokeWidthDilatedHalf + subPixelDelta) * 2) truncated + 1.
	{anchoBolita. altoBolita} print.
	0 to: altoBolita do: [ :i |
		0 to: anchoBolita do: [ :j |
			self updateMaskTotoI: i j: j altoBolita: altoBolita anchoBolita: anchoBolita
			]].
	trajectoryPoints _ OrderedCollection new.! !

!VectorEngine04 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:09:49'!
updateMaskTotoI: i j: j altoBolita: altoBolita anchoBolita: anchoBolita
	
	| pixY pixX writePrev distanceToAxisSquared alpha alphaWord dySquared dx dxSquared dy pixelIndex dxp blueAlpha greenAlpha redAlpha previousBlueAlpha previousGreenAlpha previousRedAlpha |

	pixY _ (trajectoryPoints first y / (altoBolita+1)) truncated * (altoBolita+1) + i.
	pixX _ (trajectoryPoints first x / (anchoBolita+1)) truncated * (anchoBolita+1) + j.
	trajectoryPoints first y - pixY > (altoBolita/2) ifTrue: [ pixY _ pixY + altoBolita+1].
	pixY - trajectoryPoints first y > (altoBolita/2) ifTrue: [ pixY _ pixY - altoBolita-1].
	trajectoryPoints first x - pixX > (anchoBolita/2) ifTrue: [ pixX _ pixX + anchoBolita+1].
	pixX - trajectoryPoints first x > (anchoBolita/2) ifTrue: [ pixX _ pixX - anchoBolita-1].
	
	"Leer el 1ro"
	pixelIndex _ pixY * targetWidth +  pixX.
	pixelIndex _ pixelIndex + 1.
	alphaWord _ mask bytesAt: pixelIndex.
	redAlpha _ alphaWord at: 3.
	greenAlpha _ alphaWord at: 2.
	blueAlpha _ alphaWord at: 1.
	previousRedAlpha _ redAlpha.
	previousGreenAlpha _ greenAlpha.
	previousBlueAlpha _ blueAlpha.
	
	trajectoryPoints do: [ :p |
		
		writePrev _ false.
		p y - pixY > (altoBolita/2) ifTrue: [ pixY _ pixY + altoBolita+1. writePrev _ true].
		pixY - p y > (altoBolita/2) ifTrue: [ pixY _ pixY - altoBolita-1. writePrev _ true].
		p x - pixX > (anchoBolita/2) ifTrue: [ pixX _ pixX + anchoBolita+1. writePrev _ true].
		pixX - p x > (anchoBolita/2) ifTrue: [ pixX _ pixX - anchoBolita-1. writePrev _ true].
		
		writePrev ifTrue: [
			"escribir el anterior"
			(previousRedAlpha ~= redAlpha or: [
			previousGreenAlpha ~= greenAlpha or: [
			previousBlueAlpha ~= blueAlpha ]]) ifTrue: [
				alphaWord at: 3 put: redAlpha.
				alphaWord at: 2 put: greenAlpha.
				alphaWord at: 1 put: blueAlpha.
				mask bytesAt: pixelIndex put: alphaWord ].

			"leer el nuevo" 
			pixelIndex _ pixY * targetWidth +  pixX.
			pixelIndex _ pixelIndex + 1.
			alphaWord _ mask bytesAt: pixelIndex.
			redAlpha _ alphaWord at: 3.
			greenAlpha _ alphaWord at: 2.
			blueAlpha _ alphaWord at: 1.
			previousRedAlpha _ redAlpha.
			previousGreenAlpha _ greenAlpha.
			previousBlueAlpha _ blueAlpha.
			].
		
		"Minimizar"
		dy _ pixY - p y.
		dySquared _ dy * dy.
		dx _ pixX - p x.
		"Red"
		dxp _ dx - subPixelDelta.
		dxSquared _ dxp * dxp.
		distanceToAxisSquared _ dxSquared + dySquared.
		distanceToAxisSquared < strokeWidthDilatedHalfSquared
			ifTrue: [
				alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
					ifTrue: [ 16r7F ]
					ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
				alpha > redAlpha ifTrue: [
					redAlpha _ alpha ]].
		"Green"
		dxSquared _ dx * dx.
		distanceToAxisSquared _ dxSquared + dySquared.
		distanceToAxisSquared < strokeWidthDilatedHalfSquared
			ifTrue: [
				alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
					ifTrue: [ 16r7F ]
					ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
				alpha > greenAlpha ifTrue: [
					greenAlpha _ alpha ]].
		"Blue"
		dxp _ dx + subPixelDelta.
		dxSquared _ dxp * dxp.
		distanceToAxisSquared _ dxSquared + dySquared.
		distanceToAxisSquared < strokeWidthDilatedHalfSquared
			ifTrue: [
				alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
					ifTrue: [ 16r7F ]
					ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
				alpha > blueAlpha ifTrue: [
					blueAlpha _ alpha ]].
	].

	"escribir el ultimo"
	(previousRedAlpha ~= redAlpha or: [
	previousGreenAlpha ~= greenAlpha or: [
	previousBlueAlpha ~= blueAlpha ]]) ifTrue: [
		alphaWord at: 3 put: redAlpha.
		alphaWord at: 2 put: greenAlpha.
		alphaWord at: 1 put: blueAlpha.
		mask bytesAt: pixelIndex put: alphaWord ]! !

!VectorEngine04 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:09:50'!
basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: theta start: startAngle sweep: sweepAngle
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black fillColor: Color red do: [ :engine |
		engine basicArcCenterX: 100 centerY: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.
"
	| d hops angle thetaCos thetaSin xp yp x0 y0 x y |
	
	"Por supuesto probar tambien rx no igual a ry, y uno (o ambos) menor que el ancho de trazo..."
	thetaCos _ theta cos.
	thetaSin _ theta sin.
	angle _ startAngle.
	xp _ angle cos * rx.
	yp _ angle sin * ry.
	x0 _ thetaCos * xp - (thetaSin * yp) + cx.
	y0 _ thetaSin * xp + (thetaCos * yp) + cy.
	(startAngle ~= 0.0 or: [ sweepAngle ~= Float twoPi ])
		ifTrue: [ self basicLineToX: x0 y: y0 ]	"Draw a line. There are cases where we want to join an arc. For example, window frames"
		ifFalse: [
			"trajectory starts here. Eventually, #closePath should draw a line to here"
			"Next point will be first in a new trajectory fragment"
			prevYTruncated _ nil.
			firstX _ x0.
			firstY _ y0.
			self addPenPositionX: x0 y: y0 ].
	hops _ ((rx+ry * 4 * sweepAngle abs / (2*Float pi)) * hopsPerPixel) truncated + 1.
	d _ sweepAngle / hops.
	hops timesRepeat: [
		angle _ angle + d.
		xp _ angle cos * rx.
		yp _ angle sin * ry.
		x _ thetaCos * xp - (thetaSin * yp) + cx.
		y _ thetaSin * xp + (thetaCos * yp) + cy.
		self addPenPositionX: x y: y ].

	currentX _ x.
	currentY _ y.

	self updateMask! !

!VectorEngine04 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:09:50'!
basicArcToX: x2 y: y2 radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"
	"Calcular: cx, cy, rx, ry, phi, theta1, deltaTheta"
	| x1 y1 cosPhi sinPhi x12hd y12hd x1p y1p rxSq rySq x1pSq y1pSq bigSqR bigSqRNumerator bigSqRDenominator sign cxp cyp cx cy theta1 theta2 deltaTheta scaleSq scale newRx newRy |
	x1 _ currentX.
	y1 _ currentY.
	"Handle out of range parameters as requested by the w3 implementation notes"
	(x2 = x1 and: [ y2 = y1 ]) ifTrue: [ ^self ].
	(rx = 0.0 or: [ ry = 0.0 ]) ifTrue: [ ^self basicLineToX: x2 y: y2 ].
	rx < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: 0.0 -rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	ry < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: rx radiusY: 0.0-ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	
	cosPhi _ phi cos.
	sinPhi _ phi sin.
	"step 1 in http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes"
	x12hd _ (x1-x2) * 0.5.
	y12hd _ (y1-y2) * 0.5.
	x1p _ (cosPhi * x12hd) + (sinPhi * y12hd).
	y1p _ (cosPhi * y12hd) - (sinPhi * x12hd).

	"step 2"
	rxSq _ rx * rx.
	rySq _ ry * ry.
	x1pSq _ x1p * x1p.
	y1pSq _ y1p * y1p.
	"ensure radii are large enough"
	scaleSq _ (x1pSq / rxSq) + (y1pSq / rySq).
	scaleSq > 1 ifTrue: [
		scale _ scaleSq sqrt.
		newRx _ scale * rx.
		newRy _ scale * ry.
		(newRx = rx or: [ newRy = ry ]) ifTrue: [		"This happens when scaleSq is so close to 1, that the multiplication rounds to the same numbers"
			newRx _ scaleSq * rx.
			newRy _ scaleSq * ry ].
		^self basicArcToX: x2 y: y2 radiusX: newRx radiusY: newRy angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
		].
	bigSqRNumerator _ (rxSq * rySq) - (rxSq * y1pSq)-(rySq * x1pSq).
	bigSqRDenominator _ (rxSq * y1pSq) + (rySq * x1pSq).
	sign _ doLargerArc = useIncreasingAngles ifTrue: [ -1 ] ifFalse: [ 1 ].
	bigSqR _ (bigSqRNumerator / bigSqRDenominator max: 0.0) sqrt * sign.		"This only can be < 0.0 because of rounding errors. Take 0.0 in such cases."
	cxp _ bigSqR * rx * y1p / ry.
	cyp _ 0.0 - (bigSqR * ry * x1p / rx).

	"step 3"
	cx _ (cosPhi * cxp) - (sinPhi * cyp) + ((x1+x2) * 0.5).
	cy _ (sinPhi * cxp) + (cosPhi * cyp) + ((y1+y2) * 0.5).
	
"
| u v a |
Transcript clear.
u _ 1@4. v _ 7@2.
a _ ((u dotProduct: v) / (u r * v r) ) arcCos.
a _ a * (((u x * v y) - (u y * v x)) sign).
a print.
(v theta - u theta) print.
Ojo al primitivizar. Para ellos, el theta va entre -pi y pi. Para Squeak va entre cero y 2pi...
"

	"step 4"
	"Ojo signo del angulo y del eje y!!!!!!!!!!"
	theta1 _ (((x1p - cxp) / rx) @ ((y1p - cyp) / ry)) theta.
	theta2 _ (((0 - x1p - cxp) / rx) @ (( 0 -y1p - cyp) / ry)) theta.
	deltaTheta _ theta2 - theta1.
	useIncreasingAngles = (deltaTheta > 0) ifFalse: [
		deltaTheta > 0
			ifTrue: [ deltaTheta _ deltaTheta - Float pi - Float pi ]
			ifFalse: [ deltaTheta _ deltaTheta + Float pi + Float pi ]
		].
	"Y aca calcular como dar vuelta deltaTheta, ver."


	"Finalmente, estudiar la correccion de valores fuera de rango"
	

	self basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: phi start: theta1 sweep: deltaTheta! !

!VectorEngine04 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:09:50'!
basicClosePath
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			do_ClosePath ].
Display forceToScreen
"
	self basicLineToX: firstX y: firstY! !

!VectorEngine04 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:09:50'!
basicCubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	| dx dy hops increment t x0 y0 oneLessT f2 f3 f1 f23 f4 x y |

	dx _ (x1-currentX) abs + (x2-x1) abs + (x3-x2) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs + (y3-y2) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	"en muchos casos, secuencias de estos,  repetimos puntos, el ultimo de la curva anterior... pensar, etc"
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT * oneLessT.
		f23 _ 3 * oneLessT * t.
		f2 _ f23 * oneLessT.
		f3 _ f23 * t.
		f4 _ t * t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2) + (f4 * x3).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2) + (f4 * y3).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x3 y: y3.

	currentX _ x3.
	currentY _ y3.

	self updateMask! !

!VectorEngine04 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:09:50'!
basicLineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 300 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 25.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 500 y: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 30 y: 15.
		engine abs_LineToX: 45 y: 90.
		engine abs_LineToX: 180 y: 30 ].
Display forceToScreen
"
	| dx dy hops incrementX incrementY x y |
	dy _ y2 - currentY.
	dx _ x2 - currentX.
	"Optimizar. En todas las lineas, bounds. En verticales, mucho mas. En horiz, no EdgeCounts!! Ver 02"
	x _ currentX.
	y _ currentY.
	hops _ ((dx abs max: dy abs) * hopsPerPixel) truncated + 1.
	incrementX _ dx *1.0 / hops.
	incrementY _ dy *1.0 / hops.
	hops timesRepeat: [
		self addPenPositionX: x y: y.
		x _ x + incrementX.
		y _ y + incrementY ].
	currentX _ x2.
	currentY _ y2.
	self addPenPositionX: currentX y: currentY.
	self updateMask! !

!VectorEngine04 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:09:50'!
basicMoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150;
			abs_MoveToX: 210 y: 150;
			abs_LineToX: 300 y: 200 ].
Display forceToScreen
"

	"A discontinuity in the trajectory"

	"We are starting a new trajectory, or at a discontinuity in trajectory.
	Eventually #closeTrajectory should draw a line to here"

	"Next point will be first in a new trajectory fragment"
	prevYTruncated _ nil.
	firstX _ x.
	firstY _ y.
	currentX _ x.
	currentY _ y.! !

!VectorEngine04 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:09:50'!
basicQuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| dx dy hops increment t x0 y0 oneLessT f1 f3 f2 x y |
	dx _ (x1-currentX) abs + (x2-x1) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT.
		f2 _ 2* oneLessT * t.
		f3 _ t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x2 y: y2.

	currentX _ x2.
	currentY _ y2.

	self updateMask! !

!VectorEngine04 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:09:50'!
blendFillOnly

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.

			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendFillOnlyAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine04 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:09:50'!
blendFillOnlyAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends fill over background. Despite method selector, there might be a very thin stroke of the same color as the fill. Handle this by adjusting antiAliasAlphas.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	"In this method, antiAliasAlphas are not used to blend stroke, but fill. This means that in the inside of the shape, and away from the stroke, they must be 1.0 (not 0.0)."
	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	isRedInside ifTrue: [ antiAliasRedAlpha _ 1.0 - antiAliasRedAlpha ].
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	isGreenInside ifTrue: [ antiAliasGreenAlpha _ 1.0 - antiAliasGreenAlpha ].
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	isBlueInside ifTrue: [ antiAliasBlueAlpha _ 1.0 - antiAliasBlueAlpha ].
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * fillAlphaToUse.
	resultR _ alpha * fillRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * fillAlphaToUse.
	resultG _ alpha * fillGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * fillAlphaToUse.
	resultB _ alpha * fillBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine04 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:09:50'!
blendStrokeAndFill

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.
			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendStrokeAndFillAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine04 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:09:50'!
blendStrokeAndFillAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Do an appropriate (anti aliased) mix between stoke and fill (or pick just stroke or just fill). Blend this over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha foreComponent strokeAlphaToUse fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	isRedInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse.
			foreComponent _ strokeRed ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse + ((1-antiAliasRedAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasRedAlpha * strokeRed + ((1-antiAliasRedAlpha) * fillRed) ].
	resultR _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	isGreenInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
			foreComponent _ strokeGreen ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse + ((1-antiAliasGreenAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasGreenAlpha * strokeGreen + ((1-antiAliasGreenAlpha) * fillGreen) ].
	resultG _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	isBlueInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
			foreComponent _ strokeBlue ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse + ((1-antiAliasBlueAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasBlueAlpha * strokeBlue + ((1-antiAliasBlueAlpha) * fillBlue) ].
	resultB _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine04 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:09:50'!
blendStrokeOnly

	| pixelIndex m |
	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.
				(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
					self blendStrokeOnlyAtX: displayX y: displayY pixelIndex: pixelIndex ]]].

	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine04 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:09:50'!
blendStrokeOnlyAtX: x y: y pixelIndex: pixelIndex

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends stroke over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha strokeAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		^self].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.

	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * strokeAlphaToUse.
	resultR _ alpha * strokeRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
	resultG _ alpha * strokeGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
	resultB _ alpha * strokeBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine04 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:09:50'!
experLinesAndShapes
	"
	self experLinesAndShapes
	"
	| engine y1 yy2 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		yy2 _ y2 >= 1 ifTrue: [ VectorEngine defaultAntiAliasingWidth * 0.5 ] ifFalse: [0].
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1+yy2; abs_LineToX: 530 y: y1+yy2+dy;
				abs_LineToX: 530 y: y1+y2-yy2+dy; abs_LineToX: 431 y: y1+y2-yy2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1+yy2 y: 431; abs_LineToX: y1+yy2+dy y: 530;
				abs_LineToX: y1+y2-yy2+dy y: 530; abs_LineToX: y1+y2-yy2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill."
		engine fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		"solo stroke, no fill"
		engine strokeWidth: y2 color: Color black do: [
			engine
				abs_MoveToX: y2*0.5+731 y: y2*0.5 + y1+dy+dy+dy; abs_LineToX: 830 y: y2 * 0.5 + y1  + dy + dy+dy+dy.
			engine
				abs_MoveToX: y2*0.5 + y1+dy+dy+dy y: y2*0.5+731; abs_LineToX: y2 * 0.5 + y1  + dy + dy+dy+dy y: 830 ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine04 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:09:50'!
experLinesAndShapes2
	"
	self experLinesAndShapes2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth*4*2.
	15 timesRepeat: [
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 1.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 131 y: y1; abs_LineToX: 230 y: y1+dy;
				abs_LineToX: 230 y: y1+y2+dy; abs_LineToX: 131 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX: y1 y: 131; abs_LineToX: y1+dy y: 230;
				abs_LineToX: y1+y2+dy y: 230; abs_LineToX: y1+y2 y: 131;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.8 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 231 y: y1+dy; abs_LineToX: 330 y: y1+dy+dy;
				abs_LineToX: 330 y: y1+y2+dy+dy; abs_LineToX: 231 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 231; abs_LineToX: y1+dy+dy y: 330;
				abs_LineToX: y1+y2+dy+dy y: 330; abs_LineToX: y1+y2+dy y: 231;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.6 color: Color green fillColor: Color red do: [.
			engine
				abs_MoveToX: 331 y: y1+dy+dy; abs_LineToX: 430 y: y1+dy+dy+dy;
				abs_LineToX: 430 y: y1+y2+dy+dy+dy; abs_LineToX: 331 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 331; abs_LineToX: y1+dy+dy+dy y: 430;
				abs_LineToX: y1+y2+dy+dy+dy y: 430; abs_LineToX: y1+y2+dy+dy y: 331;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.4 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 431 y: y1+dy+dy+dy; abs_LineToX: 530 y: y1+dy+dy+dy+dy;
				abs_LineToX: 530 y: y1+y2+dy+dy+dy+dy; abs_LineToX: 431 y: y1+y2+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy+dy y: 431;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.2 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 531 y: y1+dy+dy+dy+dy; abs_LineToX: 630 y: y1+dy+dy+dy+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy+dy+dy+dy; abs_LineToX: 531 y: y1+y2+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy y: 531; abs_LineToX: y1+dy+dy+dy+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 630; abs_LineToX: y1+y2+dy+dy+dy+dy y: 531;
				do_ClosePath ].
		"Solo fill. w chico. Preferimos ya usarlo para definir mejor el shape (se transparentaria demasiado)"
		engine strokeWidth: 0.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy+dy+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 print.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine04 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:09:50'!
experLinesAndShapes3
	"
	self experLinesAndShapes3
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.4 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine04 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:09:50'!
experLinesAndShapes4
	"
	self experLinesAndShapes4
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*1.5 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine04 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:09:50'!
experLinesAndShapesx
	"
	self experLinesAndShapesx
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		y2 print.
		"Solo fill. w =0"
		engine strokeWidth: 0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy y: 431;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.! !

!VectorEngine04 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:09:50'!
experLinesAndShapesx2
	"
	self experLinesAndShapesx2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	y1 _ 10.
	dy _ 3.
	y2 _ 0.1.
	y2 print.
	"Solo fill. w =0"
	engine strokeWidth: 0.5 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 10 y: y1+dy+dy; abs_LineToX: 200 y: y1+dy+dy+dy;
			abs_LineToX: 200 y: y1+y2+dy+dy+dy; abs_LineToX: 10 y: y1+y2+dy+dy;
			do_ClosePath.
		engine
			abs_MoveToX: y1+dy+dy y: 10; abs_LineToX: y1+dy+dy+dy y: 200;
			abs_LineToX: y1+y2+dy+dy+dy y: 200; abs_LineToX: y1+y2+dy+dy y: 10;
			do_ClosePath ].
	Display forceToScreen.
! !

!VectorEngine04 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:09:50'!
experimentHopsPerPixel1
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 1: Very thin stroke, the same color as fill
	VectorEngine experimentHopsPerPixel1
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) *10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine04 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:09:50'!
experimentHopsPerPixel2
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 2: Stroke of various widths, no fill
	VectorEngine experimentHopsPerPixel2
	"
	| d engine f1 f2 hops1 hops2 strokeWidth |
	hops1 _ 200.
	hops1 _ 20.
	"
	strokeWidth -> hops2
	1.3 -> 8
	1.5 -> 6
	2 -> 4
	4 -> 3
	6 -> 2
	16 -> 1
	Maybe 10 / strokeWidth + 1 is ok?
	"
	strokeWidth _ 16*2.
	hops2 _ 8*0+1.
	hops2 _ 10.0 / strokeWidth + 1.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f2 displayAt: 220@0.

Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine04 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:09:50'!
experimentHopsPerPixel3
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 3: No stroke, just fill
	VectorEngine experimentHopsPerPixel3
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine04 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 19:09:50'!
experiment1
	"
	No perfecto aun, pero se puede empezar a comparar con
	http://www.hpl.hp.com/research/mmsl/projects/graphics/antialiasing/figure21.htm
	Ni que hablar que es mucho mas rapido...
	self experiment1
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 e f |
engine _ self onForm: Display.
h _ 300.
h _ 490.
h _ 280.
bottom _ 200.
bottom _ 0.
centerX _ 400.
centerX _ 250.
w0 _ 120.0.
hf _ 1.0.
hf _ 1.73.
hf _ 1.71.
y _ nil.
delta _ nil.
	e _ 500@500.
	f _ Form extent: e depth: 32.
	f fillColor: Color transparent..
"	canvas _  self on: f.
	canvas useComponentAlphas."
1 to: "400" 150 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-3 // delta to: 3 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color black ] ifFalse: [ Color white ].
"			color _ color alpha: (((prevY-y) min: (x1-x2)) min: 1)."
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
"
	canvas removeSpuriousTranslucencyFloatAndBlendOver: Color red.
	f writePNGfileNamed: 'pp17.png'
"! !

!VectorEngine04 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 19:09:50'!
experiment2
	"
	self experiment2
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 |
engine _ self onForm: Display.
h _ 300.
h _ 600.
bottom _ 200.
centerX _ 400.
w0 _ 60.0.
hf _ 1.0.
y _ nil.
delta _ nil.
1 to: 400 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-6 // delta to: 6 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color white ] ifFalse: [ Color black ].
			color _ color alpha: (((prevY-y) min: (x1-x2)) "* 0.3" min: 1).
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
! !

!VectorEngine04 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 19:09:50'!
experiment3
	"
	self experiment3
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	100 timesRepeat: [
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
		r _ r + w.
		w _ w * 0.8.
		r _ r + w.

	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine04 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 19:09:50'!
experiment4
	"
	self experiment4
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	1 to: 100 do: [ :i |
		r _ r + w.
		w _ 20.0 / i.
		r _ r + w.
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine04 class methodsFor: 'samples' stamp: 'jmv 2/20/2020 12:30:30'!
siemensStar
	"
	self siemensStar display
	"
	| angle backColor canvas count extent foreColor form location offsetFromCenter |
	count _ 32.
	angle _ Float twoPi / count / 2.
	extent _ 512.
	offsetFromCenter _ 0.
	backColor _ `Color gray: 50/255`.
	foreColor _ `Color gray: 200/255`.
	form _ Form extent: extent asPoint depth: 32.
	form fillColor: backColor.
	canvas _ VectorCanvas onForm: form.
	1 to: count do: [ :i |
		location _ AffineTransformation withRadians: i * angle * 2+0.02 scale: extent*0.45 position: extent-1/2.0 + offsetFromCenter.
		canvas engine geometryTransformation: location.
		canvas fillColor: foreColor do: [
			canvas
				moveToX: 0 y: 0;
				lineToX: 1 y: 0;
				lineToX: angle cos y: angle sin;
				lineToX: 0 y: 0.
		].
	].
	^form! !

!VectorEngine04 class methodsFor: 'instance creation' stamp: 'jmv 2/9/2020 19:09:50'!
onForm: aForm

	^ self new setForm: aForm! !

!VectorEngine04 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:09:50'!
antiAliasingWidthForOutlineFonts
	^1.4! !

!VectorEngine04 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:09:50'!
antiAliasingWidthForStrokeFonts
	^1.1! !

!VectorEngine04 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:09:50'!
defaultAntiAliasingWidth
	^1.3. "default for graphics"! !

!VectorEngine05 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:21:48'!
antiAliasingWidth: aNumber

	antiAliasingWidth _ aNumber.
	antiAliasingWidthScaledInverse _ 127.0 / antiAliasingWidth! !

!VectorEngine05 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:21:48'!
clipRect: aRectangle 
	"by convention, aRectangle includes left and top but does not include right and bottom.
	We do draw clipRight and clipBottom but not beyond.
	"
	"In targetForm coordinates"
	clipLeft _ aRectangle left.
	clipTop _ aRectangle top.
	clipRight _ aRectangle right - 1.
	clipBottom _ aRectangle bottom - 1! !

!VectorEngine05 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:21:48'!
clippingRectForCurrentMorph
	"In targetForm coordinates.
	Only valid _after_ drawing currentMorph."

	^morphBoundsLeft @ morphBoundsTop corner: morphBoundsRight @ morphBoundsBottom! !

!VectorEngine05 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:21:48'!
currentMorph: aMorph
	currentMorph _ aMorph! !

!VectorEngine05 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:21:48'!
currentOwnerIfClips: currentMorphOwnerOrNil
	currentOwnerIfClips _ currentMorphOwnerOrNil! !

!VectorEngine05 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:21:48'!
geometryTransformation
	^geometryTransformation! !

!VectorEngine05 methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:21:48'!
geometryTransformation: aGeometryTransformation
	geometryTransformation _ aGeometryTransformation! !

!VectorEngine05 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 19:21:48'!
fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	doStroke _ false.
	doFill _ true.
	self pvtStrokeWidth: 0.0.
	hopsPerPixel _ 8.										"See #experimentHopsPerPixel3"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ nil. strokeRed _ nil. strokeGreen _ nil. strokeBlue _ nil.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine05 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 19:21:48'!
strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke."

	| strokeAlphaFactor aStrokeWidth |
	doStroke _ true.
	doFill _ false.
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.

	"Strokes we want to show. They are not too thin, or maybe they are, but there's no fill. Make them wide enough to be properly sampled."
	self pvtStrokeWidth: (aStrokeWidth max: antiAliasingWidth).
	strokeAlphaFactor _ aStrokeWidth / strokeWidth.
	hopsPerPixel _ 10.0 / strokeWidth + 1.		"See #experimentHopsPerPixel2"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ nil. fillRed _ nil. fillGreen _ nil. fillBlue _ nil.
	strokeAlpha _ (aStrokeColor alpha * 255.0 * strokeAlphaFactor) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine05 methodsFor: 'stroke & fill' stamp: 'jmv 2/9/2020 19:21:48'!
strokeWidth: clientStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	| aStrokeWidth |

	aStrokeColor ifNil: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	clientStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aFillColor ifNil: [ ^ self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock.
		^ self ].

	doStroke _ true.
	doFill _ true.
	self pvtStrokeWidth: aStrokeWidth.
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"Strokes are really thin, but strokeColor is same as fillColor, so there's no problem sampling them."
			hopsPerPixel _ 8 ]								"See #experimentHopsPerPixel1"
		ifFalse: [
			hopsPerPixel _ 10.0 / strokeWidth + 1 max: 2 ].		"See #experimentHopsPerPixel2. Additionally, fills require at least 2."

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ (aStrokeColor alpha * 255.0) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	self initializePath.
	pathCommandsBlock valueWithPossibleArgument: self.
	self finishPath! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.2 position: 200@100);
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcToX: center x y: center y radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_CircleCenterX: cx y: cy radius: mr
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_CircleCenterX: 200 y: 150 radius: 80].
Display forceToScreen
"

	| center r |
	center _ geometryTransformation externalizePosition: cx@cy.
	r _ geometryTransformation externalizeScalar: mr.
	self
		basicArcCenterX: center x centerY: center y radiusX: r radiusY: r rotationAngle: 0.0 start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 150 y: 300 radius: 10.
		engine abs_CircleCenterX: 600 y: 400 radius: 6.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 600 y: -200 radius: 10.
		engine abs_CircleCenterX: 100 y: -100 radius: 6.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_CubicBezierToX: 300 y: 100 control1X: 600 y: -200 control2X: 100 y: -100
			].
Display forceToScreen.
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 100 control2X: 100 y: -100
			].
Display forceToScreen
	"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_CubicBezierToX: x3 y: y3 control1X: mirroredContolX y: mirroredContolY control2X: x2 y: y2! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"
	| p1 p2 p3 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	p3 _ geometryTransformation externalizePosition: x3@y3.
	self basicCubicBezierToX: p3 x y: p3 y control1X: p1 x y: p1 y control2X: p2 x y: p2 y.
	lastClientX _ x3.
	lastClientY _ y3.
	lastControlX _ x2.
	lastControlY _ y2! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta start: startAngle sweep: sweepAngle
	"Currently draws a line from currentX@currentY to start (if startAngle ~= 0.0 or sweepAngle ~= Float twoPi).
	This could be useful for proper fills. But might not be what is desired in some cases.
	Implement desired behavior when clear."
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.0 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6].
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 350 radiusX: 100 radiusY: 50 rotationAngle: 0.5 start: 0.1 sweep: 6 ].
Display forceToScreen.
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: startAngle sweep:  sweepAngle! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_LineToX: x2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: x2 y: lastClientY! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p2 |
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicLineToX: p2 x y: p2 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_LineToY: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToY: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToY: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX y: y2! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p |
	p _ geometryTransformation externalizePosition: x@y.
	self basicMoveToX: p x y: p y.
	lastClientX _ x.
	lastClientY _ y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 450 y: 300 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 750 y: -100 radius: 10.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_QuadraticBezierToX: 300 y: 100 controlX: 750 y: -100
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			abs_QuadraticBezierSmoothToX: 300 y: 100
			].
Display forceToScreen
"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_QuadraticBezierToX: x2 y: y2 controlX: mirroredContolX y: mirroredContolY! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
abs_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| p1 p2 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicQuadraticBezierToX: p2 x y: p2 y controlX: p1 x y: p1 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ x1.
	lastControlY _ y1! !

!VectorEngine05 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
do_ClosePath
	"abs/rel meaningless here"
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200;
			abs_CubicBezierToX: 300 y: 120 control1X: 310 y: 110 control2X: 200 y: 200;
			do_ClosePath;
			abs_LineToX: 150 y: 300 ].
Display forceToScreen
"
	| p2 |
	self basicClosePath.

	p2 _ geometryTransformation internalizePosition: currentX@currentY.
	lastClientX _ p2 x.
	lastClientY _ p2 y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine05 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
rel_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			rel_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false;
			do_ClosePath ].
"
	self abs_ArcToX: lastClientX + cx y: lastClientY + cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine05 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
rel_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierToX: 300 y: 300 control1X: 0 y: 0 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierSmoothToX: 600 y: 100 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"

	self
		abs_CubicBezierSmoothToX: lastClientX + x3 y: lastClientY + y3
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine05 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
rel_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ];
	strokeWidth: 1.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ];
	strokeWidth: 10 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	self
		abs_CubicBezierToX: lastClientX + x3 y: lastClientY + y3
		control1X: lastClientX + x1 y: lastClientY + y1
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine05 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
rel_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine05 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
rel_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_MoveToX: lastClientX + x y: lastClientY + y! !

!VectorEngine05 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
rel_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 550 y: 350 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 850 y: -50 radius: 10.
		engine abs_MoveToX: 700 y: 150.
		engine
			rel_QuadraticBezierToX: -300 y: -50 controlX: 150 y: -200
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			rel_QuadraticBezierSmoothToX: -300 y: -50
			].
Display forceToScreen
"
	self
		abs_QuadraticBezierSmoothToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine05 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
rel_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ];
	strokeWidth: 3.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ];
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color green alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	self
		abs_QuadraticBezierToX: lastClientX + x2 y: lastClientY + y2
		controlX: lastClientX + x1 y: lastClientY + y1! !

!VectorEngine05 methodsFor: 'text' stamp: 'jmv 2/9/2020 19:21:49'!
displayString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aFont color: aColor canvas: aCanvas
	"geometryTransformation is already set to honor font pointSize
	Use as little of aFont as possible!!"
	| glyph destX destY loc |

	self antiAliasingWidth: VectorEngine antiAliasingWidthForOutlineFonts.
	loc _ geometryTransformation.
	self fillColor: aColor do: [
		destY _ aPoint y.
		destX _ aPoint x.
		startIndex to: stopIndex do: [ :charIndex |
			glyph _ aFont ttGlyphAt: (aString at: charIndex).
			glyph isComposite
				ifFalse: [
					glyph contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ].
					]]
				ifTrue: [
					glyph txAndContoursDo: [ :tx :contours |contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ (loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated) composedWith: tx.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ]]]
					].
			destX _ destX + glyph advanceWidth.
		]
	].
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth! !

!VectorEngine05 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:21:49'!
addPenPositionX: x y: y

"
Inlinear en senders. Extraer afectar bounds si es posible (linea, circulo)
"

	trajectoryPoints add: x@y.

	blendBoundsTop _ blendBoundsTop min: y.
	blendBoundsBottom _ blendBoundsBottom max: y.
	blendBoundsLeft _ blendBoundsLeft min: x.
	blendBoundsRight _ blendBoundsRight max: x.

	"Compute edges intersecting with this horizontal line, for fills."
	doFill ifTrue: [
		self updateEdgeCountAtX: x y: y ].! !

!VectorEngine05 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:21:49'!
finishPath
	"Blend stroke and/or fill over background, according to the just computed pen alphas (distance from pixel to center of stroke)"

	blendBoundsTop _ (blendBoundsTop - strokeWidthDilatedHalf) truncated +1.
	blendBoundsBottom _ (blendBoundsBottom + strokeWidthDilatedHalf) truncated.
	blendBoundsLeft _ (blendBoundsLeft - strokeWidthDilatedHalf - subPixelDelta) truncated +1.
	blendBoundsRight _ (blendBoundsRight + strokeWidthDilatedHalf + subPixelDelta) truncated.
	blendBoundsTop < clipTop ifTrue: [ blendBoundsTop _ clipTop ].
	blendBoundsBottom > clipBottom ifTrue: [ blendBoundsBottom _ clipBottom ].
	blendBoundsLeft< clipLeft ifTrue: [ blendBoundsLeft _ clipLeft ].
	blendBoundsRight > clipRight ifTrue: [ blendBoundsRight _ clipRight ].
	
	"If we are doing a fill, and caller forgot to close the trajectory, then do it anyway."
	doFill ifTrue: [
		(firstX = currentX and: [ firstY = currentY ]) ifFalse: [
			"This is actually an error condition. If we are asked to fill, then the path should be closed.
			This is a workaround. If width > 0.0, we'll be adding a visible edge to the path."
			self basicClosePath ]].

	doFill ifTrue: [
		doStroke
			ifTrue: [ self blendStrokeAndFill ]
			ifFalse: [ self blendFillOnly ]]
		ifFalse: [
		self blendStrokeOnly ].
	morphBoundsTop _ morphBoundsTop min: blendBoundsTop.
	morphBoundsBottom _ morphBoundsBottom max: blendBoundsBottom.
	morphBoundsLeft _ morphBoundsLeft min: blendBoundsLeft.
	morphBoundsRight _ morphBoundsRight max: blendBoundsRight.

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.

	Display forceToScreen! !

!VectorEngine05 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:21:49'!
initialize
	geometryTransformation _ MorphicTranslation new. "Identity"! !

!VectorEngine05 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:21:49'!
initializePath

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.
	trajectoryPoints _ OrderedCollection new.
	prevYTruncated _ nil.

	blendBoundsTop _ targetHeight.			"drawable bottom. Will later be refined."
	blendBoundsBottom _ 0.						"drawable top. Will later be refined."
	blendBoundsLeft _ targetWidth.			"drawable right. Will later be refined."
	blendBoundsRight _ 0.						"drawable left. Will later be refined."! !

!VectorEngine05 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:21:49'!
pvtStrokeWidth: aNumber
	strokeWidth _ aNumber.
	strokeWidthDilatedHalf _ strokeWidth + antiAliasingWidth * 0.5.
	strokeWidthDilatedHalfSquared _ strokeWidthDilatedHalf * strokeWidthDilatedHalf.
	strokeWidthErodedHalf _ strokeWidth - antiAliasingWidth * 0.5.
	strokeWidthErodedHalfSquared _ strokeWidthErodedHalf * strokeWidthErodedHalf * strokeWidthErodedHalf sign.
	openCLKernelWidth _ ((strokeWidthDilatedHalf + subPixelDelta) * 2) truncated + 1..
	openCLKernelHeight _ (strokeWidthDilatedHalf * 2) truncated + 1.
	{openCLKernelWidth. openCLKernelHeight} print.! !

!VectorEngine05 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:21:49'!
resetMorphBounds

	morphBoundsTop _ targetHeight - 1.
	morphBoundsBottom _ 0.
	morphBoundsLeft _ targetWidth - 1.
	morphBoundsRight _ 0! !

!VectorEngine05 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:21:49'!
setForm: aForm
	"
	World extent: World extent
	"
	| hack s |
	targetForm _ aForm.
	targetWidth _ aForm width.
	targetHeight _ aForm height.
	self resetMorphBounds.
	self clipRect: (0@0 corner: targetWidth@targetHeight).
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth.
	subPixelDelta _ 0.25. "Values closer to 0.333 might produce a bit of coloring on some displays. Used to be 0.28"
	s _ aForm bits size.
	(mask isNil or: [ mask size ~= s ])
		ifTrue: [
			mask _ WordArray new: s.
			edgeCountPerPixel _ WordArray new: s.
			morphAtPixel _ Array new: s.
			hack _ Form extent: targetWidth@targetHeight depth: 32 bits: mask.
			auxBitBlt _ BitBlt toForm: hack.
			auxBitBlt fillBitmap: (Bitmap with: 16rFF000000).
			auxBitBlt combinationRule: Form over ].

	"Perhaps this should be done in an ifCurtailed: block in case of Morphic drawing failure..."
	auxBitBlt destRect: targetForm boundingBox.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	morphAtPixel atAllPut: 0! !

!VectorEngine05 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:21:49'!
updateEdgeCountAtX: x y: y
	| thisYTruncated pixelY pixelIndexBase redPixelIndex greenPixelIndex bluePixelIndex increment countWord redCount greenCount blueCount redOffset greenOffest blueOffset |

	thisYTruncated _ (y truncated max: clipTop-1) min: clipBottom-1.
	prevYTruncated ifNil: [ 
		^ prevYTruncated _ thisYTruncated ].
	thisYTruncated = prevYTruncated ifTrue: [
		^ prevYTruncated _ thisYTruncated ].

	thisYTruncated > prevYTruncated
		ifTrue: [
			pixelY _ thisYTruncated.
			increment _ 1 ]
		ifFalse: [
			pixelY _ prevYTruncated.
			increment _ -1 ].

	"All edge count at the left of the clipRect are added there (at the left of the clipRect).
	The effect is the same, and we need to clean up less stuff afterwards.
	More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses."
	pixelIndexBase _ pixelY * targetWidth + 1.
	redOffset _ (x+subPixelDelta) truncated + 1 max: clipLeft.
	greenOffest _ x truncated + 1 max: clipLeft.
	blueOffset _ (x-subPixelDelta) truncated + 1 max: clipLeft.
	redPixelIndex _ pixelIndexBase + redOffset.
	greenPixelIndex _ pixelIndexBase + greenOffest.
	bluePixelIndex _ pixelIndexBase + blueOffset.

	"Three possible cases here: RGB in one word (pixel); RG in one, and G in another; R in one, GB in another"
	redPixelIndex = bluePixelIndex
		ifTrue: [						"First case: RGB in the same word"
			redOffset <= clipRight ifTrue: [
				countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
				redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
				countWord at: 3 put: redCount.
				greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
				countWord at: 2 put: greenCount.
				blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
				countWord at: 1 put: blueCount.
				edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].
		]
		ifFalse: [
			redPixelIndex = greenPixelIndex
				ifTrue: [				"Second case: RG in one word, B in following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
				ifFalse: [			"Third case: R in one word, GB in the following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
		].
	prevYTruncated _ thisYTruncated! !

!VectorEngine05 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:21:49'!
updateMask
	"Apdate alpha (transparency) mask using trajectoryPoints."

	"Paralelizar en displayX@displayY"
	"Esto es lo que estoy haciendo ahora. Paralelizar en la bolita, lo mas afuera posible"
"NO OLVIDARSE DE RESPETAR Los clipping bounds!!!!!!"
	0 to: openCLKernelHeight do: [ :i |
		0 to: openCLKernelWidth do: [ :j |
			self updateMaskI: i j: j
			]].
	trajectoryPoints _ OrderedCollection new.! !

!VectorEngine05 methodsFor: 'private' stamp: 'jmv 2/9/2020 19:21:49'!
updateMaskI: i j: j
	
	| pixY pixX writePrev distanceToAxisSquared alpha alphaWord dySquared dx dxSquared dy pixelIndex dxp blueAlpha greenAlpha redAlpha previousBlueAlpha previousGreenAlpha previousRedAlpha |

	pixY _ (trajectoryPoints first y / (openCLKernelHeight+1)) truncated * (openCLKernelHeight+1) + i.
	pixX _ (trajectoryPoints first x / (openCLKernelWidth+1)) truncated * (openCLKernelWidth+1) + j.
	trajectoryPoints first y - pixY > (openCLKernelHeight/2) ifTrue: [ pixY _ pixY + openCLKernelHeight+1].
	pixY - trajectoryPoints first y > (openCLKernelHeight/2) ifTrue: [ pixY _ pixY - openCLKernelHeight-1].
	trajectoryPoints first x - pixX > (openCLKernelWidth/2) ifTrue: [ pixX _ pixX + openCLKernelWidth+1].
	pixX - trajectoryPoints first x > (openCLKernelWidth/2) ifTrue: [ pixX _ pixX - openCLKernelWidth-1].
	
	"Leer el 1ro"
	pixelIndex _ pixY * targetWidth +  pixX.
	pixelIndex _ pixelIndex + 1.
	alphaWord _ mask bytesAt: pixelIndex.
	redAlpha _ alphaWord at: 3.
	greenAlpha _ alphaWord at: 2.
	blueAlpha _ alphaWord at: 1.
	previousRedAlpha _ redAlpha.
	previousGreenAlpha _ greenAlpha.
	previousBlueAlpha _ blueAlpha.
	
	trajectoryPoints do: [ :p |
		
		writePrev _ false.
		p y - pixY > (openCLKernelHeight/2) ifTrue: [ pixY _ pixY + openCLKernelHeight+1. writePrev _ true].
		pixY - p y > (openCLKernelHeight/2) ifTrue: [ pixY _ pixY - openCLKernelHeight-1. writePrev _ true].
		p x - pixX > (openCLKernelWidth/2) ifTrue: [ pixX _ pixX + openCLKernelWidth+1. writePrev _ true].
		pixX - p x > (openCLKernelWidth/2) ifTrue: [ pixX _ pixX - openCLKernelWidth-1. writePrev _ true].
		
		writePrev ifTrue: [
			"escribir el anterior"
			(previousRedAlpha ~= redAlpha or: [
			previousGreenAlpha ~= greenAlpha or: [
			previousBlueAlpha ~= blueAlpha ]]) ifTrue: [
				alphaWord at: 3 put: redAlpha.
				alphaWord at: 2 put: greenAlpha.
				alphaWord at: 1 put: blueAlpha.
				mask bytesAt: pixelIndex put: alphaWord ].

			"leer el nuevo" 
			pixelIndex _ pixY * targetWidth +  pixX.
			pixelIndex _ pixelIndex + 1.
			alphaWord _ mask bytesAt: pixelIndex.
			redAlpha _ alphaWord at: 3.
			greenAlpha _ alphaWord at: 2.
			blueAlpha _ alphaWord at: 1.
			previousRedAlpha _ redAlpha.
			previousGreenAlpha _ greenAlpha.
			previousBlueAlpha _ blueAlpha.
			].
		
		"Minimizar"
		dy _ pixY - p y.
		dySquared _ dy * dy.
		dx _ pixX - p x.
		"Red"
		dxp _ dx - subPixelDelta.
		dxSquared _ dxp * dxp.
		distanceToAxisSquared _ dxSquared + dySquared.
		distanceToAxisSquared < strokeWidthDilatedHalfSquared
			ifTrue: [
				alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
					ifTrue: [ 16r7F ]
					ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
				alpha > redAlpha ifTrue: [
					redAlpha _ alpha ]].
		"Green"
		dxSquared _ dx * dx.
		distanceToAxisSquared _ dxSquared + dySquared.
		distanceToAxisSquared < strokeWidthDilatedHalfSquared
			ifTrue: [
				alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
					ifTrue: [ 16r7F ]
					ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
				alpha > greenAlpha ifTrue: [
					greenAlpha _ alpha ]].
		"Blue"
		dxp _ dx + subPixelDelta.
		dxSquared _ dxp * dxp.
		distanceToAxisSquared _ dxSquared + dySquared.
		distanceToAxisSquared < strokeWidthDilatedHalfSquared
			ifTrue: [
				alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
					ifTrue: [ 16r7F ]
					ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
				alpha > blueAlpha ifTrue: [
					blueAlpha _ alpha ]].
	].

	"escribir el ultimo"
	(previousRedAlpha ~= redAlpha or: [
	previousGreenAlpha ~= greenAlpha or: [
	previousBlueAlpha ~= blueAlpha ]]) ifTrue: [
		alphaWord at: 3 put: redAlpha.
		alphaWord at: 2 put: greenAlpha.
		alphaWord at: 1 put: blueAlpha.
		mask bytesAt: pixelIndex put: alphaWord ]! !

!VectorEngine05 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: theta start: startAngle sweep: sweepAngle
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black fillColor: Color red do: [ :engine |
		engine basicArcCenterX: 100 centerY: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.
"
	| d hops angle thetaCos thetaSin xp yp x0 y0 x y |
	
	"Por supuesto probar tambien rx no igual a ry, y uno (o ambos) menor que el ancho de trazo..."
	thetaCos _ theta cos.
	thetaSin _ theta sin.
	angle _ startAngle.
	xp _ angle cos * rx.
	yp _ angle sin * ry.
	x0 _ thetaCos * xp - (thetaSin * yp) + cx.
	y0 _ thetaSin * xp + (thetaCos * yp) + cy.
	(startAngle ~= 0.0 or: [ sweepAngle ~= Float twoPi ])
		ifTrue: [ self basicLineToX: x0 y: y0 ]	"Draw a line. There are cases where we want to join an arc. For example, window frames"
		ifFalse: [
			"trajectory starts here. Eventually, #closePath should draw a line to here"
			"Next point will be first in a new trajectory fragment"
			prevYTruncated _ nil.
			firstX _ x0.
			firstY _ y0.
			self addPenPositionX: x0 y: y0 ].
	hops _ ((rx+ry * 4 * sweepAngle abs / (2*Float pi)) * hopsPerPixel) truncated + 1.
	d _ sweepAngle / hops.
	hops timesRepeat: [
		angle _ angle + d.
		xp _ angle cos * rx.
		yp _ angle sin * ry.
		x _ thetaCos * xp - (thetaSin * yp) + cx.
		y _ thetaSin * xp + (thetaCos * yp) + cy.
		self addPenPositionX: x y: y ].

	currentX _ x.
	currentY _ y.

	self updateMask! !

!VectorEngine05 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
basicArcToX: x2 y: y2 radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"
	"Calcular: cx, cy, rx, ry, phi, theta1, deltaTheta"
	| x1 y1 cosPhi sinPhi x12hd y12hd x1p y1p rxSq rySq x1pSq y1pSq bigSqR bigSqRNumerator bigSqRDenominator sign cxp cyp cx cy theta1 theta2 deltaTheta scaleSq scale newRx newRy |
	x1 _ currentX.
	y1 _ currentY.
	"Handle out of range parameters as requested by the w3 implementation notes"
	(x2 = x1 and: [ y2 = y1 ]) ifTrue: [ ^self ].
	(rx = 0.0 or: [ ry = 0.0 ]) ifTrue: [ ^self basicLineToX: x2 y: y2 ].
	rx < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: 0.0 -rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	ry < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: rx radiusY: 0.0-ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	
	cosPhi _ phi cos.
	sinPhi _ phi sin.
	"step 1 in http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes"
	x12hd _ (x1-x2) * 0.5.
	y12hd _ (y1-y2) * 0.5.
	x1p _ (cosPhi * x12hd) + (sinPhi * y12hd).
	y1p _ (cosPhi * y12hd) - (sinPhi * x12hd).

	"step 2"
	rxSq _ rx * rx.
	rySq _ ry * ry.
	x1pSq _ x1p * x1p.
	y1pSq _ y1p * y1p.
	"ensure radii are large enough"
	scaleSq _ (x1pSq / rxSq) + (y1pSq / rySq).
	scaleSq > 1 ifTrue: [
		scale _ scaleSq sqrt.
		newRx _ scale * rx.
		newRy _ scale * ry.
		(newRx = rx or: [ newRy = ry ]) ifTrue: [		"This happens when scaleSq is so close to 1, that the multiplication rounds to the same numbers"
			newRx _ scaleSq * rx.
			newRy _ scaleSq * ry ].
		^self basicArcToX: x2 y: y2 radiusX: newRx radiusY: newRy angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
		].
	bigSqRNumerator _ (rxSq * rySq) - (rxSq * y1pSq)-(rySq * x1pSq).
	bigSqRDenominator _ (rxSq * y1pSq) + (rySq * x1pSq).
	sign _ doLargerArc = useIncreasingAngles ifTrue: [ -1 ] ifFalse: [ 1 ].
	bigSqR _ (bigSqRNumerator / bigSqRDenominator max: 0.0) sqrt * sign.		"This only can be < 0.0 because of rounding errors. Take 0.0 in such cases."
	cxp _ bigSqR * rx * y1p / ry.
	cyp _ 0.0 - (bigSqR * ry * x1p / rx).

	"step 3"
	cx _ (cosPhi * cxp) - (sinPhi * cyp) + ((x1+x2) * 0.5).
	cy _ (sinPhi * cxp) + (cosPhi * cyp) + ((y1+y2) * 0.5).
	
"
| u v a |
Transcript clear.
u _ 1@4. v _ 7@2.
a _ ((u dotProduct: v) / (u r * v r) ) arcCos.
a _ a * (((u x * v y) - (u y * v x)) sign).
a print.
(v theta - u theta) print.
Ojo al primitivizar. Para ellos, el theta va entre -pi y pi. Para Squeak va entre cero y 2pi...
"

	"step 4"
	"Ojo signo del angulo y del eje y!!!!!!!!!!"
	theta1 _ (((x1p - cxp) / rx) @ ((y1p - cyp) / ry)) theta.
	theta2 _ (((0 - x1p - cxp) / rx) @ (( 0 -y1p - cyp) / ry)) theta.
	deltaTheta _ theta2 - theta1.
	useIncreasingAngles = (deltaTheta > 0) ifFalse: [
		deltaTheta > 0
			ifTrue: [ deltaTheta _ deltaTheta - Float pi - Float pi ]
			ifFalse: [ deltaTheta _ deltaTheta + Float pi + Float pi ]
		].
	"Y aca calcular como dar vuelta deltaTheta, ver."


	"Finalmente, estudiar la correccion de valores fuera de rango"
	

	self basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: phi start: theta1 sweep: deltaTheta! !

!VectorEngine05 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
basicClosePath
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			do_ClosePath ].
Display forceToScreen
"
	self basicLineToX: firstX y: firstY! !

!VectorEngine05 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
basicCubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	| dx dy hops increment t x0 y0 oneLessT f2 f3 f1 f23 f4 x y |

	dx _ (x1-currentX) abs + (x2-x1) abs + (x3-x2) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs + (y3-y2) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	"en muchos casos, secuencias de estos,  repetimos puntos, el ultimo de la curva anterior... pensar, etc"
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT * oneLessT.
		f23 _ 3 * oneLessT * t.
		f2 _ f23 * oneLessT.
		f3 _ f23 * t.
		f4 _ t * t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2) + (f4 * x3).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2) + (f4 * y3).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x3 y: y3.

	currentX _ x3.
	currentY _ y3.

	self updateMask! !

!VectorEngine05 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
basicLineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 300 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 25.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 500 y: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 30 y: 15.
		engine abs_LineToX: 45 y: 90.
		engine abs_LineToX: 180 y: 30 ].
Display forceToScreen
"
	| dx dy hops incrementX incrementY x y |
	dy _ y2 - currentY.
	dx _ x2 - currentX.
	"Optimizar. En todas las lineas, bounds. En verticales, mucho mas. En horiz, no EdgeCounts!! Ver 02"
	x _ currentX.
	y _ currentY.
	hops _ ((dx abs max: dy abs) * hopsPerPixel) truncated + 1.
	incrementX _ dx *1.0 / hops.
	incrementY _ dy *1.0 / hops.
	hops timesRepeat: [
		self addPenPositionX: x y: y.
		x _ x + incrementX.
		y _ y + incrementY ].
	currentX _ x2.
	currentY _ y2.
	self addPenPositionX: currentX y: currentY.
	self updateMask! !

!VectorEngine05 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
basicMoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150;
			abs_MoveToX: 210 y: 150;
			abs_LineToX: 300 y: 200 ].
Display forceToScreen
"

	"A discontinuity in the trajectory"

	"We are starting a new trajectory, or at a discontinuity in trajectory.
	Eventually #closeTrajectory should draw a line to here"

	"Next point will be first in a new trajectory fragment"
	prevYTruncated _ nil.
	firstX _ x.
	firstY _ y.
	currentX _ x.
	currentY _ y.! !

!VectorEngine05 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/9/2020 19:21:49'!
basicQuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| dx dy hops increment t x0 y0 oneLessT f1 f3 f2 x y |
	dx _ (x1-currentX) abs + (x2-x1) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT.
		f2 _ 2* oneLessT * t.
		f3 _ t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x2 y: y2.

	currentX _ x2.
	currentY _ y2.

	self updateMask! !

!VectorEngine05 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:21:49'!
blendFillOnly

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.

			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendFillOnlyAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine05 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:21:49'!
blendFillOnlyAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends fill over background. Despite method selector, there might be a very thin stroke of the same color as the fill. Handle this by adjusting antiAliasAlphas.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	"In this method, antiAliasAlphas are not used to blend stroke, but fill. This means that in the inside of the shape, and away from the stroke, they must be 1.0 (not 0.0)."
	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	isRedInside ifTrue: [ antiAliasRedAlpha _ 1.0 - antiAliasRedAlpha ].
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	isGreenInside ifTrue: [ antiAliasGreenAlpha _ 1.0 - antiAliasGreenAlpha ].
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	isBlueInside ifTrue: [ antiAliasBlueAlpha _ 1.0 - antiAliasBlueAlpha ].
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * fillAlphaToUse.
	resultR _ alpha * fillRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * fillAlphaToUse.
	resultG _ alpha * fillGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * fillAlphaToUse.
	resultB _ alpha * fillBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine05 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:21:49'!
blendStrokeAndFill

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.
			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendStrokeAndFillAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine05 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:21:49'!
blendStrokeAndFillAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Do an appropriate (anti aliased) mix between stoke and fill (or pick just stroke or just fill). Blend this over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha foreComponent strokeAlphaToUse fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	isRedInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse.
			foreComponent _ strokeRed ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse + ((1-antiAliasRedAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasRedAlpha * strokeRed + ((1-antiAliasRedAlpha) * fillRed) ].
	resultR _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	isGreenInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
			foreComponent _ strokeGreen ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse + ((1-antiAliasGreenAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasGreenAlpha * strokeGreen + ((1-antiAliasGreenAlpha) * fillGreen) ].
	resultG _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	isBlueInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
			foreComponent _ strokeBlue ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse + ((1-antiAliasBlueAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasBlueAlpha * strokeBlue + ((1-antiAliasBlueAlpha) * fillBlue) ].
	resultB _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine05 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:21:49'!
blendStrokeOnly

	| pixelIndex m |
	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.
				(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
					self blendStrokeOnlyAtX: displayX y: displayY pixelIndex: pixelIndex ]]].

	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine05 methodsFor: 'private - blend with mask' stamp: 'jmv 2/9/2020 19:21:49'!
blendStrokeOnlyAtX: x y: y pixelIndex: pixelIndex

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends stroke over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha strokeAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		^self].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.

	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * strokeAlphaToUse.
	resultR _ alpha * strokeRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
	resultG _ alpha * strokeGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
	resultB _ alpha * strokeBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine05 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:21:49'!
experLinesAndShapes
	"
	self experLinesAndShapes
	"
	| engine y1 yy2 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		yy2 _ y2 >= 1 ifTrue: [ VectorEngine defaultAntiAliasingWidth * 0.5 ] ifFalse: [0].
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1+yy2; abs_LineToX: 530 y: y1+yy2+dy;
				abs_LineToX: 530 y: y1+y2-yy2+dy; abs_LineToX: 431 y: y1+y2-yy2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1+yy2 y: 431; abs_LineToX: y1+yy2+dy y: 530;
				abs_LineToX: y1+y2-yy2+dy y: 530; abs_LineToX: y1+y2-yy2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill."
		engine fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		"solo stroke, no fill"
		engine strokeWidth: y2 color: Color black do: [
			engine
				abs_MoveToX: y2*0.5+731 y: y2*0.5 + y1+dy+dy+dy; abs_LineToX: 830 y: y2 * 0.5 + y1  + dy + dy+dy+dy.
			engine
				abs_MoveToX: y2*0.5 + y1+dy+dy+dy y: y2*0.5+731; abs_LineToX: y2 * 0.5 + y1  + dy + dy+dy+dy y: 830 ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine05 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:21:49'!
experLinesAndShapes2
	"
	self experLinesAndShapes2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth*4*2.
	15 timesRepeat: [
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 1.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 131 y: y1; abs_LineToX: 230 y: y1+dy;
				abs_LineToX: 230 y: y1+y2+dy; abs_LineToX: 131 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX: y1 y: 131; abs_LineToX: y1+dy y: 230;
				abs_LineToX: y1+y2+dy y: 230; abs_LineToX: y1+y2 y: 131;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.8 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 231 y: y1+dy; abs_LineToX: 330 y: y1+dy+dy;
				abs_LineToX: 330 y: y1+y2+dy+dy; abs_LineToX: 231 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 231; abs_LineToX: y1+dy+dy y: 330;
				abs_LineToX: y1+y2+dy+dy y: 330; abs_LineToX: y1+y2+dy y: 231;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.6 color: Color green fillColor: Color red do: [.
			engine
				abs_MoveToX: 331 y: y1+dy+dy; abs_LineToX: 430 y: y1+dy+dy+dy;
				abs_LineToX: 430 y: y1+y2+dy+dy+dy; abs_LineToX: 331 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 331; abs_LineToX: y1+dy+dy+dy y: 430;
				abs_LineToX: y1+y2+dy+dy+dy y: 430; abs_LineToX: y1+y2+dy+dy y: 331;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.4 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 431 y: y1+dy+dy+dy; abs_LineToX: 530 y: y1+dy+dy+dy+dy;
				abs_LineToX: 530 y: y1+y2+dy+dy+dy+dy; abs_LineToX: 431 y: y1+y2+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy+dy y: 431;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.2 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 531 y: y1+dy+dy+dy+dy; abs_LineToX: 630 y: y1+dy+dy+dy+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy+dy+dy+dy; abs_LineToX: 531 y: y1+y2+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy y: 531; abs_LineToX: y1+dy+dy+dy+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 630; abs_LineToX: y1+y2+dy+dy+dy+dy y: 531;
				do_ClosePath ].
		"Solo fill. w chico. Preferimos ya usarlo para definir mejor el shape (se transparentaria demasiado)"
		engine strokeWidth: 0.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy+dy+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 print.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine05 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:21:50'!
experLinesAndShapes3
	"
	self experLinesAndShapes3
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.4 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine05 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:21:50'!
experLinesAndShapes4
	"
	self experLinesAndShapes4
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*1.5 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine05 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:21:50'!
experLinesAndShapesx
	"
	self experLinesAndShapesx
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		y2 print.
		"Solo fill. w =0"
		engine strokeWidth: 0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy y: 431;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.! !

!VectorEngine05 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:21:50'!
experLinesAndShapesx2
	"
	self experLinesAndShapesx2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	y1 _ 10.
	dy _ 3.
	y2 _ 0.1.
	y2 print.
	"Solo fill. w =0"
	engine strokeWidth: 0.5 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 10 y: y1+dy+dy; abs_LineToX: 200 y: y1+dy+dy+dy;
			abs_LineToX: 200 y: y1+y2+dy+dy+dy; abs_LineToX: 10 y: y1+y2+dy+dy;
			do_ClosePath.
		engine
			abs_MoveToX: y1+dy+dy y: 10; abs_LineToX: y1+dy+dy+dy y: 200;
			abs_LineToX: y1+y2+dy+dy+dy y: 200; abs_LineToX: y1+y2+dy+dy y: 10;
			do_ClosePath ].
	Display forceToScreen.
! !

!VectorEngine05 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:21:50'!
experimentHopsPerPixel1
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 1: Very thin stroke, the same color as fill
	VectorEngine experimentHopsPerPixel1
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) *10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine05 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:21:50'!
experimentHopsPerPixel2
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 2: Stroke of various widths, no fill
	VectorEngine experimentHopsPerPixel2
	"
	| d engine f1 f2 hops1 hops2 strokeWidth |
	hops1 _ 200.
	hops1 _ 20.
	"
	strokeWidth -> hops2
	1.3 -> 8
	1.5 -> 6
	2 -> 4
	4 -> 3
	6 -> 2
	16 -> 1
	Maybe 10 / strokeWidth + 1 is ok?
	"
	strokeWidth _ 16*2.
	hops2 _ 8*0+1.
	hops2 _ 10.0 / strokeWidth + 1.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f2 displayAt: 220@0.

Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine05 class methodsFor: 'experiments' stamp: 'jmv 2/9/2020 19:21:50'!
experimentHopsPerPixel3
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 3: No stroke, just fill
	VectorEngine experimentHopsPerPixel3
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine05 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 19:21:50'!
experiment1
	"
	No perfecto aun, pero se puede empezar a comparar con
	http://www.hpl.hp.com/research/mmsl/projects/graphics/antialiasing/figure21.htm
	Ni que hablar que es mucho mas rapido...
	self experiment1
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 e f |
engine _ self onForm: Display.
h _ 300.
h _ 490.
h _ 280.
bottom _ 200.
bottom _ 0.
centerX _ 400.
centerX _ 250.
w0 _ 120.0.
hf _ 1.0.
hf _ 1.73.
hf _ 1.71.
y _ nil.
delta _ nil.
	e _ 500@500.
	f _ Form extent: e depth: 32.
	f fillColor: Color transparent..
"	canvas _  self on: f.
	canvas useComponentAlphas."
1 to: "400" 150 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-3 // delta to: 3 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color black ] ifFalse: [ Color white ].
"			color _ color alpha: (((prevY-y) min: (x1-x2)) min: 1)."
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
"
	canvas removeSpuriousTranslucencyFloatAndBlendOver: Color red.
	f writePNGfileNamed: 'pp17.png'
"! !

!VectorEngine05 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 19:21:50'!
experiment2
	"
	self experiment2
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 |
engine _ self onForm: Display.
h _ 300.
h _ 600.
bottom _ 200.
centerX _ 400.
w0 _ 60.0.
hf _ 1.0.
y _ nil.
delta _ nil.
1 to: 400 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-6 // delta to: 6 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color white ] ifFalse: [ Color black ].
			color _ color alpha: (((prevY-y) min: (x1-x2)) "* 0.3" min: 1).
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
! !

!VectorEngine05 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 19:21:50'!
experiment3
	"
	self experiment3
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	100 timesRepeat: [
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
		r _ r + w.
		w _ w * 0.8.
		r _ r + w.

	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine05 class methodsFor: 'samples' stamp: 'jmv 2/9/2020 19:21:50'!
experiment4
	"
	self experiment4
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	1 to: 100 do: [ :i |
		r _ r + w.
		w _ 20.0 / i.
		r _ r + w.
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine05 class methodsFor: 'samples' stamp: 'jmv 2/20/2020 12:30:38'!
siemensStar
	"
	self siemensStar display
	"
	| angle backColor canvas count extent foreColor form location offsetFromCenter |
	count _ 32.
	angle _ Float twoPi / count / 2.
	extent _ 512.
	offsetFromCenter _ 0.
	backColor _ `Color gray: 50/255`.
	foreColor _ `Color gray: 200/255`.
	form _ Form extent: extent asPoint depth: 32.
	form fillColor: backColor.
	canvas _ VectorCanvas onForm: form.
	1 to: count do: [ :i |
		location _ AffineTransformation withRadians: i * angle * 2+0.02 scale: extent*0.45 position: extent-1/2.0 + offsetFromCenter.
		canvas engine geometryTransformation: location.
		canvas fillColor: foreColor do: [
			canvas
				moveToX: 0 y: 0;
				lineToX: 1 y: 0;
				lineToX: angle cos y: angle sin;
				lineToX: 0 y: 0.
		].
	].
	^form! !

!VectorEngine05 class methodsFor: 'instance creation' stamp: 'jmv 2/9/2020 19:21:50'!
onForm: aForm

	^ self new setForm: aForm! !

!VectorEngine05 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:21:50'!
antiAliasingWidthForOutlineFonts
	^1.4! !

!VectorEngine05 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:21:50'!
antiAliasingWidthForStrokeFonts
	^1.1! !

!VectorEngine05 class methodsFor: 'accessing' stamp: 'jmv 2/9/2020 19:21:50'!
defaultAntiAliasingWidth
	^1.3. "default for graphics"! !

!VectorEngine06 methodsFor: 'accessing' stamp: 'jmv 2/10/2020 16:35:43'!
antiAliasingWidth: aNumber

	antiAliasingWidth _ aNumber.
	antiAliasingWidthScaledInverse _ 127.0 / antiAliasingWidth! !

!VectorEngine06 methodsFor: 'accessing' stamp: 'jmv 2/10/2020 16:35:43'!
clipRect: aRectangle 
	"by convention, aRectangle includes left and top but does not include right and bottom.
	We do draw clipRight and clipBottom but not beyond.
	"
	"In targetForm coordinates"
	clipLeft _ aRectangle left.
	clipTop _ aRectangle top.
	clipRight _ aRectangle right - 1.
	clipBottom _ aRectangle bottom - 1! !

!VectorEngine06 methodsFor: 'accessing' stamp: 'jmv 2/10/2020 16:35:43'!
clippingRectForCurrentMorph
	"In targetForm coordinates.
	Only valid _after_ drawing currentMorph."

	^morphBoundsLeft @ morphBoundsTop corner: morphBoundsRight @ morphBoundsBottom! !

!VectorEngine06 methodsFor: 'accessing' stamp: 'jmv 2/10/2020 16:35:43'!
currentMorph: aMorph
	currentMorph _ aMorph! !

!VectorEngine06 methodsFor: 'accessing' stamp: 'jmv 2/10/2020 16:35:43'!
currentOwnerIfClips: currentMorphOwnerOrNil
	currentOwnerIfClips _ currentMorphOwnerOrNil! !

!VectorEngine06 methodsFor: 'accessing' stamp: 'jmv 2/10/2020 16:35:43'!
geometryTransformation
	^geometryTransformation! !

!VectorEngine06 methodsFor: 'accessing' stamp: 'jmv 2/10/2020 16:35:43'!
geometryTransformation: aGeometryTransformation
	geometryTransformation _ aGeometryTransformation! !

!VectorEngine06 methodsFor: 'stroke & fill' stamp: 'jmv 2/10/2020 16:35:43'!
fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	doStroke _ false.
	doFill _ true.
	self pvtStrokeWidth: 0.0.
	hopsPerPixel _ 8.										"See #experimentHopsPerPixel3"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ nil. strokeRed _ nil. strokeGreen _ nil. strokeBlue _ nil.

	0 to: openCLKernelHeight do: [ :i |
		0 to: openCLKernelWidth do: [ :j |
			jj _ j. ii _ i.
			self initializePath.
			pathCommandsBlock valueWithPossibleArgument: self.
			]].
	self finishPath! !

!VectorEngine06 methodsFor: 'stroke & fill' stamp: 'jmv 2/10/2020 16:35:43'!
strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke."

	| strokeAlphaFactor aStrokeWidth |
	doStroke _ true.
	doFill _ false.
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.

	"Strokes we want to show. They are not too thin, or maybe they are, but there's no fill. Make them wide enough to be properly sampled."
	self pvtStrokeWidth: (aStrokeWidth max: antiAliasingWidth).
	strokeAlphaFactor _ aStrokeWidth / strokeWidth.
	hopsPerPixel _ 10.0 / strokeWidth + 1.		"See #experimentHopsPerPixel2"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ nil. fillRed _ nil. fillGreen _ nil. fillBlue _ nil.
	strokeAlpha _ (aStrokeColor alpha * 255.0 * strokeAlphaFactor) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	0 to: openCLKernelHeight do: [ :i |
		0 to: openCLKernelWidth do: [ :j |
			jj _ j. ii _ i.
			self initializePath.
			pathCommandsBlock valueWithPossibleArgument: self.
			]].
	self finishPath! !

!VectorEngine06 methodsFor: 'stroke & fill' stamp: 'jmv 2/10/2020 16:35:43'!
strokeWidth: clientStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	| aStrokeWidth |

	aStrokeColor ifNil: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	clientStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aFillColor ifNil: [ ^ self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock.
		^ self ].

	doStroke _ true.
	doFill _ true.
	self pvtStrokeWidth: aStrokeWidth.
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"Strokes are really thin, but strokeColor is same as fillColor, so there's no problem sampling them."
			hopsPerPixel _ 8 ]								"See #experimentHopsPerPixel1"
		ifFalse: [
			hopsPerPixel _ 10.0 / strokeWidth + 1 max: 2 ].		"See #experimentHopsPerPixel2. Additionally, fills require at least 2."

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ (aStrokeColor alpha * 255.0) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	0 to: openCLKernelHeight do: [ :i |
		0 to: openCLKernelWidth do: [ :j |
			jj _ j. ii _ i.
			self initializePath.
			pathCommandsBlock valueWithPossibleArgument: self.
			]].
	self finishPath! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.2 position: 200@100);
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcToX: center x y: center y radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_CircleCenterX: cx y: cy radius: mr
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_CircleCenterX: 200 y: 150 radius: 80].
Display forceToScreen
"

	| center r |
	center _ geometryTransformation externalizePosition: cx@cy.
	r _ geometryTransformation externalizeScalar: mr.
	self
		basicArcCenterX: center x centerY: center y radiusX: r radiusY: r rotationAngle: 0.0 start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 150 y: 300 radius: 10.
		engine abs_CircleCenterX: 600 y: 400 radius: 6.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 600 y: -200 radius: 10.
		engine abs_CircleCenterX: 100 y: -100 radius: 6.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_CubicBezierToX: 300 y: 100 control1X: 600 y: -200 control2X: 100 y: -100
			].
Display forceToScreen.
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 100 control2X: 100 y: -100
			].
Display forceToScreen
	"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_CubicBezierToX: x3 y: y3 control1X: mirroredContolX y: mirroredContolY control2X: x2 y: y2! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"
	| p1 p2 p3 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	p3 _ geometryTransformation externalizePosition: x3@y3.
	self basicCubicBezierToX: p3 x y: p3 y control1X: p1 x y: p1 y control2X: p2 x y: p2 y.
	lastClientX _ x3.
	lastClientY _ y3.
	lastControlX _ x2.
	lastControlY _ y2! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta start: startAngle sweep: sweepAngle
	"Currently draws a line from currentX@currentY to start (if startAngle ~= 0.0 or sweepAngle ~= Float twoPi).
	This could be useful for proper fills. But might not be what is desired in some cases.
	Implement desired behavior when clear."
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.0 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6].
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 350 radiusX: 100 radiusY: 50 rotationAngle: 0.5 start: 0.1 sweep: 6 ].
Display forceToScreen.
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: startAngle sweep:  sweepAngle! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_LineToX: x2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: x2 y: lastClientY! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p2 |
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicLineToX: p2 x y: p2 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_LineToY: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToY: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToY: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX y: y2! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p |
	p _ geometryTransformation externalizePosition: x@y.
	self basicMoveToX: p x y: p y.
	lastClientX _ x.
	lastClientY _ y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 450 y: 300 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 750 y: -100 radius: 10.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_QuadraticBezierToX: 300 y: 100 controlX: 750 y: -100
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			abs_QuadraticBezierSmoothToX: 300 y: 100
			].
Display forceToScreen
"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_QuadraticBezierToX: x2 y: y2 controlX: mirroredContolX y: mirroredContolY! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
abs_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| p1 p2 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicQuadraticBezierToX: p2 x y: p2 y controlX: p1 x y: p1 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ x1.
	lastControlY _ y1! !

!VectorEngine06 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
do_ClosePath
	"abs/rel meaningless here"
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200;
			abs_CubicBezierToX: 300 y: 120 control1X: 310 y: 110 control2X: 200 y: 200;
			do_ClosePath;
			abs_LineToX: 150 y: 300 ].
Display forceToScreen
"
	| p2 |
	self basicClosePath.

	p2 _ geometryTransformation internalizePosition: currentX@currentY.
	lastClientX _ p2 x.
	lastClientY _ p2 y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine06 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
rel_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			rel_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false;
			do_ClosePath ].
"
	self abs_ArcToX: lastClientX + cx y: lastClientY + cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine06 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
rel_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierToX: 300 y: 300 control1X: 0 y: 0 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierSmoothToX: 600 y: 100 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"

	self
		abs_CubicBezierSmoothToX: lastClientX + x3 y: lastClientY + y3
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine06 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
rel_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ];
	strokeWidth: 1.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ];
	strokeWidth: 10 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	self
		abs_CubicBezierToX: lastClientX + x3 y: lastClientY + y3
		control1X: lastClientX + x1 y: lastClientY + y1
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine06 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
rel_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine06 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
rel_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_MoveToX: lastClientX + x y: lastClientY + y! !

!VectorEngine06 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
rel_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 550 y: 350 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 850 y: -50 radius: 10.
		engine abs_MoveToX: 700 y: 150.
		engine
			rel_QuadraticBezierToX: -300 y: -50 controlX: 150 y: -200
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			rel_QuadraticBezierSmoothToX: -300 y: -50
			].
Display forceToScreen
"
	self
		abs_QuadraticBezierSmoothToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine06 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
rel_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ];
	strokeWidth: 3.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ];
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color green alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	self
		abs_QuadraticBezierToX: lastClientX + x2 y: lastClientY + y2
		controlX: lastClientX + x1 y: lastClientY + y1! !

!VectorEngine06 methodsFor: 'text' stamp: 'jmv 2/10/2020 16:35:43'!
displayString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aFont color: aColor canvas: aCanvas
	"geometryTransformation is already set to honor font pointSize
	Use as little of aFont as possible!!"
	| glyph destX destY loc |

	self antiAliasingWidth: VectorEngine antiAliasingWidthForOutlineFonts.
	loc _ geometryTransformation.
	self fillColor: aColor do: [
		destY _ aPoint y.
		destX _ aPoint x.
		startIndex to: stopIndex do: [ :charIndex |
			glyph _ aFont ttGlyphAt: (aString at: charIndex).
			glyph isComposite
				ifFalse: [
					glyph contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ].
					]]
				ifTrue: [
					glyph txAndContoursDo: [ :tx :contours |contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ (loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated) composedWith: tx.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ]]]
					].
			destX _ destX + glyph advanceWidth.
		]
	].
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth! !

!VectorEngine06 methodsFor: 'private' stamp: 'jmv 2/10/2020 16:35:43'!
addPenPositionX: x y: y

"
Inlinear en senders. Extraer afectar bounds si es posible (linea, circulo)
"

	self updateMaskP: x@y.

	blendBoundsTop _ blendBoundsTop min: y.
	blendBoundsBottom _ blendBoundsBottom max: y.
	blendBoundsLeft _ blendBoundsLeft min: x.
	blendBoundsRight _ blendBoundsRight max: x.

	"Compute edges intersecting with this horizontal line, for fills."
	doFill ifTrue: [
		self updateEdgeCountAtX: x y: y ].! !

!VectorEngine06 methodsFor: 'private' stamp: 'jmv 2/10/2020 16:35:43'!
finishPath
	"Blend stroke and/or fill over background, according to the just computed pen alphas (distance from pixel to center of stroke)"

	blendBoundsTop _ (blendBoundsTop - strokeWidthDilatedHalf) truncated +1.
	blendBoundsBottom _ (blendBoundsBottom + strokeWidthDilatedHalf) truncated.
	blendBoundsLeft _ (blendBoundsLeft - strokeWidthDilatedHalf - subPixelDelta) truncated +1.
	blendBoundsRight _ (blendBoundsRight + strokeWidthDilatedHalf + subPixelDelta) truncated.
	blendBoundsTop < clipTop ifTrue: [ blendBoundsTop _ clipTop ].
	blendBoundsBottom > clipBottom ifTrue: [ blendBoundsBottom _ clipBottom ].
	blendBoundsLeft< clipLeft ifTrue: [ blendBoundsLeft _ clipLeft ].
	blendBoundsRight > clipRight ifTrue: [ blendBoundsRight _ clipRight ].
	
	"If we are doing a fill, and caller forgot to close the trajectory, then do it anyway."
	doFill ifTrue: [
		(firstX = currentX and: [ firstY = currentY ]) ifFalse: [
			"This is actually an error condition. If we are asked to fill, then the path should be closed.
			This is a workaround. If width > 0.0, we'll be adding a visible edge to the path."
			self basicClosePath ]].

	doFill ifTrue: [
		doStroke
			ifTrue: [ self blendStrokeAndFill ]
			ifFalse: [ self blendFillOnly ]]
		ifFalse: [
		self blendStrokeOnly ].
	morphBoundsTop _ morphBoundsTop min: blendBoundsTop.
	morphBoundsBottom _ morphBoundsBottom max: blendBoundsBottom.
	morphBoundsLeft _ morphBoundsLeft min: blendBoundsLeft.
	morphBoundsRight _ morphBoundsRight max: blendBoundsRight.

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.

	Display forceToScreen! !

!VectorEngine06 methodsFor: 'private' stamp: 'jmv 2/10/2020 16:35:43'!
firstX: x y: y
	firstX _ x.
	firstY _ y.

	pixY _ (firstY / (openCLKernelHeight+1)) truncated * (openCLKernelHeight+1) + ii.
	pixX _ (firstX / (openCLKernelWidth+1)) truncated * (openCLKernelWidth+1) + jj.
	firstY - pixY > (openCLKernelHeight/2) ifTrue: [ pixY _ pixY + openCLKernelHeight+1].
	pixY - firstY > (openCLKernelHeight/2) ifTrue: [ pixY _ pixY - openCLKernelHeight-1].
	firstX - pixX > (openCLKernelWidth/2) ifTrue: [ pixX _ pixX + openCLKernelWidth+1].
	pixX - firstX > (openCLKernelWidth/2) ifTrue: [ pixX _ pixX - openCLKernelWidth-1].

"No me gusta, entender por que. Ver si meter clipping... no deberia"
pixY < 0 ifTrue: [ pixY _ 0 ].
pixX < 0 ifTrue: [ pixX _ 0 ].

	z_pixelIndex _ pixY * targetWidth +  pixX.
	z_pixelIndex _ z_pixelIndex + 1.
	z_alphaWord _ mask bytesAt: z_pixelIndex.
	z_redAlpha _ z_alphaWord at: 3.
	z_greenAlpha _ z_alphaWord at: 2.
	z_blueAlpha _ z_alphaWord at: 1.
	z_previousRedAlpha _ z_redAlpha.
	z_previousGreenAlpha _ z_greenAlpha.
	z_previousBlueAlpha _ z_blueAlpha.
! !

!VectorEngine06 methodsFor: 'private' stamp: 'jmv 2/10/2020 16:35:43'!
initialize
	geometryTransformation _ MorphicTranslation new. "Identity"! !

!VectorEngine06 methodsFor: 'private' stamp: 'jmv 2/10/2020 16:35:43'!
initializePath

	self firstX: 0 y: 0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.
	prevYTruncated _ nil.

	blendBoundsTop _ targetHeight.			"drawable bottom. Will later be refined."
	blendBoundsBottom _ 0.						"drawable top. Will later be refined."
	blendBoundsLeft _ targetWidth.			"drawable right. Will later be refined."
	blendBoundsRight _ 0.						"drawable left. Will later be refined."! !

!VectorEngine06 methodsFor: 'private' stamp: 'jmv 2/10/2020 16:35:43'!
pvtStrokeWidth: aNumber
	strokeWidth _ aNumber.
	strokeWidthDilatedHalf _ strokeWidth + antiAliasingWidth * 0.5.
	strokeWidthDilatedHalfSquared _ strokeWidthDilatedHalf * strokeWidthDilatedHalf.
	strokeWidthErodedHalf _ strokeWidth - antiAliasingWidth * 0.5.
	strokeWidthErodedHalfSquared _ strokeWidthErodedHalf * strokeWidthErodedHalf * strokeWidthErodedHalf sign.
	openCLKernelWidth _ ((strokeWidthDilatedHalf + subPixelDelta) * 2) truncated + 1..
	openCLKernelHeight _ (strokeWidthDilatedHalf * 2) truncated + 1.
	{openCLKernelWidth. openCLKernelHeight} print.! !

!VectorEngine06 methodsFor: 'private' stamp: 'jmv 2/10/2020 16:35:43'!
resetMorphBounds

	morphBoundsTop _ targetHeight - 1.
	morphBoundsBottom _ 0.
	morphBoundsLeft _ targetWidth - 1.
	morphBoundsRight _ 0! !

!VectorEngine06 methodsFor: 'private' stamp: 'jmv 2/10/2020 16:35:43'!
setForm: aForm
	"
	World extent: World extent
	"
	| hack s |
	targetForm _ aForm.
	targetWidth _ aForm width.
	targetHeight _ aForm height.
	self resetMorphBounds.
	self clipRect: (0@0 corner: targetWidth@targetHeight).
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth.
	subPixelDelta _ 0.25. "Values closer to 0.333 might produce a bit of coloring on some displays. Used to be 0.28"
	s _ aForm bits size.
	(mask isNil or: [ mask size ~= s ])
		ifTrue: [
			mask _ WordArray new: s.
			edgeCountPerPixel _ WordArray new: s.
			morphAtPixel _ Array new: s.
			hack _ Form extent: targetWidth@targetHeight depth: 32 bits: mask.
			auxBitBlt _ BitBlt toForm: hack.
			auxBitBlt fillBitmap: (Bitmap with: 16rFF000000).
			auxBitBlt combinationRule: Form over ].

	"Perhaps this should be done in an ifCurtailed: block in case of Morphic drawing failure..."
	auxBitBlt destRect: targetForm boundingBox.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	morphAtPixel atAllPut: 0! !

!VectorEngine06 methodsFor: 'private' stamp: 'jmv 2/10/2020 16:35:43'!
updateEdgeCountAtX: x y: y
	| thisYTruncated pixelY pixelIndexBase redPixelIndex greenPixelIndex bluePixelIndex increment countWord redCount greenCount blueCount redOffset greenOffest blueOffset |

	thisYTruncated _ (y truncated max: clipTop-1) min: clipBottom-1.
	prevYTruncated ifNil: [ 
		^ prevYTruncated _ thisYTruncated ].
	thisYTruncated = prevYTruncated ifTrue: [
		^ prevYTruncated _ thisYTruncated ].

	thisYTruncated > prevYTruncated
		ifTrue: [
			pixelY _ thisYTruncated.
			increment _ 1 ]
		ifFalse: [
			pixelY _ prevYTruncated.
			increment _ -1 ].

	"All edge count at the left of the clipRect are added there (at the left of the clipRect).
	The effect is the same, and we need to clean up less stuff afterwards.
	More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses."
	pixelIndexBase _ pixelY * targetWidth + 1.
	redOffset _ (x+subPixelDelta) truncated + 1 max: clipLeft.
	greenOffest _ x truncated + 1 max: clipLeft.
	blueOffset _ (x-subPixelDelta) truncated + 1 max: clipLeft.
	redPixelIndex _ pixelIndexBase + redOffset.
	greenPixelIndex _ pixelIndexBase + greenOffest.
	bluePixelIndex _ pixelIndexBase + blueOffset.

	"Three possible cases here: RGB in one word (pixel); RG in one, and G in another; R in one, GB in another"
	redPixelIndex = bluePixelIndex
		ifTrue: [						"First case: RGB in the same word"
			redOffset <= clipRight ifTrue: [
				countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
				redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
				countWord at: 3 put: redCount.
				greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
				countWord at: 2 put: greenCount.
				blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
				countWord at: 1 put: blueCount.
				edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].
		]
		ifFalse: [
			redPixelIndex = greenPixelIndex
				ifTrue: [				"Second case: RG in one word, B in following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
				ifFalse: [			"Third case: R in one word, GB in the following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
		].
	prevYTruncated _ thisYTruncated! !

!VectorEngine06 methodsFor: 'private' stamp: 'jmv 2/10/2020 16:35:43'!
updateMaskCoda
	"Apdate alpha (transparency) mask using trajectoryPoints."

	"escribir el ultimo"
	(z_previousRedAlpha ~= z_redAlpha or: [
	z_previousGreenAlpha ~= z_greenAlpha or: [
	z_previousBlueAlpha ~= z_blueAlpha ]]) ifTrue: [
		z_alphaWord at: 3 put: z_redAlpha.
		z_alphaWord at: 2 put: z_greenAlpha.
		z_alphaWord at: 1 put: z_blueAlpha.
		mask bytesAt: z_pixelIndex put: z_alphaWord ]! !

!VectorEngine06 methodsFor: 'private' stamp: 'jmv 2/10/2020 16:35:43'!
updateMaskP: p
	"Apdate alpha (transparency) mask using trajectoryPoints."

	"Paralelizar en displayX@displayY"
	"Esto es lo que estoy haciendo ahora. Paralelizar en la bolita, lo mas afuera posible"
"NO OLVIDARSE DE RESPETAR Los clipping bounds!!!!!!"
	
	| writePrev distanceToAxisSquared alpha dySquared dx dxSquared dy dxp |

	writePrev _ false.
	p y - pixY > (openCLKernelHeight/2) ifTrue: [ pixY _ pixY + openCLKernelHeight+1. writePrev _ true].
	pixY - p y > (openCLKernelHeight/2) ifTrue: [ pixY _ pixY - openCLKernelHeight-1. writePrev _ true].
	p x - pixX > (openCLKernelWidth/2) ifTrue: [ pixX _ pixX + openCLKernelWidth+1. writePrev _ true].
	pixX - p x > (openCLKernelWidth/2) ifTrue: [ pixX _ pixX - openCLKernelWidth-1. writePrev _ true].
	
	writePrev ifTrue: [
		"escribir el anterior"
		(z_previousRedAlpha ~= z_redAlpha or: [
		z_previousGreenAlpha ~= z_greenAlpha or: [
		z_previousBlueAlpha ~= z_blueAlpha ]]) ifTrue: [
			z_alphaWord at: 3 put: z_redAlpha.
			z_alphaWord at: 2 put: z_greenAlpha.
			z_alphaWord at: 1 put: z_blueAlpha.
			mask bytesAt: z_pixelIndex put: z_alphaWord ].

		"leer el nuevo" 
		z_pixelIndex _ pixY * targetWidth +  pixX.
		z_pixelIndex _ z_pixelIndex + 1.
		z_alphaWord _ mask bytesAt: z_pixelIndex.
		z_redAlpha _ z_alphaWord at: 3.
		z_greenAlpha _ z_alphaWord at: 2.
		z_blueAlpha _ z_alphaWord at: 1.
		z_previousRedAlpha _ z_redAlpha.
		z_previousGreenAlpha _ z_greenAlpha.
		z_previousBlueAlpha _ z_blueAlpha.
		].
	
	"Minimizar"
	dy _ pixY - p y.
	dySquared _ dy * dy.
	dx _ pixX - p x.
	"Red"
	dxp _ dx - subPixelDelta.
	dxSquared _ dxp * dxp.
	distanceToAxisSquared _ dxSquared + dySquared.
	distanceToAxisSquared < strokeWidthDilatedHalfSquared
		ifTrue: [
			alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
			alpha > z_redAlpha ifTrue: [
				z_redAlpha _ alpha ]].
	"Green"
	dxSquared _ dx * dx.
	distanceToAxisSquared _ dxSquared + dySquared.
	distanceToAxisSquared < strokeWidthDilatedHalfSquared
		ifTrue: [
			alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
			alpha > z_greenAlpha ifTrue: [
				z_greenAlpha _ alpha ]].
	"Blue"
	dxp _ dx + subPixelDelta.
	dxSquared _ dxp * dxp.
	distanceToAxisSquared _ dxSquared + dySquared.
	distanceToAxisSquared < strokeWidthDilatedHalfSquared
		ifTrue: [
			alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
			alpha > z_blueAlpha ifTrue: [
				z_blueAlpha _ alpha ]].! !

!VectorEngine06 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: theta start: startAngle sweep: sweepAngle
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black fillColor: Color red do: [ :engine |
		engine basicArcCenterX: 100 centerY: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.
"
	| d hops angle thetaCos thetaSin xp yp x0 y0 x y |
	
	"Por supuesto probar tambien rx no igual a ry, y uno (o ambos) menor que el ancho de trazo..."
	thetaCos _ theta cos.
	thetaSin _ theta sin.
	angle _ startAngle.
	xp _ angle cos * rx.
	yp _ angle sin * ry.
	x0 _ thetaCos * xp - (thetaSin * yp) + cx.
	y0 _ thetaSin * xp + (thetaCos * yp) + cy.
	(startAngle ~= 0.0 or: [ sweepAngle ~= Float twoPi ])
		ifTrue: [ self basicLineToX: x0 y: y0 ]	"Draw a line. There are cases where we want to join an arc. For example, window frames"
		ifFalse: [
			"trajectory starts here. Eventually, #closePath should draw a line to here"
			"Next point will be first in a new trajectory fragment"
			prevYTruncated _ nil.
			self firstX: x0 y: y0.
			self addPenPositionX: x0 y: y0 ].
	hops _ ((rx+ry * 4 * sweepAngle abs / (2*Float pi)) * hopsPerPixel) truncated + 1.
	d _ sweepAngle / hops.
	hops timesRepeat: [
		angle _ angle + d.
		xp _ angle cos * rx.
		yp _ angle sin * ry.
		x _ thetaCos * xp - (thetaSin * yp) + cx.
		y _ thetaSin * xp + (thetaCos * yp) + cy.
		self addPenPositionX: x y: y ].

	currentX _ x.
	currentY _ y.

	self updateMaskCoda.! !

!VectorEngine06 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
basicArcToX: x2 y: y2 radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"
	"Calcular: cx, cy, rx, ry, phi, theta1, deltaTheta"
	| x1 y1 cosPhi sinPhi x12hd y12hd x1p y1p rxSq rySq x1pSq y1pSq bigSqR bigSqRNumerator bigSqRDenominator sign cxp cyp cx cy theta1 theta2 deltaTheta scaleSq scale newRx newRy |
	x1 _ currentX.
	y1 _ currentY.
	"Handle out of range parameters as requested by the w3 implementation notes"
	(x2 = x1 and: [ y2 = y1 ]) ifTrue: [ ^self ].
	(rx = 0.0 or: [ ry = 0.0 ]) ifTrue: [ ^self basicLineToX: x2 y: y2 ].
	rx < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: 0.0 -rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	ry < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: rx radiusY: 0.0-ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	
	cosPhi _ phi cos.
	sinPhi _ phi sin.
	"step 1 in http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes"
	x12hd _ (x1-x2) * 0.5.
	y12hd _ (y1-y2) * 0.5.
	x1p _ (cosPhi * x12hd) + (sinPhi * y12hd).
	y1p _ (cosPhi * y12hd) - (sinPhi * x12hd).

	"step 2"
	rxSq _ rx * rx.
	rySq _ ry * ry.
	x1pSq _ x1p * x1p.
	y1pSq _ y1p * y1p.
	"ensure radii are large enough"
	scaleSq _ (x1pSq / rxSq) + (y1pSq / rySq).
	scaleSq > 1 ifTrue: [
		scale _ scaleSq sqrt.
		newRx _ scale * rx.
		newRy _ scale * ry.
		(newRx = rx or: [ newRy = ry ]) ifTrue: [		"This happens when scaleSq is so close to 1, that the multiplication rounds to the same numbers"
			newRx _ scaleSq * rx.
			newRy _ scaleSq * ry ].
		^self basicArcToX: x2 y: y2 radiusX: newRx radiusY: newRy angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
		].
	bigSqRNumerator _ (rxSq * rySq) - (rxSq * y1pSq)-(rySq * x1pSq).
	bigSqRDenominator _ (rxSq * y1pSq) + (rySq * x1pSq).
	sign _ doLargerArc = useIncreasingAngles ifTrue: [ -1 ] ifFalse: [ 1 ].
	bigSqR _ (bigSqRNumerator / bigSqRDenominator max: 0.0) sqrt * sign.		"This only can be < 0.0 because of rounding errors. Take 0.0 in such cases."
	cxp _ bigSqR * rx * y1p / ry.
	cyp _ 0.0 - (bigSqR * ry * x1p / rx).

	"step 3"
	cx _ (cosPhi * cxp) - (sinPhi * cyp) + ((x1+x2) * 0.5).
	cy _ (sinPhi * cxp) + (cosPhi * cyp) + ((y1+y2) * 0.5).
	
"
| u v a |
Transcript clear.
u _ 1@4. v _ 7@2.
a _ ((u dotProduct: v) / (u r * v r) ) arcCos.
a _ a * (((u x * v y) - (u y * v x)) sign).
a print.
(v theta - u theta) print.
Ojo al primitivizar. Para ellos, el theta va entre -pi y pi. Para Squeak va entre cero y 2pi...
"

	"step 4"
	"Ojo signo del angulo y del eje y!!!!!!!!!!"
	theta1 _ (((x1p - cxp) / rx) @ ((y1p - cyp) / ry)) theta.
	theta2 _ (((0 - x1p - cxp) / rx) @ (( 0 -y1p - cyp) / ry)) theta.
	deltaTheta _ theta2 - theta1.
	useIncreasingAngles = (deltaTheta > 0) ifFalse: [
		deltaTheta > 0
			ifTrue: [ deltaTheta _ deltaTheta - Float pi - Float pi ]
			ifFalse: [ deltaTheta _ deltaTheta + Float pi + Float pi ]
		].
	"Y aca calcular como dar vuelta deltaTheta, ver."


	"Finalmente, estudiar la correccion de valores fuera de rango"
	

	self basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: phi start: theta1 sweep: deltaTheta! !

!VectorEngine06 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
basicClosePath
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			do_ClosePath ].
Display forceToScreen
"
	self basicLineToX: firstX y: firstY! !

!VectorEngine06 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
basicCubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	| dx dy hops increment t x0 y0 oneLessT f2 f3 f1 f23 f4 x y |

	dx _ (x1-currentX) abs + (x2-x1) abs + (x3-x2) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs + (y3-y2) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	"en muchos casos, secuencias de estos,  repetimos puntos, el ultimo de la curva anterior... pensar, etc"
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT * oneLessT.
		f23 _ 3 * oneLessT * t.
		f2 _ f23 * oneLessT.
		f3 _ f23 * t.
		f4 _ t * t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2) + (f4 * x3).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2) + (f4 * y3).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x3 y: y3.

	currentX _ x3.
	currentY _ y3.

	self updateMaskCoda.! !

!VectorEngine06 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
basicLineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 300 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 25.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 500 y: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 30 y: 15.
		engine abs_LineToX: 45 y: 90.
		engine abs_LineToX: 180 y: 30 ].
Display forceToScreen
"
	| dx dy hops incrementX incrementY x y |
	dy _ y2 - currentY.
	dx _ x2 - currentX.
	"Optimizar. En todas las lineas, bounds. En verticales, mucho mas. En horiz, no EdgeCounts!! Ver 02"
	x _ currentX.
	y _ currentY.
	hops _ ((dx abs max: dy abs) * hopsPerPixel) truncated + 1.
	incrementX _ dx *1.0 / hops.
	incrementY _ dy *1.0 / hops.
	hops timesRepeat: [
		self addPenPositionX: x y: y.
		x _ x + incrementX.
		y _ y + incrementY ].
	currentX _ x2.
	currentY _ y2.
	self addPenPositionX: currentX y: currentY.
	self updateMaskCoda.! !

!VectorEngine06 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
basicMoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150;
			abs_MoveToX: 210 y: 150;
			abs_LineToX: 300 y: 200 ].
Display forceToScreen
"

	"A discontinuity in the trajectory"

	"We are starting a new trajectory, or at a discontinuity in trajectory.
	Eventually #closeTrajectory should draw a line to here"

	"Next point will be first in a new trajectory fragment"
	prevYTruncated _ nil.
	self firstX: x y: y.
	currentX _ x.
	currentY _ y.! !

!VectorEngine06 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/10/2020 16:35:43'!
basicQuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| dx dy hops increment t x0 y0 oneLessT f1 f3 f2 x y |
	dx _ (x1-currentX) abs + (x2-x1) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT.
		f2 _ 2* oneLessT * t.
		f3 _ t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x2 y: y2.

	currentX _ x2.
	currentY _ y2.

	self updateMaskCoda.! !

!VectorEngine06 methodsFor: 'private - blend with mask' stamp: 'jmv 2/10/2020 16:35:43'!
blendFillOnly

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.

			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendFillOnlyAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine06 methodsFor: 'private - blend with mask' stamp: 'jmv 2/10/2020 16:35:43'!
blendFillOnlyAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends fill over background. Despite method selector, there might be a very thin stroke of the same color as the fill. Handle this by adjusting antiAliasAlphas.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	"In this method, antiAliasAlphas are not used to blend stroke, but fill. This means that in the inside of the shape, and away from the stroke, they must be 1.0 (not 0.0)."
	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	isRedInside ifTrue: [ antiAliasRedAlpha _ 1.0 - antiAliasRedAlpha ].
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	isGreenInside ifTrue: [ antiAliasGreenAlpha _ 1.0 - antiAliasGreenAlpha ].
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	isBlueInside ifTrue: [ antiAliasBlueAlpha _ 1.0 - antiAliasBlueAlpha ].
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * fillAlphaToUse.
	resultR _ alpha * fillRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * fillAlphaToUse.
	resultG _ alpha * fillGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * fillAlphaToUse.
	resultB _ alpha * fillBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine06 methodsFor: 'private - blend with mask' stamp: 'jmv 2/10/2020 16:35:43'!
blendStrokeAndFill

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.
			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendStrokeAndFillAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine06 methodsFor: 'private - blend with mask' stamp: 'jmv 2/10/2020 16:35:43'!
blendStrokeAndFillAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Do an appropriate (anti aliased) mix between stoke and fill (or pick just stroke or just fill). Blend this over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha foreComponent strokeAlphaToUse fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	isRedInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse.
			foreComponent _ strokeRed ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse + ((1-antiAliasRedAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasRedAlpha * strokeRed + ((1-antiAliasRedAlpha) * fillRed) ].
	resultR _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	isGreenInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
			foreComponent _ strokeGreen ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse + ((1-antiAliasGreenAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasGreenAlpha * strokeGreen + ((1-antiAliasGreenAlpha) * fillGreen) ].
	resultG _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	isBlueInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
			foreComponent _ strokeBlue ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse + ((1-antiAliasBlueAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasBlueAlpha * strokeBlue + ((1-antiAliasBlueAlpha) * fillBlue) ].
	resultB _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine06 methodsFor: 'private - blend with mask' stamp: 'jmv 2/10/2020 16:35:43'!
blendStrokeOnly

	| pixelIndex m |
	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.
				(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
					self blendStrokeOnlyAtX: displayX y: displayY pixelIndex: pixelIndex ]]].

	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine06 methodsFor: 'private - blend with mask' stamp: 'jmv 2/10/2020 16:35:43'!
blendStrokeOnlyAtX: x y: y pixelIndex: pixelIndex

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends stroke over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha strokeAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		^self].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.

	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * strokeAlphaToUse.
	resultR _ alpha * strokeRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
	resultG _ alpha * strokeGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
	resultB _ alpha * strokeBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine06 class methodsFor: 'experiments' stamp: 'jmv 2/10/2020 16:35:43'!
experLinesAndShapes
	"
	self experLinesAndShapes
	"
	| engine y1 yy2 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		yy2 _ y2 >= 1 ifTrue: [ VectorEngine defaultAntiAliasingWidth * 0.5 ] ifFalse: [0].
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1+yy2; abs_LineToX: 530 y: y1+yy2+dy;
				abs_LineToX: 530 y: y1+y2-yy2+dy; abs_LineToX: 431 y: y1+y2-yy2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1+yy2 y: 431; abs_LineToX: y1+yy2+dy y: 530;
				abs_LineToX: y1+y2-yy2+dy y: 530; abs_LineToX: y1+y2-yy2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill."
		engine fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		"solo stroke, no fill"
		engine strokeWidth: y2 color: Color black do: [
			engine
				abs_MoveToX: y2*0.5+731 y: y2*0.5 + y1+dy+dy+dy; abs_LineToX: 830 y: y2 * 0.5 + y1  + dy + dy+dy+dy.
			engine
				abs_MoveToX: y2*0.5 + y1+dy+dy+dy y: y2*0.5+731; abs_LineToX: y2 * 0.5 + y1  + dy + dy+dy+dy y: 830 ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine06 class methodsFor: 'experiments' stamp: 'jmv 2/10/2020 16:35:43'!
experLinesAndShapes2
	"
	self experLinesAndShapes2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth*4*2.
	15 timesRepeat: [
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 1.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 131 y: y1; abs_LineToX: 230 y: y1+dy;
				abs_LineToX: 230 y: y1+y2+dy; abs_LineToX: 131 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX: y1 y: 131; abs_LineToX: y1+dy y: 230;
				abs_LineToX: y1+y2+dy y: 230; abs_LineToX: y1+y2 y: 131;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.8 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 231 y: y1+dy; abs_LineToX: 330 y: y1+dy+dy;
				abs_LineToX: 330 y: y1+y2+dy+dy; abs_LineToX: 231 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 231; abs_LineToX: y1+dy+dy y: 330;
				abs_LineToX: y1+y2+dy+dy y: 330; abs_LineToX: y1+y2+dy y: 231;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.6 color: Color green fillColor: Color red do: [.
			engine
				abs_MoveToX: 331 y: y1+dy+dy; abs_LineToX: 430 y: y1+dy+dy+dy;
				abs_LineToX: 430 y: y1+y2+dy+dy+dy; abs_LineToX: 331 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 331; abs_LineToX: y1+dy+dy+dy y: 430;
				abs_LineToX: y1+y2+dy+dy+dy y: 430; abs_LineToX: y1+y2+dy+dy y: 331;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.4 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 431 y: y1+dy+dy+dy; abs_LineToX: 530 y: y1+dy+dy+dy+dy;
				abs_LineToX: 530 y: y1+y2+dy+dy+dy+dy; abs_LineToX: 431 y: y1+y2+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy+dy y: 431;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.2 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 531 y: y1+dy+dy+dy+dy; abs_LineToX: 630 y: y1+dy+dy+dy+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy+dy+dy+dy; abs_LineToX: 531 y: y1+y2+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy y: 531; abs_LineToX: y1+dy+dy+dy+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 630; abs_LineToX: y1+y2+dy+dy+dy+dy y: 531;
				do_ClosePath ].
		"Solo fill. w chico. Preferimos ya usarlo para definir mejor el shape (se transparentaria demasiado)"
		engine strokeWidth: 0.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy+dy+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 print.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine06 class methodsFor: 'experiments' stamp: 'jmv 2/10/2020 16:35:43'!
experLinesAndShapes3
	"
	self experLinesAndShapes3
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.4 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine06 class methodsFor: 'experiments' stamp: 'jmv 2/10/2020 16:35:43'!
experLinesAndShapes4
	"
	self experLinesAndShapes4
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*1.5 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine06 class methodsFor: 'experiments' stamp: 'jmv 2/10/2020 16:35:43'!
experLinesAndShapesx
	"
	self experLinesAndShapesx
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		y2 print.
		"Solo fill. w =0"
		engine strokeWidth: 0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy y: 431;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.! !

!VectorEngine06 class methodsFor: 'experiments' stamp: 'jmv 2/10/2020 16:35:44'!
experLinesAndShapesx2
	"
	self experLinesAndShapesx2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	y1 _ 10.
	dy _ 3.
	y2 _ 0.1.
	y2 print.
	"Solo fill. w =0"
	engine strokeWidth: 0.5 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 10 y: y1+dy+dy; abs_LineToX: 200 y: y1+dy+dy+dy;
			abs_LineToX: 200 y: y1+y2+dy+dy+dy; abs_LineToX: 10 y: y1+y2+dy+dy;
			do_ClosePath.
		engine
			abs_MoveToX: y1+dy+dy y: 10; abs_LineToX: y1+dy+dy+dy y: 200;
			abs_LineToX: y1+y2+dy+dy+dy y: 200; abs_LineToX: y1+y2+dy+dy y: 10;
			do_ClosePath ].
	Display forceToScreen.
! !

!VectorEngine06 class methodsFor: 'experiments' stamp: 'jmv 2/10/2020 16:35:44'!
experimentHopsPerPixel1
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 1: Very thin stroke, the same color as fill
	VectorEngine experimentHopsPerPixel1
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) *10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine06 class methodsFor: 'experiments' stamp: 'jmv 2/10/2020 16:35:44'!
experimentHopsPerPixel2
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 2: Stroke of various widths, no fill
	VectorEngine experimentHopsPerPixel2
	"
	| d engine f1 f2 hops1 hops2 strokeWidth |
	hops1 _ 200.
	hops1 _ 20.
	"
	strokeWidth -> hops2
	1.3 -> 8
	1.5 -> 6
	2 -> 4
	4 -> 3
	6 -> 2
	16 -> 1
	Maybe 10 / strokeWidth + 1 is ok?
	"
	strokeWidth _ 16*2.
	hops2 _ 8*0+1.
	hops2 _ 10.0 / strokeWidth + 1.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f2 displayAt: 220@0.

Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine06 class methodsFor: 'experiments' stamp: 'jmv 2/10/2020 16:35:44'!
experimentHopsPerPixel3
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 3: No stroke, just fill
	VectorEngine experimentHopsPerPixel3
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine06 class methodsFor: 'samples' stamp: 'jmv 2/10/2020 16:35:44'!
experiment1
	"
	No perfecto aun, pero se puede empezar a comparar con
	http://www.hpl.hp.com/research/mmsl/projects/graphics/antialiasing/figure21.htm
	Ni que hablar que es mucho mas rapido...
	self experiment1
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 e f |
engine _ self onForm: Display.
h _ 300.
h _ 490.
h _ 280.
bottom _ 200.
bottom _ 0.
centerX _ 400.
centerX _ 250.
w0 _ 120.0.
hf _ 1.0.
hf _ 1.73.
hf _ 1.71.
y _ nil.
delta _ nil.
	e _ 500@500.
	f _ Form extent: e depth: 32.
	f fillColor: Color transparent..
"	canvas _  self on: f.
	canvas useComponentAlphas."
1 to: "400" 150 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-3 // delta to: 3 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color black ] ifFalse: [ Color white ].
"			color _ color alpha: (((prevY-y) min: (x1-x2)) min: 1)."
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
"
	canvas removeSpuriousTranslucencyFloatAndBlendOver: Color red.
	f writePNGfileNamed: 'pp17.png'
"! !

!VectorEngine06 class methodsFor: 'samples' stamp: 'jmv 2/10/2020 16:35:44'!
experiment2
	"
	self experiment2
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 |
engine _ self onForm: Display.
h _ 300.
h _ 600.
bottom _ 200.
centerX _ 400.
w0 _ 60.0.
hf _ 1.0.
y _ nil.
delta _ nil.
1 to: 400 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-6 // delta to: 6 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color white ] ifFalse: [ Color black ].
			color _ color alpha: (((prevY-y) min: (x1-x2)) "* 0.3" min: 1).
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
! !

!VectorEngine06 class methodsFor: 'samples' stamp: 'jmv 2/10/2020 16:35:44'!
experiment3
	"
	self experiment3
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	100 timesRepeat: [
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
		r _ r + w.
		w _ w * 0.8.
		r _ r + w.

	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine06 class methodsFor: 'samples' stamp: 'jmv 2/10/2020 16:35:44'!
experiment4
	"
	self experiment4
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	1 to: 100 do: [ :i |
		r _ r + w.
		w _ 20.0 / i.
		r _ r + w.
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine06 class methodsFor: 'samples' stamp: 'jmv 2/20/2020 12:30:45'!
siemensStar
	"
	self siemensStar display
	"
	| angle backColor canvas count extent foreColor form location offsetFromCenter |
	count _ 32.
	angle _ Float twoPi / count / 2.
	extent _ 512.
	offsetFromCenter _ 0.
	backColor _ `Color gray: 50/255`.
	foreColor _ `Color gray: 200/255`.
	form _ Form extent: extent asPoint depth: 32.
	form fillColor: backColor.
	canvas _ VectorCanvas onForm: form.
	1 to: count do: [ :i |
		location _ AffineTransformation withRadians: i * angle * 2+0.02 scale: extent*0.45 position: extent-1/2.0 + offsetFromCenter.
		canvas engine geometryTransformation: location.
		canvas fillColor: foreColor do: [
			canvas
				moveToX: 0 y: 0;
				lineToX: 1 y: 0;
				lineToX: angle cos y: angle sin;
				lineToX: 0 y: 0.
		].
	].
	^form! !

!VectorEngine06 class methodsFor: 'instance creation' stamp: 'jmv 2/10/2020 16:35:44'!
onForm: aForm

	^ self new setForm: aForm! !

!VectorEngine06 class methodsFor: 'accessing' stamp: 'jmv 2/10/2020 16:35:44'!
antiAliasingWidthForOutlineFonts
	^1.4! !

!VectorEngine06 class methodsFor: 'accessing' stamp: 'jmv 2/10/2020 16:35:44'!
antiAliasingWidthForStrokeFonts
	^1.1! !

!VectorEngine06 class methodsFor: 'accessing' stamp: 'jmv 2/10/2020 16:35:44'!
defaultAntiAliasingWidth
	^1.3. "default for graphics"! !

!VectorEngine07 methodsFor: 'accessing' stamp: 'jmv 2/19/2020 17:57:58'!
antiAliasingWidth: aNumber

	antiAliasingWidth _ aNumber.
	antiAliasingWidthScaledInverse _ 127.0 / antiAliasingWidth! !

!VectorEngine07 methodsFor: 'accessing' stamp: 'jmv 2/19/2020 17:57:58'!
clipRect: aRectangle 
	"by convention, aRectangle includes left and top but does not include right and bottom.
	We do draw clipRight and clipBottom but not beyond.
	"
	"In targetForm coordinates"
	clipLeft _ aRectangle left.
	clipTop _ aRectangle top.
	clipRight _ aRectangle right - 1.
	clipBottom _ aRectangle bottom - 1! !

!VectorEngine07 methodsFor: 'accessing' stamp: 'jmv 2/19/2020 17:57:58'!
clippingRectForCurrentMorph
	"In targetForm coordinates.
	Only valid _after_ drawing currentMorph."

	^morphBoundsLeft @ morphBoundsTop corner: morphBoundsRight @ morphBoundsBottom! !

!VectorEngine07 methodsFor: 'accessing' stamp: 'jmv 2/19/2020 17:57:58'!
currentMorph: aMorph
	currentMorph _ aMorph! !

!VectorEngine07 methodsFor: 'accessing' stamp: 'jmv 2/19/2020 17:57:58'!
currentOwnerIfClips: currentMorphOwnerOrNil
	currentOwnerIfClips _ currentMorphOwnerOrNil! !

!VectorEngine07 methodsFor: 'accessing' stamp: 'jmv 2/19/2020 17:57:58'!
geometryTransformation
	^geometryTransformation! !

!VectorEngine07 methodsFor: 'accessing' stamp: 'jmv 2/19/2020 17:57:58'!
geometryTransformation: aGeometryTransformation
	geometryTransformation _ aGeometryTransformation! !

!VectorEngine07 methodsFor: 'stroke & fill' stamp: 'jmv 2/19/2020 17:57:58'!
fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing fill."

	doStroke _ false.
	doFill _ true.
	self pvtStrokeWidth: 0.0.
	hopsPerPixel _ 8.										"See #experimentHopsPerPixel3"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ nil. strokeRed _ nil. strokeGreen _ nil. strokeBlue _ nil.

	0 to: openCLKernelHeight do: [ :i |
		0 to: openCLKernelWidth do: [ :j |
			jj _ j. ii _ i.
			self initializePath.
			pathCommandsBlock valueWithPossibleArgument: self.
			]].
	self finishPath! !

!VectorEngine07 methodsFor: 'stroke & fill' stamp: 'jmv 2/19/2020 17:57:58'!
strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke."

	| strokeAlphaFactor aStrokeWidth |
	doStroke _ true.
	doFill _ false.
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.

	"Strokes we want to show. They are not too thin, or maybe they are, but there's no fill. Make them wide enough to be properly sampled."
	self pvtStrokeWidth: (aStrokeWidth max: antiAliasingWidth).
	strokeAlphaFactor _ aStrokeWidth / strokeWidth.
	hopsPerPixel _ 10.0 / strokeWidth + 1.		"See #experimentHopsPerPixel2"

	"Done with stroke width. Now prepare colors."
	fillAlpha _ nil. fillRed _ nil. fillGreen _ nil. fillBlue _ nil.
	strokeAlpha _ (aStrokeColor alpha * 255.0 * strokeAlphaFactor) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	0 to: openCLKernelHeight do: [ :i |
		0 to: openCLKernelWidth do: [ :j |
			jj _ j. ii _ i.
			self initializePath.
			pathCommandsBlock valueWithPossibleArgument: self.
			]].
	self finishPath! !

!VectorEngine07 methodsFor: 'stroke & fill' stamp: 'jmv 2/19/2020 17:57:58'!
strokeWidth: clientStrokeWidth color: aStrokeColor fillColor: aFillColor do: pathCommandsBlock
	"Prepare parameters for drawing stroke, fill, or both."

	| aStrokeWidth |

	aStrokeColor ifNil: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	clientStrokeWidth = 0.0 ifTrue: [ ^ self fillColor: aFillColor do: pathCommandsBlock ].
	aFillColor ifNil: [ ^ self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock ].

	"If stroke is thinner than antiAliasingWidth, we need to make it wider and less opaque.
	But this requires doing fill first and the blending stroke over it, or else fill gets eroded by widened stroke.
	(this is only relevant if fill ~= stroke~)"
	aStrokeWidth _ geometryTransformation externalizeScalar: clientStrokeWidth.
	(aStrokeWidth < antiAliasingWidth and: [ aStrokeColor ~= aFillColor ]) ifTrue: [
		self fillColor: aFillColor do: pathCommandsBlock.
		self strokeWidth: clientStrokeWidth color: aStrokeColor do: pathCommandsBlock.
		^ self ].

	doStroke _ true.
	doFill _ true.
	self pvtStrokeWidth: aStrokeWidth.
	aStrokeWidth < antiAliasingWidth
		ifTrue: [
			"Strokes are really thin, but strokeColor is same as fillColor, so there's no problem sampling them."
			hopsPerPixel _ 8 ]								"See #experimentHopsPerPixel1"
		ifFalse: [
			hopsPerPixel _ 10.0 / strokeWidth + 1 max: 2 ].		"See #experimentHopsPerPixel2. Additionally, fills require at least 2."

	"Done with stroke width. Now prepare colors."
	fillAlpha _ (aFillColor alpha * 255.0) rounded.
	fillRed _ (aFillColor red * 255.0) rounded.
	fillGreen _ (aFillColor green * 255.0) rounded.
	fillBlue _ (aFillColor blue * 255.0) rounded.
	strokeAlpha _ (aStrokeColor alpha * 255.0) rounded.
	strokeRed _ (aStrokeColor red * 255.0) rounded.
	strokeGreen _ (aStrokeColor green * 255.0) rounded.
	strokeBlue _ (aStrokeColor blue * 255.0) rounded.

	0 to: openCLKernelHeight do: [ :i |
		0 to: openCLKernelWidth do: [ :j |
			jj _ j. ii _ i.
			self initializePath.
			pathCommandsBlock valueWithPossibleArgument: self.
			]].
	self finishPath! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.2 position: 200@100);
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcToX: center x y: center y radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_CircleCenterX: cx y: cy radius: mr
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_CircleCenterX: 200 y: 150 radius: 80].
Display forceToScreen
"

	| center r |
	center _ geometryTransformation externalizePosition: cx@cy.
	r _ geometryTransformation externalizeScalar: mr.
	self
		basicArcCenterX: center x centerY: center y radiusX: r radiusY: r rotationAngle: 0.0 start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 150 y: 300 radius: 10.
		engine abs_CircleCenterX: 600 y: 400 radius: 6.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 600 y: -200 radius: 10.
		engine abs_CircleCenterX: 100 y: -100 radius: 6.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_CubicBezierToX: 300 y: 100 control1X: 600 y: -200 control2X: 100 y: -100
			].
Display forceToScreen.
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 100 control2X: 100 y: -100
			].
Display forceToScreen
	"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_CubicBezierToX: x3 y: y3 control1X: mirroredContolX y: mirroredContolY control2X: x2 y: y2! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"
	| p1 p2 p3 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	p3 _ geometryTransformation externalizePosition: x3@y3.
	self basicCubicBezierToX: p3 x y: p3 y control1X: p1 x y: p1 y control2X: p2 x y: p2 y.
	lastClientX _ x3.
	lastClientY _ y3.
	lastControlX _ x2.
	lastControlY _ y2! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 1.2 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: -0.5 ].
Display forceToScreen
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self
		basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: 0.0 sweep:  Float pi * 2;
		basicClosePath! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_EllipseCenterX: cx y: cy radiusX: mrx radiusY: mry rotationAngle: theta start: startAngle sweep: sweepAngle
	"Currently draws a line from currentX@currentY to start (if startAngle ~= 0.0 or sweepAngle ~= Float twoPi).
	This could be useful for proper fills. But might not be what is desired in some cases.
	Implement desired behavior when clear."
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6 ].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0.5 scale: 1.0 position: 200@100);
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 150 radiusX: 100 radiusY: 50 rotationAngle: 0.0 start: 0.1 sweep: 6].
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_EllipseCenterX: 200 y: 350 radiusX: 100 radiusY: 50 rotationAngle: 0.5 start: 0.1 sweep: 6 ].
Display forceToScreen.
"

	| center dx dy phi rx ry |
	center _ geometryTransformation externalizePosition: cx@cy.
	dx _ geometryTransformation externalizeDelta: mrx@0.
	dy _ geometryTransformation externalizeDelta: 0@mry.
	rx _ dx r.
	ry _ dy r.
	phi _ geometryTransformation radians + theta.
	self basicArcCenterX: center x centerY: center y radiusX: rx radiusY: ry rotationAngle: phi start: startAngle sweep:  sweepAngle! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_LineToX: x2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: x2 y: lastClientY! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p2 |
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicLineToX: p2 x y: p2 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_LineToY: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToY: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToY: 50.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX y: y2! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ].
Display forceToScreen
"
	| p |
	p _ geometryTransformation externalizePosition: x@y.
	self basicMoveToX: p x y: p y.
	lastClientX _ x.
	lastClientY _ y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 450 y: 300 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 750 y: -100 radius: 10.
		engine abs_MoveToX: 600 y: 100.
		engine
			abs_QuadraticBezierToX: 300 y: 100 controlX: 750 y: -100
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			abs_QuadraticBezierSmoothToX: 300 y: 100
			].
Display forceToScreen
"
	| mirroredContolX mirroredContolY |
	mirroredContolX _ lastClientX + (lastClientX - lastControlX).
	mirroredContolY _ lastClientY + (lastClientY - lastControlY).
	self abs_QuadraticBezierToX: x2 y: y2 controlX: mirroredContolX y: mirroredContolY! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
abs_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| p1 p2 |
	p1 _ geometryTransformation externalizePosition: x1@y1.
	p2 _ geometryTransformation externalizePosition: x2@y2.
	self basicQuadraticBezierToX: p2 x y: p2 y controlX: p1 x y: p1 y.
	lastClientX _ x2.
	lastClientY _ y2.
	lastControlX _ x1.
	lastControlY _ y1! !

!VectorEngine07 methodsFor: 'paths - absolute coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
do_ClosePath
	"abs/rel meaningless here"
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200;
			abs_CubicBezierToX: 300 y: 120 control1X: 310 y: 110 control2X: 200 y: 200;
			do_ClosePath;
			abs_LineToX: 150 y: 300 ].
Display forceToScreen
"
	| p2 |
	self basicClosePath.

	p2 _ geometryTransformation internalizePosition: currentX@currentY.
	lastClientX _ p2 x.
	lastClientY _ p2 y.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY! !

!VectorEngine07 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
rel_ArcToX: cx y: cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			rel_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false;
			do_ClosePath ].
"
	self abs_ArcToX: lastClientX + cx y: lastClientY + cy radiusX: mrx radiusY: mry angleOfXAxis: theta largeFlag: doLargerArc sweepFlag: useIncreasingAngles! !

!VectorEngine07 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
rel_CubicBezierSmoothToX: x3 y: y3 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve
	Smooth squence of curves: use as control1 point, last used control2 point."
"Check that behavior is correct!!"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierToX: 300 y: 300 control1X: 0 y: 0 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100 control1X: 150 y: 300 control2X: 600 y: 400;
			rel_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 0.2 position: 200@100);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierSmoothToX: 600 y: 100 control2X: 600 y: 400;
			abs_CubicBezierSmoothToX: 300 y: 300 control2X: 100 y: 100
			].
Display forceToScreen
	"

	self
		abs_CubicBezierSmoothToX: lastClientX + x3 y: lastClientY + y3
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine07 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
rel_CubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ];
	strokeWidth: 1.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ];
	strokeWidth: 10 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	self
		abs_CubicBezierToX: lastClientX + x3 y: lastClientY + y3
		control1X: lastClientX + x1 y: lastClientY + y1
		control2X: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine07 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
rel_LineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_LineToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine07 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
rel_MoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150];
	strokeWidth: 2.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_LineToX: 200 y: 150].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_LineToX: 15 y: 30.
		engine abs_LineToX: 60 y: 10 ];
	geometryTransformation: (AffineTransformation withScale: 10);
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_LineToX: 15 y: 30.
		engine rel_LineToX: 60 y: 10 ].
Display forceToScreen
"
	self abs_MoveToX: lastClientX + x y: lastClientY + y! !

!VectorEngine07 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
rel_QuadraticBezierSmoothToX: x2 y: y2
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color green alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 550 y: 350 radius: 10.
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300
			].
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color red alpha: 0.7) do: [ :engine |
		engine abs_CircleCenterX: 850 y: -50 radius: 10.
		engine abs_MoveToX: 700 y: 150.
		engine
			rel_QuadraticBezierToX: -300 y: -50 controlX: 150 y: -200
			].
Display forceToScreen.
"
"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 0 scale: 1.0 position: 100@300);
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			rel_QuadraticBezierToX: 600 y: 100 controlX: 450 y: 300;
			rel_QuadraticBezierSmoothToX: -300 y: -50
			].
Display forceToScreen
"
	self
		abs_QuadraticBezierSmoothToX: lastClientX + x2 y: lastClientY + y2! !

!VectorEngine07 methodsFor: 'paths - relative coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
rel_QuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 3.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ];
	strokeWidth: 3.0 color: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			rel_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	geometryTransformation: (AffineTransformation withRadians: 1 scale: 3 position: 200@100);
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ];
	strokeWidth: 2 color: (Color red alpha: 0.7) fillColor: (Color green alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine rel_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	self
		abs_QuadraticBezierToX: lastClientX + x2 y: lastClientY + y2
		controlX: lastClientX + x1 y: lastClientY + y1! !

!VectorEngine07 methodsFor: 'text' stamp: 'jmv 2/19/2020 17:57:58'!
displayString: aString from: startIndex to: stopIndex at: aPoint trueTypeFont: aFont color: aColor canvas: aCanvas
	"geometryTransformation is already set to honor font pointSize
	Use as little of aFont as possible!!"
	| glyph destX destY loc |

	self antiAliasingWidth: VectorEngine antiAliasingWidthForOutlineFonts.
	loc _ geometryTransformation.
	self fillColor: aColor do: [
		destY _ aPoint y.
		destX _ aPoint x.
		startIndex to: stopIndex do: [ :charIndex |
			glyph _ aFont ttGlyphAt: (aString at: charIndex).
			glyph isComposite
				ifFalse: [
					glyph contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ].
					]]
				ifTrue: [
					glyph txAndContoursDo: [ :tx :contours |contours do: [ :contour |
						contour isEmpty ifFalse: [
							geometryTransformation _ (loc composedWith: (AffineTransformation withTranslation: destX@destY) withYAxisNegated) composedWith: tx.
							contour initialMoveToCommand runOn: aCanvas .
							contour pathCommand runOn: aCanvas ]]]
					].
			destX _ destX + glyph advanceWidth.
		]
	].
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
addPenPositionX: x y: y

"
Inlinear en senders. Extraer afectar bounds si es posible (linea, circulo)
"

	self updateMaskX: x y: y.

	blendBoundsTop _ blendBoundsTop min: y.
	blendBoundsBottom _ blendBoundsBottom max: y.
	blendBoundsLeft _ blendBoundsLeft min: x.
	blendBoundsRight _ blendBoundsRight max: x.

	"Compute edges intersecting with this horizontal line, for fills."
	doFill ifTrue: [
		self updateEdgeCountAtX: x y: y ].! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
adjustPixX: x y: y
	| adjusted |
	adjusted _ false.
	[y - pixY > (openCLKernelHeight/2)] whileTrue: [ pixY _ pixY + openCLKernelHeight+1. adjusted _ true].
	[pixY - y > (openCLKernelHeight/2)] whileTrue: [ pixY _ pixY - openCLKernelHeight-1. adjusted _ true].
	[x - pixX > (openCLKernelWidth/2)] whileTrue: [ pixX _ pixX + openCLKernelWidth+1. adjusted _ true].
	[pixX - x > (openCLKernelWidth/2)] whileTrue: [ pixX _ pixX - openCLKernelWidth-1. adjusted _ true].
	^ adjusted! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
finishPath
	"Blend stroke and/or fill over background, according to the just computed pen alphas (distance from pixel to center of stroke)"

	blendBoundsTop _ (blendBoundsTop - strokeWidthDilatedHalf) truncated +1.
	blendBoundsBottom _ (blendBoundsBottom + strokeWidthDilatedHalf) truncated.
	blendBoundsLeft _ (blendBoundsLeft - strokeWidthDilatedHalf - subPixelDelta) truncated +1.
	blendBoundsRight _ (blendBoundsRight + strokeWidthDilatedHalf + subPixelDelta) truncated.
	blendBoundsTop < clipTop ifTrue: [ blendBoundsTop _ clipTop ].
	blendBoundsBottom > clipBottom ifTrue: [ blendBoundsBottom _ clipBottom ].
	blendBoundsLeft< clipLeft ifTrue: [ blendBoundsLeft _ clipLeft ].
	blendBoundsRight > clipRight ifTrue: [ blendBoundsRight _ clipRight ].
	
	"If we are doing a fill, and caller forgot to close the trajectory, then do it anyway."
	doFill ifTrue: [
		(firstX = currentX and: [ firstY = currentY ]) ifFalse: [
			"This is actually an error condition. If we are asked to fill, then the path should be closed.
			This is a workaround. If width > 0.0, we'll be adding a visible edge to the path."
			self basicClosePath ]].

	doFill ifTrue: [
		doStroke
			ifTrue: [ self blendStrokeAndFill ]
			ifFalse: [ self blendFillOnly ]]
		ifFalse: [
		self blendStrokeOnly ].
	morphBoundsTop _ morphBoundsTop min: blendBoundsTop.
	morphBoundsBottom _ morphBoundsBottom max: blendBoundsBottom.
	morphBoundsLeft _ morphBoundsLeft min: blendBoundsLeft.
	morphBoundsRight _ morphBoundsRight max: blendBoundsRight.

	firstX _ 0.0.
	firstY _ 0.0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.

	Display forceToScreen! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
firstX: x y: y
	pixY _ (x / (openCLKernelHeight+1)) truncated * (openCLKernelHeight+1) + ii.
	pixX _ (y / (openCLKernelWidth+1)) truncated * (openCLKernelWidth+1) + jj.
	self adjustPixX: x y: y.
	self updateMaskReadWord.

	firstX _ x.
	firstY _ y.! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
initialize
	geometryTransformation _ MorphicTranslation new. "Identity"! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
initializePath

	self firstX: 0 y: 0.
	currentX _ 0.0.
	currentY _ 0.0.
	lastClientX _ 0.0.
	lastClientY _ 0.0.
	lastControlX _ lastClientX.
	lastControlY _ lastClientY.
	prevYTruncated _ nil.

	blendBoundsTop _ targetHeight.			"drawable bottom. Will later be refined."
	blendBoundsBottom _ 0.						"drawable top. Will later be refined."
	blendBoundsLeft _ targetWidth.			"drawable right. Will later be refined."
	blendBoundsRight _ 0.						"drawable left. Will later be refined."! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
pvtStrokeWidth: aNumber
	strokeWidth _ aNumber.
	strokeWidthDilatedHalf _ strokeWidth + antiAliasingWidth * 0.5.
	strokeWidthDilatedHalfSquared _ strokeWidthDilatedHalf * strokeWidthDilatedHalf.
	strokeWidthErodedHalf _ strokeWidth - antiAliasingWidth * 0.5.
	strokeWidthErodedHalfSquared _ strokeWidthErodedHalf * strokeWidthErodedHalf * strokeWidthErodedHalf sign.
	openCLKernelWidth _ ((strokeWidthDilatedHalf + subPixelDelta) * 2) truncated + 1..
	openCLKernelHeight _ (strokeWidthDilatedHalf * 2) truncated + 1.! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
resetMorphBounds

	morphBoundsTop _ targetHeight - 1.
	morphBoundsBottom _ 0.
	morphBoundsLeft _ targetWidth - 1.
	morphBoundsRight _ 0! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
setForm: aForm
	"
	World extent: World extent
	"
	| hack s |
	targetForm _ aForm.
	targetWidth _ aForm width.
	targetHeight _ aForm height.
	self resetMorphBounds.
	self clipRect: (0@0 corner: targetWidth@targetHeight).
	self antiAliasingWidth: VectorEngine defaultAntiAliasingWidth.
	subPixelDelta _ 0.25. "Values closer to 0.333 might produce a bit of coloring on some displays. Used to be 0.28"
	s _ aForm bits size.
	(mask isNil or: [ mask size ~= s ])
		ifTrue: [
			mask _ WordArray new: s.
			edgeCountPerPixel _ WordArray new: s.
			morphAtPixel _ Array new: s.
			hack _ Form extent: targetWidth@targetHeight depth: 32 bits: mask.
			auxBitBlt _ BitBlt toForm: hack.
			auxBitBlt fillBitmap: (Bitmap with: 16rFF000000).
			auxBitBlt combinationRule: Form over ].

	"Perhaps this should be done in an ifCurtailed: block in case of Morphic drawing failure..."
	auxBitBlt destRect: targetForm boundingBox.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	morphAtPixel atAllPut: 0! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
updateEdgeCountAtX: x y: y
	| thisYTruncated pixelY pixelIndexBase redPixelIndex greenPixelIndex bluePixelIndex increment countWord redCount greenCount blueCount redOffset greenOffest blueOffset |

	thisYTruncated _ (y truncated max: clipTop-1) min: clipBottom-1.
	prevYTruncated ifNil: [ 
		^ prevYTruncated _ thisYTruncated ].
	thisYTruncated = prevYTruncated ifTrue: [
		^ prevYTruncated _ thisYTruncated ].

	thisYTruncated > prevYTruncated
		ifTrue: [
			pixelY _ thisYTruncated.
			increment _ 1 ]
		ifFalse: [
			pixelY _ prevYTruncated.
			increment _ -1 ].

	"All edge count at the left of the clipRect are added there (at the left of the clipRect).
	The effect is the same, and we need to clean up less stuff afterwards.
	More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses."
	pixelIndexBase _ pixelY * targetWidth + 1.
	redOffset _ (x+subPixelDelta) truncated + 1 max: clipLeft.
	greenOffest _ x truncated + 1 max: clipLeft.
	blueOffset _ (x-subPixelDelta) truncated + 1 max: clipLeft.
	redPixelIndex _ pixelIndexBase + redOffset.
	greenPixelIndex _ pixelIndexBase + greenOffest.
	bluePixelIndex _ pixelIndexBase + blueOffset.

	"Three possible cases here: RGB in one word (pixel); RG in one, and G in another; R in one, GB in another"
	redPixelIndex = bluePixelIndex
		ifTrue: [						"First case: RGB in the same word"
			redOffset <= clipRight ifTrue: [
				countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
				redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
				countWord at: 3 put: redCount.
				greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
				countWord at: 2 put: greenCount.
				blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
				countWord at: 1 put: blueCount.
				edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].
		]
		ifFalse: [
			redPixelIndex = greenPixelIndex
				ifTrue: [				"Second case: RG in one word, B in following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
				ifFalse: [			"Third case: R in one word, GB in the following"
					redOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: redPixelIndex.
						redCount _ (countWord at: 3) + increment bitAnd: 16rFF.
						countWord at: 3 put: redCount.
						edgeCountPerPixel bytesAt: redPixelIndex put: countWord ].

					blueOffset <= clipRight ifTrue: [
						countWord _ edgeCountPerPixel bytesAt: bluePixelIndex.
						greenCount _ (countWord at: 2) + increment bitAnd: 16rFF.
						countWord at: 2 put: greenCount.
						blueCount _ (countWord at: 1) + increment bitAnd: 16rFF.
						countWord at: 1 put: blueCount.
						edgeCountPerPixel bytesAt: bluePixelIndex put: countWord ].
				]
		].
	prevYTruncated _ thisYTruncated! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
updateMaskReadWord
	"Read alpha (transparency) mask."

	((pixY between: clipTop and: clipBottom) and: [pixX between: clipLeft and: clipRight])
		ifTrue: [
			z_pixelIndex _ pixY * targetWidth +  pixX.
			z_pixelIndex _ z_pixelIndex + 1.
			z_alphaWord _ mask bytesAt: z_pixelIndex.
			z_redAlpha _ z_alphaWord at: 3.
			z_greenAlpha _ z_alphaWord at: 2.
			z_blueAlpha _ z_alphaWord at: 1 ]
		ifFalse: [
			z_pixelIndex _ -1 ].
	z_previousRedAlpha _ z_redAlpha.
	z_previousGreenAlpha _ z_greenAlpha.
	z_previousBlueAlpha _ z_blueAlpha! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
updateMaskWriteWord
	"Update alpha (transparency) mask using trajectoryPoints."

	(z_previousRedAlpha ~= z_redAlpha or: [
	z_previousGreenAlpha ~= z_greenAlpha or: [
	z_previousBlueAlpha ~= z_blueAlpha ]]) ifTrue: [
		z_alphaWord at: 3 put: z_redAlpha.
		z_alphaWord at: 2 put: z_greenAlpha.
		z_alphaWord at: 1 put: z_blueAlpha.
		mask bytesAt: z_pixelIndex put: z_alphaWord ]! !

!VectorEngine07 methodsFor: 'private' stamp: 'jmv 2/19/2020 17:57:58'!
updateMaskX: x y: y
	"Apdate alpha (transparency) mask using trajectoryPoints."
	| distanceToAxisSquared alpha dySquared dx dxSquared dy dxp |

	(self adjustPixX: x y: y) ifTrue: [
		self updateMaskWriteWord.
		self updateMaskReadWord ].

	z_pixelIndex = -1 ifTrue: [ ^ self ].

	"Minimizar"
	dy _ pixY - y.
	dySquared _ dy * dy.
	dx _ pixX - x.
	"Red"
	dxp _ dx - subPixelDelta.
	dxSquared _ dxp * dxp.
	distanceToAxisSquared _ dxSquared + dySquared.
	distanceToAxisSquared < strokeWidthDilatedHalfSquared
		ifTrue: [
			alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
			alpha > z_redAlpha ifTrue: [
				z_redAlpha _ alpha ]].
	"Green"
	dxSquared _ dx * dx.
	distanceToAxisSquared _ dxSquared + dySquared.
	distanceToAxisSquared < strokeWidthDilatedHalfSquared
		ifTrue: [
			alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
			alpha > z_greenAlpha ifTrue: [
				z_greenAlpha _ alpha ]].
	"Blue"
	dxp _ dx + subPixelDelta.
	dxSquared _ dxp * dxp.
	distanceToAxisSquared _ dxSquared + dySquared.
	distanceToAxisSquared < strokeWidthDilatedHalfSquared
		ifTrue: [
			alpha _ distanceToAxisSquared <= strokeWidthErodedHalfSquared
				ifTrue: [ 16r7F ]
				ifFalse: [ (strokeWidthDilatedHalf - distanceToAxisSquared sqrt * antiAliasingWidthScaledInverse) rounded ].
			alpha > z_blueAlpha ifTrue: [
				z_blueAlpha _ alpha ]].! !

!VectorEngine07 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: theta start: startAngle sweep: sweepAngle
"
(VectorEngine onForm: Display)
	strokeWidth: 2.0 color: Color black fillColor: Color red do: [ :engine |
		engine basicArcCenterX: 100 centerY: 100 radiusX: 80 radiusY: 40 rotationAngle: -0.2 start: 0 sweep: Float pi * 2 ].
Display forceToScreen.
"
	| d hops angle thetaCos thetaSin xp yp x0 y0 x y |
	
	"Por supuesto probar tambien rx no igual a ry, y uno (o ambos) menor que el ancho de trazo..."
	thetaCos _ theta cos.
	thetaSin _ theta sin.
	angle _ startAngle.
	xp _ angle cos * rx.
	yp _ angle sin * ry.
	x0 _ thetaCos * xp - (thetaSin * yp) + cx.
	y0 _ thetaSin * xp + (thetaCos * yp) + cy.
	(startAngle ~= 0.0 or: [ sweepAngle ~= Float twoPi ])
		ifTrue: [ self basicLineToX: x0 y: y0 ]	"Draw a line. There are cases where we want to join an arc. For example, window frames"
		ifFalse: [
			"trajectory starts here. Eventually, #closePath should draw a line to here"
			"Next point will be first in a new trajectory fragment"
			prevYTruncated _ nil.
			self firstX: x0 y: y0.
			self addPenPositionX: x0 y: y0 ].
	hops _ ((rx+ry * 4 * sweepAngle abs / (2*Float pi)) * hopsPerPixel) truncated + 1.
	d _ sweepAngle / hops.
	hops timesRepeat: [
		angle _ angle + d.
		xp _ angle cos * rx.
		yp _ angle sin * ry.
		x _ thetaCos * xp - (thetaSin * yp) + cx.
		y _ thetaSin * xp + (thetaCos * yp) + cy.
		self addPenPositionX: x y: y ].

	currentX _ x.
	currentY _ y.

	self updateMaskWriteWord.! !

!VectorEngine07 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
basicArcToX: x2 y: y2 radiusX: rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			basicMoveToX: 100 y: 100;
			basicArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: false ].
Display forceToScreen
"
	"Calcular: cx, cy, rx, ry, phi, theta1, deltaTheta"
	| x1 y1 cosPhi sinPhi x12hd y12hd x1p y1p rxSq rySq x1pSq y1pSq bigSqR bigSqRNumerator bigSqRDenominator sign cxp cyp cx cy theta1 theta2 deltaTheta scaleSq scale newRx newRy |
	x1 _ currentX.
	y1 _ currentY.
	"Handle out of range parameters as requested by the w3 implementation notes"
	(x2 = x1 and: [ y2 = y1 ]) ifTrue: [ ^self ].
	(rx = 0.0 or: [ ry = 0.0 ]) ifTrue: [ ^self basicLineToX: x2 y: y2 ].
	rx < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: 0.0 -rx radiusY: ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	ry < 0 ifTrue: [
		^self basicArcToX: x2 y: y2 radiusX: rx radiusY: 0.0-ry angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles ].
	
	cosPhi _ phi cos.
	sinPhi _ phi sin.
	"step 1 in http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes"
	x12hd _ (x1-x2) * 0.5.
	y12hd _ (y1-y2) * 0.5.
	x1p _ (cosPhi * x12hd) + (sinPhi * y12hd).
	y1p _ (cosPhi * y12hd) - (sinPhi * x12hd).

	"step 2"
	rxSq _ rx * rx.
	rySq _ ry * ry.
	x1pSq _ x1p * x1p.
	y1pSq _ y1p * y1p.
	"ensure radii are large enough"
	scaleSq _ (x1pSq / rxSq) + (y1pSq / rySq).
	scaleSq > 1 ifTrue: [
		scale _ scaleSq sqrt.
		newRx _ scale * rx.
		newRy _ scale * ry.
		(newRx = rx or: [ newRy = ry ]) ifTrue: [		"This happens when scaleSq is so close to 1, that the multiplication rounds to the same numbers"
			newRx _ scaleSq * rx.
			newRy _ scaleSq * ry ].
		^self basicArcToX: x2 y: y2 radiusX: newRx radiusY: newRy angleOfXAxis: phi largeFlag: doLargerArc sweepFlag: useIncreasingAngles
		].
	bigSqRNumerator _ (rxSq * rySq) - (rxSq * y1pSq)-(rySq * x1pSq).
	bigSqRDenominator _ (rxSq * y1pSq) + (rySq * x1pSq).
	sign _ doLargerArc = useIncreasingAngles ifTrue: [ -1 ] ifFalse: [ 1 ].
	bigSqR _ (bigSqRNumerator / bigSqRDenominator max: 0.0) sqrt * sign.		"This only can be < 0.0 because of rounding errors. Take 0.0 in such cases."
	cxp _ bigSqR * rx * y1p / ry.
	cyp _ 0.0 - (bigSqR * ry * x1p / rx).

	"step 3"
	cx _ (cosPhi * cxp) - (sinPhi * cyp) + ((x1+x2) * 0.5).
	cy _ (sinPhi * cxp) + (cosPhi * cyp) + ((y1+y2) * 0.5).
	
"
| u v a |
Transcript clear.
u _ 1@4. v _ 7@2.
a _ ((u dotProduct: v) / (u r * v r) ) arcCos.
a _ a * (((u x * v y) - (u y * v x)) sign).
a print.
(v theta - u theta) print.
Ojo al primitivizar. Para ellos, el theta va entre -pi y pi. Para Squeak va entre cero y 2pi...
"

	"step 4"
	"Ojo signo del angulo y del eje y!!!!!!!!!!"
	theta1 _ (((x1p - cxp) / rx) @ ((y1p - cyp) / ry)) theta.
	theta2 _ (((0 - x1p - cxp) / rx) @ (( 0 -y1p - cyp) / ry)) theta.
	deltaTheta _ theta2 - theta1.
	useIncreasingAngles = (deltaTheta > 0) ifFalse: [
		deltaTheta > 0
			ifTrue: [ deltaTheta _ deltaTheta - Float pi - Float pi ]
			ifFalse: [ deltaTheta _ deltaTheta + Float pi + Float pi ]
		].
	"Y aca calcular como dar vuelta deltaTheta, ver."


	"Finalmente, estudiar la correccion de valores fuera de rango"
	

	self basicArcCenterX: cx centerY: cy radiusX: rx radiusY: ry rotationAngle: phi start: theta1 sweep: deltaTheta! !

!VectorEngine07 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
basicClosePath
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black fillColor: Color red do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_ArcToX: 200 y: 200 radiusX: 200 radiusY: 100 angleOfXAxis: 0 largeFlag: true sweepFlag: true;
			do_ClosePath ].
Display forceToScreen
"
	self basicLineToX: firstX y: firstY! !

!VectorEngine07 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
basicCubicBezierToX: x3 y: y3 control1X: x1 y: y1 control2X: x2 y: y2
	"Cubic Bezier
	http://en.wikipedia.org/wiki/Bezier_curve"
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_CubicBezierToX: 300 y: 200 control1X: 110 y: 110 control2X: 200 y: 200 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 10 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.8) do: [ :engine |
		engine abs_MoveToX: 100 y: 50.
		engine
			abs_CubicBezierToX: 600 y: 100
			control1X: 150 y: 300
			control2X: 600 y: 400 ].
Display forceToScreen
	"

	| dx dy hops increment t x0 y0 oneLessT f2 f3 f1 f23 f4 x y |

	dx _ (x1-currentX) abs + (x2-x1) abs + (x3-x2) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs + (y3-y2) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	"en muchos casos, secuencias de estos,  repetimos puntos, el ultimo de la curva anterior... pensar, etc"
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT * oneLessT.
		f23 _ 3 * oneLessT * t.
		f2 _ f23 * oneLessT.
		f3 _ f23 * t.
		f4 _ t * t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2) + (f4 * x3).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2) + (f4 * y3).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x3 y: y3.

	currentX _ x3.
	currentY _ y3.

	self updateMaskWriteWord.! !

!VectorEngine07 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
basicLineToX: x2 y: y2
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 300 y: 150 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 25.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 500 y: 200 ].
Display forceToScreen
"
"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 30 y: 15.
		engine abs_LineToX: 45 y: 90.
		engine abs_LineToX: 180 y: 30 ].
Display forceToScreen
"
	| dx dy hops incrementX incrementY x y |
	dy _ y2 - currentY.
	dx _ x2 - currentX.
	"Optimizar. En todas las lineas, bounds. En verticales, mucho mas. En horiz, no EdgeCounts!! Ver 02"
	x _ currentX.
	y _ currentY.
	hops _ ((dx abs max: dy abs) * hopsPerPixel) truncated + 1.
	incrementX _ dx *1.0 / hops.
	incrementY _ dy *1.0 / hops.
	hops timesRepeat: [
		self addPenPositionX: x y: y.
		x _ x + incrementX.
		y _ y + incrementY ].
	currentX _ x2.
	currentY _ y2.
	self addPenPositionX: currentX y: currentY.
	self updateMaskWriteWord.! !

!VectorEngine07 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
basicMoveToX: x y: y
"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_LineToX: 200 y: 150;
			abs_MoveToX: 210 y: 150;
			abs_LineToX: 300 y: 200 ].
Display forceToScreen
"

	"A discontinuity in the trajectory"

	"We are starting a new trajectory, or at a discontinuity in trajectory.
	Eventually #closeTrajectory should draw a line to here"

	"Next point will be first in a new trajectory fragment"
	prevYTruncated _ nil.
	self firstX: x y: y.
	currentX _ x.
	currentY _ y.! !

!VectorEngine07 methodsFor: 'private - paths - pixel coordinates' stamp: 'jmv 2/19/2020 17:57:58'!
basicQuadraticBezierToX: x2 y: y2 controlX: x1 y: y1
	"
(VectorEngine onForm: Display)
	strokeWidth: 1.0 color: Color black do: [ :engine |
		engine
			abs_MoveToX: 100 y: 100;
			abs_QuadraticBezierToX: 300 y: 200 controlX: 100 y: 210 ].
Display forceToScreen
	"
	"
(VectorEngine onForm: Display)
	strokeWidth: 2 color: (Color black alpha: 0.7) fillColor: (Color orange alpha: 0.4) do: [ :engine |
		engine abs_MoveToX: 10 y: 5.
		engine abs_QuadraticBezierToX: 60 y: 10 controlX: 15 y: 30 ].
Display forceToScreen
	"
	| dx dy hops increment t x0 y0 oneLessT f1 f3 f2 x y |
	dx _ (x1-currentX) abs + (x2-x1) abs.
	dy _ (y1-currentY) abs + (y2-y1) abs.
	hops _ ((dx max: dy) * hopsPerPixel) truncated + 1.
	increment _ 1.0 / hops.
	t _ 0.0.
	x0 _ currentX.
	y0 _ currentY.
	self addPenPositionX: x0 y: y0.
	hops-1 timesRepeat: [
		t _ t + increment.
		oneLessT _ 1.0 - t.
		f1 _ oneLessT * oneLessT.
		f2 _ 2* oneLessT * t.
		f3 _ t * t.
		x _ (f1 * x0) + (f2 * x1) + (f3 * x2).
		y _ (f1 * y0) + (f2 * y1) + (f3 * y2).
		self addPenPositionX: x y: y ].
	self addPenPositionX: x2 y: y2.

	currentX _ x2.
	currentY _ y2.

	self updateMaskWriteWord.! !

!VectorEngine07 methodsFor: 'private - blend with mask' stamp: 'jmv 2/19/2020 17:57:58'!
blendFillOnly

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.

			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendFillOnlyAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine07 methodsFor: 'private - blend with mask' stamp: 'jmv 2/19/2020 17:57:58'!
blendFillOnlyAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends fill over background. Despite method selector, there might be a very thin stroke of the same color as the fill. Handle this by adjusting antiAliasAlphas.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	"In this method, antiAliasAlphas are not used to blend stroke, but fill. This means that in the inside of the shape, and away from the stroke, they must be 1.0 (not 0.0)."
	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	isRedInside ifTrue: [ antiAliasRedAlpha _ 1.0 - antiAliasRedAlpha ].
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	isGreenInside ifTrue: [ antiAliasGreenAlpha _ 1.0 - antiAliasGreenAlpha ].
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	isBlueInside ifTrue: [ antiAliasBlueAlpha _ 1.0 - antiAliasBlueAlpha ].
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * fillAlphaToUse.
	resultR _ alpha * fillRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * fillAlphaToUse.
	resultG _ alpha * fillGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * fillAlphaToUse.
	resultB _ alpha * fillBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine07 methodsFor: 'private - blend with mask' stamp: 'jmv 2/19/2020 17:57:58'!
blendStrokeAndFill

	| redEdgesTotal greenEdgesTotal blueEdgesTotal redEdges greenEdges blueEdges isRedInside isGreenInside isBlueInside edgesPerPixelWord pixelIndex m |

	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		redEdgesTotal _ 0.
		greenEdgesTotal _ 0.
		blueEdgesTotal _ 0.
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.

			edgesPerPixelWord _ edgeCountPerPixel bytesAt: pixelIndex.
			redEdges _ edgesPerPixelWord at: 3.
			greenEdges _ edgesPerPixelWord at: 2.
			blueEdges _ edgesPerPixelWord at: 1.

			"Not needed in C or asm, use signed char, i.e. a type where 16rFF means -1 and not 255"
			redEdges > 127 ifTrue: [ redEdges _ redEdges - 256 ].
			greenEdges > 127 ifTrue: [ greenEdges _ greenEdges - 256 ].
			blueEdges > 127 ifTrue: [ blueEdges _ blueEdges - 256 ].

			redEdgesTotal _ redEdgesTotal + redEdges.
			greenEdgesTotal _ greenEdgesTotal + greenEdges.
			blueEdgesTotal _ blueEdgesTotal + blueEdges.
			isRedInside _ redEdgesTotal ~= 0.
			isGreenInside _ greenEdgesTotal ~= 0.
			isBlueInside _ blueEdgesTotal ~= 0.
			(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
				self
					blendStrokeAndFillAtX: displayX y: displayY pixelIndex: pixelIndex 
					redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside.
				"-----------------------"
				"y registrar el morph actual a este pixel!!, si es que lo pintamos... Mejorar. ver alpha."
				"en realidad, si el alpha usado para el verde es relevante, mayor a 0.2, p.ej...
				Ojo. Esto exige!! que los que contesten clipsSubmorphs, sean opacotes, sino...
				Uh, usar isGreenInside hace que se clippe a la mitad interna del borde... Además, no se podrá agarrar un morph de la mitad externa del borde...
				Se podria hacer que el blend conteste si estabamos adentro o no... Y simplemente usar eso...
				"
				"-----------------------"
				isGreenInside ifTrue: [
				"(auxAlphas at: pixelIndex) = 0 ifFalse: ["
					morphAtPixel at: pixelIndex put: currentMorph ]].
			]].
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: edgeCountPerPixel.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine07 methodsFor: 'private - blend with mask' stamp: 'jmv 2/19/2020 17:57:58'!
blendStrokeAndFillAtX: x y: y pixelIndex: pixelIndex redIsInside: isRedInside greenIsInside: isGreenInside blueIsInside: isBlueInside

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Do an appropriate (anti aliased) mix between stoke and fill (or pick just stroke or just fill). Blend this over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha foreComponent strokeAlphaToUse fillAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		(isRedInside or: [  isGreenInside or: [ isBlueInside ]]) ifFalse: [
			^self]].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.
	
	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	fillAlphaToUse _ fillAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	isRedInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse.
			foreComponent _ strokeRed ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasRedAlpha * strokeAlphaToUse + ((1-antiAliasRedAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasRedAlpha * strokeRed + ((1-antiAliasRedAlpha) * fillRed) ].
	resultR _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	isGreenInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
			foreComponent _ strokeGreen ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasGreenAlpha * strokeAlphaToUse + ((1-antiAliasGreenAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasGreenAlpha * strokeGreen + ((1-antiAliasGreenAlpha) * fillGreen) ].
	resultG _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	isBlueInside
		ifFalse: [							"Blend stroke over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
			foreComponent _ strokeBlue ]
		ifTrue: [ 							"Do gradient between stroke and fill. Blend the result over background"
			alpha _ antiAliasBlueAlpha * strokeAlphaToUse + ((1-antiAliasBlueAlpha) * fillAlphaToUse).
			foreComponent _ antiAliasBlueAlpha * strokeBlue + ((1-antiAliasBlueAlpha) * fillBlue) ].
	resultB _ alpha * foreComponent + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine07 methodsFor: 'private - blend with mask' stamp: 'jmv 2/19/2020 17:57:58'!
blendStrokeOnly

	| pixelIndex m |
	blendBoundsTop to: blendBoundsBottom do: [ :displayY |
		pixelIndex _ displayY * targetWidth +  blendBoundsLeft.
		blendBoundsLeft to: blendBoundsRight do: [ :displayX |
			pixelIndex _ pixelIndex + 1.
				(currentOwnerIfClips isNil or: [
				m _ morphAtPixel at: pixelIndex.
				m = currentOwnerIfClips or: [m = currentMorph]]) ifTrue: [
					self blendStrokeOnlyAtX: displayX y: displayY pixelIndex: pixelIndex ]]].

	auxBitBlt
		destX: blendBoundsLeft destY: blendBoundsTop
		width: blendBoundsRight-blendBoundsLeft+1 height: blendBoundsBottom-blendBoundsTop+1.
	auxBitBlt destForm bits: mask.
	auxBitBlt copyBits.
	Display forceToScreen! !

!VectorEngine07 methodsFor: 'private - blend with mask' stamp: 'jmv 2/19/2020 17:57:58'!
blendStrokeOnlyAtX: x y: y pixelIndex: pixelIndex

	"targetForm only contains opaque colors. Assume its alpha is always one. Don't ask for it. Set it to one when writing.
	Blends stroke over background.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in [0 .. 255]"

	| targetWord bits resultR resultG resultB antiAliasAlphasWord antiAliasRedAlpha antiAliasGreenAlpha antiAliasBlueAlpha alpha strokeAlphaToUse |

	antiAliasAlphasWord _ mask bytesAt: pixelIndex.
	antiAliasAlphasWord = "16rFF000000" #[16r00 16r00 16r00 16rFF] ifTrue: [
		^self].	"Optimization: We are completely transparent at this point. Do nothing."

	antiAliasRedAlpha _ (antiAliasAlphasWord at: 3) / 127.0.
	antiAliasGreenAlpha _ (antiAliasAlphasWord at: 2) / 127.0.
	antiAliasBlueAlpha _ (antiAliasAlphasWord at: 1) / 127.0.

	targetForm depth = 1  "We only support depths 32 and 1, right now"
		ifTrue: [
			antiAliasGreenAlpha > 0.5 ifTrue: [	"Take somewhat opaque pixels. Consider only green alpha"	"Ojo, habria que tomar el alpha del fill o border!!!!"	 "Color black pixelValueForDepth: 1"
				"Atencion: Falla si el form no es potencia de 2 (anda bien 512x512). Ademas hardcodea que somos little endian. MEJORAR (y poner en el otro blend)"
				"bits _ targetForm bits.
				backgroundWord _ bits at: pixelIndex >> 5.
				backgroundWord _ backgroundWord bitOr: 1 << (31-(pixelIndex bitAnd: 31)).
				bits at: pixelIndex >> 5 put: backgroundWord."
				"Esto es super ineficiente pero parece andar bien. Mejorar..."
				targetForm pixelValueAt: (pixelIndex \\ targetWidth) @(pixelIndex // targetWidth) put: 1
			].
			^ self].

	strokeAlphaToUse _ strokeAlpha / 255.0.
	bits _ targetForm bits.
	targetWord _ bits bytesAt: pixelIndex.

	alpha _ antiAliasRedAlpha * strokeAlphaToUse.
	resultR _ alpha * strokeRed + ((1.0 - alpha) * (targetWord at: 3)).
	targetWord at: 3 put: resultR rounded.

	alpha _ antiAliasGreenAlpha * strokeAlphaToUse.
	resultG _ alpha * strokeGreen + ((1.0 - alpha) * (targetWord at: 2)).
	targetWord at: 2 put: resultG rounded.

	alpha _ antiAliasBlueAlpha * strokeAlphaToUse.
	resultB _ alpha * strokeBlue + ((1.0 - alpha) * (targetWord at: 1)).
	targetWord at: 1 put: resultB rounded.

	bits bytesAt: pixelIndex put: targetWord.! !

!VectorEngine07 class methodsFor: 'experiments' stamp: 'jmv 2/19/2020 17:57:58'!
experLinesAndShapes
	"
	self experLinesAndShapes
	"
	| engine y1 yy2 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		yy2 _ y2 >= 1 ifTrue: [ VectorEngine defaultAntiAliasingWidth * 0.5 ] ifFalse: [0].
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1+yy2; abs_LineToX: 530 y: y1+yy2+dy;
				abs_LineToX: 530 y: y1+y2-yy2+dy; abs_LineToX: 431 y: y1+y2-yy2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1+yy2 y: 431; abs_LineToX: y1+yy2+dy y: 530;
				abs_LineToX: y1+y2-yy2+dy y: 530; abs_LineToX: y1+y2-yy2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill."
		engine fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		"solo stroke, no fill"
		engine strokeWidth: y2 color: Color black do: [
			engine
				abs_MoveToX: y2*0.5+731 y: y2*0.5 + y1+dy+dy+dy; abs_LineToX: 830 y: y2 * 0.5 + y1  + dy + dy+dy+dy.
			engine
				abs_MoveToX: y2*0.5 + y1+dy+dy+dy y: y2*0.5+731; abs_LineToX: y2 * 0.5 + y1  + dy + dy+dy+dy y: 830 ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine07 class methodsFor: 'experiments' stamp: 'jmv 2/19/2020 17:57:58'!
experLinesAndShapes2
	"
	self experLinesAndShapes2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth*4*2.
	15 timesRepeat: [
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 1.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 131 y: y1; abs_LineToX: 230 y: y1+dy;
				abs_LineToX: 230 y: y1+y2+dy; abs_LineToX: 131 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX: y1 y: 131; abs_LineToX: y1+dy y: 230;
				abs_LineToX: y1+y2+dy y: 230; abs_LineToX: y1+y2 y: 131;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.8 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 231 y: y1+dy; abs_LineToX: 330 y: y1+dy+dy;
				abs_LineToX: 330 y: y1+y2+dy+dy; abs_LineToX: 231 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 231; abs_LineToX: y1+dy+dy y: 330;
				abs_LineToX: y1+y2+dy+dy y: 330; abs_LineToX: y1+y2+dy y: 231;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.6 color: Color green fillColor: Color red do: [.
			engine
				abs_MoveToX: 331 y: y1+dy+dy; abs_LineToX: 430 y: y1+dy+dy+dy;
				abs_LineToX: 430 y: y1+y2+dy+dy+dy; abs_LineToX: 331 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 331; abs_LineToX: y1+dy+dy+dy y: 430;
				abs_LineToX: y1+y2+dy+dy+dy y: 430; abs_LineToX: y1+y2+dy+dy y: 331;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.4 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 431 y: y1+dy+dy+dy; abs_LineToX: 530 y: y1+dy+dy+dy+dy;
				abs_LineToX: 530 y: y1+y2+dy+dy+dy+dy; abs_LineToX: 431 y: y1+y2+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy+dy y: 431;
				do_ClosePath ].
		"Solo fill. w chico pero aun visible"
		engine strokeWidth: 0.2 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 531 y: y1+dy+dy+dy+dy; abs_LineToX: 630 y: y1+dy+dy+dy+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy+dy+dy+dy; abs_LineToX: 531 y: y1+y2+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy y: 531; abs_LineToX: y1+dy+dy+dy+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 630; abs_LineToX: y1+y2+dy+dy+dy+dy y: 531;
				do_ClosePath ].
		"Solo fill. w chico. Preferimos ya usarlo para definir mejor el shape (se transparentaria demasiado)"
		engine strokeWidth: 0.0 color: Color green fillColor: Color red do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy+dy+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy+dy+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy+dy+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy+dy+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 print.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen! !

!VectorEngine07 class methodsFor: 'experiments' stamp: 'jmv 2/19/2020 17:57:58'!
experLinesAndShapes3
	"
	self experLinesAndShapes3
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.4 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine07 class methodsFor: 'experiments' stamp: 'jmv 2/19/2020 17:57:58'!
experLinesAndShapes4
	"
	self experLinesAndShapes4
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.
	engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 220 y: 10;
			abs_LineToX: 410 y: 15; abs_LineToX: 220 y: 20;
			abs_LineToX: 215 y: 410; abs_LineToX: 210 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		"stroke con w > aaw"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*2 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 431 y: y1; abs_LineToX: 530 y: y1+dy;
				abs_LineToX: 530 y: y1+y2+dy; abs_LineToX: 431 y: y1+y2;
				do_ClosePath.
			engine
				abs_MoveToX:  y1 y: 431; abs_LineToX: y1+dy y: 530;
				abs_LineToX: y1+y2+dy y: 530; abs_LineToX: y1+y2 y: 431;
				do_ClosePath ].
		"Solo fill. w casi=0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth*1.5 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 531 y: y1+dy; abs_LineToX: 630 y: y1+dy+dy;
				abs_LineToX: 630 y: y1+y2+dy+dy; abs_LineToX: 531 y: y1+y2+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy y: 531; abs_LineToX: y1+dy+dy y: 630;
				abs_LineToX: y1+y2+dy+dy y: 630; abs_LineToX: y1+y2+dy y: 531;
				do_ClosePath ].
		"Solo fill. w =0"
		engine strokeWidth: VectorEngine defaultAntiAliasingWidth color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 631; abs_LineToX: y1+dy+dy+dy y: 730;
				abs_LineToX: y1+y2+dy+dy+dy y: 730; abs_LineToX: y1+y2+dy+dy y: 631;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.
! !

!VectorEngine07 class methodsFor: 'experiments' stamp: 'jmv 2/19/2020 17:57:58'!
experLinesAndShapesx
	"
	self experLinesAndShapesx
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	Display forceToScreen.

	y1 _ 10.
	dy _ 3.
	y2 _ VectorEngine defaultAntiAliasingWidth * 2.
	15 timesRepeat: [
		y2 print.
		"Solo fill. w =0"
		engine strokeWidth: 0.0 color: Color black fillColor: Color black do: [
			engine
				abs_MoveToX: 631 y: y1+dy+dy; abs_LineToX: 730 y: y1+dy+dy+dy;
				abs_LineToX: 730 y: y1+y2+dy+dy+dy; abs_LineToX: 631 y: y1+y2+dy+dy;
				do_ClosePath.
			engine
				abs_MoveToX: y1+dy+dy y: 431; abs_LineToX: y1+dy+dy+dy y: 530;
				abs_LineToX: y1+y2+dy+dy+dy y: 530; abs_LineToX: y1+y2+dy+dy y: 431;
				do_ClosePath ].
		y1 _ y1 + y2 + VectorEngine defaultAntiAliasingWidth + 3.
		Display forceToScreen.
		y2 _ y2 * 0.8.
	].
	
	Display forceToScreen.! !

!VectorEngine07 class methodsFor: 'experiments' stamp: 'jmv 2/19/2020 17:57:58'!
experLinesAndShapesx2
	"
	self experLinesAndShapesx2
	"
	| engine y1 dy y2 |
	engine _ self onForm: Display.
	y1 _ 10.
	dy _ 3.
	y2 _ 0.1.
	y2 print.
	"Solo fill. w =0"
	engine strokeWidth: 0.5 color: Color black fillColor: Color black do: [
		engine
			abs_MoveToX: 10 y: y1+dy+dy; abs_LineToX: 200 y: y1+dy+dy+dy;
			abs_LineToX: 200 y: y1+y2+dy+dy+dy; abs_LineToX: 10 y: y1+y2+dy+dy;
			do_ClosePath.
		engine
			abs_MoveToX: y1+dy+dy y: 10; abs_LineToX: y1+dy+dy+dy y: 200;
			abs_LineToX: y1+y2+dy+dy+dy y: 200; abs_LineToX: y1+y2+dy+dy y: 10;
			do_ClosePath ].
	Display forceToScreen.
! !

!VectorEngine07 class methodsFor: 'experiments' stamp: 'jmv 2/19/2020 17:57:58'!
experimentHopsPerPixel1
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 1: Very thin stroke, the same color as fill
	VectorEngine experimentHopsPerPixel1
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: 0.001 color: Color black fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) *10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine07 class methodsFor: 'experiments' stamp: 'jmv 2/19/2020 17:57:58'!
experimentHopsPerPixel2
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 2: Stroke of various widths, no fill
	VectorEngine experimentHopsPerPixel2
	"
	| d engine f1 f2 hops1 hops2 strokeWidth |
	hops1 _ 200.
	hops1 _ 20.
	"
	strokeWidth -> hops2
	1.3 -> 8
	1.5 -> 6
	2 -> 4
	4 -> 3
	6 -> 2
	16 -> 1
	Maybe 10 / strokeWidth + 1 is ok?
	"
	strokeWidth _ 16*2.
	hops2 _ 8*0+1.
	hops2 _ 10.0 / strokeWidth + 1.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine strokeWidth: strokeWidth color: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 40 y: 30;
			abs_LineToX: 190 y: 135; abs_LineToX: 40 y: 40;
			abs_LineToX: 135 y: 390; abs_LineToX: 30 y: 40;
			do_ClosePath ].
	f2 displayAt: 220@0.

Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine07 class methodsFor: 'experiments' stamp: 'jmv 2/19/2020 17:57:58'!
experimentHopsPerPixel3
	"Play with this to learn about the effect of hopsPerPixel
	Experiment 3: No stroke, just fill
	VectorEngine experimentHopsPerPixel3
	"
	| d engine f1 f2 hops1 hops2 |
	hops1 _ 200.
	hops2 _ 8.
	f1 _ Form extent: 220@420 depth: 32.
	f1 fillColor: Color white.
	engine _ VectorEngine onForm: f1.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops1.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f1 displayAt: 0@0.

	f2 _ Form extent: 220@420 depth: 32.
	f2 fillColor: Color white.
	engine _ VectorEngine onForm: f2.
	engine fillColor: Color black do: [
		engine instVarNamed: 'hopsPerPixel' put: hops2.
		engine
			abs_MoveToX: 20 y: 10;
			abs_LineToX: 210 y: 15; abs_LineToX: 20 y: 20;
			abs_LineToX: 15 y: 410; abs_LineToX: 10 y: 20;
			do_ClosePath ].
	f2 displayAt: 220@0.

	Feature require: 'LinearAlgebra'.
	Smalltalk at: #FloatMatrix ifPresent: [ :matrixClass |
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 440@0.
		d _ (matrixClass form: f1 color: #red) - (matrixClass form: f2 color: #red) * 10 + 0.5.
		(d asFormMin: 0 max: 1) displayAt: 660@0.
		{d elements min * 255. d elements max * 255. 'diff entre'. hops1. hops2} print ]! !

!VectorEngine07 class methodsFor: 'samples' stamp: 'jmv 2/19/2020 17:57:58'!
experiment1
	"
	No perfecto aun, pero se puede empezar a comparar con
	http://www.hpl.hp.com/research/mmsl/projects/graphics/antialiasing/figure21.htm
	Ni que hablar que es mucho mas rapido...
	self experiment1
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 e f |
engine _ self onForm: Display.
h _ 300.
h _ 490.
h _ 280.
bottom _ 200.
bottom _ 0.
centerX _ 400.
centerX _ 250.
w0 _ 120.0.
hf _ 1.0.
hf _ 1.73.
hf _ 1.71.
y _ nil.
delta _ nil.
	e _ 500@500.
	f _ Form extent: e depth: 32.
	f fillColor: Color transparent..
"	canvas _  self on: f.
	canvas useComponentAlphas."
1 to: "400" 150 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-3 // delta to: 3 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color black ] ifFalse: [ Color white ].
"			color _ color alpha: (((prevY-y) min: (x1-x2)) min: 1)."
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
"
	canvas removeSpuriousTranslucencyFloatAndBlendOver: Color red.
	f writePNGfileNamed: 'pp17.png'
"! !

!VectorEngine07 class methodsFor: 'samples' stamp: 'jmv 2/19/2020 17:57:58'!
experiment2
	"
	self experiment2
	"
| engine h bottom centerX w0 hf y delta prevDelta prevY color x1p x2p x1 x2 |
engine _ self onForm: Display.
h _ 300.
h _ 600.
bottom _ 200.
centerX _ 400.
w0 _ 60.0.
hf _ 1.0.
y _ nil.
delta _ nil.
1 to: 400 do: [ :i |
	i print.
	prevDelta _ delta.
	delta _ h / (w0 * i + h).
	prevY _ y.
	y _ bottom + (delta * hf * h).
	prevY ifNotNil: [
"		-40 to: 40 do: [ :ii |"
		-6 // delta to: 6 // delta do: [ :ii |
			x1p _ centerX - (prevDelta * w0 * (ii-1)).
			x2p _ centerX - (prevDelta * w0 * ii).
			x1 _ centerX - (delta * w0 * (ii-1)).
			x2 _ centerX - (delta * w0 * ii).
			color _ i + ii \\ 2 = 0 ifTrue: [ Color white ] ifFalse: [ Color black ].
			color _ color alpha: (((prevY-y) min: (x1-x2)) "* 0.3" min: 1).
"			color _ color alpha: 0.5."
			engine fillColor: color do: [
				engine
					abs_MoveToX: x1 y: y;
					abs_LineToX: x2 y: y;
					abs_LineToX: x2p y: prevY;
					abs_LineToX: x1p y: prevY;
					do_ClosePath ]
			].
		].
	Display forceToScreen.
	].
Display forceToScreen.
! !

!VectorEngine07 class methodsFor: 'samples' stamp: 'jmv 2/19/2020 17:57:58'!
experiment3
	"
	self experiment3
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	100 timesRepeat: [
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
		r _ r + w.
		w _ w * 0.8.
		r _ r + w.

	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine07 class methodsFor: 'samples' stamp: 'jmv 2/19/2020 17:57:58'!
experiment4
	"
	self experiment4
	"
	| engine w r |
	engine _ self onForm: Display.
	w _ 10.
	r _ 15.
	1 to: 100 do: [ :i |
		r _ r + w.
		w _ 20.0 / i.
		r _ r + w.
		engine strokeWidth: w color: Color black do: [
			engine abs_CircleCenterX: 300 y: 300 radius: r ].
	Display forceToScreen.
	].
Display forceToScreen! !

!VectorEngine07 class methodsFor: 'samples' stamp: 'jmv 2/20/2020 12:30:52'!
siemensStar
	"
	self siemensStar display
	"
	| angle backColor canvas count extent foreColor form location offsetFromCenter |
	count _ 32.
	angle _ Float twoPi / count / 2.
	extent _ 512.
	offsetFromCenter _ 0.
	backColor _ `Color gray: 50/255`.
	foreColor _ `Color gray: 200/255`.
	form _ Form extent: extent asPoint depth: 32.
	form fillColor: backColor.
	canvas _ VectorCanvas onForm: form.
	1 to: count do: [ :i |
		location _ AffineTransformation withRadians: i * angle * 2+0.02 scale: extent*0.45 position: extent-1/2.0 + offsetFromCenter.
		canvas engine geometryTransformation: location.
		canvas fillColor: foreColor do: [
			canvas
				moveToX: 0 y: 0;
				lineToX: 1 y: 0;
				lineToX: angle cos y: angle sin;
				lineToX: 0 y: 0.
		].
	].
	^form! !

!VectorEngine07 class methodsFor: 'instance creation' stamp: 'jmv 2/19/2020 17:57:58'!
onForm: aForm

	^ self new setForm: aForm! !

!VectorEngine07 class methodsFor: 'accessing' stamp: 'jmv 2/19/2020 17:57:58'!
antiAliasingWidthForOutlineFonts
	^1.4! !

!VectorEngine07 class methodsFor: 'accessing' stamp: 'jmv 2/19/2020 17:57:58'!
antiAliasingWidthForStrokeFonts
	^1.1! !

!VectorEngine07 class methodsFor: 'accessing' stamp: 'jmv 2/19/2020 17:57:58'!
defaultAntiAliasingWidth
	^1.3. "default for graphics"! !
