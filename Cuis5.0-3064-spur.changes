'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 7 November 2016 at 2:53:38 pm'!


----SNAPSHOT----#(7 November 2016 2:53:55.973029 pm) Cuis5.0-2974-spur.image priorSource: 0!

----QUIT----#(7 November 2016 2:54:03.110029 pm) Cuis5.0-2974-spur.image priorSource: 92!

----STARTUP----#(17 November 2016 12:32:23.600889 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-2974-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 16 November 2016 at 3:55:25 pm'!
!Integer class methodsFor: 'instance creation' stamp: 'jmv 11/16/2016 15:37:15' prior: 16860879!
              readFrom: aStream base: base
	"Answer an instance of one of my concrete subclasses. Initial minus sign
	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not
	allowed--use Number readFrom: for that. Answer zero (not an error) if
	there are no digits."

	| digit value neg cc atLeastOneDigitRead |
	neg _ aStream peekFor: $-.
	neg ifFalse: [aStream peekFor: $+].
	value _ 0.
	atLeastOneDigitRead _ false.
	[ aStream atEnd ]
		whileFalse: [
			cc _ aStream next.
			digit _ cc digitValue.
			(digit < 0 or: [digit >= base])
				ifTrue: [
					aStream skip: -1.
					atLeastOneDigitRead ifFalse: [self error: 'At least one digit expected here'].
					^neg
						ifTrue: [value negated]
						ifFalse: [value]].
			value _ value * base + digit.
			atLeastOneDigitRead _ true ].
	neg ifTrue: [^ value negated].
	^ value! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2975-Integer-readFrom-cleanup-JuanVuletich-2016Nov16-15h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2975] on 17 November 2016 at 9:08:34 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:06:59' prior: 16891425!
           peek
	"Answer what would be returned if the message next were sent to the 
	receiver. If the receiver is at the end, answer nil."

	| nextObject |
	position < readLimit ifTrue: [
		^collection at: position+1 ].
	self atEnd ifTrue: [^nil].
	nextObject _ self next.
	position _ position - 1.
	^nextObject! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 11/17/2016 09:07:20' prior: 16913380!
    peek
	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "
	| next |
	position < readLimit ifTrue: [
		^collection at: position+1 ].
	self atEnd ifTrue: [^ nil].
	next _ self basicNext.
	self position: self position - 1.
	^ next! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2976-peek-Optimization-JuanVuletich-2016Nov17-09h06m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2975] on 17 November 2016 at 9:18:37 am'!
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:42'!
                               nextDouble64BigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: false ])
			readStream nextDouble64BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: true ])
			readStream nextDouble64BigEndian: true
	"
	| bytes |
	bytes _ self next: 8.
	^ bytes doubleAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:40'!
            nextDouble64Put: aFloat bigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 8.
	bytes doubleAt: 1 put: aFloat bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:38'!
      nextFloat32BigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'
	Float pi asIEEE32BitWord hex '16r40490FDB'
	Float pi negated asIEEE32BitWord hex '16rC0490FDB'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: false ])
			readStream nextFloat32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: true ])
			readStream nextFloat32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes floatAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:34'!
                  nextFloat32Put: aFloat bigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'
	Float pi asIEEE32BitWord hex '16r40490FDB'
	Float pi negated asIEEE32BitWord hex '16rC0490FDB'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: false ]) hex 'DB0F4940'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: true ]) hex '40490FDB'
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes floatAt: 1 put: aFloat bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
                    nextSignedInt16BigEndian: bigEndian
	"Answer the next  signed, 16-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: false ]) 
			readStream nextSignedInt16BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: true ]) 
			readStream nextSignedInt16BigEndian: true
	"
	| bytes |
	bytes _ self next: 2.
	^ bytes shortAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
          nextSignedInt16Put: aNumber bigEndian: bigEndian
	"Store the given number as a signed, 16-bit integer on this (binary) stream.

	(16r10000-12345) hex '16rCFC7'

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 2.
	bytes shortAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
nextSignedInt32BigEndian: bigEndian
	"Answer the next signed, 32-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: false ]) 
			readStream nextSignedInt32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: true ]) 
			readStream nextSignedInt32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes longAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
          nextSignedInt32Put: aNumber bigEndian: bigEndian
	"Store the given number as a signed, 32-bit integer on this (binary) stream.

	(16r100000000-123456) hex '16rFFFE1DC0'

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes longAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:18'!
                      nextUnsignedInt16BigEndian: bigEndian
	"Answer the next unsigned, 16-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: false ]) 
			readStream nextUnsignedInt16BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: true ]) 
			readStream nextUnsignedInt16BigEndian: true
	"
	| bytes |
	bytes _ self next: 2.
	^ bytes unsignedShortAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
                         nextUnsignedInt16Put: aNumber bigEndian: bigEndian
	"Store the given number as a unsigned, 16-bit integer on this (binary) stream.

	12345 hex  '16r3039'

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 2.
	bytes unsignedShortAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:19'!
                            nextUnsignedInt32BigEndian: bigEndian
	"Answer the next unsigned, 32-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: false ]) 
			readStream nextUnsignedInt32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: true ]) 
			readStream nextUnsignedInt32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes unsignedLongAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
                        nextUnsignedInt32Put: aNumber bigEndian: bigEndian
	"Store the given number as a unsigned, 32-bit integer on this (binary) stream.

	123456 hex '16r1E240'

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes unsignedLongAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 6/14/2013 20:02'!
                   nextNumber
	"Answer a number from the stream."

	|element|
	[(element := self next) isNil or: [element isDigit or: [element = $- or: [element = $)]]]] whileFalse.
	element ifNil: [^nil].
	self skip: -1.
	element = $) ifTrue: [^nil].
	^Number readFrom: self! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 2/29/2016 11:04'!
               nextNumber: n 
	"Answer the next n bytes as a positive Integer or LargePositiveInteger.
	Currently only for bigEndian. Consider following the convention in category 'normalized access'"
	| s |
	s _ 0.
	1 to: n do: 
		[:i | s _ (s bitShift: 8) bitOr: self next asInteger].
	^ s normalize! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 2/29/2016 11:04'!
                 nextNumber: n put: v 
	"Append to the receiver the argument, v, which is a positive 
	SmallInteger or a LargePositiveInteger, as the next n bytes.
	Possibly pad with leading zeros.
	Currently only for bigEndian. Consider following the convention in category 'normalized access'"

	1 to: n do: [:i | self nextPut: (v digitAt: n+1-i)].
	^ v
! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'ls 9/14/1998 22:46'!
                             nextString
	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."

	| aString length |

	"read the length in binary mode"
	self binary.
	length _ self next.		"first byte."
	length >= 192 ifTrue: [length _ length - 192.
		1 to: 3 do: [:ii | length _ length * 256 + self next]].
	aString _ String new: length.

	"read the characters in ASCII mode"
	self ascii.
	self nextInto: aString.
	^aString! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'yo 4/16/2001 17:56'!
                 nextStringPut: s 
	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."

	| length |
	(length _ s size) < 192
		ifTrue: [self nextPut: length]
		ifFalse: 
			[self nextPut: (length digitAt: 4)+192.
			self nextPut: (length digitAt: 3).
			self nextPut: (length digitAt: 2).
			self nextPut: (length digitAt: 1)].
	self nextPutAll: s asByteArray.
	^s! !

DummyStream removeSelector: #nextDouble64BigEndian:!

DummyStream removeSelector: #nextDouble64BigEndian:!

DummyStream removeSelector: #nextDouble64Put:bigEndian:!

DummyStream removeSelector: #nextDouble64Put:bigEndian:!

DummyStream removeSelector: #nextNumber:put:!

DummyStream removeSelector: #nextNumber:put:!

DummyStream removeSelector: #nextSignedInt16BigEndian:!

DummyStream removeSelector: #nextSignedInt16BigEndian:!

DummyStream removeSelector: #nextSignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextSignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextSignedInt32BigEndian:!

DummyStream removeSelector: #nextSignedInt32BigEndian:!

DummyStream removeSelector: #nextSignedInt32Put:bigEndian:!

DummyStream removeSelector: #nextSignedInt32Put:bigEndian:!

DummyStream removeSelector: #nextStringPut:!

DummyStream removeSelector: #nextStringPut:!

DummyStream removeSelector: #nextUnsignedInt16BigEndian:!

DummyStream removeSelector: #nextUnsignedInt16BigEndian:!

DummyStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextUnsignedInt32BigEndian:!

DummyStream removeSelector: #nextUnsignedInt32BigEndian:!

DummyStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

DummyStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

DataStream removeSelector: #readStringOld!

DataStream removeSelector: #readStringOld!

PositionableStream removeSelector: #nextDouble64BigEndian:!

PositionableStream removeSelector: #nextDouble64BigEndian:!

PositionableStream removeSelector: #nextDouble64Put:bigEndian:!

PositionableStream removeSelector: #nextDouble64Put:bigEndian:!

PositionableStream removeSelector: #nextFloat32BigEndian:!

PositionableStream removeSelector: #nextFloat32BigEndian:!

PositionableStream removeSelector: #nextFloat32Put:bigEndian:!

PositionableStream removeSelector: #nextFloat32Put:bigEndian:!

PositionableStream removeSelector: #nextNumber!

PositionableStream removeSelector: #nextNumber!

PositionableStream removeSelector: #nextNumber:!

PositionableStream removeSelector: #nextNumber:!

PositionableStream removeSelector: #nextNumber:put:!

PositionableStream removeSelector: #nextNumber:put:!

PositionableStream removeSelector: #nextSignedInt16BigEndian:!

PositionableStream removeSelector: #nextSignedInt16BigEndian:!

PositionableStream removeSelector: #nextSignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextSignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextSignedInt32BigEndian:!

PositionableStream removeSelector: #nextSignedInt32BigEndian:!

PositionableStream removeSelector: #nextSignedInt32Put:bigEndian:!

PositionableStream removeSelector: #nextSignedInt32Put:bigEndian:!

PositionableStream removeSelector: #nextString!

PositionableStream removeSelector: #nextString!

PositionableStream removeSelector: #nextStringOld!

PositionableStream removeSelector: #nextStringOld!

PositionableStream removeSelector: #nextStringPut:!

PositionableStream removeSelector: #nextStringPut:!

PositionableStream removeSelector: #nextUnsignedInt16BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt16BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

Stream removeSelector: #nextStringOld!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2977-Stream-refactor-JuanVuletich-2016Nov17-09h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2977] on 17 November 2016 at 10:29:07 am'!
!PositionableStream methodsFor: 'testing' stamp: 'jmv 11/17/2016 10:28:06' prior: 16891536!
         atEnd
	"Answer whether the receiver can access any more objects."

	^position >= readLimit! !
!ReadStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:59:57' prior: 16897965!
            next
	"Answer the next object in the Stream represented by the receiver."

	^position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 10:28:35' prior: 16946385!
             nextPut: anObject 
	"Insert the argument at the next position in the Stream represented by the receiver."

	position >= writeLimit
		ifTrue: [^ self pastEndPut: anObject]
		ifFalse: [
			position _ position + 1.
			^collection at: position put: anObject]! !
!ReadWriteStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 10:28:45' prior: 16898094!
   next
	"Return the next object in the Stream represented by the receiver."

	"treat me as a FIFO"
	^ position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 11/17/2016 10:00:56' prior: 16913098!
   basicNext
	"Answer the next byte from this file, or nil if at the end of the file."
	
	| count |
	collection ifNotNil: [
		position < readLimit 
			ifFalse: [ 
				readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.
				position := 0.
				readLimit = 0 ifTrue: [ ^nil ] ].
		^collection at: (position := position + 1) ].	
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	^count = 1
		ifTrue: [ buffer1 at: 1 ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2978-RemoveObsoletePrimCalls-JuanVuletich-2016Nov17-10h26m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2977] on 17 November 2016 at 10:31:18 am'!

Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOReadStream category: #'System-Support'!
Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!
!StdIOReadStream commentStamp: '<historical>' prior: 0!
     Standard Input Stream.

A basic problem/restriction with this code is that currently the VM runs multiple VM threads within a single OS thread.

This means that waiting on StdIn blocks the VM, suspending all Smalltalk code.!

Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOWriteStream category: #'System-Support'!
Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!
!StdIOWriteStream commentStamp: '<historical>' prior: 0!
               Standard Output/Error Streams.!
!StdIOReadStream methodsFor: 'open / close' stamp: 'jmv 11/17/2016 10:12:24'!
                  openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID _ aFileID.
	name _ streamName.
	buffer1 _ String new: 1! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 10:01:57'!
                          next
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!"

	| count |
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	^count = 1
		ifTrue: [ buffer1 at: 1 ]! !
!StdIOReadStream methodsFor: 'printing' stamp: 'jmv 11/17/2016 09:47:10'!
                     printOn: aStream
	"Put a printed version of the receiver onto aStream."

	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !
!StdIOReadStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 09:45:28'!
    primRead: id into: byteArray startingAt: startIndex count: count
	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."

	<primitive: 'primitiveFileRead' module: 'FilePlugin'>
	self error: 'File read failed'! !
!StdIOReadStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 09:46:36'!
               stdin
	| newSelf |
	newSelf _ self basicNew.
	newSelf 
		openOnHandle: self stdinHandle 
		name: 'stdin'.
	^newSelf! !
!StdIOReadStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:47'!
                        stdinHandle

	^ StdIOWriteStream stdioHandles at: 1! !
!StdIOWriteStream methodsFor: 'open / close' stamp: 'jmv 11/17/2016 10:14:32'!
                          openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID _ aFileID.
	name _ streamName.
	buffer1 _ String new: 1! !
!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 10:19:51'!
                         flush
	"Flush pending changes"
	^self primFlush: fileID! !
!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 10:18:42'!
                         nextPut: char
	"Write the given character to this file."

	buffer1 at: 1 put: char.
	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.
	^ char
! !
!StdIOWriteStream methodsFor: 'printing' stamp: 'jmv 11/17/2016 09:35:56'!
                       printOn: aStream
	"Put a printed version of the receiver onto aStream.  1/31/96 sw"

	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !
!StdIOWriteStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 10:20:17'!
                       primFlush: id
	"Flush pending changes to the disk"

	<primitive: 'primitiveFileFlush' module: 'FilePlugin'>! !
!StdIOWriteStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 10:19:14'!
    primWrite: id from: stringOrByteArray startingAt: startIndex count: count
	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."

	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>
	(FileWriteError fileName: name)
		signal: (self closed
			ifTrue: [ 'File [', name, '] is closed' ]
			ifFalse: [ 'File [', name, '] write failed' ])! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 10:15:08'!
stderr
	| newSelf |
	newSelf _ self basicNew.
	newSelf 
		openOnHandle: self stderrHandle 
		name: 'stderr'.
	^newSelf! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 10:15:11'!
            stdout
	| newSelf |
	newSelf _ self basicNew.
	newSelf 
		openOnHandle: self stdoutHandle 
		name: 'stdout'.
	^newSelf! !
!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:20'!
                    stderrHandle

	^ self stdioHandles at: 3! !
!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:09'!
  stdioHandles
" answer handles: #(stdin stdout stderr) "
	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: ec>
	self primitiveFailed! !
!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:12'!
                    stdoutHandle

	^ self stdioHandles at: 2! !

Smalltalk removeClassNamed: #StdIOFileStream!

Smalltalk removeClassNamed: #StdIOFileStream!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2979-NewStdIO-JuanVuletich-2016Nov17-10h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2979] on 17 November 2016 at 10:51:20 am'!
!StdIOWriteStream methodsFor: 'character writing' stamp: 'jmv 11/17/2016 10:48:18'!
                              newLine
	"Append a newLine character to the receiver.
	The Cuis convention is to use lf on output."

	self nextPut: Character newLineCharacter! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2980-stdout-newLine-JuanVuletich-2016Nov17-10h48m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2980] on 17 November 2016 at 11:51:03 am'!

Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked '
	classVariableNames: 'StdIn '
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOReadStream category: #'System-Support'!
Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked'
	classVariableNames: 'StdIn'
	poolDictionaries: ''
	category: 'System-Support'!

Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position '
	classVariableNames: 'StdOut StdErr '
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOWriteStream category: #'System-Support'!
Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'System-Support'!
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:28:43'!
                    peek
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!
	
	Do not advance the stream!!"

	"Multiple calls to #peek don't make new reads"
	peeked ifFalse: [
		self privateRead.
		peeked _ true ].

	"peeked is always true on exit"
	^buffer1 at: 1! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:33:22'!
                 peekFor: aCharacter 
	"Answer false and do not move over the next element if it is not equal to the argument, aCharacter 
	Answer true and increment the position for accessing elements, if the next element is equal to anObject."

	| nextChar |
	nextChar _ self peek.
	aCharacter = nextChar ifTrue: [
		self next.
		^ true].
	^ false! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:24:52'!
     privateRead
	"Read one Character.
	Private."
	| count |
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	count = 1 ifFalse: [ buffer1 at: 1 put: nil ]! !
!StdIOReadStream class methodsFor: 'cached state access' stamp: 'jmv 11/17/2016 11:45:00'!
                      releaseClassCachedState

	StdIn _ nil! !
!StdIOWriteStream methodsFor: 'character writing' stamp: 'jmv 11/17/2016 11:08:02'!
   space
	"Append a space character to the receiver."

	self nextPut: Character space! !
!StdIOWriteStream class methodsFor: 'cached state access' stamp: 'jmv 11/17/2016 11:44:50'!
              releaseClassCachedState

	StdOut _ nil.
	StdErr _ nil! !
!StdIOReadStream methodsFor: 'open / close' stamp: 'jmv 11/17/2016 11:13:30' prior: 50332252!
         openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID _ aFileID.
	name _ streamName.
	buffer1 _ String new: 1.
	peeked _ false! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:28:44' prior: 50332266!
                         next
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!"

	"If last call was #peek, not #next, then just answer cached value."
	peeked
		ifFalse: [ self privateRead ]
		ifTrue: [ peeked _ false ].

	"peeked is always false on exit"
	^buffer1 at: 1! !
!StdIOReadStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:45:39' prior: 50332298!
                stdin
	StdIn ifNil: [
		StdIn _ self basicNew.
		StdIn 
			openOnHandle: self stdinHandle 
			name: 'stdin' ].
	^StdIn! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:46:13' prior: 50332367!
                            stderr
	StdErr ifNil: [
		StdErr _ self basicNew.
		StdErr 
			openOnHandle: self stderrHandle 
			name: 'stderr' ].
	^StdErr! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:46:37' prior: 50332374!
                     stdout
	StdOut ifNil: [
		StdOut _ self basicNew.
		StdOut 
			openOnHandle: self stdoutHandle 
			name: 'stdout' ].
	^StdOut! !

Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked'
	classVariableNames: 'StdIn'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOReadStream category: #'System-Support'!
Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked'
	classVariableNames: 'StdIn'
	poolDictionaries: ''
	category: 'System-Support'!

Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOWriteStream category: #'System-Support'!
Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'System-Support'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2981-StdIn-peek-peekFor-JuanVuletich-2016Nov17-11h08m-jmv.1.cs.st----!

----SNAPSHOT----#(17 November 2016 12:32:56.842092 pm) Cuis5.0-2981-spur.image priorSource: 186!

----QUIT----#(17 November 2016 12:33:29.990717 pm) Cuis5.0-2981-spur.image priorSource: 29844!

----STARTUP----#(14 December 2016 2:31:49.510252 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-2981-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 17 November 2016 at 5:11:35 pm'!
!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 11/17/2016 17:08:04' prior: 16906186!
               copyReplaceFrom: start to: stop with: replacementCollection 
	"Answer a copy of the receiver satisfying the following conditions: 
	+ stop is less than start, then this is an insertion; stop should be exactly start-1, 
	+ start = 1 means insert before the first character,
	+ start = size+1 means append after last character. 
	+ Otherwise, this is a replacement; start and stop have to be within the receiver's bounds."

	| newSequenceableCollection newSize endReplacement |
	newSize _ self size - (stop - start + 1) + replacementCollection size.
	endReplacement _ start - 1 + replacementCollection size.
	newSequenceableCollection _ self species new: newSize.
	start > 1 ifTrue:[
		newSequenceableCollection
			replaceFrom: 1
			to: start - 1
			with: self
			startingAt: 1].
	start <= endReplacement ifTrue:[
		newSequenceableCollection
			replaceFrom: start
			to: endReplacement
			with: replacementCollection
			startingAt: 1].
	endReplacement < newSize ifTrue:[
		newSequenceableCollection
			replaceFrom: endReplacement + 1
			to: newSize
			with: self
			startingAt: stop + 1].
	^newSequenceableCollection! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 11/17/2016 16:54:39' prior: 16903350!
        setAttributesFromRanges: ranges

	formattedText removeAttributesThat: [ :attribute | attribute isForShout ].

	"Optimize for mutation speed unless method is really large but with very few distict elements:
	Source code that includes just big literals is better served by conventional Text+RunArray"
	"Do it only if we are not breaking textModel!! (for instance, StyledTextEditor asks for formatting just sections, not whole #actualContents)."
	formattedText == textModel actualContents ifTrue: [
		(formattedText size > 2000 and: [ ranges size < 50 ]) ifFalse: [
			formattedText _ formattedText optimizedForMutationSpeed.
			textModel basicActualContents: formattedText ]].

	ranges do: [ :range |

		"Smalltalk text styling"
		(self attributesFor: range rangeType) ifNotNil: [ :attributes |
			attributes do: [ :each |
				formattedText addAttribute: each from: range start to: range end ]].

		"Show as subscripts if appropriate."
		(classOrMetaClass isNil or: [
			classOrMetaClass theNonMetaClass lastUnderscoreMeansSubscript]) ifTrue: [
				(#( instVar classVar globalVar workspaceVar poolConstant
					patternArg methodArg patternTempVar tempVar		
					blockPatternArg blockArg blockPatternTempVar blockTempVar 
					incompleteIdentifier undefinedIdentifier) pointsTo: range rangeType )
						ifTrue: [
							formattedText lastIndexOf: $_ startingAt: range end endingAt: range start do: [ :i |
								formattedText addAttribute: ShoutTextEmphasis subscript from: i to: range end ] ]]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2982-CodeColorizerFix-JuanVuletich-2016Nov17-17h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 17 November 2016 at 5:18:27 pm'!
!DummyStream methodsFor: 'as yet unclassified' stamp: 'KenD 11/5/2016 16:17:09'!
           space! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2983-DummyStream-space-KenDickey-2016Nov17-17h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 18 November 2016 at 10:49:39 am'!
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/3/2015 10:19' prior: 16935004!
                       newMorph
	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."
	| menu subMenu catDict shortCat class |
	menu _ self menu: 'Add a new morph'.
	menu

		add: 'From Clipboard'
		target: myHand
		action: #pasteMorph;
		
		add: 'From Alphabetical List'
		subMenu: self alphabeticalMorphMenu.
	menu addLine.
		
	"Add 'Classic' New Morph menu"
	catDict _ Dictionary new.
	SystemOrganization categories do: [ :cat |
		((cat beginsWith: 'Morphic-') and: [ (#('Morphic-Menus' 'Morphic-Support' ) includes: cat) not ]) ifTrue: [
			shortCat _ (cat
				copyFrom: 'Morphic-' size + 1
				to: cat size).
			(SystemOrganization listAtCategoryNamed: cat) do: [ :cName |
				class _ Smalltalk at: cName.
				((class inheritsFrom: Morph) and: [ class includeInNewMorphMenu ]) ifTrue: [
					(catDict includesKey: shortCat)
						ifTrue: [ (catDict at: shortCat) addLast: class ]
						ifFalse: [
							catDict
								at: shortCat
								put: (OrderedCollection with: class) ]]]]].
	catDict keys sort do: [ :categ |
		subMenu _ MenuMorph new.
		((catDict at: categ) asArray sort: [ :c1 :c2 |
			c1 name < c2 name ]) do: [ :cl |
			subMenu
				add: cl name
				target: self
				selector: #newMorphOfClass:event:
				argument: cl ].
		menu
			add: categ
			subMenu: subMenu ].

	self doPopUp: menu.! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2984-NewMorphMenuFix-JuanVuletich-2016Nov18-10h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2984] on 30 November 2016 at 2:56:21 pm'!
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 11/30/2016 14:52:08'!
     with: otherCollection with: thirdCollection collect: threeArgBlock
	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."
	| n result |
	n _ self size.
	otherCollection size = n ifFalse: [ self error: 'otherCollection must be the same size' ].
	thirdCollection size = n ifFalse: [ self error: 'thirdCollection must be the same size' ].
	result _ self species new: n.
	1 to: n do: [ :index | 
		result at: index put:
			(threeArgBlock
				value: (self at: index)
				value: (otherCollection at: index)
				value: (thirdCollection at: index) )].
	^ result! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 11/25/2016 12:15:27'!
                     with: otherCollection with: thirdCollection do: threeArgBlock 
	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."
	| n |
	n _ self size.
	otherCollection size = n ifFalse: [self error: 'otherCollection must be the same size'].
	thirdCollection size = n ifFalse: [self error: 'thirdCollection must be the same size'].
	1 to: n do: [ :index |
		threeArgBlock
			value: (self at: index)
			value: (otherCollection at: index)
			value: (thirdCollection at: index)]! !
!OrderedCollection methodsFor: 'enumerating' stamp: 'jmv 11/30/2016 14:51:19'!
                      with: otherCollection with: thirdCollection collect: threeArgBlock
	"Collect and return the result of evaluating twoArgBlock with 
	corresponding elements from this collection and otherCollection."
	| result |
	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].
	result _ self species new: self size.
	1 to: self size do: [ :index |
		result addLast:
			(threeArgBlock
				value: (self at: index)
				value: (otherCollection at: index)
				value: (thirdCollection at: index) )].
	^ result! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2985-withwithdo-withwithdcollect-JuanVuletich-2016Nov30-14h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2984] on 30 November 2016 at 3:22:11 pm'!
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/30/2016 15:04:11'!
                         += anObject
	^anObject isNumber
		ifTrue: [ self replace: [ :v | v + anObject ]]
		ifFalse: [
			self withIndexDo: [ :v :i |
				self at: i put: ((self at: i) + (anObject at: i)) ]]! !
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/25/2016 11:41:25'!
                -= anObject
	^anObject isNumber
		ifTrue: [ self replace: [ :v | v - anObject ]]
		ifFalse: [
			self withIndexDo: [ :v :i |
				self at: i put: ((self at: i) - (anObject at: i)) ]]! !
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/30/2016 15:21:00'!
                derivative
	| displaced answer |
	displaced _ self class new: self size.
	displaced replaceFrom: 2 to: self size with: self startingAt: 1.
	displaced at: 1 put: self first - self first.	"Some reasonable zero"
	answer _ self copy.
	answer -= displaced.
	^answer! !
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/29/2016 14:23:32'!
 integral
	| answer |
	answer _ self copy.
	2 to: answer size do: [ :i |
		answer at: i put: (answer at: i) + (answer at: i-1) ].
	^answer! !

FloatArray removeSelector: #derivative!

FloatArray removeSelector: #derivative!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2986-Collection-derivative-integral-JuanVuletich-2016Nov30-14h56m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 8:42:22 am'!
!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:39'!
        step
	(target isNil or: [target isInWorld not]) ifTrue: [self delete]! !
!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:41'!
                       stepTime
	^ 100! !
!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:38'!
             wantsSteps
	^ true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2987-DeleteHaloWhenMorphIsDeleted-LucianoEstebanNotarfrancesco-2016Nov26-08h41m-len.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 8:46:53 am'!
!MenuMorph methodsFor: 'keyboard control' stamp: 'len 6/11/2016 20:40' prior: 16867064!
           keyboardFocusChange: aBoolean
	"Notify change due to green border for keyboard focus"

	aBoolean ifFalse: [self deleteIfPopUp: nil].
	self redrawNeeded! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2988-AvoidManuesHangingAround-LucianoEstebanNotarfrancesco-2016Nov26-08h42m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 8:52:37 am'!
!SequenceableCollection methodsFor: 'copying' stamp: 'len 4/18/2016 22:08'!
                      shuffledBy: aGenerator
	"To answer a mutable collection when receiver is, for example, an Interval."
	^ (self collect: [ :each | each ]) shuffleBy: aGenerator! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2989-ShuffledBy-LucianoEstebanNotarfrancesco-2016Nov26-08h46m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:02:48 am'!
!SystemDictionary methodsFor: 'browsing' stamp: 'len 6/9/2016 23:23'!
   browseAllPrimitives
	self browseAllSelect: [:each| each primitive ~= 0 and: [(each primitive between: 256 and: 291) not]]
! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2990-SmalltalkBrowseAllPrimitives-LucianoEstebanNotarfrancesco-2016Nov26-08h52m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:03:51 am'!
!SystemDictionary methodsFor: 'retrieving' stamp: 'len 11/26/2016 09:03:25' prior: 16921461!
                              allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."
	"Answer a Collection of all the methods that call on aLiteral."
	| aCollection special aList byte |

	#(23 48 'fred' (new open:label:)) size.
"Example above should find #open:label:, though it is deeply embedded here."

	aCollection _ OrderedCollection new.
	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte _ b ].
	self allBehaviorsDo: [:class |
		aList _ class whichSelectorsReferTo: aLiteral special: special byte: byte.
		aList do: [ :sel |
			"For special selectors, look for the literal in the source code.
			Otherwise, for example, searching for senders of #== will include senders of #ifNil.
			Except for #at:put:, because it has two arguments and won't find it in the source code like that."
			(byte isNil or: [aLiteral = #at:put: or: [
				((class sourceCodeAt: sel)
					findString: aLiteral) > 0]]) ifTrue: [

				aCollection add: (
					MethodReference new
						setStandardClass: class 
						methodSymbol: sel
				)
			]
		]
	].
	^ aCollection! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2991-SendersOfatput-LucianoEstebanNotarfrancesco-2016Nov26-09h02m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:06:05 am'!
!String methodsFor: 'testing' stamp: 'len 11/26/2016 09:05:35'!
         isAlphaNumeric
	"Answer true if the receiver contains only letters or digits."
	^ self allSatisfy: [:each| each isAlphaNumeric]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2992-StringisAlphaNumeric-LucianoEstebanNotarfrancesco-2016Nov26-09h03m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:08:39 am'!
!Form methodsFor: 'fileIn/Out' stamp: 'len 8/1/2016 08:13' prior: 16847779!
                  printOn: aStream
	aStream isText
		ifTrue:
			[aStream withAttribute: (TextAnchor new anchoredFormOrMorph: self) do: [aStream nextPut: $*].
			^ self].
	aStream
		nextPutAll: self class name;
		nextPut: $(; print: width;
		nextPut: $x; print: height;
		nextPut: $x; print: depth;
		nextPut: $)! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2993-FormPrintOnTextForWorkspaces-LucianoEstebanNotarfrancesco-2016Nov26-09h06m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2993] on 5 December 2016 at 8:17:22 am'!
!Morph methodsFor: 'printing' stamp: 'jmv 12/5/2016 08:16:19' prior: 16876467!
  printOn: aStream 
	"Add the identity of the receiver to a stream"
	aStream isText
		ifTrue: [
			aStream
				withAttribute: (TextAnchor new anchoredFormOrMorph: (owner ifNil: [self] ifNotNil: [self imageForm:32]))
				do: [ aStream nextPut: $* ].
			^ self].
	super printOn: aStream. "a(n) className"
	aStream 
		nextPut: $(;
		print: self identityHash;
		nextPut: $).
	self valueOfProperty: #morphName ifPresentDo: [ :x | aStream nextPutAll: x asString]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2994-MorphPrintOnTextEnh-JuanVuletich-2016Dec05-08h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2994] on 5 December 2016 at 9:46:02 am'!
!Integer methodsFor: 'comparing' stamp: 'len 12/5/2016 09:46:00' prior: 16859447!
                       hash
	"Hash is reimplemented because = is implemented.
	| s |
	s _ (1 to: 10000) asSet.
	[s includes: 123456] bench
	"

	^self hashMultiply! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

Set rehashAllSets!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2995-Integer-hash-LucianoEstebanNotarfrancesco-2016Dec05-09h39m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2986] on 2 December 2016 at 4:40:51 pm'!
!Form methodsFor: 'scaling, rotation' stamp: 'jmv 12/2/2016 15:47:08' prior: 16848280!
                         flippedBy: direction
	"Return a copy of the receiver flipped either #vertical, #horizontal or #both. (#both is a 180 degrees rotation)
	Form lena display.
	(Form lena flippedBy: #vertical) display.
	(Form lena flippedBy: #horizontal) display.
	(Form lena flippedBy: #both) display.
	"
	| newForm quad |
	newForm _ self class extent: self extent depth: depth.
	quad _ self boundingBox innerCorners.
	quad _ (
		direction caseOf: {
			[ #vertical ] 		-> [#(2 1 4 3)].
			[ #horizontal ] 	-> [#(4 3 2 1)].
			[ #both ] 			-> [#(3 4 1 2)]})
		collect: [:i | quad at: i].
	(WarpBlt toForm: newForm)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: newForm);
		combinationRule: 3;
		copyQuad: quad toRect: newForm boundingBox.
"	newForm offset: (self offset flippedBy: direction centerAt: aPoint)."
	^ newForm
"
[Sensor isAnyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))
			flippedBy: #vertical centerAt: 0@0) display]
"
"Consistency test...
 | f f2 p |
[ Sensor isAnyButtonPressed ] whileFalse: [
	f _ Form fromDisplay: ((p _ Sensor mousePoint) extent: 31@41).
	Display fillBlack: (p extent: 31@41).
	f2 _ f flippedBy: #vertical centerAt: 0@0.
	(f2 flippedBy: #vertical centerAt: 0@0) displayAt: p ]
"! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2996-Form-FlippedBy-both-JuanVuletich-2016Dec02-15h42m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2996] on 9 December 2016 at 9:12:18 am'!
!StringMorph methodsFor: 'initialization' stamp: 'jmv 12/9/2016 09:09:45' prior: 16918230!
                       initialize
	super initialize.
	font _ nil.
	emphasis _ 0.
	self contents: 'String Morph'
! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2997-StringMorph-fix-JuanVuletich-2016Dec09-09h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 29 November 2016 at 9:10:32 pm'!
!OrderedCollection methodsFor: 'converting' stamp: 'len 11/29/2016 08:54:14'!
           asNewArray
	^ array copyFrom: firstIndex to: lastIndex! !
!OrderedCollection class methodsFor: 'instance creation' stamp: 'len 11/28/2016 19:18:39'!
           newFrom: aCollection
	"Create a new collection containing all the elements from aCollection"

	^(self new: aCollection size)
		resetTo: 1;
		addAll: aCollection;
		yourself! !
!OrderedCollection methodsFor: 'enumerating' stamp: 'len 11/28/2016 10:50:21' prior: 16883972!
                 collect: aBlock 
	"Evaluate aBlock with each of my elements as the argument. Collect the 
	resulting values into a collection that is like me. Answer the new 
	collection. Override superclass in order to use addLast:, not at:put:."

	| newCollection |
	newCollection _ self species new: self size.
	newCollection resetTo: 1.
	firstIndex to: lastIndex do: [ :index |
		newCollection addLast: (aBlock value: (array at: index))].
	^ newCollection! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2998-OrderedCollectionTweaks-LucianoEstebanNotarfrancesco-2016Nov26-09h08m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2995] on 6 December 2016 at 8:16:54 pm'!

RectangleLikeMorph subclass: #ResizeMorph
	instanceVariableNames: 'gridLineWidth gridColor selectionColor outlineMorph grid from to action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #ResizeMorph category: #'Morphic-Views'!
RectangleLikeMorph subclass: #ResizeMorph
	instanceVariableNames: 'gridLineWidth gridColor selectionColor outlineMorph grid from to action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!
!SystemWindow methodsFor: 'resize/collapse' stamp: 'bp 10/18/2015 12:18'!
             resize
	| resizeMorph |
	resizeMorph _ ResizeMorph new morphExtent: 200@150.
	resizeMorph action: [self resize: (resizeMorph selectionRectangle: Display extent)].
	resizeMorph morphPosition: self world activeHand morphPosition.
	resizeMorph openInWorld
	! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 22:22'!
                 action: aBlock
	action _ aBlock! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/18/2015 18:00'!
                drawGridOn: aCanvas
	0 to: grid x do: [:i |
		| x |
		x _ i * (extent x - gridLineWidth) / grid x.
		aCanvas line: x @ 0 to: x @ (extent y - 2) width: gridLineWidth color: gridColor].
	0 to: grid y do: [:i |
		| y |
		y _ i * (extent y - gridLineWidth) / grid y.
		aCanvas line: 0 @ y to: (extent x - 2) @ y width: gridLineWidth color: gridColor]! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:02'!
                     drawOn: aCanvas
	super drawOn: aCanvas.
	from ifNotNil: [aCanvas fillRectangle: (self selectionRectangle: extent) color: selectionColor].
	self drawGridOn: aCanvas! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 19:00'!
            grid: aPoint
	grid _ aPoint! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 19:00'!
                    handlesMouseDown: aMouseButtonEvent
	^true! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:51'!
     initialize
	super initialize.
	extent _ 400@300.
	color _ Color white.
	grid _ 8@6.
	gridLineWidth _ 2.
	gridColor _ Color black.
	selectionColor _ Color red! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:18'!
                  mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	from _ self toGridPoint: localEventPosition.
	outlineMorph _ BorderedRectMorph new
		borderColor: Color black;
		color: Color transparent;
		openInWorld;
		hide.
	self selectTo: localEventPosition! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:17'!
    mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	self selectTo: localEventPosition.
	outlineMorph delete.
	action ifNotNil: [
		action value.
		self delete]! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 21:32'!
                               mouseMove: aMouseButtonEvent localPosition: localEventPosition
	self selectTo: localEventPosition! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 21:25'!
              printOn: aStream
	super printOn: aStream.
	aStream space; print: from; space; print: to! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:14'!
                        selectTo: localEventPosition
	| newTo |
	newTo _ self toGridPoint: localEventPosition.
	newTo ~= to ifTrue: [
		to _ newTo.
		self redrawNeeded.
		self updateOutlineMorph]! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:35'!
    selectionRectangle: aRectangle
	^(from corner: to + 1) scaledBy: aRectangle // grid! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:34'!
                            toGridPoint: aPoint
	^(aPoint min: extent - 1) // (extent // grid)! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:15'!
             updateOutlineMorph
	| rectangle |
	rectangle _ self selectionRectangle: Display extent.
	outlineMorph
		morphPosition: rectangle origin extent: rectangle extent;
		show! !
!SystemWindow methodsFor: 'menu' stamp: 'bp 10/11/2015 21:42' prior: 16926424!
     buildWindowMenu

	| aMenu |

	aMenu _ MenuMorph new defaultTarget: self.

	aMenu 
		add: 'change title...' action: #relabel;
		add: 'window color...' action: #setWindowColor;
		addLine;
		add: 'send to back' action: #sendToBack;
		add: 'make next-to-topmost' action: #makeSecondTopmost;
		addLine;
		add: (self isSticky ifTrue: [ 'make draggable' ] ifFalse: [ 'make undraggable' ]) action: #toggleStickiness;
		addLine;
		add: 'close' action: #delete;
		add: 'collapse' action: #collapse;
		add: 'expand / contract' action: #expandBoxHit;
		addLine;
		add: 'resize...' action: #resize;
		add: 'resize full' action: #resizeFull;
		add: 'resize top' action: #resizeTop;
		add: 'resize left' action: #resizeLeft;
		add: 'resize bottom' action: #resizeBottom;
		add: 'resize right' action: #resizeRight;
		add: 'resize top left' action: #resizeTopLeft;
		add: 'resize top right' action: #resizeTopRight;
		add: 'resize bottom left' action: #resizeBottomLeft;
		add: 'resize bottom right' action: #resizeBottomRight.

	^ aMenu! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2999-ResizeMorph-BernhardPieber-2016Dec06-20h13m-bp.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 9 December 2016 at 10:27:21 am'!
!PasteUpMorph methodsFor: 'printing' stamp: 'jmv 12/9/2016 10:25:13' prior: 16887389!
  printOn: aStream
	"Reimplemented to add a tag showing that the receiver is currently functioning as a 'world', if it is"

	self isWorldMorph
		ifTrue: [aStream nextPutAll: ' [world]']
		ifFalse: [super printOn: aStream]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3000-PasteUpMorph-print-fix-JuanVuletich-2016Dec09-10h25m-jmv.1.cs.st----!

----SNAPSHOT----#(14 December 2016 2:32:05.602236 pm) Cuis5.0-3000-spur.image priorSource: 29942!

----QUIT----#(14 December 2016 2:32:40.672866 pm) Cuis5.0-3000-spur.image priorSource: 54545!

----STARTUP----#(19 December 2016 1:35:02.293384 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3000-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3000] on 15 December 2016 at 12:11:15 pm'!
!Point methodsFor: 'printing' stamp: 'jmv 12/15/2016 10:20:58'!
                 printStringFractionDigits: placesDesired
	^(x printStringFractionDigits: placesDesired), '@', (y printStringFractionDigits: placesDesired)! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3001-Point-printStringFractionDigits-JuanVuletich-2016Dec15-10h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3000] on 16 December 2016 at 3:13:12 pm'!
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 12/16/2016 15:05:52' prior: 16924259!
                             browseMyChanges
	"Browse only the changes (in the changes file) by the current author.
	Smalltalk browseMyChanges
	"
	self browseAllSelect: [ :method |
       method fileIndex > 1 "only look at changes file"
               and: [ method timeStamp beginsWith: Utilities authorInitials, ' ' ]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3002-BrowseMyChanges-fix-JuanVuletich-2016Dec16-15h03m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3002] on 19 December 2016 at 12:44:03 pm'!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 12/17/2016 22:38:52' prior: 16819446!
                initialPC
	"Answer the program counter for the receiver's first bytecode."
	^ (self numLiterals + 1) * Smalltalk wordSize + 1! !
!SystemDictionary methodsFor: 'memory space' stamp: 'jmv 12/17/2016 22:37:27' prior: 16920388!
lowSpaceThreshold 
	"Answer the low space threshold. When the amount of free memory (after garbage collection)
	 falls below this limit, the system is in serious danger of completely exhausting memory and
	 crashing. This limit should be made high enough to allow the user open a debugger to diagnose
	 a problem or to save the image.  In a stack-based VM such as Cog contexts for activations in
	 the stack zone will have to be created as the debugger opens, requiring additional headroom."

	| slotsForDebugger slotsForContextsOnStackPages |
	slotsForDebugger := 65536. "Arbitrary guess"
	slotsForContextsOnStackPages :=
		(self vmParameterAt: 42)
			ifNil: [0]
			ifNotNil:
				[:numStackPages| | headerSize numActivationsPerPage maxContextSize |
				numActivationsPerPage := 40. "Design goal of the Cog VM"
				headerSize := 2. "64-bytes for Spur"
				maxContextSize := MethodContext instSize + CompiledMethod fullFrameSize + headerSize.
				numStackPages * numActivationsPerPage * maxContextSize].
	^slotsForDebugger + slotsForContextsOnStackPages * self wordSize! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3003-FixFor64BitSpur-JuanVuletich-2016Dec19-12h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3002] on 19 December 2016 at 12:54:39 pm'!
!Parser methodsFor: 'primitives' stamp: 'nice 9/6/2013 00:48' prior: 16885817!
                      externalFunctionDeclaration
	"Parse the function declaration for a call to an external library."
	| descriptorClass callType modifier retType externalName args argType module fn |
	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent: [ ^ false ].
	callType := descriptorClass callingConventionFor: here.
	callType == nil ifTrue:[^false].
	[modifier := descriptorClass callingConventionModifierFor: token.
	 modifier notNil] whileTrue:
		[self advance.
		 callType := callType bitOr: modifier].
	"Parse return type"
	self advance.
	retType := self externalType: descriptorClass.
	retType == nil ifTrue:[^self expected:'return type'].
	"Parse function name or index"
	externalName := here.
	(self match: #string) 
		ifTrue:[externalName := externalName asSymbol]
		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].
	(self match: #leftParenthesis) ifFalse:[^self expected:'argument list'].
	args := WriteStream on: Array new.
	[self match: #rightParenthesis] whileFalse:[
		argType := self externalType: descriptorClass.
		argType == nil ifTrue:[^self expected:'argument'].
		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType]].
	(self matchToken: 'module:') ifTrue:[
		module := here.
		(self match: #string) ifFalse:[^self expected: 'String'].
		module := module asSymbol].
	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|
		fn := xfn name: externalName 
				module: module 
				callType: callType
				returnType: retType
				argumentTypes: args contents.
		self allocateLiteral: fn].
	(self matchToken: 'error:')
		ifTrue:
			[| errorCodeVariable |
			 errorCodeVariable := here.
			(hereType == #string
			 or: [hereType == #word]) ifFalse:[^self expected: 'error code (a variable or string)'].
			 self advance.
			 self addPragma: (Pragma keyword: #primitive:error: arguments: (Array with: 120 with: errorCodeVariable)).
			 fn ifNotNil: [fn setErrorCodeName: errorCodeVariable]]
		ifFalse:
			[self addPragma: (Pragma keyword: #primitive: arguments: #(120))].
	^true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3004-externalFunctionDeclaration-JuanVuletich-2016Dec19-12h44m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3002] on 19 December 2016 at 1:08:36 pm'!

SmallInteger class
	instanceVariableNames: 'minVal maxVal '!

!classDefinition: 'SmallInteger class' category: #'Kernel-Numbers'!
SmallInteger class
	instanceVariableNames: 'minVal maxVal'!
!SmallInteger class methodsFor: 'class initialization' stamp: 'jmv 12/19/2016 13:03:09'!
                    initMinValAndMaxVal
	| next val |
	val := -32768. "Assume at least 16 bits"
	[next := val + val.
	 next class == self] whileTrue:
		[val := next].
	minVal := val.
	maxVal := -1 - val! !
!SystemDictionary methodsFor: 'image' stamp: 'jmv 12/19/2016 13:04:12' prior: 16925538!
              wordSize
	"Answer the size in bytes of an object pointer or word in the object memory.
	The value does not change for a given image, but may be modified by a SystemTracer
	when converting the image to another format. The value is cached in WordSize to
	avoid the performance overhead of repeatedly consulting the VM."

	"Smalltalk wordSize"

	^ WordSize ifNil: [
		SmallInteger initMinValAndMaxVal.
		WordSize := [self vmParameterAt: 40] on: Error do: [4]]! !

SmallInteger class
	instanceVariableNames: 'minVal maxVal'!

!classDefinition: 'SmallInteger class' category: #'Kernel-Numbers'!
SmallInteger class
	instanceVariableNames: 'minVal maxVal'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
SmallInteger initMinValAndMaxVal!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3005-SmallInteger-minVal-maxVal-part1-JuanVuletich-2016Dec19-12h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3005] on 19 December 2016 at 1:12:20 pm'!
!SmallInteger class methodsFor: 'constants' stamp: 'jmv 12/19/2016 13:06:38' prior: 16909182!
    maxVal
	"Answer the maximum value for a SmallInteger."

	"Ensure word size is properly set. If so, maxVal is also set."
	Smalltalk wordSize.
	^maxVal! !
!SmallInteger class methodsFor: 'constants' stamp: 'jmv 12/19/2016 13:07:24' prior: 16909186!
         minVal
	"Answer the minimum value for a SmallInteger."

	"Ensure word size is properly set. If so, minVal is also set."
	Smalltalk wordSize.
	^minVal! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3006-SmallInteger-minVal-maxVal-part2-JuanVuletich-2016Dec19-13h11m-jmv.1.cs.st----!

----SNAPSHOT----#(19 December 2016 1:35:11.847544 pm) Cuis5.0-3006-spur.image priorSource: 54644!

----QUIT----#(19 December 2016 1:35:24.272429 pm) Cuis5.0-3006-spur.image priorSource: 62581!

----STARTUP----#(19 December 2016 1:45:03.353057 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3006-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3006] on 19 December 2016 at 1:42:27 pm'!
!SmallFloat64 commentStamp: '<historical>' prior: 16908181!
                  My instances represent 64-bit Floats whose exponent fits in 8 bits as immediate objects. This representation is only available on 64-bit systems, not 32-bit systems.!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
SmallFloat64 tryPrimitive: 161 withArgs: #(999).
!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3007-SmallFloat64-fixHash-forSpur64Conversion-JuanVuletich-2016Dec19-13h41m-jmv.1.cs.st----!

----SNAPSHOT----#(19 December 2016 1:45:10.081033 pm) Cuis5.0-3007-spur.image priorSource: 62680!

----QUIT----#(19 December 2016 1:45:27.503203 pm) Cuis5.0-3007-spur.image priorSource: 63733!

----STARTUP----#(27 December 2016 12:18:09.525689 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3007-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3007] on 22 December 2016 at 4:05:04 pm'!
!LargePositiveInteger methodsFor: 'testing' stamp: 'nice 8/31/2008 00:07'!
  isLarge
	^true! !
!SmallInteger methodsFor: 'testing' stamp: 'nice 8/31/2008 00:07'!
           isLarge
	^false! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/27/2015 23:01'!
                           long64At: index bigEndian: bigEndian
	"Return a 64-bit signed integer quantity starting from the given byte index."

	| value |
	value := self unsignedLong64At: index bigEndian: bigEndian.
	value digitLength < 8 ifTrue: [ ^value ].
	(value digitAt: 8) < 16r80 ifTrue: [ ^value ].
	^value - 16r10000000000000000! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/27/2015 22:57'!
                    long64At: index put: value bigEndian: bigEndian
	"Store a 64-bit signed integer quantity starting from the given byte index."
	
	^self
		unsignedLong64At: index
		put: (value negative
			ifFalse: [ value ]
			ifTrue: [ value + 16r10000000000000000 ])
		bigEndian: bigEndian! !
!ByteArray methodsFor: 'platform independent access' stamp: 'eem 2/22/2016 09:36'!
                        unsignedLong64At: index bigEndian: bigEndian
	"Return a 64-bit unsigned integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."

	| byte |
	SmallInteger maxVal >  1073741823 ifTrue:
		[bigEndian
			ifTrue: "64-bit SmallIntegers have a 3 bit tag and a sign bit, so the most positive value has 16rF as its top byte."
				[(byte := self at: index) <= 16rF ifTrue:
					[^((((((((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3)) bitShift: 8)
						+ (self at: index + 4) bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 7)]]
			ifFalse:
				[(byte := self at: index + 7) <= 16rF ifTrue:
					[^((((((((byte bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 4)) bitShift: 8)
						+ (self at: index + 3) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index)]]].
	bigEndian ifFalse: [
		(byte := self at: index + 7) = 0 ifFalse: [
			^(LargePositiveInteger new: 8)
				replaceFrom: 1 to: 8 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 6) = 0 ifFalse: [
			^(LargePositiveInteger new: 7)
				replaceFrom: 1 to: 7 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 5) = 0 ifFalse: [
			^(LargePositiveInteger new: 6)
				replaceFrom: 1 to: 6 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 4) = 0 ifFalse: [
			^(LargePositiveInteger new: 5)
				replaceFrom: 1 to: 5 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 3) <= 16r3F ifFalse: [
			^(LargePositiveInteger new: 4)
				replaceFrom: 1 to: 4 with: self startingAt: index;
				normalize ].
		^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index) ].
	(byte := self at: index) = 0 ifFalse: [
		^(LargePositiveInteger new: 8)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: (self at: index + 2);
			digitAt: 7 put: (self at: index + 1);
			digitAt: 8 put: byte;
			normalize ].
	(byte := self at: index + 1) = 0 ifFalse: [	
		^(LargePositiveInteger new: 7)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: (self at: index + 2);
			digitAt: 7 put: byte;
			normalize ].
	(byte := self at: index + 2) = 0 ifFalse: [	
		^(LargePositiveInteger new: 6)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: byte;
			normalize ].
	(byte := self at: index + 3) = 0 ifFalse: [	
		^(LargePositiveInteger new: 5)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: byte;
			normalize ].		
	(byte := self at: index + 4) <= 16r3F ifFalse: [
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: byte;
			normalize ].
	^(((byte bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 7)! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/9/2015 20:18'!
        unsignedLong64At: index put: value bigEndian: bigEndian
	"Store a 64-bit unsigned integer quantity starting from the given byte index"
	
	| i j |
	value isLarge ifTrue: [
		i := value digitLength.
		bigEndian ifFalse: [
			self
				replaceFrom: index
					to: index + i - 1
					with: value 
					startingAt: 1;
				replaceFrom: index + i
					to: index + 7
					with: #[0 0 0 0 0 0 0 0]
					startingAt: 1.
			^value ].
		j := index + 8.
		i <= 7 ifTrue: [
			self
				replaceFrom: index
				to: j - i - 1
				with: #[0 0 0 0 0 0 0 0]
				startingAt: 1 ].
		[ 1 <= i ] whileTrue: [
			self at: j - i put: (value digitAt: i).
			i := i - 1 ].
		^value ].
	bigEndian ifFalse: [
		j := index - 1.
		i := value.
		[ 1 <= i ] whileTrue: [
			self at: (j := j + 1) put: (i bitAnd: 16rFF).
			i := i bitShift: -8 ].
		self replaceFrom: j + 1
			to: index + 7
			with: #[0 0 0 0 0 0 0 0]
			startingAt: 1.
		^value ].
	j := index + 8.
	i := value.
	[ 1 <= i ] whileTrue: [
		self at: (j := j - 1) put: (i bitAnd: 16rFF).
		i := i bitShift: -8 ].
	self replaceFrom: index
		to: j - 1
		with: #[0 0 0 0 0 0 0 0]
		startingAt: 1.
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/9/2015 20:28' prior: 16793638!
                    longAt: index bigEndian: bigEndian
	"Return a 32-bit integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."
	
	| byte result |
	bigEndian ifFalse: [
		(byte := self at: index + 3) <= 16r7F ifTrue: [ "Is the result non-negative?"
			byte <= 16r3F ifTrue: [
				^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index) ].
			^(LargePositiveInteger new: 4)
				replaceFrom: 1
					to: 4
					with: self
					startingAt: index;
				normalize ].
		"Negative"
		byte >= 16rC0 ifTrue: [
			^-1 - (((((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitXor: 16rFFFFFF) bitShift: 8) + ((self at: index) bitXor: 16rFF)) ].
		(result := LargeNegativeInteger new: 4)
			digitAt: 4 put: ((self at: index + 3) bitXor: 16rFF);
			digitAt: 3 put: ((self at: index + 2) bitXor: 16rFF);
			digitAt: 2 put: ((self at: index + 1) bitXor: 16rFF).
		(byte := ((self at: index) bitXor: 16rFF) + 1) <= 16rFF ifTrue: [
			^result
				digitAt: 1 put: byte;
				normalize ].
		^result
			digitAt: 1 put: 16rFF;
			- 1 "It's tempting to do the subtraction in a loop to avoid the LargeInteger creation, but it's actually slower than this." ].
	(byte := self at: index) <= 16r7F ifTrue: [ "Is the result non-negative?"
		byte <= 16r3F ifTrue: [
			^(((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3) ].
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 3);
			digitAt: 2 put: (self at: index + 2);
			digitAt: 3 put: (self at: index + 1);
			digitAt: 4 put: byte;
			normalize ].
	"Negative"
	16rC0 <= byte ifTrue: [
		^-1 - (((((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitXor: 16rFFFFFF) bitShift: 8) + ((self at: index + 3) bitXor: 16rFF)) ].
	(result := LargeNegativeInteger new: 4)
		digitAt: 4 put: (byte bitXor: 16rFF);
		digitAt: 3 put: ((self at: index + 1) bitXor: 16rFF);
		digitAt: 2 put: ((self at: index + 2) bitXor: 16rFF).
	(byte := ((self at: index + 3) bitXor: 16rFF) + 1) <= 16rFF ifTrue: [
		^result
			digitAt: 1 put: byte;
			normalize ].
	^result 
		digitAt: 1 put: 16rFF;
		- 1 "It's tempting to do the subtraction in a loop to avoid the LargeInteger creation, but it's actually slower than this."! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 17:13' prior: 16793658!
             longAt: index put: value bigEndian: bigEndian
	"Store a 32-bit signed integer quantity starting from the given byte index"
	
	| v v2 |
	value isLarge ifTrue: [
		bigEndian ifFalse: [
			value positive ifTrue: [
				self 
					replaceFrom: index
					to: index + 3
					with: value
					startingAt: 1.
				^value ].
			v := 0.
			[ v <= 3 and: [ (v2 := ((value digitAt: v + 1) bitXor: 16rFF) + 1) = 16r100 ] ] whileTrue: [
				self at: index + v put: 0.
				v := v + 1 ].
			self at: index + v put: v2.
			v := v + 1.
			[ v <= 3 ] whileTrue: [
				self at: index + v put: ((value digitAt: (v := v + 1)) bitXor: 16rFF) ].
			^value ].
		value positive ifTrue: [
			self
				at: index put: (value digitAt: 4);
				at: index + 1 put: (value digitAt: 3);
				at: index + 2 put: (value digitAt: 2);
				at: index + 3 put: (value digitAt: 1).
			^value ].
		v := 3.
		[ 0 <= v and: [ (v2 := ((value digitAt: 4 - v) bitXor: 16rFF) + 1) = 16r100 ] ] whileTrue: [
			self at: index + v put: 0.
			v := v - 1 ].
		self at: index + v put: v2.
		[ 0 <= (v := v - 1) ] whileTrue: [
			self at: index + v put: ((value digitAt: 4 - v) bitXor: 16rFF) ].
		^value ].
	v := value bitShift: -24.
	0 <= (v := (v bitAnd: 16r7F) - (v bitAnd: 16r80)) ifFalse: [
		v := v + 16r100 ].
	bigEndian ifFalse: [
		self 
			at: index put: (value bitAnd: 16rFF);
			at: index + 1 put: ((value bitShift: -8) bitAnd: 16rFF);
			at: index + 2 put: ((value bitShift: -16) bitAnd: 16rFF);
			at: index + 3 put: v.
		^value ].
	self
		at: index put: v;
		at: index + 1 put: ((value bitShift: -16) bitAnd: 16rFF);
		at: index + 2 put: ((value bitShift: -8) bitAnd: 16rFF);
		at: index + 3 put: (value bitAnd: 16rFF).
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 23:16' prior: 16793680!
      shortAt: index bigEndian: bigEndian
	"Return a 16-bit signed integer quantity starting from the given byte index"

	| result |
	result := bigEndian
		ifFalse: [ ((self at: index + 1) bitShift: 8) + (self at: index) ]
		ifTrue: [ ((self at: index) bitShift: 8) + (self at: index + 1) ].
	result < 16r8000 ifTrue: [ ^result ].
	^result - 16r10000! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 23:16' prior: 16793690!
   shortAt: index put: value bigEndian: bigEndian
	"Store a 16-bit signed integer quantity starting from the given byte index"
	
	| unsignedValue |
	(unsignedValue := value) < 0 ifTrue: [
		unsignedValue := unsignedValue + 16r10000 ].
	bigEndian ifFalse: [
		self 
			at: index + 1 put: (unsignedValue bitShift: -8);
			at: index put: (unsignedValue bitAnd: 16rFF).
		^value ].
	self
		at: index put: (unsignedValue bitShift: -8);
		at: index + 1 put: (unsignedValue bitAnd: 16rFF).
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'eem 2/22/2016 09:20' prior: 16793700!
                  unsignedLongAt: index bigEndian: bigEndian
	"Return a 32-bit unsigned integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."
	| byte |
	bigEndian ifTrue:
		[((byte := self at: index) <= 16r3F
		 or: [SmallInteger maxVal >  1073741823]) ifTrue:
			[^(((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3)].
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 3);
			digitAt: 2 put: (self at: index + 2);
			digitAt: 3 put: (self at: index + 1);
			digitAt: 4 put: byte;
			normalize].
	((byte := self at: index + 3) <= 16r3F
	 or: [SmallInteger maxVal >  1073741823]) ifTrue:
		[^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index)].
	^(LargePositiveInteger new: 4)
		replaceFrom: 1 to: 4 with: self startingAt: index;
		normalize! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 01:33' prior: 16793720!
  unsignedLongAt: index put: value bigEndian: bigEndian
	"Store a 32-bit unsigned integer quantity starting from the given byte index"
	
	value isLarge
		ifTrue: [
			bigEndian ifFalse: [
				self
					replaceFrom: index
					to: index + 3
					with: value
					startingAt: 1.
				^value ].
			self
				at: index put: (value digitAt: 4);
				at: index + 1 put: (value digitAt: 3);
				at: index + 2 put: (value digitAt: 2);
				at: index +3 put: (value digitAt: 1) ]
		ifFalse: [
			bigEndian ifFalse: [
				self 
					at: index put: (value bitAnd: 16rFF);
					at: index + 1 put: ((value bitShift: -8) bitAnd: 16rFF);
					at: index + 2 put: ((value bitShift: -16) bitAnd: 16rFF);
					at: index + 3 put: (value bitShift: -24).
				^value ].
			self 
				at: index put: (value bitShift: -24);
				at: index + 1 put: ((value bitShift: -16) bitAnd: 16rFF);
				at: index + 2 put: ((value bitShift: -8) bitAnd: 16rFF);
				at: index + 3 put: (value bitAnd: 16rFF) ].
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 01:33' prior: 16793740!
                 unsignedShortAt: index bigEndian: bigEndian
	"Return a 16-bit unsigned integer quantity starting from the given byte index"

	bigEndian ifFalse: [ ^((self at: index + 1) bitShift: 8) + (self at: index) ].
	^((self at: index) bitShift: 8) + (self at: index + 1)
	! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 15:29' prior: 16793751!
                     unsignedShortAt: index put: value bigEndian: bigEndian
	"Store a 16-bit unsigned integer quantity starting from the given byte index"
	
	bigEndian ifFalse: [
		self 
			at: index + 1 put: (value bitShift: -8);
			at: index put: (value bitAnd: 16rFF).
		^value ].
	self
		at: index put: (value bitShift: -8);
		at: index+1 put: (value bitAnd: 16rFF).
	^value! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3008-ByteArray-UpdateToSqueak-JuanVuletich-2016Dec22-15h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3008] on 26 December 2016 at 2:54:38 pm'!
!Float64Array methodsFor: 'accessing' stamp: 'jmv 12/26/2016 14:53:06' prior: 16846088!
            floatAt: index put: aFloat
	"Store the argument (e.g., 64 bit Float) at the given index
	Use the same internal representation as BoxedFloat64. I.e. a BoxedFloat64 and a Float64Array of size 1 hold the same bits.
	Allow subclasses to redefine #at:put:"

	"This breaks with SmallFloat64"
	"self replaceWordsFrom: index * 2 - 1 to: index * 2  with: aFloat asFloat startingAt: 1."

	"Float >>basicAt: acts as if Floats were stored in big endian format. Our instances are in platform endianess."
	Smalltalk isLittleEndian
		ifTrue: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 2).
			self basicAt: index * 2 put: (aFloat basicAt: 1) ]
		ifFalse: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 1).
			self basicAt: index * 2 put: (aFloat basicAt: 2) ].
	^aFloat! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3009-Float64Array-fixForSmallFloats-JuanVuletich-2016Dec26-14h53m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3009] on 27 December 2016 at 12:14:57 pm'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 12/27/2016 12:14:33' prior: 16922764!
                         saveAsNewVersion
	"Save the image/changes using the next available version number."
	"
	Smalltalk saveAsNewVersion
	"
	| fileName newName changesName systemVersion |
	self okayToSave ifFalse: [ ^ self ].
	systemVersion _ SystemVersion current.
	fileName _ String streamContents: [ :strm |
		strm
			nextPutAll: 'Cuis';
			print: systemVersion versionMajor;
			nextPut: $.;
			print: systemVersion versionMinor;
			nextPut: $-;
			print: systemVersion highestUpdate.
		Smalltalk isSpur ifTrue: [
			strm nextPutAll: '-spur'.
			Smalltalk wordSize = 8 ifTrue: [
				strm nextPutAll: '-64' ]]].
	newName _ fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName _ DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName _ self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		^ self inform:
'There is already .changes file of the desired name,
', newName, '
curiously already present, even though there is
no corresponding .image file.   Please remedy
manually and then repeat your request.' ].
	"Try to clear all user state, including all class vars, preferences, etc"
	self saveAs: newName andQuit: false clearAllClassState: true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3010-saveAsNewVersion-spur64-JuanVuletich-2016Dec27-12h14m-jmv.1.cs.st----!

----SNAPSHOT----#(27 December 2016 12:18:17.352492 pm) Cuis5.0-3010-spur.image priorSource: 63832!

----QUIT----#(27 December 2016 12:18:31.197719 pm) Cuis5.0-3010-spur.image priorSource: 81559!

----STARTUP----#(27 December 2016 3:29:30.265752 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3010-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3009] on 27 December 2016 at 9:51:30 am'!
!Float64Array methodsFor: 'accessing' stamp: 'jmv 12/27/2016 09:51:21' prior: 50334113!
                  floatAt: index put: aNumber
	"Store the argument (e.g., 64 bit Float) at the given index
	Use the same internal representation as BoxedFloat64. I.e. a BoxedFloat64 and a Float64Array of size 1 hold the same bits.
	Allow subclasses to redefine #at:put:"

	"This breaks with SmallFloat64"
	"self replaceWordsFrom: index * 2 - 1 to: index * 2  with: aFloat asFloat startingAt: 1."

	"Float >>basicAt: acts as if Floats were stored in big endian format. Our instances are in platform endianess."
	| aFloat |
	aFloat _ aNumber asFloat.
	Smalltalk isLittleEndian
		ifTrue: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 2).
			self basicAt: index * 2 put: (aFloat basicAt: 1) ]
		ifFalse: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 1).
			self basicAt: index * 2 put: (aFloat basicAt: 2) ].
	^aFloat! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3011-Float64Array-fixForSmallIntegers-JuanVuletich-2016Dec27-09h51m-jmv.1.cs.st----!

----SNAPSHOT----#(27 December 2016 3:29:38.401581 pm) Cuis5.0-3011-spur.image priorSource: 81659!

----QUIT----#(27 December 2016 3:29:55.295453 pm) Cuis5.0-3011-spur.image priorSource: 83053!

----STARTUP----#(18 January 2017 10:34:48.334248 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3011-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3011] on 29 December 2016 at 11:02:24 am'!

PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #HierarchicalListMorph category: #'Morphic-Views'!
PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!
!Inspector methodsFor: 'user commands' stamp: 'jmv 12/29/2016 10:58:58'!
                inspectSelection
	self selection inspect! !
!ObjectExplorer methodsFor: 'user commands' stamp: 'jmv 12/29/2016 11:01:35'!
      inspectSelection
	self object inspect! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 12/29/2016 10:55:06'!
         doubleClick: aMouseButtonEvent localPosition: localEventPosition

	doubleClickSelector ifNil: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	^ self model perform: doubleClickSelector! !
!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 12/29/2016 10:55:42'!
                 doubleClickSelector: aSymbol
	doubleClickSelector _ aSymbol! !
!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 12/29/2016 10:41:28'!
              doubleClickSelector: aSymbol
	doubleClickSelector _ aSymbol! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 12/29/2016 10:53:49' prior: 16853080!
   mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| itemMorph |
	aMouseButtonEvent hand newKeyboardFocus: self.
	itemMorph _ self itemFromPoint: localEventPosition.
	itemMorph ifNil: [ ^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].
	self highlightedMorph: itemMorph.
	(itemMorph inToggleArea: (itemMorph internalize: (scroller internalize: localEventPosition)))
		ifTrue: [ ^self toggleExpandedState: itemMorph event: aMouseButtonEvent ]. 
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent 
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 10:59:15' prior: 16831023!
 buildMorphicWindow
	"Open a full morphic debugger with the given label"

	| upperMorph receiverInspector receiverInspectorText contextVariableInspector contextVariableInspectorText bottomMorph |

	upperMorph _ PluggableListMorph
		model: model 
		listGetter: #contextStackList
		indexGetter: #contextStackIndex
		indexSetter: #toggleContextStackIndex:
		mainView: self
		menuGetter: #contextStackMenu
		keystrokeAction: #contextStackKey:from:.

	receiverInspector _ PluggableListMorph
			model: model receiverInspector
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #receiverFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	receiverInspector doubleClickSelector: #inspectSelection.
	receiverInspectorText _ TextModelMorph
			textProvider: model receiverInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.
	contextVariableInspector _ PluggableListMorph
			model: model contextVariablesInspector 
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #contextFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	contextVariableInspector doubleClickSelector: #inspectSelection.
	contextVariableInspectorText _ TextModelMorph
			textProvider: model contextVariablesInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.

	bottomMorph _ LayoutMorph newRow.
	bottomMorph
		addMorph: receiverInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: receiverInspectorText proportionalWidth: 0.3;
		addAdjusterAndMorph: contextVariableInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: contextVariableInspectorText proportionalWidth: 0.3.

	self layoutMorph
		addMorph: upperMorph proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55;
		addAdjusterAndMorph: bottomMorph proportionalHeight: 0.2! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 11:00:06' prior: 16857200!
                    buildMorphicWindow
	" Inspector openOn: SystemOrganization "
	| contentsText list upperRow evaluatorText label |
	"Build widgets. We'll assemble them below."
	list _ PluggableListMorph
			model: model 
			listGetter: #fieldList
			indexGetter: #selectionIndex
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #fieldListMenu
			keystrokeAction: #inspectorKey:from:.
	list doubleClickSelector: #inspectSelection.
	contentsText _ TextModelMorph
			textProvider: model
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.
	evaluatorText _ (TextModelMorph textProvider: model)
			askBeforeDiscardingEdits: false.
	"Upper row has two widgets, side by side: the list of variables at the left side, and the variable contents pane at the right side."
	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: list proportionalWidth: 0.3;
		addAdjusterAndMorph: contentsText proportionalWidth: 0.7.
	"Inspector Window has two rows: At the top, the one we just bult. Below it, the evaluation pane."
	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.7;
		addAdjusterAndMorph: evaluatorText proportionalHeight: 0.3.
	"Set label"
	label _ [model object printStringLimitedTo: 64]
		on: UnhandledError
		do: [:ex | ex return: model object class printString, ' (printing failed)'].
	(label includesSubString: model object  class name)
		ifFalse: [label _ model object  class name, ': ', label].
	self setLabel: label! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 11:00:46' prior: 16883288!
buildMorphicWindow

	| textMorph |
	listMorph _ HierarchicalListMorph
			model: model
			listGetter: #getList
			indexGetter: #getCurrentSelection
			indexSetter: #noteNewSelection:
			mainView: self
			menuGetter: #genericMenu
			keystrokeAction: #explorerKey:from:.
	listMorph autoDeselect: false.
	listMorph doubleClickSelector: #inspectSelection.
	textMorph _ (TextModelMorph textProvider: model)
			askBeforeDiscardingEdits: false.
	self layoutMorph
		addMorph: listMorph proportionalHeight: 0.8;
		addAdjusterAndMorph: textMorph proportionalHeight: 0.2.
	self setLabel: (model rootObject printStringLimitedTo: 64)! !
!ObjectExplorerWindow methodsFor: 'menu commands' stamp: 'jmv 12/29/2016 10:50:28' prior: 16883479!
             openWeightExplorer
	"Create and schedule a Weight Explorer on the receiver's model's currently selected object."

	^WeightTracer openExplorerOn: model object! !

PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #HierarchicalListMorph category: #'Morphic-Views'!
PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3012-DoubleClickOpensInspector-JuanVuletich-2016Dec29-10h36m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3012] on 29 December 2016 at 11:30:18 am'!
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/29/2016 11:29:52' prior: 16902537!
                           parseExternalCall
	self scanNext.
	self failWhen: currentToken isNil.
	self scanPast: #externalCallType.
	currentToken = '*' 
		ifTrue: [self scanPast: #externalCallTypePointerIndicator].
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: 	[
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentTokenFirst == $(.
	self scanPast: #leftParenthesis.
	[currentTokenFirst ~~ $)] 
		whileTrue: [
			self failWhen: currentToken isNil.
			self scanPast: #externalCallType.
			currentToken = '*' 
				ifTrue: [self scanPast: #externalCallTypePointerIndicator]].
	self scanPast: #rightParenthesis.
	currentToken = 'module:' 
		ifTrue: [
			self scanPast: #module.
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3013-Shout-ExternalCallFix-JuanVuletich-2016Dec29-11h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3013] on 29 December 2016 at 3:36:31 pm'!
!CompiledMethod methodsFor: 'file in/out' stamp: 'jmv 12/29/2016 15:25:13' prior: 16820644!
               storeDataOn: aDataStream
	"Store myself on a DataStream.  I am a mixture of objects and raw data bytes.  Only use this for blocks.  Normal methodDictionaries should not be put out using ReferenceStreams.  Their fileOut should be attached to the beginning of the file."

	| byteLength lits |
	"No inst vars of the normal type"
	byteLength _ self basicSize.
	aDataStream
		beginInstance: self class
		size: byteLength.
	lits _ self numLiterals + 1.	"counting header"
	1 to: lits do:
		[:ii | aDataStream nextPut: (self objectAt: ii)].
	lits*Smalltalk wordSize+1 to: byteLength do:
		[:ii | aDataStream byteStream nextPut: (self basicAt: ii)].
			"write bytes straight through to the file"! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 12/29/2016 15:27:40' prior: 16827456!
                   readMethod
	"PRIVATE -- Read the contents of an arbitrary instance.
	 ASSUMES: readDataFrom:size: sends me beginReference: after it
	   instantiates the new object but before reading nested objects.
	 NOTE: We must restore the current reference position after
	   recursive calls to next.
	Let the instance, not the class read the data.  "
	| instSize refPosn newClass className xxHeader nLits byteCodeSizePlusTrailer newMethod lits |

	instSize _ (byteStream nextUnsignedInt32BigEndian: true) - 1.
	refPosn _ self getCurrentReference.
	className _ self next.
	newClass _ Smalltalk at: className asSymbol.

	xxHeader _ self next.
		"nArgs _ (xxHeader >> 24) bitAnd: 16rF."
		"nTemps _ (xxHeader >> 18) bitAnd: 16r3F."
		"largeBit _ (xxHeader >> 17) bitAnd: 1."
	nLits _ (xxHeader >> 9) bitAnd: 16rFF.
		"primBits _ ((xxHeader >> 19) bitAnd: 16r600) + (xxHeader bitAnd: 16r1FF)."
	byteCodeSizePlusTrailer _ instSize - (newClass instSize "0") - (nLits + 1 * Smalltalk wordSize).

	newMethod _ newClass 
		newMethod: byteCodeSizePlusTrailer
		header: xxHeader.

	self setCurrentReference: refPosn.  "before readDataFrom:size:"
	self beginReference: newMethod.
	lits _ newMethod numLiterals + 1.	"counting header"
	2 to: lits do:
		[:ii | newMethod objectAt: ii put: self next].
	lits*Smalltalk wordSize+1 to: newMethod basicSize do:
		[:ii | newMethod basicAt: ii put: byteStream next].
			"Get raw bytes directly from the file"
	self setCurrentReference: refPosn.  "before returning to next"
	^ newMethod! !
!DataStream methodsFor: 'other' stamp: 'jmv 12/29/2016 15:36:22' prior: 16827907!
            vacantRef
	"Answer the magic 32-bit constant we use ***ON DISK*** as a stream 'reference
	 position' to identify a reference that's not yet filled in. This must be a
	 value that won't be used as an ordinary reference. Cf. outputReference: and
	 readReference. -- 
	 NOTE: We could use a different type ID for vacant-refs rather than writing
		object-references with a magic value. (The type ID and value are
		overwritten by ordinary object-references when weak refs are fullfilled.)"

	"In 32 bit Cuis it was:"
	"^ SmallInteger maxVal"

	"Use that very same value even if in 64 bit Cuis.
	This means that DataStreams are limited to 1GibiBytes in size."
	^16r3FFFFFFF! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3014-DataStream-FixFor64Bits-JuanVuletich-2016Dec29-15h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3000] on 10 December 2016 at 10:41:46 am'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 12/10/2016 01:38:21'!
                              xBacktick
	"Smalltalk code evaluated at compile time as a literal."

	self step.
	buffer reset.
	[hereChar == $`
		and: [aheadChar == $`
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched back quote']].
	self step.
	token _ Compiler evaluate: buffer contents.
	tokenType _ #literal! !
!Character methodsFor: 'testing' stamp: 'jmv 12/10/2016 01:26:44' prior: 16800539!
               isValidInIdentifiers
	"Can c be part of an identifier? (unary or keyword selector, or variable name)"

	^self isAlphaNumeric or: [ #( $_ ) statePointsTo: self ]! !
!CompiledMethod methodsFor: 'comparing' stamp: 'jmv 12/10/2016 01:27:06' prior: 16819629!
  = method
	| numLits lit1 lit2 |

	"Any object is equal to itself"
	self == method ifTrue: [ ^ true ].

	"Answer whether the receiver implements the same code as the 
	argument, method."
	(method is: #CompiledMethod) ifFalse: [ ^false ].
	self size = method size ifFalse: [ ^false ].
	self header = method header ifFalse: [ ^false ].
	self initialPC to: self endPC do: [ :i |
		(self at: i) = (method at: i) ifFalse: [ ^false ]].
	(numLits _ self numLiterals) ~= method numLiterals ifTrue: [ ^false ].

	"Dont bother checking FFI and named primitives''
	jmv: Does this make any sense?
	 (#(117 120) includes: self primitive) ifTrue: [^ true]."

	 "properties"
	(self properties analogousCodeTo: method properties) ifFalse: [
		^false ].

	"#penultimateLiteral is selector (or properties, just compared, above)
	Last literal is #methodClass.
	Don't compare them. Two methods might be equal even if they have different selector (or none at all)
	or are installed in different classes (or none at all)"
	1 to: numLits-2 do: [ :i |
		lit1 _ self literalAt: i.
		lit2 _ method literalAt: i.
		lit1 = lit2 ifFalse: [
			(i = 1 and: [ #(117 120) includes: self primitive ])
				ifTrue: [
					lit1 isArray
						ifTrue: [
							(lit2 isArray and: [ lit1 allButLast = lit2 allButLast ]) ifFalse: [
								^false ]]
						ifFalse: [ "ExternalLibraryFunction"
							(lit1 analogousCodeTo: lit2) ifFalse: [
								^false ]]]
				ifFalse: [
					 lit1 isFloat
						ifTrue: [
							"Floats match if values are close, due to roundoff error."
							(lit1 closeTo: lit2) ifFalse: [ ^false ].
							self flag: 'just checking'. self halt ]
						ifFalse: [
							"any other discrepancy is a failure"
							^ false ]]]].
	^true! !
!Scanner class methodsFor: 'cached class state' stamp: 'jmv 12/10/2016 01:26:17' prior: 16904329!
     initTypeTable
	| newTable |
	newTable := Array new: 256 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"

	1 to: 255
		do: [:index |
			(Character numericValue: index) isValidInIdentifiers
				ifTrue: [
					"Digits and $_ are overwritten later"
					newTable at: index put: #xLetter ]].

	newTable atAll: ($0 numericValue to: $9 numericValue) put: #xDigit.
	newTable atAll:  '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.

	newTable at: Scanner doItCharacterValue put: #doIt.
	newTable at: $" numericValue put: #xDoubleQuote.
	newTable at: $# numericValue put: #xLitQuote.
	newTable at: $$ numericValue put: #xDollar.
	newTable at: $' numericValue put: #xSingleQuote.
	newTable at: $` numericValue put: #xBacktick.
	newTable at: $: numericValue put: #xColon.
	newTable at: $( numericValue put: #leftParenthesis.
	newTable at: $) numericValue put: #rightParenthesis.
	newTable at: $. numericValue put: #period.
	newTable at: $; numericValue put: #semicolon.
	newTable at: $[ numericValue put: #leftBracket.
	newTable at: $] numericValue put: #rightBracket.
	newTable at: ${ numericValue put: #leftBrace.
	newTable at: $} numericValue put: #rightBrace.
	newTable at: $^ numericValue put: #upArrow.
	newTable at: $_ numericValue put: #xUnderscore.
	newTable at: $| numericValue put: #verticalBar.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 12/10/2016 01:42:02' prior: 16901958!
                             scanWhitespace
	| c |
	
	[c := self currentChar.
	c notNil and: [c isSeparator or: [c == $`]]] 
		whileTrue: [sourcePosition := sourcePosition + 1].
	c == $" ifTrue: [self scanComment]! !
!SHParserST80 methodsFor: 'character testing' stamp: 'jmv 12/10/2016 10:24:38' prior: 16902078!
    isBinarySelectorCharacter: aCharacter

	aCharacter isValidInIdentifiers ifTrue: [^false].
	aCharacter isSeparator ifTrue: [^false].

	('"#$'':().;[]{}_`'  includes: aCharacter) 
		ifTrue:[^false].
	aCharacter numericValue = Scanner doItCharacterValue ifTrue: [^false "the doIt char"].
	aCharacter numericValue = 0 ifTrue: [^false].
	"Any other char is ok as a binary selector char."
	^true! !

Scanner removeSelector: #scanStringStruct!

Scanner removeSelector: #scanStringStruct!

Scanner removeSelector: #scanStringStruct:!

Scanner removeSelector: #scanStringStruct:!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Scanner initTypeTable!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3015-Backticks-JuanVuletich-2016Dec10-10h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3015] on 29 December 2016 at 4:06:32 pm'!
!LiteralNode methodsFor: 'printing' stamp: 'jmv 12/29/2016 16:06:13' prior: 16865098!
                             printOn: aStream indent: level

	key isVariableBinding
		ifTrue: [
			key key isNil
				ifTrue: [
					aStream nextPutAll: '###'; nextPutAll: key value soleInstance name ]
				ifFalse: [
					aStream nextPutAll: '##'; nextPutAll: key key ]]
		ifFalse: [
			key isLiteral
				ifTrue: [ key storeOn: aStream ]
				ifFalse: [
					"Need to generate code for stuff that is in a CompiledMethod literal
					but is not understood as a literal by the Compiler.
					Well, then it is because it was generated using backticks!!"
					aStream nextPut: $`.
					key storeOn: aStream.
					aStream nextPut: $`.
					]
			]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3016-Backticks-SupportInDecompiler-JuanVuletich-2016Dec29-15h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3016] on 30 December 2016 at 10:57:00 am'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 12/30/2016 10:29:16' prior: 50334661!
  xBacktick
	"Smalltalk code evaluated at compile time as a literal."

	self step.
	buffer reset.
	[hereChar == $`
		and: [aheadChar == $`
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched back quote']].
	self step.
	token _ [ Compiler evaluate: buffer contents ] 
		on: SyntaxErrorNotification, UndeclaredVariableReference, Error
		do: [ :ex |
			ex class caseOf: {
				[ SyntaxErrorNotification ] -> [
						self notify: 'Can not compile: ', ex errorMessage at: mark].
				[ UndeclaredVariableReference ] -> [ 
						self notify: 'Can not compile: Variable ''', ex varName, ''' is not declared' at: mark ]
			} otherwise: [
						self notify: 'Can not evaluate code: ', ex description at: mark ]].
	tokenType _ #literal! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3017-Backticks-betterErrorMessages-JuanVuletich-2016Dec30-10h56m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3016] on 30 December 2016 at 11:00:38 am'!
!Editor class methodsFor: 'class initialization' stamp: 'jmv 12/30/2016 11:00:14' prior: 16836909!
               initialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c |
		c basicInitialize ]! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 12/30/2016 10:34:01' prior: 16931735!
        enclose: aKeyboardEvent
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| left right startIndex stopIndex oldSelection which |
	startIndex _ self startIndex.
	stopIndex _ self stopIndex.
	oldSelection _ self selection.
	which _ '([<{"''`' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].
	left _ '([<{"''`' at: which.
	right _ ')]>}"''`' at: which.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) = left and: [(model actualContents at: stopIndex) = right]])
		ifTrue: [
			"already enclosed; strip off brackets"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection]
		ifFalse: [
			"not enclosed; enclose by matching brackets"
			self replaceSelectionWith:
				(Text string: (String with: left) attributes: emphasisHere),
				oldSelection,
				(Text string: (String with: right) attributes: emphasisHere).
			self selectFrom: startIndex+1 to: stopIndex].
	^true! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 12/30/2016 10:33:45' prior: 16933087!
        basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< #enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$f 	#find:						'Find')
		#(		$g 	#findAgain:				'Find again')
		#(		$h 	#help:						'Open this help')
		#(		$j 	#setSearchString:		'Set selection as search string for find again')

		#(		$z 	#undo:						'Undo (multiple levels)')
		#(		$x 	#cut:							'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:						'Paste Clipboard contents')

		#(		$R	#indent:						'Indent (move selection one tab-stap right)')
		#(		$Y	#makeUppercase:		'Force selection to uppercase')
		#(		$U	#changeLineEndsToLf:	'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H	#cursorTopHome:		'Move cursor to start of text')
		#(		$L	#outdent:					'Outdent (move selection one tab-stop left)')

		#(		$Z	#redo:						'Redo (multiple levels)')
		#(		$X	#makeLowercase:		'Force selection to lowercase')
		#(		$C	#compareToClipboard:	'Compare argument to clipboard')

		#(		$ 	#selectWord:				'Select the current word as with double clicking')
	)! !
!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 12/30/2016 10:36:10' prior: 16910578!
                     selectWord
	"Select delimited text or word--the result of double-clicking."

	| leftDelimiters rightDelimiters |
	"Warning. Once me (jmv) added Character crCharacter to the delimiters, to make double-click at and of line select whole line.
	This had the bad effect that if a class name is the last word of a line, double-click would correctly select it, but after that,
	doing ctrl-b to browse it would select the whole line..."
	leftDelimiters _ '([{<|''"`'.
	rightDelimiters _ ')]}>|''"`'.
	^self selectWordLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters! !

Editor initialize!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3018-Backticks-editorSupport-JuanVuletich-2016Dec30-10h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3016] on 30 December 2016 at 11:01:51 am'!
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/30/2016 10:51:03'!
                     parseBacktick
	self enterBlock.
	self scanPast: #backtick.
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $`.
	self scanPast: #backtick.
	self leaveBlock! !
!SHParserST80 methodsFor: 'scan' stamp: 'tween 2/17/2007 14:51' prior: 50334792!
 scanWhitespace
	| c |
	
	[c := self currentChar.
	c notNil and: [c isSeparator]] 
		whileTrue: [sourcePosition := sourcePosition + 1].
	c == $" ifTrue: [self scanComment]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/30/2016 10:51:08' prior: 16902861!
                              parseTerm
	self failWhen: currentToken isNil.
	currentTokenFirst == $( 
		ifTrue: [
			bracketDepth := bracketDepth + 1.
			self scanPast: #leftParenthesis level: bracketDepth.
			self parseExpression.
			self failUnless: currentTokenFirst == $).
			self scanPast: #rightParenthesis level: bracketDepth.
			bracketDepth := bracketDepth - 1.
			^self ].
	currentTokenFirst == $[ ifTrue: [^self parseBlock].
	currentTokenFirst == $` ifTrue: [^self parseBacktick].
	currentTokenFirst == ${ 
		ifTrue: [
			self scanPast: #leftBrace.
			self parseBraceArray.
			^self ].
	self isName ifTrue: [^self scanPast: (self resolve: currentToken)].
	self parseLiteral: false! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3019-Backticks-BetterShoutSupport-JuanVuletich-2016Dec30-11h00m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3019] on 30 December 2016 at 11:46:58 am'!
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 12/30/2016 11:44:19' prior: 50332635!
                     setAttributesFromRanges: ranges

	formattedText removeAttributesThat: [ :attribute | attribute isForShout ].

	"Optimize for mutation speed unless method is really large but with very few distict elements:
	Source code that includes just big literals is better served by conventional Text+RunArray"
	"Do it only if we are not breaking textModel!! (for instance, StyledTextEditor asks for formatting just sections, not whole #actualContents)."
	formattedText == textModel actualContents ifTrue: [
		(formattedText size > 2000 and: [ ranges size < 50 ]) ifFalse: [
			formattedText _ formattedText optimizedForMutationSpeed.
			textModel basicActualContents: formattedText ]].

	ranges do: [ :range |

		"Smalltalk text styling"
		(self attributesFor: range rangeType) ifNotNil: [ :attributes |
			attributes do: [ :each |
				formattedText addAttribute: each from: range start to: range end ]].

		"Show as subscripts if appropriate."
		classOrMetaClass ifNotNil: [
			classOrMetaClass theNonMetaClass lastUnderscoreMeansSubscript ifTrue: [
				(#( instVar classVar globalVar workspaceVar poolConstant
					patternArg methodArg patternTempVar tempVar		
					blockPatternArg blockArg blockPatternTempVar blockTempVar 
					incompleteIdentifier undefinedIdentifier) pointsTo: range rangeType )
						ifTrue: [
							formattedText lastIndexOf: $_ startingAt: range end endingAt: range start do: [ :i |
								formattedText addAttribute: ShoutTextEmphasis subscript from: i to: range end ] ]]]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3020-AvoidUnwantedSubscriptInClassDefinitions-JuanVuletich-2016Dec30-11h45m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3020] on 2 January 2017 at 2:27:29 pm'!
!Preferences class methodsFor: 'personalization' stamp: 'jmv 1/2/2017 14:18:06'!
                       usePreDebugWindow
	^ self
		valueOfFlag: #usePreDebugWindow
		ifAbsent: [ false ].! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 1/2/2017 14:11:03'!
   initialFrameIn: aWorld
	^RealEstateAgent initialFrameFor: self world: aWorld! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 1/2/2017 14:13:23'!
     initialFrameIn: aWorld
	| e |
	e _ self runningWorld morphExtent.
	^(0@0 corner: e) insetBy: e // 10! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 1/2/2017 14:11:12' prior: 16926575!
 openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| frameRect |
	frameRect _ self initialFrameIn: aWorld.
	self morphExtent: frameRect extent.
	aWorld addMorph: self position: frameRect topLeft.
	"Do it deferred. Was needed for text cursor to start blinking if (Preferences disable: #focusFollowsMouse) "
	WorldState addDeferredUIMessage: [ self activate ]! !
!PreDebugWindow class methodsFor: 'instance creation' stamp: 'jmv 1/2/2017 14:19:05' prior: 16892694!
        open: model label: aString message: messageString
	|  window |
	Preferences usePreDebugWindow
		ifTrue: [
			window _ self new.
			window
				model: model;
				buildMorphicWindowMessage: messageString print.
			aString ifNotNil: [ window setLabel: aString ].
			 window openInWorld ]
		ifFalse: [
			model openFullMorphicLabel: aString ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3021-DebuggerUsabilityEnh-JuanVuletich-2017Jan02-14h27m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3021] on 3 January 2017 at 9:34:24 pm'!
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/3/2017 21:22:43'!
                         nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ super nextPutAllString: aString withAttributes: attributesArray ].

	newEnd _ position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position _ newEnd! !
!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 21:21:34'!
          isCompatibleWithContents: aCollection

	collection class == aCollection class
		ifTrue: [ ^ true ].

	(aCollection isString and: [ collection is: #Text])
		ifTrue: [ ^ true ].

	^ false! !
!PositionableStream methodsFor: 'testing' stamp: 'jmv 1/3/2017 10:57:48' prior: 16891569!
         isText
	"Return true if the receiver is a Text stream"
	^collection is: #Text! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/3/2017 21:22:51' prior: 16946406!
                          nextPutAll: aCollection

	| newEnd |
	(self isCompatibleWithContents: aCollection)
		ifFalse: [ ^ super nextPutAll: aCollection ].

	newEnd _ position + aCollection size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.
	position _ newEnd.! !
!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 10:57:15' prior: 16946621!
                             withAttribute: aTextAttribute do: streamBlock
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock value ].

	pos1 _ self position.
	val _ streamBlock value.
	collection addAttribute: aTextAttribute from: pos1+1 to: self position.
	^ val! !
!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 10:57:19' prior: 16946627!
                withAttributes: attributes do: streamBlock 
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock value ].

	pos1 _ self position.
	val _ streamBlock value.
	attributes do: [:attribute |
		collection
			addAttribute: attribute
			from: pos1 + 1
			to: self position].
	^ val! !

Text class removeSelector: #streamContents:!

Text class removeSelector: #streamContents:!

Smalltalk removeClassNamed: #TextStream!

Smalltalk removeClassNamed: #TextStream!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3022-TextStream-removal-JuanVuletich-2017Jan03-21h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3022] on 4 January 2017 at 10:42:00 am'!
!SmallInteger methodsFor: 'system primitives' stamp: 'jmv 1/4/2017 10:35:09' prior: 16909090!
     digitAt: n 
	"Answer the value of an indexable field in the receiver.  LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds."
	n > Smalltalk wordSize ifTrue: [^ 0].
	self < 0
		ifTrue: 
			[self = SmallInteger minVal ifTrue: [
				"Can't negate minVal -- treat specially"
				^ Smalltalk wordSize = 4
					ifTrue: [ #(0 0 0 64) at: n ]
					ifFalse: [ #(0 0 0 0 0 0 0 16) at: n ]].
			^ ((0-self) bitShift: (1-n)*8) bitAnd: 16rFF]
		ifFalse: [^ (self bitShift: (1-n)*8) bitAnd: 16rFF]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3023-SmallInteger-digitAt-fixFor64Bits-JuanVuletich-2017Jan04-10h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3022] on 4 January 2017 at 10:46:32 am'!

Integer class removeSelector: #byte1:byte2:byte3:byte4:!

Integer class removeSelector: #byte1:byte2:byte3:byte4:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3024-Integer-from4Bytes-removal-JuanVuletich-2017Jan04-10h44m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3024] on 6 January 2017 at 10:05:27 am'!
!WeakArray class methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:56:14'!
startUp
	"Do it even if just continuing after image snapshot"
	self restartFinalizationProcess! !
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 1/6/2017 09:59:32'!
                      doStartUp: isARealStartup
	"
	isARealStartup
		true: system is coming up (VM and image just started)
		false: we have just saved an image snapshot, but didn't quit.
	"

	"Here, startup begins!!"
	Cursor normal activateCursor.
	self setGCParameters.
	isARealStartup ifTrue: [
		self clearExternalObjects ].
	self readCommandLineArguments.
	self processStartUpList: isARealStartup.
	isARealStartup ifTrue: [
		self setPlatformPreferences.
		self setStartupStamp ]! !
!Behavior methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:52:14' prior: 16785037!
                        startUp
	"This message is sent to registered classes when the system is coming up, or after an image save."! !
!Behavior methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:53:18' prior: 16785042!
                          startUp: isARealStartup
	"This message is sent to registered classes, with isARealStartup = true when the system is coming up,
	and with isARealStartup = false after a snapshot (image save, no quit).
	Classes caring about the difference should reimplement this method."

	^ self startUp! !
!WeakArray class methodsFor: 'class initialization' stamp: 'jmv 1/6/2017 09:49:16' prior: 16943683!
                          initialize
	"
	WeakArray initialize.
	SystemDictionary initialize.
	"

	self restartFinalizationProcess! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/6/2017 09:53:30' prior: 16922685!
                   processStartUpList: isARealStartup
	"Send #startUp to each class that needs to run initialization after a snapshot."

	EndianCache _ self calcEndianness.
	self send: #startUp: toClassesNamedIn: StartUpList with: isARealStartup! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/6/2017 09:55:41' prior: 16922813!
                        send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument
	"Send the message #startUp: or #shutDown: to each class named in the list.
	The argument indicates if the system is about to quit (for #shutDown:) or if
	the image is ia real startup (or just continue after image save) (for #startUp:).
	If any name cannot be found, then remove it from the list."

	| removals class |
	removals _ OrderedCollection new.
	startUpOrShutDownList do:
		[:name |
		class _ self at: name ifAbsent: nil.
		class
			ifNil: [removals add: name]
			ifNotNil: [
				class isInMemory ifTrue: [
					class perform: startUpOrShutDown with: argument]]].

	"Remove any obsolete entries, but after the iteration"
	"Well, not. Better just ignore them. Maybe it is stuff, like SoundPlayer, that was moved to optional packages, and can be loaded again anytime."
	"startUpOrShutDownList removeAll: removals"! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/6/2017 09:59:34' prior: 16922908!
                       snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup world reopenTranscript |
	self logSapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	world _ ProjectX ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"world _ clearAllStateFlag ifFalse: [ ProjectX ui ]."
	ProjectX stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: 1024@768 depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.
	
	
	ProjectX spawnNewMorphicProcessFor: (world ifNil: [ PasteUpMorph newWorld ]).

	reopenTranscript ifTrue: [
		WorldState addDeferredUIMessage: [
			TranscriptWindow openTranscript ]].
	"
	WorldState addDeferredUIMessage: [
		world fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [	
		WorldState addDeferredUIMessage: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !

SystemDictionary removeSelector: #startup:!

SystemDictionary removeSelector: #startup:!

WeakArray class removeSelector: #startUp:!

WeakArray class removeSelector: #startUp:!

WeakArray initialize!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3025-RestartFinalizationAfterImageSave-JuanVuletich-2017Jan06-09h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 13 January 2017 at 9:55:29 am'!
!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'jmv 1/13/2017 09:39:07'!
                 bitXor: arg
	"Primitive 36 deals with only 64-bit values (up to 8 byte LargeIntegers).
	The inherited <primitive: 'primDigitBitXor' module:'LargeIntegers'> deals with 
	arbitrary sized large integers, but is much slower.
	This method gives a performance improvement for integers using 32 to 64 bits on 32 bit VMs,
	but only for 62 to 64 bits on 64 bits VMs.
	See http://forum.world.st/Integer-arithmetic-and-bit-operations-in-Squeak-and-Pharo-32bit-amp-64bit-tc4928994.html#none
	"

    <primitive:36>
    ^super bitXor: arg! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3026-LargeInteger-bitXor-performanceImprov-JuanVuletich-2017Jan13-09h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 13 January 2017 at 9:55:58 am'!
!SHParserST80 methodsFor: 'parse' stamp: 'ul 10/12/2010 02:43'!
                 parseStringOrSymbol

	currentTokenFirst == $' ifTrue: [ ^self parseString ].
	currentTokenFirst == $# ifTrue: [ ^self parseSymbol ].
	self error! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 1/13/2017 09:53:38' prior: 16902728!
                         parsePrimitive
	self scanNext.
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: [
			self failUnless: currentTokenFirst == $'.
			self parseString.
			currentToken = 'module:' 
				ifTrue: [
					self scanPast: #module.
					self failUnless: currentTokenFirst == $'.
					self parseString]].
	currentToken = 'error:' ifTrue: [
		self scanPast: #primitive. "there's no rangeType for error"
		self isName
			ifTrue: [ self scanPast: #patternTempVar ]
			ifFalse: [ self parseStringOrSymbol ] ].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3027-ShoutFix-JuanVuletich-2017Jan13-09h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 13 January 2017 at 9:59:33 am'!
!Float methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:46' prior: 16845694!
                    replaceWordsFrom: start to: stop with: replacement startingAt: repStart
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	self primitiveFailed! !
!LargePositiveInteger methodsFor: 'system primitives' stamp: 'jmv 1/13/2017 09:58:53' prior: 16862796!
            replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!String methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:04' prior: 16917188!
                    replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!Array methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:31' prior: 16779882!
                     replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!ByteArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:38' prior: 16793800!
                 replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!Float64Array methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:50' prior: 16846133!
              replaceWordsFrom: start to: stop with: replacement startingAt: repStart
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	self primitiveFailed! !
!FloatArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:24' prior: 16846632!
replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!RunNotArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:00' prior: 16901681!
               replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Copied from Array"
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!WordArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:38' prior: 16945290!
                            replaceFrom: start to: stop with: replacement startingAt: repStart 

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart ! !
!Bitmap methodsFor: 'accessing' stamp: 'jmv 1/13/2017 09:57:27' prior: 16787571!
replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3028-GrabErrorCodeForPrim105-JuanVuletich-2017Jan13-09h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3028] on 14 January 2017 at 8:18:04 am'!
!Point commentStamp: 'jmv 12/30/2016 17:39:06' prior: 16890200!
                  I represent an x-y pair of numbers usually designating a location on the screen.

When dealing with display coordinates, the y axis is usually considered to increase downwards. However, the standard math convention is to consider it increasing upwards. 
Points don't need to know about this. In the first case, theta increases clockwise. In the second case, it increases counter-clockwise, also the standard math convention.

Any method that doesn't follow this (because it assumes one specific convention) include this fact in the selector and in a comment.

My instances are immutable. See #privateSetX:setY:!
!Point methodsFor: 'private' stamp: 'jmv 12/11/2016 10:28:44'!
                             privateSetX: xValue setY: yValue
	"Points are immutable. Right now this is by convention, but we'll make this enfoced by VM.
	Do not all this method, except from instance creation."
	x _ xValue.
	y _ yValue! !
!Point methodsFor: 'copying' stamp: 'pb 10/29/2016 18:18:07'!
                shallowCopy
	"Immutable"
	^ self.! !
!Object class methodsFor: 'instance creation' stamp: 'jmv 12/30/2016 17:33:31' prior: 16882941!
                           unStream: aByteArray
	^ ReferenceStream unStream: aByteArray! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'jmv 12/30/2016 17:33:27' prior: 16828091!
                          unStream: aByteArray

	^(self on: ((RWBinaryOrTextStream with: aByteArray) reset; binary)) next! !
!Point class methodsFor: 'instance creation' stamp: 'pb 10/29/2016 17:14:00' prior: 16890866!
                               r: rho degrees: degrees
	"Answer an instance of me with polar coordinates rho and theta."
	^ self
		rho: rho
		theta: degrees asFloat degreesToRadians.! !
!Point class methodsFor: 'instance creation' stamp: 'pb 10/29/2016 17:12:53' prior: 16890873!
       rho: rho theta: radians
	"Answer an instance of me with polar coordinates rho and theta."
	^ self
		x: rho asFloat * radians cos
		y: rho asFloat * radians sin.! !
!Point class methodsFor: 'instance creation' stamp: 'jmv 12/11/2016 10:28:50' prior: 16890880!
                             x: anX y: anY
	"Answer an instance of me with supplied coordinates."

	^self new privateSetX: anX setY: anY! !

Point removeSelector: #setR:degrees:!

Point removeSelector: #setR:degrees:!

Point removeSelector: #setRho:theta:!

Point removeSelector: #setRho:theta:!

Point removeSelector: #setX:setY:!

Point removeSelector: #setX:setY:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3029-Point-immutable-PhilBellalouna-2017Jan14-08h15m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3029] on 14 January 2017 at 8:53:02 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 1/14/2017 08:52:09' prior: 16920588!
     knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 					'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('BenComan' 			'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 					'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 					'Doug Way')
	#('dgd' 					'Diego Gomez Deck')
	#('dkh'					'Dale Henrichs')
	#('dhn'	 				'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DKL'					'Daniel K Lyons ')
	#('DM' 					'Duncan Mak')
	#('DSM' 					'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 					'Hari Balaraman')
	#('hjh' 					'Hannes Hirzel')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 					'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 					'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 					'Mike Rutenberg')
	#('mga' 					'Markus Galli')
	#('mha' 					'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('PHK' 					'Peter Keeler')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 					'Paul McDonough')
	#('r++' 					'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 					'Ron Teitelbaum')
	#('rr' 						'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 					'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 					'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 					'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sqr' 					'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 					'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 					'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 					'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3030-AddHernanAndGeraToKnownAuthors-JuanVuletich-2017Jan14-08h52m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 10 January 2017 at 8:09:15 pm'!

Object subclass: #TestResultForDebuggingAndInspection
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #TestResultForDebuggingAndInspection category: #'Tools-Testing'!
Object subclass: #TestResultForDebuggingAndInspection
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!
!CompiledMethod methodsFor: 'testing' stamp: 'HernanWilkinson 1/10/2017 18:22:10'!
                       isTestMethod

    ^ (self methodClass is: #TestCaseClass) 
		and: [ ((self selector beginsWith: 'test') or: [ (self selector beginsWith: 'should')]) 
		and: [ self numArgs isZero ] ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:35:14'!
                      acceptAndTest
	
	^self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteOf: aMethod methodClass ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:35:34'!
   acceptAndTestAll
	
	^self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteForCategoryOf: aMethod methodClass ]
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:04:06'!
                 acceptThenTestMethodAndSuite: aSuiteBuilder
	
	| potencialTestMethod |
	
	self acceptContents ifFalse: [ ^false ].
	
	potencialTestMethod _ model textProvider currentCompiledMethod.
	self runAndDebuggIfNecessary: potencialTestMethod.
	^(self runTestSuite: (aSuiteBuilder value: potencialTestMethod)) hasPassed
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 18:50:03'!
                     flashWith: aColor

	^morph flashWith: aColor! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 18:50:21'!
flashWithGreen

	^self flashWith: Color green

	
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:03:07'!
                        runAndDebuggIfNecessary: aPotentialTestMethod

	aPotentialTestMethod isTestMethod ifTrue: [
		aPotentialTestMethod methodClass debug: aPotentialTestMethod selector ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:04:42'!
       runTestSuite: aTestSuite

	| suiteRunResult |
	 
	suiteRunResult _ aTestSuite run.
	suiteRunResult hasPassed 
		ifTrue: [self flashWithGreen ]
		ifFalse: [ suiteRunResult forDebuggingAndInspection inspect ].
		
	^suiteRunResult 

	
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:35:52'!
 testSuiteForCategoryOf: aClass

	| testCaseClasses |
	
	testCaseClasses _ (SystemOrganization listAtCategoryNamed: aClass category)
		collect: [ :aClassName | Smalltalk classNamed: aClassName ]
		thenSelect: [ :aClassInCategory | aClassInCategory is: #TestCaseClass ].
		
	
	^testCaseClasses
		inject: (TestSuite named: 'Test of Category ', aClass category)
		into: [ :suite :testCaseClass | testCaseClass addToSuiteFromSelectors: suite ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:34:58'!
                      testSuiteOf: aPotentialTestCaseClass

	^(aPotentialTestCaseClass is: #TestCaseClass)
		ifTrue: [ aPotentialTestCaseClass buildSuite ]
		ifFalse: [ TestSuite named: 'Tests of ', aPotentialTestCaseClass name ]! !
!DisplayScreen methodsFor: 'displaying' stamp: 'HernanWilkinson 1/10/2017 18:45:48'!
                        flash: aRectangle with: aColor

	self fill: aRectangle fillColor: aColor.
	self forceToScreen: aRectangle.
	(Delay forMilliseconds: 100) wait.
	self fill: aRectangle fillColor: aColor.
	self forceToScreen: aRectangle! !
!Morph methodsFor: 'macpal' stamp: 'HernanWilkinson 1/10/2017 18:49:44'!
                           flashWith: aColor

	self morphBoundsInWorld ifNotNil: [ :r | Display flash: r with: aColor ]! !
!InnerTextMorph methodsFor: 'editing' stamp: 'HernanWilkinson 1/10/2017 15:56:51'!
             confirmAcceptAnyway

	^ self confirm: 
'Caution!! Contents were saved
elsewhere since you started
editing them here.  Accept anyway?'! !
!TestCase class methodsFor: 'Testing' stamp: 'HernanWilkinson 1/10/2017 16:29:48'!
    is: aSymbol

	^aSymbol == #TestCaseClass or: [ super is: aSymbol ]! !
!TestResult methodsFor: 'Inspecting' stamp: 'HernanWilkinson 1/10/2017 16:33:03'!
        forDebuggingAndInspection

	^TestResultForDebuggingAndInspection on: self! !
!TestResultForDebuggingAndInspection methodsFor: 'initialization' stamp: 'HernanWilkinson 1/10/2017 16:34:56'!
    initializeOn: aTestResult

	testResult _ aTestResult! !
!TestResultForDebuggingAndInspection methodsFor: 'printing' stamp: 'HernanWilkinson 1/10/2017 17:49:59'!
                               print: aCollectionOfTestCases startingWith: header on: aStream
	
	aCollectionOfTestCases
		do: [ :aTestCase |
			aStream 
				nextPutAll: header;
				space;
				nextPutAll: aTestCase class name;
				nextPutAll: ' debug: #';
				nextPutAll: aTestCase selector ]
		separatedBy: [ aStream newLine ].
		
	! !
!TestResultForDebuggingAndInspection methodsFor: 'printing' stamp: 'HernanWilkinson 1/10/2017 17:49:05'!
      printOn: aStream

	aStream print: testResult.
	aStream newLine.
	
	self print: testResult errors startingWith: '"E"' on: aStream.
	self print: testResult failures startingWith: '"F"' on: aStream.
	! !
!TestResultForDebuggingAndInspection methodsFor: 'running' stamp: 'HernanWilkinson 1/10/2017 18:14:09'!
               reRun

	| suite |
	 
	suite _ TestSuite new.
	suite addTests: testResult tests.
	
	testResult _ suite run.! !
!TestResultForDebuggingAndInspection class methodsFor: 'instance creation' stamp: 'HernanWilkinson 1/10/2017 16:34:28'!
                          on: aTestResult

	^self new initializeOn: aTestResult! !
!TextEditor methodsFor: 'menu messages' stamp: 'HernanWilkinson 1/10/2017 16:00:24' prior: 16932076!
  acceptContents
	"Save the current text of the text being edited as the current acceptable version for purposes of canceling.  Allow my morph to take appropriate action"
	^morph acceptContents! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HernanWilkinson 1/10/2017 19:58:01' prior: 16910705!
  initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.										#openHelp}.
		#-.
		{'Do it (d)'.									#doIt}.
		{'Print it (p)'.									#printIt}.
		{'Inspect it (i)'.								#inspectIt}.
		{'Explore it (I)'.								#exploreIt}.
		{'Debug it (D)'.								#debugIt}.
		{'Profile it'.									#profileIt}.
		#-.
		{'Explain'.										#explain}.
		{'Browse it (b)'.								#browseIt}.
		{'Senders of it (n)'.							#sendersOfIt}.
		{'Implementors of it (m)'.					#implementorsOfIt}.
		{'References to it (N)'.						#referencesToIt}.
		#-.
		{'Method Strings with it (E)'.				#methodStringsContainingit}.
		{'Method Source with it'.					#methodSourceContainingIt}.
		{'Class Comments with it'.					#classCommentsContainingIt}.
		#-.
		{'Accept (s)'.									#acceptContents}.
		{'Cancel (l)'.									#cancelEdits}.
		{'Accept & Run Test in Class (t)'.			#acceptAndTest}.
		{'Accept & Run Test in Category (y)'.		#acceptAndTestAll}.
		#-.
		{'More...'.										#getMenu2}.
	}.
	menu2 _ SelectionMenu fromArray: {
		{'Find...(f)'.									#find}.
		{'Find Again (g)'.								#findAgain}.
		{'Use Selection for Find (j)'.				#setSearchString}.
		#-.
		{'Undo - multiple (z)'.						#undo}.
		{'Redo - multiple (Z)'.						#redo}.
		{'Undo / Redo history'.						#offerUndoHistory}.
		#-.
		{'Copy (c)'.									#copySelection}.
		{'Cut (x)'.										#cut}.
		{'Paste (v)'.									#paste}.
		{'Paste without Format'.						#pasteString}.
		{'Paste...'.									#pasteRecent}.
		#-.
		{'Toggle WordWrap'.						#wrapOnOff}.
		{'Set Font... (k)'.								#offerFontMenu}.
		{'Clear Font'.									#clearFont}.
		{'Set Default Font...'.						#offerDefaultFontMenu}.
		#-.
		{'More...'.										#getMenu}.
	}! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'HernanWilkinson 1/10/2017 17:47:44' prior: 16857247!
                     initialExtent

	^600@325! !
!InnerTextMorph methodsFor: 'editing' stamp: 'HernanWilkinson 1/10/2017 19:46:39' prior: 16855583!
 acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| accepted prevSelection prevScrollValue |
	
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar value.
	
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) ifTrue: [self flash. ^true].
	(self hasEditingConflicts and: [ self confirmAcceptAnyway not ]) ifTrue: [self flash. ^false].
	
	accepted _ model acceptContentsFrom: owner.
	"During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the code-holding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
	
	"some implementors of acceptContentsFrom: answer self :("
	^accepted == true 
		ifTrue: [
			model refetch.
			self editor selectFrom: prevSelection first to: prevSelection last.
			WorldState addDeferredUIMessage: [
				self world ifNotNil: [ :w | w activeHand newKeyboardFocus: self ].
				owner verticalScrollBar setValue: prevScrollValue].
			true]
		ifFalse: [ false ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3031-TDDSupport-0-HernanWilkinson.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 10 January 2017 at 8:09:22 pm'!
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:04:06'!
         acceptAndTest: aKeyboardEvent

	^self acceptAndTest! !
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:04:34'!
                acceptAndTestAll: aKeyboardEvent

	^self acceptAndTestAll! !
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:02:27'!
          debugIt: aKeyboardEvent

	self debugIt.
	^true! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HernanWilkinson 1/10/2017 20:03:23' prior: 16910661!
                   cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')
		#(		$l	#cancelEdits:						'Cancel')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$A	#argAdvance:						'Advance argument')
		#(		$D	#debugIt:							'Debut it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HernanWilkinson 1/10/2017 19:58:01' prior: 50336246!
                           initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.										#openHelp}.
		#-.
		{'Do it (d)'.									#doIt}.
		{'Print it (p)'.									#printIt}.
		{'Inspect it (i)'.								#inspectIt}.
		{'Explore it (I)'.								#exploreIt}.
		{'Debug it (D)'.								#debugIt}.
		{'Profile it'.									#profileIt}.
		#-.
		{'Explain'.										#explain}.
		{'Browse it (b)'.								#browseIt}.
		{'Senders of it (n)'.							#sendersOfIt}.
		{'Implementors of it (m)'.					#implementorsOfIt}.
		{'References to it (N)'.						#referencesToIt}.
		#-.
		{'Method Strings with it (E)'.				#methodStringsContainingit}.
		{'Method Source with it'.					#methodSourceContainingIt}.
		{'Class Comments with it'.					#classCommentsContainingIt}.
		#-.
		{'Accept (s)'.									#acceptContents}.
		{'Cancel (l)'.									#cancelEdits}.
		{'Accept & Run Test in Class (t)'.			#acceptAndTest}.
		{'Accept & Run Test in Category (y)'.		#acceptAndTestAll}.
		#-.
		{'More...'.										#getMenu2}.
	}.
	menu2 _ SelectionMenu fromArray: {
		{'Find...(f)'.									#find}.
		{'Find Again (g)'.								#findAgain}.
		{'Use Selection for Find (j)'.				#setSearchString}.
		#-.
		{'Undo - multiple (z)'.						#undo}.
		{'Redo - multiple (Z)'.						#redo}.
		{'Undo / Redo history'.						#offerUndoHistory}.
		#-.
		{'Copy (c)'.									#copySelection}.
		{'Cut (x)'.										#cut}.
		{'Paste (v)'.									#paste}.
		{'Paste without Format'.						#pasteString}.
		{'Paste...'.									#pasteRecent}.
		#-.
		{'Toggle WordWrap'.						#wrapOnOff}.
		{'Set Font... (k)'.								#offerFontMenu}.
		{'Clear Font'.									#clearFont}.
		{'Set Default Font...'.						#offerDefaultFontMenu}.
		#-.
		{'More...'.										#getMenu}.
	}! !
!InnerTextMorph methodsFor: 'editing' stamp: 'HernanWilkinson 1/10/2017 19:46:39' prior: 50336311!
                           acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| accepted prevSelection prevScrollValue |
	
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar value.
	
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) ifTrue: [self flash. ^true].
	(self hasEditingConflicts and: [ self confirmAcceptAnyway not ]) ifTrue: [self flash. ^false].
	
	accepted _ model acceptContentsFrom: owner.
	"During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the code-holding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
	
	"some implementors of acceptContentsFrom: answer self :("
	^accepted == true 
		ifTrue: [
			model refetch.
			self editor selectFrom: prevSelection first to: prevSelection last.
			WorldState addDeferredUIMessage: [
				self world ifNotNil: [ :w | w activeHand newKeyboardFocus: self ].
				owner verticalScrollBar setValue: prevScrollValue].
			true]
		ifFalse: [ false ]! !

Editor initialize!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3032-TDDSupport-1-HernanWilkinson.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 12 January 2017 at 5:14:29 pm'!
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:05:16'!
 askForSuperclassOf: aClass toImplement: aSelector ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes _ aClass withAllSuperclasses.
	chosenClassIndex _ PopUpMenu
		withCaption: 'Define #', aSelector, ' in which class?'
		chooseFrom: (classes collect: [:c | c name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock value].

	^ classes at: chosenClassIndex! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:09:46'!
    create

	self shouldBeAbleToCreateMethod 
		ifTrue: [ self createMethod ]
		ifFalse: [ self inform: 'Only available for doesNotUndertand:' ]! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:04:29'!
   createMethod

	| message chosenClass interruptedContext |
	
	interruptedContext _ self interruptedContext.
	message _ interruptedContext tempAt: 1.
	chosenClass _ self
		askForSuperclassOf: interruptedContext receiver class
		toImplement: message selector
		ifCancel: [^self].
	self implement: message inClass: chosenClass.
! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:01:22'!
           shouldBeAbleToCreateMethod

	^self interruptedContext selector == #doesNotUnderstand:! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 17:04:50' prior: 16831115!
           customButtonSpecs
	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."

	^#(
		('Restart'		restart				'reset this context to its start.')
		('Into'			send					'step Into message sends')
		('Over'			doStep				'step Over message sends')
		('Through'		stepIntoBlock		'step into a block')
		('Full Stack'	fullStack			'show full stack')
		('Where'		where				'select current pc range')
		('Create'		create 				'create method'))! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 17:06:02' prior: 16892577!
             buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	(aDebugger shouldBeAbleToCreateMethod) ifTrue: [
		triads add: { 'Create'. #createMethod. 'create the missing method' }
	].
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: Color transparent.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!PreDebugWindow methodsFor: 'button actions' stamp: 'HAW 1/12/2017 17:06:43' prior: 16892636!
            createMethod
	"Should only be called when this Debugger was created in response to a
	MessageNotUnderstood exception. Create a stub for the method that was
	missing and proceed into it."
	
	model createMethod.
	self debug
! !

PreDebugWindow removeSelector: #askForSuperclassOf:toImplement:ifCancel:!

PreDebugWindow removeSelector: #askForSuperclassOf:toImplement:ifCancel:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3033-CreateMethodSupport-HernanWilkinson-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 12 January 2017 at 6:54:23 pm'!
!Behavior methodsFor: 'accessing class hierarchy' stamp: 'HAW 1/12/2017 18:29:00'!
                      allSuperclassesUpTo: aSuperclass
	
	| superclasses |
	
	^ superclass = aSuperclass
		ifTrue: [ OrderedCollection with: aSuperclass]
		ifFalse: [superclasses _ superclass allSuperclassesUpTo: aSuperclass.
			superclasses addFirst: superclass.
			superclasses]! !
!Behavior methodsFor: 'accessing class hierarchy' stamp: 'HAW 1/12/2017 18:30:53'!
       withAllSuperclassesUpTo: aSuperclass

	| classes |
	
	classes _ self allSuperclassesUpTo: aSuperclass.
	classes addFirst: self.
	
	^ classes! !
!ContextPart methodsFor: 'debugger access' stamp: 'HAW 1/12/2017 17:48:35'!
    arguments

	| arguments |

	arguments _ Array new: self selector numArgs.
	1 to: arguments size do: [ :index | arguments at: index put: (self tempAt: index)].

	^arguments.
	
	! !
!ContextPart methodsFor: 'debugger access' stamp: 'HAW 1/12/2017 17:47:30'!
messageForYourself

	^Message selector: self selector arguments: self arguments.
	! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:31:14'!
 askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes _ aClass withAllSuperclassesUpTo: aSuperclass. 
	chosenClassIndex _ PopUpMenu
		withCaption: 'Define #', aSelector, ' in which class?'
		chooseFrom: (classes collect: [:c | c name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock value].

	^ classes at: chosenClassIndex! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:45:03'!
    createMethodOnSubclassResponsibility

	| message chosenClass subclassResponsibilityContext |
	
	subclassResponsibilityContext _ self interruptedContext sender sender.
	message _ subclassResponsibilityContext messageForYourself.
	
	chosenClass _ self
		askForSuperclassOf: subclassResponsibilityContext receiver class
		upTo: subclassResponsibilityContext method methodClass
		toImplement: message selector
		ifCancel: [^self].
		
	self implement: message inClass: chosenClass context: subclassResponsibilityContext 

! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:43:11'!
              createMethodWhenDoesNotUndertand

	| message chosenClass interruptedContext |
	
	interruptedContext _ self interruptedContext.
	message _ interruptedContext tempAt: 1.
	
	chosenClass _ self
		askForSuperclassOf: interruptedContext receiver class
		toImplement: message selector
		ifCancel: [^self].
	
	self implement: message inClass: chosenClass context: self selectedContext

! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:43:25'!
                         implement: aMessage inClass: aClass context: aContext 
	
	aClass
		compile: aMessage createStubMethod
		classified: (self askForCategoryIn: aClass default: 'as yet unclassified').
		
	aContext privRefreshWith: (aClass lookupSelector: aMessage selector).
	aMessage arguments withIndexDo: [ :arg :index | aContext tempAt: index put: arg ].
	self resetContext: aContext! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:22:28'!
     wasInterrupedOnDoesNotUnderstand

	^self interruptedContext selector == #doesNotUnderstand:! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:25:23'!
                        wasInterruptedOnSubclassResponsibility

	^self interruptedContext sender ifNil: [ false ] ifNotNil: [ :senderContext | senderContext selector == #subclassResponsibility ]! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:31:48' prior: 50336542!
                         askForSuperclassOf: aClass toImplement: aSelector ifCancel: cancelBlock

	^self askForSuperclassOf: aClass upTo: ProtoObject toImplement: aSelector ifCancel: cancelBlock
! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:46:00' prior: 50336563!
                         createMethod

	self wasInterrupedOnDoesNotUnderstand ifTrue: [ ^self createMethodWhenDoesNotUndertand ].
	self wasInterruptedOnSubclassResponsibility ifTrue: [ ^self createMethodOnSubclassResponsibility ].
	
	self inform: 'Only available for #doesNotUndertand: and #subclassResponsibility' ! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:22:47' prior: 50336576!
 shouldBeAbleToCreateMethod

	^self wasInterrupedOnDoesNotUnderstand or: [ self wasInterruptedOnSubclassResponsibility]! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:46:32' prior: 50336582!
          customButtonSpecs
	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."

	^#(
		('Restart'		restart				'reset this context to its start.')
		('Into'			send					'step Into message sends')
		('Over'			doStep				'step Over message sends')
		('Through'		stepIntoBlock		'step into a block')
		('Full Stack'	fullStack			'show full stack')
		('Where'		where				'select current pc range')
		('Create'		createMethod		'create method'))! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:47:35' prior: 50336601!
          buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: Color transparent.
	row separation: 1.
	row addMorphs: buttons.
	^row! !

Debugger removeSelector: #create!

Debugger removeSelector: #create!

Debugger removeSelector: #implement:inClass:!

Debugger removeSelector: #implement:inClass:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3034-CreateMethodSupport-HernanWilkinson-1-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3032] on 14 January 2017 at 9:09:47 am'!
!Theme methodsFor: 'menus' stamp: 'jmv 1/14/2017 09:09:05' prior: 16936064!
                             miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history' 'code file contents' 'package file contents') -> #changesIcon.
		#('Install New Updates' 'update' 'turn on auto-update (a)' 'update list (u)' 'install code' 'fileIn entire file' 'install package') -> #updateIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' 'turn off auto-update (a)') -> #cancelIcon.
		#('debug...' 'Debug it (D)' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'restore all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor'  'basic text editor'  'unicode editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList' 'compress file') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner' 'Accept & Run Test in Class (t)' 'Accept & Run Test in Category (y)') -> #weatherFewCloudsIcon.
		#('Font Sizes...' 'system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'All preferences...' 'what to show...' 'view as hex') -> #preferencesIcon.
		#('Editor keyboard shortcuts') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.		"currently unused, but a neat icon"
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set code author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'Profile it') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance') -> #instanceIcon.
		#('Use Selection for Find (j)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('smalltalk options' 'method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)' 'Toggle WordWrap') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)' 'More...') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...' 'Set Default Font...') -> #fontXGenericIcon.
		#('Clear Font') -> #newIcon.
		#('code file browser' 'package file browser') -> #findIcon.
	}! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Theme current class beCurrent!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3035-AddIconsForTDDSupport-JuanVuletich-2017Jan14-09h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3035] on 16 January 2017 at 11:04:32 am'!

(Smalltalk classNamed: 'Taskbar') ifNotNil: [ :tbClass |
	PasteUpMorph allInstancesDo: [ :w | w hideTaskbar ].
	tbClass allInstancesDo: [ :each | each delete ]]!

StringMorph subclass: #UpdatingStringMorph
	instanceVariableNames: 'target getSelector stepTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #UpdatingStringMorph category: #'Morphic-Widgets'!
StringMorph subclass: #UpdatingStringMorph
	instanceVariableNames: 'target getSelector stepTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!UpdatingStringMorph commentStamp: 'jmv 1/5/2013 23:49' prior: 0!
        UpdatingStringMorph new
     target: [self runningWorld activeHand morphPosition asString];
     getSelector: #value;
     stepTime: 10;
     openInWorld!

LayoutMorph subclass: #TaskbarMorph
	instanceVariableNames: 'viewBox scale'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Taskbar'!

!classDefinition: #TaskbarMorph category: #'Tools-Taskbar'!
LayoutMorph subclass: #TaskbarMorph
	instanceVariableNames: 'viewBox scale'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Taskbar'!
!TaskbarMorph commentStamp: '<historical>' prior: 0!
      A simple task bar written for Cuis.

dashBoard contains views/controls
viewBox contains graphic buttons of "iconized" windows/morphs.
scale allows 1x 2x 4x tarkbar height. [scale= 1,2,4]!
!Preferences class methodsFor: 'personalization' stamp: 'jmv 1/15/2017 18:51:02'!
                  taskbarIncludesAllWindows
	"
	true: All windows are included in Taskbar
	false: Only collapsed windows are included in Taskbar
	"
	^ self
		valueOfFlag: #taskbarIncludesAllWindows
		ifAbsent: [ true ].! !
!Morph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 18:06:45'!
                   taskbar
	^self world ifNotNil: [ :w | w taskbar ]! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/15/2017 14:52:58'!
showAndComeToFront

	self show; comeToFront! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 1/16/2017 09:56:14'!
   addedMorph: aMorph
	"Notify the receiver that the given morph was just added."
	super addedMorph: aMorph.
	self taskbar ifNotNil: [ :tb |
		tb wasOpened: aMorph ]! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 1/16/2017 09:56:07'!
            removedMorph: aMorph
	"Notify the receiver that aMorph was just removed from its children"
	super removedMorph: aMorph.
	self taskbar ifNotNil: [ :tb |
		tb wasDeleted: aMorph ]! !
!PasteUpMorph methodsFor: 'taskbar' stamp: 'jmv 1/15/2017 18:57:53'!
      taskbarDeleted
	taskbar _ nil! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
                     getSelector: aSymbol
	getSelector _ aSymbol! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:18'!
       stepTime

	^stepTime! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
                              stepTime: aNumber
	stepTime _ aNumber! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
             target: anObject
	target _ anObject! !
!UpdatingStringMorph methodsFor: 'initialization' stamp: 'jmv 9/13/2013 09:23'!
         initialize
	super initialize.
	target _ self.
	getSelector _ #contents.
	stepTime _ 50! !
!UpdatingStringMorph methodsFor: 'stepping' stamp: 'jmv 2/27/2016 20:07'!
                            stepAt: millisecondSinceLast

	self contents: (target perform: getSelector)! !
!UpdatingStringMorph methodsFor: 'stepping' stamp: 'jmv 1/4/2013 13:18'!
        wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run"

	^true! !
!UpdatingStringMorph methodsFor: 'geometry' stamp: 'jmv 1/15/2017 14:25:27'!
                fitContents
	"Don't shrink each time contents change.
	Might shrink during layout"
	self morphExtent: (extent max: self measureContents)! !
!UpdatingStringMorph class methodsFor: 'new-morph participation' stamp: 'jmv 4/15/2014 09:26'!
                     initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (AbstractFont familyName: 'DejaVu' pointSize: 22) 
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #value.
		
	^ newInst! !
!TaskbarMorph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 14:49:41'!
                        buttonFor: aMorph
	
	viewBox ifNotNil: [
		viewBox submorphs do: [ :button | 
			button model == aMorph
				ifTrue: [ ^button ]]
	].
	^nil! !
!TaskbarMorph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 14:49:30'!
           scale

	 ^ scale ifNil: [ self defaultScale ] ifNotNil: [ scale ]! !
!TaskbarMorph methodsFor: 'events' stamp: 'jmv 1/8/2017 16:48:00'!
                        notifyDisplayResize
	Display
		when: #screenSizeChanged
		send: #screenSizeChanged
		to: self.
	self screenSizeChanged! !
!TaskbarMorph methodsFor: 'events' stamp: 'jmv 1/8/2017 16:48:14'!
   screenSizeChanged
	"Respond to change in screen size by repositioning self to bottom of screen"
	
"	Transcript newLine; print: 'Taskbar screenSizeChanged'.
"
	| y e |
	WorldState addDeferredUIMessage: [
		self world ifNotNil: [ :w |
			y _ w morphExtent y - self defaultHeight.
			e _ self internalizeDistance: w morphExtent x @ self defaultHeight.
			self morphPosition: 0@y extent: e ]]! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/15/2017 14:49:51'!
            defaultHeight

	^ Preferences windowTitleFont height * 2 * self scale! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/15/2017 14:49:19'!
           defaultScale

	 ^ 1! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/8/2017 16:57:33'!
                              initialize
	super initialize.
	viewBox _ LayoutMorph newRow color: self defaultColor.
	self
		addMorph: UpdatingStringMorph initializedInstance
		layoutSpec:  (LayoutSpec morphWidthProportionalHeight: 1.0).
	self
		addMorph: viewBox 
		layoutSpec: (LayoutSpec
			proportionalWidth: 1.0
			proportionalHeight: 1.0 
			minorDirectionPadding: #right).
	viewBox separation: 5
! !
!TaskbarMorph methodsFor: 'testing' stamp: 'jmv 1/8/2017 16:44:53'!
    is: aSymbol
	^ aSymbol == #TaskbarMorph or: [ super is: aSymbol ]! !
!TaskbarMorph methodsFor: 'testing' stamp: 'jmv 1/8/2017 16:47:41'!
                       isSticky
	"answer whether the receiver is Sticky"
	^true! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:42:23'!
                              addButtonFor: aMorph

	| button |
	button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #showAndComeToFront.
	button
		color: self color;
		icon: (aMorph imageForm: 32);
		setBalloonText: aMorph label.
	viewBox
		addMorph: button
		fixedWidth: self defaultHeight! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:20:11'!
                       removeButtonFor: aMorph

	(self buttonFor: aMorph) ifNotNil: [ :b |
		b delete ]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:49:21'!
      restoreAll
	viewBox ifNotNil: [
		viewBox submorphs do: [ :button | 
			button model showAndComeToFront ]	]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:23:09'!
           wasCollapsed: aMorph
	"Add a button for aMorph if not already there (see #taskbarIncludesAllWindows)"

	(self buttonFor: aMorph) ifNil: [
		self addButtonFor: aMorph ]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:25:27'!
               wasDeleted: aMorph
	"aMorph was deleted. Remove button for aMorph"

	self removeButtonFor: aMorph! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:19:22'!
                     wasMadeVisible: aMorph
	"aMorph is now visible. Remove button for aMorph if appropriate (see #taskbarIncludesAllWindows)"

	Preferences taskbarIncludesAllWindows ifFalse: [
		self removeButtonFor: aMorph ]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:21:15'!
         wasOpened: aMorph
	"aMorph was added to the world. Add button for aMorph if appropriate (see #taskbarIncludesAllWindows)"
	
	Preferences taskbarIncludesAllWindows ifTrue: [
		self addButtonFor: aMorph ]! !
!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/15/2017 18:57:58'!
delete

	| w |
	self restoreAll.
	super delete.
	w _ self world ifNil: [ self runningWorld ].
	Display removeActionsWithReceiver: self.
	w ifNotNil: [ w taskbarDeleted ]! !
!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/16/2017 09:52:23'!
 noteNewOwner: aMorph
	"I have just been added as a submorph of aMorph"
	super noteNewOwner: aMorph.
	Preferences taskbarIncludesAllWindows ifTrue: [
		aMorph submorphsDo: [ :m |
			m == self ifFalse: [
				self addButtonFor: m ]]].
	self notifyDisplayResize! !
!TaskbarMorph methodsFor: 'menus' stamp: 'jmv 1/15/2017 19:14:11'!
                        handlesMouseDown: aMouseButtonEvent

	^ true! !
!TaskbarMorph methodsFor: 'menus' stamp: 'jmv 1/15/2017 19:10:57'!
             mouseButton2Activity

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	menu
		addLine;
		add: 'Normal Height' action: #scaleNormal;
		add: 'Scale x 2' action: #scaleX2;
		add: 'Scale x 4' action: #scaleX4.
	menu popUpInWorld! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:01:25'!
                   scale: anInteger

	(anInteger between: 1 and: 4) ifFalse: [ self error: 'scale should be 1 2 or 4' ].
	scale := anInteger.
	self screenSizeChanged. "rescale self"
	viewBox ifNotNil: [ "rescale buttons"
		viewBox submorphs do: [ :button | 
			button layoutSpec fixedWidth: self defaultHeight
		]
	]! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:49'!
               scaleNormal

	self scale: 1! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:52'!
                             scaleX2

	self scale: 2! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:55'!
 scaleX4

	self scale: 4! !
!TaskbarMorph class methodsFor: 'system startup' stamp: 'jmv 1/8/2017 16:47:17'!
                    initClassCachedState

	"Should use some other way to find relevant instances"
	self flag: #jmvVer2.
	self allInstancesDo: [ :each |
		each notifyDisplayResize ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 1/15/2017 18:24:25' prior: 16874345!
              visible: aBoolean
	"set the 'visible' attribute of the receiver to aBoolean"

	self visible == aBoolean
		ifTrue: [ ^ self ].
	aBoolean ifFalse: [
		self redrawNeeded ].
	self setProperty: #visible toValue: aBoolean.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	aBoolean ifTrue: [
		self redrawNeeded.
		self taskbar ifNotNil: [ :tb |
			tb wasMadeVisible: self ]]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 1/15/2017 14:58:58' prior: 16875692!
                               comeToFrontAndAddHalo
	self show.
	self comeToFront.
	self addHalo! !
!Morph methodsFor: 'menus' stamp: 'jmv 1/15/2017 18:24:40' prior: 16876276!
              collapse
	"If taskbar not visible, just hide."

	self hide.
	self taskbar
		ifNotNil: [ :tb | tb wasCollapsed: self ]! !
!Morph methodsFor: 'menus' stamp: 'jmv 1/15/2017 14:59:12' prior: 16876281!
                           expand
	
	self show.
	self comeToFront! !
!Morph methodsFor: 'testing' stamp: 'jmv 1/15/2017 15:04:18' prior: 16876985!
        isCollapsed

	^ self visible not! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 1/8/2017 16:44:57' prior: 16887743!
    allNonWindowRelatedSubmorphs
	"Answer all non-window submorphs that are not flap-related"

	^submorphs 
		reject: [ :m | (m is: #SystemWindow) or: [ m is: #TaskbarMorph ] ]! !
!PasteUpMorph methodsFor: 'taskbar' stamp: 'jmv 1/15/2017 14:43:48' prior: 16887920!
                           showTaskbar

	taskbar ifNil: [
		taskbar _ TaskbarMorph newRow.
		taskbar openInWorld: self ]! !
!StringMorph methodsFor: 'geometry' stamp: 'jmv 1/15/2017 14:22:53' prior: 16918181!
          measureContents
	| f |
	f _ self fontToUse.
	^((f widthOfString: contents) max: 3)  @ f height! !

TaskbarMorph removeSelector: #intoWorld:!

PasteUpMorph removeSelector: #isCollapsed:!

PasteUpMorph removeSelector: #isCollapsed:!

PasteUpMorph removeSelector: #minimize:!

PasteUpMorph removeSelector: #minimize:!

PasteUpMorph removeSelector: #restore:!

PasteUpMorph removeSelector: #restore:!

PasteUpMorph removeSelector: #taskbar:!

PasteUpMorph removeSelector: #taskbar:!

PasteUpMorph allInstancesDo: [ :w | w showTaskbar ]!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3036-NewTaskbar-JuanVuletich-2017Jan16-10h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3036] on 17 January 2017 at 11:13:18 am'!
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 1/17/2017 10:51:52'!
                          initialExtent
	^ RealEstateAgent standardWindowExtent * 3 // 2! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 1/17/2017 11:12:27' prior: 16898269!
                    maximumUsableAreaInWorld: aWorldOrNil

	| allowedArea |
	allowedArea _ Display boundingBox.
	aWorldOrNil ifNotNil: [
		allowedArea _ allowedArea intersect: aWorldOrNil viewBox.
		aWorldOrNil taskbar ifNotNil: [ :tb |
			allowedArea _ (allowedArea areasOutside: tb morphBoundsInWorld) first ]].
	^allowedArea
! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 1/17/2017 11:00:35' prior: 16887247!
                  privateExtent: newExtent

	^ (super privateExtent: newExtent)
		ifTrue: [
			self buildMagnifiedBackgroundImage.
			worldState clearCanvas ]; yourself! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 1/17/2017 10:56:23' prior: 16887422!
           viewBox

	^ worldState
		ifNotNil: [
			 0@0 extent: extent ]
		ifNil: [
			self world viewBox ]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 1/17/2017 11:05:24' prior: 16887834!
   restoreMorphicDisplay
	DisplayScreen startUp.
	self
		morphExtent: Display extent;
		handsDo: [ :h | h visible: true ];
		fullRepaintNeeded.
	WorldState addDeferredUIMessage: [ Cursor normal activateCursor ]! !
!PasteUpMorph class methodsFor: 'instance creation' stamp: 'jmv 1/17/2017 11:04:44' prior: 16887959!
        newWorld
	"
[
	ProjectX stopUIProcess.
	ProjectX spawnNewMorphicProcessFor: PasteUpMorph newWorld
] fork.
	"
	| w ws |
	w _ self new.
	ws _ WorldState new.
	w worldState: ws.
	w morphPosition: 0@0 extent: Display extent.
	ws setCanvas: Display getCanvas.
	w borderWidth: 0.
	ws handsDo: [ :h |
		h privateOwner: w ].
	^w! !
!WorldState methodsFor: 'canvas' stamp: 'jmv 1/17/2017 10:57:47' prior: 16945711!
          ensureNonDisplayCanvas
	(canvas isNil or: [
		canvas drawsOnDisplay or: [
		(canvas extent ~= world morphExtent) or: [
		canvas form depth ~= Display depth]]]) ifTrue: [
			"allocate a new offscreen canvas the size of the window"
			self setCanvas: (BitBltCanvas withExtent: world morphExtent depth: Display depth)]! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 1/17/2017 11:05:18' prior: 16946039!
         tryDeferredUpdatingAndSetCanvasFor: aWorld
        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, set a non-Disply canvas and answer false.."
	| properDisplay |
	
	"As this is the only sender of #deferUpdates: , this could be done in Morphic or image startup, and never efterwards..."
	(Display deferUpdates: true) ifNil: [
		"deferred updates not supported by the VM, do them in the image!!"
		self ensureNonDisplayCanvas.
		^ false].
	
	"if no canvas, or canvas was offscreen, from a platform that didnt support defers, then fix it"
	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].
	properDisplay ifFalse: [
		aWorld morphPosition: 0@0 extent: Display extent.
		self setCanvas: Display getCanvas.
	].
	^ true! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 7/28/2015 08:35' prior: 16946090!
                  displayWorld: aWorld submorphs: submorphs
	"Update this world's display."

	| deferredUpdateVMMode worldDamageRects handsToDraw allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"
	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvasFor: aWorld.

	"repair world's damage on canvas"
	worldDamageRects _ self drawInvalidAreasWorld: aWorld submorphs: submorphs.

	"Check which hands need to be drawn (they are not the hardware mouse pointer)"
	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.
	allDamage _ Array streamContents: [ :strm |
		strm nextPutAll: worldDamageRects.
		handsToDraw do: [ :h | 
			h savePatchFrom: canvas appendDamageTo: strm ]].

	"Draw hands (usually carying morphs) onto world canvas"
	canvas newClipRect: nil.
	handsToDraw reverseDo: [ :h | canvas fullDrawHand: h ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		"Drawing was done to off-Display canvas. Copy content to Display"
		canvas showAt: aWorld viewBox origin invalidRects: allDamage ].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	Display forceDamageToScreen: allDamage.

	"Restore world canvas under hands and their carried morphs"
	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].! !

WorldState removeSelector: #viewBox!

WorldState removeSelector: #viewBox!

WorldState removeSelector: #viewBox:!

WorldState removeSelector: #viewBox:!

DebuggerWindow removeSelector: #initialFrameIn:!

DebuggerWindow removeSelector: #initialFrameIn:!

PasteUpMorph removeSelector: #viewBox:!

PasteUpMorph removeSelector: #viewBox:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3037-WindowsAvoidTaskbarArea-JuanVuletich-2017Jan17-10h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3037] on 18 January 2017 at 10:36:09 am'!
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/18/2017 10:34:55' prior: 50337249!
                  addButtonFor: aMorph

	| button |
	aMorph == self ifFalse: [
		button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #showAndComeToFront.
		button
			color: self color;
			icon: (aMorph imageForm: 32);
			setBalloonText: aMorph label.
		viewBox
			addMorph: button
			fixedWidth: self defaultHeight ]! !
!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/18/2017 10:35:05' prior: 50337312!
                      noteNewOwner: aMorph
	"I have just been added as a submorph of aMorph"
	super noteNewOwner: aMorph.
	Preferences taskbarIncludesAllWindows ifTrue: [
		aMorph submorphsDo: [ :m |
			self addButtonFor: m ]].
	self notifyDisplayResize! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3038-TaskbarTweaks-JuanVuletich-2017Jan18-10h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3038] on 18 January 2017 at 7:35:13 pm'!
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:20:57'!
   fileMatching: pattern
"
	DirectoryEntry smalltalkImageDirectory fileMatching: '*.image'.
	DirectoryEntry smalltalkImageDirectory fileMatching: 'x*.image'.
"
	self filesDo: [ :file |
		(pattern match: file name)
			ifTrue: [ ^ file ]].
	^ nil! !
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:13:59' prior: 16834484!
                directoriesDo: aBlock
	self childrenDo: [ :each |
		each isFile ifFalse: [
			aBlock value: each ]]! !
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:19:42' prior: 16834701!
                              directoryMatching: pattern
"
	DirectoryEntry smalltalkImageDirectory directoryMatching: 'C*Pack*'.
	DirectoryEntry smalltalkImageDirectory directoryMatching: 'xC*Pack*'.
"
	self directoriesDo: [ :directory |
		(pattern match: directory name)
			ifTrue: [ ^ directory ]].
	^ nil! !
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:14:17' prior: 16834493!
            filesDo: aBlock
	self childrenDo: [ :each |
		each isFile ifTrue: [
			aBlock value: each ]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3039-DirectoryEntryTweaks-JuanVuletich-2017Jan18-19h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3039] on 18 January 2017 at 10:26:44 pm'!
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/18/2017 22:25:29' prior: 50337610!
                           addButtonFor: aMorph

	| button |
	aMorph == self ifFalse: [
		button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #showAndComeToFront.
		button
			color: self color;
			icon: (aMorph imageForm: 32);
			setBalloonText: aMorph label.
		button icon: button magnifiedIcon.
		viewBox
			addMorph: button
			fixedWidth: self defaultHeight ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3040-DontWasteMemoryOnTaskbarButtons-JuanVuletich-2017Jan18-22h26m-jmv.1.cs.st----!

----SNAPSHOT----#(18 January 2017 10:35:08.449455 pm) Cuis5.0-3040-spur.image priorSource: 83152!

----QUIT----#(18 January 2017 10:35:21.576339 pm) Cuis5.0-3040-spur.image priorSource: 193704!

----STARTUP----#(20 February 2017 12:21:53.409414 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3040-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3040] on 22 January 2017 at 9:33:48 pm'!
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 1/22/2017 21:17:32' prior: 50337465!
    privateExtent: newExtent

	^ (super privateExtent: newExtent)
		ifTrue: [
			self buildMagnifiedBackgroundImage.
			worldState ifNotNil: [
				worldState clearCanvas ]];
		yourself! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 1/22/2017 21:25:10' prior: 16926091!
                   drawOn: aCanvas

	| titleColor roundCorners |

	titleColor _ self widgetsColor.
	self isTopWindow
		ifTrue: [ titleColor _ titleColor lighter ].

	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			"Round corners. Optional title gradient."
			self drawRoundedFrameOn: aCanvas color: titleColor ]
		ifFalse: [
			"No round corners. No title gradient."
			self drawClassicFrameOn: aCanvas color: titleColor ].
	Theme current minimalWindows
		ifFalse: [
			labelString ifNotNil: [self drawLabelOn: aCanvas]]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 1/22/2017 21:31:40' prior: 16866779!
                       popUpInWorld: aWorld
	"Present this menu under control of the given hand."
	"Needed if not the real world but an inner PasteUpMorph"
	| positionInWorld |
	positionInWorld _ aWorld internalizeFromWorld: aWorld activeHand morphPosition.
	^self
		popUpAt: positionInWorld
		forHand: aWorld activeHand
		in: aWorld
! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3041-Fix-clearCanvas-DNU-JuanVuletich-2017Jan22-21h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 3 December 2016 at 9:04:32 am'!
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:13'!
                          montgomeryDigitBase
	"Answer the base used by Montgomery algorithm."
	^1 << self montgomeryDigitLength! !
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:27'!
                        montgomeryDigitLength
	"Answer the number of bits composing a digit in Montgomery algorithm.
	Primitive use either 8 or 32 bits digits"
	<primitive: 'primMontgomeryDigitLength' module:'LargeIntegers'>
	^8 "Legacy plugin which did not have this primitive did use 8 bits digits"! !
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:14'!
          montgomeryDigitMax
	"Answer the maximum value of a digit used in Montgomery algorithm."
	
	^1 << self montgomeryDigitLength - 1! !
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:16'!
                               montgomeryNumberOfDigits
	"Answer the number of montgomery digits required to represent the receiver."
	^self digitLength * 8 + (self montgomeryDigitLength - 1) // self montgomeryDigitLength! !
!Integer methodsFor: 'mathematical functions' stamp: 'nice 1/16/2013 18:38' prior: 16859768!
 raisedTo: n modulo: m
	"Answer the modular exponential.
	Note: this implementation is optimized for case of large integers raised to large powers."
	| a s mInv |
	n = 0 ifTrue: [^1].
	(self >= m or: [self < 0]) ifTrue: [^self \\ m raisedTo: n modulo: m].
	n < 0 ifTrue: [^(self reciprocalModulo: m) raisedTo: n negated modulo: m].
	(n < 4096 or: [m even])
		ifTrue:
			["Overhead of Montgomery method might cost more than naive divisions, use naive"
			^self slidingLeftRightRaisedTo: n modulo: m].
	
	mInv := self montgomeryDigitBase - ((m bitAnd: self montgomeryDigitMax) reciprocalModulo: self montgomeryDigitBase).
 
	"Initialize the result to R=self montgomeryDigitModulo raisedTo: m montgomeryNumberOfDigits"
	a := (1 bitShift: m montgomeryNumberOfDigits * m montgomeryDigitLength) \\ m.
	
	"Montgomerize self (multiply by R)"
	(s := self montgomeryTimes: (a*a \\ m) modulo: m mInvModB: mInv)
		ifNil:
			["No Montgomery primitive available ? fallback to naive divisions"
			^self slidingLeftRightRaisedTo: n modulo: m].

	"Exponentiate self*R"
	a := s montgomeryRaisedTo: n times: a modulo: m mInvModB: mInv.

	"Demontgomerize the result (divide by R)"
	^a montgomeryTimes: 1 modulo: m mInvModB: mInv! !
!Integer methodsFor: 'testing' stamp: 'nice 11/14/2011 21:59' prior: 16860231!
                      isProbablyPrime
	"See isProbablyPrimeWithK:andQ: for the algoritm description."
	
	| k q |
	self <= 1 ifTrue: [ ^false ].
	self even ifTrue: [ ^self = 2 ].
	"Factor self into (2 raisedTo: k) * q + 1, where q odd"
	q := self bitShift: -1.
	k := q lowBit.
	q := q bitShift: 1 - k.
	"Repeat the probabilistic until false (the probability of false negative is null) or until probability is very low."
	25 timesRepeat: [ (self isProbablyPrimeWithK: k andQ: q) ifFalse: [ ^false ] ].
	"The probability of false positive after 25 iterations is less than (1/4 raisedTo: 25) < 1.0e-15"
	^true! !
!Integer methodsFor: 'private' stamp: 'nice 11/15/2011 23:13' prior: 16860590!
      isProbablyPrimeWithK: k andQ: q 
	"Algorithm P, probabilistic primality test, from
	Knuth, Donald E. 'The Art of Computer Programming', Vol 2,
	Third Edition, section 4.5.4, page 395, P1-P5 refer to Knuth description..
	Note that this is a Miller Rabin test which may answer false positives (known as pseudoprimes) for at most 1/4 of the possible bases x."

	| x j y minusOne |
	"P1"
	x := (self - 2) atRandom + 1.
	"P2"
	j := 0.
	y := x raisedTo: q modulo: self.
	minusOne := self - 1.
	
	["P3"
	y = 1 ifTrue: [^j = 0].
	y = minusOne ifTrue: [^true].
	"P4"
	(j := j + 1) < k]
		whileTrue:
			[y := y squared \\ self].
	"P5"
	^false! !
!Integer methodsFor: 'private' stamp: 'nice 1/16/2013 18:40' prior: 16860675!
                      montgomeryTimes: a modulo: m mInvModB: mInv
	"Answer the result of a Montgomery multiplication
	self * a * (b raisedTo: m montgomeryNumberOfDigits) inv \\ m
	NOTE: it is assumed that:
	self montgomeryNumberOfDigits <= m montgomeryNumberOfDigits
	a montgomeryNumberOfDigits <= m montgomeryNumberOfDigits
	mInv * m \\ b = (-1 \\ b) = (b-1) (this implies m odd)
	where b = self montgomeryDigitBase
	
	Answer nil in case of absent plugin or other failure."
	
	<primitive: 'primMontgomeryTimesModulo' module:'LargeIntegers'>
	^nil! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3042-MontgomeryExponentiationFix-LucianoEstebanNotarfrancesco-2016Nov29-21h10m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3042] on 22 January 2017 at 9:49:56 pm'!
!Integer methodsFor: 'arithmetic' stamp: 'len 12/4/2016 13:11:44'!
       reciprocalModulo2: n
	"Answer an integer x such that self * x \\ n = 1, with 0 < x < n, or nil if it doesn't exist."
	| xgcd |
	self == 0 ifTrue: [^ nil].
	self == 1 ifTrue: [^ 1].
	xgcd _ self xgcd: n.
	^ (xgcd at: 1) == 1 ifTrue: [^ (xgcd at: 2) \\ n]! !
!Integer methodsFor: 'arithmetic' stamp: 'len 12/4/2016 13:07:08'!
                            xgcd: anInteger
	"Extended Euclidean algorithm.
	Answer an array {x. u. v} where self * u + (anInteger * v) = x, and x = (self gcd: anInteger)."
	| a b s t sp tp r rp |
	a _ self. b _ anInteger.
	s _ 0. sp _ 1.
	t _ 1. tp _ 0.
	r _ a abs. rp _ b abs.
	[r == 0]
		whileFalse:
			[ | q temp |
			q _ rp // r.
			temp _ r. r _ rp - (q * r). rp _ temp.
			temp _ s. s _ sp - (q * s). sp _ temp.
			temp _ t. t _ tp - (q * t). tp _ temp].
	sp _ sp * b sign. tp _ tp * a sign.
	^ {rp. tp. sp}! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3043-Alternative-gcd-reciprocalModulo-LucianoEstebanNotarfrancesco-2017Jan22-21h46m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3043] on 16 February 2017 at 2:31:35 pm'!
!FileSystemEntry methodsFor: 'accessing-file name' stamp: 'jmv 2/16/2017 11:21:10' prior: 16843823!
       baseName
	^self fileAccessor baseNameFor: name! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3044-basename-fix-JuanVuletich-2017Feb16-11h21m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3044] on 17 February 2017 at 3:11:08 pm'!
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 2/17/2017 15:10:48' prior: 16888368!
          magnifiedIcon
	| factor magnifiedExtent w h |

	icon ifNil: [ ^nil ].
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		w _ icon width.
		h _ icon height.
		w*h = 0 ifFalse: [
			factor _ 1.0 * extent x / w min: 1.0 * extent y / h.
			(factor < 1 or: [ factor > 1.7 and: [self isRoundButton]]) ifTrue: [
				magnifiedExtent _ (icon extent * factor) rounded.
				magnifiedIcon _ icon magnifyTo: magnifiedExtent ]]].
	^magnifiedIcon! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3045-magnifiedIcon-fix-JuanVuletich-2017Feb17-15h10m-jmv.1.cs.st----!

----SNAPSHOT----#(20 February 2017 12:22:00.936181 pm) Cuis5.0-3045-spur.image priorSource: 193803!

----QUIT----#(20 February 2017 12:22:14.041134 pm) Cuis5.0-3045-spur.image priorSource: 202591!

----STARTUP----#(6 March 2017 10:37:07.905351 am) as C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\Cuis5.0-3045-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3042] on 10 February 2017 at 5:39:28 pm'!

Object subclass: #ProgessiveTestRunner
	instanceVariableNames: 'testSuite testsStream progressBar testResult testRunIncrement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #ProgessiveTestRunner category: #'Tools-Testing'!
Object subclass: #ProgessiveTestRunner
	instanceVariableNames: 'testSuite testsStream progressBar testResult testRunIncrement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!
!Browser methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:32:22'!
debugMethodTest
	
	currentCompiledMethod isTestMethod ifTrue: [
		currentCompiledMethod methodClass debugAsFailure: currentCompiledMethod selector ]
! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/4/2017 20:33:00'!
            runClassTests
	
	self selectedClassName ifNotNil: [ :aClassName | | selectedClass |
		selectedClass _ Smalltalk classNamed: aClassName.
		(ProgessiveTestRunner for: (TestSuite forClass: selectedClass)) value ]! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/7/2017 10:47:50'!
                runMessageCategoryTests
	
	selectedMessageCategory ifNotNil: [ | selectedClass suite |
		selectedClass _ Smalltalk classNamed: selectedClassName.
		suite _ TestSuite forMessageCategoryNamed: selectedMessageCategory of: selectedClass categorizedWith: classOrganizer.
		(ProgessiveTestRunner for: suite) value ]
	
	! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/4/2017 21:51:50'!
        runMethodTest
	
	| suite |
	
	suite _ TestSuite forCompiledMethod: currentCompiledMethod.
	(ProgessiveTestRunner for: suite) value 
	! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/1/2017 19:23:54'!
                            runSystemCategoryTests
	
	selectedSystemCategory ifNotNil: [ | suite |
		suite _ TestSuite forSystemCategoryNamed: selectedSystemCategory using: systemOrganizer.
		(ProgessiveTestRunner for: suite) value ]
	
	! !
!Behavior methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:55:50'!
               testCaseClass

	self subclassResponsibility ! !
!Behavior methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:55:40'!
                    withTestCaseClassDo: aFoundTestCaseClassBlock ifNone: aNoneBlock 
		
	| potentialTestCaseClass |
	
	potentialTestCaseClass _ self testCaseClass.
	
	^potentialTestCaseClass ifNil: aNoneBlock ifNotNil: aFoundTestCaseClassBlock 
	! !
!Class methodsFor: 'tdd' stamp: 'HAW 2/7/2017 10:42:40'!
testCaseClass
		
	| potentialTestCaseClass |
	
	potentialTestCaseClass _ Smalltalk classNamed: self name, 'Test'.
	
	^potentialTestCaseClass 
	
 ! !
!Metaclass methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:56:51'!
              testCaseClass

	^self soleInstance testCaseClass ! !
!Categorizer methodsFor: 'tdd' stamp: 'HAW 2/7/2017 09:06:13'!
            classesAt: aCategoryName

	^(self listAtCategoryNamed: aCategoryName) collect: [:aClassName | Smalltalk classNamed: aClassName ]
		! !
!Categorizer methodsFor: 'tdd' stamp: 'HAW 2/7/2017 09:06:34'!
                          testCaseClassesAt: aCategoryName

	^(self classesAt: aCategoryName) select: [ :aClass | aClass is: #TestCaseClass ]! !
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HAW 2/10/2017 16:03:46'!
                            acceptAndDebugTest: aKeyboardEvent 
	
	^self acceptAndDebugTest ! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:34:45'!
                        acceptAndDebugTest
	
	^self acceptAndWithMethodDo: [ :aPotencialTestMethod | 
		aPotencialTestMethod isTestMethod ifTrue: [ aPotencialTestMethod methodClass debugAsFailure: aPotencialTestMethod selector ]]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:34:38'!
           acceptAndWithMethodDo: aBlock
	
	| potencialTestMethod |
	
	self acceptContents ifFalse: [ ^false ].
	
	potencialTestMethod _ self codeProvider currentCompiledMethod.
	^potencialTestMethod 
		ifNil: [ false ]
		ifNotNil: [
			aBlock value: potencialTestMethod.
			true]! !
!ProgessiveTestRunner methodsFor: 'initialization' stamp: 'HAW 2/1/2017 19:20:06'!
                            initializeFor: aTestSuite

	testSuite _ aTestSuite.
	! !
!ProgessiveTestRunner methodsFor: 'evaluating' stamp: 'HAW 1/31/2017 11:50:37'!
                       value

	testsStream _ ReadStream on: testSuite tests.
	testsStream atEnd
		ifTrue: [ self informNoTestToRun ]
	 	ifFalse:[ self createProgressBarAndRun ]! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:22'!
       calculateTestRunIncrement
	
	testRunIncrement _ 1/testsStream size! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:31'!
                              createProgressBar
		
	progressBar _ ProgressMorph label: testSuite name.
	self calculateTestRunIncrement.
	self updateProgressBarSubLabel.
	! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:43'!
                    updateDoneIncrement 

 	progressBar incrDone: testRunIncrement 
	! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 11:10:25'!
                               updateProgressBarSubLabel

	testsStream atEnd ifFalse: [
		progressBar subLabel: testsStream next printString, ' (', testsStream position printString, '/', testsStream size printString, ')' ].! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 1/31/2017 20:05:25'!
 informAllTestPassed 
	
	PopUpMenu inform: testResult printString.
	! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 1/31/2017 10:05:21'!
                              informNoTestToRun
		
	 PopUpMenu inform: 'No test to run'! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 2/1/2017 19:26:08'!
         openTestResultForDebuggingAndInspection

	testResult forDebuggingAndInspection inspect ! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 1/31/2017 10:10:53'!
          showDeffects
	
	 | defects |
			
	defects _ 	testResult defects.
	defects size = 1
		ifTrue: [ defects anyOne debug ] 
		ifFalse: [ self openTestResultForDebuggingAndInspection]! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:14:08'!
                  createProgressBarAndRun

	self createProgressBar.
	[ self runSuiteShowingProgress ] fork! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:26:59'!
           registerTestSuiteAction
		
	testSuite when: #changed: send: #testRun: to: self! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 10:09:41'!
                    runSuite
		
	testResult _ testSuite run.	
	testResult hasPassed 
		ifTrue: [ self informAllTestPassed ] 
		ifFalse: [self showDeffects ]
	! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 11:47:58'!
                        runSuiteShowingProgress

	[ self registerTestSuiteAction. 
	progressBar openInWorld.
	self runSuite ] ensure: [
		self unregisterTestSuiteAction.
		WorldState addDeferredUIMessage: [progressBar dismissMorph] ].
	! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:19:28'!
               testRun: aTest

	self updateProgressBarSubLabel.
	self updateDoneIncrement 
	
		! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 10:04:32'!
                  unregisterTestSuiteAction
	
	testSuite releaseActionMap ! !
!ProgessiveTestRunner class methodsFor: 'instance creation' stamp: 'HAW 1/31/2017 09:37:34'!
       for: aTestSuite

	^self new initializeFor: aTestSuite! !
!TestCase class methodsFor: 'Instance Creation' stamp: 'HAW 2/10/2017 16:01:40'!
                      debugAsFailure: aSymbol

	^(self selector: aSymbol) debugAsFailure
			! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/4/2017 20:31:47'!
              forClass: aClass

	^(aClass is: #TestCaseClass) 
		ifTrue: [ self forTestCaseClass: aClass ]
		ifFalse: [ self forNoTestCaseClass: aClass ]
! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/4/2017 21:53:12'!
        forCompiledMethod: aCompiledMethod

	^aCompiledMethod isTestMethod 
		ifTrue: [ self forTestMethod: aCompiledMethod ]
		ifFalse: [ self forNoTestMethod: aCompiledMethod ]
	! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/1/2017 18:43:22'!
        forMessageCategoryNamed: aMessageCategoryName of: aClass categorizedWith: aClassOrganizer

	| suite |
	
	suite _ self named: aClass name, ' tests categorized under ',aMessageCategoryName.
	(aClassOrganizer listAtCategoryNamed: aMessageCategoryName) do: [ :selector |
		(aClass compiledMethodAt: selector) isTestMethod ifTrue: [ suite addTest: (aClass selector: selector) ]].
	
	^suite
	! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/7/2017 10:24:12'!
                  forSystemCategoryNamed: aCategoryName  using: aSystemOrganizer 

	| testCaseClasses |
	
	testCaseClasses _ aSystemOrganizer testCaseClassesAt: aCategoryName.
	
	^testCaseClasses isEmpty 
		ifTrue: [ self forClasses: (aSystemOrganizer classesAt: aCategoryName) named: aCategoryName, ' infered tests' ]
		ifFalse: [ self forTestCaseClasses: testCaseClasses named: aCategoryName, ' tests' ]
		
! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:25:51'!
   allTestCaseClassesReferencing: aClass

	^(aClass allCallsOn 
		collect: [ :aMethodReference | aMethodReference actualClass ]
		thenSelect: [ :aPotentialTestCaseClass | aPotentialTestCaseClass is: #TestCaseClass ]) asSet.! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:27:27'!
              allTestsSending: aSelector
	
	^(Smalltalk allCallsOn: aSelector) select: [:aMethodReference | 
		(aMethodReference actualClass is: #TestCaseClass) and: [aMethodReference compiledMethod isTestMethod ]].! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 09:08:23'!
 forClasses: classes named: name

	| suite |
	
	suite _ classes
		inject: (self named: name)
		into: [ :partialSuite :aClass | partialSuite addTests: (self forClass: aClass) tests ].
		
	^suite
		
! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:32:17'!
      forNoTestCaseClass: aClass 

	^aClass 
		withTestCaseClassDo: [ :aTestCaseClass | self forTestCaseClass: aTestCaseClass ]
		ifNone: [ self forReferencesToClass: aClass ]

! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 11:28:55'!
                               forNoTestMethod: aCompiledMethod 
	
	| allTestSenders testCaseClassesReferencingClass reducedTestSenders suite |
	
	allTestSenders _ self allTestsSending: aCompiledMethod selector.
	testCaseClassesReferencingClass _ aCompiledMethod methodClass 
		withTestCaseClassDo:  [:aTestCaseClass | Array with: aTestCaseClass ]
		ifNone: [ self allTestCaseClassesReferencing: aCompiledMethod methodClass ].
		
	reducedTestSenders _ allTestSenders select: [ :aMethodReference | testCaseClassesReferencingClass includes: aMethodReference actualClass ].
	reducedTestSenders isEmpty 
		ifTrue: [ suite _ self forClass: aCompiledMethod methodClass ]
		ifFalse: [ 
			suite _ self named: 'Tests senders of ', aCompiledMethod selector.
			reducedTestSenders do: [ :aMethodReference | suite addTest: (aMethodReference actualClass selector: aMethodReference selector)]].
	
	^suite! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:33:27'!
              forReferencesToClass: aClass 

	| testCaseClasses |
	
	testCaseClasses _ self allTestCaseClassesReferencing: aClass.
		
	^testCaseClasses 
		inject: (self named: aClass name, ' all test references')
		into: [ :suite :aTestCaseClass | aTestCaseClass addToSuiteFromSelectors: suite ]
	

! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:34:27'!
             forTestCaseClass: aTestCaseClass 

	| suite |
	
	suite _ aTestCaseClass buildSuite.
	suite name: aTestCaseClass name, ' tests'.
	
	^suite! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 09:04:48'!
 forTestCaseClasses: testCaseClasses named: aName

	| suite |
	
	suite _ testCaseClasses
		inject: (self named: aName) 
		into: [:partialSuite :aTestCaseClass | aTestCaseClass addToSuiteFromSelectors: partialSuite ].
		
	^suite! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/4/2017 21:53:22'!
        forTestMethod: aCompiledMethod
	
	| suite |
	
	suite _ self named: 'Test'.
	suite addTest: (aCompiledMethod methodClass selector: aCompiledMethod selector).
	
	^suite
		! !
!UndefinedObject methodsFor: 'class hierarchy' stamp: 'HAW 2/10/2017 17:37:23'!
   allSuperclassesUpTo: aSuperclass 

	self error: (self superclassNotValidErrorDescriptionFor: aSuperclass)! !
!UndefinedObject methodsFor: 'class hierarchy' stamp: 'HAW 2/10/2017 17:37:30'!
   superclassNotValidErrorDescriptionFor: aClass 

	^aClass name, ' not in superclasses chain'! !
!Behavior methodsFor: 'system-support' stamp: 'HAW 2/4/2017 20:51:10' prior: 16785122!
          allCallsOn
	"Answer a SortedCollection of all the methods that refer to me by name or 
	as part of an association in a global dict."
	"
	^ (Smalltalk
		allCallsOn: (Smalltalk associationAt: self theNonMetaClass name))
		, (Smalltalk allCallsOn: self theNonMetaClass name)
	"

	^ Smalltalk allCallsOn: self theNonMetaClass name! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 2/4/2017 20:49:09' prior: 16923905!
                             browseAllCallsOnClass: aClass
	"Create and schedule a message browser on each method that refers to 
	aClass. For example, Smalltalk browseAllCallsOnClass: Object."
	self
		browseMessageList: aClass allCallsOn asArray sort
		name: 'Users of class ' , aClass theNonMetaClass name
		autoSelect: aClass theNonMetaClass name.! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 18:51:22' prior: 50336080!
        acceptAndTest
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteOf: aMethod methodClass ].
	^true! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 18:50:41' prior: 50336086!
                         acceptAndTestAll
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteForCategoryOf: aMethod methodClass ].
	^true
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:34:52' prior: 50336093!
      acceptThenTestMethodAndSuite: aSuiteBuilder
	
	self acceptAndWithMethodDo: [ :aPotencialTestMethod |
		self runAndDebuggIfNecessary: aPotencialTestMethod.
		self runTestSuite: (aSuiteBuilder value: aPotencialTestMethod) ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 16:08:47' prior: 50336115!
           runAndDebuggIfNecessary: aPotencialTestMethod

	aPotencialTestMethod isTestMethod ifTrue: [
		aPotencialTestMethod methodClass debug: aPotencialTestMethod selector ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 19:19:02' prior: 50336123!
    runTestSuite: aTestSuite

	(ProgessiveTestRunner for: aTestSuite) value
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/5/2017 10:49:25' prior: 50336133!
                              testSuiteForCategoryOf: aClass

	^TestSuite forSystemCategoryNamed: aClass category using: SystemOrganization 
! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/5/2017 10:48:27' prior: 50336150!
                          testSuiteOf: aClass

	^TestSuite forClass: aClass
! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 2/10/2017 15:58:27' prior: 50336377!
                           cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$r	#acceptAndDebugTest:		'Saves method and debugs it')
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')
		#(		$l	#cancelEdits:						'Cancel')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$A	#argAdvance:						'Advance argument')
		#(		$D	#debugIt:							'Debut it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 2/10/2017 15:57:40' prior: 50336431!
          initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.										#openHelp}.
		#-.
		{'Do it (d)'.									#doIt}.
		{'Print it (p)'.									#printIt}.
		{'Inspect it (i)'.								#inspectIt}.
		{'Explore it (I)'.								#exploreIt}.
		{'Debug it (D)'.								#debugIt}.
		{'Profile it'.									#profileIt}.
		#-.
		{'Explain'.										#explain}.
		{'Browse it (b)'.								#browseIt}.
		{'Senders of it (n)'.							#sendersOfIt}.
		{'Implementors of it (m)'.					#implementorsOfIt}.
		{'References to it (N)'.						#referencesToIt}.
		#-.
		{'Method Strings with it (E)'.				#methodStringsContainingit}.
		{'Method Source with it'.					#methodSourceContainingIt}.
		{'Class Comments with it'.					#classCommentsContainingIt}.
		#-.
		{'Accept (s)'.									#acceptContents}.
		{'Cancel (l)'.									#cancelEdits}.
		{'Accept & Run Test in Class (t)'.			#acceptAndTest}.
		{'Accept & Run Test in Category (y)'.		#acceptAndTestAll}.
		{'Accept & Debug Test (r)'.					#acceptAndDebugTest}.
		#-.
		{'More...'.										#getMenu2}.
	}.
	menu2 _ SelectionMenu fromArray: {
		{'Find...(f)'.									#find}.
		{'Find Again (g)'.								#findAgain}.
		{'Use Selection for Find (j)'.				#setSearchString}.
		#-.
		{'Undo - multiple (z)'.						#undo}.
		{'Redo - multiple (Z)'.						#redo}.
		{'Undo / Redo history'.						#offerUndoHistory}.
		#-.
		{'Copy (c)'.									#copySelection}.
		{'Cut (x)'.										#cut}.
		{'Paste (v)'.									#paste}.
		{'Paste without Format'.						#pasteString}.
		{'Paste...'.									#pasteRecent}.
		#-.
		{'Toggle WordWrap'.						#wrapOnOff}.
		{'Set Font... (k)'.								#offerFontMenu}.
		{'Clear Font'.									#clearFont}.
		{'Set Default Font...'.						#offerDefaultFontMenu}.
		#-.
		{'More...'.										#getMenu}.
	}! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 1/31/2017 11:56:31' prior: 16813767!
        classListKey: aChar from: view 
	"Respond to a Command key.  I am a model with a list of classes and a 
	code pane, and I also have a listView that has a list of methods.  The 
	view knows how to get the list and selection."

	aChar == $r ifTrue: [^ model recent].
	aChar == $h ifTrue: [^ self browseHierarchy].
	aChar == $x ifTrue: [^ model removeClass].
	aChar == $t ifTrue: [^ model runClassTests ].
	
	^ self messageListKey: aChar from: view! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 2/10/2017 17:33:25' prior: 16813782!
 messageListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also
	have a listView that has a list of methods.  The view knows how to get
	the list and selection."

	| sel class |
	aChar == $D ifTrue: [^ model toggleDiffing].

	sel _ model selectedMessageName.
	aChar == $m ifTrue: [  "These next two put up a type in if no message selected"
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk].
	aChar == $n ifTrue: [
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk].

	"The following require a class selection"
	(class _ model selectedClassOrMetaClass) ifNil: [^ self ].
	aChar == $b ifTrue: [^ BrowserWindow fullOnClass: class selector: sel].
	aChar == $N ifTrue: [^ self browseClassRefs].
	aChar == $i ifTrue: [^ self methodHierarchy].
	aChar == $h ifTrue: [^ self browseHierarchy].
	aChar == $p ifTrue: [^ self browseFullProtocol].

	"The following require a method selection"
	sel ifNotNil: [
		aChar == $o ifTrue: [^ model fileOutMessage].
		aChar == $c ifTrue: [^ model copySelector].
		aChar == $v ifTrue: [^ self browseVersions].
		aChar == $O ifTrue: [^ self openSingleMessageBrowser].
		aChar == $x ifTrue: [^ model removeMessage].
		aChar == $t ifTrue: [^ model runMethodTest].
		aChar == $r ifTrue: [^ model debugMethodTest]]! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 2/7/2017 10:49:07' prior: 16813824!
                   systemCatListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."

	aChar == $f ifTrue: [^ self findClass].
	aChar == $x ifTrue: [^ model removeSystemCategory].
	aChar == $t ifTrue: [ ^model runSystemCategoryTests ].
	
	^ self classListKey: aChar from: view! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 11:32:21' prior: 16793212!
                       classListMenu
	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList: #(
		('browse full (b)'			browseMethodFull)
		('browse hierarchy (h)'		browseHierarchy)
		('browse protocol (p)'		browseFullProtocol)
		-
		('fileOut'					fileOutClass				''		model)
		-
		('show hierarchy'			hierarchy					''		model)
		('show definition'			editClass					''		model)
		('show comment'			editComment			''		model)
		-
		('inst var refs...'				browseInstVarRefs)
		('inst var defs...'			browseInstVarDefs)
		-
		('class var refs...'			browseClassVarRefs)
		('class vars'					browseClassVariables)
		('class refs (N)'				browseClassRefs)
		-
		('rename class ...'			renameClass				''		model)
		('copy class...'				copyClass				''		model)
		('remove class (x)'			removeClass				''		model)
		-
		('Run tests (t)'		runClassTests 	''	model)
		('more...'					offerShiftedClassListMenu)).
	^ aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 19:57:02' prior: 16793244!
                 messageCategoryMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.			"All the options are for the model."
	aMenu addList: #(
		('fileOut'							fileOutMessageCategories)
		-
		('reorganize'						editMessageCategories)
		('alphabetize'						alphabetizeMessageCategories)
		('remove empty categories'		removeEmptyCategories)
		('categorize all uncategorized'		categorizeAllUncategorizedMethods)
		('new category...'					addCategory)
		-
		('rename...'							renameCategory)
		('remove'							removeMessageCategory)
		-
		('Run tests'	runMessageCategoryTests)).
	^aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 2/10/2017 17:29:43' prior: 16793264!
messageListMenu
	"Answer the message-list menu"
	"Changed by emm to include menu-item for breakpoints"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList:#(
			('what to show...'				offerWhatToShowMenu)
                	('toggle break on entry'		toggleBreakOnEntry					''		model)
            	-
			('browse full (b)' 				browseMethodFull)
			('browse hierarchy (h)'			browseHierarchy)
			('browse method (O)'			openSingleMessageBrowser)
			('browse protocol (p)'			browseFullProtocol)
			-
			('fileOut'						fileOutMessage							''		model)
			-
			('senders of... (n)'				browseSendersOfMessages)
			('implementors of... (m)'			browseMessages)
			('inheritance (i)'					methodHierarchy)
			('versions (v)'					browseVersions)
			-
			('inst var refs...'					browseInstVarRefs)
			('inst var defs...'				browseInstVarDefs)
			('class var refs...'				browseClassVarRefs)
			('class variables'				browseClassVariables)
			('class refs (N)'					browseClassRefs)
			-
			('remove method (x)'			removeMessage							''		model)
			('Run test (t)'		runMethodTest 	'' 	model)
			('Debug test (r)'		debugMethodTest 	'' 	model)
			-
			('more...'						openShiftedMessageListMenu)).
	^ aMenu
! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 11:52:17' prior: 16793404!
                systemCategoryMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	self flag: #renameSystemCategory.	"temporarily disabled"
	aMenu addList: #(
		('find class... (f)'				findClass)
		('recent classes... (r)'		recent									''		model)
		-
		('browse all'				browseAllClasses)
		('browse'					openSystemCategoryBrowser)
		-
		('fileOut'					fileOutSystemCategory				''		model)
		-
		('reorganize'				editSystemCategories					''		model)
		('alphabetize'				alphabetizeSystemCategories		''		model)
		-
		('update'					updateSystemCategories				''		model)
		('add item...'				addSystemCategory					''		model)
"		('rename...'					renameSystemCategory				''		model)"
		('remove'					removeSystemCategory				''		model)
		-
		('move to top'				moveSystemCategoryTop				''		model)
		('move up'					moveSystemCategoryUp				''		model)
		('move down'				moveSystemCategoryDown			''		model)
		('move to bottom' 			moveSystemCategoryBottom			''		model)
		-
		('Run tests (t)'				runSystemCategoryTests  	''	model)).
	^aMenu! !
!Theme methodsFor: 'menus' stamp: 'HAW 2/10/2017 17:30:49' prior: 50336837!
                       miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history' 'code file contents' 'package file contents') -> #changesIcon.
		#('Install New Updates' 'update' 'turn on auto-update (a)' 'update list (u)' 'install code' 'fileIn entire file' 'install package') -> #updateIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' 'turn off auto-update (a)') -> #cancelIcon.
		#('debug...' 'Debug it (D)' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'restore all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor'  'basic text editor'  'unicode editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList' 'compress file') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner' 'Accept & Run Test in Class (t)' 'Accept & Run Test in Category (y)' 'Run tests (t)' 'Run tests' 'Run test (t)' 'Accept & Debug Test (r)' 'Debug test (r)') -> #weatherFewCloudsIcon.
		#('Font Sizes...' 'system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'All preferences...' 'what to show...' 'view as hex') -> #preferencesIcon.
		#('Editor keyboard shortcuts') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.		"currently unused, but a neat icon"
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set code author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'Profile it') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance') -> #instanceIcon.
		#('Use Selection for Find (j)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('smalltalk options' 'method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)' 'Toggle WordWrap') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)' 'More...') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...' 'Set Default Font...') -> #fontXGenericIcon.
		#('Clear Font') -> #newIcon.
		#('code file browser' 'package file browser') -> #findIcon.
	}! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 2/10/2017 17:37:41'!
                           should: aBlock raise: anExceptionalType withExceptionDo: assertionsBlock

	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalType withExceptionDo: assertionsBlock)
			! !
!TestCase methodsFor: 'Private' stamp: 'HAW 2/10/2017 17:38:10'!
    executeShould: aBlock inScopeOf: anExceptionType withExceptionDo: assertionsBlock

	^[aBlock value.
 	false] 
		on: anExceptionType
		do: [:exception | 
			assertionsBlock value: exception.
			exception sunitExitWith: true]! !
!TestCase class methodsFor: 'Testing' stamp: 'HAW 2/10/2017 16:32:10' prior: 50336183!
      is: aSymbol

	^self ~= TestCase 
		and: [ aSymbol == #TestCaseClass or: [ super is: aSymbol ]]! !
!TestCase class methodsFor: 'Testing' stamp: 'HAW 2/1/2017 19:35:57' prior: 16927731!
        shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^self ~= TestCase 
		and: [ self superclass isAbstract or: [self testSelectors isEmpty]]

"$QA Ignore:Sends system method(superclass)$"
			! !
!TestResultForDebuggingAndInspection methodsFor: 'printing' stamp: 'HAW 2/7/2017 10:51:56' prior: 50336200!
                 print: aCollectionOfTestCases startingWith: header on: aStream
	
	aCollectionOfTestCases do: [ :aTestCase |
		aStream 
			nextPutAll: header;
			space;
			nextPutAll: aTestCase class name;
			nextPutAll: ' debug: #';
			nextPutAll: aTestCase selector;
			newLine ]
		
		
	! !

TestSuite class removeSelector: #allTestCasesReferencing:!

TestSuite class removeSelector: #allTestReferencesTo:!

TestSuite class removeSelector: #allTestsReferencing:!

TestSuite class removeSelector: #from:using:!

TestSuite class removeSelector: #fromClass:!

TestSuite class removeSelector: #fromSystemCategoryNamed:using:!

ProgessiveTestRunner removeSelector: #initializeFor:informingResultUsing:!

ProgessiveTestRunner removeSelector: #initializeFor:showingTestPassedWith:!

ProgessiveTestRunner removeSelector: #showProgressBarAndRunSuite!

SmalltalkEditor removeSelector: #acceptAndWithTestMethodDo:!

SmalltalkEditor removeSelector: #flashWith:!

SmalltalkEditor removeSelector: #flashWith:!

SmalltalkEditor removeSelector: #flashWithGreen!

SmalltalkEditor removeSelector: #flashWithGreen!

Categorizer removeSelector: #testCasesAt:!

Class removeSelector: #withTestCaseClassDo:ifNone:!

Behavior removeSelector: #withTestClassDo:ifNone:!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3046-TestRunningHelpers-HernanWilkinson-2017Jan31-09h21m-HAW.5.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3046] on 1 March 2017 at 12:34:07 pm'!
!CodeFile methodsFor: 'change record types' stamp: 'jmv 3/1/2017 12:31:23' prior: 16808869!
                          doIt: chgRec
	"See senders of #doIt "
	| string |
	string := chgRec string.
	
	"Method classification spec"
	(string beginsWith: '(''') ifTrue: [
		^ doIts add: chgRec ].
		
	"Just for compatibility with Squeak, as Cuis always adds the #classDefinition change type marker in the files."
	('*ubclass:*instanceVariableNames:*classVariableNames:*poolDictionaries:*category:*'
		match: string) ifTrue:[^self classDefinition: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #classDefinition change type marker in the files."
	('* class*instanceVariableNames:*'
		match: string) ifTrue:[^self metaClassDefinition: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #methodRemoval: (or similar) change type marker in the files."
	('* removeSelector: *'
		match: string) ifTrue:[^self removedMethod: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #classComment change type marker in the files."
	('* comment:*'
		match: string) ifTrue:[^self msgClassComment: string with: chgRec].

	"Don't add these to a CodeFile. They will be added on save if needed."
	('* initialize'
		match: string) ifTrue:[^self]. "Initialization is done based on class>>initialize"

	('''From *'
		match: string) ifTrue:[^self possibleSystemSource: chgRec].
	doIts add: chgRec.! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3047-FileCodeBrowserFix-JuanVuletich-2017Mar01-12h33m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3047] on 2 March 2017 at 10:50:58 am'!

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph oldKeyboardFocus '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph oldKeyboardFocus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!MenuMorph commentStamp: '<historical>' prior: 16866262!
  Instance variables:
	defaultTarget 		<Object>					The default target for creating menu items
	selectedItem			<MenuItemMorph> 		The currently selected item in the receiver
	stayUp 				<Boolean>				True if the receiver should stay up after clicks!
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:47:30' prior: 16866663!
                         deleteIfPopUp: evt
	"Remove this menu from the screen if stayUp is not true."

	stayUp ifFalse: [ self delete ].
	evt ifNotNil: [ evt hand ifNotNil: [ :h | h releaseMouseFocus: self ]]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:48:01' prior: 16866680!
                   popUpAdjacentTo: rightOrLeftPointInWorld from: sourceItem
	"Present this menu at the given point under control of the given hand.
	Used mostly for submenus."

	| delta tryToPlace selectedOffset |
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld
			amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:48:31' prior: 16866709!
    popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	self runningWorld addMorphFront: self position: aPoint - (2 @ 8).
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastMouseEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:48:26' prior: 16866745!
       popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	self items isEmpty ifTrue: [ ^self ].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph]) 
		do: [ :m | m updateContents].
	aWorld addMorphFront: self position: aPoint - (2 @ 8).
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ]! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 3/2/2017 10:47:45' prior: 16866819!
                     keyStroke: aKeyboardEvent 
	| matchString char asc selectable |
	char := aKeyboardEvent keyCharacter.
	asc := char numericValue.
	aKeyboardEvent isReturnKey
		ifTrue: [
			selectedItem ifNotNil: [
					selectedItem hasSubMenu 
						ifTrue: [
							aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
							^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
						ifFalse: [
							"self delete."
							^selectedItem invokeWithEvent: aKeyboardEvent]].
			(selectable := self items) size = 1 
				ifTrue: [^selectable first invokeWithEvent: aKeyboardEvent].
			^self].
	asc = 27 
		ifTrue: [
			"escape key"
			self
				valueOfProperty: #matchString
				ifPresentDo: [ :str | 
					str isEmpty 
						ifFalse: [
							"If filtered, first ESC removes filter"
							self setProperty: #matchString toValue: String new.
							self selectItem: nil.
							^self displayFiltered: aKeyboardEvent]].
			"If a stand-alone menu, just delete it"
			^self delete].
	(asc = 28 or: [asc = 29]) 
		ifTrue: [
			"left or right arrow key"
			(selectedItem notNil and: [selectedItem hasSubMenu]) 
				ifTrue: [
					aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
					selectedItem subMenu moveSelectionDown: 1 event: aKeyboardEvent.
					^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]].
	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: aKeyboardEvent].	"up arrow key"
	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: aKeyboardEvent].	"down arrow key"
	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: aKeyboardEvent].	"page up key"
	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: aKeyboardEvent].	"page down key"
	matchString := self valueOfProperty: #matchString ifAbsent: [String new].
	matchString := char = Character backspace 
				ifTrue: [
					matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]
				ifFalse: [matchString copyWith: aKeyboardEvent keyCharacter].
	self setProperty: #matchString toValue: matchString.
	self displayFiltered: aKeyboardEvent! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 3/2/2017 10:47:57' prior: 16866952!
                    handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	| eventPositionInOurCoordinates |
	eventPositionInOurCoordinates _ self internalizeFromWorld: aMorphicEvent eventPosition.

	self dispatchEvent: aMorphicEvent localPosition: eventPositionInOurCoordinates.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]]! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 3/2/2017 10:47:34' prior: 16867015!
             initialize
	super initialize.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 3/2/2017 10:45:33' prior: 16866023!
                               mouseEnter: evt
	"The mouse entered the receiver"
	owner ifNil: [ ^self ].
	owner selectItem: self! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 3/2/2017 10:36:12' prior: 16866139!
   deselect

	self isSelected: false.
	subMenu ifNotNil: [
		self removeAlarm: #deselectTimeOut ]! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 3/2/2017 10:36:17' prior: 16866151!
       select
	self isSelected: true.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphBoundsInWorld topRight + (10@0)
									with: self morphBoundsInWorld topLeft)
			from: self.
		subMenu selectItem: nil ]! !

MenuItemMorph removeSelector: #activateOwnerMenu:!

MenuItemMorph removeSelector: #activateOwnerMenu:!

MenuMorph removeSelector: #activeSubmenu:!

MenuMorph removeSelector: #activeSubmenu:!

MenuMorph removeSelector: #delete!

MenuMorph removeSelector: #delete!

MenuMorph removeSelector: #popUpOwner!

MenuMorph removeSelector: #popUpOwner!

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3048-MenuSimplification-JuanVuletich-2017Mar02-10h45m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3048] on 2 March 2017 at 4:11:32 pm'!
!Transcripter class methodsFor: 'instance creation' stamp: 'dhn 2/6/2017 13:38:40' prior: 16938922!
        newInFrame: frame
"
(Transcripter newInFrame: (0@0 extent: 100@200))
	nextPutAll: 'Hello there'; endEntry;
	newLine; print: 355.0/113; endEntry;
	readEvalPrint.
"
	| transcript |
	transcript _ self on: (String new: 100).
	transcript initInFrame: frame.
	^ transcript clear! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3049-TranscripterCommentFix-DanNorton-2017Mar02-16h10m-dhn.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:17:59 am'!
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:35:58'!
                cleanseStepList
	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."

	| deletions morphToStep |
	deletions _ nil.
	stepList do: [:entry |
		morphToStep _ entry receiver.
		morphToStep world == world ifFalse:[
			deletions ifNil: [deletions _ OrderedCollection new].
			deletions addLast: entry]].

	deletions ifNotNil:[
		deletions do: [:entry|
			self stopSteppingMorph: entry receiver]].

	self alarms copy do:[:entry|
		morphToStep _ entry receiver.
		((morphToStep is: #Morph) and: [ morphToStep world == world ]) 
			ifFalse: [ self removeAlarm: entry selector for: entry receiver ]].! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:42:28'!
      runStepMethods
	"Perform periodic activity inbetween event cycles"
	| queue msg |

	queue _ self class deferredUIMessages.
	[ (msg _ queue nextOrNil) isNil ] whileFalse: [
		msg value
	].
	self runLocalStepMethods.

	"we are using a normal #step for these now"
	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."
! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:34:41'!
              displayWorldSafely
	"Update this world's display and keep track of errors during draw methods."

	[world displayWorld] ifError: [:err :rcvr |
		"Handle a drawing error"
		| errCtx errMorph |
		errCtx _ thisContext.
		[
			errCtx _ errCtx sender.
			"Search the sender chain to find the morph causing the problem"
			[errCtx notNil and: [ (errCtx receiver is: #Morph) not ]] 
				whileTrue:[errCtx _ errCtx sender].
			"If we're at the root of the context chain then we have a fatal drawing problem"
			errCtx ifNil:[^self handleFatalDrawingError: err].
			errMorph _ errCtx receiver.
			"If the morph causing the problem has already the #drawError flag set,
			then search for the next morph above in the caller chain."
			errMorph isKnownFailing
		] whileTrue.
		errMorph drawingFails.
		self clearCanvas.
		"Install the old error handler, so we can re-raise the error"
		rcvr error: err.
	]! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:34:09'!
                         doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < 200				"No events processed? Start saving CPU!! But never make the user wait more than 200ms for being responsive again."
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time localMillisecondClock ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 0 ifTrue: [
		waitDelay beingWaitedOn
			ifFalse: [ waitDelay setDelay: wait; wait ]
			ifTrue: [
				"If we are called from a different process than that of the main UI, we might be called in the main
				interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
				(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:34:47'!
                doOneCycleNow
	"Immediately do one cycle of the interaction loop.
	This should not be called directly, but only via doOneCycleFor:"

	| hadAnyEvent |
	"See #eventTickler"
	Cursor currentCursor = Cursor wait ifTrue: [
		Cursor normal activateCursor ].

	"Repair visual damage."
	DisplayScreen checkForNewScreenSize.
	self displayWorldSafely.

	"Run steps, alarms and deferred UI messages"
	world runStepMethods.

	"Process user input events. Run all event triggered code."
	hadAnyEvent _ false.
	self handsDo: [ :h |
		activeHand _ h.
		hadAnyEvent _ hadAnyEvent | h processEventQueue.
		activeHand _ nil ].

	"The default is the primary hand"
	activeHand _ self hands first.


	^hadAnyEvent! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:43:12'!
   tryDeferredUpdatingAndSetCanvas
        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, set a non-Disply canvas and answer false.."
	| properDisplay |
	
	"As this is the only sender of #deferUpdates: , this could be done in Morphic or image startup, and never efterwards..."
	(Display deferUpdates: true) ifNil: [
		"deferred updates not supported by the VM, do them in the image!!"
		self ensureNonDisplayCanvas.
		^ false].
	
	"if no canvas, or canvas was offscreen, from a platform that didnt support defers, then fix it"
	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].
	properDisplay ifFalse: [
		world morphPosition: 0@0 extent: Display extent.
		self setCanvas: Display getCanvas.
	].
	^ true! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:43:18'!
            displayWorldAndSubmorphs: submorphs
	"Update this world's display."

	| deferredUpdateVMMode worldDamageRects handsToDraw allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"
	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvas.

	"repair world's damage on canvas"
	worldDamageRects _ self drawInvalidAreasSubmorphs: submorphs.

	"Check which hands need to be drawn (they are not the hardware mouse pointer)"
	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.
	allDamage _ Array streamContents: [ :strm |
		strm nextPutAll: worldDamageRects.
		handsToDraw do: [ :h | 
			h savePatchFrom: canvas appendDamageTo: strm ]].

	"Draw hands (usually carying morphs) onto world canvas"
	canvas newClipRect: nil.
	handsToDraw reverseDo: [ :h | canvas fullDrawHand: h ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		"Drawing was done to off-Display canvas. Copy content to Display"
		canvas showAt: world viewBox origin invalidRects: allDamage ].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	Display forceDamageToScreen: allDamage.

	"Restore world canvas under hands and their carried morphs"
	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:40:12'!
        drawInvalidAreasSubmorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |

	"The simple implementation is slowers as it draws morph areas that will later be covered by other morphs.
	But it works, and it is easier to understand.
	See en.wikipedia.org/wiki/Painter's_algorithm"
	true not ifTrue: [ ^self simpleDrawInvalidAreasSubmorphs: submorphs ].

	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.

	"The idea here is to iterate morphs front to back, i.e. first the ones on top.
	For each morph, record the rectangles it affects. And if a morph is opaque, remove the area behind it from the list of rectangles to be repaired.
	This means, for example, that morphs completely covered might even not be redrawn.
	this is a huge performance gain when there are many morphs on screen, especially if there are more than ten open windows, and Theme uses opaque colors.
	See 'A reverse painter's algorithm' at en.wikipedia.org/wiki/Painter's_algorithm"
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ world fillRects: initialRectsToRepair color: Color gray ].

	"Draw world background on those areas that were not completely covered by opaque morphs"
	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			world drawOn: (canvas newClipRect: r) ]].

	"Now, draw the recorded areas of selected morphs, back to front."
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could think about merging all xrects into just one call...
		This would mean drawing each morph just once.
		But that would mean drawing pixels we were not told to. There could be other morphs in that area that are not even being drawn!!
		See WorldState class >> #experiment1"
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			(canvas newClipRect: r) fullDraw: m.
		].
"		(canvas newClipRect: rr) fullDraw: m"
		"*make this true to flash damaged areas for testing*"
		Preferences debugShowDamage2 ifTrue: [
			world flashRects: xrects color: Color random ].
	].

	"Answer a list of rectangles to be updated on the Display.
	This usually is not performance critical, drawing morphs is slower than just exposing the Display."
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:39:56'!
    simpleDrawInvalidAreasSubmorphs: submorphs

	"mover todo esto al canvas, no?
	Y ver que hacer con los argumentos, etc.... Toda esta bananarama!!"

	"Redraw the damaged areas of the given canvas and clear the damage list.
	Return a collection of the areas that were redrawn.
	This simple implementation just does as requested: No optimizations are done."

	| rectsToRepair morphBounds |
	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	rectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.

	"Draw World"
	rectsToRepair do: [ :r |
		world drawOn: (canvas newClipRect: r) ].

	"Draw morphs"
	submorphs reverseDo: [ :morph |
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			rectsToRepair do: [ :r |
				(morphBounds intersects: r) ifTrue: [
					(canvas newClipRect: r) fullDraw: morph ]]]].

	^ rectsToRepair! !
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/2/2017 21:47:15'!
         runLocalStepMethods
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| now morphToStep scheduledTime |
	now _ lastCycleTime.
	self triggerAlarmsBefore: now.
	stepList isEmpty 
		ifTrue: [ ^self].
	[ stepList isEmpty not and: [ stepList first scheduledTime <= now ]] 
		whileTrue: [
			lastStepMessage _ stepList removeFirst.
			morphToStep _ lastStepMessage receiver.
			(morphToStep shouldGetStepsFrom: world) 
				ifTrue: [
					scheduledTime _ lastStepMessage scheduledTime.
					lastStepMessage valueAtTime: now - scheduledTime + lastStepMessage stepTime.
					lastStepMessage ifNotNil: [
							lastStepMessage scheduledTime: (scheduledTime + lastStepMessage stepTime max: now + 1).
							stepList add: lastStepMessage ]].
			lastStepMessage _ nil ]! !
!PasteUpMorph methodsFor: 'interaction loop' stamp: 'jmv 3/2/2017 19:34:01' prior: 16887286!
 doOneCycleNow
	"see the comment in doOneCycleNowFor:
	Only used for a few tests."
	worldState doOneCycleNow! !
!PasteUpMorph methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:36:23' prior: 16887443!
                            cleanseStepList
	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."

	worldState cleanseStepList! !
!PasteUpMorph methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:42:32' prior: 16887451!
 runStepMethods

	worldState runStepMethods! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:34:54' prior: 16887760!
                          displayWorldSafely

	worldState displayWorldSafely
! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:33:20' prior: 16887765!
                 doOneCycle
	"see the comment in WorldState >> doOneCycle"

	worldState doOneCycle! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:37:11' prior: 16887829!
                   privateOuterDisplayWorld

	worldState displayWorldAndSubmorphs: submorphs
! !
!WorldState class methodsFor: 'sample code' stamp: 'jmv 3/2/2017 19:39:21' prior: 16946320!
                      experiment1
	"To play with and learn about morphic Display update logic.
	Remove the morphs when done!!"
	"
	WorldState experiment1
	"
	| dr morph1 morph2 s w |
	morph1 _ RectangleLikeMorph new openInWorld.
	morph2 _ RectangleLikeMorph new openInWorld.
	morph2 color: Color green.
	morph2 morphPosition: 200@800 extent: 50@40.
	morph1 morphPosition: 120@720 extent: 220@100.

	w _ self runningWorld.
	s _ w instVarNamed: 'worldState'.
	dr _ s instVarNamed: 'damageRecorder'.

	dr doFullRepaint.
	dr reset;
	"	recordInvalidRect: (100@700 corner: 400@900);"
		recordInvalidRect: (100@700 corner: 150@900);
		recordInvalidRect: (300@700 corner: 400@900).
	Display fillColor: Color gray.
	"Do not draw the area used by the small rectangle, unless it is also drawn!!"
	s drawInvalidAreasSubmorphs: {morph1. morph2 }! !

WorldState removeSelector: #cleanseStepListForWorld:!

WorldState removeSelector: #cleanseStepListForWorld:!

WorldState removeSelector: #displayWorld:submorphs:!

WorldState removeSelector: #displayWorld:submorphs:!

WorldState removeSelector: #displayWorldSafely:!

WorldState removeSelector: #displayWorldSafely:!

WorldState removeSelector: #doOneCycleFor:!

WorldState removeSelector: #doOneCycleFor:!

WorldState removeSelector: #doOneCycleNowFor:!

WorldState removeSelector: #doOneCycleNowFor:!

WorldState removeSelector: #drawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #drawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #runLocalStepMethodsIn:!

WorldState removeSelector: #runLocalStepMethodsIn:!

WorldState removeSelector: #runStepMethodsIn:!

WorldState removeSelector: #runStepMethodsIn:!

WorldState removeSelector: #simpleDrawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #simpleDrawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #tryDeferredUpdatingAndSetCanvasFor:!

WorldState removeSelector: #tryDeferredUpdatingAndSetCanvasFor:!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3050-WorldState-refactor-JuanVuletich-2017Mar03-09h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:22:19 am'!
!PasteUpMorph methodsFor: 'interaction loop' stamp: 'jmv 3/2/2017 19:58:01' prior: 50339846!
              doOneCycleNow
	"see the comment in WorldState >> doOneCycleNow
	Only used for a few tests."
	worldState doOneCycleNow! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/3/2017 09:21:41' prior: 50339563!
                doOneCycleNow
	"Immediately do one cycle of the interaction loop."

	| hadAnyEvent |
	"See #eventTickler"
	Cursor currentCursor = Cursor wait ifTrue: [
		Cursor normal activateCursor ].

	"Repair visual damage."
	DisplayScreen checkForNewScreenSize.
	self displayWorldSafely.

	"Run steps, alarms and deferred UI messages"
	self runStepMethods.

	"Process user input events. Run all event triggered code."
	hadAnyEvent _ false.
	self handsDo: [ :h |
		activeHand _ h.
		hadAnyEvent _ hadAnyEvent | h processEventQueue.
		activeHand _ nil ].

	"The default is the primary hand"
	activeHand _ self hands first.


	^hadAnyEvent! !

PasteUpMorph removeSelector: #runStepMethods!

PasteUpMorph removeSelector: #runStepMethods!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3051-WorldState-refactor-JuanVuletich-2017Mar03-09h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:27:56 am'!
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 20:08:11'!
             doOneMinimalCycleNow
	"see the comment in WorldState >> doOneMinimalCycleNow"

	worldState doOneMinimalCycleNow! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 20:06:48'!
      doOneMinimalCycleNow
	"Immediately do one cycle of the interaction loop.
	Only repair display and process events. For modal menus and such."

	"Repair visual damage."
	self displayWorldSafely.

	"Process user input events. Run all event triggered code."
	^activeHand processEventQueue! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 3/2/2017 20:08:34' prior: 16867177!
         invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu
	See senders of this method for finding out how to use modal menu morphs."
	| w oldFocus actHand |
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneMinimalCycleNow.
	self	
		popUpAt: actHand morphPosition
		forHand: actHand 
		allowKeyboard: allowKeyboardControl.
	self isModalInvokationDone: false.
	[ self isInWorld & self isModalInvokationDone not ] whileTrue: [ w doOneMinimalCycleNow ].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ self modalSelection! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 3/2/2017 20:08:29' prior: 16865463!
                          invokeAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	|actHand w oldFocus |
	self flag: #bob.		"is <aPoint> global or local?"
	self flag: #arNote.	"<aPoint> is local to aWorld"
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneMinimalCycleNow.
	self
		popUpAt: aPoint
		forHand: actHand
		allowKeyboard: aBoolean.
	done _ false.
	[ self isInWorld & done not ] whileTrue: [ w doOneMinimalCycleNow ].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ mvcSelection ! !
!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'jmv 3/2/2017 20:08:24' prior: 16844196!
                   getUserResponse
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."

	| w |
	w _ self world.
	w ifNil: [^ response].
	done _ false.
	textPane focusText.
	[done] whileFalse: [w doOneMinimalCycleNow].
	self delete.
	w doOneMinimalCycleNow.
	^ response
! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 3/3/2017 09:26:42' prior: 16844289!
                             request: queryString initialAnswer: defaultAnswer centerAt: aPoint onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."
	"
	FillInTheBlankMorph
		request: 'Type something, then type [Return].'
		initialAnswer: 'yo ho ho!!'
	"

	| aFillInTheBlankMorph |
	aFillInTheBlankMorph _ self new
		setQuery: queryString
		initialAnswer: defaultAnswer
		acceptOnCR: acceptBoolean.
	aFillInTheBlankMorph responseUponCancel: returnOnCancel.
	self runningWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.
	^ aFillInTheBlankMorph getUserResponse! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3052-MenusDoReducedWorldCycle-JuanVuletich-2017Mar03-09h22m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:49:08 am'!
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/3/2017 09:47:13'!
     runLocalStepMethods: nowTime
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| morphToStep scheduledTime |
	[ stepList notEmpty and: [ stepList first scheduledTime <= nowTime ]] 
		whileTrue: [
			lastStepMessage _ stepList removeFirst.
			morphToStep _ lastStepMessage receiver.
			(morphToStep shouldGetStepsFrom: world) 
				ifTrue: [
					scheduledTime _ lastStepMessage scheduledTime.
					lastStepMessage valueAtTime: nowTime - scheduledTime + lastStepMessage stepTime.
					lastStepMessage ifNotNil: [
							lastStepMessage scheduledTime: (scheduledTime + lastStepMessage stepTime max: nowTime + 1).
							stepList add: lastStepMessage ]].
			lastStepMessage _ nil ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:33:59' prior: 16945643!
                            addAlarm: aSelector withArguments: argArray for: aTarget at: scheduledTime
	"Add a new alarm with the given set of parameters"

	alarms add: 
		(MorphicAlarm 
			receiver: aTarget
			selector: aSelector
			arguments: argArray
			at: scheduledTime)! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:34:03' prior: 16945653!
                    adjustAlarmTimes: nowTime
	"Adjust the alarm times after some clock weirdness (such as image-startup etc)"
	| deltaTime |
	deltaTime _ nowTime - lastAlarmTime.
	alarms do: [ :alarm |
		alarm scheduledTime: alarm scheduledTime + deltaTime ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:34:21' prior: 16945673!
                            removeAlarm: aSelector for: aTarget 
	"Remove the alarm with the given selector"

	| alarm |
	alarm := alarms 
				detect: [ :any | any receiver == aTarget and: [any selector == aSelector]]
				ifNone: nil.
	alarm ifNotNil: [ alarms remove: alarm ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:35:03' prior: 16945684!
                   triggerAlarmsBefore: nowTime
	"Trigger all pending alarms that are to be executed before nowTime."

	nowTime - lastAlarmTime > 10000
		ifTrue: [ self adjustAlarmTimes: nowTime ].
	[ alarms notEmpty and: [ alarms first scheduledTime < nowTime ]]
		whileTrue: [ alarms removeFirst valueAtTime: nowTime ].
	lastAlarmTime _ nowTime! !
!WorldState methodsFor: 'initialization' stamp: 'jmv 3/3/2017 09:33:53' prior: 16945782!
                            initialize

	activeHand _ HandMorph new.
	hands _ { activeHand }.
	damageRecorder _ DamageRecorder new.
	stepList _ Heap sortBlock: self stepListSortBlock.
	alarms _ Heap sortBlock: self alarmSortBlock.
	lastAlarmTime _ 0.
	drawingFailingMorphs _ WeakIdentitySet new.
	pause _ 20.
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ false! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 09:39:18' prior: 50339440!
      cleanseStepList
	"Remove morphs from the step list that are not in this World."

	| deletions morphToStep |
	deletions _ nil.
	stepList do: [:entry |
		morphToStep _ entry receiver.
		morphToStep world == world ifFalse:[
			deletions ifNil: [deletions _ OrderedCollection new].
			deletions addLast: entry]].

	deletions ifNotNil:[
		deletions do: [:entry|
			self stopSteppingMorph: entry receiver]].

	alarms copy do: [ :entry |
		morphToStep _ entry receiver.
		((morphToStep is: #Morph) and: [ morphToStep world == world ]) 
			ifFalse: [ self removeAlarm: entry selector for: entry receiver ]]! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 09:46:37' prior: 50339463!
                   runStepMethods
	"Perform periodic activity inbetween event cycles"
	| queue msg |

	queue _ self class deferredUIMessages.
	[ (msg _ queue nextOrNil) isNil ] whileFalse: [
		msg value
	].
	self triggerAlarmsBefore: lastCycleTime.
	self runLocalStepMethods: lastCycleTime.

	"we are using a normal #step for these now"
	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."
! !

WorldState removeSelector: #alarms!

WorldState removeSelector: #alarms!

WorldState removeSelector: #runLocalStepMethods!

WorldState removeSelector: #runLocalStepMethods!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3053-WorldState-refactor-JuanVuletich-2017Mar03-09h27m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3053] on 3 March 2017 at 11:17:47 am'!

MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #StepMessage category: #'Morphic-Events'!
MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/3/2017 11:14:28'!
     valueAtTime: millisecondClock

	|  nArgs millisecondsSinceLast |
	numArgs ifNil: [numArgs _ selector numArgs].
	nArgs _ arguments ifNil: [0] ifNotNil: [arguments size].
"OJO!!"
lastEvaluationTime ifNil: [ lastEvaluationTime _ millisecondClock ].
	millisecondsSinceLast _ millisecondClock - lastEvaluationTime.
	lastEvaluationTime _ millisecondClock.
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self value ].
	^arguments
		ifNil: [ receiver perform: selector with: millisecondsSinceLast]
		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: millisecondsSinceLast) ]! !
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/3/2017 11:16:08' prior: 50340127!
                runLocalStepMethods: nowTime
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| morphToStep scheduledTime |
	[ stepList notEmpty and: [ stepList first scheduledTime <= nowTime ]] 
		whileTrue: [
			lastStepMessage _ stepList removeFirst.
			morphToStep _ lastStepMessage receiver.
			(morphToStep shouldGetStepsFrom: world) 
				ifTrue: [
					scheduledTime _ lastStepMessage scheduledTime.
					lastStepMessage valueAtTime: nowTime.
					lastStepMessage ifNotNil: [
						lastStepMessage scheduledTime: (scheduledTime + lastStepMessage stepTime max: nowTime + 1).
						stepList add: lastStepMessage ]].
			lastStepMessage _ nil ]! !

MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #StepMessage category: #'Morphic-Events'!
MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3054-StepMessageCleanup-JuanVuletich-2017Mar03-11h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3053] on 3 March 2017 at 11:41:31 am'!
!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/3/2017 11:28:02'!
                   rescheduleAfter: millisecondTimer
	"Schedule next run"
	scheduledTime _ scheduledTime + self stepTime max: millisecondTimer + 1! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:39:34' prior: 16945882!
          stopStepping: aMorph selector: aSelector
	"Remove the given morph from the step list."
	stepList removeAll: (stepList select:[:stepMsg| stepMsg receiver == aMorph and: [ stepMsg selector == aSelector ]])! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:39:22' prior: 16945896!
                              stopSteppingMorph: aMorph
	"Remove the given morph from the step list."
	stepList removeAll: (stepList select: [ :stepMsg | stepMsg receiver == aMorph])! !
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/3/2017 11:39:10' prior: 50340299!
                runLocalStepMethods: nowTime
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| stepMessage |
	[ stepList notEmpty and: [ stepList first scheduledTime <= nowTime ]] 
		whileTrue: [

			stepMessage _ stepList first.
			(stepMessage receiver shouldGetStepsFrom: world)
				ifTrue: [
					stepMessage valueAtTime: nowTime.
					"If it was not removed from the list during its own evaluation"
					stepMessage == stepList first ifTrue: [
						stepList removeFirst.
						stepMessage rescheduleAfter: nowTime.
						stepList add: stepMessage ]]

				ifFalse: [ stepList removeFirst ].
		]! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3055-SteppingCleanup-JuanVuletich-2017Mar03-11h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3053] on 3 March 2017 at 11:55:19 am'!
!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/3/2017 11:55:15' prior: 50340277!
                             valueAtTime: millisecondClock

	|  nArgs millisecondsSinceLast |
	numArgs ifNil: [numArgs _ selector numArgs].
	nArgs _ arguments ifNil: [0] ifNotNil: [arguments size].
	lastEvaluationTime ifNil: [ lastEvaluationTime _ millisecondClock ].
	millisecondsSinceLast _ millisecondClock - lastEvaluationTime.
	lastEvaluationTime _ millisecondClock.
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self value ].
	^arguments
		ifNil: [ receiver perform: selector with: millisecondsSinceLast]
		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: millisecondsSinceLast) ]! !
!PasteUpMorph methodsFor: 'caching' stamp: 'jmv 3/3/2017 11:42:44' prior: 16887042!
                       releaseCachedState
	super releaseCachedState.
	backgroundImage _ nil.
	self isWorldMorph ifTrue: [
		worldState cleanseStepList.
		worldState clearCanvas ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 11:54:00' prior: 50340176!
                removeAlarm: aSelector for: aTarget 
	"Remove the alarm with the given selector"

	| alarm |
	alarm _ alarms 
				detect: [ :any | any receiver == aTarget and: [any selector == aSelector]]
				ifNone: nil.
	alarm ifNotNil: [ alarms remove: alarm ]! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:51:16' prior: 50340215!
                  cleanseStepList
	"Remove morphs from the step list that are not in this World."

	| deletions |
	deletions _ OrderedCollection new.
	stepList do: [ :entry |
		entry receiver world == world ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		stepList remove: entry ].

	deletions _ OrderedCollection new.
	alarms do: [ :entry |
		((entry receiver is: #Morph) and: [ entry receiver world == world ]) ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		alarms remove: entry ]! !

PasteUpMorph removeSelector: #cleanseStepList!

PasteUpMorph removeSelector: #cleanseStepList!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3056-SteppingCleanup-JuanVuletich-2017Mar03-11h41m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3056] on 3 March 2017 at 3:11:05 pm'!
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/3/2017 15:04:20' prior: 50339507!
                              doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < 200				"No events processed? Start saving CPU!! But never make the user wait more than 200ms for being responsive again."
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time localMillisecondClock ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 5
		ifFalse: [ Processor yield ]
		ifTrue: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3057-SteppingHangWorkaround-JuanVuletich-2017Mar03-15h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 7:15:45 pm'!
!TestCase methodsFor: 'Running' stamp: 'HAW 3/3/2017 19:13:13'!
                    debugAsFailureIfCanNot: handler
	
	| semaphore |
	
	self ifCanNotDebugDo: [ ^handler value].
	
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. 
	self tearDown.
	self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 14:13:09'!
                 canNotDebugMethodErrorDescription

	^self class canNotDebugMethodErrorDescription! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 18:50:08'!
           ifCanNotDebugDo: handler

	^self testMethod isQuick ifTrue: handler! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 14:13:37'!
                         signalCanNotDebugMethod 

	self error: self canNotDebugMethodErrorDescription! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 14:10:20'!
               testMethod 

	^self class lookupSelector: self selector! !
!TestCase class methodsFor: 'Instance Creation' stamp: 'HAW 3/3/2017 18:51:38'!
                     debugAsFailure: aSymbol ifCanNot: handler

	^(self selector: aSymbol) debugAsFailureIfCanNot: handler
	! !
!TestCase class methodsFor: 'Error Descriptions' stamp: 'HAW 3/3/2017 16:33:00'!
    canNotDebugMethodErrorDescription

	^'Quick methods can not be debugged'! !
!Browser methodsFor: 'tdd' stamp: 'HAW 3/3/2017 19:12:25' prior: 50338009!
         debugMethodTest
	
	currentCompiledMethod isTestMethod ifTrue: [
		currentCompiledMethod methodClass debugAsFailure: currentCompiledMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]
! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 3/3/2017 19:12:39' prior: 50338096!
          acceptAndDebugTest
	
	^self acceptAndWithMethodDo: [ :aPotencialTestMethod | 
		aPotencialTestMethod isTestMethod ifTrue: [ 
			aPotencialTestMethod methodClass debugAsFailure: aPotencialTestMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]]! !
!TestCase methodsFor: 'Running' stamp: 'HAW 3/3/2017 18:49:24' prior: 16927491!
                 debugAsFailure
	
	^self debugAsFailureIfCanNot: [ self signalCanNotDebugMethod ]! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 19:13:40' prior: 16927518!
                            openDebuggerOnFailingTestMethod

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self testMethod.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ Debugger new
		process: guineaPig
		context: context.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 19:14:27' prior: 16927535!
                               openDebuggerOnFailingTestMethod: semaphore

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self testMethod.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ TestCaseDebugger new
		process: guineaPig
		context: context.
	debugger doneSemaphore: semaphore.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !

TestCase class removeSelector: #debugAsFailure:!

TestCase class removeSelector: #debugAsFailure:!

TestCase removeSelector: #assertCanDebugMethod!

TestCase removeSelector: #canNotDebugQuickMethodErrorDescription!

TestCase removeSelector: #signalCanNotDebugQuickMethod!

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3058-CuisCore-HernanWilkinson-2017Mar02-18h30m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3058] on 6 March 2017 at 10:14:29 am'!
!Delay class methodsFor: 'timer process' stamp: 'jmv 3/6/2017 10:13:34' prior: 16833016!
                            handleTimerEvent
	"Handle a timer event; which can be either:
		- a schedule request (ScheduledDelay notNil)
		- an unschedule request (FinishedDelay notNil)
		- a timer signal (not explicitly specified)
	We check for timer expiry every time we get a signal."
	| nowTick nextTick afterwardsTick |
	"Wait until there is work to do."
	TimingSemaphore wait.

	"Process any schedule requests"
	ScheduledDelay ifNotNil: [
		"Schedule the given delay"
		self scheduleDelay: ScheduledDelay.
		ScheduledDelay := nil.
		ScheduledDelayNilledSemaphore initSignals. 
		ScheduledDelayNilledSemaphore signal ].

	"Process any unschedule requests"
	FinishedDelay ifNotNil: [
		self unscheduleDelay: FinishedDelay.
		FinishedDelay := nil.
		FinishedDelayNilledSemaphore initSignals.
		FinishedDelayNilledSemaphore signal ].

	"Check for clock wrap-around."
	nowTick := Time millisecondClockValue.
	nowTick < ActiveDelayStartTime ifTrue: [
		"clock wrapped"
		self saveResumptionTimes.
		self restoreResumptionTimes ].
	ActiveDelayStartTime := nowTick.

	"Signal any expired delays"
	[ ActiveDelay notNil and:[ nowTick >= ActiveDelay resumptionTime ]] whileTrue: [
		ActiveDelay signalWaitingProcess.
		SuspendedDelays isEmpty 
			ifTrue: [ ActiveDelay := nil ] 
			ifFalse:[ ActiveDelay := SuspendedDelays removeFirst ]].

	"And signal when the next request is due. We sleep at most 1sec here
	as a soft busy-loop so that we don't accidentally miss signals."
	nextTick := nowTick + 1000.
	ActiveDelay ifNotNil: [
		nextTick := nextTick min: ActiveDelay resumptionTime ].
	nextTick := nextTick min: SmallInteger maxVal.

	"Since we have processed all outstanding requests, reset the timing semaphore so
	that only new work will wake us up again. Do this RIGHT BEFORE setting the next
	wakeup call from the VM because it is only signaled once so we mustn't miss it."
	TimingSemaphore initSignals.
	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.

	"This test is necessary for the obscure case that the msecs clock rolls over
	after nowTick has been computed (unlikely but not impossible). In this case we'd
	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets
	scheduled (which may not be any time soon). In any case, since handling the
	condition is easy, let's just deal with it."
	afterwardsTick _ Time millisecondClockValue.
	afterwardsTick < nowTick  						"Means clock rollover."
		ifTrue: [ TimingSemaphore signal ]. "retry"

	"It seems that #primSignal:atMilliseconds: might not signal the semaphore if the requested moment is in the past.
	This behavior was observed in Linux Spur64 VMs.
	If this happens, next delay never finishes. Usual symptom is frozen Morphic.
	If there is any risk of this happening, just do another iteration right now."
	nextTick < afterwardsTick  						"We're already late for next signal."
		ifTrue: [ TimingSemaphore signal ]. "retry"! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/5/2017 00:38:27' prior: 50340472!
                     doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < 200				"No events processed? Start saving CPU!! But never make the user wait more than 200ms for being responsive again."
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time localMillisecondClock ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 0
		ifFalse: [ Processor yield ]
		ifTrue: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow! !

----End fileIn of C:\Users\Juan-Tuerca\PayloadSoftware\Cuis-Smalltalk-Dev\CoreUpdates\3059-RealFixForSteppingFreeze-JuanVuletich-2017Mar06-10h02m-jmv.1.cs.st----!

----SNAPSHOT----#(6 March 2017 10:37:24.244351 am) Cuis5.0-3059-spur.image priorSource: 202692!

----QUIT----#(6 March 2017 10:37:44.404351 am) Cuis5.0-3059-spur.image priorSource: 293363!

----STARTUP----#(8 March 2017 9:23:04.041449 am) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3059-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3059] on 7 March 2017 at 9:52:45 am'!
!Time class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 09:52:37' prior: 16937622!
       primMillisecondClock
	"Primitive. Answer the number of milliseconds since the millisecond clock
	was last reset or rolled over. No sync to any system clock.
	Implemented by all major platforms.
	Essential. See Object documentation whatIsAPrimitive. 
	
	Time primMillisecondClock
	Time primMillisecondClock / 1000 / 60.0

	Range is  from zero to 16r1FFFFFFF.
	The VM defines MillisecondClockMask as 16r1FFFFFFF

	Overflows usually every six days.
	Still used in #localMillisecondClock if the VM doesn't implement
		Time primLocalMicrosecondClock
	"
"Not really a clock, but a timer or ticker"

	<primitive: 135>
	self primitiveFailed! !
!Delay class methodsFor: 'timer process' stamp: 'jmv 3/7/2017 09:51:10' prior: 50340662!
           handleTimerEvent
	"Handle a timer event; which can be either:
		- a schedule request (ScheduledDelay notNil)
		- an unschedule request (FinishedDelay notNil)
		- a timer signal (not explicitly specified)
	We check for timer expiry every time we get a signal."
	| nowTick nextTick afterwardsTick |
	"Wait until there is work to do."
	TimingSemaphore wait.

	"Process any schedule requests"
	ScheduledDelay ifNotNil: [
		"Schedule the given delay"
		self scheduleDelay: ScheduledDelay.
		ScheduledDelay := nil.
		ScheduledDelayNilledSemaphore initSignals. 
		ScheduledDelayNilledSemaphore signal ].

	"Process any unschedule requests"
	FinishedDelay ifNotNil: [
		self unscheduleDelay: FinishedDelay.
		FinishedDelay := nil.
		FinishedDelayNilledSemaphore initSignals.
		FinishedDelayNilledSemaphore signal ].

	"Check for clock wrap-around."
	nowTick := Time millisecondClockValue.
	nowTick < ActiveDelayStartTime ifTrue: [
		"clock wrapped"
		self saveResumptionTimes.
		self restoreResumptionTimes ].
	ActiveDelayStartTime := nowTick.

	"Signal any expired delays"
	[ ActiveDelay notNil and:[ nowTick >= ActiveDelay resumptionTime ]] whileTrue: [
		ActiveDelay signalWaitingProcess.
		SuspendedDelays isEmpty 
			ifTrue: [ ActiveDelay := nil ] 
			ifFalse:[ ActiveDelay := SuspendedDelays removeFirst ]].

	"And signal when the next request is due. We sleep at most 1sec here
	as a soft busy-loop so that we don't accidentally miss signals."
	nextTick := nowTick + 1000.
	ActiveDelay ifNotNil: [
		nextTick := nextTick min: ActiveDelay resumptionTime ].
	nextTick := nextTick min: 16r1FFFFFFF.	"MillisecondClockMask"

	"Since we have processed all outstanding requests, reset the timing semaphore so
	that only new work will wake us up again. Do this RIGHT BEFORE setting the next
	wakeup call from the VM because it is only signaled once so we mustn't miss it."
	TimingSemaphore initSignals.
	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.

	"This test is necessary for the obscure case that the msecs clock rolls over
	after nowTick has been computed (unlikely but not impossible). In this case we'd
	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets
	scheduled (which may not be any time soon). In any case, since handling the
	condition is easy, let's just deal with it."
	afterwardsTick _ Time millisecondClockValue.
	afterwardsTick < nowTick  						"Means clock rollover."
		ifTrue: [ TimingSemaphore signal ]. "retry"

	"It seems that #primSignal:atMilliseconds: might not signal the semaphore if the requested moment is in the past.
	This behavior was observed in Linux Spur64 VMs.
	If this happens, next delay never finishes. Usual symptom is frozen Morphic.
	If there is any risk of this happening, just do another iteration right now."
	nextTick < afterwardsTick  						"We're already late for next signal."
		ifTrue: [ TimingSemaphore signal ]. "retry"! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3060-Proper-MillisecondClockMask-JuanVuletich-2017Mar07-09h05m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3061] on 7 March 2017 at 12:20:30 pm'!
!Time class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 12:16:43' prior: 16937642!
                     primUtcMicrosecondClock
	"Answer the number of microseconds since the UTC Smalltalk epoch, 
	i.e. 00:00 on the morning of January 1, 1901, the start of the 20th century, in UTC time.
	 The value is derived from the Posix epoch with a constant offset corresponding to elapsed microseconds
	 between the two epochs according to RFC 868.
	Answer is (at least usually) a  LargePositiveInteger
	Cog VMs implement this. Interpreters might not."
	"
	Time primUtcMicrosecondClock
	Time primUtcMicrosecondClock/ 1000 / 1000 / 60 / 60 / 24 / 365.25

	(Time primUtcMicrosecondClock / 1000 / 1000 + Time primUtcWithOffset second) / 60 / 60 / 24 / 365.25
	(DateAndTime now - (DateAndTime year: 1901 month: 1 day: 1)) totalSeconds / 60 / 60 / 24 / 365.25
	"
	<primitive: 240>
	^nil! !
!Delay class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 12:19:39'!
                       primSignal: aSemaphore atUTCMicroseconds: anInteger
	"Signal the semaphore when the UTC microsecond clock reaches the value of the second argument.
	 Fail if the first argument is neither a Semaphore nor nil.
	Fail if the second argument is not an integer (either SmallInteger or LargePositiveInteger).
	See #primUtcMicrosecondClock
	 Essential. See Object documentation whatIsAPrimitive."
	<primitive: 242>
	^self primitiveFailed! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3061-UTCDelayedSignalPrimitive-JuanVuletich-2017Mar07-12h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3061] on 7 March 2017 at 2:55:27 pm'!

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!MenuMorph methodsFor: 'control' stamp: 'ar 9/17/2000 20:38'!
  activeSubmenu: aSubmenu
	activeSubMenu ifNotNil:[activeSubMenu delete].
	activeSubMenu _ aSubmenu.! !
!MenuMorph methodsFor: 'initialization' stamp: 'ar 10/10/2000 01:57'!
                    delete
	activeSubMenu ifNotNil:[activeSubMenu delete].
	^super delete! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 9/20/2012 00:14'!
                     activateOwnerMenu: evt
	"Activate our owner menu; e.g., pass control to it"
	owner ifNil: [ ^false ]. "not applicable"
	(owner morphContainsPoint: (owner internalizeFromWorld: evt eventPosition))
		ifFalse: [ ^false ].
	owner activate: evt.
	^true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/7/2017 14:37:43' prior: 50339169!
                    deleteIfPopUp: evt
	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."

	stayUp ifFalse: [ self delete ].
	popUpOwner ifNotNil: [
		popUpOwner isSelected: false.
		popUpOwner deleteIfPopUp: evt ].
	evt ifNotNil: [ evt hand ifNotNil: [ :h | h releaseMouseFocus: self ]]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 5/9/2016 20:40' prior: 50339178!
          popUpAdjacentTo: rightOrLeftPointInWorld from: sourceItem
	"Present this menu at the given point under control of the given hand.
	Used mostly for submenus."

	| delta tryToPlace selectedOffset |
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld
			amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 17:50' prior: 50339317!
  handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	| eventPositionInOurCoordinates |
	eventPositionInOurCoordinates _ self internalizeFromWorld: aMorphicEvent eventPosition.

	self dispatchEvent: aMorphicEvent localPosition: eventPositionInOurCoordinates.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [^self]].! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 9/8/2012 20:15' prior: 50339359!
     initialize
	super initialize.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 1/29/2014 23:46' prior: 50339372!
           deselect

	self isSelected: false.
	subMenu ifNotNil: [
		owner ifNotNil:[ owner activeSubmenu: nil ].
		self removeAlarm: #deselectTimeOut ]! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 1/29/2014 23:44' prior: 50339378!
                          select
	self isSelected: true.
	owner activeSubmenu: subMenu.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphBoundsInWorld topRight + (10@0)
									with: self morphBoundsInWorld topLeft)
			from: self.
		subMenu selectItem: nil ]! !

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3062-FixRecentMenuBreackage-JuanVuletich-2017Mar07-14h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 7 March 2017 at 3:18:07 pm'!
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:23'!
                              methodForTest

	"Can not call it testMethod because it will be detected as test - Hernan" 

	^self class lookupSelector: self selector! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:38' prior: 50340556!
      ifCanNotDebugDo: handler

	^self methodForTest isQuick ifTrue: handler! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:45' prior: 50340610!
      openDebuggerOnFailingTestMethod

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self methodForTest.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ Debugger new
		process: guineaPig
		context: context.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:50' prior: 50340627!
                            openDebuggerOnFailingTestMethod: semaphore

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self methodForTest.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ TestCaseDebugger new
		process: guineaPig
		context: context.
	debugger doneSemaphore: semaphore.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !

TestCase removeSelector: #testMethod!

TestCase removeSelector: #testMethod!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3063-FixForExtraTest-HernanWilkinson-2017Mar03-19h15m-HAW.1.cs.st----!

----SNAPSHOT----#(8 March 2017 9:23:22.879116 am) Cuis5.0-3063-spur.image priorSource: 293460!

----QUIT----#(8 March 2017 9:23:36.083407 am) Cuis5.0-3063-spur.image priorSource: 306695!

----STARTUP----#(13 March 2017 5:40:32.989338 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3063-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3063] on 13 March 2017 at 4:16:45 pm'!
!WriteStream methodsFor: 'accessing' stamp: 'jmv 3/12/2017 18:55:36' prior: 50335199!
                  nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ self nextPutAll: aString ].

	newEnd _ position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position _ newEnd! !
!WriteStream methodsFor: 'private' stamp: 'jmv 3/12/2017 19:08:07' prior: 16946568!
growTo: anInteger
	"Grow the collection by creating a new bigger collection and then
	copy over the contents from the old one. We grow by doubling the size.

	anInteger is the required minimal new size of the collection "

	| oldSize grownCollection newSize |
	oldSize _ collection size.
     newSize _ anInteger + (oldSize max: 20).
	grownCollection _ collection class new: newSize.
	collection _ grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.
	writeLimit _ collection size! !
!WriteStream methodsFor: 'private' stamp: 'jmv 3/12/2017 19:07:28' prior: 16946596!
                  pastEndPut: anObject
	"Grow the collection.
	Then we put <anObject> at the current write position."

	self growTo: collection size + 1.
	collection at: (position _ position + 1) put: anObject! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3064-WriteStreamTweaks-JuanVuletich-2017Mar13-16h06m-jmv.1.cs.st----!

----SNAPSHOT----#(13 March 2017 5:40:41.575048 pm) Cuis5.0-3064-spur.image priorSource: 306791!

----QUIT----#(13 March 2017 5:41:02.939794 pm) Cuis5.0-3064-spur.image priorSource: 308624!