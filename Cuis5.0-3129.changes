'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 7 November 2016 at 2:53:38 pm'!


----SNAPSHOT----#(7 November 2016 2:53:55.973029 pm) Cuis5.0-2974-spur.image priorSource: 0!

----QUIT----#(7 November 2016 2:54:03.110029 pm) Cuis5.0-2974-spur.image priorSource: 92!

----STARTUP----#(17 November 2016 12:32:23.600889 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-2974-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 16 November 2016 at 3:55:25 pm'!
!Integer class methodsFor: 'instance creation' stamp: 'jmv 11/16/2016 15:37:15' prior: 16860879!
              readFrom: aStream base: base
	"Answer an instance of one of my concrete subclasses. Initial minus sign
	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not
	allowed--use Number readFrom: for that. Answer zero (not an error) if
	there are no digits."

	| digit value neg cc atLeastOneDigitRead |
	neg _ aStream peekFor: $-.
	neg ifFalse: [aStream peekFor: $+].
	value _ 0.
	atLeastOneDigitRead _ false.
	[ aStream atEnd ]
		whileFalse: [
			cc _ aStream next.
			digit _ cc digitValue.
			(digit < 0 or: [digit >= base])
				ifTrue: [
					aStream skip: -1.
					atLeastOneDigitRead ifFalse: [self error: 'At least one digit expected here'].
					^neg
						ifTrue: [value negated]
						ifFalse: [value]].
			value _ value * base + digit.
			atLeastOneDigitRead _ true ].
	neg ifTrue: [^ value negated].
	^ value! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2975-Integer-readFrom-cleanup-JuanVuletich-2016Nov16-15h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2975] on 17 November 2016 at 9:08:34 am'!
!PositionableStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:06:59' prior: 16891425!
           peek
	"Answer what would be returned if the message next were sent to the 
	receiver. If the receiver is at the end, answer nil."

	| nextObject |
	position < readLimit ifTrue: [
		^collection at: position+1 ].
	self atEnd ifTrue: [^nil].
	nextObject _ self next.
	position _ position - 1.
	^nextObject! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 11/17/2016 09:07:20' prior: 16913380!
    peek
	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "
	| next |
	position < readLimit ifTrue: [
		^collection at: position+1 ].
	self atEnd ifTrue: [^ nil].
	next _ self basicNext.
	self position: self position - 1.
	^ next! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2976-peek-Optimization-JuanVuletich-2016Nov17-09h06m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2975] on 17 November 2016 at 9:18:37 am'!
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:42'!
                               nextDouble64BigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: false ])
			readStream nextDouble64BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: true ])
			readStream nextDouble64BigEndian: true
	"
	| bytes |
	bytes _ self next: 8.
	^ bytes doubleAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:40'!
            nextDouble64Put: aFloat bigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextDouble64Put: Float pi bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 8.
	bytes doubleAt: 1 put: aFloat bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:38'!
      nextFloat32BigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'
	Float pi asIEEE32BitWord hex '16r40490FDB'
	Float pi negated asIEEE32BitWord hex '16rC0490FDB'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: false ])
			readStream nextFloat32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: true ])
			readStream nextFloat32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes floatAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:34'!
                  nextFloat32Put: aFloat bigEndian: bigEndian
	"Store the given number as a 32 bit Float on this (binary) stream.

	Float pi hex '400921FB54442D18'
	Float pi negated hex 'C00921FB54442D18'
	Float pi asIEEE32BitWord hex '16r40490FDB'
	Float pi negated asIEEE32BitWord hex '16rC0490FDB'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: false ]) hex 'DB0F4940'

	(ByteArray streamContents: [ :strm |
		strm nextFloat32Put: Float pi bigEndian: true ]) hex '40490FDB'
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes floatAt: 1 put: aFloat bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
                    nextSignedInt16BigEndian: bigEndian
	"Answer the next  signed, 16-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: false ]) 
			readStream nextSignedInt16BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: true ]) 
			readStream nextSignedInt16BigEndian: true
	"
	| bytes |
	bytes _ self next: 2.
	^ bytes shortAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
          nextSignedInt16Put: aNumber bigEndian: bigEndian
	"Store the given number as a signed, 16-bit integer on this (binary) stream.

	(16r10000-12345) hex '16rCFC7'

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt16Put: -12345 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 2.
	bytes shortAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:26'!
nextSignedInt32BigEndian: bigEndian
	"Answer the next signed, 32-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: false ]) 
			readStream nextSignedInt32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: true ]) 
			readStream nextSignedInt32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes longAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
          nextSignedInt32Put: aNumber bigEndian: bigEndian
	"Store the given number as a signed, 32-bit integer on this (binary) stream.

	(16r100000000-123456) hex '16rFFFE1DC0'

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextSignedInt32Put: -123456 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes longAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:18'!
                      nextUnsignedInt16BigEndian: bigEndian
	"Answer the next unsigned, 16-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: false ]) 
			readStream nextUnsignedInt16BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: true ]) 
			readStream nextUnsignedInt16BigEndian: true
	"
	| bytes |
	bytes _ self next: 2.
	^ bytes unsignedShortAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
                         nextUnsignedInt16Put: aNumber bigEndian: bigEndian
	"Store the given number as a unsigned, 16-bit integer on this (binary) stream.

	12345 hex  '16r3039'

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt16Put: 12345 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 2.
	bytes unsignedShortAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:19'!
                            nextUnsignedInt32BigEndian: bigEndian
	"Answer the next unsigned, 32-bit integer from this (binary) stream.

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: false ]) 
			readStream nextUnsignedInt32BigEndian: false

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: true ]) 
			readStream nextUnsignedInt32BigEndian: true
	"
	| bytes |
	bytes _ self next: 4.
	^ bytes unsignedLongAt: 1 bigEndian: bigEndian! !
!Stream methodsFor: 'normalized access' stamp: 'jmv 2/25/2016 11:27'!
                        nextUnsignedInt32Put: aNumber bigEndian: bigEndian
	"Store the given number as a unsigned, 32-bit integer on this (binary) stream.

	123456 hex '16r1E240'

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: false ]) hex

	(ByteArray streamContents: [ :strm |
		strm nextUnsignedInt32Put: 123456 bigEndian: true ]) hex
	"
	| bytes |
	bytes _ ByteArray new: 4.
	bytes unsignedLongAt: 1 put: aNumber bigEndian: bigEndian.
	self nextPutAll: bytes! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 6/14/2013 20:02'!
                   nextNumber
	"Answer a number from the stream."

	|element|
	[(element := self next) isNil or: [element isDigit or: [element = $- or: [element = $)]]]] whileFalse.
	element ifNil: [^nil].
	self skip: -1.
	element = $) ifTrue: [^nil].
	^Number readFrom: self! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 2/29/2016 11:04'!
               nextNumber: n 
	"Answer the next n bytes as a positive Integer or LargePositiveInteger.
	Currently only for bigEndian. Consider following the convention in category 'normalized access'"
	| s |
	s _ 0.
	1 to: n do: 
		[:i | s _ (s bitShift: 8) bitOr: self next asInteger].
	^ s normalize! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'jmv 2/29/2016 11:04'!
                 nextNumber: n put: v 
	"Append to the receiver the argument, v, which is a positive 
	SmallInteger or a LargePositiveInteger, as the next n bytes.
	Possibly pad with leading zeros.
	Currently only for bigEndian. Consider following the convention in category 'normalized access'"

	1 to: n do: [:i | self nextPut: (v digitAt: n+1-i)].
	^ v
! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'ls 9/14/1998 22:46'!
                             nextString
	"Read a string from the receiver. The first byte is the length of the string, unless it is greater than 192, in which case the first four bytes encode the length.  I expect to be in ascii mode when called (caller puts back to binary)."

	| aString length |

	"read the length in binary mode"
	self binary.
	length _ self next.		"first byte."
	length >= 192 ifTrue: [length _ length - 192.
		1 to: 3 do: [:ii | length _ length * 256 + self next]].
	aString _ String new: length.

	"read the characters in ASCII mode"
	self ascii.
	self nextInto: aString.
	^aString! !
!Stream methodsFor: 'nonhomogeneous accessing' stamp: 'yo 4/16/2001 17:56'!
                 nextStringPut: s 
	"Append the string, s, to the receiver.  Only used by DataStream.  Max size of 64*256*256*256."

	| length |
	(length _ s size) < 192
		ifTrue: [self nextPut: length]
		ifFalse: 
			[self nextPut: (length digitAt: 4)+192.
			self nextPut: (length digitAt: 3).
			self nextPut: (length digitAt: 2).
			self nextPut: (length digitAt: 1)].
	self nextPutAll: s asByteArray.
	^s! !

DummyStream removeSelector: #nextDouble64BigEndian:!

DummyStream removeSelector: #nextDouble64BigEndian:!

DummyStream removeSelector: #nextDouble64Put:bigEndian:!

DummyStream removeSelector: #nextDouble64Put:bigEndian:!

DummyStream removeSelector: #nextNumber:put:!

DummyStream removeSelector: #nextNumber:put:!

DummyStream removeSelector: #nextSignedInt16BigEndian:!

DummyStream removeSelector: #nextSignedInt16BigEndian:!

DummyStream removeSelector: #nextSignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextSignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextSignedInt32BigEndian:!

DummyStream removeSelector: #nextSignedInt32BigEndian:!

DummyStream removeSelector: #nextSignedInt32Put:bigEndian:!

DummyStream removeSelector: #nextSignedInt32Put:bigEndian:!

DummyStream removeSelector: #nextStringPut:!

DummyStream removeSelector: #nextStringPut:!

DummyStream removeSelector: #nextUnsignedInt16BigEndian:!

DummyStream removeSelector: #nextUnsignedInt16BigEndian:!

DummyStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

DummyStream removeSelector: #nextUnsignedInt32BigEndian:!

DummyStream removeSelector: #nextUnsignedInt32BigEndian:!

DummyStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

DummyStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

DataStream removeSelector: #readStringOld!

DataStream removeSelector: #readStringOld!

PositionableStream removeSelector: #nextDouble64BigEndian:!

PositionableStream removeSelector: #nextDouble64BigEndian:!

PositionableStream removeSelector: #nextDouble64Put:bigEndian:!

PositionableStream removeSelector: #nextDouble64Put:bigEndian:!

PositionableStream removeSelector: #nextFloat32BigEndian:!

PositionableStream removeSelector: #nextFloat32BigEndian:!

PositionableStream removeSelector: #nextFloat32Put:bigEndian:!

PositionableStream removeSelector: #nextFloat32Put:bigEndian:!

PositionableStream removeSelector: #nextNumber!

PositionableStream removeSelector: #nextNumber!

PositionableStream removeSelector: #nextNumber:!

PositionableStream removeSelector: #nextNumber:!

PositionableStream removeSelector: #nextNumber:put:!

PositionableStream removeSelector: #nextNumber:put:!

PositionableStream removeSelector: #nextSignedInt16BigEndian:!

PositionableStream removeSelector: #nextSignedInt16BigEndian:!

PositionableStream removeSelector: #nextSignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextSignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextSignedInt32BigEndian:!

PositionableStream removeSelector: #nextSignedInt32BigEndian:!

PositionableStream removeSelector: #nextSignedInt32Put:bigEndian:!

PositionableStream removeSelector: #nextSignedInt32Put:bigEndian:!

PositionableStream removeSelector: #nextString!

PositionableStream removeSelector: #nextString!

PositionableStream removeSelector: #nextStringOld!

PositionableStream removeSelector: #nextStringOld!

PositionableStream removeSelector: #nextStringPut:!

PositionableStream removeSelector: #nextStringPut:!

PositionableStream removeSelector: #nextUnsignedInt16BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt16BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextUnsignedInt16Put:bigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32BigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

PositionableStream removeSelector: #nextUnsignedInt32Put:bigEndian:!

Stream removeSelector: #nextStringOld!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2977-Stream-refactor-JuanVuletich-2016Nov17-09h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2977] on 17 November 2016 at 10:29:07 am'!
!PositionableStream methodsFor: 'testing' stamp: 'jmv 11/17/2016 10:28:06' prior: 16891536!
         atEnd
	"Answer whether the receiver can access any more objects."

	^position >= readLimit! !
!ReadStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:59:57' prior: 16897965!
            next
	"Answer the next object in the Stream represented by the receiver."

	^position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 10:28:35' prior: 16946385!
             nextPut: anObject 
	"Insert the argument at the next position in the Stream represented by the receiver."

	position >= writeLimit
		ifTrue: [^ self pastEndPut: anObject]
		ifFalse: [
			position _ position + 1.
			^collection at: position put: anObject]! !
!ReadWriteStream methodsFor: 'accessing' stamp: 'jmv 11/17/2016 10:28:45' prior: 16898094!
   next
	"Return the next object in the Stream represented by the receiver."

	"treat me as a FIFO"
	^ position >= readLimit
		ifFalse: [collection at: (position _ position + 1)]! !
!StandardFileStream methodsFor: 'read, write, position' stamp: 'jmv 11/17/2016 10:00:56' prior: 16913098!
   basicNext
	"Answer the next byte from this file, or nil if at the end of the file."
	
	| count |
	collection ifNotNil: [
		position < readLimit 
			ifFalse: [ 
				readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.
				position := 0.
				readLimit = 0 ifTrue: [ ^nil ] ].
		^collection at: (position := position + 1) ].	
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	^count = 1
		ifTrue: [ buffer1 at: 1 ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2978-RemoveObsoletePrimCalls-JuanVuletich-2016Nov17-10h26m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2977] on 17 November 2016 at 10:31:18 am'!

Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOReadStream category: #'System-Support'!
Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!
!StdIOReadStream commentStamp: '<historical>' prior: 0!
     Standard Input Stream.

A basic problem/restriction with this code is that currently the VM runs multiple VM threads within a single OS thread.

This means that waiting on StdIn blocks the VM, suspending all Smalltalk code.!

Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOWriteStream category: #'System-Support'!
Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'System-Support'!
!StdIOWriteStream commentStamp: '<historical>' prior: 0!
               Standard Output/Error Streams.!
!StdIOReadStream methodsFor: 'open / close' stamp: 'jmv 11/17/2016 10:12:24'!
                  openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID _ aFileID.
	name _ streamName.
	buffer1 _ String new: 1! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 10:01:57'!
                          next
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!"

	| count |
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	^count = 1
		ifTrue: [ buffer1 at: 1 ]! !
!StdIOReadStream methodsFor: 'printing' stamp: 'jmv 11/17/2016 09:47:10'!
                     printOn: aStream
	"Put a printed version of the receiver onto aStream."

	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !
!StdIOReadStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 09:45:28'!
    primRead: id into: byteArray startingAt: startIndex count: count
	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."

	<primitive: 'primitiveFileRead' module: 'FilePlugin'>
	self error: 'File read failed'! !
!StdIOReadStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 09:46:36'!
               stdin
	| newSelf |
	newSelf _ self basicNew.
	newSelf 
		openOnHandle: self stdinHandle 
		name: 'stdin'.
	^newSelf! !
!StdIOReadStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:47'!
                        stdinHandle

	^ StdIOWriteStream stdioHandles at: 1! !
!StdIOWriteStream methodsFor: 'open / close' stamp: 'jmv 11/17/2016 10:14:32'!
                          openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID _ aFileID.
	name _ streamName.
	buffer1 _ String new: 1! !
!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 10:19:51'!
                         flush
	"Flush pending changes"
	^self primFlush: fileID! !
!StdIOWriteStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 10:18:42'!
                         nextPut: char
	"Write the given character to this file."

	buffer1 at: 1 put: char.
	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.
	^ char
! !
!StdIOWriteStream methodsFor: 'printing' stamp: 'jmv 11/17/2016 09:35:56'!
                       printOn: aStream
	"Put a printed version of the receiver onto aStream.  1/31/96 sw"

	aStream nextPutAll: self class name; nextPutAll: ': '; print: name! !
!StdIOWriteStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 10:20:17'!
                       primFlush: id
	"Flush pending changes to the disk"

	<primitive: 'primitiveFileFlush' module: 'FilePlugin'>! !
!StdIOWriteStream methodsFor: 'primitives' stamp: 'jmv 11/17/2016 10:19:14'!
    primWrite: id from: stringOrByteArray startingAt: startIndex count: count
	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."

	<primitive: 'primitiveFileWrite' module: 'FilePlugin'>
	(FileWriteError fileName: name)
		signal: (self closed
			ifTrue: [ 'File [', name, '] is closed' ]
			ifFalse: [ 'File [', name, '] write failed' ])! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 10:15:08'!
stderr
	| newSelf |
	newSelf _ self basicNew.
	newSelf 
		openOnHandle: self stderrHandle 
		name: 'stderr'.
	^newSelf! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 10:15:11'!
            stdout
	| newSelf |
	newSelf _ self basicNew.
	newSelf 
		openOnHandle: self stdoutHandle 
		name: 'stdout'.
	^newSelf! !
!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:20'!
                    stderrHandle

	^ self stdioHandles at: 3! !
!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:09'!
  stdioHandles
" answer handles: #(stdin stdout stderr) "
	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: ec>
	self primitiveFailed! !
!StdIOWriteStream class methodsFor: 'accessing' stamp: 'jmv 11/17/2016 09:26:12'!
                    stdoutHandle

	^ self stdioHandles at: 2! !

Smalltalk removeClassNamed: #StdIOFileStream!

Smalltalk removeClassNamed: #StdIOFileStream!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2979-NewStdIO-JuanVuletich-2016Nov17-10h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2979] on 17 November 2016 at 10:51:20 am'!
!StdIOWriteStream methodsFor: 'character writing' stamp: 'jmv 11/17/2016 10:48:18'!
                              newLine
	"Append a newLine character to the receiver.
	The Cuis convention is to use lf on output."

	self nextPut: Character newLineCharacter! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2980-stdout-newLine-JuanVuletich-2016Nov17-10h48m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2980] on 17 November 2016 at 11:51:03 am'!

Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked '
	classVariableNames: 'StdIn '
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOReadStream category: #'System-Support'!
Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked'
	classVariableNames: 'StdIn'
	poolDictionaries: ''
	category: 'System-Support'!

Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position '
	classVariableNames: 'StdOut StdErr '
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOWriteStream category: #'System-Support'!
Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1 collection readLimit position'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'System-Support'!
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:28:43'!
                    peek
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!
	
	Do not advance the stream!!"

	"Multiple calls to #peek don't make new reads"
	peeked ifFalse: [
		self privateRead.
		peeked _ true ].

	"peeked is always true on exit"
	^buffer1 at: 1! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:33:22'!
                 peekFor: aCharacter 
	"Answer false and do not move over the next element if it is not equal to the argument, aCharacter 
	Answer true and increment the position for accessing elements, if the next element is equal to anObject."

	| nextChar |
	nextChar _ self peek.
	aCharacter = nextChar ifTrue: [
		self next.
		^ true].
	^ false! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:24:52'!
     privateRead
	"Read one Character.
	Private."
	| count |
	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.
	count = 1 ifFalse: [ buffer1 at: 1 put: nil ]! !
!StdIOReadStream class methodsFor: 'cached state access' stamp: 'jmv 11/17/2016 11:45:00'!
                      releaseClassCachedState

	StdIn _ nil! !
!StdIOWriteStream methodsFor: 'character writing' stamp: 'jmv 11/17/2016 11:08:02'!
   space
	"Append a space character to the receiver."

	self nextPut: Character space! !
!StdIOWriteStream class methodsFor: 'cached state access' stamp: 'jmv 11/17/2016 11:44:50'!
              releaseClassCachedState

	StdOut _ nil.
	StdErr _ nil! !
!StdIOReadStream methodsFor: 'open / close' stamp: 'jmv 11/17/2016 11:13:30' prior: 50332252!
         openOnHandle: aFileID name: streamName
	"Initialize the instance with the given file handle.
	 N.B. Do _not_ register the stream.  We do not want it to be
	 closed implicitly (e.g. on GC).  There may be multiple instances
	 accessing the same stream.  The stream is not a file."

	fileID _ aFileID.
	name _ streamName.
	buffer1 _ String new: 1.
	peeked _ false! !
!StdIOReadStream methodsFor: 'streaming' stamp: 'jmv 11/17/2016 11:28:44' prior: 50332266!
                         next
	"Answer the next byte from this stream, or wait until one becomes available.
	Warning: all Smalltalk processes are essentially suspended until that happens!!"

	"If last call was #peek, not #next, then just answer cached value."
	peeked
		ifFalse: [ self privateRead ]
		ifTrue: [ peeked _ false ].

	"peeked is always false on exit"
	^buffer1 at: 1! !
!StdIOReadStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:45:39' prior: 50332298!
                stdin
	StdIn ifNil: [
		StdIn _ self basicNew.
		StdIn 
			openOnHandle: self stdinHandle 
			name: 'stdin' ].
	^StdIn! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:46:13' prior: 50332367!
                            stderr
	StdErr ifNil: [
		StdErr _ self basicNew.
		StdErr 
			openOnHandle: self stderrHandle 
			name: 'stderr' ].
	^StdErr! !
!StdIOWriteStream class methodsFor: 'instance creation' stamp: 'jmv 11/17/2016 11:46:37' prior: 50332374!
                     stdout
	StdOut ifNil: [
		StdOut _ self basicNew.
		StdOut 
			openOnHandle: self stdoutHandle 
			name: 'stdout' ].
	^StdOut! !

Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked'
	classVariableNames: 'StdIn'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOReadStream category: #'System-Support'!
Stream subclass: #StdIOReadStream
	instanceVariableNames: 'fileID name buffer1 peeked'
	classVariableNames: 'StdIn'
	poolDictionaries: ''
	category: 'System-Support'!

Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'System-Support'!

!classDefinition: #StdIOWriteStream category: #'System-Support'!
Stream subclass: #StdIOWriteStream
	instanceVariableNames: 'fileID name buffer1'
	classVariableNames: 'StdErr StdOut'
	poolDictionaries: ''
	category: 'System-Support'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2981-StdIn-peek-peekFor-JuanVuletich-2016Nov17-11h08m-jmv.1.cs.st----!

----SNAPSHOT----#(17 November 2016 12:32:56.842092 pm) Cuis5.0-2981-spur.image priorSource: 186!

----QUIT----#(17 November 2016 12:33:29.990717 pm) Cuis5.0-2981-spur.image priorSource: 29844!

----STARTUP----#(14 December 2016 2:31:49.510252 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-2981-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 17 November 2016 at 5:11:35 pm'!
!SequenceableCollection methodsFor: 'copying' stamp: 'jmv 11/17/2016 17:08:04' prior: 16906186!
               copyReplaceFrom: start to: stop with: replacementCollection 
	"Answer a copy of the receiver satisfying the following conditions: 
	+ stop is less than start, then this is an insertion; stop should be exactly start-1, 
	+ start = 1 means insert before the first character,
	+ start = size+1 means append after last character. 
	+ Otherwise, this is a replacement; start and stop have to be within the receiver's bounds."

	| newSequenceableCollection newSize endReplacement |
	newSize _ self size - (stop - start + 1) + replacementCollection size.
	endReplacement _ start - 1 + replacementCollection size.
	newSequenceableCollection _ self species new: newSize.
	start > 1 ifTrue:[
		newSequenceableCollection
			replaceFrom: 1
			to: start - 1
			with: self
			startingAt: 1].
	start <= endReplacement ifTrue:[
		newSequenceableCollection
			replaceFrom: start
			to: endReplacement
			with: replacementCollection
			startingAt: 1].
	endReplacement < newSize ifTrue:[
		newSequenceableCollection
			replaceFrom: endReplacement + 1
			to: newSize
			with: self
			startingAt: stop + 1].
	^newSequenceableCollection! !
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 11/17/2016 16:54:39' prior: 16903350!
        setAttributesFromRanges: ranges

	formattedText removeAttributesThat: [ :attribute | attribute isForShout ].

	"Optimize for mutation speed unless method is really large but with very few distict elements:
	Source code that includes just big literals is better served by conventional Text+RunArray"
	"Do it only if we are not breaking textModel!! (for instance, StyledTextEditor asks for formatting just sections, not whole #actualContents)."
	formattedText == textModel actualContents ifTrue: [
		(formattedText size > 2000 and: [ ranges size < 50 ]) ifFalse: [
			formattedText _ formattedText optimizedForMutationSpeed.
			textModel basicActualContents: formattedText ]].

	ranges do: [ :range |

		"Smalltalk text styling"
		(self attributesFor: range rangeType) ifNotNil: [ :attributes |
			attributes do: [ :each |
				formattedText addAttribute: each from: range start to: range end ]].

		"Show as subscripts if appropriate."
		(classOrMetaClass isNil or: [
			classOrMetaClass theNonMetaClass lastUnderscoreMeansSubscript]) ifTrue: [
				(#( instVar classVar globalVar workspaceVar poolConstant
					patternArg methodArg patternTempVar tempVar		
					blockPatternArg blockArg blockPatternTempVar blockTempVar 
					incompleteIdentifier undefinedIdentifier) pointsTo: range rangeType )
						ifTrue: [
							formattedText lastIndexOf: $_ startingAt: range end endingAt: range start do: [ :i |
								formattedText addAttribute: ShoutTextEmphasis subscript from: i to: range end ] ]]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2982-CodeColorizerFix-JuanVuletich-2016Nov17-17h08m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 17 November 2016 at 5:18:27 pm'!
!DummyStream methodsFor: 'as yet unclassified' stamp: 'KenD 11/5/2016 16:17:09'!
           space! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2983-DummyStream-space-KenDickey-2016Nov17-17h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 18 November 2016 at 10:49:39 am'!
!TheWorldMenu methodsFor: 'construction' stamp: 'jmv 5/3/2015 10:19' prior: 16935004!
                       newMorph
	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."
	| menu subMenu catDict shortCat class |
	menu _ self menu: 'Add a new morph'.
	menu

		add: 'From Clipboard'
		target: myHand
		action: #pasteMorph;
		
		add: 'From Alphabetical List'
		subMenu: self alphabeticalMorphMenu.
	menu addLine.
		
	"Add 'Classic' New Morph menu"
	catDict _ Dictionary new.
	SystemOrganization categories do: [ :cat |
		((cat beginsWith: 'Morphic-') and: [ (#('Morphic-Menus' 'Morphic-Support' ) includes: cat) not ]) ifTrue: [
			shortCat _ (cat
				copyFrom: 'Morphic-' size + 1
				to: cat size).
			(SystemOrganization listAtCategoryNamed: cat) do: [ :cName |
				class _ Smalltalk at: cName.
				((class inheritsFrom: Morph) and: [ class includeInNewMorphMenu ]) ifTrue: [
					(catDict includesKey: shortCat)
						ifTrue: [ (catDict at: shortCat) addLast: class ]
						ifFalse: [
							catDict
								at: shortCat
								put: (OrderedCollection with: class) ]]]]].
	catDict keys sort do: [ :categ |
		subMenu _ MenuMorph new.
		((catDict at: categ) asArray sort: [ :c1 :c2 |
			c1 name < c2 name ]) do: [ :cl |
			subMenu
				add: cl name
				target: self
				selector: #newMorphOfClass:event:
				argument: cl ].
		menu
			add: categ
			subMenu: subMenu ].

	self doPopUp: menu.! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2984-NewMorphMenuFix-JuanVuletich-2016Nov18-10h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2984] on 30 November 2016 at 2:56:21 pm'!
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 11/30/2016 14:52:08'!
     with: otherCollection with: thirdCollection collect: threeArgBlock
	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."
	| n result |
	n _ self size.
	otherCollection size = n ifFalse: [ self error: 'otherCollection must be the same size' ].
	thirdCollection size = n ifFalse: [ self error: 'thirdCollection must be the same size' ].
	result _ self species new: n.
	1 to: n do: [ :index | 
		result at: index put:
			(threeArgBlock
				value: (self at: index)
				value: (otherCollection at: index)
				value: (thirdCollection at: index) )].
	^ result! !
!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 11/25/2016 12:15:27'!
                     with: otherCollection with: thirdCollection do: threeArgBlock 
	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."
	| n |
	n _ self size.
	otherCollection size = n ifFalse: [self error: 'otherCollection must be the same size'].
	thirdCollection size = n ifFalse: [self error: 'thirdCollection must be the same size'].
	1 to: n do: [ :index |
		threeArgBlock
			value: (self at: index)
			value: (otherCollection at: index)
			value: (thirdCollection at: index)]! !
!OrderedCollection methodsFor: 'enumerating' stamp: 'jmv 11/30/2016 14:51:19'!
                      with: otherCollection with: thirdCollection collect: threeArgBlock
	"Collect and return the result of evaluating twoArgBlock with 
	corresponding elements from this collection and otherCollection."
	| result |
	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].
	result _ self species new: self size.
	1 to: self size do: [ :index |
		result addLast:
			(threeArgBlock
				value: (self at: index)
				value: (otherCollection at: index)
				value: (thirdCollection at: index) )].
	^ result! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2985-withwithdo-withwithdcollect-JuanVuletich-2016Nov30-14h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2984] on 30 November 2016 at 3:22:11 pm'!
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/30/2016 15:04:11'!
                         += anObject
	^anObject isNumber
		ifTrue: [ self replace: [ :v | v + anObject ]]
		ifFalse: [
			self withIndexDo: [ :v :i |
				self at: i put: ((self at: i) + (anObject at: i)) ]]! !
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/25/2016 11:41:25'!
                -= anObject
	^anObject isNumber
		ifTrue: [ self replace: [ :v | v - anObject ]]
		ifFalse: [
			self withIndexDo: [ :v :i |
				self at: i put: ((self at: i) - (anObject at: i)) ]]! !
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/30/2016 15:21:00'!
                derivative
	| displaced answer |
	displaced _ self class new: self size.
	displaced replaceFrom: 2 to: self size with: self startingAt: 1.
	displaced at: 1 put: self first - self first.	"Some reasonable zero"
	answer _ self copy.
	answer -= displaced.
	^answer! !
!SequenceableCollection methodsFor: 'math functions' stamp: 'jmv 11/29/2016 14:23:32'!
 integral
	| answer |
	answer _ self copy.
	2 to: answer size do: [ :i |
		answer at: i put: (answer at: i) + (answer at: i-1) ].
	^answer! !

FloatArray removeSelector: #derivative!

FloatArray removeSelector: #derivative!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2986-Collection-derivative-integral-JuanVuletich-2016Nov30-14h56m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 8:42:22 am'!
!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:39'!
        step
	(target isNil or: [target isInWorld not]) ifTrue: [self delete]! !
!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:41'!
                       stepTime
	^ 100! !
!HaloMorph methodsFor: 'stepping' stamp: 'len 7/25/2016 21:38'!
             wantsSteps
	^ true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2987-DeleteHaloWhenMorphIsDeleted-LucianoEstebanNotarfrancesco-2016Nov26-08h41m-len.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 8:46:53 am'!
!MenuMorph methodsFor: 'keyboard control' stamp: 'len 6/11/2016 20:40' prior: 16867064!
           keyboardFocusChange: aBoolean
	"Notify change due to green border for keyboard focus"

	aBoolean ifFalse: [self deleteIfPopUp: nil].
	self redrawNeeded! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2988-AvoidManuesHangingAround-LucianoEstebanNotarfrancesco-2016Nov26-08h42m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 8:52:37 am'!
!SequenceableCollection methodsFor: 'copying' stamp: 'len 4/18/2016 22:08'!
                      shuffledBy: aGenerator
	"To answer a mutable collection when receiver is, for example, an Interval."
	^ (self collect: [ :each | each ]) shuffleBy: aGenerator! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2989-ShuffledBy-LucianoEstebanNotarfrancesco-2016Nov26-08h46m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:02:48 am'!
!SystemDictionary methodsFor: 'browsing' stamp: 'len 6/9/2016 23:23'!
   browseAllPrimitives
	self browseAllSelect: [:each| each primitive ~= 0 and: [(each primitive between: 256 and: 291) not]]
! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2990-SmalltalkBrowseAllPrimitives-LucianoEstebanNotarfrancesco-2016Nov26-08h52m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:03:51 am'!
!SystemDictionary methodsFor: 'retrieving' stamp: 'len 11/26/2016 09:03:25' prior: 16921461!
                              allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."
	"Answer a Collection of all the methods that call on aLiteral."
	| aCollection special aList byte |

	#(23 48 'fred' (new open:label:)) size.
"Example above should find #open:label:, though it is deeply embedded here."

	aCollection _ OrderedCollection new.
	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte _ b ].
	self allBehaviorsDo: [:class |
		aList _ class whichSelectorsReferTo: aLiteral special: special byte: byte.
		aList do: [ :sel |
			"For special selectors, look for the literal in the source code.
			Otherwise, for example, searching for senders of #== will include senders of #ifNil.
			Except for #at:put:, because it has two arguments and won't find it in the source code like that."
			(byte isNil or: [aLiteral = #at:put: or: [
				((class sourceCodeAt: sel)
					findString: aLiteral) > 0]]) ifTrue: [

				aCollection add: (
					MethodReference new
						setStandardClass: class 
						methodSymbol: sel
				)
			]
		]
	].
	^ aCollection! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2991-SendersOfatput-LucianoEstebanNotarfrancesco-2016Nov26-09h02m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:06:05 am'!
!String methodsFor: 'testing' stamp: 'len 11/26/2016 09:05:35'!
         isAlphaNumeric
	"Answer true if the receiver contains only letters or digits."
	^ self allSatisfy: [:each| each isAlphaNumeric]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2992-StringisAlphaNumeric-LucianoEstebanNotarfrancesco-2016Nov26-09h03m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 26 November 2016 at 9:08:39 am'!
!Form methodsFor: 'fileIn/Out' stamp: 'len 8/1/2016 08:13' prior: 16847779!
                  printOn: aStream
	aStream isText
		ifTrue:
			[aStream withAttribute: (TextAnchor new anchoredFormOrMorph: self) do: [aStream nextPut: $*].
			^ self].
	aStream
		nextPutAll: self class name;
		nextPut: $(; print: width;
		nextPut: $x; print: height;
		nextPut: $x; print: depth;
		nextPut: $)! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2993-FormPrintOnTextForWorkspaces-LucianoEstebanNotarfrancesco-2016Nov26-09h06m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2993] on 5 December 2016 at 8:17:22 am'!
!Morph methodsFor: 'printing' stamp: 'jmv 12/5/2016 08:16:19' prior: 16876467!
  printOn: aStream 
	"Add the identity of the receiver to a stream"
	aStream isText
		ifTrue: [
			aStream
				withAttribute: (TextAnchor new anchoredFormOrMorph: (owner ifNil: [self] ifNotNil: [self imageForm:32]))
				do: [ aStream nextPut: $* ].
			^ self].
	super printOn: aStream. "a(n) className"
	aStream 
		nextPut: $(;
		print: self identityHash;
		nextPut: $).
	self valueOfProperty: #morphName ifPresentDo: [ :x | aStream nextPutAll: x asString]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2994-MorphPrintOnTextEnh-JuanVuletich-2016Dec05-08h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2994] on 5 December 2016 at 9:46:02 am'!
!Integer methodsFor: 'comparing' stamp: 'len 12/5/2016 09:46:00' prior: 16859447!
                       hash
	"Hash is reimplemented because = is implemented.
	| s |
	s _ (1 to: 10000) asSet.
	[s includes: 123456] bench
	"

	^self hashMultiply! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

Set rehashAllSets!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2995-Integer-hash-LucianoEstebanNotarfrancesco-2016Dec05-09h39m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2986] on 2 December 2016 at 4:40:51 pm'!
!Form methodsFor: 'scaling, rotation' stamp: 'jmv 12/2/2016 15:47:08' prior: 16848280!
                         flippedBy: direction
	"Return a copy of the receiver flipped either #vertical, #horizontal or #both. (#both is a 180 degrees rotation)
	Form lena display.
	(Form lena flippedBy: #vertical) display.
	(Form lena flippedBy: #horizontal) display.
	(Form lena flippedBy: #both) display.
	"
	| newForm quad |
	newForm _ self class extent: self extent depth: depth.
	quad _ self boundingBox innerCorners.
	quad _ (
		direction caseOf: {
			[ #vertical ] 		-> [#(2 1 4 3)].
			[ #horizontal ] 	-> [#(4 3 2 1)].
			[ #both ] 			-> [#(3 4 1 2)]})
		collect: [:i | quad at: i].
	(WarpBlt toForm: newForm)
		sourceForm: self;
		colorMap: (self colormapIfNeededFor: newForm);
		combinationRule: 3;
		copyQuad: quad toRect: newForm boundingBox.
"	newForm offset: (self offset flippedBy: direction centerAt: aPoint)."
	^ newForm
"
[Sensor isAnyButtonPressed] whileFalse:
	[((Form fromDisplay: (Sensor mousePoint extent: 130@66))
			flippedBy: #vertical centerAt: 0@0) display]
"
"Consistency test...
 | f f2 p |
[ Sensor isAnyButtonPressed ] whileFalse: [
	f _ Form fromDisplay: ((p _ Sensor mousePoint) extent: 31@41).
	Display fillBlack: (p extent: 31@41).
	f2 _ f flippedBy: #vertical centerAt: 0@0.
	(f2 flippedBy: #vertical centerAt: 0@0) displayAt: p ]
"! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2996-Form-FlippedBy-both-JuanVuletich-2016Dec02-15h42m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2996] on 9 December 2016 at 9:12:18 am'!
!StringMorph methodsFor: 'initialization' stamp: 'jmv 12/9/2016 09:09:45' prior: 16918230!
                       initialize
	super initialize.
	font _ nil.
	emphasis _ 0.
	self contents: 'String Morph'
! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2997-StringMorph-fix-JuanVuletich-2016Dec09-09h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 29 November 2016 at 9:10:32 pm'!
!OrderedCollection methodsFor: 'converting' stamp: 'len 11/29/2016 08:54:14'!
           asNewArray
	^ array copyFrom: firstIndex to: lastIndex! !
!OrderedCollection class methodsFor: 'instance creation' stamp: 'len 11/28/2016 19:18:39'!
           newFrom: aCollection
	"Create a new collection containing all the elements from aCollection"

	^(self new: aCollection size)
		resetTo: 1;
		addAll: aCollection;
		yourself! !
!OrderedCollection methodsFor: 'enumerating' stamp: 'len 11/28/2016 10:50:21' prior: 16883972!
                 collect: aBlock 
	"Evaluate aBlock with each of my elements as the argument. Collect the 
	resulting values into a collection that is like me. Answer the new 
	collection. Override superclass in order to use addLast:, not at:put:."

	| newCollection |
	newCollection _ self species new: self size.
	newCollection resetTo: 1.
	firstIndex to: lastIndex do: [ :index |
		newCollection addLast: (aBlock value: (array at: index))].
	^ newCollection! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2998-OrderedCollectionTweaks-LucianoEstebanNotarfrancesco-2016Nov26-09h08m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2995] on 6 December 2016 at 8:16:54 pm'!

RectangleLikeMorph subclass: #ResizeMorph
	instanceVariableNames: 'gridLineWidth gridColor selectionColor outlineMorph grid from to action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #ResizeMorph category: #'Morphic-Views'!
RectangleLikeMorph subclass: #ResizeMorph
	instanceVariableNames: 'gridLineWidth gridColor selectionColor outlineMorph grid from to action'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!
!SystemWindow methodsFor: 'resize/collapse' stamp: 'bp 10/18/2015 12:18'!
             resize
	| resizeMorph |
	resizeMorph _ ResizeMorph new morphExtent: 200@150.
	resizeMorph action: [self resize: (resizeMorph selectionRectangle: Display extent)].
	resizeMorph morphPosition: self world activeHand morphPosition.
	resizeMorph openInWorld
	! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 22:22'!
                 action: aBlock
	action _ aBlock! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/18/2015 18:00'!
                drawGridOn: aCanvas
	0 to: grid x do: [:i |
		| x |
		x _ i * (extent x - gridLineWidth) / grid x.
		aCanvas line: x @ 0 to: x @ (extent y - 2) width: gridLineWidth color: gridColor].
	0 to: grid y do: [:i |
		| y |
		y _ i * (extent y - gridLineWidth) / grid y.
		aCanvas line: 0 @ y to: (extent x - 2) @ y width: gridLineWidth color: gridColor]! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:02'!
                     drawOn: aCanvas
	super drawOn: aCanvas.
	from ifNotNil: [aCanvas fillRectangle: (self selectionRectangle: extent) color: selectionColor].
	self drawGridOn: aCanvas! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 19:00'!
            grid: aPoint
	grid _ aPoint! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 19:00'!
                    handlesMouseDown: aMouseButtonEvent
	^true! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:51'!
     initialize
	super initialize.
	extent _ 400@300.
	color _ Color white.
	grid _ 8@6.
	gridLineWidth _ 2.
	gridColor _ Color black.
	selectionColor _ Color red! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:18'!
                  mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	from _ self toGridPoint: localEventPosition.
	outlineMorph _ BorderedRectMorph new
		borderColor: Color black;
		color: Color transparent;
		openInWorld;
		hide.
	self selectTo: localEventPosition! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:17'!
    mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition
	self selectTo: localEventPosition.
	outlineMorph delete.
	action ifNotNil: [
		action value.
		self delete]! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 21:32'!
                               mouseMove: aMouseButtonEvent localPosition: localEventPosition
	self selectTo: localEventPosition! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 21:25'!
              printOn: aStream
	super printOn: aStream.
	aStream space; print: from; space; print: to! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:14'!
                        selectTo: localEventPosition
	| newTo |
	newTo _ self toGridPoint: localEventPosition.
	newTo ~= to ifTrue: [
		to _ newTo.
		self redrawNeeded.
		self updateOutlineMorph]! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:35'!
    selectionRectangle: aRectangle
	^(from corner: to + 1) scaledBy: aRectangle // grid! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:34'!
                            toGridPoint: aPoint
	^(aPoint min: extent - 1) // (extent // grid)! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:15'!
             updateOutlineMorph
	| rectangle |
	rectangle _ self selectionRectangle: Display extent.
	outlineMorph
		morphPosition: rectangle origin extent: rectangle extent;
		show! !
!SystemWindow methodsFor: 'menu' stamp: 'bp 10/11/2015 21:42' prior: 16926424!
     buildWindowMenu

	| aMenu |

	aMenu _ MenuMorph new defaultTarget: self.

	aMenu 
		add: 'change title...' action: #relabel;
		add: 'window color...' action: #setWindowColor;
		addLine;
		add: 'send to back' action: #sendToBack;
		add: 'make next-to-topmost' action: #makeSecondTopmost;
		addLine;
		add: (self isSticky ifTrue: [ 'make draggable' ] ifFalse: [ 'make undraggable' ]) action: #toggleStickiness;
		addLine;
		add: 'close' action: #delete;
		add: 'collapse' action: #collapse;
		add: 'expand / contract' action: #expandBoxHit;
		addLine;
		add: 'resize...' action: #resize;
		add: 'resize full' action: #resizeFull;
		add: 'resize top' action: #resizeTop;
		add: 'resize left' action: #resizeLeft;
		add: 'resize bottom' action: #resizeBottom;
		add: 'resize right' action: #resizeRight;
		add: 'resize top left' action: #resizeTopLeft;
		add: 'resize top right' action: #resizeTopRight;
		add: 'resize bottom left' action: #resizeBottomLeft;
		add: 'resize bottom right' action: #resizeBottomRight.

	^ aMenu! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/2999-ResizeMorph-BernhardPieber-2016Dec06-20h13m-bp.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2981] on 9 December 2016 at 10:27:21 am'!
!PasteUpMorph methodsFor: 'printing' stamp: 'jmv 12/9/2016 10:25:13' prior: 16887389!
  printOn: aStream
	"Reimplemented to add a tag showing that the receiver is currently functioning as a 'world', if it is"

	self isWorldMorph
		ifTrue: [aStream nextPutAll: ' [world]']
		ifFalse: [super printOn: aStream]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3000-PasteUpMorph-print-fix-JuanVuletich-2016Dec09-10h25m-jmv.1.cs.st----!

----SNAPSHOT----#(14 December 2016 2:32:05.602236 pm) Cuis5.0-3000-spur.image priorSource: 29942!

----QUIT----#(14 December 2016 2:32:40.672866 pm) Cuis5.0-3000-spur.image priorSource: 54545!

----STARTUP----#(19 December 2016 1:35:02.293384 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3000-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3000] on 15 December 2016 at 12:11:15 pm'!
!Point methodsFor: 'printing' stamp: 'jmv 12/15/2016 10:20:58'!
                 printStringFractionDigits: placesDesired
	^(x printStringFractionDigits: placesDesired), '@', (y printStringFractionDigits: placesDesired)! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3001-Point-printStringFractionDigits-JuanVuletich-2016Dec15-10h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3000] on 16 December 2016 at 3:13:12 pm'!
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 12/16/2016 15:05:52' prior: 16924259!
                             browseMyChanges
	"Browse only the changes (in the changes file) by the current author.
	Smalltalk browseMyChanges
	"
	self browseAllSelect: [ :method |
       method fileIndex > 1 "only look at changes file"
               and: [ method timeStamp beginsWith: Utilities authorInitials, ' ' ]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3002-BrowseMyChanges-fix-JuanVuletich-2016Dec16-15h03m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3002] on 19 December 2016 at 12:44:03 pm'!
!CompiledMethod methodsFor: 'accessing' stamp: 'jmv 12/17/2016 22:38:52' prior: 16819446!
                initialPC
	"Answer the program counter for the receiver's first bytecode."
	^ (self numLiterals + 1) * Smalltalk wordSize + 1! !
!SystemDictionary methodsFor: 'memory space' stamp: 'jmv 12/17/2016 22:37:27' prior: 16920388!
lowSpaceThreshold 
	"Answer the low space threshold. When the amount of free memory (after garbage collection)
	 falls below this limit, the system is in serious danger of completely exhausting memory and
	 crashing. This limit should be made high enough to allow the user open a debugger to diagnose
	 a problem or to save the image.  In a stack-based VM such as Cog contexts for activations in
	 the stack zone will have to be created as the debugger opens, requiring additional headroom."

	| slotsForDebugger slotsForContextsOnStackPages |
	slotsForDebugger := 65536. "Arbitrary guess"
	slotsForContextsOnStackPages :=
		(self vmParameterAt: 42)
			ifNil: [0]
			ifNotNil:
				[:numStackPages| | headerSize numActivationsPerPage maxContextSize |
				numActivationsPerPage := 40. "Design goal of the Cog VM"
				headerSize := 2. "64-bytes for Spur"
				maxContextSize := MethodContext instSize + CompiledMethod fullFrameSize + headerSize.
				numStackPages * numActivationsPerPage * maxContextSize].
	^slotsForDebugger + slotsForContextsOnStackPages * self wordSize! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3003-FixFor64BitSpur-JuanVuletich-2016Dec19-12h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3002] on 19 December 2016 at 12:54:39 pm'!
!Parser methodsFor: 'primitives' stamp: 'nice 9/6/2013 00:48' prior: 16885817!
                      externalFunctionDeclaration
	"Parse the function declaration for a call to an external library."
	| descriptorClass callType modifier retType externalName args argType module fn |
	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent: [ ^ false ].
	callType := descriptorClass callingConventionFor: here.
	callType == nil ifTrue:[^false].
	[modifier := descriptorClass callingConventionModifierFor: token.
	 modifier notNil] whileTrue:
		[self advance.
		 callType := callType bitOr: modifier].
	"Parse return type"
	self advance.
	retType := self externalType: descriptorClass.
	retType == nil ifTrue:[^self expected:'return type'].
	"Parse function name or index"
	externalName := here.
	(self match: #string) 
		ifTrue:[externalName := externalName asSymbol]
		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].
	(self match: #leftParenthesis) ifFalse:[^self expected:'argument list'].
	args := WriteStream on: Array new.
	[self match: #rightParenthesis] whileFalse:[
		argType := self externalType: descriptorClass.
		argType == nil ifTrue:[^self expected:'argument'].
		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType]].
	(self matchToken: 'module:') ifTrue:[
		module := here.
		(self match: #string) ifFalse:[^self expected: 'String'].
		module := module asSymbol].
	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|
		fn := xfn name: externalName 
				module: module 
				callType: callType
				returnType: retType
				argumentTypes: args contents.
		self allocateLiteral: fn].
	(self matchToken: 'error:')
		ifTrue:
			[| errorCodeVariable |
			 errorCodeVariable := here.
			(hereType == #string
			 or: [hereType == #word]) ifFalse:[^self expected: 'error code (a variable or string)'].
			 self advance.
			 self addPragma: (Pragma keyword: #primitive:error: arguments: (Array with: 120 with: errorCodeVariable)).
			 fn ifNotNil: [fn setErrorCodeName: errorCodeVariable]]
		ifFalse:
			[self addPragma: (Pragma keyword: #primitive: arguments: #(120))].
	^true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3004-externalFunctionDeclaration-JuanVuletich-2016Dec19-12h44m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3002] on 19 December 2016 at 1:08:36 pm'!

SmallInteger class
	instanceVariableNames: 'minVal maxVal '!

!classDefinition: 'SmallInteger class' category: #'Kernel-Numbers'!
SmallInteger class
	instanceVariableNames: 'minVal maxVal'!
!SmallInteger class methodsFor: 'class initialization' stamp: 'jmv 12/19/2016 13:03:09'!
                    initMinValAndMaxVal
	| next val |
	val := -32768. "Assume at least 16 bits"
	[next := val + val.
	 next class == self] whileTrue:
		[val := next].
	minVal := val.
	maxVal := -1 - val! !
!SystemDictionary methodsFor: 'image' stamp: 'jmv 12/19/2016 13:04:12' prior: 16925538!
              wordSize
	"Answer the size in bytes of an object pointer or word in the object memory.
	The value does not change for a given image, but may be modified by a SystemTracer
	when converting the image to another format. The value is cached in WordSize to
	avoid the performance overhead of repeatedly consulting the VM."

	"Smalltalk wordSize"

	^ WordSize ifNil: [
		SmallInteger initMinValAndMaxVal.
		WordSize := [self vmParameterAt: 40] on: Error do: [4]]! !

SmallInteger class
	instanceVariableNames: 'minVal maxVal'!

!classDefinition: 'SmallInteger class' category: #'Kernel-Numbers'!
SmallInteger class
	instanceVariableNames: 'minVal maxVal'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
SmallInteger initMinValAndMaxVal!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3005-SmallInteger-minVal-maxVal-part1-JuanVuletich-2016Dec19-12h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3005] on 19 December 2016 at 1:12:20 pm'!
!SmallInteger class methodsFor: 'constants' stamp: 'jmv 12/19/2016 13:06:38' prior: 16909182!
    maxVal
	"Answer the maximum value for a SmallInteger."

	"Ensure word size is properly set. If so, maxVal is also set."
	Smalltalk wordSize.
	^maxVal! !
!SmallInteger class methodsFor: 'constants' stamp: 'jmv 12/19/2016 13:07:24' prior: 16909186!
         minVal
	"Answer the minimum value for a SmallInteger."

	"Ensure word size is properly set. If so, minVal is also set."
	Smalltalk wordSize.
	^minVal! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3006-SmallInteger-minVal-maxVal-part2-JuanVuletich-2016Dec19-13h11m-jmv.1.cs.st----!

----SNAPSHOT----#(19 December 2016 1:35:11.847544 pm) Cuis5.0-3006-spur.image priorSource: 54644!

----QUIT----#(19 December 2016 1:35:24.272429 pm) Cuis5.0-3006-spur.image priorSource: 62581!

----STARTUP----#(19 December 2016 1:45:03.353057 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3006-spur.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3006] on 19 December 2016 at 1:42:27 pm'!
!SmallFloat64 commentStamp: '<historical>' prior: 16908181!
                  My instances represent 64-bit Floats whose exponent fits in 8 bits as immediate objects. This representation is only available on 64-bit systems, not 32-bit systems.!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
SmallFloat64 tryPrimitive: 161 withArgs: #(999).
!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3007-SmallFloat64-fixHash-forSpur64Conversion-JuanVuletich-2016Dec19-13h41m-jmv.1.cs.st----!

----SNAPSHOT----#(19 December 2016 1:45:10.081033 pm) Cuis5.0-3007-spur.image priorSource: 62680!

----QUIT----#(19 December 2016 1:45:27.503203 pm) Cuis5.0-3007-spur.image priorSource: 63733!

----STARTUP----#(19 December 2016 3:02:46.256654 pm) as /root/PayloadSoftware/ffi/Cuis5.0-3007-spur-64.image!


Display extent!

Display extent!

Display extent!

----QUIT----#(19 December 2016 3:04:52.716701 pm) Cuis5.0-3007-spur-64.image priorSource: 63832!

----STARTUP----#(27 December 2016 12:18:48.689655 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3007-spur-64.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3007] on 22 December 2016 at 4:05:04 pm'!
!LargePositiveInteger methodsFor: 'testing' stamp: 'nice 8/31/2008 00:07'!
                          isLarge
	^true! !
!SmallInteger methodsFor: 'testing' stamp: 'nice 8/31/2008 00:07'!
           isLarge
	^false! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/27/2015 23:01'!
                           long64At: index bigEndian: bigEndian
	"Return a 64-bit signed integer quantity starting from the given byte index."

	| value |
	value := self unsignedLong64At: index bigEndian: bigEndian.
	value digitLength < 8 ifTrue: [ ^value ].
	(value digitAt: 8) < 16r80 ifTrue: [ ^value ].
	^value - 16r10000000000000000! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/27/2015 22:57'!
                    long64At: index put: value bigEndian: bigEndian
	"Store a 64-bit signed integer quantity starting from the given byte index."
	
	^self
		unsignedLong64At: index
		put: (value negative
			ifFalse: [ value ]
			ifTrue: [ value + 16r10000000000000000 ])
		bigEndian: bigEndian! !
!ByteArray methodsFor: 'platform independent access' stamp: 'eem 2/22/2016 09:36'!
                        unsignedLong64At: index bigEndian: bigEndian
	"Return a 64-bit unsigned integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."

	| byte |
	SmallInteger maxVal >  1073741823 ifTrue:
		[bigEndian
			ifTrue: "64-bit SmallIntegers have a 3 bit tag and a sign bit, so the most positive value has 16rF as its top byte."
				[(byte := self at: index) <= 16rF ifTrue:
					[^((((((((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3)) bitShift: 8)
						+ (self at: index + 4) bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 7)]]
			ifFalse:
				[(byte := self at: index + 7) <= 16rF ifTrue:
					[^((((((((byte bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 4)) bitShift: 8)
						+ (self at: index + 3) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index)]]].
	bigEndian ifFalse: [
		(byte := self at: index + 7) = 0 ifFalse: [
			^(LargePositiveInteger new: 8)
				replaceFrom: 1 to: 8 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 6) = 0 ifFalse: [
			^(LargePositiveInteger new: 7)
				replaceFrom: 1 to: 7 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 5) = 0 ifFalse: [
			^(LargePositiveInteger new: 6)
				replaceFrom: 1 to: 6 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 4) = 0 ifFalse: [
			^(LargePositiveInteger new: 5)
				replaceFrom: 1 to: 5 with: self startingAt: index;
				normalize ].
		(byte := self at: index + 3) <= 16r3F ifFalse: [
			^(LargePositiveInteger new: 4)
				replaceFrom: 1 to: 4 with: self startingAt: index;
				normalize ].
		^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index) ].
	(byte := self at: index) = 0 ifFalse: [
		^(LargePositiveInteger new: 8)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: (self at: index + 2);
			digitAt: 7 put: (self at: index + 1);
			digitAt: 8 put: byte;
			normalize ].
	(byte := self at: index + 1) = 0 ifFalse: [	
		^(LargePositiveInteger new: 7)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: (self at: index + 2);
			digitAt: 7 put: byte;
			normalize ].
	(byte := self at: index + 2) = 0 ifFalse: [	
		^(LargePositiveInteger new: 6)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: (self at: index + 3);
			digitAt: 6 put: byte;
			normalize ].
	(byte := self at: index + 3) = 0 ifFalse: [	
		^(LargePositiveInteger new: 5)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: (self at: index + 4);
			digitAt: 5 put: byte;
			normalize ].		
	(byte := self at: index + 4) <= 16r3F ifFalse: [
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 7);
			digitAt: 2 put: (self at: index + 6);
			digitAt: 3 put: (self at: index + 5);
			digitAt: 4 put: byte;
			normalize ].
	^(((byte bitShift: 8) + (self at: index + 5) bitShift: 8) + (self at: index + 6) bitShift: 8) + (self at: index + 7)! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/9/2015 20:18'!
        unsignedLong64At: index put: value bigEndian: bigEndian
	"Store a 64-bit unsigned integer quantity starting from the given byte index"
	
	| i j |
	value isLarge ifTrue: [
		i := value digitLength.
		bigEndian ifFalse: [
			self
				replaceFrom: index
					to: index + i - 1
					with: value 
					startingAt: 1;
				replaceFrom: index + i
					to: index + 7
					with: #[0 0 0 0 0 0 0 0]
					startingAt: 1.
			^value ].
		j := index + 8.
		i <= 7 ifTrue: [
			self
				replaceFrom: index
				to: j - i - 1
				with: #[0 0 0 0 0 0 0 0]
				startingAt: 1 ].
		[ 1 <= i ] whileTrue: [
			self at: j - i put: (value digitAt: i).
			i := i - 1 ].
		^value ].
	bigEndian ifFalse: [
		j := index - 1.
		i := value.
		[ 1 <= i ] whileTrue: [
			self at: (j := j + 1) put: (i bitAnd: 16rFF).
			i := i bitShift: -8 ].
		self replaceFrom: j + 1
			to: index + 7
			with: #[0 0 0 0 0 0 0 0]
			startingAt: 1.
		^value ].
	j := index + 8.
	i := value.
	[ 1 <= i ] whileTrue: [
		self at: (j := j - 1) put: (i bitAnd: 16rFF).
		i := i bitShift: -8 ].
	self replaceFrom: index
		to: j - 1
		with: #[0 0 0 0 0 0 0 0]
		startingAt: 1.
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/9/2015 20:28' prior: 16793638!
                    longAt: index bigEndian: bigEndian
	"Return a 32-bit integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."
	
	| byte result |
	bigEndian ifFalse: [
		(byte := self at: index + 3) <= 16r7F ifTrue: [ "Is the result non-negative?"
			byte <= 16r3F ifTrue: [
				^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index) ].
			^(LargePositiveInteger new: 4)
				replaceFrom: 1
					to: 4
					with: self
					startingAt: index;
				normalize ].
		"Negative"
		byte >= 16rC0 ifTrue: [
			^-1 - (((((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitXor: 16rFFFFFF) bitShift: 8) + ((self at: index) bitXor: 16rFF)) ].
		(result := LargeNegativeInteger new: 4)
			digitAt: 4 put: ((self at: index + 3) bitXor: 16rFF);
			digitAt: 3 put: ((self at: index + 2) bitXor: 16rFF);
			digitAt: 2 put: ((self at: index + 1) bitXor: 16rFF).
		(byte := ((self at: index) bitXor: 16rFF) + 1) <= 16rFF ifTrue: [
			^result
				digitAt: 1 put: byte;
				normalize ].
		^result
			digitAt: 1 put: 16rFF;
			- 1 "It's tempting to do the subtraction in a loop to avoid the LargeInteger creation, but it's actually slower than this." ].
	(byte := self at: index) <= 16r7F ifTrue: [ "Is the result non-negative?"
		byte <= 16r3F ifTrue: [
			^(((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3) ].
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 3);
			digitAt: 2 put: (self at: index + 2);
			digitAt: 3 put: (self at: index + 1);
			digitAt: 4 put: byte;
			normalize ].
	"Negative"
	16rC0 <= byte ifTrue: [
		^-1 - (((((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitXor: 16rFFFFFF) bitShift: 8) + ((self at: index + 3) bitXor: 16rFF)) ].
	(result := LargeNegativeInteger new: 4)
		digitAt: 4 put: (byte bitXor: 16rFF);
		digitAt: 3 put: ((self at: index + 1) bitXor: 16rFF);
		digitAt: 2 put: ((self at: index + 2) bitXor: 16rFF).
	(byte := ((self at: index + 3) bitXor: 16rFF) + 1) <= 16rFF ifTrue: [
		^result
			digitAt: 1 put: byte;
			normalize ].
	^result 
		digitAt: 1 put: 16rFF;
		- 1 "It's tempting to do the subtraction in a loop to avoid the LargeInteger creation, but it's actually slower than this."! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 17:13' prior: 16793658!
             longAt: index put: value bigEndian: bigEndian
	"Store a 32-bit signed integer quantity starting from the given byte index"
	
	| v v2 |
	value isLarge ifTrue: [
		bigEndian ifFalse: [
			value positive ifTrue: [
				self 
					replaceFrom: index
					to: index + 3
					with: value
					startingAt: 1.
				^value ].
			v := 0.
			[ v <= 3 and: [ (v2 := ((value digitAt: v + 1) bitXor: 16rFF) + 1) = 16r100 ] ] whileTrue: [
				self at: index + v put: 0.
				v := v + 1 ].
			self at: index + v put: v2.
			v := v + 1.
			[ v <= 3 ] whileTrue: [
				self at: index + v put: ((value digitAt: (v := v + 1)) bitXor: 16rFF) ].
			^value ].
		value positive ifTrue: [
			self
				at: index put: (value digitAt: 4);
				at: index + 1 put: (value digitAt: 3);
				at: index + 2 put: (value digitAt: 2);
				at: index + 3 put: (value digitAt: 1).
			^value ].
		v := 3.
		[ 0 <= v and: [ (v2 := ((value digitAt: 4 - v) bitXor: 16rFF) + 1) = 16r100 ] ] whileTrue: [
			self at: index + v put: 0.
			v := v - 1 ].
		self at: index + v put: v2.
		[ 0 <= (v := v - 1) ] whileTrue: [
			self at: index + v put: ((value digitAt: 4 - v) bitXor: 16rFF) ].
		^value ].
	v := value bitShift: -24.
	0 <= (v := (v bitAnd: 16r7F) - (v bitAnd: 16r80)) ifFalse: [
		v := v + 16r100 ].
	bigEndian ifFalse: [
		self 
			at: index put: (value bitAnd: 16rFF);
			at: index + 1 put: ((value bitShift: -8) bitAnd: 16rFF);
			at: index + 2 put: ((value bitShift: -16) bitAnd: 16rFF);
			at: index + 3 put: v.
		^value ].
	self
		at: index put: v;
		at: index + 1 put: ((value bitShift: -16) bitAnd: 16rFF);
		at: index + 2 put: ((value bitShift: -8) bitAnd: 16rFF);
		at: index + 3 put: (value bitAnd: 16rFF).
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 23:16' prior: 16793680!
      shortAt: index bigEndian: bigEndian
	"Return a 16-bit signed integer quantity starting from the given byte index"

	| result |
	result := bigEndian
		ifFalse: [ ((self at: index + 1) bitShift: 8) + (self at: index) ]
		ifTrue: [ ((self at: index) bitShift: 8) + (self at: index + 1) ].
	result < 16r8000 ifTrue: [ ^result ].
	^result - 16r10000! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/6/2015 23:16' prior: 16793690!
   shortAt: index put: value bigEndian: bigEndian
	"Store a 16-bit signed integer quantity starting from the given byte index"
	
	| unsignedValue |
	(unsignedValue := value) < 0 ifTrue: [
		unsignedValue := unsignedValue + 16r10000 ].
	bigEndian ifFalse: [
		self 
			at: index + 1 put: (unsignedValue bitShift: -8);
			at: index put: (unsignedValue bitAnd: 16rFF).
		^value ].
	self
		at: index put: (unsignedValue bitShift: -8);
		at: index + 1 put: (unsignedValue bitAnd: 16rFF).
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'eem 2/22/2016 09:20' prior: 16793700!
                  unsignedLongAt: index bigEndian: bigEndian
	"Return a 32-bit unsigned integer quantity starting from the given byte index. Use #normalize where necessary to ensure compatibility with non-30-bit SmallIntegers."
	| byte |
	bigEndian ifTrue:
		[((byte := self at: index) <= 16r3F
		 or: [SmallInteger maxVal >  1073741823]) ifTrue:
			[^(((byte bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 3)].
		^(LargePositiveInteger new: 4)
			digitAt: 1 put: (self at: index + 3);
			digitAt: 2 put: (self at: index + 2);
			digitAt: 3 put: (self at: index + 1);
			digitAt: 4 put: byte;
			normalize].
	((byte := self at: index + 3) <= 16r3F
	 or: [SmallInteger maxVal >  1073741823]) ifTrue:
		[^(((byte bitShift: 8) + (self at: index + 2) bitShift: 8) + (self at: index + 1) bitShift: 8) + (self at: index)].
	^(LargePositiveInteger new: 4)
		replaceFrom: 1 to: 4 with: self startingAt: index;
		normalize! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 01:33' prior: 16793720!
  unsignedLongAt: index put: value bigEndian: bigEndian
	"Store a 32-bit unsigned integer quantity starting from the given byte index"
	
	value isLarge
		ifTrue: [
			bigEndian ifFalse: [
				self
					replaceFrom: index
					to: index + 3
					with: value
					startingAt: 1.
				^value ].
			self
				at: index put: (value digitAt: 4);
				at: index + 1 put: (value digitAt: 3);
				at: index + 2 put: (value digitAt: 2);
				at: index +3 put: (value digitAt: 1) ]
		ifFalse: [
			bigEndian ifFalse: [
				self 
					at: index put: (value bitAnd: 16rFF);
					at: index + 1 put: ((value bitShift: -8) bitAnd: 16rFF);
					at: index + 2 put: ((value bitShift: -16) bitAnd: 16rFF);
					at: index + 3 put: (value bitShift: -24).
				^value ].
			self 
				at: index put: (value bitShift: -24);
				at: index + 1 put: ((value bitShift: -16) bitAnd: 16rFF);
				at: index + 2 put: ((value bitShift: -8) bitAnd: 16rFF);
				at: index + 3 put: (value bitAnd: 16rFF) ].
	^value! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 01:33' prior: 16793740!
                 unsignedShortAt: index bigEndian: bigEndian
	"Return a 16-bit unsigned integer quantity starting from the given byte index"

	bigEndian ifFalse: [ ^((self at: index + 1) bitShift: 8) + (self at: index) ].
	^((self at: index) bitShift: 8) + (self at: index + 1)
	! !
!ByteArray methodsFor: 'platform independent access' stamp: 'ul 9/3/2015 15:29' prior: 16793751!
                     unsignedShortAt: index put: value bigEndian: bigEndian
	"Store a 16-bit unsigned integer quantity starting from the given byte index"
	
	bigEndian ifFalse: [
		self 
			at: index + 1 put: (value bitShift: -8);
			at: index put: (value bitAnd: 16rFF).
		^value ].
	self
		at: index put: (value bitShift: -8);
		at: index+1 put: (value bitAnd: 16rFF).
	^value! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3008-ByteArray-UpdateToSqueak-JuanVuletich-2016Dec22-15h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3008] on 26 December 2016 at 2:54:38 pm'!
!Float64Array methodsFor: 'accessing' stamp: 'jmv 12/26/2016 14:53:06' prior: 16846088!
            floatAt: index put: aFloat
	"Store the argument (e.g., 64 bit Float) at the given index
	Use the same internal representation as BoxedFloat64. I.e. a BoxedFloat64 and a Float64Array of size 1 hold the same bits.
	Allow subclasses to redefine #at:put:"

	"This breaks with SmallFloat64"
	"self replaceWordsFrom: index * 2 - 1 to: index * 2  with: aFloat asFloat startingAt: 1."

	"Float >>basicAt: acts as if Floats were stored in big endian format. Our instances are in platform endianess."
	Smalltalk isLittleEndian
		ifTrue: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 2).
			self basicAt: index * 2 put: (aFloat basicAt: 1) ]
		ifFalse: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 1).
			self basicAt: index * 2 put: (aFloat basicAt: 2) ].
	^aFloat! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3009-Float64Array-fixForSmallFloats-JuanVuletich-2016Dec26-14h53m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3009] on 27 December 2016 at 12:14:57 pm'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 12/27/2016 12:14:33' prior: 16922764!
                         saveAsNewVersion
	"Save the image/changes using the next available version number."
	"
	Smalltalk saveAsNewVersion
	"
	| fileName newName changesName systemVersion |
	self okayToSave ifFalse: [ ^ self ].
	systemVersion _ SystemVersion current.
	fileName _ String streamContents: [ :strm |
		strm
			nextPutAll: 'Cuis';
			print: systemVersion versionMajor;
			nextPut: $.;
			print: systemVersion versionMinor;
			nextPut: $-;
			print: systemVersion highestUpdate.
		Smalltalk isSpur ifTrue: [
			strm nextPutAll: '-spur'.
			Smalltalk wordSize = 8 ifTrue: [
				strm nextPutAll: '-64' ]]].
	newName _ fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName _ DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName _ self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		^ self inform:
'There is already .changes file of the desired name,
', newName, '
curiously already present, even though there is
no corresponding .image file.   Please remedy
manually and then repeat your request.' ].
	"Try to clear all user state, including all class vars, preferences, etc"
	self saveAs: newName andQuit: false clearAllClassState: true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3010-saveAsNewVersion-spur64-JuanVuletich-2016Dec27-12h14m-jmv.1.cs.st----!

----SNAPSHOT----#(27 December 2016 12:18:59.203561 pm) Cuis5.0-3010-spur-64.image priorSource: 64090!

----QUIT----#(27 December 2016 12:19:11.089187 pm) Cuis5.0-3010-spur-64.image priorSource: 81847!

----STARTUP----#(27 December 2016 3:30:14.950041 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3010-spur-64.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3009] on 27 December 2016 at 9:51:30 am'!
!Float64Array methodsFor: 'accessing' stamp: 'jmv 12/27/2016 09:51:21' prior: 50334122!
         floatAt: index put: aNumber
	"Store the argument (e.g., 64 bit Float) at the given index
	Use the same internal representation as BoxedFloat64. I.e. a BoxedFloat64 and a Float64Array of size 1 hold the same bits.
	Allow subclasses to redefine #at:put:"

	"This breaks with SmallFloat64"
	"self replaceWordsFrom: index * 2 - 1 to: index * 2  with: aFloat asFloat startingAt: 1."

	"Float >>basicAt: acts as if Floats were stored in big endian format. Our instances are in platform endianess."
	| aFloat |
	aFloat _ aNumber asFloat.
	Smalltalk isLittleEndian
		ifTrue: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 2).
			self basicAt: index * 2 put: (aFloat basicAt: 1) ]
		ifFalse: [
			self basicAt: index * 2 - 1 put: (aFloat basicAt: 1).
			self basicAt: index * 2 put: (aFloat basicAt: 2) ].
	^aFloat! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3011-Float64Array-fixForSmallIntegers-JuanVuletich-2016Dec27-09h51m-jmv.1.cs.st----!

----SNAPSHOT----#(27 December 2016 3:30:22.206752 pm) Cuis5.0-3011-spur-64.image priorSource: 81950!

----QUIT----#(27 December 2016 3:30:38.307126 pm) Cuis5.0-3011-spur-64.image priorSource: 83341!

----STARTUP----#(18 January 2017 10:35:47.281303 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3011-spur-64.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3011] on 29 December 2016 at 11:02:24 am'!

PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #HierarchicalListMorph category: #'Morphic-Views'!
PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!
!Inspector methodsFor: 'user commands' stamp: 'jmv 12/29/2016 10:58:58'!
       inspectSelection
	self selection inspect! !
!ObjectExplorer methodsFor: 'user commands' stamp: 'jmv 12/29/2016 11:01:35'!
      inspectSelection
	self object inspect! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 12/29/2016 10:55:06'!
         doubleClick: aMouseButtonEvent localPosition: localEventPosition

	doubleClickSelector ifNil: [ ^super doubleClick: aMouseButtonEvent localPosition: localEventPosition ].
	^ self model perform: doubleClickSelector! !
!HierarchicalListMorph methodsFor: 'initialization' stamp: 'jmv 12/29/2016 10:55:42'!
                 doubleClickSelector: aSymbol
	doubleClickSelector _ aSymbol! !
!PluggableListMorph methodsFor: 'initialization' stamp: 'jmv 12/29/2016 10:41:28'!
              doubleClickSelector: aSymbol
	doubleClickSelector _ aSymbol! !
!HierarchicalListMorph methodsFor: 'events' stamp: 'jmv 12/29/2016 10:53:49' prior: 16853080!
   mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition

	| itemMorph |
	aMouseButtonEvent hand newKeyboardFocus: self.
	itemMorph _ self itemFromPoint: localEventPosition.
	itemMorph ifNil: [ ^super mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition ].
	self highlightedMorph: itemMorph.
	(itemMorph inToggleArea: (itemMorph internalize: (scroller internalize: localEventPosition)))
		ifTrue: [ ^self toggleExpandedState: itemMorph event: aMouseButtonEvent ]. 
	aMouseButtonEvent hand 
		waitForClicksOrDragOrSimulatedMouseButton2: self 
		event: aMouseButtonEvent 
		clkSel: #click:localPosition:
		clkNHalf: nil
		dblClkSel: (doubleClickSelector ifNotNil: [ #doubleClick:localPosition: ])
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 10:59:15' prior: 16831023!
 buildMorphicWindow
	"Open a full morphic debugger with the given label"

	| upperMorph receiverInspector receiverInspectorText contextVariableInspector contextVariableInspectorText bottomMorph |

	upperMorph _ PluggableListMorph
		model: model 
		listGetter: #contextStackList
		indexGetter: #contextStackIndex
		indexSetter: #toggleContextStackIndex:
		mainView: self
		menuGetter: #contextStackMenu
		keystrokeAction: #contextStackKey:from:.

	receiverInspector _ PluggableListMorph
			model: model receiverInspector
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #receiverFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	receiverInspector doubleClickSelector: #inspectSelection.
	receiverInspectorText _ TextModelMorph
			textProvider: model receiverInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.
	contextVariableInspector _ PluggableListMorph
			model: model contextVariablesInspector 
			listGetter: #fieldList
			indexGetter: #selectionIndex 
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #contextFieldListMenu
			keystrokeAction: #inspectorKey:from:.
	contextVariableInspector doubleClickSelector: #inspectSelection.
	contextVariableInspectorText _ TextModelMorph
			textProvider: model contextVariablesInspector
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.

	bottomMorph _ LayoutMorph newRow.
	bottomMorph
		addMorph: receiverInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: receiverInspectorText proportionalWidth: 0.3;
		addAdjusterAndMorph: contextVariableInspector proportionalWidth: 0.2;
		addAdjusterAndMorph: contextVariableInspectorText proportionalWidth: 0.3.

	self layoutMorph
		addMorph: upperMorph proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55;
		addAdjusterAndMorph: bottomMorph proportionalHeight: 0.2! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 11:00:06' prior: 16857200!
                    buildMorphicWindow
	" Inspector openOn: SystemOrganization "
	| contentsText list upperRow evaluatorText label |
	"Build widgets. We'll assemble them below."
	list _ PluggableListMorph
			model: model 
			listGetter: #fieldList
			indexGetter: #selectionIndex
			indexSetter: #toggleIndex:
			mainView: self
			menuGetter: #fieldListMenu
			keystrokeAction: #inspectorKey:from:.
	list doubleClickSelector: #inspectSelection.
	contentsText _ TextModelMorph
			textProvider: model
			textGetter: #acceptedContents 
			textSetter: #accept:
			selectionGetter: #contentsSelection.
	evaluatorText _ (TextModelMorph textProvider: model)
			askBeforeDiscardingEdits: false.
	"Upper row has two widgets, side by side: the list of variables at the left side, and the variable contents pane at the right side."
	upperRow _ LayoutMorph newRow.
	upperRow
		addMorph: list proportionalWidth: 0.3;
		addAdjusterAndMorph: contentsText proportionalWidth: 0.7.
	"Inspector Window has two rows: At the top, the one we just bult. Below it, the evaluation pane."
	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.7;
		addAdjusterAndMorph: evaluatorText proportionalHeight: 0.3.
	"Set label"
	label _ [model object printStringLimitedTo: 64]
		on: UnhandledError
		do: [:ex | ex return: model object class printString, ' (printing failed)'].
	(label includesSubString: model object  class name)
		ifFalse: [label _ model object  class name, ': ', label].
	self setLabel: label! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 12/29/2016 11:00:46' prior: 16883288!
buildMorphicWindow

	| textMorph |
	listMorph _ HierarchicalListMorph
			model: model
			listGetter: #getList
			indexGetter: #getCurrentSelection
			indexSetter: #noteNewSelection:
			mainView: self
			menuGetter: #genericMenu
			keystrokeAction: #explorerKey:from:.
	listMorph autoDeselect: false.
	listMorph doubleClickSelector: #inspectSelection.
	textMorph _ (TextModelMorph textProvider: model)
			askBeforeDiscardingEdits: false.
	self layoutMorph
		addMorph: listMorph proportionalHeight: 0.8;
		addAdjusterAndMorph: textMorph proportionalHeight: 0.2.
	self setLabel: (model rootObject printStringLimitedTo: 64)! !
!ObjectExplorerWindow methodsFor: 'menu commands' stamp: 'jmv 12/29/2016 10:50:28' prior: 16883479!
             openWeightExplorer
	"Create and schedule a Weight Explorer on the receiver's model's currently selected object."

	^WeightTracer openExplorerOn: model object! !

PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #HierarchicalListMorph category: #'Morphic-Views'!
PluggableScrollPane subclass: #HierarchicalListMorph
	instanceVariableNames: 'selectedMorph getListSelector keystrokeActionSelector autoDeselect autoExpand sortingSelector getSelectionSelector setSelectionSelector menuGetter mainView highlightedMorph doubleClickSelector'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3012-DoubleClickOpensInspector-JuanVuletich-2016Dec29-10h36m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3012] on 29 December 2016 at 11:30:18 am'!
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/29/2016 11:29:52' prior: 16902537!
                           parseExternalCall
	self scanNext.
	self failWhen: currentToken isNil.
	self scanPast: #externalCallType.
	currentToken = '*' 
		ifTrue: [self scanPast: #externalCallTypePointerIndicator].
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: 	[
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentTokenFirst == $(.
	self scanPast: #leftParenthesis.
	[currentTokenFirst ~~ $)] 
		whileTrue: [
			self failWhen: currentToken isNil.
			self scanPast: #externalCallType.
			currentToken = '*' 
				ifTrue: [self scanPast: #externalCallTypePointerIndicator]].
	self scanPast: #rightParenthesis.
	currentToken = 'module:' 
		ifTrue: [
			self scanPast: #module.
			self failUnless: currentTokenFirst == $'.
			self parseString].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3013-Shout-ExternalCallFix-JuanVuletich-2016Dec29-11h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3013] on 29 December 2016 at 3:36:31 pm'!
!CompiledMethod methodsFor: 'file in/out' stamp: 'jmv 12/29/2016 15:25:13' prior: 16820644!
               storeDataOn: aDataStream
	"Store myself on a DataStream.  I am a mixture of objects and raw data bytes.  Only use this for blocks.  Normal methodDictionaries should not be put out using ReferenceStreams.  Their fileOut should be attached to the beginning of the file."

	| byteLength lits |
	"No inst vars of the normal type"
	byteLength _ self basicSize.
	aDataStream
		beginInstance: self class
		size: byteLength.
	lits _ self numLiterals + 1.	"counting header"
	1 to: lits do:
		[:ii | aDataStream nextPut: (self objectAt: ii)].
	lits*Smalltalk wordSize+1 to: byteLength do:
		[:ii | aDataStream byteStream nextPut: (self basicAt: ii)].
			"write bytes straight through to the file"! !
!DataStream methodsFor: 'write and read' stamp: 'jmv 12/29/2016 15:27:40' prior: 16827456!
                   readMethod
	"PRIVATE -- Read the contents of an arbitrary instance.
	 ASSUMES: readDataFrom:size: sends me beginReference: after it
	   instantiates the new object but before reading nested objects.
	 NOTE: We must restore the current reference position after
	   recursive calls to next.
	Let the instance, not the class read the data.  "
	| instSize refPosn newClass className xxHeader nLits byteCodeSizePlusTrailer newMethod lits |

	instSize _ (byteStream nextUnsignedInt32BigEndian: true) - 1.
	refPosn _ self getCurrentReference.
	className _ self next.
	newClass _ Smalltalk at: className asSymbol.

	xxHeader _ self next.
		"nArgs _ (xxHeader >> 24) bitAnd: 16rF."
		"nTemps _ (xxHeader >> 18) bitAnd: 16r3F."
		"largeBit _ (xxHeader >> 17) bitAnd: 1."
	nLits _ (xxHeader >> 9) bitAnd: 16rFF.
		"primBits _ ((xxHeader >> 19) bitAnd: 16r600) + (xxHeader bitAnd: 16r1FF)."
	byteCodeSizePlusTrailer _ instSize - (newClass instSize "0") - (nLits + 1 * Smalltalk wordSize).

	newMethod _ newClass 
		newMethod: byteCodeSizePlusTrailer
		header: xxHeader.

	self setCurrentReference: refPosn.  "before readDataFrom:size:"
	self beginReference: newMethod.
	lits _ newMethod numLiterals + 1.	"counting header"
	2 to: lits do:
		[:ii | newMethod objectAt: ii put: self next].
	lits*Smalltalk wordSize+1 to: newMethod basicSize do:
		[:ii | newMethod basicAt: ii put: byteStream next].
			"Get raw bytes directly from the file"
	self setCurrentReference: refPosn.  "before returning to next"
	^ newMethod! !
!DataStream methodsFor: 'other' stamp: 'jmv 12/29/2016 15:36:22' prior: 16827907!
            vacantRef
	"Answer the magic 32-bit constant we use ***ON DISK*** as a stream 'reference
	 position' to identify a reference that's not yet filled in. This must be a
	 value that won't be used as an ordinary reference. Cf. outputReference: and
	 readReference. -- 
	 NOTE: We could use a different type ID for vacant-refs rather than writing
		object-references with a magic value. (The type ID and value are
		overwritten by ordinary object-references when weak refs are fullfilled.)"

	"In 32 bit Cuis it was:"
	"^ SmallInteger maxVal"

	"Use that very same value even if in 64 bit Cuis.
	This means that DataStreams are limited to 1GibiBytes in size."
	^16r3FFFFFFF! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3014-DataStream-FixFor64Bits-JuanVuletich-2016Dec29-15h19m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3000] on 10 December 2016 at 10:41:46 am'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 12/10/2016 01:38:21'!
                              xBacktick
	"Smalltalk code evaluated at compile time as a literal."

	self step.
	buffer reset.
	[hereChar == $`
		and: [aheadChar == $`
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched back quote']].
	self step.
	token _ Compiler evaluate: buffer contents.
	tokenType _ #literal! !
!Character methodsFor: 'testing' stamp: 'jmv 12/10/2016 01:26:44' prior: 16800539!
               isValidInIdentifiers
	"Can c be part of an identifier? (unary or keyword selector, or variable name)"

	^self isAlphaNumeric or: [ #( $_ ) statePointsTo: self ]! !
!CompiledMethod methodsFor: 'comparing' stamp: 'jmv 12/10/2016 01:27:06' prior: 16819629!
  = method
	| numLits lit1 lit2 |

	"Any object is equal to itself"
	self == method ifTrue: [ ^ true ].

	"Answer whether the receiver implements the same code as the 
	argument, method."
	(method is: #CompiledMethod) ifFalse: [ ^false ].
	self size = method size ifFalse: [ ^false ].
	self header = method header ifFalse: [ ^false ].
	self initialPC to: self endPC do: [ :i |
		(self at: i) = (method at: i) ifFalse: [ ^false ]].
	(numLits _ self numLiterals) ~= method numLiterals ifTrue: [ ^false ].

	"Dont bother checking FFI and named primitives''
	jmv: Does this make any sense?
	 (#(117 120) includes: self primitive) ifTrue: [^ true]."

	 "properties"
	(self properties analogousCodeTo: method properties) ifFalse: [
		^false ].

	"#penultimateLiteral is selector (or properties, just compared, above)
	Last literal is #methodClass.
	Don't compare them. Two methods might be equal even if they have different selector (or none at all)
	or are installed in different classes (or none at all)"
	1 to: numLits-2 do: [ :i |
		lit1 _ self literalAt: i.
		lit2 _ method literalAt: i.
		lit1 = lit2 ifFalse: [
			(i = 1 and: [ #(117 120) includes: self primitive ])
				ifTrue: [
					lit1 isArray
						ifTrue: [
							(lit2 isArray and: [ lit1 allButLast = lit2 allButLast ]) ifFalse: [
								^false ]]
						ifFalse: [ "ExternalLibraryFunction"
							(lit1 analogousCodeTo: lit2) ifFalse: [
								^false ]]]
				ifFalse: [
					 lit1 isFloat
						ifTrue: [
							"Floats match if values are close, due to roundoff error."
							(lit1 closeTo: lit2) ifFalse: [ ^false ].
							self flag: 'just checking'. self halt ]
						ifFalse: [
							"any other discrepancy is a failure"
							^ false ]]]].
	^true! !
!Scanner class methodsFor: 'cached class state' stamp: 'jmv 12/10/2016 01:26:17' prior: 16904329!
     initTypeTable
	| newTable |
	newTable := Array new: 256 withAll: #xIllegal. "default"
	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"

	1 to: 255
		do: [:index |
			(Character numericValue: index) isValidInIdentifiers
				ifTrue: [
					"Digits and $_ are overwritten later"
					newTable at: index put: #xLetter ]].

	newTable atAll: ($0 numericValue to: $9 numericValue) put: #xDigit.
	newTable atAll:  '!!%&+-*/\,<=>?@~' asByteArray put: #xBinary.

	newTable at: Scanner doItCharacterValue put: #doIt.
	newTable at: $" numericValue put: #xDoubleQuote.
	newTable at: $# numericValue put: #xLitQuote.
	newTable at: $$ numericValue put: #xDollar.
	newTable at: $' numericValue put: #xSingleQuote.
	newTable at: $` numericValue put: #xBacktick.
	newTable at: $: numericValue put: #xColon.
	newTable at: $( numericValue put: #leftParenthesis.
	newTable at: $) numericValue put: #rightParenthesis.
	newTable at: $. numericValue put: #period.
	newTable at: $; numericValue put: #semicolon.
	newTable at: $[ numericValue put: #leftBracket.
	newTable at: $] numericValue put: #rightBracket.
	newTable at: ${ numericValue put: #leftBrace.
	newTable at: $} numericValue put: #rightBrace.
	newTable at: $^ numericValue put: #upArrow.
	newTable at: $_ numericValue put: #xUnderscore.
	newTable at: $| numericValue put: #verticalBar.
	TypeTable := newTable "bon voyage!!"

	"
	Scanner initTypeTable
	"! !
!SHParserST80 methodsFor: 'scan' stamp: 'jmv 12/10/2016 01:42:02' prior: 16901958!
                             scanWhitespace
	| c |
	
	[c := self currentChar.
	c notNil and: [c isSeparator or: [c == $`]]] 
		whileTrue: [sourcePosition := sourcePosition + 1].
	c == $" ifTrue: [self scanComment]! !
!SHParserST80 methodsFor: 'character testing' stamp: 'jmv 12/10/2016 10:24:38' prior: 16902078!
    isBinarySelectorCharacter: aCharacter

	aCharacter isValidInIdentifiers ifTrue: [^false].
	aCharacter isSeparator ifTrue: [^false].

	('"#$'':().;[]{}_`'  includes: aCharacter) 
		ifTrue:[^false].
	aCharacter numericValue = Scanner doItCharacterValue ifTrue: [^false "the doIt char"].
	aCharacter numericValue = 0 ifTrue: [^false].
	"Any other char is ok as a binary selector char."
	^true! !

Scanner removeSelector: #scanStringStruct!

Scanner removeSelector: #scanStringStruct!

Scanner removeSelector: #scanStringStruct:!

Scanner removeSelector: #scanStringStruct:!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Scanner initTypeTable!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3015-Backticks-JuanVuletich-2016Dec10-10h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3015] on 29 December 2016 at 4:06:32 pm'!
!LiteralNode methodsFor: 'printing' stamp: 'jmv 12/29/2016 16:06:13' prior: 16865098!
                             printOn: aStream indent: level

	key isVariableBinding
		ifTrue: [
			key key isNil
				ifTrue: [
					aStream nextPutAll: '###'; nextPutAll: key value soleInstance name ]
				ifFalse: [
					aStream nextPutAll: '##'; nextPutAll: key key ]]
		ifFalse: [
			key isLiteral
				ifTrue: [ key storeOn: aStream ]
				ifFalse: [
					"Need to generate code for stuff that is in a CompiledMethod literal
					but is not understood as a literal by the Compiler.
					Well, then it is because it was generated using backticks!!"
					aStream nextPut: $`.
					key storeOn: aStream.
					aStream nextPut: $`.
					]
			]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3016-Backticks-SupportInDecompiler-JuanVuletich-2016Dec29-15h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3016] on 30 December 2016 at 10:57:00 am'!
!Scanner methodsFor: 'multi-character scans' stamp: 'jmv 12/30/2016 10:29:16' prior: 50334670!
  xBacktick
	"Smalltalk code evaluated at compile time as a literal."

	self step.
	buffer reset.
	[hereChar == $`
		and: [aheadChar == $`
				ifTrue: [self step. false]
				ifFalse: [true]]]
		whileFalse: [
			buffer nextPut: self step.
			(hereChar = Scanner doItCharacterValue asCharacter and: [source atEnd])
				ifTrue: [^self offEnd: 'Unmatched back quote']].
	self step.
	token _ [ Compiler evaluate: buffer contents ] 
		on: SyntaxErrorNotification, UndeclaredVariableReference, Error
		do: [ :ex |
			ex class caseOf: {
				[ SyntaxErrorNotification ] -> [
						self notify: 'Can not compile: ', ex errorMessage at: mark].
				[ UndeclaredVariableReference ] -> [ 
						self notify: 'Can not compile: Variable ''', ex varName, ''' is not declared' at: mark ]
			} otherwise: [
						self notify: 'Can not evaluate code: ', ex description at: mark ]].
	tokenType _ #literal! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3017-Backticks-betterErrorMessages-JuanVuletich-2016Dec30-10h56m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3016] on 30 December 2016 at 11:00:38 am'!
!Editor class methodsFor: 'class initialization' stamp: 'jmv 12/30/2016 11:00:14' prior: 16836909!
               initialize
	"
	Editor initialize
	"
	self withAllSubclassesDo: [ :c |
		c basicInitialize ]! !
!TextEditor methodsFor: 'editing keys' stamp: 'jmv 12/30/2016 10:34:01' prior: 16931735!
        enclose: aKeyboardEvent
	"Insert or remove bracket characters around the current selection."
	"This is a user command, and generates undo"

	| left right startIndex stopIndex oldSelection which |
	startIndex _ self startIndex.
	stopIndex _ self stopIndex.
	oldSelection _ self selection.
	which _ '([<{"''`' indexOf: aKeyboardEvent keyCharacter ifAbsent: [ ^true ].
	left _ '([<{"''`' at: which.
	right _ ')]>}"''`' at: which.
	((startIndex > 1 and: [stopIndex <= model textSize])
			and: [ (model actualContents at: startIndex-1) = left and: [(model actualContents at: stopIndex) = right]])
		ifTrue: [
			"already enclosed; strip off brackets"
			self selectFrom: startIndex-1 to: stopIndex.
			self replaceSelectionWith: oldSelection]
		ifFalse: [
			"not enclosed; enclose by matching brackets"
			self replaceSelectionWith:
				(Text string: (String with: left) attributes: emphasisHere),
				oldSelection,
				(Text string: (String with: right) attributes: emphasisHere).
			self selectFrom: startIndex+1 to: stopIndex].
	^true! !
!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 12/30/2016 10:33:45' prior: 16933087!
        basicCmdShortcutsSpec
	"
	Editor initialize
	"

	"arranged in QWERTY keyboard order"
	^#(
		#(		$( 	#enclose:					'Enclose within ( and ), or remove enclosing ( and )')
		#(		$[ 	#enclose:					'Enclose within [ and ], or remove enclosing [ and ]')
		#(		${ 	#enclose:					'Enclose within { and }, or remove enclosing { and }')
		#(		$' 	#enclose:					'Enclose within single quotes, or remove enclosing single quotes')
		#(		$" 	#enclose:					'Enclose within double quotes, or remove enclosing double quotes')
		#(		$` 	#enclose:					'Enclose within backticks, or remove enclosing backticks')
		#(		$< #enclose:					'Enclose within < and >, or remove enclosing < and >')

		#(		$a 	#selectAll:					'Select all')
		#(		$f 	#find:						'Find')
		#(		$g 	#findAgain:				'Find again')
		#(		$h 	#help:						'Open this help')
		#(		$j 	#setSearchString:		'Set selection as search string for find again')

		#(		$z 	#undo:						'Undo (multiple levels)')
		#(		$x 	#cut:							'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:						'Paste Clipboard contents')

		#(		$R	#indent:						'Indent (move selection one tab-stap right)')
		#(		$Y	#makeUppercase:		'Force selection to uppercase')
		#(		$U	#changeLineEndsToLf:	'Convert line endings to LF characters (Cuis convention) in selection')

		#(		$H	#cursorTopHome:		'Move cursor to start of text')
		#(		$L	#outdent:					'Outdent (move selection one tab-stop left)')

		#(		$Z	#redo:						'Redo (multiple levels)')
		#(		$X	#makeLowercase:		'Force selection to lowercase')
		#(		$C	#compareToClipboard:	'Compare argument to clipboard')

		#(		$ 	#selectWord:				'Select the current word as with double clicking')
	)! !
!SmalltalkEditor methodsFor: 'new selection' stamp: 'jmv 12/30/2016 10:36:10' prior: 16910578!
                     selectWord
	"Select delimited text or word--the result of double-clicking."

	| leftDelimiters rightDelimiters |
	"Warning. Once me (jmv) added Character crCharacter to the delimiters, to make double-click at and of line select whole line.
	This had the bad effect that if a class name is the last word of a line, double-click would correctly select it, but after that,
	doing ctrl-b to browse it would select the whole line..."
	leftDelimiters _ '([{<|''"`'.
	rightDelimiters _ ')]}>|''"`'.
	^self selectWordLeftDelimiters: leftDelimiters rightDelimiters: rightDelimiters! !

Editor initialize!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3018-Backticks-editorSupport-JuanVuletich-2016Dec30-10h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3016] on 30 December 2016 at 11:01:51 am'!
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/30/2016 10:51:03'!
                     parseBacktick
	self enterBlock.
	self scanPast: #backtick.
	currentTokenFirst == $| ifTrue: [self parseBlockTemporaries].
	self parseStatementList.
	self failUnless: currentTokenFirst == $`.
	self scanPast: #backtick.
	self leaveBlock! !
!SHParserST80 methodsFor: 'scan' stamp: 'tween 2/17/2007 14:51' prior: 50334801!
 scanWhitespace
	| c |
	
	[c := self currentChar.
	c notNil and: [c isSeparator]] 
		whileTrue: [sourcePosition := sourcePosition + 1].
	c == $" ifTrue: [self scanComment]! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 12/30/2016 10:51:08' prior: 16902861!
                              parseTerm
	self failWhen: currentToken isNil.
	currentTokenFirst == $( 
		ifTrue: [
			bracketDepth := bracketDepth + 1.
			self scanPast: #leftParenthesis level: bracketDepth.
			self parseExpression.
			self failUnless: currentTokenFirst == $).
			self scanPast: #rightParenthesis level: bracketDepth.
			bracketDepth := bracketDepth - 1.
			^self ].
	currentTokenFirst == $[ ifTrue: [^self parseBlock].
	currentTokenFirst == $` ifTrue: [^self parseBacktick].
	currentTokenFirst == ${ 
		ifTrue: [
			self scanPast: #leftBrace.
			self parseBraceArray.
			^self ].
	self isName ifTrue: [^self scanPast: (self resolve: currentToken)].
	self parseLiteral: false! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3019-Backticks-BetterShoutSupport-JuanVuletich-2016Dec30-11h00m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3019] on 30 December 2016 at 11:46:58 am'!
!SHTextStylerST80 methodsFor: 'private' stamp: 'jmv 12/30/2016 11:44:19' prior: 50332635!
                     setAttributesFromRanges: ranges

	formattedText removeAttributesThat: [ :attribute | attribute isForShout ].

	"Optimize for mutation speed unless method is really large but with very few distict elements:
	Source code that includes just big literals is better served by conventional Text+RunArray"
	"Do it only if we are not breaking textModel!! (for instance, StyledTextEditor asks for formatting just sections, not whole #actualContents)."
	formattedText == textModel actualContents ifTrue: [
		(formattedText size > 2000 and: [ ranges size < 50 ]) ifFalse: [
			formattedText _ formattedText optimizedForMutationSpeed.
			textModel basicActualContents: formattedText ]].

	ranges do: [ :range |

		"Smalltalk text styling"
		(self attributesFor: range rangeType) ifNotNil: [ :attributes |
			attributes do: [ :each |
				formattedText addAttribute: each from: range start to: range end ]].

		"Show as subscripts if appropriate."
		classOrMetaClass ifNotNil: [
			classOrMetaClass theNonMetaClass lastUnderscoreMeansSubscript ifTrue: [
				(#( instVar classVar globalVar workspaceVar poolConstant
					patternArg methodArg patternTempVar tempVar		
					blockPatternArg blockArg blockPatternTempVar blockTempVar 
					incompleteIdentifier undefinedIdentifier) pointsTo: range rangeType )
						ifTrue: [
							formattedText lastIndexOf: $_ startingAt: range end endingAt: range start do: [ :i |
								formattedText addAttribute: ShoutTextEmphasis subscript from: i to: range end ] ]]]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3020-AvoidUnwantedSubscriptInClassDefinitions-JuanVuletich-2016Dec30-11h45m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3020] on 2 January 2017 at 2:27:29 pm'!
!Preferences class methodsFor: 'personalization' stamp: 'jmv 1/2/2017 14:18:06'!
                       usePreDebugWindow
	^ self
		valueOfFlag: #usePreDebugWindow
		ifAbsent: [ false ].! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 1/2/2017 14:11:03'!
   initialFrameIn: aWorld
	^RealEstateAgent initialFrameFor: self world: aWorld! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 1/2/2017 14:13:23'!
     initialFrameIn: aWorld
	| e |
	e _ self runningWorld morphExtent.
	^(0@0 corner: e) insetBy: e // 10! !
!SystemWindow methodsFor: 'open/close' stamp: 'jmv 1/2/2017 14:11:12' prior: 16926575!
 openInWorld: aWorld
	"This msg and its callees result in the window being activeOnlyOnTop"
	| frameRect |
	frameRect _ self initialFrameIn: aWorld.
	self morphExtent: frameRect extent.
	aWorld addMorph: self position: frameRect topLeft.
	"Do it deferred. Was needed for text cursor to start blinking if (Preferences disable: #focusFollowsMouse) "
	WorldState addDeferredUIMessage: [ self activate ]! !
!PreDebugWindow class methodsFor: 'instance creation' stamp: 'jmv 1/2/2017 14:19:05' prior: 16892694!
        open: model label: aString message: messageString
	|  window |
	Preferences usePreDebugWindow
		ifTrue: [
			window _ self new.
			window
				model: model;
				buildMorphicWindowMessage: messageString print.
			aString ifNotNil: [ window setLabel: aString ].
			 window openInWorld ]
		ifFalse: [
			model openFullMorphicLabel: aString ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3021-DebuggerUsabilityEnh-JuanVuletich-2017Jan02-14h27m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3021] on 3 January 2017 at 9:34:24 pm'!
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/3/2017 21:22:43'!
                         nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ super nextPutAllString: aString withAttributes: attributesArray ].

	newEnd _ position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position _ newEnd! !
!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 21:21:34'!
          isCompatibleWithContents: aCollection

	collection class == aCollection class
		ifTrue: [ ^ true ].

	(aCollection isString and: [ collection is: #Text])
		ifTrue: [ ^ true ].

	^ false! !
!PositionableStream methodsFor: 'testing' stamp: 'jmv 1/3/2017 10:57:48' prior: 16891569!
         isText
	"Return true if the receiver is a Text stream"
	^collection is: #Text! !
!WriteStream methodsFor: 'accessing' stamp: 'jmv 1/3/2017 21:22:51' prior: 16946406!
                          nextPutAll: aCollection

	| newEnd |
	(self isCompatibleWithContents: aCollection)
		ifFalse: [ ^ super nextPutAll: aCollection ].

	newEnd _ position + aCollection size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.
	position _ newEnd.! !
!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 10:57:15' prior: 16946621!
                             withAttribute: aTextAttribute do: streamBlock
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock value ].

	pos1 _ self position.
	val _ streamBlock value.
	collection addAttribute: aTextAttribute from: pos1+1 to: self position.
	^ val! !
!WriteStream methodsFor: 'private' stamp: 'jmv 1/3/2017 10:57:19' prior: 16946627!
                withAttributes: attributes do: streamBlock 
	| pos1 val |

	(collection is: #Text) ifFalse: [
		^streamBlock value ].

	pos1 _ self position.
	val _ streamBlock value.
	attributes do: [:attribute |
		collection
			addAttribute: attribute
			from: pos1 + 1
			to: self position].
	^ val! !

Text class removeSelector: #streamContents:!

Text class removeSelector: #streamContents:!

Smalltalk removeClassNamed: #TextStream!

Smalltalk removeClassNamed: #TextStream!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3022-TextStream-removal-JuanVuletich-2017Jan03-21h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3022] on 4 January 2017 at 10:42:00 am'!
!SmallInteger methodsFor: 'system primitives' stamp: 'jmv 1/4/2017 10:35:09' prior: 16909090!
     digitAt: n 
	"Answer the value of an indexable field in the receiver.  LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds."
	n > Smalltalk wordSize ifTrue: [^ 0].
	self < 0
		ifTrue: 
			[self = SmallInteger minVal ifTrue: [
				"Can't negate minVal -- treat specially"
				^ Smalltalk wordSize = 4
					ifTrue: [ #(0 0 0 64) at: n ]
					ifFalse: [ #(0 0 0 0 0 0 0 16) at: n ]].
			^ ((0-self) bitShift: (1-n)*8) bitAnd: 16rFF]
		ifFalse: [^ (self bitShift: (1-n)*8) bitAnd: 16rFF]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3023-SmallInteger-digitAt-fixFor64Bits-JuanVuletich-2017Jan04-10h41m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3022] on 4 January 2017 at 10:46:32 am'!

Integer class removeSelector: #byte1:byte2:byte3:byte4:!

Integer class removeSelector: #byte1:byte2:byte3:byte4:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3024-Integer-from4Bytes-removal-JuanVuletich-2017Jan04-10h44m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3024] on 6 January 2017 at 10:05:27 am'!
!WeakArray class methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:56:14'!
startUp
	"Do it even if just continuing after image snapshot"
	self restartFinalizationProcess! !
!SystemDictionary methodsFor: 'startup' stamp: 'jmv 1/6/2017 09:59:32'!
                      doStartUp: isARealStartup
	"
	isARealStartup
		true: system is coming up (VM and image just started)
		false: we have just saved an image snapshot, but didn't quit.
	"

	"Here, startup begins!!"
	Cursor normal activateCursor.
	self setGCParameters.
	isARealStartup ifTrue: [
		self clearExternalObjects ].
	self readCommandLineArguments.
	self processStartUpList: isARealStartup.
	isARealStartup ifTrue: [
		self setPlatformPreferences.
		self setStartupStamp ]! !
!Behavior methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:52:14' prior: 16785037!
                        startUp
	"This message is sent to registered classes when the system is coming up, or after an image save."! !
!Behavior methodsFor: 'system startup' stamp: 'jmv 1/6/2017 09:53:18' prior: 16785042!
                          startUp: isARealStartup
	"This message is sent to registered classes, with isARealStartup = true when the system is coming up,
	and with isARealStartup = false after a snapshot (image save, no quit).
	Classes caring about the difference should reimplement this method."

	^ self startUp! !
!WeakArray class methodsFor: 'class initialization' stamp: 'jmv 1/6/2017 09:49:16' prior: 16943683!
                          initialize
	"
	WeakArray initialize.
	SystemDictionary initialize.
	"

	self restartFinalizationProcess! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/6/2017 09:53:30' prior: 16922685!
                   processStartUpList: isARealStartup
	"Send #startUp to each class that needs to run initialization after a snapshot."

	EndianCache _ self calcEndianness.
	self send: #startUp: toClassesNamedIn: StartUpList with: isARealStartup! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/6/2017 09:55:41' prior: 16922813!
                        send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument
	"Send the message #startUp: or #shutDown: to each class named in the list.
	The argument indicates if the system is about to quit (for #shutDown:) or if
	the image is ia real startup (or just continue after image save) (for #startUp:).
	If any name cannot be found, then remove it from the list."

	| removals class |
	removals _ OrderedCollection new.
	startUpOrShutDownList do:
		[:name |
		class _ self at: name ifAbsent: nil.
		class
			ifNil: [removals add: name]
			ifNotNil: [
				class isInMemory ifTrue: [
					class perform: startUpOrShutDown with: argument]]].

	"Remove any obsolete entries, but after the iteration"
	"Well, not. Better just ignore them. Maybe it is stuff, like SoundPlayer, that was moved to optional packages, and can be loaded again anytime."
	"startUpOrShutDownList removeAll: removals"! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 1/6/2017 09:59:34' prior: 16922908!
                       snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup world reopenTranscript |
	self logSapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	world _ ProjectX ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"world _ clearAllStateFlag ifFalse: [ ProjectX ui ]."
	ProjectX stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: 1024@768 depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.
	
	
	ProjectX spawnNewMorphicProcessFor: (world ifNil: [ PasteUpMorph newWorld ]).

	reopenTranscript ifTrue: [
		WorldState addDeferredUIMessage: [
			TranscriptWindow openTranscript ]].
	"
	WorldState addDeferredUIMessage: [
		world fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [	
		WorldState addDeferredUIMessage: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !

SystemDictionary removeSelector: #startup:!

SystemDictionary removeSelector: #startup:!

WeakArray class removeSelector: #startUp:!

WeakArray class removeSelector: #startUp:!

WeakArray initialize!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3025-RestartFinalizationAfterImageSave-JuanVuletich-2017Jan06-09h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 13 January 2017 at 9:55:29 am'!
!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'jmv 1/13/2017 09:39:07'!
                 bitXor: arg
	"Primitive 36 deals with only 64-bit values (up to 8 byte LargeIntegers).
	The inherited <primitive: 'primDigitBitXor' module:'LargeIntegers'> deals with 
	arbitrary sized large integers, but is much slower.
	This method gives a performance improvement for integers using 32 to 64 bits on 32 bit VMs,
	but only for 62 to 64 bits on 64 bits VMs.
	See http://forum.world.st/Integer-arithmetic-and-bit-operations-in-Squeak-and-Pharo-32bit-amp-64bit-tc4928994.html#none
	"

    <primitive:36>
    ^super bitXor: arg! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3026-LargeInteger-bitXor-performanceImprov-JuanVuletich-2017Jan13-09h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 13 January 2017 at 9:55:58 am'!
!SHParserST80 methodsFor: 'parse' stamp: 'ul 10/12/2010 02:43'!
                 parseStringOrSymbol

	currentTokenFirst == $' ifTrue: [ ^self parseString ].
	currentTokenFirst == $# ifTrue: [ ^self parseSymbol ].
	self error! !
!SHParserST80 methodsFor: 'parse' stamp: 'jmv 1/13/2017 09:53:38' prior: 16902728!
                         parsePrimitive
	self scanNext.
	currentTokenFirst isDigit 
		ifTrue: [self scanPast: #integer]
		ifFalse: [
			self failUnless: currentTokenFirst == $'.
			self parseString.
			currentToken = 'module:' 
				ifTrue: [
					self scanPast: #module.
					self failUnless: currentTokenFirst == $'.
					self parseString]].
	currentToken = 'error:' ifTrue: [
		self scanPast: #primitive. "there's no rangeType for error"
		self isName
			ifTrue: [ self scanPast: #patternTempVar ]
			ifFalse: [ self parseStringOrSymbol ] ].
	self failUnless: currentToken = '>'.
	self scanPast: #primitiveOrExternalCallEnd! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3027-ShoutFix-JuanVuletich-2017Jan13-09h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 13 January 2017 at 9:59:33 am'!
!Float methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:46' prior: 16845694!
                    replaceWordsFrom: start to: stop with: replacement startingAt: repStart
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	self primitiveFailed! !
!LargePositiveInteger methodsFor: 'system primitives' stamp: 'jmv 1/13/2017 09:58:53' prior: 16862796!
            replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!String methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:04' prior: 16917188!
                    replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!Array methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:31' prior: 16779882!
                     replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!ByteArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:38' prior: 16793800!
                 replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!Float64Array methodsFor: 'private' stamp: 'jmv 1/13/2017 09:57:50' prior: 16846133!
              replaceWordsFrom: start to: stop with: replacement startingAt: repStart
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	self primitiveFailed! !
!FloatArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:24' prior: 16846632!
replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!RunNotArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:00' prior: 16901681!
               replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Copied from Array"
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !
!WordArray methodsFor: 'private' stamp: 'jmv 1/13/2017 09:58:38' prior: 16945290!
                            replaceFrom: start to: stop with: replacement startingAt: repStart 

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart ! !
!Bitmap methodsFor: 'accessing' stamp: 'jmv 1/13/2017 09:57:27' prior: 16787571!
replaceFrom: start to: stop with: replacement startingAt: repStart 
	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."

	<primitive: 105 error: ec>
	super replaceFrom: start to: stop with: replacement startingAt: repStart! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3028-GrabErrorCodeForPrim105-JuanVuletich-2017Jan13-09h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3028] on 14 January 2017 at 8:18:04 am'!
!Point commentStamp: 'jmv 12/30/2016 17:39:06' prior: 16890200!
                  I represent an x-y pair of numbers usually designating a location on the screen.

When dealing with display coordinates, the y axis is usually considered to increase downwards. However, the standard math convention is to consider it increasing upwards. 
Points don't need to know about this. In the first case, theta increases clockwise. In the second case, it increases counter-clockwise, also the standard math convention.

Any method that doesn't follow this (because it assumes one specific convention) include this fact in the selector and in a comment.

My instances are immutable. See #privateSetX:setY:!
!Point methodsFor: 'private' stamp: 'jmv 12/11/2016 10:28:44'!
                             privateSetX: xValue setY: yValue
	"Points are immutable. Right now this is by convention, but we'll make this enfoced by VM.
	Do not all this method, except from instance creation."
	x _ xValue.
	y _ yValue! !
!Point methodsFor: 'copying' stamp: 'pb 10/29/2016 18:18:07'!
                shallowCopy
	"Immutable"
	^ self.! !
!Object class methodsFor: 'instance creation' stamp: 'jmv 12/30/2016 17:33:31' prior: 16882941!
                           unStream: aByteArray
	^ ReferenceStream unStream: aByteArray! !
!DataStream class methodsFor: 'as yet unclassified' stamp: 'jmv 12/30/2016 17:33:27' prior: 16828091!
                          unStream: aByteArray

	^(self on: ((RWBinaryOrTextStream with: aByteArray) reset; binary)) next! !
!Point class methodsFor: 'instance creation' stamp: 'pb 10/29/2016 17:14:00' prior: 16890866!
                               r: rho degrees: degrees
	"Answer an instance of me with polar coordinates rho and theta."
	^ self
		rho: rho
		theta: degrees asFloat degreesToRadians.! !
!Point class methodsFor: 'instance creation' stamp: 'pb 10/29/2016 17:12:53' prior: 16890873!
       rho: rho theta: radians
	"Answer an instance of me with polar coordinates rho and theta."
	^ self
		x: rho asFloat * radians cos
		y: rho asFloat * radians sin.! !
!Point class methodsFor: 'instance creation' stamp: 'jmv 12/11/2016 10:28:50' prior: 16890880!
                             x: anX y: anY
	"Answer an instance of me with supplied coordinates."

	^self new privateSetX: anX setY: anY! !

Point removeSelector: #setR:degrees:!

Point removeSelector: #setR:degrees:!

Point removeSelector: #setRho:theta:!

Point removeSelector: #setRho:theta:!

Point removeSelector: #setX:setY:!

Point removeSelector: #setX:setY:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3029-Point-immutable-PhilBellalouna-2017Jan14-08h15m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3029] on 14 January 2017 at 8:53:02 am'!
!SystemDictionary methodsFor: 'code authors' stamp: 'jmv 1/14/2017 08:52:09' prior: 16920588!
     knownInitialsAndNames
	"This list could include people who hasn't contributed code to the Cuis image, but to some optional package."
"
| all ok |
all _ Smalltalk allContributors asSet.
ok _ (Smalltalk knownInitialsAndNames collect: [ :pair | pair first ]) asSet.
(all copyWithoutAll: ok) print

		initials         				name"
^ #(
	#('ab' 						'Alexandre Bergel')
	#('abc' 					'Colin Putney')
	#('acg' 					'Andrew C. Greenberg')
	#('ads' 					'Adam Spitz')
	#('AFi' 					'Alain Fischer')
	#('ajh' 					'Anthony Hannan')
	#('al' 						'Adrian Lienhard')
	#('aoy' 					'Andres Otaduy')
	#('apb' 					'Andrew P. Black')
	#('ar' 						'Andreas Raab')
	#('asm' 					'Alejandro Magistrello')
	#('avi' 					'Avi Bryant')
	#('BenComan' 			'Ben Coman')
	#('bf' 						'Bert Freudenberg')
	#('BG' 					'Boris Gaertner')
	#('BJP' 					'Bijan Parsia')
	#('bkv' 					'Brent Vukmer')
	#('bolot' 					'Bolot Kerimbaev')
	#('bp' 						'Bernhard Pieber')
	#('BP' 						'Brent Pinkney') 
	#('brp' 					'Brent Pinkney')
	#('cbc' 					'Chris Cunningham')
	#('cbr'						'Casey Ransberger')
	#('ccn' 					'Chris Norton')
	#('cmm' 					'Chris Muller')
	#('crl' 						'Craig Latta')
	#('cwp' 					'Colin Putney')
	#('das' 					'David A Smith')
	#('dc' 						'Damien Cassou')
	#('dew' 					'Doug Way')
	#('dgd' 					'Diego Gomez Deck')
	#('dkh'					'Dale Henrichs')
	#('dhn'	 				'Dan Norton')
	#('dhhi' 					'Dan Ingalls')
	#('di' 						'Dan Ingalls')
	#('djp' 					'David J. Pennell')
	#('DKL'					'Daniel K Lyons ')
	#('DM' 					'Duncan Mak')
	#('DSM' 					'Duane Maxwell')
	#('DSG'					'David Graham')
	#('dtl' 						'Dave Lewis')
	#('dvf' 					'Daniel Vainsencher')
	#('eat' 					'Eric Arseneau Tremblay')
	#('eem'					'Eliot Emilio Miranda')
	#('eliot'					'Eliot Emilio Miranda')
	#('efc' 					'Eddie Cottongim')
	#('em' 					'Ernest Micklei?')
	#('emm' 					'Ernest Micklei')
	#('fbs' 					'Frank Shearar')
	#('FBS' 					'Frank Shearar')
	#('fc' 						'Frank Caggiano')
	#('fcs' 					'Frank Sergeant')
	#('FernandoOlivero' 		'Fernando Olivero')
	#('FernanodOlivero' 		'Fernando Olivero')
	#('GabrielOmarCotelli' 	'Gabriel Omar Cotelli')
	#('gera' 					'Gerardo Richarte')
	#('gh' 						'Goran Krampe (nee Hultgren)')
	#('gk' 						'Goran Krampe (nee Hultgren)')
	#('gm' 					'German Morales')
	#('go' 						'Georg Gollmann')
	#('gsa' 					'German Arduino')
	#('HAW' 					'Hernan Wilkinson')
	#('HB' 					'Hari Balaraman')
	#('hjh' 					'Hannes Hirzel')
	#('hmm' 					'Hans-Martin Mosner')
	#('hsj' 					'Henrik Sperre Johansen')
	#('Igor.Stasenko' 		'Igor Stasenko')
	#('ikp' 					'Ian Piumarta')
	#('Jb' 						'Jean Baptiste Arnaud')
	#('jcg' 					'Joshua Gargus')
	#('jdr' 					'Javier Diaz-Reinoso')
	#('je' 						'Joern Eyrich')
	#('jf' 						'Julian Fitzell')
	#('JF' 						'Julian Fitzell')
	#('jhm' 					'John Maloney')
	#('jk'						'Jonathan Kelly')
	#('jlb' 						'Jim Benson')
	#('jm' '					John Maloney')
	#('jmb' 					'Hans Baveco')
	#('JMG'					'Jeff Gonis')
	#('JMM' 					'John McIntosh')
	#('jmv' 					'Juan Vuletich')
	#('JMV' 					'Juan Vuletich')
	#('jp' 						'Joseph Pelrine')
	#('jrm' 					'John-Reed Maffeo')
	#('jrp' 					'John Pierce')
	#('jsp' 					'Jeff Pierce')
	#('KenD' 					'Ken Dickey')
	#('kfr' 					'Karl Ramberg')
	#('KLC'			 		'Ken Causey')
	#('kph'					'Keith Hodges')
	#('KTT' 					'Kurt Thams')
	#('laza' 					'Alexander Lazarevic')
	#('LC' 						'Leandro Caniglia')
	#('len' 					'Luciano Esteban Notarfrancesco')
	#('lpc'						'Laura Perez Cerrato')
	#('lr' 						'Lukas Renggli')
	#('Lukas Renggli' 		'Lukas Renggli')
	#('ls' 						'Lex Spoon')
	#('md' 					'Marcus Denker')
	#('MarcusDenker' 		'Marcus Denker')
	#('marcus.denker' 		'Marcus Denker')
	#('mdr' 					'Mike Rutenberg')
	#('mga' 					'Markus Galli')
	#('mha' 					'Michael Haupt')
	#('mir' 					'Michael Rueger')
	#('mjg' 					'Mark Guzdial')
	#('mk' 					'Matej Kosik')
	#('MPH' 					'Michael Hewner')
	#('mpw' 					'Marcel Weiher')
	#('MPW' 					'Marcel Weiher')
	#('mrm' 					'Martin McClure')
	#('mtf' 					'Matthew Fulmer')
	#('mu' 					'Masashi Umezawa')
	#('nb' 						'Naala Brewer')
	#('nice'				 	'Nicolas Cellier')
	#('nk' 						'Ned Konz')
	#('nop' 					'Jay Carlson')
	#('NS' 						'Nathanael Schaerli')
	#('panda' 					'Michael Rueger')
	#('pb'						'Phil Bellalouna')
	#('PHK' 					'Peter Keeler')
	#('Pmm' 					'Philippe Marschall')
	#('pnm' 					'Paul McDonough')
	#('r++' 					'Gerardo Richarte')
	#('raa' 					'Bob Arning')
	#('RAA' 					'Bob Arning')
	#('raok' 					'Richard A. O''Keefe')
	#('rca' 					'Russell Allen')
	#('reThink'			 	'Paul McDonough')
	#('rew' 					'Roger Whitney')
	#('rhi' 						'Robert Hirschfeld')
	#('RJT' 					'Ron Teitelbaum')
	#('rr' 						'Romain Robbes')
	#('rss' 					'Ron Spengler')
	#('rw' 						'Robert Withers')
	#('rww' 					'Robert Withers')
	#('Sames' 				'Samuel S. Shuster')
	#('sbw' 					'Stephan B. Wessels')
	#('sd' 						'Stephane Ducasse')
	#('SD' 					'Stephane Ducasse')
	#('sge' 					'Steve Elkins')
	#('sma' 					'Stefan Matthias Aust')
	#('sps' 					'Steven Swerling')
	#('SqR' 					'Andres Valloud')
	#('sqr' 					'Andres Valloud')
	#('sr' 						'Stephan Rudlof')
	#('SSS' 					'Samuel S. Shuster')
	#('stephane.ducasse' 	'Stephane Ducasse')
	#('stephaneducasse' 	'Stephane Ducasse')
	#('stp' 					'Stephen Travis Pope')
	#('sumim' 				'Masato Sumi')
	#('svp' 					'Stephen Vincent Pair')
	#('sw' 					'Scott Wallace')
	#('TAG' 					'Travis Griggs')
	#('tak' 					'Takashi Yamamiya')
	#('tao' 					'Tim Olson')
	#('TBn' 					'Torsten Bergmann')
	#('tfei' 					'The Fourth Estate, Inc.')
	#('tfel' 					'Tim Felgentreff')
	#('th' 						'Torge Husfeldt')
	#('tk' 						'Ted Kaehler')
	#('tlk' 						'Tom Koenig')
	#('tpr' 					'Tim Rowledge')
	#('TPR' 					'Tim Rowledge')
	#('tween' 				'Andy Tween')
	#('ul' 						'Levente Uzonyi')
	#('vb' 						'Vassili Bykov')
	#('ward' 					'Ward Cunningham')
	#('wiz' 					'Jerome Peace')
	#('wod' 					'Bill Dargel')
	#('yo' 						'Yoshiki Ohshima')
	#('zz' 						'Serge Stinckwich'))! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3030-AddHernanAndGeraToKnownAuthors-JuanVuletich-2017Jan14-08h52m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 10 January 2017 at 8:09:15 pm'!

Object subclass: #TestResultForDebuggingAndInspection
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #TestResultForDebuggingAndInspection category: #'Tools-Testing'!
Object subclass: #TestResultForDebuggingAndInspection
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!
!CompiledMethod methodsFor: 'testing' stamp: 'HernanWilkinson 1/10/2017 18:22:10'!
                       isTestMethod

    ^ (self methodClass is: #TestCaseClass) 
		and: [ ((self selector beginsWith: 'test') or: [ (self selector beginsWith: 'should')]) 
		and: [ self numArgs isZero ] ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:35:14'!
                      acceptAndTest
	
	^self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteOf: aMethod methodClass ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:35:34'!
   acceptAndTestAll
	
	^self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteForCategoryOf: aMethod methodClass ]
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:04:06'!
                 acceptThenTestMethodAndSuite: aSuiteBuilder
	
	| potencialTestMethod |
	
	self acceptContents ifFalse: [ ^false ].
	
	potencialTestMethod _ model textProvider currentCompiledMethod.
	self runAndDebuggIfNecessary: potencialTestMethod.
	^(self runTestSuite: (aSuiteBuilder value: potencialTestMethod)) hasPassed
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 18:50:03'!
                     flashWith: aColor

	^morph flashWith: aColor! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 18:50:21'!
flashWithGreen

	^self flashWith: Color green

	
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:03:07'!
                        runAndDebuggIfNecessary: aPotentialTestMethod

	aPotentialTestMethod isTestMethod ifTrue: [
		aPotentialTestMethod methodClass debug: aPotentialTestMethod selector ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:04:42'!
       runTestSuite: aTestSuite

	| suiteRunResult |
	 
	suiteRunResult _ aTestSuite run.
	suiteRunResult hasPassed 
		ifTrue: [self flashWithGreen ]
		ifFalse: [ suiteRunResult forDebuggingAndInspection inspect ].
		
	^suiteRunResult 

	
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:35:52'!
 testSuiteForCategoryOf: aClass

	| testCaseClasses |
	
	testCaseClasses _ (SystemOrganization listAtCategoryNamed: aClass category)
		collect: [ :aClassName | Smalltalk classNamed: aClassName ]
		thenSelect: [ :aClassInCategory | aClassInCategory is: #TestCaseClass ].
		
	
	^testCaseClasses
		inject: (TestSuite named: 'Test of Category ', aClass category)
		into: [ :suite :testCaseClass | testCaseClass addToSuiteFromSelectors: suite ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HernanWilkinson 1/10/2017 19:34:58'!
                      testSuiteOf: aPotentialTestCaseClass

	^(aPotentialTestCaseClass is: #TestCaseClass)
		ifTrue: [ aPotentialTestCaseClass buildSuite ]
		ifFalse: [ TestSuite named: 'Tests of ', aPotentialTestCaseClass name ]! !
!DisplayScreen methodsFor: 'displaying' stamp: 'HernanWilkinson 1/10/2017 18:45:48'!
                        flash: aRectangle with: aColor

	self fill: aRectangle fillColor: aColor.
	self forceToScreen: aRectangle.
	(Delay forMilliseconds: 100) wait.
	self fill: aRectangle fillColor: aColor.
	self forceToScreen: aRectangle! !
!Morph methodsFor: 'macpal' stamp: 'HernanWilkinson 1/10/2017 18:49:44'!
                           flashWith: aColor

	self morphBoundsInWorld ifNotNil: [ :r | Display flash: r with: aColor ]! !
!InnerTextMorph methodsFor: 'editing' stamp: 'HernanWilkinson 1/10/2017 15:56:51'!
             confirmAcceptAnyway

	^ self confirm: 
'Caution!! Contents were saved
elsewhere since you started
editing them here.  Accept anyway?'! !
!TestCase class methodsFor: 'Testing' stamp: 'HernanWilkinson 1/10/2017 16:29:48'!
    is: aSymbol

	^aSymbol == #TestCaseClass or: [ super is: aSymbol ]! !
!TestResult methodsFor: 'Inspecting' stamp: 'HernanWilkinson 1/10/2017 16:33:03'!
        forDebuggingAndInspection

	^TestResultForDebuggingAndInspection on: self! !
!TestResultForDebuggingAndInspection methodsFor: 'initialization' stamp: 'HernanWilkinson 1/10/2017 16:34:56'!
    initializeOn: aTestResult

	testResult _ aTestResult! !
!TestResultForDebuggingAndInspection methodsFor: 'printing' stamp: 'HernanWilkinson 1/10/2017 17:49:59'!
                               print: aCollectionOfTestCases startingWith: header on: aStream
	
	aCollectionOfTestCases
		do: [ :aTestCase |
			aStream 
				nextPutAll: header;
				space;
				nextPutAll: aTestCase class name;
				nextPutAll: ' debug: #';
				nextPutAll: aTestCase selector ]
		separatedBy: [ aStream newLine ].
		
	! !
!TestResultForDebuggingAndInspection methodsFor: 'printing' stamp: 'HernanWilkinson 1/10/2017 17:49:05'!
      printOn: aStream

	aStream print: testResult.
	aStream newLine.
	
	self print: testResult errors startingWith: '"E"' on: aStream.
	self print: testResult failures startingWith: '"F"' on: aStream.
	! !
!TestResultForDebuggingAndInspection methodsFor: 'running' stamp: 'HernanWilkinson 1/10/2017 18:14:09'!
               reRun

	| suite |
	 
	suite _ TestSuite new.
	suite addTests: testResult tests.
	
	testResult _ suite run.! !
!TestResultForDebuggingAndInspection class methodsFor: 'instance creation' stamp: 'HernanWilkinson 1/10/2017 16:34:28'!
                          on: aTestResult

	^self new initializeOn: aTestResult! !
!TextEditor methodsFor: 'menu messages' stamp: 'HernanWilkinson 1/10/2017 16:00:24' prior: 16932076!
  acceptContents
	"Save the current text of the text being edited as the current acceptable version for purposes of canceling.  Allow my morph to take appropriate action"
	^morph acceptContents! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HernanWilkinson 1/10/2017 19:58:01' prior: 16910705!
  initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.										#openHelp}.
		#-.
		{'Do it (d)'.									#doIt}.
		{'Print it (p)'.									#printIt}.
		{'Inspect it (i)'.								#inspectIt}.
		{'Explore it (I)'.								#exploreIt}.
		{'Debug it (D)'.								#debugIt}.
		{'Profile it'.									#profileIt}.
		#-.
		{'Explain'.										#explain}.
		{'Browse it (b)'.								#browseIt}.
		{'Senders of it (n)'.							#sendersOfIt}.
		{'Implementors of it (m)'.					#implementorsOfIt}.
		{'References to it (N)'.						#referencesToIt}.
		#-.
		{'Method Strings with it (E)'.				#methodStringsContainingit}.
		{'Method Source with it'.					#methodSourceContainingIt}.
		{'Class Comments with it'.					#classCommentsContainingIt}.
		#-.
		{'Accept (s)'.									#acceptContents}.
		{'Cancel (l)'.									#cancelEdits}.
		{'Accept & Run Test in Class (t)'.			#acceptAndTest}.
		{'Accept & Run Test in Category (y)'.		#acceptAndTestAll}.
		#-.
		{'More...'.										#getMenu2}.
	}.
	menu2 _ SelectionMenu fromArray: {
		{'Find...(f)'.									#find}.
		{'Find Again (g)'.								#findAgain}.
		{'Use Selection for Find (j)'.				#setSearchString}.
		#-.
		{'Undo - multiple (z)'.						#undo}.
		{'Redo - multiple (Z)'.						#redo}.
		{'Undo / Redo history'.						#offerUndoHistory}.
		#-.
		{'Copy (c)'.									#copySelection}.
		{'Cut (x)'.										#cut}.
		{'Paste (v)'.									#paste}.
		{'Paste without Format'.						#pasteString}.
		{'Paste...'.									#pasteRecent}.
		#-.
		{'Toggle WordWrap'.						#wrapOnOff}.
		{'Set Font... (k)'.								#offerFontMenu}.
		{'Clear Font'.									#clearFont}.
		{'Set Default Font...'.						#offerDefaultFontMenu}.
		#-.
		{'More...'.										#getMenu}.
	}! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'HernanWilkinson 1/10/2017 17:47:44' prior: 16857247!
                     initialExtent

	^600@325! !
!InnerTextMorph methodsFor: 'editing' stamp: 'HernanWilkinson 1/10/2017 19:46:39' prior: 16855583!
 acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| accepted prevSelection prevScrollValue |
	
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar value.
	
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) ifTrue: [self flash. ^true].
	(self hasEditingConflicts and: [ self confirmAcceptAnyway not ]) ifTrue: [self flash. ^false].
	
	accepted _ model acceptContentsFrom: owner.
	"During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the code-holding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
	
	"some implementors of acceptContentsFrom: answer self :("
	^accepted == true 
		ifTrue: [
			model refetch.
			self editor selectFrom: prevSelection first to: prevSelection last.
			WorldState addDeferredUIMessage: [
				self world ifNotNil: [ :w | w activeHand newKeyboardFocus: self ].
				owner verticalScrollBar setValue: prevScrollValue].
			true]
		ifFalse: [ false ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3031-TDDSupport-0-HernanWilkinson.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 10 January 2017 at 8:09:22 pm'!
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:04:06'!
         acceptAndTest: aKeyboardEvent

	^self acceptAndTest! !
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:04:34'!
                acceptAndTestAll: aKeyboardEvent

	^self acceptAndTestAll! !
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HernanWilkinson 1/10/2017 20:02:27'!
          debugIt: aKeyboardEvent

	self debugIt.
	^true! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HernanWilkinson 1/10/2017 20:03:23' prior: 16910661!
                   cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')
		#(		$l	#cancelEdits:						'Cancel')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$A	#argAdvance:						'Advance argument')
		#(		$D	#debugIt:							'Debut it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HernanWilkinson 1/10/2017 19:58:01' prior: 50336255!
                           initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.										#openHelp}.
		#-.
		{'Do it (d)'.									#doIt}.
		{'Print it (p)'.									#printIt}.
		{'Inspect it (i)'.								#inspectIt}.
		{'Explore it (I)'.								#exploreIt}.
		{'Debug it (D)'.								#debugIt}.
		{'Profile it'.									#profileIt}.
		#-.
		{'Explain'.										#explain}.
		{'Browse it (b)'.								#browseIt}.
		{'Senders of it (n)'.							#sendersOfIt}.
		{'Implementors of it (m)'.					#implementorsOfIt}.
		{'References to it (N)'.						#referencesToIt}.
		#-.
		{'Method Strings with it (E)'.				#methodStringsContainingit}.
		{'Method Source with it'.					#methodSourceContainingIt}.
		{'Class Comments with it'.					#classCommentsContainingIt}.
		#-.
		{'Accept (s)'.									#acceptContents}.
		{'Cancel (l)'.									#cancelEdits}.
		{'Accept & Run Test in Class (t)'.			#acceptAndTest}.
		{'Accept & Run Test in Category (y)'.		#acceptAndTestAll}.
		#-.
		{'More...'.										#getMenu2}.
	}.
	menu2 _ SelectionMenu fromArray: {
		{'Find...(f)'.									#find}.
		{'Find Again (g)'.								#findAgain}.
		{'Use Selection for Find (j)'.				#setSearchString}.
		#-.
		{'Undo - multiple (z)'.						#undo}.
		{'Redo - multiple (Z)'.						#redo}.
		{'Undo / Redo history'.						#offerUndoHistory}.
		#-.
		{'Copy (c)'.									#copySelection}.
		{'Cut (x)'.										#cut}.
		{'Paste (v)'.									#paste}.
		{'Paste without Format'.						#pasteString}.
		{'Paste...'.									#pasteRecent}.
		#-.
		{'Toggle WordWrap'.						#wrapOnOff}.
		{'Set Font... (k)'.								#offerFontMenu}.
		{'Clear Font'.									#clearFont}.
		{'Set Default Font...'.						#offerDefaultFontMenu}.
		#-.
		{'More...'.										#getMenu}.
	}! !
!InnerTextMorph methodsFor: 'editing' stamp: 'HernanWilkinson 1/10/2017 19:46:39' prior: 50336320!
                           acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| accepted prevSelection prevScrollValue |
	
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar value.
	
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) ifTrue: [self flash. ^true].
	(self hasEditingConflicts and: [ self confirmAcceptAnyway not ]) ifTrue: [self flash. ^false].
	
	accepted _ model acceptContentsFrom: owner.
	"During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the code-holding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
	
	"some implementors of acceptContentsFrom: answer self :("
	^accepted == true 
		ifTrue: [
			model refetch.
			self editor selectFrom: prevSelection first to: prevSelection last.
			WorldState addDeferredUIMessage: [
				self world ifNotNil: [ :w | w activeHand newKeyboardFocus: self ].
				owner verticalScrollBar setValue: prevScrollValue].
			true]
		ifFalse: [ false ]! !

Editor initialize!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3032-TDDSupport-1-HernanWilkinson.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 12 January 2017 at 5:14:29 pm'!
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:05:16'!
 askForSuperclassOf: aClass toImplement: aSelector ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes _ aClass withAllSuperclasses.
	chosenClassIndex _ PopUpMenu
		withCaption: 'Define #', aSelector, ' in which class?'
		chooseFrom: (classes collect: [:c | c name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock value].

	^ classes at: chosenClassIndex! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:09:46'!
    create

	self shouldBeAbleToCreateMethod 
		ifTrue: [ self createMethod ]
		ifFalse: [ self inform: 'Only available for doesNotUndertand:' ]! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:04:29'!
   createMethod

	| message chosenClass interruptedContext |
	
	interruptedContext _ self interruptedContext.
	message _ interruptedContext tempAt: 1.
	chosenClass _ self
		askForSuperclassOf: interruptedContext receiver class
		toImplement: message selector
		ifCancel: [^self].
	self implement: message inClass: chosenClass.
! !
!Debugger methodsFor: 'as yet unclassified' stamp: 'HAW 1/12/2017 17:01:22'!
           shouldBeAbleToCreateMethod

	^self interruptedContext selector == #doesNotUnderstand:! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 17:04:50' prior: 16831115!
           customButtonSpecs
	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."

	^#(
		('Restart'		restart				'reset this context to its start.')
		('Into'			send					'step Into message sends')
		('Over'			doStep				'step Over message sends')
		('Through'		stepIntoBlock		'step into a block')
		('Full Stack'	fullStack			'show full stack')
		('Where'		where				'select current pc range')
		('Create'		create 				'create method'))! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 17:06:02' prior: 16892577!
             buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	(aDebugger shouldBeAbleToCreateMethod) ifTrue: [
		triads add: { 'Create'. #createMethod. 'create the missing method' }
	].
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: Color transparent.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!PreDebugWindow methodsFor: 'button actions' stamp: 'HAW 1/12/2017 17:06:43' prior: 16892636!
            createMethod
	"Should only be called when this Debugger was created in response to a
	MessageNotUnderstood exception. Create a stub for the method that was
	missing and proceed into it."
	
	model createMethod.
	self debug
! !

PreDebugWindow removeSelector: #askForSuperclassOf:toImplement:ifCancel:!

PreDebugWindow removeSelector: #askForSuperclassOf:toImplement:ifCancel:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3033-CreateMethodSupport-HernanWilkinson-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3025] on 12 January 2017 at 6:54:23 pm'!
!Behavior methodsFor: 'accessing class hierarchy' stamp: 'HAW 1/12/2017 18:29:00'!
                      allSuperclassesUpTo: aSuperclass
	
	| superclasses |
	
	^ superclass = aSuperclass
		ifTrue: [ OrderedCollection with: aSuperclass]
		ifFalse: [superclasses _ superclass allSuperclassesUpTo: aSuperclass.
			superclasses addFirst: superclass.
			superclasses]! !
!Behavior methodsFor: 'accessing class hierarchy' stamp: 'HAW 1/12/2017 18:30:53'!
       withAllSuperclassesUpTo: aSuperclass

	| classes |
	
	classes _ self allSuperclassesUpTo: aSuperclass.
	classes addFirst: self.
	
	^ classes! !
!ContextPart methodsFor: 'debugger access' stamp: 'HAW 1/12/2017 17:48:35'!
    arguments

	| arguments |

	arguments _ Array new: self selector numArgs.
	1 to: arguments size do: [ :index | arguments at: index put: (self tempAt: index)].

	^arguments.
	
	! !
!ContextPart methodsFor: 'debugger access' stamp: 'HAW 1/12/2017 17:47:30'!
messageForYourself

	^Message selector: self selector arguments: self arguments.
	! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:31:14'!
 askForSuperclassOf: aClass upTo: aSuperclass toImplement: aSelector ifCancel: cancelBlock

	| classes chosenClassIndex |

	classes _ aClass withAllSuperclassesUpTo: aSuperclass. 
	chosenClassIndex _ PopUpMenu
		withCaption: 'Define #', aSelector, ' in which class?'
		chooseFrom: (classes collect: [:c | c name]).
	chosenClassIndex = 0 ifTrue: [^ cancelBlock value].

	^ classes at: chosenClassIndex! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:45:03'!
    createMethodOnSubclassResponsibility

	| message chosenClass subclassResponsibilityContext |
	
	subclassResponsibilityContext _ self interruptedContext sender sender.
	message _ subclassResponsibilityContext messageForYourself.
	
	chosenClass _ self
		askForSuperclassOf: subclassResponsibilityContext receiver class
		upTo: subclassResponsibilityContext method methodClass
		toImplement: message selector
		ifCancel: [^self].
		
	self implement: message inClass: chosenClass context: subclassResponsibilityContext 

! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:43:11'!
              createMethodWhenDoesNotUndertand

	| message chosenClass interruptedContext |
	
	interruptedContext _ self interruptedContext.
	message _ interruptedContext tempAt: 1.
	
	chosenClass _ self
		askForSuperclassOf: interruptedContext receiver class
		toImplement: message selector
		ifCancel: [^self].
	
	self implement: message inClass: chosenClass context: self selectedContext

! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:43:25'!
                         implement: aMessage inClass: aClass context: aContext 
	
	aClass
		compile: aMessage createStubMethod
		classified: (self askForCategoryIn: aClass default: 'as yet unclassified').
		
	aContext privRefreshWith: (aClass lookupSelector: aMessage selector).
	aMessage arguments withIndexDo: [ :arg :index | aContext tempAt: index put: arg ].
	self resetContext: aContext! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:22:28'!
     wasInterrupedOnDoesNotUnderstand

	^self interruptedContext selector == #doesNotUnderstand:! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:25:23'!
                        wasInterruptedOnSubclassResponsibility

	^self interruptedContext sender ifNil: [ false ] ifNotNil: [ :senderContext | senderContext selector == #subclassResponsibility ]! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:31:48' prior: 50336551!
                         askForSuperclassOf: aClass toImplement: aSelector ifCancel: cancelBlock

	^self askForSuperclassOf: aClass upTo: ProtoObject toImplement: aSelector ifCancel: cancelBlock
! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 18:46:00' prior: 50336572!
                         createMethod

	self wasInterrupedOnDoesNotUnderstand ifTrue: [ ^self createMethodWhenDoesNotUndertand ].
	self wasInterruptedOnSubclassResponsibility ifTrue: [ ^self createMethodOnSubclassResponsibility ].
	
	self inform: 'Only available for #doesNotUndertand: and #subclassResponsibility' ! !
!Debugger methodsFor: 'method creation' stamp: 'HAW 1/12/2017 17:22:47' prior: 50336585!
 shouldBeAbleToCreateMethod

	^self wasInterrupedOnDoesNotUnderstand or: [ self wasInterruptedOnSubclassResponsibility]! !
!DebuggerWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:46:32' prior: 50336591!
          customButtonSpecs
	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."

	^#(
		('Restart'		restart				'reset this context to its start.')
		('Into'			send					'step Into message sends')
		('Over'			doStep				'step Over message sends')
		('Through'		stepIntoBlock		'step into a block')
		('Full Stack'	fullStack			'show full stack')
		('Where'		where				'select current pc range')
		('Create'		createMethod		'create method'))! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:47:35' prior: 50336610!
          buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: Color transparent.
	row separation: 1.
	row addMorphs: buttons.
	^row! !

Debugger removeSelector: #create!

Debugger removeSelector: #create!

Debugger removeSelector: #implement:inClass:!

Debugger removeSelector: #implement:inClass:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3034-CreateMethodSupport-HernanWilkinson-1-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3032] on 14 January 2017 at 9:09:47 am'!
!Theme methodsFor: 'menus' stamp: 'jmv 1/14/2017 09:09:05' prior: 16936064!
                             miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history' 'code file contents' 'package file contents') -> #changesIcon.
		#('Install New Updates' 'update' 'turn on auto-update (a)' 'update list (u)' 'install code' 'fileIn entire file' 'install package') -> #updateIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' 'turn off auto-update (a)') -> #cancelIcon.
		#('debug...' 'Debug it (D)' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'restore all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor'  'basic text editor'  'unicode editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList' 'compress file') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner' 'Accept & Run Test in Class (t)' 'Accept & Run Test in Category (y)') -> #weatherFewCloudsIcon.
		#('Font Sizes...' 'system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'All preferences...' 'what to show...' 'view as hex') -> #preferencesIcon.
		#('Editor keyboard shortcuts') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.		"currently unused, but a neat icon"
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set code author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'Profile it') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance') -> #instanceIcon.
		#('Use Selection for Find (j)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('smalltalk options' 'method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)' 'Toggle WordWrap') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)' 'More...') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...' 'Set Default Font...') -> #fontXGenericIcon.
		#('Clear Font') -> #newIcon.
		#('code file browser' 'package file browser') -> #findIcon.
	}! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."
Theme current class beCurrent!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3035-AddIconsForTDDSupport-JuanVuletich-2017Jan14-09h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3035] on 16 January 2017 at 11:04:32 am'!

(Smalltalk classNamed: 'Taskbar') ifNotNil: [ :tbClass |
	PasteUpMorph allInstancesDo: [ :w | w hideTaskbar ].
	tbClass allInstancesDo: [ :each | each delete ]]!

StringMorph subclass: #UpdatingStringMorph
	instanceVariableNames: 'target getSelector stepTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!

!classDefinition: #UpdatingStringMorph category: #'Morphic-Widgets'!
StringMorph subclass: #UpdatingStringMorph
	instanceVariableNames: 'target getSelector stepTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets'!
!UpdatingStringMorph commentStamp: 'jmv 1/5/2013 23:49' prior: 0!
        UpdatingStringMorph new
     target: [self runningWorld activeHand morphPosition asString];
     getSelector: #value;
     stepTime: 10;
     openInWorld!

LayoutMorph subclass: #TaskbarMorph
	instanceVariableNames: 'viewBox scale'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Taskbar'!

!classDefinition: #TaskbarMorph category: #'Tools-Taskbar'!
LayoutMorph subclass: #TaskbarMorph
	instanceVariableNames: 'viewBox scale'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Taskbar'!
!TaskbarMorph commentStamp: '<historical>' prior: 0!
      A simple task bar written for Cuis.

dashBoard contains views/controls
viewBox contains graphic buttons of "iconized" windows/morphs.
scale allows 1x 2x 4x tarkbar height. [scale= 1,2,4]!
!Preferences class methodsFor: 'personalization' stamp: 'jmv 1/15/2017 18:51:02'!
                  taskbarIncludesAllWindows
	"
	true: All windows are included in Taskbar
	false: Only collapsed windows are included in Taskbar
	"
	^ self
		valueOfFlag: #taskbarIncludesAllWindows
		ifAbsent: [ true ].! !
!Morph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 18:06:45'!
                   taskbar
	^self world ifNotNil: [ :w | w taskbar ]! !
!Morph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/15/2017 14:52:58'!
showAndComeToFront

	self show; comeToFront! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 1/16/2017 09:56:14'!
   addedMorph: aMorph
	"Notify the receiver that the given morph was just added."
	super addedMorph: aMorph.
	self taskbar ifNotNil: [ :tb |
		tb wasOpened: aMorph ]! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 1/16/2017 09:56:07'!
            removedMorph: aMorph
	"Notify the receiver that aMorph was just removed from its children"
	super removedMorph: aMorph.
	self taskbar ifNotNil: [ :tb |
		tb wasDeleted: aMorph ]! !
!PasteUpMorph methodsFor: 'taskbar' stamp: 'jmv 1/15/2017 18:57:53'!
      taskbarDeleted
	taskbar _ nil! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
                     getSelector: aSymbol
	getSelector _ aSymbol! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:18'!
       stepTime

	^stepTime! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
                              stepTime: aNumber
	stepTime _ aNumber! !
!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jmv 1/4/2013 13:15'!
             target: anObject
	target _ anObject! !
!UpdatingStringMorph methodsFor: 'initialization' stamp: 'jmv 9/13/2013 09:23'!
         initialize
	super initialize.
	target _ self.
	getSelector _ #contents.
	stepTime _ 50! !
!UpdatingStringMorph methodsFor: 'stepping' stamp: 'jmv 2/27/2016 20:07'!
                            stepAt: millisecondSinceLast

	self contents: (target perform: getSelector)! !
!UpdatingStringMorph methodsFor: 'stepping' stamp: 'jmv 1/4/2013 13:18'!
        wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run"

	^true! !
!UpdatingStringMorph methodsFor: 'geometry' stamp: 'jmv 1/15/2017 14:25:27'!
                fitContents
	"Don't shrink each time contents change.
	Might shrink during layout"
	self morphExtent: (extent max: self measureContents)! !
!UpdatingStringMorph class methodsFor: 'new-morph participation' stamp: 'jmv 4/15/2014 09:26'!
                     initializedInstance
	"Answer a digital clock"

	| newInst |
	newInst := self 
		contents: '' 
		font: (AbstractFont familyName: 'DejaVu' pointSize: 22) 
		emphasis: AbstractFont  boldCode.
	newInst 
		stepTime: 500; "half a second"
		target: [String streamContents: [ :strm | DateAndTime now printHMSOn: strm]] ;
		getSelector: #value.
		
	^ newInst! !
!TaskbarMorph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 14:49:41'!
                        buttonFor: aMorph
	
	viewBox ifNotNil: [
		viewBox submorphs do: [ :button | 
			button model == aMorph
				ifTrue: [ ^button ]]
	].
	^nil! !
!TaskbarMorph methodsFor: 'accessing' stamp: 'jmv 1/15/2017 14:49:30'!
           scale

	 ^ scale ifNil: [ self defaultScale ] ifNotNil: [ scale ]! !
!TaskbarMorph methodsFor: 'events' stamp: 'jmv 1/8/2017 16:48:00'!
                        notifyDisplayResize
	Display
		when: #screenSizeChanged
		send: #screenSizeChanged
		to: self.
	self screenSizeChanged! !
!TaskbarMorph methodsFor: 'events' stamp: 'jmv 1/8/2017 16:48:14'!
   screenSizeChanged
	"Respond to change in screen size by repositioning self to bottom of screen"
	
"	Transcript newLine; print: 'Taskbar screenSizeChanged'.
"
	| y e |
	WorldState addDeferredUIMessage: [
		self world ifNotNil: [ :w |
			y _ w morphExtent y - self defaultHeight.
			e _ self internalizeDistance: w morphExtent x @ self defaultHeight.
			self morphPosition: 0@y extent: e ]]! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/15/2017 14:49:51'!
            defaultHeight

	^ Preferences windowTitleFont height * 2 * self scale! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/15/2017 14:49:19'!
           defaultScale

	 ^ 1! !
!TaskbarMorph methodsFor: 'initialization' stamp: 'jmv 1/8/2017 16:57:33'!
                              initialize
	super initialize.
	viewBox _ LayoutMorph newRow color: self defaultColor.
	self
		addMorph: UpdatingStringMorph initializedInstance
		layoutSpec:  (LayoutSpec morphWidthProportionalHeight: 1.0).
	self
		addMorph: viewBox 
		layoutSpec: (LayoutSpec
			proportionalWidth: 1.0
			proportionalHeight: 1.0 
			minorDirectionPadding: #right).
	viewBox separation: 5
! !
!TaskbarMorph methodsFor: 'testing' stamp: 'jmv 1/8/2017 16:44:53'!
    is: aSymbol
	^ aSymbol == #TaskbarMorph or: [ super is: aSymbol ]! !
!TaskbarMorph methodsFor: 'testing' stamp: 'jmv 1/8/2017 16:47:41'!
                       isSticky
	"answer whether the receiver is Sticky"
	^true! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:42:23'!
                              addButtonFor: aMorph

	| button |
	button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #showAndComeToFront.
	button
		color: self color;
		icon: (aMorph imageForm: 32);
		setBalloonText: aMorph label.
	viewBox
		addMorph: button
		fixedWidth: self defaultHeight! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:20:11'!
                       removeButtonFor: aMorph

	(self buttonFor: aMorph) ifNotNil: [ :b |
		b delete ]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:49:21'!
      restoreAll
	viewBox ifNotNil: [
		viewBox submorphs do: [ :button | 
			button model showAndComeToFront ]	]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:23:09'!
           wasCollapsed: aMorph
	"Add a button for aMorph if not already there (see #taskbarIncludesAllWindows)"

	(self buttonFor: aMorph) ifNil: [
		self addButtonFor: aMorph ]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:25:27'!
               wasDeleted: aMorph
	"aMorph was deleted. Remove button for aMorph"

	self removeButtonFor: aMorph! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:19:22'!
                     wasMadeVisible: aMorph
	"aMorph is now visible. Remove button for aMorph if appropriate (see #taskbarIncludesAllWindows)"

	Preferences taskbarIncludesAllWindows ifFalse: [
		self removeButtonFor: aMorph ]! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/15/2017 18:21:15'!
         wasOpened: aMorph
	"aMorph was added to the world. Add button for aMorph if appropriate (see #taskbarIncludesAllWindows)"
	
	Preferences taskbarIncludesAllWindows ifTrue: [
		self addButtonFor: aMorph ]! !
!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/15/2017 18:57:58'!
delete

	| w |
	self restoreAll.
	super delete.
	w _ self world ifNil: [ self runningWorld ].
	Display removeActionsWithReceiver: self.
	w ifNotNil: [ w taskbarDeleted ]! !
!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/16/2017 09:52:23'!
 noteNewOwner: aMorph
	"I have just been added as a submorph of aMorph"
	super noteNewOwner: aMorph.
	Preferences taskbarIncludesAllWindows ifTrue: [
		aMorph submorphsDo: [ :m |
			m == self ifFalse: [
				self addButtonFor: m ]]].
	self notifyDisplayResize! !
!TaskbarMorph methodsFor: 'menus' stamp: 'jmv 1/15/2017 19:14:11'!
                        handlesMouseDown: aMouseButtonEvent

	^ true! !
!TaskbarMorph methodsFor: 'menus' stamp: 'jmv 1/15/2017 19:10:57'!
             mouseButton2Activity

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	menu
		addLine;
		add: 'Normal Height' action: #scaleNormal;
		add: 'Scale x 2' action: #scaleX2;
		add: 'Scale x 4' action: #scaleX4.
	menu popUpInWorld! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:01:25'!
                   scale: anInteger

	(anInteger between: 1 and: 4) ifFalse: [ self error: 'scale should be 1 2 or 4' ].
	scale := anInteger.
	self screenSizeChanged. "rescale self"
	viewBox ifNotNil: [ "rescale buttons"
		viewBox submorphs do: [ :button | 
			button layoutSpec fixedWidth: self defaultHeight
		]
	]! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:49'!
               scaleNormal

	self scale: 1! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:52'!
                             scaleX2

	self scale: 2! !
!TaskbarMorph methodsFor: 'resize' stamp: 'jmv 1/15/2017 19:00:55'!
 scaleX4

	self scale: 4! !
!TaskbarMorph class methodsFor: 'system startup' stamp: 'jmv 1/8/2017 16:47:17'!
                    initClassCachedState

	"Should use some other way to find relevant instances"
	self flag: #jmvVer2.
	self allInstancesDo: [ :each |
		each notifyDisplayResize ]! !
!Morph methodsFor: 'drawing' stamp: 'jmv 1/15/2017 18:24:25' prior: 16874345!
              visible: aBoolean
	"set the 'visible' attribute of the receiver to aBoolean"

	self visible == aBoolean
		ifTrue: [ ^ self ].
	aBoolean ifFalse: [
		self redrawNeeded ].
	self setProperty: #visible toValue: aBoolean.
	owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
	aBoolean ifTrue: [
		self redrawNeeded.
		self taskbar ifNotNil: [ :tb |
			tb wasMadeVisible: self ]]! !
!Morph methodsFor: 'halos and balloon help' stamp: 'jmv 1/15/2017 14:58:58' prior: 16875692!
                               comeToFrontAndAddHalo
	self show.
	self comeToFront.
	self addHalo! !
!Morph methodsFor: 'menus' stamp: 'jmv 1/15/2017 18:24:40' prior: 16876276!
              collapse
	"If taskbar not visible, just hide."

	self hide.
	self taskbar
		ifNotNil: [ :tb | tb wasCollapsed: self ]! !
!Morph methodsFor: 'menus' stamp: 'jmv 1/15/2017 14:59:12' prior: 16876281!
                           expand
	
	self show.
	self comeToFront! !
!Morph methodsFor: 'testing' stamp: 'jmv 1/15/2017 15:04:18' prior: 16876985!
        isCollapsed

	^ self visible not! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 1/8/2017 16:44:57' prior: 16887743!
    allNonWindowRelatedSubmorphs
	"Answer all non-window submorphs that are not flap-related"

	^submorphs 
		reject: [ :m | (m is: #SystemWindow) or: [ m is: #TaskbarMorph ] ]! !
!PasteUpMorph methodsFor: 'taskbar' stamp: 'jmv 1/15/2017 14:43:48' prior: 16887920!
                           showTaskbar

	taskbar ifNil: [
		taskbar _ TaskbarMorph newRow.
		taskbar openInWorld: self ]! !
!StringMorph methodsFor: 'geometry' stamp: 'jmv 1/15/2017 14:22:53' prior: 16918181!
          measureContents
	| f |
	f _ self fontToUse.
	^((f widthOfString: contents) max: 3)  @ f height! !

TaskbarMorph removeSelector: #intoWorld:!

PasteUpMorph removeSelector: #isCollapsed:!

PasteUpMorph removeSelector: #isCollapsed:!

PasteUpMorph removeSelector: #minimize:!

PasteUpMorph removeSelector: #minimize:!

PasteUpMorph removeSelector: #restore:!

PasteUpMorph removeSelector: #restore:!

PasteUpMorph removeSelector: #taskbar:!

PasteUpMorph removeSelector: #taskbar:!

PasteUpMorph allInstancesDo: [ :w | w showTaskbar ]!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3036-NewTaskbar-JuanVuletich-2017Jan16-10h55m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3036] on 17 January 2017 at 11:13:18 am'!
!DebuggerWindow methodsFor: 'GUI building' stamp: 'jmv 1/17/2017 10:51:52'!
                          initialExtent
	^ RealEstateAgent standardWindowExtent * 3 // 2! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 1/17/2017 11:12:27' prior: 16898269!
                    maximumUsableAreaInWorld: aWorldOrNil

	| allowedArea |
	allowedArea _ Display boundingBox.
	aWorldOrNil ifNotNil: [
		allowedArea _ allowedArea intersect: aWorldOrNil viewBox.
		aWorldOrNil taskbar ifNotNil: [ :tb |
			allowedArea _ (allowedArea areasOutside: tb morphBoundsInWorld) first ]].
	^allowedArea
! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 1/17/2017 11:00:35' prior: 16887247!
                  privateExtent: newExtent

	^ (super privateExtent: newExtent)
		ifTrue: [
			self buildMagnifiedBackgroundImage.
			worldState clearCanvas ]; yourself! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 1/17/2017 10:56:23' prior: 16887422!
           viewBox

	^ worldState
		ifNotNil: [
			 0@0 extent: extent ]
		ifNil: [
			self world viewBox ]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 1/17/2017 11:05:24' prior: 16887834!
   restoreMorphicDisplay
	DisplayScreen startUp.
	self
		morphExtent: Display extent;
		handsDo: [ :h | h visible: true ];
		fullRepaintNeeded.
	WorldState addDeferredUIMessage: [ Cursor normal activateCursor ]! !
!PasteUpMorph class methodsFor: 'instance creation' stamp: 'jmv 1/17/2017 11:04:44' prior: 16887959!
        newWorld
	"
[
	ProjectX stopUIProcess.
	ProjectX spawnNewMorphicProcessFor: PasteUpMorph newWorld
] fork.
	"
	| w ws |
	w _ self new.
	ws _ WorldState new.
	w worldState: ws.
	w morphPosition: 0@0 extent: Display extent.
	ws setCanvas: Display getCanvas.
	w borderWidth: 0.
	ws handsDo: [ :h |
		h privateOwner: w ].
	^w! !
!WorldState methodsFor: 'canvas' stamp: 'jmv 1/17/2017 10:57:47' prior: 16945711!
          ensureNonDisplayCanvas
	(canvas isNil or: [
		canvas drawsOnDisplay or: [
		(canvas extent ~= world morphExtent) or: [
		canvas form depth ~= Display depth]]]) ifTrue: [
			"allocate a new offscreen canvas the size of the window"
			self setCanvas: (BitBltCanvas withExtent: world morphExtent depth: Display depth)]! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 1/17/2017 11:05:18' prior: 16946039!
         tryDeferredUpdatingAndSetCanvasFor: aWorld
        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, set a non-Disply canvas and answer false.."
	| properDisplay |
	
	"As this is the only sender of #deferUpdates: , this could be done in Morphic or image startup, and never efterwards..."
	(Display deferUpdates: true) ifNil: [
		"deferred updates not supported by the VM, do them in the image!!"
		self ensureNonDisplayCanvas.
		^ false].
	
	"if no canvas, or canvas was offscreen, from a platform that didnt support defers, then fix it"
	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].
	properDisplay ifFalse: [
		aWorld morphPosition: 0@0 extent: Display extent.
		self setCanvas: Display getCanvas.
	].
	^ true! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 7/28/2015 08:35' prior: 16946090!
                  displayWorld: aWorld submorphs: submorphs
	"Update this world's display."

	| deferredUpdateVMMode worldDamageRects handsToDraw allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"
	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvasFor: aWorld.

	"repair world's damage on canvas"
	worldDamageRects _ self drawInvalidAreasWorld: aWorld submorphs: submorphs.

	"Check which hands need to be drawn (they are not the hardware mouse pointer)"
	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.
	allDamage _ Array streamContents: [ :strm |
		strm nextPutAll: worldDamageRects.
		handsToDraw do: [ :h | 
			h savePatchFrom: canvas appendDamageTo: strm ]].

	"Draw hands (usually carying morphs) onto world canvas"
	canvas newClipRect: nil.
	handsToDraw reverseDo: [ :h | canvas fullDrawHand: h ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		"Drawing was done to off-Display canvas. Copy content to Display"
		canvas showAt: aWorld viewBox origin invalidRects: allDamage ].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	Display forceDamageToScreen: allDamage.

	"Restore world canvas under hands and their carried morphs"
	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].! !

WorldState removeSelector: #viewBox!

WorldState removeSelector: #viewBox!

WorldState removeSelector: #viewBox:!

WorldState removeSelector: #viewBox:!

DebuggerWindow removeSelector: #initialFrameIn:!

DebuggerWindow removeSelector: #initialFrameIn:!

PasteUpMorph removeSelector: #viewBox:!

PasteUpMorph removeSelector: #viewBox:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3037-WindowsAvoidTaskbarArea-JuanVuletich-2017Jan17-10h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3037] on 18 January 2017 at 10:36:09 am'!
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/18/2017 10:34:55' prior: 50337258!
                  addButtonFor: aMorph

	| button |
	aMorph == self ifFalse: [
		button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #showAndComeToFront.
		button
			color: self color;
			icon: (aMorph imageForm: 32);
			setBalloonText: aMorph label.
		viewBox
			addMorph: button
			fixedWidth: self defaultHeight ]! !
!TaskbarMorph methodsFor: 'submorphs-add/remove' stamp: 'jmv 1/18/2017 10:35:05' prior: 50337321!
                      noteNewOwner: aMorph
	"I have just been added as a submorph of aMorph"
	super noteNewOwner: aMorph.
	Preferences taskbarIncludesAllWindows ifTrue: [
		aMorph submorphsDo: [ :m |
			self addButtonFor: m ]].
	self notifyDisplayResize! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3038-TaskbarTweaks-JuanVuletich-2017Jan18-10h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3038] on 18 January 2017 at 7:35:13 pm'!
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:20:57'!
   fileMatching: pattern
"
	DirectoryEntry smalltalkImageDirectory fileMatching: '*.image'.
	DirectoryEntry smalltalkImageDirectory fileMatching: 'x*.image'.
"
	self filesDo: [ :file |
		(pattern match: file name)
			ifTrue: [ ^ file ]].
	^ nil! !
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:13:59' prior: 16834484!
                directoriesDo: aBlock
	self childrenDo: [ :each |
		each isFile ifFalse: [
			aBlock value: each ]]! !
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:19:42' prior: 16834701!
                              directoryMatching: pattern
"
	DirectoryEntry smalltalkImageDirectory directoryMatching: 'C*Pack*'.
	DirectoryEntry smalltalkImageDirectory directoryMatching: 'xC*Pack*'.
"
	self directoriesDo: [ :directory |
		(pattern match: directory name)
			ifTrue: [ ^ directory ]].
	^ nil! !
!DirectoryEntry methodsFor: 'enumeration' stamp: 'jmv 1/18/2017 11:14:17' prior: 16834493!
            filesDo: aBlock
	self childrenDo: [ :each |
		each isFile ifTrue: [
			aBlock value: each ]]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3039-DirectoryEntryTweaks-JuanVuletich-2017Jan18-19h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3039] on 18 January 2017 at 10:26:44 pm'!
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 1/18/2017 22:25:29' prior: 50337619!
                           addButtonFor: aMorph

	| button |
	aMorph == self ifFalse: [
		button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #showAndComeToFront.
		button
			color: self color;
			icon: (aMorph imageForm: 32);
			setBalloonText: aMorph label.
		button icon: button magnifiedIcon.
		viewBox
			addMorph: button
			fixedWidth: self defaultHeight ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3040-DontWasteMemoryOnTaskbarButtons-JuanVuletich-2017Jan18-22h26m-jmv.1.cs.st----!

----SNAPSHOT----#(18 January 2017 10:36:10.429049 pm) Cuis5.0-3040-spur-64.image priorSource: 83443!

----QUIT----#(18 January 2017 10:36:23.953152 pm) Cuis5.0-3040-spur-64.image priorSource: 193992!

----STARTUP----#(20 February 2017 12:08:31.543295 pm) as /home/juan/Rectifier/Cuis-Smalltalk-Dev/Cuis5.0-3040-spur-64.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3040] on 22 January 2017 at 9:33:48 pm'!
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 1/22/2017 21:17:32' prior: 50337474!
                            privateExtent: newExtent

	^ (super privateExtent: newExtent)
		ifTrue: [
			self buildMagnifiedBackgroundImage.
			worldState ifNotNil: [
				worldState clearCanvas ]];
		yourself! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 1/22/2017 21:25:10' prior: 16926091!
                   drawOn: aCanvas

	| titleColor roundCorners |

	titleColor _ self widgetsColor.
	self isTopWindow
		ifTrue: [ titleColor _ titleColor lighter ].

	roundCorners _ Theme current roundWindowCorners.
	roundCorners
		ifTrue: [
			"Round corners. Optional title gradient."
			self drawRoundedFrameOn: aCanvas color: titleColor ]
		ifFalse: [
			"No round corners. No title gradient."
			self drawClassicFrameOn: aCanvas color: titleColor ].
	Theme current minimalWindows
		ifFalse: [
			labelString ifNotNil: [self drawLabelOn: aCanvas]]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 1/22/2017 21:31:40' prior: 16866779!
                       popUpInWorld: aWorld
	"Present this menu under control of the given hand."
	"Needed if not the real world but an inner PasteUpMorph"
	| positionInWorld |
	positionInWorld _ aWorld internalizeFromWorld: aWorld activeHand morphPosition.
	^self
		popUpAt: positionInWorld
		forHand: aWorld activeHand
		in: aWorld
! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3041-Fix-clearCanvas-DNU-JuanVuletich-2017Jan22-21h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #2974] on 3 December 2016 at 9:04:32 am'!
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:13'!
                           montgomeryDigitBase
	"Answer the base used by Montgomery algorithm."
	^1 << self montgomeryDigitLength! !
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:27'!
                        montgomeryDigitLength
	"Answer the number of bits composing a digit in Montgomery algorithm.
	Primitive use either 8 or 32 bits digits"
	<primitive: 'primMontgomeryDigitLength' module:'LargeIntegers'>
	^8 "Legacy plugin which did not have this primitive did use 8 bits digits"! !
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:14'!
          montgomeryDigitMax
	"Answer the maximum value of a digit used in Montgomery algorithm."
	
	^1 << self montgomeryDigitLength - 1! !
!Integer methodsFor: 'private' stamp: 'nice 1/19/2013 03:16'!
                               montgomeryNumberOfDigits
	"Answer the number of montgomery digits required to represent the receiver."
	^self digitLength * 8 + (self montgomeryDigitLength - 1) // self montgomeryDigitLength! !
!Integer methodsFor: 'mathematical functions' stamp: 'nice 1/16/2013 18:38' prior: 16859768!
 raisedTo: n modulo: m
	"Answer the modular exponential.
	Note: this implementation is optimized for case of large integers raised to large powers."
	| a s mInv |
	n = 0 ifTrue: [^1].
	(self >= m or: [self < 0]) ifTrue: [^self \\ m raisedTo: n modulo: m].
	n < 0 ifTrue: [^(self reciprocalModulo: m) raisedTo: n negated modulo: m].
	(n < 4096 or: [m even])
		ifTrue:
			["Overhead of Montgomery method might cost more than naive divisions, use naive"
			^self slidingLeftRightRaisedTo: n modulo: m].
	
	mInv := self montgomeryDigitBase - ((m bitAnd: self montgomeryDigitMax) reciprocalModulo: self montgomeryDigitBase).
 
	"Initialize the result to R=self montgomeryDigitModulo raisedTo: m montgomeryNumberOfDigits"
	a := (1 bitShift: m montgomeryNumberOfDigits * m montgomeryDigitLength) \\ m.
	
	"Montgomerize self (multiply by R)"
	(s := self montgomeryTimes: (a*a \\ m) modulo: m mInvModB: mInv)
		ifNil:
			["No Montgomery primitive available ? fallback to naive divisions"
			^self slidingLeftRightRaisedTo: n modulo: m].

	"Exponentiate self*R"
	a := s montgomeryRaisedTo: n times: a modulo: m mInvModB: mInv.

	"Demontgomerize the result (divide by R)"
	^a montgomeryTimes: 1 modulo: m mInvModB: mInv! !
!Integer methodsFor: 'testing' stamp: 'nice 11/14/2011 21:59' prior: 16860231!
                      isProbablyPrime
	"See isProbablyPrimeWithK:andQ: for the algoritm description."
	
	| k q |
	self <= 1 ifTrue: [ ^false ].
	self even ifTrue: [ ^self = 2 ].
	"Factor self into (2 raisedTo: k) * q + 1, where q odd"
	q := self bitShift: -1.
	k := q lowBit.
	q := q bitShift: 1 - k.
	"Repeat the probabilistic until false (the probability of false negative is null) or until probability is very low."
	25 timesRepeat: [ (self isProbablyPrimeWithK: k andQ: q) ifFalse: [ ^false ] ].
	"The probability of false positive after 25 iterations is less than (1/4 raisedTo: 25) < 1.0e-15"
	^true! !
!Integer methodsFor: 'private' stamp: 'nice 11/15/2011 23:13' prior: 16860590!
      isProbablyPrimeWithK: k andQ: q 
	"Algorithm P, probabilistic primality test, from
	Knuth, Donald E. 'The Art of Computer Programming', Vol 2,
	Third Edition, section 4.5.4, page 395, P1-P5 refer to Knuth description..
	Note that this is a Miller Rabin test which may answer false positives (known as pseudoprimes) for at most 1/4 of the possible bases x."

	| x j y minusOne |
	"P1"
	x := (self - 2) atRandom + 1.
	"P2"
	j := 0.
	y := x raisedTo: q modulo: self.
	minusOne := self - 1.
	
	["P3"
	y = 1 ifTrue: [^j = 0].
	y = minusOne ifTrue: [^true].
	"P4"
	(j := j + 1) < k]
		whileTrue:
			[y := y squared \\ self].
	"P5"
	^false! !
!Integer methodsFor: 'private' stamp: 'nice 1/16/2013 18:40' prior: 16860675!
                      montgomeryTimes: a modulo: m mInvModB: mInv
	"Answer the result of a Montgomery multiplication
	self * a * (b raisedTo: m montgomeryNumberOfDigits) inv \\ m
	NOTE: it is assumed that:
	self montgomeryNumberOfDigits <= m montgomeryNumberOfDigits
	a montgomeryNumberOfDigits <= m montgomeryNumberOfDigits
	mInv * m \\ b = (-1 \\ b) = (b-1) (this implies m odd)
	where b = self montgomeryDigitBase
	
	Answer nil in case of absent plugin or other failure."
	
	<primitive: 'primMontgomeryTimesModulo' module:'LargeIntegers'>
	^nil! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3042-MontgomeryExponentiationFix-LucianoEstebanNotarfrancesco-2016Nov29-21h10m-len.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3042] on 22 January 2017 at 9:49:56 pm'!
!Integer methodsFor: 'arithmetic' stamp: 'len 12/4/2016 13:11:44'!
        reciprocalModulo2: n
	"Answer an integer x such that self * x \\ n = 1, with 0 < x < n, or nil if it doesn't exist."
	| xgcd |
	self == 0 ifTrue: [^ nil].
	self == 1 ifTrue: [^ 1].
	xgcd _ self xgcd: n.
	^ (xgcd at: 1) == 1 ifTrue: [^ (xgcd at: 2) \\ n]! !
!Integer methodsFor: 'arithmetic' stamp: 'len 12/4/2016 13:07:08'!
                            xgcd: anInteger
	"Extended Euclidean algorithm.
	Answer an array {x. u. v} where self * u + (anInteger * v) = x, and x = (self gcd: anInteger)."
	| a b s t sp tp r rp |
	a _ self. b _ anInteger.
	s _ 0. sp _ 1.
	t _ 1. tp _ 0.
	r _ a abs. rp _ b abs.
	[r == 0]
		whileFalse:
			[ | q temp |
			q _ rp // r.
			temp _ r. r _ rp - (q * r). rp _ temp.
			temp _ s. s _ sp - (q * s). sp _ temp.
			temp _ t. t _ tp - (q * t). tp _ temp].
	sp _ sp * b sign. tp _ tp * a sign.
	^ {rp. tp. sp}! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3043-Alternative-gcd-reciprocalModulo-LucianoEstebanNotarfrancesco-2017Jan22-21h46m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3043] on 16 February 2017 at 2:31:35 pm'!
!FileSystemEntry methodsFor: 'accessing-file name' stamp: 'jmv 2/16/2017 11:21:10' prior: 16843823!
        baseName
	^self fileAccessor baseNameFor: name! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3044-basename-fix-JuanVuletich-2017Feb16-11h21m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3044] on 17 February 2017 at 3:11:08 pm'!
!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 2/17/2017 15:10:48' prior: 16888368!
           magnifiedIcon
	| factor magnifiedExtent w h |

	icon ifNil: [ ^nil ].
	magnifiedIcon ifNil: [
		magnifiedIcon _ icon.
		w _ icon width.
		h _ icon height.
		w*h = 0 ifFalse: [
			factor _ 1.0 * extent x / w min: 1.0 * extent y / h.
			(factor < 1 or: [ factor > 1.7 and: [self isRoundButton]]) ifTrue: [
				magnifiedExtent _ (icon extent * factor) rounded.
				magnifiedIcon _ icon magnifyTo: magnifiedExtent ]]].
	^magnifiedIcon! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3045-magnifiedIcon-fix-JuanVuletich-2017Feb17-15h10m-jmv.1.cs.st----!

----SNAPSHOT----#(20 February 2017 12:09:34.739158 pm) Cuis5.0-3045-spur-64.image priorSource: 194094!

----QUIT----#(20 February 2017 12:09:57.201979 pm) Cuis5.0-3045-spur-64.image priorSource: 202910!

----STARTUP----#(6 March 2017 10:16:04.474788 am) as /home/juan/Rectifier/Cuis-Smalltalk-Dev/Cuis5.0-3045-spur-64.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3042] on 10 February 2017 at 5:39:28 pm'!

Object subclass: #ProgessiveTestRunner
	instanceVariableNames: 'testSuite testsStream progressBar testResult testRunIncrement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #ProgessiveTestRunner category: #'Tools-Testing'!
Object subclass: #ProgessiveTestRunner
	instanceVariableNames: 'testSuite testsStream progressBar testResult testRunIncrement'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!
!Browser methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:32:22'!
        debugMethodTest
	
	currentCompiledMethod isTestMethod ifTrue: [
		currentCompiledMethod methodClass debugAsFailure: currentCompiledMethod selector ]
! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/4/2017 20:33:00'!
            runClassTests
	
	self selectedClassName ifNotNil: [ :aClassName | | selectedClass |
		selectedClass _ Smalltalk classNamed: aClassName.
		(ProgessiveTestRunner for: (TestSuite forClass: selectedClass)) value ]! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/7/2017 10:47:50'!
                runMessageCategoryTests
	
	selectedMessageCategory ifNotNil: [ | selectedClass suite |
		selectedClass _ Smalltalk classNamed: selectedClassName.
		suite _ TestSuite forMessageCategoryNamed: selectedMessageCategory of: selectedClass categorizedWith: classOrganizer.
		(ProgessiveTestRunner for: suite) value ]
	
	! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/4/2017 21:51:50'!
        runMethodTest
	
	| suite |
	
	suite _ TestSuite forCompiledMethod: currentCompiledMethod.
	(ProgessiveTestRunner for: suite) value 
	! !
!Browser methodsFor: 'tdd' stamp: 'HAW 2/1/2017 19:23:54'!
                            runSystemCategoryTests
	
	selectedSystemCategory ifNotNil: [ | suite |
		suite _ TestSuite forSystemCategoryNamed: selectedSystemCategory using: systemOrganizer.
		(ProgessiveTestRunner for: suite) value ]
	
	! !
!Behavior methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:55:50'!
               testCaseClass

	self subclassResponsibility ! !
!Behavior methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:55:40'!
                    withTestCaseClassDo: aFoundTestCaseClassBlock ifNone: aNoneBlock 
		
	| potentialTestCaseClass |
	
	potentialTestCaseClass _ self testCaseClass.
	
	^potentialTestCaseClass ifNil: aNoneBlock ifNotNil: aFoundTestCaseClassBlock 
	! !
!Class methodsFor: 'tdd' stamp: 'HAW 2/7/2017 10:42:40'!
testCaseClass
		
	| potentialTestCaseClass |
	
	potentialTestCaseClass _ Smalltalk classNamed: self name, 'Test'.
	
	^potentialTestCaseClass 
	
 ! !
!Metaclass methodsFor: 'tdd' stamp: 'HAW 2/7/2017 11:56:51'!
              testCaseClass

	^self soleInstance testCaseClass ! !
!Categorizer methodsFor: 'tdd' stamp: 'HAW 2/7/2017 09:06:13'!
            classesAt: aCategoryName

	^(self listAtCategoryNamed: aCategoryName) collect: [:aClassName | Smalltalk classNamed: aClassName ]
		! !
!Categorizer methodsFor: 'tdd' stamp: 'HAW 2/7/2017 09:06:34'!
                          testCaseClassesAt: aCategoryName

	^(self classesAt: aCategoryName) select: [ :aClass | aClass is: #TestCaseClass ]! !
!SmalltalkEditor methodsFor: 'editing keys' stamp: 'HAW 2/10/2017 16:03:46'!
                            acceptAndDebugTest: aKeyboardEvent 
	
	^self acceptAndDebugTest ! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:34:45'!
                        acceptAndDebugTest
	
	^self acceptAndWithMethodDo: [ :aPotencialTestMethod | 
		aPotencialTestMethod isTestMethod ifTrue: [ aPotencialTestMethod methodClass debugAsFailure: aPotencialTestMethod selector ]]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:34:38'!
           acceptAndWithMethodDo: aBlock
	
	| potencialTestMethod |
	
	self acceptContents ifFalse: [ ^false ].
	
	potencialTestMethod _ self codeProvider currentCompiledMethod.
	^potencialTestMethod 
		ifNil: [ false ]
		ifNotNil: [
			aBlock value: potencialTestMethod.
			true]! !
!ProgessiveTestRunner methodsFor: 'initialization' stamp: 'HAW 2/1/2017 19:20:06'!
                            initializeFor: aTestSuite

	testSuite _ aTestSuite.
	! !
!ProgessiveTestRunner methodsFor: 'evaluating' stamp: 'HAW 1/31/2017 11:50:37'!
                       value

	testsStream _ ReadStream on: testSuite tests.
	testsStream atEnd
		ifTrue: [ self informNoTestToRun ]
	 	ifFalse:[ self createProgressBarAndRun ]! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:22'!
       calculateTestRunIncrement
	
	testRunIncrement _ 1/testsStream size! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:31'!
                              createProgressBar
		
	progressBar _ ProgressMorph label: testSuite name.
	self calculateTestRunIncrement.
	self updateProgressBarSubLabel.
	! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 10:25:43'!
                    updateDoneIncrement 

 	progressBar incrDone: testRunIncrement 
	! !
!ProgessiveTestRunner methodsFor: 'progress bar - private' stamp: 'HAW 1/31/2017 11:10:25'!
                               updateProgressBarSubLabel

	testsStream atEnd ifFalse: [
		progressBar subLabel: testsStream next printString, ' (', testsStream position printString, '/', testsStream size printString, ')' ].! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 1/31/2017 20:05:25'!
 informAllTestPassed 
	
	PopUpMenu inform: testResult printString.
	! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 1/31/2017 10:05:21'!
                              informNoTestToRun
		
	 PopUpMenu inform: 'No test to run'! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 2/1/2017 19:26:08'!
         openTestResultForDebuggingAndInspection

	testResult forDebuggingAndInspection inspect ! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 1/31/2017 10:10:53'!
          showDeffects
	
	 | defects |
			
	defects _ 	testResult defects.
	defects size = 1
		ifTrue: [ defects anyOne debug ] 
		ifFalse: [ self openTestResultForDebuggingAndInspection]! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:14:08'!
                  createProgressBarAndRun

	self createProgressBar.
	[ self runSuiteShowingProgress ] fork! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:26:59'!
           registerTestSuiteAction
		
	testSuite when: #changed: send: #testRun: to: self! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 10:09:41'!
                    runSuite
		
	testResult _ testSuite run.	
	testResult hasPassed 
		ifTrue: [ self informAllTestPassed ] 
		ifFalse: [self showDeffects ]
	! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 11:47:58'!
                        runSuiteShowingProgress

	[ self registerTestSuiteAction. 
	progressBar openInWorld.
	self runSuite ] ensure: [
		self unregisterTestSuiteAction.
		WorldState addDeferredUIMessage: [progressBar dismissMorph] ].
	! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 2/1/2017 19:19:28'!
               testRun: aTest

	self updateProgressBarSubLabel.
	self updateDoneIncrement 
	
		! !
!ProgessiveTestRunner methodsFor: 'evaluating - private' stamp: 'HAW 1/31/2017 10:04:32'!
                  unregisterTestSuiteAction
	
	testSuite releaseActionMap ! !
!ProgessiveTestRunner class methodsFor: 'instance creation' stamp: 'HAW 1/31/2017 09:37:34'!
       for: aTestSuite

	^self new initializeFor: aTestSuite! !
!TestCase class methodsFor: 'Instance Creation' stamp: 'HAW 2/10/2017 16:01:40'!
                      debugAsFailure: aSymbol

	^(self selector: aSymbol) debugAsFailure
			! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/4/2017 20:31:47'!
              forClass: aClass

	^(aClass is: #TestCaseClass) 
		ifTrue: [ self forTestCaseClass: aClass ]
		ifFalse: [ self forNoTestCaseClass: aClass ]
! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/4/2017 21:53:12'!
        forCompiledMethod: aCompiledMethod

	^aCompiledMethod isTestMethod 
		ifTrue: [ self forTestMethod: aCompiledMethod ]
		ifFalse: [ self forNoTestMethod: aCompiledMethod ]
	! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/1/2017 18:43:22'!
        forMessageCategoryNamed: aMessageCategoryName of: aClass categorizedWith: aClassOrganizer

	| suite |
	
	suite _ self named: aClass name, ' tests categorized under ',aMessageCategoryName.
	(aClassOrganizer listAtCategoryNamed: aMessageCategoryName) do: [ :selector |
		(aClass compiledMethodAt: selector) isTestMethod ifTrue: [ suite addTest: (aClass selector: selector) ]].
	
	^suite
	! !
!TestSuite class methodsFor: 'Creation' stamp: 'HAW 2/7/2017 10:24:12'!
                  forSystemCategoryNamed: aCategoryName  using: aSystemOrganizer 

	| testCaseClasses |
	
	testCaseClasses _ aSystemOrganizer testCaseClassesAt: aCategoryName.
	
	^testCaseClasses isEmpty 
		ifTrue: [ self forClasses: (aSystemOrganizer classesAt: aCategoryName) named: aCategoryName, ' infered tests' ]
		ifFalse: [ self forTestCaseClasses: testCaseClasses named: aCategoryName, ' tests' ]
		
! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:25:51'!
   allTestCaseClassesReferencing: aClass

	^(aClass allCallsOn 
		collect: [ :aMethodReference | aMethodReference actualClass ]
		thenSelect: [ :aPotentialTestCaseClass | aPotentialTestCaseClass is: #TestCaseClass ]) asSet.! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:27:27'!
              allTestsSending: aSelector
	
	^(Smalltalk allCallsOn: aSelector) select: [:aMethodReference | 
		(aMethodReference actualClass is: #TestCaseClass) and: [aMethodReference compiledMethod isTestMethod ]].! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 09:08:23'!
 forClasses: classes named: name

	| suite |
	
	suite _ classes
		inject: (self named: name)
		into: [ :partialSuite :aClass | partialSuite addTests: (self forClass: aClass) tests ].
		
	^suite
		
! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:32:17'!
      forNoTestCaseClass: aClass 

	^aClass 
		withTestCaseClassDo: [ :aTestCaseClass | self forTestCaseClass: aTestCaseClass ]
		ifNone: [ self forReferencesToClass: aClass ]

! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 11:28:55'!
                               forNoTestMethod: aCompiledMethod 
	
	| allTestSenders testCaseClassesReferencingClass reducedTestSenders suite |
	
	allTestSenders _ self allTestsSending: aCompiledMethod selector.
	testCaseClassesReferencingClass _ aCompiledMethod methodClass 
		withTestCaseClassDo:  [:aTestCaseClass | Array with: aTestCaseClass ]
		ifNone: [ self allTestCaseClassesReferencing: aCompiledMethod methodClass ].
		
	reducedTestSenders _ allTestSenders select: [ :aMethodReference | testCaseClassesReferencingClass includes: aMethodReference actualClass ].
	reducedTestSenders isEmpty 
		ifTrue: [ suite _ self forClass: aCompiledMethod methodClass ]
		ifFalse: [ 
			suite _ self named: 'Tests senders of ', aCompiledMethod selector.
			reducedTestSenders do: [ :aMethodReference | suite addTest: (aMethodReference actualClass selector: aMethodReference selector)]].
	
	^suite! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:33:27'!
              forReferencesToClass: aClass 

	| testCaseClasses |
	
	testCaseClasses _ self allTestCaseClassesReferencing: aClass.
		
	^testCaseClasses 
		inject: (self named: aClass name, ' all test references')
		into: [ :suite :aTestCaseClass | aTestCaseClass addToSuiteFromSelectors: suite ]
	

! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 10:34:27'!
             forTestCaseClass: aTestCaseClass 

	| suite |
	
	suite _ aTestCaseClass buildSuite.
	suite name: aTestCaseClass name, ' tests'.
	
	^suite! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/7/2017 09:04:48'!
 forTestCaseClasses: testCaseClasses named: aName

	| suite |
	
	suite _ testCaseClasses
		inject: (self named: aName) 
		into: [:partialSuite :aTestCaseClass | aTestCaseClass addToSuiteFromSelectors: partialSuite ].
		
	^suite! !
!TestSuite class methodsFor: 'Creation - Private' stamp: 'HAW 2/4/2017 21:53:22'!
        forTestMethod: aCompiledMethod
	
	| suite |
	
	suite _ self named: 'Test'.
	suite addTest: (aCompiledMethod methodClass selector: aCompiledMethod selector).
	
	^suite
		! !
!UndefinedObject methodsFor: 'class hierarchy' stamp: 'HAW 2/10/2017 17:37:23'!
   allSuperclassesUpTo: aSuperclass 

	self error: (self superclassNotValidErrorDescriptionFor: aSuperclass)! !
!UndefinedObject methodsFor: 'class hierarchy' stamp: 'HAW 2/10/2017 17:37:30'!
   superclassNotValidErrorDescriptionFor: aClass 

	^aClass name, ' not in superclasses chain'! !
!Behavior methodsFor: 'system-support' stamp: 'HAW 2/4/2017 20:51:10' prior: 16785122!
          allCallsOn
	"Answer a SortedCollection of all the methods that refer to me by name or 
	as part of an association in a global dict."
	"
	^ (Smalltalk
		allCallsOn: (Smalltalk associationAt: self theNonMetaClass name))
		, (Smalltalk allCallsOn: self theNonMetaClass name)
	"

	^ Smalltalk allCallsOn: self theNonMetaClass name! !
!SystemDictionary methodsFor: 'browsing' stamp: 'HAW 2/4/2017 20:49:09' prior: 16923905!
                             browseAllCallsOnClass: aClass
	"Create and schedule a message browser on each method that refers to 
	aClass. For example, Smalltalk browseAllCallsOnClass: Object."
	self
		browseMessageList: aClass allCallsOn asArray sort
		name: 'Users of class ' , aClass theNonMetaClass name
		autoSelect: aClass theNonMetaClass name.! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 18:51:22' prior: 50336089!
        acceptAndTest
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteOf: aMethod methodClass ].
	^true! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 18:50:41' prior: 50336095!
                         acceptAndTestAll
	
	self acceptThenTestMethodAndSuite: [ :aMethod | self testSuiteForCategoryOf: aMethod methodClass ].
	^true
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 17:34:52' prior: 50336102!
      acceptThenTestMethodAndSuite: aSuiteBuilder
	
	self acceptAndWithMethodDo: [ :aPotencialTestMethod |
		self runAndDebuggIfNecessary: aPotencialTestMethod.
		self runTestSuite: (aSuiteBuilder value: aPotencialTestMethod) ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/10/2017 16:08:47' prior: 50336124!
           runAndDebuggIfNecessary: aPotencialTestMethod

	aPotencialTestMethod isTestMethod ifTrue: [
		aPotencialTestMethod methodClass debug: aPotencialTestMethod selector ]! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/1/2017 19:19:02' prior: 50336132!
    runTestSuite: aTestSuite

	(ProgessiveTestRunner for: aTestSuite) value
	
	! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/5/2017 10:49:25' prior: 50336142!
                              testSuiteForCategoryOf: aClass

	^TestSuite forSystemCategoryNamed: aClass category using: SystemOrganization 
! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 2/5/2017 10:48:27' prior: 50336159!
                          testSuiteOf: aClass

	^TestSuite forClass: aClass
! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 2/10/2017 15:58:27' prior: 50336386!
                           cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$r	#acceptAndDebugTest:		'Saves method and debugs it')
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')
		#(		$l	#cancelEdits:						'Cancel')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$A	#argAdvance:						'Advance argument')
		#(		$D	#debugIt:							'Debut it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 2/10/2017 15:57:40' prior: 50336440!
          initializeMenu
	"Initialize the mouseButton2 (right button) pop-up menu and corresponding messages."
	"
	Editor initialize
	"

	menu _ SelectionMenu fromArray: {
		{'Help...'.										#openHelp}.
		#-.
		{'Do it (d)'.									#doIt}.
		{'Print it (p)'.									#printIt}.
		{'Inspect it (i)'.								#inspectIt}.
		{'Explore it (I)'.								#exploreIt}.
		{'Debug it (D)'.								#debugIt}.
		{'Profile it'.									#profileIt}.
		#-.
		{'Explain'.										#explain}.
		{'Browse it (b)'.								#browseIt}.
		{'Senders of it (n)'.							#sendersOfIt}.
		{'Implementors of it (m)'.					#implementorsOfIt}.
		{'References to it (N)'.						#referencesToIt}.
		#-.
		{'Method Strings with it (E)'.				#methodStringsContainingit}.
		{'Method Source with it'.					#methodSourceContainingIt}.
		{'Class Comments with it'.					#classCommentsContainingIt}.
		#-.
		{'Accept (s)'.									#acceptContents}.
		{'Cancel (l)'.									#cancelEdits}.
		{'Accept & Run Test in Class (t)'.			#acceptAndTest}.
		{'Accept & Run Test in Category (y)'.		#acceptAndTestAll}.
		{'Accept & Debug Test (r)'.					#acceptAndDebugTest}.
		#-.
		{'More...'.										#getMenu2}.
	}.
	menu2 _ SelectionMenu fromArray: {
		{'Find...(f)'.									#find}.
		{'Find Again (g)'.								#findAgain}.
		{'Use Selection for Find (j)'.				#setSearchString}.
		#-.
		{'Undo - multiple (z)'.						#undo}.
		{'Redo - multiple (Z)'.						#redo}.
		{'Undo / Redo history'.						#offerUndoHistory}.
		#-.
		{'Copy (c)'.									#copySelection}.
		{'Cut (x)'.										#cut}.
		{'Paste (v)'.									#paste}.
		{'Paste without Format'.						#pasteString}.
		{'Paste...'.									#pasteRecent}.
		#-.
		{'Toggle WordWrap'.						#wrapOnOff}.
		{'Set Font... (k)'.								#offerFontMenu}.
		{'Clear Font'.									#clearFont}.
		{'Set Default Font...'.						#offerDefaultFontMenu}.
		#-.
		{'More...'.										#getMenu}.
	}! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 1/31/2017 11:56:31' prior: 16813767!
        classListKey: aChar from: view 
	"Respond to a Command key.  I am a model with a list of classes and a 
	code pane, and I also have a listView that has a list of methods.  The 
	view knows how to get the list and selection."

	aChar == $r ifTrue: [^ model recent].
	aChar == $h ifTrue: [^ self browseHierarchy].
	aChar == $x ifTrue: [^ model removeClass].
	aChar == $t ifTrue: [^ model runClassTests ].
	
	^ self messageListKey: aChar from: view! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 2/10/2017 17:33:25' prior: 16813782!
 messageListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also
	have a listView that has a list of methods.  The view knows how to get
	the list and selection."

	| sel class |
	aChar == $D ifTrue: [^ model toggleDiffing].

	sel _ model selectedMessageName.
	aChar == $m ifTrue: [  "These next two put up a type in if no message selected"
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllImplementorsOf: to: Smalltalk].
	aChar == $n ifTrue: [
		^ self useSelector: sel orGetSelectorAndSendQuery: #browseAllCallsOn: to: Smalltalk].

	"The following require a class selection"
	(class _ model selectedClassOrMetaClass) ifNil: [^ self ].
	aChar == $b ifTrue: [^ BrowserWindow fullOnClass: class selector: sel].
	aChar == $N ifTrue: [^ self browseClassRefs].
	aChar == $i ifTrue: [^ self methodHierarchy].
	aChar == $h ifTrue: [^ self browseHierarchy].
	aChar == $p ifTrue: [^ self browseFullProtocol].

	"The following require a method selection"
	sel ifNotNil: [
		aChar == $o ifTrue: [^ model fileOutMessage].
		aChar == $c ifTrue: [^ model copySelector].
		aChar == $v ifTrue: [^ self browseVersions].
		aChar == $O ifTrue: [^ self openSingleMessageBrowser].
		aChar == $x ifTrue: [^ model removeMessage].
		aChar == $t ifTrue: [^ model runMethodTest].
		aChar == $r ifTrue: [^ model debugMethodTest]]! !
!CodeWindow methodsFor: 'keyboard shortcuts' stamp: 'HAW 2/7/2017 10:49:07' prior: 16813824!
                   systemCatListKey: aChar from: view
	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."

	aChar == $f ifTrue: [^ self findClass].
	aChar == $x ifTrue: [^ model removeSystemCategory].
	aChar == $t ifTrue: [ ^model runSystemCategoryTests ].
	
	^ self classListKey: aChar from: view! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 11:32:21' prior: 16793212!
                       classListMenu
	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList: #(
		('browse full (b)'			browseMethodFull)
		('browse hierarchy (h)'		browseHierarchy)
		('browse protocol (p)'		browseFullProtocol)
		-
		('fileOut'					fileOutClass				''		model)
		-
		('show hierarchy'			hierarchy					''		model)
		('show definition'			editClass					''		model)
		('show comment'			editComment			''		model)
		-
		('inst var refs...'				browseInstVarRefs)
		('inst var defs...'			browseInstVarDefs)
		-
		('class var refs...'			browseClassVarRefs)
		('class vars'					browseClassVariables)
		('class refs (N)'				browseClassRefs)
		-
		('rename class ...'			renameClass				''		model)
		('copy class...'				copyClass				''		model)
		('remove class (x)'			removeClass				''		model)
		-
		('Run tests (t)'		runClassTests 	''	model)
		('more...'					offerShiftedClassListMenu)).
	^ aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 19:57:02' prior: 16793244!
                 messageCategoryMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: model.			"All the options are for the model."
	aMenu addList: #(
		('fileOut'							fileOutMessageCategories)
		-
		('reorganize'						editMessageCategories)
		('alphabetize'						alphabetizeMessageCategories)
		('remove empty categories'		removeEmptyCategories)
		('categorize all uncategorized'		categorizeAllUncategorizedMethods)
		('new category...'					addCategory)
		-
		('rename...'							renameCategory)
		('remove'							removeMessageCategory)
		-
		('Run tests'	runMessageCategoryTests)).
	^aMenu! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 2/10/2017 17:29:43' prior: 16793264!
messageListMenu
	"Answer the message-list menu"
	"Changed by emm to include menu-item for breakpoints"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList:#(
			('what to show...'				offerWhatToShowMenu)
                	('toggle break on entry'		toggleBreakOnEntry					''		model)
            	-
			('browse full (b)' 				browseMethodFull)
			('browse hierarchy (h)'			browseHierarchy)
			('browse method (O)'			openSingleMessageBrowser)
			('browse protocol (p)'			browseFullProtocol)
			-
			('fileOut'						fileOutMessage							''		model)
			-
			('senders of... (n)'				browseSendersOfMessages)
			('implementors of... (m)'			browseMessages)
			('inheritance (i)'					methodHierarchy)
			('versions (v)'					browseVersions)
			-
			('inst var refs...'					browseInstVarRefs)
			('inst var defs...'				browseInstVarDefs)
			('class var refs...'				browseClassVarRefs)
			('class variables'				browseClassVariables)
			('class refs (N)'					browseClassRefs)
			-
			('remove method (x)'			removeMessage							''		model)
			('Run test (t)'		runMethodTest 	'' 	model)
			('Debug test (r)'		debugMethodTest 	'' 	model)
			-
			('more...'						openShiftedMessageListMenu)).
	^ aMenu
! !
!BrowserWindow methodsFor: 'menu building' stamp: 'HAW 1/31/2017 11:52:17' prior: 16793404!
                systemCategoryMenu

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	self flag: #renameSystemCategory.	"temporarily disabled"
	aMenu addList: #(
		('find class... (f)'				findClass)
		('recent classes... (r)'		recent									''		model)
		-
		('browse all'				browseAllClasses)
		('browse'					openSystemCategoryBrowser)
		-
		('fileOut'					fileOutSystemCategory				''		model)
		-
		('reorganize'				editSystemCategories					''		model)
		('alphabetize'				alphabetizeSystemCategories		''		model)
		-
		('update'					updateSystemCategories				''		model)
		('add item...'				addSystemCategory					''		model)
"		('rename...'					renameSystemCategory				''		model)"
		('remove'					removeSystemCategory				''		model)
		-
		('move to top'				moveSystemCategoryTop				''		model)
		('move up'					moveSystemCategoryUp				''		model)
		('move down'				moveSystemCategoryDown			''		model)
		('move to bottom' 			moveSystemCategoryBottom			''		model)
		-
		('Run tests (t)'				runSystemCategoryTests  	''	model)).
	^aMenu! !
!Theme methodsFor: 'menus' stamp: 'HAW 2/10/2017 17:30:49' prior: 50336846!
                       miscellaneousIcons

	"Everything else."

	^ {
		#('restore display (r)' 'set display depth...' 'move windows onscreen' 'Utilities saveDisplay.') -> #displayIcon.
		#('changes...' 'dual change sorter' 'change sets with this method' 'find a change sorter' 'recent changes in file' 'Undo / Redo history' 'code file contents' 'package file contents') -> #changesIcon.
		#('Install New Updates' 'update' 'turn on auto-update (a)' 'update list (u)' 'install code' 'fileIn entire file' 'install package') -> #updateIcon.
		#('find again (g)' 'full stack (k)') -> #systemIcon.
		#('print it (p)' 'check change set for slips') -> #printIcon.
		#('accept (s)' 'make changes go to me (m)') -> #acceptIcon.
		#('cancel (l)' 'turn off auto-update (a)') -> #cancelIcon.
		#('debug...' 'Debug it (D)' 'toggle break on entry') -> #debugIcon.
		#('close' 'close all debuggers' 'close top window') -> #closeIcon.
		#('collapse' 'hide taskbar' 'collapse all windows') -> #collapseIcon.
		#('expand / contract' 'show taskbar' 'restore all windows') -> #expandIcon.
		#('menu') -> #windowMenuIcon.
		#('browse all' 'browser' 'browse it (b)' 'MessageTally UI and browse' 'browse recent submissions' 'browse full (b)' 'find changed browsers...' 'browse (b)' 'browse my changes') -> #editFindReplaceIcon.
		#('workspace' 'workspace with contents') -> #terminalIcon.
		#('styled text editor' 'text editor'  'basic text editor'  'unicode editor' 'edit this list' 'edit postscript...' 'add postscript...') -> #textEditorIcon.
		#('file list' 'find a fileList' 'compress file') -> #systemFileManagerIcon.
		#('transcript' 'find a transcript' 'Transcript clear.' 'log to transcript') -> #printerIcon.
		#('process browser' 'vm statistics' 'MessageTally all Processes') -> #systemMonitorIcon.
		#('emergency evaluator' 'conflicts with other change sets' 'check for slips' 'conflicts with change set opposite' 'conflicts with category opposite') -> #emblemImportantIcon.
		#('change sorter') -> #halfRefreshIcon.
		#('SUnit Test Runner' 'Accept & Run Test in Class (t)' 'Accept & Run Test in Category (y)' 'Run tests (t)' 'Run tests' 'Run test (t)' 'Accept & Debug Test (r)' 'Debug test (r)') -> #weatherFewCloudsIcon.
		#('Font Sizes...' 'system fonts...' 'set font... (k)') -> #preferencesDesktopFontIcon.
		#('full screen on') -> #viewFullscreenIcon.
		#('full screen off') -> #exitFullscreenIcon.
		#('set desktop color...') -> #wallpaperIcon.
		#('preferences...' 'All preferences...' 'what to show...' 'view as hex') -> #preferencesIcon.
		#('Editor keyboard shortcuts') -> #keyboardShortcutsIcon.
		#('world menu help') -> #globeIcon.		"currently unused, but a neat icon"
		#('useful expressions' 'class comments with it' 'check for uncommented methods' 'check for uncommented classes') -> #chatIcon.
		#('set code author...' 'check for other authors' 'check for any other authors') -> #usersIcon.
		#('space left') -> #removableMediaIcon.
		#('start drawing all again' 'window color...') -> #graphicsIcon.
		#('start stepping again') -> #mediaPlaybackStartIcon.
		#('file out current change set' 'fileOut' 'File out and remove (o)' 'File out and keep (k)') -> #fileOutIcon.
		#('recently logged changes...' 'versions (v)' 'recent classes... (r)' 'trim history' 'Profile it') -> #clockIcon.
		#('senders of it (n)' 'senders of... (n)' 'local senders of...' 'senders (n)') -> #mailForwardIcon.
		#('implementors of it (m)' 'implementors of... (m)' 'implementors of sent messages') -> #developmentIcon.
		#('references to it (N)') -> #addressBookIcon.
		#('class var refs...' 'class refs (N)' 'class variables' 'class vars' 'local implementors of...' 'subclass template') -> #classIcon.
		#('inst var refs...' 'inst var defs...' 'sample instance') -> #instanceIcon.
		#('Use Selection for Find (j)' 'rename class ...' 'rename...' 'change title...') -> #saveAsIcon.
		#('smalltalk options' 'method source with it' 'browse method (O)' 'check for uncategorized methods') -> #scriptIcon.
		#('method strings with it (E)' 'Toggle WordWrap') -> #genericTextIcon.
		#('browse hierarchy (h)' 'move to top' 'promote to top of list') -> #goTopIcon.
		#('move up' 'make next-to-topmost') -> #goUpIcon.
		#('move to bottom' 'send to back' 'send top window to back') -> #goBottomIcon.
		#('inheritance (i)' 'move down') -> #goDownIcon.
		#('browse protocol (p)' 'spawn sub-protocol') -> #spreadsheetIcon.
		#('spawn full protocol') -> #speadsheetTemplateIcon.
		#('alphabetize') -> #fontXGenericIcon.
		#('Installed Packages' 'browse' 'show category (C)' 'categorize all uncategorized' 'select change set...' 'view affected class categories') -> #packageIcon.
		#('remove from current change set' 'remove empty categories' 'subtract other side (-)' 'remove from this browser') -> #listRemoveIcon.
		#('add to current change set' 'add all meths to current chgs' 'add preamble (p)' 'More...') -> #listAddIcon.
		#('toggle diffing (D)' 'toggle selections') -> #switchIcon.
		#('reorganize' 'create inst var accessors' 'ChangeSorter reorderChangeSets.' 'reorder all change sets' 'by name' 'by size' 'by date') -> #sendReceiveIcon.
		#('unsent methods' 'unreferenced class vars' 'unreferenced inst vars' 'Undeclared inspect.' 'Undeclared removeUnreferencedKeys; inspect.' 'ChangeSorter removeEmptyUnnamedChangeSets.' 'check for unsent messages') -> #junkIcon.
		#('find changed windows...') -> #newWindowIcon.
		#('make undraggable') -> #pushPinIcon.
		#('Utilities saveScreenshot.') -> #stillCameraIcon.
		#('add new directory') -> #newFolderIcon.
		#('select all' 'deselect all') -> #selectAllIcon.
		#('sort by date') -> #dateIcon.
		#('justified') -> #formatJustifyFillIcon.
		#('centered') -> #formatJustifyCenterIcon.
		#('set alignment...' 'leftFlush') -> #formatJustifyLeftIcon.
		#('rightFlush') -> #formatJustifyRightIcon.
		#('signal Semaphore (S)') -> #haloHelpIcon.
		#('Change Paragraph Style...' 'Change Character Style...' 'Remove Character Style' 'Replace all uses of Paragraph Style...' 'Replace all uses of Character Style...' 'Set Default Font...') -> #fontXGenericIcon.
		#('Clear Font') -> #newIcon.
		#('code file browser' 'package file browser') -> #findIcon.
	}! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 2/10/2017 17:37:41'!
                           should: aBlock raise: anExceptionalType withExceptionDo: assertionsBlock

	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalType withExceptionDo: assertionsBlock)
			! !
!TestCase methodsFor: 'Private' stamp: 'HAW 2/10/2017 17:38:10'!
    executeShould: aBlock inScopeOf: anExceptionType withExceptionDo: assertionsBlock

	^[aBlock value.
 	false] 
		on: anExceptionType
		do: [:exception | 
			assertionsBlock value: exception.
			exception sunitExitWith: true]! !
!TestCase class methodsFor: 'Testing' stamp: 'HAW 2/10/2017 16:32:10' prior: 50336192!
      is: aSymbol

	^self ~= TestCase 
		and: [ aSymbol == #TestCaseClass or: [ super is: aSymbol ]]! !
!TestCase class methodsFor: 'Testing' stamp: 'HAW 2/1/2017 19:35:57' prior: 16927731!
        shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^self ~= TestCase 
		and: [ self superclass isAbstract or: [self testSelectors isEmpty]]

"$QA Ignore:Sends system method(superclass)$"
			! !
!TestResultForDebuggingAndInspection methodsFor: 'printing' stamp: 'HAW 2/7/2017 10:51:56' prior: 50336209!
                 print: aCollectionOfTestCases startingWith: header on: aStream
	
	aCollectionOfTestCases do: [ :aTestCase |
		aStream 
			nextPutAll: header;
			space;
			nextPutAll: aTestCase class name;
			nextPutAll: ' debug: #';
			nextPutAll: aTestCase selector;
			newLine ]
		
		
	! !

TestSuite class removeSelector: #allTestCasesReferencing:!

TestSuite class removeSelector: #allTestReferencesTo:!

TestSuite class removeSelector: #allTestsReferencing:!

TestSuite class removeSelector: #from:using:!

TestSuite class removeSelector: #fromClass:!

TestSuite class removeSelector: #fromSystemCategoryNamed:using:!

ProgessiveTestRunner removeSelector: #initializeFor:informingResultUsing:!

ProgessiveTestRunner removeSelector: #initializeFor:showingTestPassedWith:!

ProgessiveTestRunner removeSelector: #showProgressBarAndRunSuite!

SmalltalkEditor removeSelector: #acceptAndWithTestMethodDo:!

SmalltalkEditor removeSelector: #flashWith:!

SmalltalkEditor removeSelector: #flashWith:!

SmalltalkEditor removeSelector: #flashWithGreen!

SmalltalkEditor removeSelector: #flashWithGreen!

Categorizer removeSelector: #testCasesAt:!

Class removeSelector: #withTestCaseClassDo:ifNone:!

Behavior removeSelector: #withTestClassDo:ifNone:!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3046-TestRunningHelpers-HernanWilkinson-2017Jan31-09h21m-HAW.5.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3046] on 1 March 2017 at 12:34:07 pm'!
!CodeFile methodsFor: 'change record types' stamp: 'jmv 3/1/2017 12:31:23' prior: 16808869!
          doIt: chgRec
	"See senders of #doIt "
	| string |
	string := chgRec string.
	
	"Method classification spec"
	(string beginsWith: '(''') ifTrue: [
		^ doIts add: chgRec ].
		
	"Just for compatibility with Squeak, as Cuis always adds the #classDefinition change type marker in the files."
	('*ubclass:*instanceVariableNames:*classVariableNames:*poolDictionaries:*category:*'
		match: string) ifTrue:[^self classDefinition: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #classDefinition change type marker in the files."
	('* class*instanceVariableNames:*'
		match: string) ifTrue:[^self metaClassDefinition: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #methodRemoval: (or similar) change type marker in the files."
	('* removeSelector: *'
		match: string) ifTrue:[^self removedMethod: string with: chgRec].

	"Just for compatibility with Squeak, as Cuis always adds the #classComment change type marker in the files."
	('* comment:*'
		match: string) ifTrue:[^self msgClassComment: string with: chgRec].

	"Don't add these to a CodeFile. They will be added on save if needed."
	('* initialize'
		match: string) ifTrue:[^self]. "Initialization is done based on class>>initialize"

	('''From *'
		match: string) ifTrue:[^self possibleSystemSource: chgRec].
	doIts add: chgRec.! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3047-FileCodeBrowserFix-JuanVuletich-2017Mar01-12h33m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3047] on 2 March 2017 at 10:50:58 am'!

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph oldKeyboardFocus '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp popUpOwner activeSubMenu titleMorph oldKeyboardFocus'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!MenuMorph commentStamp: '<historical>' prior: 16866262!
                  Instance variables:
	defaultTarget 		<Object>					The default target for creating menu items
	selectedItem			<MenuItemMorph> 		The currently selected item in the receiver
	stayUp 				<Boolean>				True if the receiver should stay up after clicks!
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:47:30' prior: 16866663!
                         deleteIfPopUp: evt
	"Remove this menu from the screen if stayUp is not true."

	stayUp ifFalse: [ self delete ].
	evt ifNotNil: [ evt hand ifNotNil: [ :h | h releaseMouseFocus: self ]]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:48:01' prior: 16866680!
                   popUpAdjacentTo: rightOrLeftPointInWorld from: sourceItem
	"Present this menu at the given point under control of the given hand.
	Used mostly for submenus."

	| delta tryToPlace selectedOffset |
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld
			amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:48:31' prior: 16866709!
    popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	self runningWorld addMorphFront: self position: aPoint - (2 @ 8).
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastMouseEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/2/2017 10:48:26' prior: 16866745!
       popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	self items isEmpty ifTrue: [ ^self ].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph]) 
		do: [ :m | m updateContents].
	aWorld addMorphFront: self position: aPoint - (2 @ 8).
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ]! !
!MenuMorph methodsFor: 'events' stamp: 'jmv 3/2/2017 10:47:45' prior: 16866819!
                     keyStroke: aKeyboardEvent 
	| matchString char asc selectable |
	char := aKeyboardEvent keyCharacter.
	asc := char numericValue.
	aKeyboardEvent isReturnKey
		ifTrue: [
			selectedItem ifNotNil: [
					selectedItem hasSubMenu 
						ifTrue: [
							aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
							^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]
						ifFalse: [
							"self delete."
							^selectedItem invokeWithEvent: aKeyboardEvent]].
			(selectable := self items) size = 1 
				ifTrue: [^selectable first invokeWithEvent: aKeyboardEvent].
			^self].
	asc = 27 
		ifTrue: [
			"escape key"
			self
				valueOfProperty: #matchString
				ifPresentDo: [ :str | 
					str isEmpty 
						ifFalse: [
							"If filtered, first ESC removes filter"
							self setProperty: #matchString toValue: String new.
							self selectItem: nil.
							^self displayFiltered: aKeyboardEvent]].
			"If a stand-alone menu, just delete it"
			^self delete].
	(asc = 28 or: [asc = 29]) 
		ifTrue: [
			"left or right arrow key"
			(selectedItem notNil and: [selectedItem hasSubMenu]) 
				ifTrue: [
					aKeyboardEvent hand newMouseFocus: selectedItem subMenu.
					selectedItem subMenu moveSelectionDown: 1 event: aKeyboardEvent.
					^aKeyboardEvent hand newKeyboardFocus: selectedItem subMenu]].
	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: aKeyboardEvent].	"up arrow key"
	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: aKeyboardEvent].	"down arrow key"
	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: aKeyboardEvent].	"page up key"
	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: aKeyboardEvent].	"page down key"
	matchString := self valueOfProperty: #matchString ifAbsent: [String new].
	matchString := char = Character backspace 
				ifTrue: [
					matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]
				ifFalse: [matchString copyWith: aKeyboardEvent keyCharacter].
	self setProperty: #matchString toValue: matchString.
	self displayFiltered: aKeyboardEvent! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 3/2/2017 10:47:57' prior: 16866952!
                    handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	| eventPositionInOurCoordinates |
	eventPositionInOurCoordinates _ self internalizeFromWorld: aMorphicEvent eventPosition.

	self dispatchEvent: aMorphicEvent localPosition: eventPositionInOurCoordinates.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]]! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 3/2/2017 10:47:34' prior: 16867015!
             initialize
	super initialize.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 3/2/2017 10:45:33' prior: 16866023!
                               mouseEnter: evt
	"The mouse entered the receiver"
	owner ifNil: [ ^self ].
	owner selectItem: self! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 3/2/2017 10:36:12' prior: 16866139!
   deselect

	self isSelected: false.
	subMenu ifNotNil: [
		self removeAlarm: #deselectTimeOut ]! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 3/2/2017 10:36:17' prior: 16866151!
       select
	self isSelected: true.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphBoundsInWorld topRight + (10@0)
									with: self morphBoundsInWorld topLeft)
			from: self.
		subMenu selectItem: nil ]! !

MenuItemMorph removeSelector: #activateOwnerMenu:!

MenuItemMorph removeSelector: #activateOwnerMenu:!

MenuMorph removeSelector: #activeSubmenu:!

MenuMorph removeSelector: #activeSubmenu:!

MenuMorph removeSelector: #delete!

MenuMorph removeSelector: #delete!

MenuMorph removeSelector: #popUpOwner!

MenuMorph removeSelector: #popUpOwner!

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3048-MenuSimplification-JuanVuletich-2017Mar02-10h45m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3048] on 2 March 2017 at 4:11:32 pm'!
!Transcripter class methodsFor: 'instance creation' stamp: 'dhn 2/6/2017 13:38:40' prior: 16938922!
                        newInFrame: frame
"
(Transcripter newInFrame: (0@0 extent: 100@200))
	nextPutAll: 'Hello there'; endEntry;
	newLine; print: 355.0/113; endEntry;
	readEvalPrint.
"
	| transcript |
	transcript _ self on: (String new: 100).
	transcript initInFrame: frame.
	^ transcript clear! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3049-TranscripterCommentFix-DanNorton-2017Mar02-16h10m-dhn.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:17:59 am'!
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:35:58'!
cleanseStepList
	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."

	| deletions morphToStep |
	deletions _ nil.
	stepList do: [:entry |
		morphToStep _ entry receiver.
		morphToStep world == world ifFalse:[
			deletions ifNil: [deletions _ OrderedCollection new].
			deletions addLast: entry]].

	deletions ifNotNil:[
		deletions do: [:entry|
			self stopSteppingMorph: entry receiver]].

	self alarms copy do:[:entry|
		morphToStep _ entry receiver.
		((morphToStep is: #Morph) and: [ morphToStep world == world ]) 
			ifFalse: [ self removeAlarm: entry selector for: entry receiver ]].! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:42:28'!
      runStepMethods
	"Perform periodic activity inbetween event cycles"
	| queue msg |

	queue _ self class deferredUIMessages.
	[ (msg _ queue nextOrNil) isNil ] whileFalse: [
		msg value
	].
	self runLocalStepMethods.

	"we are using a normal #step for these now"
	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."
! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:34:41'!
              displayWorldSafely
	"Update this world's display and keep track of errors during draw methods."

	[world displayWorld] ifError: [:err :rcvr |
		"Handle a drawing error"
		| errCtx errMorph |
		errCtx _ thisContext.
		[
			errCtx _ errCtx sender.
			"Search the sender chain to find the morph causing the problem"
			[errCtx notNil and: [ (errCtx receiver is: #Morph) not ]] 
				whileTrue:[errCtx _ errCtx sender].
			"If we're at the root of the context chain then we have a fatal drawing problem"
			errCtx ifNil:[^self handleFatalDrawingError: err].
			errMorph _ errCtx receiver.
			"If the morph causing the problem has already the #drawError flag set,
			then search for the next morph above in the caller chain."
			errMorph isKnownFailing
		] whileTrue.
		errMorph drawingFails.
		self clearCanvas.
		"Install the old error handler, so we can re-raise the error"
		rcvr error: err.
	]! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:34:09'!
                         doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < 200				"No events processed? Start saving CPU!! But never make the user wait more than 200ms for being responsive again."
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time localMillisecondClock ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 0 ifTrue: [
		waitDelay beingWaitedOn
			ifFalse: [ waitDelay setDelay: wait; wait ]
			ifTrue: [
				"If we are called from a different process than that of the main UI, we might be called in the main
				interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
				(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:34:47'!
                doOneCycleNow
	"Immediately do one cycle of the interaction loop.
	This should not be called directly, but only via doOneCycleFor:"

	| hadAnyEvent |
	"See #eventTickler"
	Cursor currentCursor = Cursor wait ifTrue: [
		Cursor normal activateCursor ].

	"Repair visual damage."
	DisplayScreen checkForNewScreenSize.
	self displayWorldSafely.

	"Run steps, alarms and deferred UI messages"
	world runStepMethods.

	"Process user input events. Run all event triggered code."
	hadAnyEvent _ false.
	self handsDo: [ :h |
		activeHand _ h.
		hadAnyEvent _ hadAnyEvent | h processEventQueue.
		activeHand _ nil ].

	"The default is the primary hand"
	activeHand _ self hands first.


	^hadAnyEvent! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 19:43:12'!
   tryDeferredUpdatingAndSetCanvas
        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, set a non-Disply canvas and answer false.."
	| properDisplay |
	
	"As this is the only sender of #deferUpdates: , this could be done in Morphic or image startup, and never efterwards..."
	(Display deferUpdates: true) ifNil: [
		"deferred updates not supported by the VM, do them in the image!!"
		self ensureNonDisplayCanvas.
		^ false].
	
	"if no canvas, or canvas was offscreen, from a platform that didnt support defers, then fix it"
	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].
	properDisplay ifFalse: [
		world morphPosition: 0@0 extent: Display extent.
		self setCanvas: Display getCanvas.
	].
	^ true! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:43:18'!
            displayWorldAndSubmorphs: submorphs
	"Update this world's display."

	| deferredUpdateVMMode worldDamageRects handsToDraw allDamage |
	self checkIfUpdateNeeded ifFalse: [ ^ self ].  "display is already up-to-date"
	"I (jmv) removed the call to 'deferUpdates: false' below. No more need to call this every time."
	deferredUpdateVMMode _ self tryDeferredUpdatingAndSetCanvas.

	"repair world's damage on canvas"
	worldDamageRects _ self drawInvalidAreasSubmorphs: submorphs.

	"Check which hands need to be drawn (they are not the hardware mouse pointer)"
	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.
	allDamage _ Array streamContents: [ :strm |
		strm nextPutAll: worldDamageRects.
		handsToDraw do: [ :h | 
			h savePatchFrom: canvas appendDamageTo: strm ]].

	"Draw hands (usually carying morphs) onto world canvas"
	canvas newClipRect: nil.
	handsToDraw reverseDo: [ :h | canvas fullDrawHand: h ].

	"quickly copy altered rects of canvas to Display:"
	deferredUpdateVMMode ifFalse: [
		"Drawing was done to off-Display canvas. Copy content to Display"
		canvas showAt: world viewBox origin invalidRects: allDamage ].

	"Display deferUpdates: false."
	"Display forceDisplayUpdate"
	Display forceDamageToScreen: allDamage.

	"Restore world canvas under hands and their carried morphs"
	handsToDraw do: [ :h | h restoreSavedPatchOn: canvas ].! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:40:12'!
        drawInvalidAreasSubmorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |

	"The simple implementation is slowers as it draws morph areas that will later be covered by other morphs.
	But it works, and it is easier to understand.
	See en.wikipedia.org/wiki/Painter's_algorithm"
	true not ifTrue: [ ^self simpleDrawInvalidAreasSubmorphs: submorphs ].

	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.

	"The idea here is to iterate morphs front to back, i.e. first the ones on top.
	For each morph, record the rectangles it affects. And if a morph is opaque, remove the area behind it from the list of rectangles to be repaired.
	This means, for example, that morphs completely covered might even not be redrawn.
	this is a huge performance gain when there are many morphs on screen, especially if there are more than ten open windows, and Theme uses opaque colors.
	See 'A reverse painter's algorithm' at en.wikipedia.org/wiki/Painter's_algorithm"
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ world fillRects: initialRectsToRepair color: Color gray ].

	"Draw world background on those areas that were not completely covered by opaque morphs"
	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			world drawOn: (canvas newClipRect: r) ]].

	"Now, draw the recorded areas of selected morphs, back to front."
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could think about merging all xrects into just one call...
		This would mean drawing each morph just once.
		But that would mean drawing pixels we were not told to. There could be other morphs in that area that are not even being drawn!!
		See WorldState class >> #experiment1"
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			(canvas newClipRect: r) fullDraw: m.
		].
"		(canvas newClipRect: rr) fullDraw: m"
		"*make this true to flash damaged areas for testing*"
		Preferences debugShowDamage2 ifTrue: [
			world flashRects: xrects color: Color random ].
	].

	"Answer a list of rectangles to be updated on the Display.
	This usually is not performance critical, drawing morphs is slower than just exposing the Display."
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:39:56'!
    simpleDrawInvalidAreasSubmorphs: submorphs

	"mover todo esto al canvas, no?
	Y ver que hacer con los argumentos, etc.... Toda esta bananarama!!"

	"Redraw the damaged areas of the given canvas and clear the damage list.
	Return a collection of the areas that were redrawn.
	This simple implementation just does as requested: No optimizations are done."

	| rectsToRepair morphBounds |
	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	rectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.

	"Draw World"
	rectsToRepair do: [ :r |
		world drawOn: (canvas newClipRect: r) ].

	"Draw morphs"
	submorphs reverseDo: [ :morph |
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			rectsToRepair do: [ :r |
				(morphBounds intersects: r) ifTrue: [
					(canvas newClipRect: r) fullDraw: morph ]]]].

	^ rectsToRepair! !
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/2/2017 21:47:15'!
         runLocalStepMethods
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| now morphToStep scheduledTime |
	now _ lastCycleTime.
	self triggerAlarmsBefore: now.
	stepList isEmpty 
		ifTrue: [ ^self].
	[ stepList isEmpty not and: [ stepList first scheduledTime <= now ]] 
		whileTrue: [
			lastStepMessage _ stepList removeFirst.
			morphToStep _ lastStepMessage receiver.
			(morphToStep shouldGetStepsFrom: world) 
				ifTrue: [
					scheduledTime _ lastStepMessage scheduledTime.
					lastStepMessage valueAtTime: now - scheduledTime + lastStepMessage stepTime.
					lastStepMessage ifNotNil: [
							lastStepMessage scheduledTime: (scheduledTime + lastStepMessage stepTime max: now + 1).
							stepList add: lastStepMessage ]].
			lastStepMessage _ nil ]! !
!PasteUpMorph methodsFor: 'interaction loop' stamp: 'jmv 3/2/2017 19:34:01' prior: 16887286!
 doOneCycleNow
	"see the comment in doOneCycleNowFor:
	Only used for a few tests."
	worldState doOneCycleNow! !
!PasteUpMorph methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:36:23' prior: 16887443!
                            cleanseStepList
	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."

	worldState cleanseStepList! !
!PasteUpMorph methodsFor: 'stepping' stamp: 'jmv 3/2/2017 19:42:32' prior: 16887451!
 runStepMethods

	worldState runStepMethods! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:34:54' prior: 16887760!
                          displayWorldSafely

	worldState displayWorldSafely
! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:33:20' prior: 16887765!
                 doOneCycle
	"see the comment in WorldState >> doOneCycle"

	worldState doOneCycle! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 19:37:11' prior: 16887829!
                   privateOuterDisplayWorld

	worldState displayWorldAndSubmorphs: submorphs
! !
!WorldState class methodsFor: 'sample code' stamp: 'jmv 3/2/2017 19:39:21' prior: 16946320!
                      experiment1
	"To play with and learn about morphic Display update logic.
	Remove the morphs when done!!"
	"
	WorldState experiment1
	"
	| dr morph1 morph2 s w |
	morph1 _ RectangleLikeMorph new openInWorld.
	morph2 _ RectangleLikeMorph new openInWorld.
	morph2 color: Color green.
	morph2 morphPosition: 200@800 extent: 50@40.
	morph1 morphPosition: 120@720 extent: 220@100.

	w _ self runningWorld.
	s _ w instVarNamed: 'worldState'.
	dr _ s instVarNamed: 'damageRecorder'.

	dr doFullRepaint.
	dr reset;
	"	recordInvalidRect: (100@700 corner: 400@900);"
		recordInvalidRect: (100@700 corner: 150@900);
		recordInvalidRect: (300@700 corner: 400@900).
	Display fillColor: Color gray.
	"Do not draw the area used by the small rectangle, unless it is also drawn!!"
	s drawInvalidAreasSubmorphs: {morph1. morph2 }! !

WorldState removeSelector: #cleanseStepListForWorld:!

WorldState removeSelector: #cleanseStepListForWorld:!

WorldState removeSelector: #displayWorld:submorphs:!

WorldState removeSelector: #displayWorld:submorphs:!

WorldState removeSelector: #displayWorldSafely:!

WorldState removeSelector: #displayWorldSafely:!

WorldState removeSelector: #doOneCycleFor:!

WorldState removeSelector: #doOneCycleFor:!

WorldState removeSelector: #doOneCycleNowFor:!

WorldState removeSelector: #doOneCycleNowFor:!

WorldState removeSelector: #drawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #drawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #runLocalStepMethodsIn:!

WorldState removeSelector: #runLocalStepMethodsIn:!

WorldState removeSelector: #runStepMethodsIn:!

WorldState removeSelector: #runStepMethodsIn:!

WorldState removeSelector: #simpleDrawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #simpleDrawInvalidAreasWorld:submorphs:!

WorldState removeSelector: #tryDeferredUpdatingAndSetCanvasFor:!

WorldState removeSelector: #tryDeferredUpdatingAndSetCanvasFor:!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3050-WorldState-refactor-JuanVuletich-2017Mar03-09h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:22:19 am'!
!PasteUpMorph methodsFor: 'interaction loop' stamp: 'jmv 3/2/2017 19:58:01' prior: 50339854!
                              doOneCycleNow
	"see the comment in WorldState >> doOneCycleNow
	Only used for a few tests."
	worldState doOneCycleNow! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/3/2017 09:21:41' prior: 50339571!
                doOneCycleNow
	"Immediately do one cycle of the interaction loop."

	| hadAnyEvent |
	"See #eventTickler"
	Cursor currentCursor = Cursor wait ifTrue: [
		Cursor normal activateCursor ].

	"Repair visual damage."
	DisplayScreen checkForNewScreenSize.
	self displayWorldSafely.

	"Run steps, alarms and deferred UI messages"
	self runStepMethods.

	"Process user input events. Run all event triggered code."
	hadAnyEvent _ false.
	self handsDo: [ :h |
		activeHand _ h.
		hadAnyEvent _ hadAnyEvent | h processEventQueue.
		activeHand _ nil ].

	"The default is the primary hand"
	activeHand _ self hands first.


	^hadAnyEvent! !

PasteUpMorph removeSelector: #runStepMethods!

PasteUpMorph removeSelector: #runStepMethods!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3051-WorldState-refactor-JuanVuletich-2017Mar03-09h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:27:56 am'!
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 3/2/2017 20:08:11'!
                             doOneMinimalCycleNow
	"see the comment in WorldState >> doOneMinimalCycleNow"

	worldState doOneMinimalCycleNow! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/2/2017 20:06:48'!
      doOneMinimalCycleNow
	"Immediately do one cycle of the interaction loop.
	Only repair display and process events. For modal menus and such."

	"Repair visual damage."
	self displayWorldSafely.

	"Process user input events. Run all event triggered code."
	^activeHand processEventQueue! !
!MenuMorph methodsFor: 'modal control' stamp: 'jmv 3/2/2017 20:08:34' prior: 16867177!
         invokeModal: allowKeyboardControl
	"Invoke this menu and don't return until the user has chosen a value.  If the allowKeyboarControl boolean is true, permit keyboard control of the menu
	See senders of this method for finding out how to use modal menu morphs."
	| w oldFocus actHand |
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneMinimalCycleNow.
	self	
		popUpAt: actHand morphPosition
		forHand: actHand 
		allowKeyboard: allowKeyboardControl.
	self isModalInvokationDone: false.
	[ self isInWorld & self isModalInvokationDone not ] whileTrue: [ w doOneMinimalCycleNow ].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ self modalSelection! !
!MVCMenuMorph methodsFor: 'invoking' stamp: 'jmv 3/2/2017 20:08:29' prior: 16865463!
                          invokeAt: aPoint allowKeyboard: aBoolean
	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 
	|actHand w oldFocus |
	self flag: #bob.		"is <aPoint> global or local?"
	self flag: #arNote.	"<aPoint> is local to aWorld"
	w _ self runningWorld.
	actHand _ w activeHand.
	oldFocus _ actHand keyboardFocus.
	w doOneMinimalCycleNow.
	self
		popUpAt: aPoint
		forHand: actHand
		allowKeyboard: aBoolean.
	done _ false.
	[ self isInWorld & done not ] whileTrue: [ w doOneMinimalCycleNow ].
	self delete.
	oldFocus ifNotNil: [ actHand newKeyboardFocus: oldFocus ].
	^ mvcSelection ! !
!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'jmv 3/2/2017 20:08:24' prior: 16844196!
                   getUserResponse
	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."
	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."

	| w |
	w _ self world.
	w ifNil: [^ response].
	done _ false.
	textPane focusText.
	[done] whileFalse: [w doOneMinimalCycleNow].
	self delete.
	w doOneMinimalCycleNow.
	^ response
! !
!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'jmv 3/3/2017 09:26:42' prior: 16844289!
                             request: queryString initialAnswer: defaultAnswer centerAt: aPoint onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean
	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."
	"
	FillInTheBlankMorph
		request: 'Type something, then type [Return].'
		initialAnswer: 'yo ho ho!!'
	"

	| aFillInTheBlankMorph |
	aFillInTheBlankMorph _ self new
		setQuery: queryString
		initialAnswer: defaultAnswer
		acceptOnCR: acceptBoolean.
	aFillInTheBlankMorph responseUponCancel: returnOnCancel.
	self runningWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.
	^ aFillInTheBlankMorph getUserResponse! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3052-MenusDoReducedWorldCycle-JuanVuletich-2017Mar03-09h22m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 9:49:08 am'!
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/3/2017 09:47:13'!
                     runLocalStepMethods: nowTime
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| morphToStep scheduledTime |
	[ stepList notEmpty and: [ stepList first scheduledTime <= nowTime ]] 
		whileTrue: [
			lastStepMessage _ stepList removeFirst.
			morphToStep _ lastStepMessage receiver.
			(morphToStep shouldGetStepsFrom: world) 
				ifTrue: [
					scheduledTime _ lastStepMessage scheduledTime.
					lastStepMessage valueAtTime: nowTime - scheduledTime + lastStepMessage stepTime.
					lastStepMessage ifNotNil: [
							lastStepMessage scheduledTime: (scheduledTime + lastStepMessage stepTime max: nowTime + 1).
							stepList add: lastStepMessage ]].
			lastStepMessage _ nil ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:33:59' prior: 16945643!
                            addAlarm: aSelector withArguments: argArray for: aTarget at: scheduledTime
	"Add a new alarm with the given set of parameters"

	alarms add: 
		(MorphicAlarm 
			receiver: aTarget
			selector: aSelector
			arguments: argArray
			at: scheduledTime)! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:34:03' prior: 16945653!
                    adjustAlarmTimes: nowTime
	"Adjust the alarm times after some clock weirdness (such as image-startup etc)"
	| deltaTime |
	deltaTime _ nowTime - lastAlarmTime.
	alarms do: [ :alarm |
		alarm scheduledTime: alarm scheduledTime + deltaTime ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:34:21' prior: 16945673!
                            removeAlarm: aSelector for: aTarget 
	"Remove the alarm with the given selector"

	| alarm |
	alarm := alarms 
				detect: [ :any | any receiver == aTarget and: [any selector == aSelector]]
				ifNone: nil.
	alarm ifNotNil: [ alarms remove: alarm ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 09:35:03' prior: 16945684!
                   triggerAlarmsBefore: nowTime
	"Trigger all pending alarms that are to be executed before nowTime."

	nowTime - lastAlarmTime > 10000
		ifTrue: [ self adjustAlarmTimes: nowTime ].
	[ alarms notEmpty and: [ alarms first scheduledTime < nowTime ]]
		whileTrue: [ alarms removeFirst valueAtTime: nowTime ].
	lastAlarmTime _ nowTime! !
!WorldState methodsFor: 'initialization' stamp: 'jmv 3/3/2017 09:33:53' prior: 16945782!
                            initialize

	activeHand _ HandMorph new.
	hands _ { activeHand }.
	damageRecorder _ DamageRecorder new.
	stepList _ Heap sortBlock: self stepListSortBlock.
	alarms _ Heap sortBlock: self alarmSortBlock.
	lastAlarmTime _ 0.
	drawingFailingMorphs _ WeakIdentitySet new.
	pause _ 20.
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ false! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 09:39:18' prior: 50339448!
      cleanseStepList
	"Remove morphs from the step list that are not in this World."

	| deletions morphToStep |
	deletions _ nil.
	stepList do: [:entry |
		morphToStep _ entry receiver.
		morphToStep world == world ifFalse:[
			deletions ifNil: [deletions _ OrderedCollection new].
			deletions addLast: entry]].

	deletions ifNotNil:[
		deletions do: [:entry|
			self stopSteppingMorph: entry receiver]].

	alarms copy do: [ :entry |
		morphToStep _ entry receiver.
		((morphToStep is: #Morph) and: [ morphToStep world == world ]) 
			ifFalse: [ self removeAlarm: entry selector for: entry receiver ]]! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 09:46:37' prior: 50339471!
                   runStepMethods
	"Perform periodic activity inbetween event cycles"
	| queue msg |

	queue _ self class deferredUIMessages.
	[ (msg _ queue nextOrNil) isNil ] whileFalse: [
		msg value
	].
	self triggerAlarmsBefore: lastCycleTime.
	self runLocalStepMethods: lastCycleTime.

	"we are using a normal #step for these now"
	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."
! !

WorldState removeSelector: #alarms!

WorldState removeSelector: #alarms!

WorldState removeSelector: #runLocalStepMethods!

WorldState removeSelector: #runLocalStepMethods!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3053-WorldState-refactor-JuanVuletich-2017Mar03-09h27m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3053] on 3 March 2017 at 11:17:47 am'!

MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #StepMessage category: #'Morphic-Events'!
MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!
!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/3/2017 11:14:28'!
                     valueAtTime: millisecondClock

	|  nArgs millisecondsSinceLast |
	numArgs ifNil: [numArgs _ selector numArgs].
	nArgs _ arguments ifNil: [0] ifNotNil: [arguments size].
"OJO!!"
lastEvaluationTime ifNil: [ lastEvaluationTime _ millisecondClock ].
	millisecondsSinceLast _ millisecondClock - lastEvaluationTime.
	lastEvaluationTime _ millisecondClock.
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self value ].
	^arguments
		ifNil: [ receiver perform: selector with: millisecondsSinceLast]
		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: millisecondsSinceLast) ]! !
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/3/2017 11:16:08' prior: 50340135!
                runLocalStepMethods: nowTime
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| morphToStep scheduledTime |
	[ stepList notEmpty and: [ stepList first scheduledTime <= nowTime ]] 
		whileTrue: [
			lastStepMessage _ stepList removeFirst.
			morphToStep _ lastStepMessage receiver.
			(morphToStep shouldGetStepsFrom: world) 
				ifTrue: [
					scheduledTime _ lastStepMessage scheduledTime.
					lastStepMessage valueAtTime: nowTime.
					lastStepMessage ifNotNil: [
						lastStepMessage scheduledTime: (scheduledTime + lastStepMessage stepTime max: nowTime + 1).
						stepList add: lastStepMessage ]].
			lastStepMessage _ nil ]! !

MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

!classDefinition: #StepMessage category: #'Morphic-Events'!
MorphicAlarm subclass: #StepMessage
	instanceVariableNames: 'stepTime lastEvaluationTime'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Events'!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3054-StepMessageCleanup-JuanVuletich-2017Mar03-11h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3053] on 3 March 2017 at 11:41:31 am'!
!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/3/2017 11:28:02'!
   rescheduleAfter: millisecondTimer
	"Schedule next run"
	scheduledTime _ scheduledTime + self stepTime max: millisecondTimer + 1! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:39:34' prior: 16945882!
          stopStepping: aMorph selector: aSelector
	"Remove the given morph from the step list."
	stepList removeAll: (stepList select:[:stepMsg| stepMsg receiver == aMorph and: [ stepMsg selector == aSelector ]])! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:39:22' prior: 16945896!
                              stopSteppingMorph: aMorph
	"Remove the given morph from the step list."
	stepList removeAll: (stepList select: [ :stepMsg | stepMsg receiver == aMorph])! !
!WorldState methodsFor: 'accessing' stamp: 'jmv 3/3/2017 11:39:10' prior: 50340307!
                runLocalStepMethods: nowTime
	"Run morph 'step' methods (LOCAL TO THIS WORLD) whose time has come. Purge any morphs that are no longer in this world."

	| stepMessage |
	[ stepList notEmpty and: [ stepList first scheduledTime <= nowTime ]] 
		whileTrue: [

			stepMessage _ stepList first.
			(stepMessage receiver shouldGetStepsFrom: world)
				ifTrue: [
					stepMessage valueAtTime: nowTime.
					"If it was not removed from the list during its own evaluation"
					stepMessage == stepList first ifTrue: [
						stepList removeFirst.
						stepMessage rescheduleAfter: nowTime.
						stepList add: stepMessage ]]

				ifFalse: [ stepList removeFirst ].
		]! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3055-SteppingCleanup-JuanVuletich-2017Mar03-11h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3053] on 3 March 2017 at 11:55:19 am'!
!StepMessage methodsFor: 'evaluating' stamp: 'jmv 3/3/2017 11:55:15' prior: 50340285!
             valueAtTime: millisecondClock

	|  nArgs millisecondsSinceLast |
	numArgs ifNil: [numArgs _ selector numArgs].
	nArgs _ arguments ifNil: [0] ifNotNil: [arguments size].
	lastEvaluationTime ifNil: [ lastEvaluationTime _ millisecondClock ].
	millisecondsSinceLast _ millisecondClock - lastEvaluationTime.
	lastEvaluationTime _ millisecondClock.
	nArgs = numArgs ifTrue: [
		"Ignore extra argument"
		^self value ].
	^arguments
		ifNil: [ receiver perform: selector with: millisecondsSinceLast]
		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: millisecondsSinceLast) ]! !
!PasteUpMorph methodsFor: 'caching' stamp: 'jmv 3/3/2017 11:42:44' prior: 16887042!
                       releaseCachedState
	super releaseCachedState.
	backgroundImage _ nil.
	self isWorldMorph ifTrue: [
		worldState cleanseStepList.
		worldState clearCanvas ]! !
!WorldState methodsFor: 'alarms' stamp: 'jmv 3/3/2017 11:54:00' prior: 50340184!
                removeAlarm: aSelector for: aTarget 
	"Remove the alarm with the given selector"

	| alarm |
	alarm _ alarms 
				detect: [ :any | any receiver == aTarget and: [any selector == aSelector]]
				ifNone: nil.
	alarm ifNotNil: [ alarms remove: alarm ]! !
!WorldState methodsFor: 'stepping' stamp: 'jmv 3/3/2017 11:51:16' prior: 50340223!
                  cleanseStepList
	"Remove morphs from the step list that are not in this World."

	| deletions |
	deletions _ OrderedCollection new.
	stepList do: [ :entry |
		entry receiver world == world ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		stepList remove: entry ].

	deletions _ OrderedCollection new.
	alarms do: [ :entry |
		((entry receiver is: #Morph) and: [ entry receiver world == world ]) ifFalse: [
			deletions add: entry]].
	deletions do: [ :entry|
		alarms remove: entry ]! !

PasteUpMorph removeSelector: #cleanseStepList!

PasteUpMorph removeSelector: #cleanseStepList!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3056-SteppingCleanup-JuanVuletich-2017Mar03-11h41m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3056] on 3 March 2017 at 3:11:05 pm'!
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/3/2017 15:04:20' prior: 50339515!
              doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < 200				"No events processed? Start saving CPU!! But never make the user wait more than 200ms for being responsive again."
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time localMillisecondClock ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 5
		ifFalse: [ Processor yield ]
		ifTrue: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3057-SteppingHangWorkaround-JuanVuletich-2017Mar03-15h10m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 3 March 2017 at 7:15:45 pm'!
!TestCase methodsFor: 'Running' stamp: 'HAW 3/3/2017 19:13:13'!
    debugAsFailureIfCanNot: handler
	
	| semaphore |
	
	self ifCanNotDebugDo: [ ^handler value].
	
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. 
	self tearDown.
	self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 14:13:09'!
                 canNotDebugMethodErrorDescription

	^self class canNotDebugMethodErrorDescription! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 18:50:08'!
           ifCanNotDebugDo: handler

	^self testMethod isQuick ifTrue: handler! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 14:13:37'!
                         signalCanNotDebugMethod 

	self error: self canNotDebugMethodErrorDescription! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 14:10:20'!
               testMethod 

	^self class lookupSelector: self selector! !
!TestCase class methodsFor: 'Instance Creation' stamp: 'HAW 3/3/2017 18:51:38'!
                     debugAsFailure: aSymbol ifCanNot: handler

	^(self selector: aSymbol) debugAsFailureIfCanNot: handler
	! !
!TestCase class methodsFor: 'Error Descriptions' stamp: 'HAW 3/3/2017 16:33:00'!
    canNotDebugMethodErrorDescription

	^'Quick methods can not be debugged'! !
!Browser methodsFor: 'tdd' stamp: 'HAW 3/3/2017 19:12:25' prior: 50338019!
         debugMethodTest
	
	currentCompiledMethod isTestMethod ifTrue: [
		currentCompiledMethod methodClass debugAsFailure: currentCompiledMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]
! !
!SmalltalkEditor methodsFor: 'tdd' stamp: 'HAW 3/3/2017 19:12:39' prior: 50338106!
          acceptAndDebugTest
	
	^self acceptAndWithMethodDo: [ :aPotencialTestMethod | 
		aPotencialTestMethod isTestMethod ifTrue: [ 
			aPotencialTestMethod methodClass debugAsFailure: aPotencialTestMethod selector ifCanNot: [ PopUpMenu inform: TestCase canNotDebugMethodErrorDescription ]]]! !
!TestCase methodsFor: 'Running' stamp: 'HAW 3/3/2017 18:49:24' prior: 16927491!
                 debugAsFailure
	
	^self debugAsFailureIfCanNot: [ self signalCanNotDebugMethod ]! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 19:13:40' prior: 16927518!
                            openDebuggerOnFailingTestMethod

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self testMethod.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ Debugger new
		process: guineaPig
		context: context.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/3/2017 19:14:27' prior: 16927535!
                               openDebuggerOnFailingTestMethod: semaphore

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self testMethod.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ TestCaseDebugger new
		process: guineaPig
		context: context.
	debugger doneSemaphore: semaphore.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !

TestCase class removeSelector: #debugAsFailure:!

TestCase class removeSelector: #debugAsFailure:!

TestCase removeSelector: #assertCanDebugMethod!

TestCase removeSelector: #canNotDebugQuickMethodErrorDescription!

TestCase removeSelector: #signalCanNotDebugQuickMethod!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3058-CuisCore-HernanWilkinson-2017Mar02-18h30m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3058] on 6 March 2017 at 10:14:29 am'!
!Delay class methodsFor: 'timer process' stamp: 'jmv 3/6/2017 10:13:34' prior: 16833016!
            handleTimerEvent
	"Handle a timer event; which can be either:
		- a schedule request (ScheduledDelay notNil)
		- an unschedule request (FinishedDelay notNil)
		- a timer signal (not explicitly specified)
	We check for timer expiry every time we get a signal."
	| nowTick nextTick afterwardsTick |
	"Wait until there is work to do."
	TimingSemaphore wait.

	"Process any schedule requests"
	ScheduledDelay ifNotNil: [
		"Schedule the given delay"
		self scheduleDelay: ScheduledDelay.
		ScheduledDelay := nil.
		ScheduledDelayNilledSemaphore initSignals. 
		ScheduledDelayNilledSemaphore signal ].

	"Process any unschedule requests"
	FinishedDelay ifNotNil: [
		self unscheduleDelay: FinishedDelay.
		FinishedDelay := nil.
		FinishedDelayNilledSemaphore initSignals.
		FinishedDelayNilledSemaphore signal ].

	"Check for clock wrap-around."
	nowTick := Time millisecondClockValue.
	nowTick < ActiveDelayStartTime ifTrue: [
		"clock wrapped"
		self saveResumptionTimes.
		self restoreResumptionTimes ].
	ActiveDelayStartTime := nowTick.

	"Signal any expired delays"
	[ ActiveDelay notNil and:[ nowTick >= ActiveDelay resumptionTime ]] whileTrue: [
		ActiveDelay signalWaitingProcess.
		SuspendedDelays isEmpty 
			ifTrue: [ ActiveDelay := nil ] 
			ifFalse:[ ActiveDelay := SuspendedDelays removeFirst ]].

	"And signal when the next request is due. We sleep at most 1sec here
	as a soft busy-loop so that we don't accidentally miss signals."
	nextTick := nowTick + 1000.
	ActiveDelay ifNotNil: [
		nextTick := nextTick min: ActiveDelay resumptionTime ].
	nextTick := nextTick min: SmallInteger maxVal.

	"Since we have processed all outstanding requests, reset the timing semaphore so
	that only new work will wake us up again. Do this RIGHT BEFORE setting the next
	wakeup call from the VM because it is only signaled once so we mustn't miss it."
	TimingSemaphore initSignals.
	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.

	"This test is necessary for the obscure case that the msecs clock rolls over
	after nowTick has been computed (unlikely but not impossible). In this case we'd
	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets
	scheduled (which may not be any time soon). In any case, since handling the
	condition is easy, let's just deal with it."
	afterwardsTick _ Time millisecondClockValue.
	afterwardsTick < nowTick  						"Means clock rollover."
		ifTrue: [ TimingSemaphore signal ]. "retry"

	"It seems that #primSignal:atMilliseconds: might not signal the semaphore if the requested moment is in the past.
	This behavior was observed in Linux Spur64 VMs.
	If this happens, next delay never finishes. Usual symptom is frozen Morphic.
	If there is any risk of this happening, just do another iteration right now."
	nextTick < afterwardsTick  						"We're already late for next signal."
		ifTrue: [ TimingSemaphore signal ]. "retry"! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 3/5/2017 00:38:27' prior: 50340477!
                     doOneCycle
	"Do one cycle of the interaction loop. This method is called repeatedly when the world is running.
	
	Make for low cpu usage if the ui is inactive, but quick response when ui is in use.
	However, after some inactivity, there will be a larger delay before the ui gets responsive again."

	| wait waitUntil |
	waitDelay ifNil: [ waitDelay _ Delay forMilliseconds: 50 ].
	lastCycleHadAnyEvent
		ifTrue: [
			pause _ 20.				"This value will only be used when there are no more events to serve."
			wait _ 0 ]					"Don't wait"
		ifFalse: [
			pause < 200				"No events processed? Start saving CPU!! But never make the user wait more than 200ms for being responsive again."
				ifTrue: [ pause _ pause * 21//20 ].
			waitUntil _ lastCycleTime + pause.
			"Earlier if steps"
			stepList isEmpty not ifTrue: [
				waitUntil _ waitUntil min: stepList first scheduledTime ].
			"Earlier if alarms"
			alarms ifNotNil: [
				alarms isEmpty not ifTrue: [
					waitUntil _ waitUntil min: alarms first scheduledTime ]].

			wait _ waitUntil - Time localMillisecondClock ].
	Preferences serverMode
		ifTrue: [ wait _ wait max: 50 ].	"Always wait at least a bit on servers, even if this makes the UI slow."
	wait > 0
		ifFalse: [ Processor yield ]
		ifTrue: [
			waitDelay beingWaitedOn
				ifFalse: [ waitDelay setDelay: wait; wait ]
				ifTrue: [
					"If we are called from a different process than that of the main UI, we might be called in the main
					interCyclePause. In such case, use a new Delay to avoid 'This Delay has already been scheduled' errors"
					(Delay forMilliseconds: wait) wait ]].

	"Record start time of this cycle, and do cycle"
	lastCycleTime _ Time localMillisecondClock.
	lastCycleHadAnyEvent _ self doOneCycleNow! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3059-RealFixForSteppingFreeze-JuanVuletich-2017Mar06-10h02m-jmv.1.cs.st----!

----SNAPSHOT----#(6 March 2017 10:16:14.796027 am) Cuis5.0-3059-spur-64.image priorSource: 203014!

----QUIT----#(6 March 2017 10:16:31.136894 am) Cuis5.0-3059-spur-64.image priorSource: 293443!

----STARTUP----#(8 March 2017 9:09:50.654222 am) as /home/juan/Rectifier/Cuis-Smalltalk-Dev/Cuis5.0-3059-spur-64.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3059] on 7 March 2017 at 9:52:45 am'!
!Time class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 09:52:37' prior: 16937622!
               primMillisecondClock
	"Primitive. Answer the number of milliseconds since the millisecond clock
	was last reset or rolled over. No sync to any system clock.
	Implemented by all major platforms.
	Essential. See Object documentation whatIsAPrimitive. 
	
	Time primMillisecondClock
	Time primMillisecondClock / 1000 / 60.0

	Range is  from zero to 16r1FFFFFFF.
	The VM defines MillisecondClockMask as 16r1FFFFFFF

	Overflows usually every six days.
	Still used in #localMillisecondClock if the VM doesn't implement
		Time primLocalMicrosecondClock
	"
"Not really a clock, but a timer or ticker"

	<primitive: 135>
	self primitiveFailed! !
!Delay class methodsFor: 'timer process' stamp: 'jmv 3/7/2017 09:51:10' prior: 50340665!
           handleTimerEvent
	"Handle a timer event; which can be either:
		- a schedule request (ScheduledDelay notNil)
		- an unschedule request (FinishedDelay notNil)
		- a timer signal (not explicitly specified)
	We check for timer expiry every time we get a signal."
	| nowTick nextTick afterwardsTick |
	"Wait until there is work to do."
	TimingSemaphore wait.

	"Process any schedule requests"
	ScheduledDelay ifNotNil: [
		"Schedule the given delay"
		self scheduleDelay: ScheduledDelay.
		ScheduledDelay := nil.
		ScheduledDelayNilledSemaphore initSignals. 
		ScheduledDelayNilledSemaphore signal ].

	"Process any unschedule requests"
	FinishedDelay ifNotNil: [
		self unscheduleDelay: FinishedDelay.
		FinishedDelay := nil.
		FinishedDelayNilledSemaphore initSignals.
		FinishedDelayNilledSemaphore signal ].

	"Check for clock wrap-around."
	nowTick := Time millisecondClockValue.
	nowTick < ActiveDelayStartTime ifTrue: [
		"clock wrapped"
		self saveResumptionTimes.
		self restoreResumptionTimes ].
	ActiveDelayStartTime := nowTick.

	"Signal any expired delays"
	[ ActiveDelay notNil and:[ nowTick >= ActiveDelay resumptionTime ]] whileTrue: [
		ActiveDelay signalWaitingProcess.
		SuspendedDelays isEmpty 
			ifTrue: [ ActiveDelay := nil ] 
			ifFalse:[ ActiveDelay := SuspendedDelays removeFirst ]].

	"And signal when the next request is due. We sleep at most 1sec here
	as a soft busy-loop so that we don't accidentally miss signals."
	nextTick := nowTick + 1000.
	ActiveDelay ifNotNil: [
		nextTick := nextTick min: ActiveDelay resumptionTime ].
	nextTick := nextTick min: 16r1FFFFFFF.	"MillisecondClockMask"

	"Since we have processed all outstanding requests, reset the timing semaphore so
	that only new work will wake us up again. Do this RIGHT BEFORE setting the next
	wakeup call from the VM because it is only signaled once so we mustn't miss it."
	TimingSemaphore initSignals.
	Delay primSignal: TimingSemaphore atMilliseconds: nextTick.

	"This test is necessary for the obscure case that the msecs clock rolls over
	after nowTick has been computed (unlikely but not impossible). In this case we'd
	wait for MillisecondClockMask msecs (roughly six days) or until another delay gets
	scheduled (which may not be any time soon). In any case, since handling the
	condition is easy, let's just deal with it."
	afterwardsTick _ Time millisecondClockValue.
	afterwardsTick < nowTick  						"Means clock rollover."
		ifTrue: [ TimingSemaphore signal ]. "retry"

	"It seems that #primSignal:atMilliseconds: might not signal the semaphore if the requested moment is in the past.
	This behavior was observed in Linux Spur64 VMs.
	If this happens, next delay never finishes. Usual symptom is frozen Morphic.
	If there is any risk of this happening, just do another iteration right now."
	nextTick < afterwardsTick  						"We're already late for next signal."
		ifTrue: [ TimingSemaphore signal ]. "retry"! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3060-Proper-MillisecondClockMask-JuanVuletich-2017Mar07-09h05m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3061] on 7 March 2017 at 12:20:30 pm'!
!Time class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 12:16:43' prior: 16937642!
                      primUtcMicrosecondClock
	"Answer the number of microseconds since the UTC Smalltalk epoch, 
	i.e. 00:00 on the morning of January 1, 1901, the start of the 20th century, in UTC time.
	 The value is derived from the Posix epoch with a constant offset corresponding to elapsed microseconds
	 between the two epochs according to RFC 868.
	Answer is (at least usually) a  LargePositiveInteger
	Cog VMs implement this. Interpreters might not."
	"
	Time primUtcMicrosecondClock
	Time primUtcMicrosecondClock/ 1000 / 1000 / 60 / 60 / 24 / 365.25

	(Time primUtcMicrosecondClock / 1000 / 1000 + Time primUtcWithOffset second) / 60 / 60 / 24 / 365.25
	(DateAndTime now - (DateAndTime year: 1901 month: 1 day: 1)) totalSeconds / 60 / 60 / 24 / 365.25
	"
	<primitive: 240>
	^nil! !
!Delay class methodsFor: 'primitives' stamp: 'jmv 3/7/2017 12:19:39'!
                       primSignal: aSemaphore atUTCMicroseconds: anInteger
	"Signal the semaphore when the UTC microsecond clock reaches the value of the second argument.
	 Fail if the first argument is neither a Semaphore nor nil.
	Fail if the second argument is not an integer (either SmallInteger or LargePositiveInteger).
	See #primUtcMicrosecondClock
	 Essential. See Object documentation whatIsAPrimitive."
	<primitive: 242>
	^self primitiveFailed! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3061-UTCDelayedSignalPrimitive-JuanVuletich-2017Mar07-12h16m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3061] on 7 March 2017 at 2:55:27 pm'!

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!
!MenuMorph methodsFor: 'control' stamp: 'ar 9/17/2000 20:38'!
   activeSubmenu: aSubmenu
	activeSubMenu ifNotNil:[activeSubMenu delete].
	activeSubMenu _ aSubmenu.! !
!MenuMorph methodsFor: 'initialization' stamp: 'ar 10/10/2000 01:57'!
                    delete
	activeSubMenu ifNotNil:[activeSubMenu delete].
	^super delete! !
!MenuItemMorph methodsFor: 'events' stamp: 'jmv 9/20/2012 00:14'!
                     activateOwnerMenu: evt
	"Activate our owner menu; e.g., pass control to it"
	owner ifNil: [ ^false ]. "not applicable"
	(owner morphContainsPoint: (owner internalizeFromWorld: evt eventPosition))
		ifFalse: [ ^false ].
	owner activate: evt.
	^true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 3/7/2017 14:37:43' prior: 50339178!
                    deleteIfPopUp: evt
	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."

	stayUp ifFalse: [ self delete ].
	popUpOwner ifNotNil: [
		popUpOwner isSelected: false.
		popUpOwner deleteIfPopUp: evt ].
	evt ifNotNil: [ evt hand ifNotNil: [ :h | h releaseMouseFocus: self ]]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 5/9/2016 20:40' prior: 50339187!
          popUpAdjacentTo: rightOrLeftPointInWorld from: sourceItem
	"Present this menu at the given point under control of the given hand.
	Used mostly for submenus."

	| delta tryToPlace selectedOffset |
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld
			amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = (0@0) ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !
!MenuMorph methodsFor: 'events-processing' stamp: 'jmv 8/20/2012 17:50' prior: 50339326!
  handleFocusEvent: aMorphicEvent
	"Handle focus events. Valid menu transitions are determined based on the menu currently holding the focus after the mouse went down on one of its children."
	| eventPositionInOurCoordinates |
	eventPositionInOurCoordinates _ self internalizeFromWorld: aMorphicEvent eventPosition.

	self dispatchEvent: aMorphicEvent localPosition: eventPositionInOurCoordinates.

	"Need to handle keyboard input if we have the focus."
	aMorphicEvent isKeyboard ifTrue: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates].

	"We need to handle button clicks outside and transitions to local popUps so throw away everything else"
	(aMorphicEvent isMouseOver or: [aMorphicEvent isMouse not]) ifTrue: [ ^self ].
	"What remains are mouse buttons and moves"
	aMorphicEvent isMove ifFalse: [ ^ aMorphicEvent sentTo: self localPosition: eventPositionInOurCoordinates ]. "handle clicks outside by regular means"
	"Now it's getting tricky. On #mouseMove we might transfer control to *either* the currently active submenu or the pop up owner, if any. Since the active sub menu is always displayed upfront check it first."
	selectedItem ifNotNil:[(selectedItem activateSubmenu: aMorphicEvent) ifTrue: [^self]].
	"Note: The following does not traverse upwards but it's the best I can do for now"
	popUpOwner ifNotNil:[(popUpOwner activateOwnerMenu: aMorphicEvent) ifTrue: [^self]].! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 9/8/2012 20:15' prior: 50339368!
     initialize
	super initialize.
	extent _ 40@10.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 1/29/2014 23:46' prior: 50339381!
           deselect

	self isSelected: false.
	subMenu ifNotNil: [
		owner ifNotNil:[ owner activeSubmenu: nil ].
		self removeAlarm: #deselectTimeOut ]! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 1/29/2014 23:44' prior: 50339387!
                          select
	self isSelected: true.
	owner activeSubmenu: subMenu.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphBoundsInWorld topRight + (10@0)
									with: self morphBoundsInWorld topLeft)
			from: self.
		subMenu selectItem: nil ]! !

BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

!classDefinition: #MenuMorph category: #'Morphic-Menus'!
BorderedRectMorph subclass: #MenuMorph
	instanceVariableNames: 'defaultTarget selectedItem stayUp titleMorph activeSubMenu popUpOwner'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Menus'!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3062-FixRecentMenuBreackage-JuanVuletich-2017Mar07-14h20m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3049] on 7 March 2017 at 3:18:07 pm'!
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:23'!
                               methodForTest

	"Can not call it testMethod because it will be detected as test - Hernan" 

	^self class lookupSelector: self selector! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:38' prior: 50340560!
      ifCanNotDebugDo: handler

	^self methodForTest isQuick ifTrue: handler! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:45' prior: 50340614!
      openDebuggerOnFailingTestMethod

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self methodForTest.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ Debugger new
		process: guineaPig
		context: context.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !
!TestCase methodsFor: 'Private' stamp: 'HAW 3/6/2017 14:55:50' prior: 50340631!
                            openDebuggerOnFailingTestMethod: semaphore

	| guineaPig context compiledMethod debugger |

	compiledMethod _ self methodForTest.
	guineaPig _ [ self performTest ] newProcess.
	context _ guineaPig suspendedContext.
	debugger _ TestCaseDebugger new
		process: guineaPig
		context: context.
	debugger doneSemaphore: semaphore.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod]
		whileFalse: [debugger send].
! !

TestCase removeSelector: #testMethod!

TestCase removeSelector: #testMethod!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3063-FixForExtraTest-HernanWilkinson-2017Mar03-19h15m-HAW.1.cs.st----!

----SNAPSHOT----#(8 March 2017 9:10:16.580592 am) Cuis5.0-3063-spur-64.image priorSource: 293543!

----QUIT----#(8 March 2017 9:10:32.980626 am) Cuis5.0-3063-spur-64.image priorSource: 306790!

----STARTUP----#(13 March 2017 4:27:27.626002 pm) as /home/juan/Rectifier/Cuis-Smalltalk-Dev/Cuis5.0-3063-spur-64.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3063] on 13 March 2017 at 4:16:45 pm'!
!WriteStream methodsFor: 'accessing' stamp: 'jmv 3/12/2017 18:55:36' prior: 50335208!
           nextPutAllString: aString withAttributes: attributesArray

	| newEnd |
	(self isCompatibleWithContents: aString)
		ifFalse: [ ^ self nextPutAll: aString ].

	newEnd _ position + aString size.
	newEnd > writeLimit ifTrue: [
		self growTo: newEnd + 10].

	collection
		replaceFrom: position+1
		to: newEnd 
		withString: aString
		attributes: attributesArray
		startingAt: 1.
	position _ newEnd! !
!WriteStream methodsFor: 'private' stamp: 'jmv 3/12/2017 19:08:07' prior: 16946568!
growTo: anInteger
	"Grow the collection by creating a new bigger collection and then
	copy over the contents from the old one. We grow by doubling the size.

	anInteger is the required minimal new size of the collection "

	| oldSize grownCollection newSize |
	oldSize _ collection size.
     newSize _ anInteger + (oldSize max: 20).
	grownCollection _ collection class new: newSize.
	collection _ grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.
	writeLimit _ collection size! !
!WriteStream methodsFor: 'private' stamp: 'jmv 3/12/2017 19:07:28' prior: 16946596!
                  pastEndPut: anObject
	"Grow the collection.
	Then we put <anObject> at the current write position."

	self growTo: collection size + 1.
	collection at: (position _ position + 1) put: anObject! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3064-WriteStreamTweaks-JuanVuletich-2017Mar13-16h06m-jmv.1.cs.st----!

----SNAPSHOT----#(13 March 2017 4:27:36.062745 pm) Cuis5.0-3064-spur-64.image priorSource: 306889!

----QUIT----#(13 March 2017 4:27:47.296681 pm) Cuis5.0-3064-spur-64.image priorSource: 308719!

----STARTUP----#(19 March 2017 8:11:18.86056 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3064-spur-64.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 15 March 2017 at 2:07:10 pm'!
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 3/15/2017 14:06:54' prior: 50337461!
            maximumUsableAreaInWorld: aWorldOrNil

	| allowedArea |
	allowedArea _ Display boundingBox.
	aWorldOrNil ifNotNil: [
		allowedArea _ allowedArea intersect: aWorldOrNil viewBox.
		aWorldOrNil taskbar ifNotNil: [ :tb |
			tb morphBoundsInWorld ifNotNil: [ :r |
				allowedArea _ (allowedArea areasOutside: r) first ]]].
	^allowedArea
! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3065-TaskbarFix-JuanVuletich-2017Mar15-14h03m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 17 March 2017 at 10:25:22 am'!
!Debugger methodsFor: 'method creation' stamp: 'HAW 3/17/2017 10:24:51' prior: 50336720!
                    createMethodWhenDoesNotUndertand

	| message chosenClass interruptedContext |
	
	"The doesNotUndertand context must be selected - Hernan"
	contextStackIndex = 1 ifFalse: [ self contextStackIndex: 1 oldContextWas: self selectedContext ].
		
	interruptedContext _ self interruptedContext.
	message _ interruptedContext tempAt: 1.
	
	chosenClass _ self
		askForSuperclassOf: interruptedContext receiver class
		toImplement: message selector
		ifCancel: [^self].
	
	self implement: message inClass: chosenClass context: self selectedContext

! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3066-CreateMissingMethodInDebuggerFix-HernanWilkinson-2017Mar16-20h05m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 18 March 2017 at 10:47:28 am'!
!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'HAW 3/18/2017 10:44:48' prior: 50338485!
                       cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$r	#acceptAndDebugTest:		'Saves method and debugs it')
		#(		$t	#acceptAndTest:				'Saves method, runs it as test and then all tests in class. Opens debugger if error')
		#(		$y	#acceptAndTestAll:				'Saves method, runs it as test and then all tests in class category. Opens debugger if error')
		#(		$i	#inspectIt:							'Inspect it (selection is a valid expression, or selection is over an inspect-ilst)')
		#(		$p	#printIt:								'Print it (selection is a valid expression)')

		#(		$s	#save:								'Save (i.e. accept)')
		#(		$d	#doIt:								'Do it (selection is a valid expression)')
		#(		$l	#cancelEdits:						'Cancel')

		#(		$b	#browseIt:							'Browse it (selection is a class name or cursor is over a class-list or message-list)')
		#(		$n	#sendersOfIt:						'Senders of it (selection is a message selector or cursor is over a class-list or message-list)')
		#(		$m	#implementorsOfIt:				'Implementors of it (selection is a message selector or cursor is over a class-list or message-list)')

		#(		$E	#methodStringsContainingit:'Method strings containing it')
		#(		$T	#displayIfTrue:					'Insert #ifTrue:')
		#(		$I	#exploreIt:							'Inspect via Object Explorer')

		#(		$A	#argAdvance:						'Advance argument')
		#(		$D	#debugIt:							'Debug it')
		#(		$F	#displayIfFalse:					'Insert #ifFalse:')
		#(		$G	#fileItIn:							'File in selection')

		#(		$V	#pasteInitials:					'Paste author initials')
		#(		$N	#referencesToIt:					'References to it (selection is a class name, or cursor is over a class-list or message-list)')
	)! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3067-FixATypo-HernanWilkinson-2017Mar18-10h44m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 18 March 2017 at 8:30:03 pm'!
!TheWorldMenu methodsFor: 'construction' stamp: 'HAW 3/18/2017 20:26:59' prior: 16934784!
                            buildWorldMenu
	"Build the menu that is put up when the screen-desktop is clicked on"

	| menu |
	menu _ MenuMorph new defaultTarget: self.
	self colorForDebugging: menu.
	menu addStayUpIcons.
	self fillIn: menu
		from: {
				{ 'Open...'. { self. #openWindow}}.
				{ 'New morph...'. { self. #newMorph}.
					'Offers a variety of ways to create new objects'}.
				{ 'Preferences...'. { self. #preferencesDo}.
					'put up a menu offering many controls over appearance and system preferences.'}.
				{ 'Windows...'. { self. #windowsDo}}.
				{ 'Help...'. { self. #helpDo}.
					'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}.
				nil.
				{ 'Changes...'. { self. #changesDo}}.
				{ 'Debug...'. { self. #debugDo}.
					'a menu of debugging items'}.
				{ 'Restore Display (r)'. { myWorld. #restoreMorphicDisplay}.
					'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}.
				nil.
				{ 'Save'. { Smalltalk . #saveSession}.
					'save the current version of the image on disk'}.
				{ 'Save as...'. { Smalltalk . #saveAs}.
					'save the current version of the image on disk under a new name.'}.
				{ 'Save as New Version'. { Smalltalk . #saveAsNewVersion}.
					'give the current image a new version-stamped name\and save it under that name on disk.\Clear all user preferences and user state (class vars).' withNewLines}.
				{ 'Save and Quit'. { self. #saveAndQuit}.
					'save the image and quit out of Cuis.'}.				
				{ 'Quit'. { self. #quitSession}.
					'quit out of Cuis.'}}.
	^menu! !

TheWorldMenu removeSelector: #saveAndQuitSession!

TheWorldMenu removeSelector: #saveMenu!

TheWorldMenu removeSelector: #saveMenu!

TheWorldMenu removeSelector: #saveOptionsDo!

TheWorldMenu removeSelector: #saveOptionsDo!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3068-SaveMenuIntegrationInWorldMenu-HernanWilkinson-2017Mar18-10h53m-HAW.1.cs.st----!

----SNAPSHOT----#(19 March 2017 8:11:24.98593 pm) Cuis5.0-3068-spur-64.image priorSource: 308819!

----QUIT----#(19 March 2017 8:11:36.879466 pm) Cuis5.0-3068-spur-64.image priorSource: 314821!

----STARTUP----#(16 April 2017 9:01:55.583301 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3068-spur-64.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3068] on 26 March 2017 at 11:30:12 pm'!
!Theme class methodsFor: 'class initialization' stamp: 'jmv 3/26/2017 23:25:17' prior: 16936878!
                              currentTheme: aTheme

	CurrentTheme := aTheme new.
	SHTextStylerST80 initialize.
	self runningWorld ifNotNil: [ :w |
		w backgroundImage ifNil: [
			w color: CurrentTheme background ]].
	SystemWindow initialize.
	BitBltCanvas releaseClassCachedState.
	self runningWorld ifNotNil: [ :w |
		CurrentTheme useTaskbar
			ifTrue: [w showTaskbar]
			ifFalse: [w hideTaskbar].
		w restoreMorphicDisplay ].
	
	^ CurrentTheme! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3069-Theme-fix-JuanVuletich-2017Mar26-23h30m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 25 March 2017 at 10:48:23 am'!
!BasicClassOrganizer methodsFor: 'accessing' stamp: 'HAW 3/25/2017 10:48:00' prior: 16782575!
                             classComment: aString 
	"Store the comment, aString, associated with the object that refers to the 
	receiver."

	aString ifNil: [ ^classComment _ nil ].
	
	aString isRemote
		ifTrue: [classComment _ aString]
		ifFalse: [aString size = 0
			ifTrue: [classComment _ nil]
			ifFalse: [
				self error: 'use aClass classComment:'.
				classComment _ RemoteString newString: aString onFileNumber: 2]]
				"Later add priorSource and date and initials?"! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3070-ClassCommentSetterFix-HernanWilkinson-2017Mar25-10h47m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 27 March 2017 at 9:11:54 am'!
!Delay class methodsFor: 'instance creation' stamp: 'HAW 3/27/2017 09:08:00' prior: 16832891!
               forDuration: aDuration

	^ self forMilliseconds: aDuration totalMilliseconds! !

Duration removeSelector: #totalMilliSeconds!

Duration removeSelector: #totalMilliSeconds!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3071-Remove-totalMilliSeconds-HernanWilkinson-2017Mar27-09h08m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3068] on 30 March 2017 at 8:42:47 am'!
!Morph methodsFor: 'user interface' stamp: 'jmv 3/30/2017 08:41:08'!
                            toggleCollapseOrShow
	"If collapsed, show me.
	If visible, collapse me."

	self visible
		ifTrue:  [ self collapse ]
		ifFalse: [ self showAndComeToFront ]! !
!Morph methodsFor: 'user interface' stamp: 'jmv 3/30/2017 08:38:46' prior: 50337398!
            collapse
	"If taskbar not visible, just hide."

	self hide.
	self taskbar
		ifNotNil: [ :tb | tb wasCollapsed: self ]! !
!Morph methodsFor: 'user interface' stamp: 'jmv 3/30/2017 08:38:12' prior: 50337113!
                  showAndComeToFront
	"Make me visible if not, set me on top of all other sibling morphs."
	self show; comeToFront! !
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 3/30/2017 08:41:28' prior: 50337694!
                      addButtonFor: aMorph

	| button |
	aMorph == self ifFalse: [
		button _ PluggableButtonMorph
			model: aMorph
			stateGetter: nil
			action: #toggleCollapseOrShow.
		button
			color: self color;
			icon: (aMorph imageForm: 32);
			setBalloonText: aMorph label.
		button icon: button magnifiedIcon.
		viewBox
			addMorph: button
			fixedWidth: self defaultHeight ]! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3072-taskbarButtonTogglesCollapsing-JuanVuletich-2017Mar30-08h36m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3072] on 30 March 2017 at 8:57:52 am'!
!TaskbarMorph methodsFor: 'services' stamp: 'jmv 3/30/2017 08:54:49'!
                     aboutToCollapse: aMorph
	"Add a button for aMorph if not already there (see #taskbarIncludesAllWindows)"

	(self buttonFor: aMorph) ifNil: [
		self addButtonFor: aMorph ]! !
!Morph methodsFor: 'user interface' stamp: 'jmv 3/30/2017 08:55:31' prior: 50341576!
                             collapse
	"If taskbar not visible, just hide."

	self taskbar
		ifNotNil: [ :tb | tb aboutToCollapse: self ].
	self hide! !

TaskbarMorph removeSelector: #wasCollapsed:!

TaskbarMorph removeSelector: #wasCollapsed:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3073-TaskbarFix-JuanVuletich-2017Mar30-08h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 29 March 2017 at 5:18:04 pm'!

Object subclass: #ExceptionHandlingCondition
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!classDefinition: #ExceptionHandlingCondition category: #'Exceptions Kernel'!
Object subclass: #ExceptionHandlingCondition
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!
!ExceptionHandlingCondition commentStamp: '<historical>' prior: 0!
       I represent the protocol expected to be as condition on the exception handling message on:do:
I also define the protocol to create and combine exceptions handling conditions.
See methods #, and #- for a complemented documentation!
!ExceptionHandlingCondition commentStamp: '<historical>' prior: 50341649!
               I represent the protocol expected to be as condition on the exception handling message on:do:
I also define the protocol to create and combine exceptions handling conditions.
See methods #, and #- for a complemented documentation!

Smalltalk renameClassNamed: #ExceptionFilter as: #FilterExceptionHandlingCondition!

ExceptionHandlingCondition subclass: #FilterExceptionHandlingCondition
	instanceVariableNames: 'handleCondition filterCondition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!classDefinition: #FilterExceptionHandlingCondition category: #'Exceptions Kernel'!
ExceptionHandlingCondition subclass: #FilterExceptionHandlingCondition
	instanceVariableNames: 'handleCondition filterCondition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

Smalltalk renameClassNamed: #ExceptionAdd as: #OrExceptionHandlingCondition!

ExceptionHandlingCondition subclass: #OrExceptionHandlingCondition
	instanceVariableNames: 'leftCondition rightCondition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!

!classDefinition: #OrExceptionHandlingCondition category: #'Exceptions Kernel'!
ExceptionHandlingCondition subclass: #OrExceptionHandlingCondition
	instanceVariableNames: 'leftCondition rightCondition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Exceptions Kernel'!
!BlockClosure methodsFor: 'error handing' stamp: 'HAW 3/29/2017 15:16:01'!
                     handles: anException

	"This allows a block to be the handling condition of an exception handling.
	See Exception class>>handles:"
	
	^self value: anException ! !
!Exception class methodsFor: 'handling condition creation' stamp: 'HAW 3/28/2017 15:48:57' prior: 16840211!
                 , anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>,"
	
	^anExceptionHandlingCondition createOrConditionWithExceptionType: self! !
!Exception class methodsFor: 'handling condition creation' stamp: 'HAW 3/28/2017 15:49:08'!
                  - anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>-"

	^anExceptionHandlingCondition createFilterConditionWithExceptionType: self! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:23:04'!
     createFilterConditionWithExceptionType: anExceptionType

	^FilterExceptionHandlingCondition handling: anExceptionType filtering: self! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:26:42'!
                 createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^FilterExceptionHandlingCondition handling: aFilterExceptionHandlingCondition filtering: self! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 15:40:33'!
         createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^FilterExceptionHandlingCondition handling: anOrExceptionHandlingCondition filtering: self! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 15:37:59'!
                   createOrConditionWithExceptionType: anExceptionType

	^OrExceptionHandlingCondition handling: anExceptionType or: self
! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 15:48:29'!
                               createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition handleCondition, self - aFilterExceptionHandlingCondition filterCondition 
	
	! !
!Exception class methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:09:54'!
                         createOrConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^OrExceptionHandlingCondition handling: anOrExceptionHandlingCondition or: self! !
!ExceptionHandlingCondition methodsFor: 'error handling' stamp: 'HAW 3/28/2017 17:29:18'!
              handles: anException 
	
	"Must return true if anException must be handle
	See also Exception class>>handles: anException"
	
	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/28/2017 17:17:36'!
                            , anExceptionHandlingCondition

	"Creates a handling condition that will return true if either part of the condition handles the exception.
	It behaves like an or
	The following example will handle the exception
	[ Error signal ]
	   on:  Error, Halt 
	  do: [ :anError | ... ]
	
	The following example will also handle the exception:
	[ Halt signal ]
	   on:  Error, Halt
	  do: [ :anError | ... ]"
	
	self subclassResponsibility 
	! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:37'!
    - anExceptionHandlingCondition

	"Creates a handling condition that will not handle exceptions that meet the right side of the condition
	The following example will not handle the exception
	[ 1/0 ]
	   on:  Error - ZeroDivide 
	  do: [ :anError | ... ]
	
	The following example will handle the exception:
	[ Error signal ]
	   on:  Error - ZeroDivide 
	  do: [ :anError | ... ]
	
	Due to inconsisties that can arrise with combining #, with #- the implementation orders the in such a way that 'or conditions' go first 
	and 'filter conditions' go last. Doing so (Error - Notification) , (UnhandledError - ZeroDivide)  is converted to  Error, UnhandledError - Notification - ZeroDivide 
	Inconsisties can arrise because ZeroDivide is a subclass of Error and therefore if the condition is not ordered correctly a ZeroDivide could be handled.
	This inconsisty can be found in Pharo where the condition (Error - Notification) , (UnhandledError - ZeroDivide) does not filter ZeroDivide but 
	the condition Error, UnhandledError - Notification - ZeroDivide does filter it.
	That is the reason the implementation uses double dispatch
	"
	
	self subclassResponsibility 
	! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:31:13'!
createFilterConditionWithExceptionType: anExceptionType

	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:33:31'!
                     createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 

	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:33:39'!
createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 

	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:33:51'!
       createOrConditionWithExceptionType: anExceptionType

	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:34:31'!
                         createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 

	self subclassResponsibility ! !
!ExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 13:34:42'!
    createOrConditionWithOrCondition: anOrExceptionHandlingCondition 

	self subclassResponsibility ! !
!FilterExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:20:21'!
 filterCondition
	
	^filterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:20:26'!
                             handleCondition
	
	^handleCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'error handling' stamp: 'HAW 3/28/2017 17:20:41'!
                        handles: anException 
	
	^ (filterCondition handles: anException) not and: [ handleCondition handles: anException ]! !
!FilterExceptionHandlingCondition methodsFor: 'initialization' stamp: 'HAW 3/29/2017 13:45:21'!
         initializeHandling: aHandleCondition filtering: aFilterCondition 

	handleCondition _ aHandleCondition.
	filterCondition _ aFilterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:08'!
   , anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createOrConditionWithFilterCondition: self! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:00'!
                          - anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createFilterConditionWithFilterCondition: self! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:56:46'!
            createFilterConditionWithExceptionType: anExceptionType

	^self class 
		handling: anExceptionType, filterCondition 
		filtering: handleCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:19:24'!
                   createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition - handleCondition, filterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:19:48'!
               createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^anOrExceptionHandlingCondition, filterCondition - handleCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:19:56'!
                         createOrConditionWithExceptionType: anExceptionType

	^anExceptionType - handleCondition - filterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:20:04'!
                          createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition handleCondition,handleCondition - aFilterExceptionHandlingCondition filterCondition - filterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 15:32:33'!
                createOrConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^anOrExceptionHandlingCondition, handleCondition - filterCondition ! !
!FilterExceptionHandlingCondition methodsFor: 'printing' stamp: 'HAW 3/28/2017 17:20:55'!
                          printOn: aStream

	aStream
		print: handleCondition ;
		nextPutAll: ' - ';
		print: filterCondition ! !
!FilterExceptionHandlingCondition class methodsFor: 'instance creation' stamp: 'HAW 3/28/2017 17:18:11'!
               handling: aHandleCondition filtering: aFilterCondition 
	
	^self new initializeHandling: aHandleCondition filtering: aFilterCondition 
! !
!OrExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:55:27'!
                              leftCondition

	^leftCondition ! !
!OrExceptionHandlingCondition methodsFor: 'accessing' stamp: 'HAW 3/28/2017 17:56:11'!
      rightCondition

	^rightCondition ! !
!OrExceptionHandlingCondition methodsFor: 'error handling' stamp: 'HAW 3/28/2017 17:31:39'!
                               handles: anException

	^ (leftCondition handles: anException) or: [ rightCondition handles: anException ]! !
!OrExceptionHandlingCondition methodsFor: 'initialization' stamp: 'HAW 3/28/2017 17:32:20'!
                       initializeHandling: aLeftCondition or: aRightCondition

	leftCondition _ aLeftCondition.
	rightCondition _ aRightCondition ! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:16'!
                        , anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createOrConditionWithOrCondition: self
	! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation' stamp: 'HAW 3/29/2017 13:59:22'!
- anExceptionHandlingCondition

	"See ExceptionHandlingCondition>>#- for an explanation of why double dispatch is used as implementation"
	
	^anExceptionHandlingCondition createFilterConditionWithOrCondition: self
	! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:32:37'!
                  createFilterConditionWithExceptionType: anExceptionType

	^FilterExceptionHandlingCondition 
		handling: anExceptionType - leftCondition 
		filtering: rightCondition ! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:33:37'!
   createFilterConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^aFilterExceptionHandlingCondition - leftCondition - rightCondition ! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 17:34:05'!
                     createFilterConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^ anOrExceptionHandlingCondition - leftCondition - rightCondition ! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:16:37'!
                              createOrConditionWithExceptionType: anExceptionType

	^self class handling: anExceptionType or: self! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 14:56:09'!
     createOrConditionWithFilterCondition: aFilterExceptionHandlingCondition 
	
	^self, aFilterExceptionHandlingCondition ! !
!OrExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/28/2017 11:20:32'!
                    createOrConditionWithOrCondition: anOrExceptionHandlingCondition 
	
	^self class handling: anOrExceptionHandlingCondition or: self! !
!OrExceptionHandlingCondition methodsFor: 'printing' stamp: 'HAW 3/28/2017 17:54:46'!
    printOn: aStream
	
	aStream
		print: leftCondition;
		nextPutAll: ', ';
		print: rightCondition ! !
!OrExceptionHandlingCondition class methodsFor: 'instance creation' stamp: 'HAW 3/27/2017 15:47:32'!
                       handling: anExceptionClass or: anotherExceptionClass
 
	^self new initializeHandling: anExceptionClass or: anotherExceptionClass
! !

OrExceptionHandlingCondition removeSelector: #createOrHandlingConditionWithOrHandlingCondition:!

Exception class removeSelector: #createFilterConditionWithExceptionClass:!

Exception class removeSelector: #createHandlingConditionWithExceptionClass:!

Exception class removeSelector: #handling:!

Exception class removeSelector: #orHandlingExceptionClass:!

Smalltalk removeClassNamed: #ExceptionSet!

Smalltalk removeClassNamed: #ExceptionSet!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3074-ExceptionHandlingConditionEnh-HernanWilkinson-2017Mar26-18h04m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3064] on 29 March 2017 at 6:09:56 pm'!
!FilterExceptionHandlingCondition methodsFor: 'handling condition creation - private' stamp: 'HAW 3/29/2017 17:59:55' prior: 50341963!
                              createOrConditionWithExceptionType: anExceptionType

	^anExceptionType, handleCondition - filterCondition ! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3075-ExceptionHandlingConditionFix-HernanWilkinson-2017Mar29-17h18m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3068] on 16 April 2017 at 7:53:58 pm'!
!TextEditor methodsFor: 'menu messages' stamp: 'jmv 4/16/2017 19:53:14' prior: 16932110!
 compareToClipboard
	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."
	| s1 s2 |
	s1 _ self clipboardStringOrText string.
	s2 _ self selection ifEmpty: [self privateCurrentString].
	s1 = s2 ifTrue: [^ self inform: 'Exact match'].

	(TextModel new contents:
		(DifferenceFinder displayPatchFrom: s1 to: s2 tryWords: true))
			openLabel: 'Comparison to Clipboard Text'! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3076-CompareToClipboardComparesSelection-JuanVuletich-2017Apr16-19h53m-jmv.1.cs.st----!

----SNAPSHOT----#(16 April 2017 9:02:02.273545 pm) Cuis5.0-3076-spur-64.image priorSource: 314920!

----QUIT----#(16 April 2017 9:02:15.23247 pm) Cuis5.0-3076-spur-64.image priorSource: 336694!

----STARTUP----#(14 May 2017 7:55:36.65277 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3076-spur-64.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3076] on 13 May 2017 at 12:54:11 pm'!
!Integer methodsFor: 'printing' stamp: 'jmv 5/9/2017 19:45:38'!
                   printOn: aStream length: minimum zeroPadded: zeroFlag
	"
	7 printOn: Transcript length: 4 padded: true. Transcript newLine.
	"
	self printOn: aStream base: 10 length: minimum padded: zeroFlag! !
!Character methodsFor: 'accessing' stamp: 'jmv 5/9/2017 19:49:32' prior: 16800371!
          digitValue
	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 
	otherwise. This is used to parse literal numbers of radix 2-36.
	$0 numericValue = 48
	$9 numericValue = 57
	$A numericValue = 65
	$Z numericValue = 90 
	$7 digitValue = 7 
	"

	| nv |
	nv _ self numericValue.
	(nv between: 48 and: 57)
		ifTrue: [ ^ nv - 48 ].
	(nv between: 65 and: 90)
		ifTrue: [ ^ nv - 55 ].
	^ -1! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3077-Integer-printPadded-JuanVuletich-2017May13-12h51m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3076] on 13 May 2017 at 1:02:33 pm'!
!Timespan class methodsFor: 'squeak protocol' stamp: 'jmv 5/9/2017 19:54:38'!
                      fromString: aString
	"Please call with specific subclass."

	^ self readFrom: aString readStream! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 17:48:37'!
                 readFrom: aStream 
	"Read a Week from the stream in any of the forms:  
		<year>-W<week>			(2009-W01) (ISO8601)"
	| weekNumber yearNumber firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [yearNumber := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream next = $W ifFalse: [
		self error: 'Invalid Format' ].

	weekNumber _ Integer readFrom: aStream.
	weekNumber < 1 ifTrue: [ self error: 'Invalid Format' ].
	(yearNumber < 100 and: [yearNumber >= 0])  ifTrue: [
		yearNumber _ yearNumber < 69 
			ifTrue: [2000 + yearNumber]
			ifFalse: [1900 + yearNumber]].

	^ self yearNumber: yearNumber weekNumber: weekNumber! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 10:54:55'!
                      yearNumber: yearNumber weekNumber: weekNumber

	| firstOfJanuary firstThursday thisThursday |
	firstOfJanuary _ DateAndTime year: yearNumber month: 1 day: 1.
	firstThursday _ firstOfJanuary + (4 - firstOfJanuary dayOfWeek \\ 7) days.
	thisThursday _ firstThursday + ((weekNumber-1) * 7) days.

	thisThursday yearNumber = yearNumber
		ifFalse: [ self error: 'Week does not exist' ].

	^ self including: thisThursday! !
!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 16:41:15'!
                   readFrom: aStream 

	| year sign |
	sign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isDigit] whileFalse: [aStream skip: 1].
	year := (Integer readFrom: aStream) * sign.
	^ self yearNumber: year! !
!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 11:24:09'!
     asMonth
	"Many allowed forms, see Month>>#readFrom:
		'July 1998' asMonth.
		'1998/7'asMonth.
	"

	^ Month fromString: self! !
!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 16:39:13'!
                               asWeek
	"
		'2008-W52' asWeek.
		'2008-W53' asWeek. 'Invalid format!!'.
		'2009-W01' asWeek
		'2009-W02' asWeek
		'2009-W53' asWeek
		'2010-W01' asWeek
		'2010-W02' asWeek
		'2008-W52' asWeek start.
		'2009-W01' asWeek start
		'2009-W02' asWeek start
		'2009-W53' asWeek start
		'2010-W01' asWeek start
		'2010-W02' asWeek start
	"

	^ Week fromString: self! !
!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 16:37:23'!
                     asYear
	"
		'2008' asYear.
		'2008' asYear start.
	"

	^ Year fromString: self! !
!DateAndTime methodsFor: 'ansi protocol' stamp: 'jmv 5/12/2017 10:55:06' prior: 16828675!
                    dayOfWeek

	"
	Sunday=1, ... , Saturday=7
	Monday=1, ... , Sunday=7
	'12 May 2017 ' asDate dayOfWeek = 5
	"

	^ (jdn rem: 7) + 1! !
!DateAndTime methodsFor: 'ansi protocol' stamp: 'jmv 5/12/2017 10:53:00' prior: 16828685!
  dayOfWeekName
	"
	'12 May 2017 ' asDate dayOfWeek = 5 
	'12 May 2017 ' asDate dayOfWeekName = #Friday 
	"

	^ Week nameOfDay: self dayOfWeek
! !
!Duration methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 10:59:51' prior: 16836040!
                      printOn: aStream
	"Format as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]
	(Duration days: 2 hours: 3 minutes: 16 seconds: 43) printString =  '2:03:16:43' 
	"
	| d h m s n |
	d _ self days abs.
	h _ self hours abs.
	m _ self minutes abs.
 	s _ self seconds abs truncated.
	n _ self nanoSeconds abs. 	self negative ifTrue: [ aStream nextPut: $- ].
	d printOn: aStream. aStream nextPut: $:.
	h printOn: aStream length: 2 zeroPadded: true.aStream nextPut: $:.
	m printOn: aStream length: 2 zeroPadded: true.aStream nextPut: $:.
	s printOn: aStream length: 2 zeroPadded: true.
	n = 0 ifFalse: [
		| z ps |
		aStream nextPut: $..
		ps _ n printString padded: #left to: 9 with: $0. 
		z _ ps findLast: [ :c | c digitValue > 0 ].
		ps from: 1 to: z do: [ :c | aStream nextPut: c ] ]! !
!Date methodsFor: 'smalltalk-80' stamp: 'jmv 5/12/2017 10:54:58' prior: 16828235!
           weekdayIndex
	"Sunday=1, ... , Saturday=7
	Monday=1, ... , Sunday=7
	'12 May 2017 ' asDate weekdayIndex = 5
	"

	^ self dayOfWeek! !
!Date class methodsFor: 'squeak protocol' stamp: 'jmv 5/10/2017 21:56:27' prior: 16828417!
readFrom: aStream 
	"Read a Date from the stream in any of the forms:
		<day> <month> <year>		(15 April 1982; 15-APR-82; 15.4.82; 15APR82)  
		<month> <day> <year>		(April 15, 1982; 4/15/82)
		<year>-<month>-<day>		(1982-04-15) (ISO8601)"
	| day month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 31])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isLetter
		ifTrue: ["MonthName-DD-YY or DD-MonthName-YY or YY-MonthName-DD"
			month _ String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
			firstAsNumber
				ifNil: ["MonthName DD YY"
					day := Integer readFrom: aStream]
				ifNotNil: [
					year ifNil: ["DD MonthName YY"
						day := firstAsNumber]]]
		ifFalse: ["MM-DD-YY or DD-MM-YY or YY-MM-DD"
			year 
				ifNil: ["MM-DD-YY or DD-MM-YY"
					firstAsNumber > 12
						ifTrue: ["DD-MM-YY"
							day := firstAsNumber.
							month := Month nameOfMonth: (Integer readFrom: aStream)]
						ifFalse: ["MM-DD-YY"
							month := Month nameOfMonth: firstAsNumber.
							day := Integer readFrom: aStream]]
				ifNotNil: ["YY-MM-DD"
					month := Month nameOfMonth: (Integer readFrom: aStream)]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	year
		ifNil: [year := Integer readFrom: aStream]
		ifNotNil: [day := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year _  year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self year: year month: month day: day! !
!Month class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 11:28:03' prior: 16873841!
                   readFrom: aStream 
	"Read a Month from the stream in any of the forms:  
		<month> <year>			(April 1982; APR-82; 4.82; APR82)  
		<month> <year>			(April, 1982; 4/82)
		<year>-<month>			(1982-04) (ISO8601)"
	"
	Month readFrom: 'July 1998' readStream
	"
	| month year firstAsNumber firstAsNumberSign |
	firstAsNumberSign := aStream peek = $- ifTrue: [-1] ifFalse: [1].
	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isDigit ifTrue: [
		firstAsNumber := (Integer readFrom: aStream) * firstAsNumberSign.
		(firstAsNumber < 0 or: [firstAsNumber > 12])
			ifTrue: [year := firstAsNumber]].

	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
	aStream peek isLetter
		ifTrue: ["MonthName-YY or YY-MonthName"
			month _ String streamContents: [ :strm |
				[ aStream peek isLetter ] whileTrue: [ strm nextPut: aStream next ]].
			[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1]]
		ifFalse: ["MM-YY or YY-MM"
			month _ year 
				ifNil: ["MM-YY"
					Month nameOfMonth: firstAsNumber ]
				ifNotNil: ["YY-MM"
					Month nameOfMonth: (Integer readFrom: aStream)]].

	year ifNil: [
		[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].
		year := Integer readFrom: aStream].
	(year < 100 and: [year >= 0])  ifTrue: [
		year _ year < 69 
			ifTrue: [2000 + year]
			ifFalse: [1900 + year]].

	^ self month: month year: year! !
!Week methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 11:53:32' prior: 16944751!
           printOn: aStream
	"
		'2008-W52' asWeek.
		'2009-W01' asWeek
		'2009-W02' asWeek
		'2009-W53' asWeek
		'2010-W01' asWeek
		'2010-W02' asWeek
	"
	| thursday |
	thursday _ self start + 3 days.
	thursday yearNumber printOn: aStream.
	aStream nextPutAll: '-W'.
	(thursday dayOfYear-1 // 7 + 1) printOn: aStream length: 2 zeroPadded: true! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 10:54:04' prior: 16944773!
                    indexOfDay: aSymbol
	"
	Week indexOfDay: #Sunday = 7
	Week nameOfDay: 7 = #Sunday 
	"

	^ self dayNames indexOf: aSymbol! !
!Week class methodsFor: 'smalltalk-80' stamp: 'jmv 5/12/2017 10:53:55' prior: 16944778!
            nameOfDay: anIndex
	"
	Week indexOfDay: #Sunday = 7
	Week nameOfDay: 7 = #Sunday 
	"

	^ self dayNames at: anIndex! !
!Week class methodsFor: 'inquiries' stamp: 'jmv 5/10/2017 22:25:02' prior: 16944786!
                     dayNames

	^ #(Monday Tuesday Wednesday Thursday Friday Saturday Sunday)! !
!String methodsFor: 'converting' stamp: 'jmv 5/12/2017 11:22:17' prior: 16916294!
  asDate
	"Many allowed forms, see Date>>#readFrom:
		'2014/6/30' asDate.
		'70/12/30' asDate.
		'12/30/70' asDate.
		'30/12/70' asDate.
		'4/5/6' asDate.
		'15 April 1982' asDate.
	"

	^ Date fromString: self! !

Date class removeSelector: #fromString:!

Date class removeSelector: #fromString:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3078-WeekStartsOnMonday-NewWeekMonthYearCreationMethods-JuanVuletich-2017May13-12h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3076] on 13 May 2017 at 1:02:55 pm'!
!DateAndTime methodsFor: 'double dispatching' stamp: 'jmv 5/12/2017 17:17:21'!
  includingTimespanOf: aTimespanClass

	^ aTimespanClass includingDateAndTime: self! !
!Timespan methodsFor: 'double displatching' stamp: 'jmv 5/12/2017 17:17:18'!
                              includingTimespanOf: aTimespanClass

	^ aTimespanClass includingTimespan: self! !
!Timespan class methodsFor: 'instance creation' stamp: 'jmv 5/12/2017 16:48:47'!
                             includingDateAndTime: aDateAndTime

	^ self starting: aDateAndTime duration: Duration zero! !
!Timespan class methodsFor: 'instance creation' stamp: 'jmv 5/12/2017 17:22:59'!
                 includingTimespan: aDateAndTime

	| ending starting |
	starting _ self includingDateAndTime: aDateAndTime start.
	ending _ self includingDateAndTime: aDateAndTime end.
	starting = ending ifTrue: [ ^ starting ].
	self error: aDateAndTime printString, ' can not be included in a ', self name! !
!Date class methodsFor: 'instance creation' stamp: 'jmv 5/12/2017 16:48:52'!
              includingDateAndTime: aDateAndTime

	^self basicNew
 		start: aDateAndTime midnight;
		duration: (Duration days: 1);
		yourself! !
!Month class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 16:48:55'!
                 includingDateAndTime: aDateAndTime
	"Months start at day 1"
	| monthStart days |
	monthStart _ DateAndTime
				year: aDateAndTime yearNumber
				month: aDateAndTime monthIndex
				day: 1.
	days _ self daysInMonth: monthStart monthIndex forYear: monthStart yearNumber.
	^ self basicNew
 		start: monthStart;
		duration: (Duration days: days);
		yourself! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 18:05:57'!
                 includingDateAndTime: aDateAndTime
	"
	Week including: '12 May 2017 ' asDate start
	(Week including: '12 May 2017 ' asDate start) start dayOfWeekName = #Monday 
	"

	| midnight weekStart |
	midnight _ aDateAndTime midnight.
	weekStart _ midnight - (midnight dayOfWeek - 1) days.

	^ self basicNew
 		start: weekStart;
		duration: (Duration weeks: 1);
		yourself! !
!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 18:00:49'!
        includingDateAndTime: aDateAndTime
	"Answer a calendar year"

	^ self yearNumber: aDateAndTime yearNumber! !
!Timespan class methodsFor: 'instance creation' stamp: 'jmv 5/12/2017 17:18:23' prior: 16938217!
                  including: aDateAndTime

	^ aDateAndTime includingTimespanOf: self! !
!Year class methodsFor: 'squeak protocol' stamp: 'jmv 5/12/2017 17:43:17' prior: 16946731!
                               yearNumber: aYear

	| yearStart |
	yearStart _ DateAndTime year: aYear month: 1 day: 1.
	^ self basicNew
 		start: yearStart;
		duration: (Duration days: (self daysInYear: yearStart yearNumber));
		yourself! !

Year class removeSelector: #including:!

Year class removeSelector: #including:!

Week class removeSelector: #including:!

Week class removeSelector: #including:!

Month class removeSelector: #including:!

Month class removeSelector: #including:!

Date class removeSelector: #including:!

Date class removeSelector: #including:!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3079-TimespanCreation-includingTimespan-JuanVuletich-2017May13-13h02m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3079] on 13 May 2017 at 2:18:26 pm'!
!DateAndTime methodsFor: 'private' stamp: 'jmv 5/13/2017 10:58:22'!
        substractDateAndtime: operand
	"operand is a DateAndTime or a Duration"

	| lvalue rvalue |
	offset = operand offset
		ifTrue: [
			lvalue _ self.
			rvalue _ operand ]
		ifFalse: [
			lvalue _ self asUTC.
			rvalue _ operand asUTC ].
	^ Duration
		seconds: (Time secondsInDay *(lvalue julianDayNumber - rvalue julianDayNumber)) + 
					(lvalue secondsSinceMidnight - rvalue secondsSinceMidnight)
		nanoSeconds: lvalue nanoSecond - rvalue nanoSecond! !
!DateAndTime methodsFor: 'private' stamp: 'jmv 5/13/2017 10:58:31'!
                       substractDuration: operand
	"operand is a DateAndTime or a Duration"

	^self + operand negated! !
!DateAndTime methodsFor: 'double dispatching' stamp: 'jmv 5/13/2017 10:59:45'!
               substractFrom: aDateAndTime

	^ aDateAndTime substractDateAndtime: self! !
!Duration methodsFor: 'double dispatching' stamp: 'jmv 5/13/2017 11:03:50'!
         substractFrom: aDateAndTimeOrDate

	^aDateAndTimeOrDate substractDuration: self! !
!Timespan methodsFor: 'private' stamp: 'jmv 5/13/2017 11:09:07'!
            substractDuration: aDuration

	^self class classDefinesDuration
		ifTrue: [ self class including: start - aDuration ]
		ifFalse: [ self class starting: start - aDuration duration: duration ]! !
!Timespan methodsFor: 'private' stamp: 'jmv 5/13/2017 11:18:25'!
                             substractTimespan: aTimespan

	aTimespan duration = self duration ifFalse: [
		self error: 'Can not substract Timespans of different duration' ].
	
	^self start substractDateAndtime: aTimespan start! !
!Timespan methodsFor: 'double displatching' stamp: 'jmv 5/13/2017 11:08:17'!
         substractFrom: aTimespan

	^ aTimespan substractTimespan: self! !
!DateAndTime methodsFor: 'ansi protocol' stamp: 'jmv 5/13/2017 11:00:53' prior: 16828596!
    - operand
	"operand is a DateAndTime or a Duration.
	Double dispatch"

	^ operand substractFrom: self! !
!Timespan methodsFor: 'ansi protocol' stamp: 'jmv 5/13/2017 14:16:21' prior: 16937995!
- aDurationOrTimespan

	^ aDurationOrTimespan substractFrom: self! !
!Timespan methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 11:13:39' prior: 16938027!
  includes: operand
	"Operand might be a Timespan or a DateAndtime"

	^ (operand is: #Timespan)
			ifTrue: [ (self includes: operand start)
						and: [ self includes: operand end ] ]
			ifFalse: [ operand between: start and: self end ]! !
!Timespan class methodsFor: 'instance creation' stamp: 'jmv 5/13/2017 11:12:44' prior: 50342535!
                 includingTimespan: aTimespan

	| ending starting |
	starting _ self includingDateAndTime: aTimespan start.
	ending _ self includingDateAndTime: aTimespan end.
	starting = ending ifTrue: [ ^ starting ].
	self error: aTimespan printString, ' can not be included in a ', self name! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3080-TimespanLessTimespan-JuanVuletich-2017May13-14h12m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3080] on 13 May 2017 at 7:48:17 pm'!
!Week methodsFor: 'public protocol' stamp: 'jmv 5/13/2017 14:37:37'!
                        weekNumber

	| thursday |
	thursday _ self start + 3 days.
	^thursday dayOfYear-1 // 7 + 1! !
!Week methodsFor: 'public protocol' stamp: 'jmv 5/13/2017 14:37:18'!
                             yearNumber

	| thursday |
	thursday _ self start + 3 days.
	^thursday yearNumber! !
!Year methodsFor: 'public protocol' stamp: 'jmv 5/13/2017 14:51:58'!
       yearNumber

	^ start yearNumber! !
!Week methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 14:38:20' prior: 50342464!
        printOn: aStream
	"
		'2008-W52' asWeek.
		'2009-W01' asWeek
		'2009-W02' asWeek
		'2009-W53' asWeek
		'2010-W01' asWeek
		'2010-W02' asWeek
	"
	self yearNumber printOn: aStream.
	aStream nextPutAll: '-W'.
	self weekNumber printOn: aStream length: 2 zeroPadded: true! !
!Week class methodsFor: 'squeak protocol' stamp: 'jmv 5/13/2017 14:59:27' prior: 50342478!
                       indexOfDay: aSymbol
	"
	(Week indexOfDay: #Sunday) = 7
	(Week nameOfDay: 7) = #Sunday 
	"

	^ self dayNames indexOf: aSymbol! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3081-WeekYearTweaks-JuanVuletich-2017May13-19h46m-jmv.1.cs.st----!

Cursor webLink maskForm bits: (Form extent: 16@16 
			fromArray: (#(3072 7680 7680 7680 7680 8118 8191 32767 65535 65535 65535 65535 65535 32766 32766 16380 )  collect: [:bits | bits bitShift: 16])
			offset: 0@0) bits.
Smalltalk garbageCollect.!

Form allInstances!

----SNAPSHOT----#(14 May 2017 7:55:58.705571 pm) Cuis5.0-3081-spur-64.image priorSource: 336794!

----QUIT----#(14 May 2017 7:56:15.500912 pm) Cuis5.0-3081-spur-64.image priorSource: 355670!

----STARTUP----#(25 May 2017 9:59:53.730516 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3081-spur-64.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3081] on 16 May 2017 at 10:43:45 am'!
!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'jmv 5/16/2017 10:43:40' prior: 16896077!
     defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame oldFilledWidth oldFilledWidth2 prevContents |
	f _ AbstractFont default.
	h _ f height * 3//2.
	textWidth _ (f widthOfString: progressTitle) + h.
	width _ 150 max: textWidth.

	textForm _ Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame _ Rectangle center: aPoint extent: width@h.
	textFrame _ 0@0 extent: width@h.
	textFrame _ textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + (0@2).
	outerFrame _ barFrame merge: textFrame.
	delta _ outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame _ barFrame translatedBy: delta.
	textFrame _ textFrame translatedBy: delta.
	outerFrame _ outerFrame translatedBy: delta.
	prevContents _ Form fromDisplay: outerFrame.
	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame _ barFrame insetBy: 2.
	textForm displayAt: textFrame topLeft.
	Display fillBlack: barFrame.
	Display fillWhite: innerBarFrame.
	oldFilledWidth _ 0.
	oldFilledWidth2 _ 0.
	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal _ barVal ]
			ifNil: [
				currentVal _ currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal _ minVal ]].
		filledWidth _ ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		filledWidth  > oldFilledWidth ifTrue: [
			textForm displayAt: textFrame topLeft.
			Display fillBlack: barFrame.
			Display fillWhite: innerBarFrame.
			Display fillGray: (barFrame topLeft + (2@2) extent: filledWidth@17).
			filledWidth -200 > oldFilledWidth2
				ifFalse: [
					"Usually just request an update, to be done asynchronously."
					DisplayScreen screenUpdateRequired: outerFrame ]
				ifTrue: [
					"Once in a while, force a real screen update (warning: really slow on MacOS if done too often)"
					Display forceToScreen: outerFrame. oldFilledWidth2 _ filledWidth ].
			oldFilledWidth _ filledWidth ]].
	prevContents displayAt: outerFrame topLeft.
	self resume: result! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3082-displayProgressAt-slownessOnMacFix-JuanVuletich-2017May16-10h38m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3082] on 24 May 2017 at 12:34:49 am'!
!Collection methodsFor: 'sorting' stamp: 'jmv 5/24/2017 00:28:06'!
                           sorted
	"Return a new sequenceable collection which contains the same elements as self but its elements are sorted "

	^self sorted: nil! !
!ClassDescription methodsFor: 'instance variables' stamp: 'jmv 5/24/2017 00:29:04' prior: 16805949!
                chooseInstVarAlphabeticallyThenDo: aBlock
	| allVars index |
	"Put up a menu of all the instance variables in the receiver, presented in alphabetical order, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter."

	allVars _ self allInstVarNames sorted.
	allVars isEmpty ifTrue: [^ self inform: 'There are no
instance variables'].

	index _ (PopUpMenu labelArray: allVars lines: #()) startUpWithCaption: 'Instance variables in
', self name.
	index = 0 ifTrue: [^ self].
	aBlock value: (allVars at: index)! !
!ClassDescription methodsFor: 'method dictionary' stamp: 'jmv 5/24/2017 00:28:55' prior: 16807219!
                              allMethodsInCategory: aSymbol
	"Answer a list of all the method categories of the receiver and all its superclasses"

	| aColl |
	aColl _ OrderedCollection new.
	self withAllSuperclasses do:
		[:aClass | aColl addAll:
			(aSymbol == ClassOrganizer allCategory
				ifTrue:
					[aClass organization allMethodSelectors]
				ifFalse:
					[aClass organization listAtCategoryNamed: aSymbol])].
	^ aColl asSet sorted

"TileMorph allMethodsInCategory: #initialization"! !
!SystemDictionary methodsFor: 'browsing' stamp: 'jmv 5/24/2017 00:29:09' prior: 16924088!
                    browseClassesWithNamesContaining: aString caseSensitive: caseSensitive 
	"Smalltalk browseClassesWithNamesContaining: 'eMorph' caseSensitive: true "
	"Launch a class-list list browser on all classes whose names containg aString as a substring."

	| suffix aList |
	suffix _ caseSensitive
				ifTrue: [' (case-sensitive)']
				ifFalse: [' (use shift for case-sensitive)'].
	aList _ OrderedCollection new.
	Smalltalk allClassesDo: [ :class |
		(class name includesSubstring: aString caseSensitive: caseSensitive)
			ifTrue: [aList add: class name]].
	aList size > 0
		ifTrue: [HierarchyBrowserWindow forClassesNamed: aList asSet sorted title: 'Classes whose names contain ' , aString , suffix]! !
!ChangeSet methodsFor: 'method changes' stamp: 'jmv 5/24/2017 00:28:50' prior: 16797810!
                changedMessageList
	"Used by a message set browser to access the list view information."

	| messageList |
	messageList _ OrderedCollection new.
	changeRecords associationsDo: [ :clAssoc | | classNameInFull classNameInParts |
		classNameInFull _ clAssoc key asString.
		classNameInParts _ classNameInFull findTokens: ' '.

		(clAssoc value allChangeTypes includes: #comment) ifTrue: [
			messageList add:
				(MethodReference new
					setClassSymbol: classNameInParts first asSymbol
					classIsMeta: false 
					methodSymbol: #Comment 
					stringVersion: classNameInFull, ' Comment')].

		clAssoc value methodChangeTypes associationsDo: [ :mAssoc |
			(#(remove addedThenRemoved movedToOtherPackage) includes: mAssoc value) ifFalse: [
				messageList add:
					(MethodReference new
						setClassSymbol: classNameInParts first asSymbol
						classIsMeta: classNameInParts size > 1 
						methodSymbol: mAssoc key 
						stringVersion: classNameInFull, ' ' , mAssoc key)]]].
	^ messageList sorted! !

ArrayedCollection removeSelector: #asSortedArray!

ArrayedCollection removeSelector: #asSortedArray!

Collection removeSelector: #asSortedArray!

Collection removeSelector: #asSortedArray!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3083-remove-asSortedArray-JuanVuletich-2017May24-00h34m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3083] on 25 May 2017 at 8:17:34 pm'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 5/25/2017 20:10:06' prior: 16859018!
                            tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results
	0 tinyBenchmarks
		292 MHz G3 Mac: 				        			 22,727,272 bytecodes/sec; 			    984,169 sends/sec
		400 MHz PII/Win98:  			        			 18,028,169 bytecodes/sec; 			1,081,272 sends/sec

		RasPi2 - StackVM: 								 37,758,112 bytecodes/sec; 		       2,412,667 sends/sec
		Raspi2- CogSSpur: 							     157,441,574 bytecodes/sec; 		     10,946,039 sends/sec
		
		C.H.I.P. (*1) - StackVM: 							55,315,471 bytecodes/sec;  			3,348,667 sends/sec
		C.H.I.P. (*1) - CogSpur: 					 	    253,716,551 bytecodes/sec; 		    16,853,816 sends/sec

		1.66GHz Atom N450 - Cog: 					     244,274,809 bytecodes/sec; 		    28,795,277 sends/sec
		1.66GHz Atom N450 - CogSpur: 			     469,724,770 bytecodes/sec; 		    30,754,699 sends/sec

		1.33GHz Atom 3735G - Cog: 				     326,114,649 bytecodes/sec; 		    34,985,976 sends/sec
		1.33GHz Atom 3735G - CogSpur: 			     632,098,765 bytecodes/sec; 		    33,692,910 sends/sec

		1.5GHz AMD A4-5000 APU - Cog: 			    390,243,902 bytecodes/sec; 		    47,507,997 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur: 		    675,907,590 bytecodes/sec; 		    40,669,724 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur64:	    659,368,963 bytecodes/sec; 		    50,338,916 sends/sec

		2.3GHz Tegra (*2) - StackVM: 				    258,847,320 bytecodes/sec; 		    13,014,759 sends/sec	
		2.3GHz Tegra (*2) - CogSpur: 				1,083,024,854 bytecodes/sec; 		    64,289,750 sends/sec

		3.1GHz Core i3-2100 - Cog:  				1,203,290,246 bytecodes/sec; 		165,723,327 sends/sec
		3.1GHz Core i3-2100 - CogSpur:  			2,042,892,768 bytecodes/sec; 		127,837,794 sends/sec

		(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
		(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
		
	It is interesting to note that Spur for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance.
	"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue:[n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue:[n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^ ((n1 * 500000 * 1000) // t1) printStringWithCommas, ' bytecodes/sec; ',
	  ((r * 1000) // t2) printStringWithCommas, ' sends/sec'! !
!SystemDictionary methodsFor: 'system attributes' stamp: 'jmv 5/14/2017 23:20:19' prior: 16925038!
     isRunningCogit
	"Returns true if we're running on the Cog JIT
	 (vmParameterAt: 46 is the size of the machine code zone)
	Smalltalk isRunningCogit
	"

	^(self vmParameterAt: 46)
		ifNotNil: [ :machineCodeZoneSize  | machineCodeZoneSize > 0 ]
		ifNil: [ false ]! !
!SystemDictionary methodsFor: 'system attributes' stamp: 'jmv 5/14/2017 23:20:40' prior: 16925049!
                     isSpur
	"Answer true if we are a Spur ObjectMemory.
	Spur introduces a new format of header for objects, new format for classes, etc.
	Smalltalk isSpur
	"

	^ self compactClassesArray isNil! !
!SystemDictionary class methodsFor: 'copyright' stamp: 'jmv 5/14/2017 23:13:07' prior: 16925610!
                              copyright
	"The Cuis Smalltalk copyright.
	Parts are copyright of many contributors to Squeak and Cuis projects."

	^
'Portions of Cuis are:
Copyright (c) Xerox Corp. 1981, 1982.
Copyright (c) Apple Computer, Inc. 1985-1996.
Copyright (c) Contributors to Squeak and Cuis projects. 1997-2017.'! !

Utilities class removeSelector: #compileUsingClosures!

Utilities class removeSelector: #compileUsingClosures!

Utilities class removeSelector: #decommissionTheAllCategory!

Utilities class removeSelector: #decommissionTheAllCategory!

Utilities class removeSelector: #initializeClosures!

Utilities class removeSelector: #initializeClosures!

SystemVersion class removeSelector: #currentPluginVersion!

SystemVersion class removeSelector: #currentPluginVersion!

SystemVersion class removeSelector: #parseVersionString:!

SystemVersion class removeSelector: #parseVersionString:!

SystemVersion class removeSelector: #pluginVersion:newerThan:!

SystemVersion class removeSelector: #pluginVersion:newerThan:!

SystemDictionary removeSelector: #fixSourceCodeLineEndings!

SystemDictionary removeSelector: #fixSourceCodeLineEndings!

SystemDictionary removeSelector: #makeInternalRelease!

SystemDictionary removeSelector: #makeInternalRelease!

SystemDictionary removeSelector: #removeTextCode!

SystemDictionary removeSelector: #removeTextCode!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3084-Cleanup-JuanVuletich-2017May25-20h08m-jmv.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3083] on 25 May 2017 at 8:23:29 pm'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3085-Cleanup-JuanVuletich-2017May25-20h17m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3085] on 25 May 2017 at 9:56:27 pm'!
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 5/25/2017 21:56:04' prior: 50334158!
     saveAsNewVersion
	"Save the image/changes using the next available version number."
	"
	Smalltalk saveAsNewVersion
	"
	| fileName newName changesName systemVersion |
	self okayToSave ifFalse: [ ^ self ].
	systemVersion _ SystemVersion current.
	fileName _ String streamContents: [ :strm |
		strm
			nextPutAll: 'Cuis';
			print: systemVersion versionMajor;
			nextPut: $.;
			print: systemVersion versionMinor;
			nextPut: $-;
			print: systemVersion highestUpdate.
		Smalltalk isSpur
			ifTrue: [	
				Smalltalk wordSize = 4 ifTrue: [
					strm nextPutAll: '-32' ]]
			ifFalse: [
				strm nextPutAll: '-v3' ]].
	newName _ fileName, '.image'.
	(DirectoryEntry smalltalkImageDirectory // newName) exists ifTrue: [
		newName _ DirectoryEntry smalltalkImageDirectory
			nextNameFor: fileName
			extension: 'image' ].
	changesName _ self fullNameForChangesNamed: newName.
	"Check to see if there is a .changes file that would cause a problem if we saved a new .image file with the new version number"
	changesName asFileEntry exists ifTrue: [
		^ self inform:
'There is already .changes file of the desired name,
', newName, '
curiously already present, even though there is
no corresponding .image file.   Please remedy
manually and then repeat your request.' ].
	"Try to clear all user state, including all class vars, preferences, etc"
	self saveAs: newName andQuit: false clearAllClassState: true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3086-NewImageFlavorNaming-JuanVuletich-2017May25-21h56m-jmv.1.cs.st----!

----SNAPSHOT----#(25 May 2017 10:00:04.671955 pm) Cuis5.0-3086.image priorSource: 355768!

----QUIT----#(25 May 2017 10:00:19.215065 pm) Cuis5.0-3086.image priorSource: 369480!

----STARTUP----#(14 June 2017 3:33:55.592953 pm) as /home/juan/Rectifier/Cuis-Smalltalk-Dev/Cuis5.0-3086.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3086] on 29 May 2017 at 10:56:45 pm'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 5/29/2017 22:55:50' prior: 50342981!
      tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results
	0 tinyBenchmarks
		292 MHz G3 Mac: 				        			 22,727,272 bytecodes/sec; 			    984,169 sends/sec
		400 MHz PII/Win98:  			        			 18,028,169 bytecodes/sec; 			1,081,272 sends/sec

		RasPi2 - StackVM: 								 37,758,112 bytecodes/sec; 		       2,412,667 sends/sec
		RasPi2- CogSSpur: 							     157,441,574 bytecodes/sec; 		     10,946,039 sends/sec
		
		C.H.I.P. (*1) - StackVM: 							55,315,471 bytecodes/sec;  			3,348,667 sends/sec
		C.H.I.P. (*1) - CogSpur: 					 	    253,716,551 bytecodes/sec; 		    16,853,816 sends/sec
		
		RasPi3B - StackSpur 								44,107,512 bytecodes/sec; 			2,767,863 sends/sec
		RasPi3B - CogSpur 							    281,783,159 bytecodes/sec; 		    16,404,381 sends/sec

		1.66GHz Atom N450 - Cog: 					     244,274,809 bytecodes/sec; 		    28,795,277 sends/sec
		1.66GHz Atom N450 - CogSpur: 			     469,724,770 bytecodes/sec; 		    30,754,699 sends/sec

		1.33GHz Atom 3735G - Cog: 				     326,114,649 bytecodes/sec; 		    34,985,976 sends/sec
		1.33GHz Atom 3735G - CogSpur: 			     632,098,765 bytecodes/sec; 		    33,692,910 sends/sec

		1.5GHz AMD A4-5000 APU - Cog: 			    390,243,902 bytecodes/sec; 		    47,507,997 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur: 		    675,907,590 bytecodes/sec; 		    40,669,724 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur64:	    659,368,963 bytecodes/sec; 		    50,338,916 sends/sec

		2.3GHz Tegra (*2) - StackVM: 				    258,847,320 bytecodes/sec; 		    13,014,759 sends/sec	
		2.3GHz Tegra (*2) - CogSpur: 				1,083,024,854 bytecodes/sec; 		    64,289,750 sends/sec

		3.1GHz Core i3-2100 - Cog:  				1,203,290,246 bytecodes/sec; 		165,723,327 sends/sec
		3.1GHz Core i3-2100 - CogSpur:  			2,042,892,768 bytecodes/sec; 		127,837,794 sends/sec

		(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
		(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
		
	It is interesting to note that Spur for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance.
	"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue:[n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue:[n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^ ((n1 * 500000 * 1000) // t1) printStringWithCommas, ' bytecodes/sec; ',
	  ((r * 1000) // t2) printStringWithCommas, ' sends/sec'! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3087-RasPi3-tinyBenchmarks-JuanVuletich-2017May29-22h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3087] on 30 May 2017 at 2:27:08 pm'!
!Integer methodsFor: 'benchmarks' stamp: 'jmv 5/30/2017 14:24:33' prior: 50343209!
    tinyBenchmarks
	"Report the results of running the two tiny Squeak benchmarks.
	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results
	0 tinyBenchmarks
		292 MHz G3 Mac: 				        			 22,727,272 bytecodes/sec; 			    984,169 sends/sec
		400 MHz PII/Win98:  			        			 18,028,169 bytecodes/sec; 			1,081,272 sends/sec

		RasPi2 - StackVM: 								 37,758,112 bytecodes/sec; 		       2,412,667 sends/sec
		RasPi2- CogSSpur: 							     157,441,574 bytecodes/sec; 		     10,946,039 sends/sec
		
		C.H.I.P. (*1) - StackVM: 							55,315,471 bytecodes/sec;  			3,348,667 sends/sec
		C.H.I.P. (*1) - CogSpur: 					 	    253,716,551 bytecodes/sec; 		    16,853,816 sends/sec
		
		RasPi3B - StackSpur 								44,107,512 bytecodes/sec; 			2,767,863 sends/sec
		RasPi3B - CogSpur 							    281,783,159 bytecodes/sec; 		    16,404,381 sends/sec

		1.66GHz Atom N450 - Cog: 					     244,274,809 bytecodes/sec; 		    28,795,277 sends/sec
		1.66GHz Atom N450 - CogSpur: 			     469,724,770 bytecodes/sec; 		    30,754,699 sends/sec

		1.33GHz Atom 3735G - Cog: 				     326,114,649 bytecodes/sec; 		    34,985,976 sends/sec
		1.33GHz Atom 3735G - CogSpur: 			     632,098,765 bytecodes/sec; 		    33,692,910 sends/sec

		1.5GHz AMD A4-5000 APU - Cog: 			    390,243,902 bytecodes/sec; 		    47,507,997 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur: 		    675,907,590 bytecodes/sec; 		    40,669,724 sends/sec
		1.5GHz AMD A4-5000 APU - CogSpur64:	    659,368,963 bytecodes/sec; 		    50,338,916 sends/sec

		2.3GHz Tegra (*2) - StackVM: 				    258,847,320 bytecodes/sec; 		    13,014,759 sends/sec	
		2.3GHz Tegra (*2) - CogSpur: 				1,083,024,854 bytecodes/sec; 		    64,289,750 sends/sec

		3.1GHz Core i3-2100 - Cog:  				1,203,290,246 bytecodes/sec; 		165,723,327 sends/sec
		3.1GHz Core i3-2100 - CogSpur:  			2,042,892,768 bytecodes/sec; 		127,837,794 sends/sec

		2.70GHz Core i5-6400 -CogSpur64 		3,162,934,362 bytecodes/sec; 		243,321,293 sends/sec
	
		(*1) C.H.I.P. $9 Computer [Next Thing Co], Allwinner R8 Single-Core ARM Cortex-A8 - 1 GHz
		(*2) ACER Chromebook CB5-311 - NVIDIA Tegra K1 Quad-Core ARM Cortex-A15 'r3'  - 2.3 GHz
		
	It is interesting to note that Spur for the first time brings ARM hardware (RasPi and C.H.I.P.) into a 'Morphic is confortable and nice to use' level of performance.
	"
	| t1 t2 r n1 n2 |
	n1 _ 1.
	[
		t1 _ Time millisecondsToRun: [n1 benchmark].
		t1 < 1000] 
			whileTrue:[n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"

	n2 _ 28.
	[
		t2 _ Time millisecondsToRun: [r _ n2 benchFib].
		t2 < 1000] 
			whileTrue:[n2 _ n2 + 1]. 
	"Note: #benchFib's runtime is about O(k^n),
		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."

	^ ((n1 * 500000 * 1000) // t1) printStringWithCommas, ' bytecodes/sec; ',
	  ((r * 1000) // t2) printStringWithCommas, ' sends/sec'! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3088-CoreI5-tinyBenchmarks-JuanVuletich-2017May30-14h24m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3088] on 31 May 2017 at 10:25:43 am'!
!WordArray methodsFor: 'accessing' stamp: 'jmv 5/31/2017 09:48:37'!
                       bytesAt: index
	"Answer a ByteArray of 4 elements.
	The 32-bit word is split in 4 bytes, in little endian format
	WordArray with: 16rFF32791B :: bytesAt: 1 :: hex
	"

	| bytes word |
	bytes _ ByteArray new: 4.
	word _ self at: index. "Usually a SmallInteger, but may be a Large Integer in 32-bit images"
	1 to: 4 do: [ :i | bytes at: i put: (word digitAt: i) ].
	^ bytes! !
!WordArray methodsFor: 'accessing' stamp: 'jmv 5/31/2017 09:53:07'!
      bytesAt: index put: aByteArray
	"Takes a ByteArray of 4 elements.
	Store the 32-bit word made with those byes, in little endian format
	WordArray new: 1 :: bytesAt: 1 put: #[16r1B 16r79 16r32 16rFF] :: first hex
	"

	| word |
	word _ 0.
	4 to: 1 by: -1 do: [ :i | word _ word * 256 + (aByteArray at: i) ].
	self at: index put: word! !
!Bitmap methodsFor: 'accessing' stamp: 'jmv 5/31/2017 10:16:34'!
                bytesAt: index
	"Answer a ByteArray of 4 elements.
	The 32-bit word is split in 4 bytes, in little endian format
	WordArray with: 16rFF32791B :: bytesAt: 1 :: hex
	"

	| bytes word |
	bytes _ ByteArray new: 4.
	word _ self at: index. "Usually a SmallInteger, but may be a Large Integer in 32-bit images"
	1 to: 4 do: [ :i | bytes at: i put: (word digitAt: i) ].
	^ bytes! !
!Bitmap methodsFor: 'accessing' stamp: 'jmv 5/31/2017 10:16:38'!
         bytesAt: index put: aByteArray
	"Takes a ByteArray of 4 elements.
	Store the 32-bit word made with those byes, in little endian format
	WordArray new: 1 :: bytesAt: 1 put: #[16r1B 16r79 16r32 16rFF] :: first hex
	"

	| word |
	word _ 0.
	4 to: 1 by: -1 do: [ :i | word _ word * 256 + (aByteArray at: i) ].
	self at: index put: word! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3089-BytesAccessForBitmapAndWordArray-JuanVuletich-2017May31-10h25m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3083] on 28 May 2017 at 8:07:38 pm'!
!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:01:43'!
                           setUpResources
			
	self resources do: [:res | res isAvailable ifFalse: [^res signalInitializationError]].
! !
!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:02:07'!
                tearDownResources
	
	self resources do: [:each | each reset]! !
!TestCase methodsFor: 'Private' stamp: 'HAW 5/28/2017 20:03:22'!
                               runCaseAsFailure

	self setUpResources.
	self setUp.
	
	self openDebuggerOnFailingTestMethod! !
!TestSuite methodsFor: 'Running - Private' stamp: 'HAW 5/28/2017 20:04:46'!
                    setUpResources
			
	self resources do: [ :res | res isAvailable ifFalse: [^res signalInitializationError]].
	! !
!TestSuite methodsFor: 'Running - Private' stamp: 'HAW 5/28/2017 20:05:08'!
   tearDownResources
			
	self resources do: [:each | each reset]! !
!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:01:57' prior: 16927482!
             debug

	self setUpResources.
	
	[(self class selector: testSelector) runCase] ensure: [self tearDownResources]
			! !
!TestCase methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:06:48' prior: 50340541!
                         debugAsFailureIfCanNot: handler
	
	self ifCanNotDebugDo: [ ^handler value].
	
	(self class selector: testSelector) runCaseAsFailure! !
!TestCase methodsFor: 'Private' stamp: 'HAW 5/28/2017 16:11:59' prior: 16927577!
        executeShould: aBlock inScopeOf: anExceptonHandlingCondition 
	
	^self executeShould: aBlock inScopeOf: anExceptonHandlingCondition withExceptionDo: [:anException | ]
! !
!TestCase methodsFor: 'Private' stamp: 'HAW 5/28/2017 16:12:11' prior: 50339015!
    executeShould: aBlock inScopeOf: anExceptonHandlingCondition withExceptionDo: assertionsBlock

	^[aBlock value.
 	false] 
		on: anExceptonHandlingCondition
		do: [:exception | 
			assertionsBlock value: exception.
			exception sunitExitWith: true]! !
!TestCase methodsFor: 'Private' stamp: 'HAW 5/28/2017 20:03:03' prior: 50341196!
                    openDebuggerOnFailingTestMethod

	| processToDebug context compiledMethod debugger |

	compiledMethod _ self methodForTest.
	
	processToDebug _ [ [ self performTest ] ensure: [
		self tearDown.
		self tearDownResources]] newProcess.
	context _ processToDebug suspendedContext.
	
	debugger _ Debugger new
		process: processToDebug 
		context: context.
	debugger openFullNoSuspendLabel: 'Debug failed test ', self printString.

	[debugger interruptedContext method == compiledMethod] whileFalse: [debugger send].
! !
!TestSuite methodsFor: 'Running' stamp: 'HAW 5/28/2017 20:04:59' prior: 16928869!
           run

	| result |
 
	result := TestResult new.
	self setUpResources.	
	[self run: result] ensure: [self tearDownResources].
	
	^result
			! !

TestCase removeSelector: #openDebuggerOnFailingTestMethod2!

TestCase removeSelector: #openDebuggerOnFailingTestMethod:!

TestCase removeSelector: #openDebuggerOnFailingTestMethod:!

TestCase removeSelector: #runCaseAsFailure:!

TestCase removeSelector: #runCaseAsFailure:!

Smalltalk removeClassNamed: #TestCaseDebugger!

Smalltalk removeClassNamed: #TestCaseDebugger!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3090-SUnitDebugFix-HernanWilkinson-2017May23-19h28m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3083] on 28 May 2017 at 8:55:15 pm'!

MessageNode removeSelector: #test!

MessageNode removeSelector: #test!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3091-MessageNode-test-removal-HernanWilkinson-2017May28-20h54m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3083] on 28 May 2017 at 8:56:52 pm'!
!SetInspector methodsFor: 'accessing' stamp: 'HAW 5/28/2017 20:56:40' prior: 16907433!
            fieldList
	
	(object isNil or: [ object array isNil]) ifTrue: [^ Set new].
	
	^ self baseFieldList, (object array withIndexCollect: [:each :i | each ifNotNil: [i printString]]) select: [:each | each notNil]! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3092-SetInspectorFix-HernanWilkinson-2017May28-20h55m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3092] on 2 June 2017 at 11:21:59 am'!
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:01:27'!
    defaultFailDescription

	^'Test failed'! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:02:09'!
                   fail

	^self failWith: self defaultFailDescription ! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:02:55'!
       failWith: aDescription

	self signalFailure: aDescription ! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:57:13'!
should: aBlock raise: anExceptonHandlingCondition withExceptionDo: assertionsBlock description: aFailDescription

	^[aBlock value.
 	self failWith: aFailDescription ] 
		on: anExceptonHandlingCondition
		do: assertionsBlock ! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:58:09' prior: 16927436!
          should: aBlock

	self assert: aBlock value
			! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:58:16' prior: 16927439!
                            should: aBlock description: aString

	self assert: aBlock value description: aString
			! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:54:56' prior: 16927443!
                  should: aBlock raise: anExceptonHandlingCondition 

	^self should: aBlock raise: anExceptonHandlingCondition withExceptionDo: [ :anException | ]
			! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:00:17' prior: 16927448!
                      should: aBlock raise: anExceptonHandlingCondition description: aFailDescription

	^self should: aBlock raise: anExceptonHandlingCondition withExceptionDo: [:anException | ] description: aFailDescription! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 10:57:59' prior: 50339007!
should: aBlock raise: anExceptonHandlingCondition withExceptionDo: assertionsBlock

	^self should: aBlock raise: anExceptonHandlingCondition withExceptionDo: assertionsBlock description: self defaultFailDescription! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:09:25' prior: 16927455!
                    shouldnt: aBlock

	self deny: aBlock value
			! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:09:20' prior: 16927458!
                            shouldnt: aBlock description: aString

	self deny: aBlock value description: aString
			! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:10:31' prior: 16927462!
                  shouldnt: aBlock raise: anExceptonHandlingCondition 

	^self shouldnt: aBlock raise: anExceptonHandlingCondition description: anExceptonHandlingCondition printString, ' was not expected to be raised'! !
!TestCase methodsFor: 'Accessing' stamp: 'HAW 6/2/2017 11:06:04' prior: 16927468!
   shouldnt: aBlock raise: anExceptonHandlingCondition description: aFailDescription

	^aBlock 
		on: anExceptonHandlingCondition 
		do: [ :anException | self failWith: aFailDescription ]
! !

TestCase removeSelector: #executeShould:inScopeOf:!

TestCase removeSelector: #executeShould:inScopeOf:!

TestCase removeSelector: #executeShould:inScopeOf:withExceptionDo:!

TestCase removeSelector: #executeShould:inScopeOf:withExceptionDo:!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3093-TestsDebuggingImprovements-HernanWilkinson-2017Jun02-10h25m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3092] on 2 June 2017 at 4:06:08 pm'!
!Behavior methodsFor: 'user interface' stamp: 'HAW 6/2/2017 16:05:24'!
                      addTo: aSet referencesTo: aSymbol special: special byte: byte.
	
	self withAllSuperAndSubclassesDoGently: [ :class |
		(class whichSelectorsReferTo: aSymbol special: special byte: byte)
			do: [ :sel | aSet add: (MethodReference class: class selector: sel) ]].
	! !
!Behavior methodsFor: 'user interface' stamp: 'HAW 6/2/2017 16:05:35' prior: 16784612!
                               allLocalCallsOn: aSymbol
	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."

	| aSet special byte cls |
	
	aSet _ Set new.
	cls _ self theNonMetaClass.
	special _ Smalltalk 
		hasSpecialSelector: aSymbol
		ifTrueSetByte: [ :b | byte _ b ].
	
	cls addTo: aSet referencesTo: aSymbol special: special byte: byte.
	cls class addTo: aSet referencesTo: aSymbol special: special byte: byte.
	
	^aSet! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3094-LocalCallsFix-HernanWilkinson-2017Jun02-11h21m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3095] on 7 June 2017 at 10:50:30 am'!
!MessageSetWindow class methodsFor: 'instance creation' stamp: 'jmv 6/7/2017 10:49:13' prior: 16870573!
                   openMessageList: anArray label: aString
	"Create a standard system view for the message set on the list, anArray. 
	The label of the view is aString."

	^self open: (MessageSet messageList: anArray) label: aString! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3095-openMessageListlabel-fix-JuanVuletich-2017Jun07-10h47m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3094] on 3 June 2017 at 8:52:25 pm'!

MessageSetWindow subclass: #TestResultWindow
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!

!classDefinition: #TestResultWindow category: #'Tools-Testing'!
MessageSetWindow subclass: #TestResultWindow
	instanceVariableNames: 'testResult'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tools-Testing'!
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 6/3/2017 20:40:29'!
      openTestResultWindow

	TestResultWindow openFor: testResult 
	! !
!TestCase methodsFor: 'Testing' stamp: 'HAW 6/3/2017 20:26:43'!
                              isSameAs: aTestCase

	^self class = aTestCase class and: [ testSelector = aTestCase selector ]! !
!TestResult methodsFor: 'Accessing' stamp: 'HAW 6/3/2017 20:27:28'!
                          removeFromDefectsAndAddToPassed: aPassed 

	errors 
		detect: [ :anError | anError isSameAs: aPassed ]
		ifFound: [ :anError | errors remove: anError ]
		ifNone: [ 
			failures 
				detect: [ :aFail | aFail isSameAs: aPassed ]
				ifFound: [ :aFail | failures remove: aFail ]
				ifNone: [ self error: aPassed printString, ' is not an error nor a failure' ]].
	passed add: aPassed
! !
!TestResultWindow methodsFor: 'actions' stamp: 'HAW 6/3/2017 20:51:08'!
                       debug

	model selection ifNotNil: [ :selection | | test |
		test := selection actualClass selector: selection selector.
		test debug.
		testResult removeFromDefectsAndAddToPassed: test.
		model removeMessageFromBrowserKeepingLabel. 
		self setLabel: testResult printString ]! !
!TestResultWindow methodsFor: 'actions' stamp: 'HAW 6/3/2017 20:51:12'!
  runSuite

	| suite |
	 
	suite := TestSuite new.
	suite addTests: testResult tests.
	self delete.
	(ProgessiveTestRunner for: suite) value.
	! !
!TestResultWindow methodsFor: 'button creation' stamp: 'HAW 6/3/2017 20:51:16'!
                               createDebugButton

	^PluggableButtonMorph 
		model: self
		stateGetter: #isMessageSelected
		action: #debug
		label: 'Debug'.
! !
!TestResultWindow methodsFor: 'button creation' stamp: 'HAW 6/3/2017 20:51:20'!
              createReRunButton

	^PluggableButtonMorph 
		model: self
		stateGetter: nil
		action: #runSuite
		label: 'Run Suite'.
! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:24'!
                         addButton: button to: row color: buttonColor

	button color: buttonColor.
	row addMorph: button proportionalWidth: 10! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:28'!
                          addButtonsTo: row color: buttonColor

	self addButton: self createDebugButton to: row color: buttonColor.
	self addButton: self createReRunButton to: row color: buttonColor.
	! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:32'!
buildLowerPanes

	| codeAndButtons  |

	codeAndButtons _ LayoutMorph newColumn.
	codeAndButtons
		addMorph: self buttonsRow fixedHeight: self defaultButtonPaneHeight;
		addAdjusterMorph;
		addMorph: self buildMorphicCodePane proportionalHeight: 1.0.
	
	^codeAndButtons ! !
!TestResultWindow methodsFor: 'GUI building' stamp: 'HAW 6/3/2017 20:51:36'!
  buttonsRow

	| buttonColor row |

	buttonColor := self buttonColor.
	row := LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: buttonColor.

	self addButtonsTo: row color: buttonColor.
	
	^row
	
	! !
!TestResultWindow methodsFor: 'initialization' stamp: 'HAW 6/3/2017 20:51:40'!
  initializeFor: aTestResult 

	testResult := aTestResult ! !
!TestResultWindow methodsFor: 'testing' stamp: 'HAW 6/3/2017 20:51:46'!
                            isMessageSelected

	^model selection notNil ! !
!TestResultWindow class methodsFor: 'instance creation' stamp: 'HAW 6/3/2017 20:50:29'!
                        methodReferencesOf: tests

	^tests collect: [:aTest | MethodReference class: aTest class selector: aTest selector].
! !
!TestResultWindow class methodsFor: 'instance creation' stamp: 'HAW 6/3/2017 20:50:25'!
                openFor: aTestResult

	| window |

	window := self openMessageList: (self methodReferencesOf: aTestResult defects) label: aTestResult printString.
	window initializeFor: aTestResult.
	
	^window 

! !
!ProgessiveTestRunner methodsFor: 'show result - private' stamp: 'HAW 6/3/2017 20:40:17' prior: 50338186!
              showDeffects
	
	 | defects |
			
	defects _ 	testResult defects.
	defects size = 1
		ifTrue: [ defects anyOne debug ] 
		ifFalse: [ self openTestResultWindow]! !

TestResult removeSelector: #forDebuggingAndInspection!

TestResult removeSelector: #forDebuggingAndInspection!

TestCase removeSelectorIfInBaseSystem: #should:raise:withMessageText:!

ProgessiveTestRunner removeSelector: #openTestResultForDebuggingAndInspection!

ProgessiveTestRunner removeSelector: #openTestResultForDebuggingAndInspection!

Smalltalk removeClassNamed: #TestResultForDebuggingAndInspection!

Smalltalk removeClassNamed: #TestResultForDebuggingAndInspection!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3096-TestResultWindow-HernanWilkinson-2017May28-21h03m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3094] on 3 June 2017 at 8:55:22 pm'!
!StringMorph methodsFor: 'drawing' stamp: 'HAW 6/3/2017 20:55:08' prior: 16918187!
     drawOn: aCanvas
	aCanvas
		drawString: (contents ifNil: [ '' ])
		at: 0@0
		font: self fontToUse
		color: color
		! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3097-StringMorph-fix-HernanWilkinson-2017Jun03-20h52m-HAW.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3092] on 5 June 2017 at 12:39:46 am'!
!TheWorldMenu methodsFor: 'commands' stamp: 'pb 6/5/2017 00:35:30' prior: 16934691!
              splitNewMorphList: list depth: d
	| middle c prev next out |
	d <= 0 ifTrue: [ ^ Array with: list ].
	middle := list size // 2 + 1.
	c := (list at: middle) name first: 3.
	prev := middle - 1.
	[
	prev > 0 and: [ ((list at: prev) name first: 3) = c ]] whileTrue: [ prev := prev - 1 ].
	next := middle + 1.
	[
	next <= list size and: [ ((list at: next) name first: 3) = c ]] whileTrue: [ next := next + 1 ].
	"Choose the better cluster"
	middle := middle - prev < (next - middle)
		ifTrue: [ prev + 1 ]
		ifFalse: [ next ].
	middle = 1 ifTrue: [ middle := next ].
	middle >= list size ifTrue: [ middle := prev + 1 ].
	(middle = 1 or: [ middle >= list size ]) ifTrue: [ ^ Array with: list ].
	out := WriteStream on: Array new.
	out nextPutAll:
		(self
			splitNewMorphList:
				(list
					copyFrom: 1
					to: middle - 1)
			depth: d - 1).
	out nextPutAll:
		(self
			splitNewMorphList:
				(list
					copyFrom: middle
					to: list size)
			depth: d - 1).
	^ out contents.! !
!TheWorldMenu methodsFor: 'construction' stamp: 'pb 6/5/2017 00:38:53' prior: 16934754!
                          alphabeticalMorphMenu
	| list splitLists menu firstChar lastChar subMenu |
	list := Morph withAllSubclasses select: [ :m |
		m includeInNewMorphMenu ].
	list := list asArray sort: [ :c1 :c2 |
		c1 name < c2 name ].
	splitLists := self
		splitNewMorphList: list
		depth: 4.
	menu := MenuMorph new defaultTarget: self.
	1
		to: splitLists size
		do: [ :i |
			firstChar := i = 1
				ifTrue: [ $A ]
				ifFalse: [ 
					(splitLists at: i) first name first: 3 ].
			lastChar := i = splitLists size
				ifTrue: [ $Z ]
				ifFalse: [ 
					(splitLists at: i) last name first: 3 ].
			subMenu := MenuMorph new.
			(splitLists at: i) do: [ :cl |
				subMenu
					add: cl name
					target: self
					selector: #newMorphOfClass:event:
					argument: cl ].
			menu
				add: firstChar asString , ' - ' , lastChar asString
				subMenu: subMenu ].
	^ menu.! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3098-MoreGranularAlphaMorphMenu-PhilBellalouna-2017Jun05-00h35m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3086] on 5 June 2017 at 11:53:55 am'!
!CodeProvider methodsFor: 'message list menu' stamp: 'jmv 6/5/2017 11:51:33'!
                   exploreCompiledMethod
	"Open an Explorer on the CompiledMethod itself"

	self selectedMessageName ifNotNil: [
		(self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName)
			explore ]! !
!BrowserWindow methodsFor: 'menu building' stamp: 'jmv 6/5/2017 11:46:27' prior: 50338736!
                          messageListMenu
	"Answer the message-list menu"
	"Changed by emm to include menu-item for breakpoints"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addList:#(
			('what to show...'					offerWhatToShowMenu)
                	('toggle break on entry'		toggleBreakOnEntry						''		model)
            	-
			('browse full (b)' 					browseMethodFull)
			('browse hierarchy (h)'			browseHierarchy)
			('browse method (O)'			openSingleMessageBrowser)
			('browse protocol (p)'			browseFullProtocol)
			-
			('fileOut'							fileOutMessage							''		model)
			('explore CompiledMethod'		exploreCompiledMethod				''		model)
			-
			('senders of... (n)'				browseSendersOfMessages)
			('implementors of... (m)'		browseMessages)
			('inheritance (i)'					methodHierarchy)
			('versions (v)'						browseVersions)
			-
			('inst var refs...'					browseInstVarRefs)
			('inst var defs...'					browseInstVarDefs)
			('class var refs...'				browseClassVarRefs)
			('class variables'					browseClassVariables)
			('class refs (N)'					browseClassRefs)
			-
			('remove method (x)'			removeMessage							''		model)
			('Run test (t)'						runMethodTest 							'' 	model)
			('Debug test (r)'					debugMethodTest 						'' 	model)
			-
			('more...'							openShiftedMessageListMenu)).
	^ aMenu
! !
!Theme methodsFor: 'menus' stamp: 'jmv 6/5/2017 11:46:34' prior: 16935967!
      basicIcons

	"Minimal menu scheme.
	Theme current class beCurrent
	"

	^ { 
		#('open...') -> #openIcon.
		#('windows...' 'find window' 'Focus follows mouse' 'Click to focus') -> #windowIcon.
		#('help...' 'explain' 'about this system...' 'Terse Guide to Cuis' 'Class Comment Browser' 'Code management in Cuis' 'Using GitHub to host Cuis packages' ) -> #helpIcon.
		#('themes...') -> #appearanceIcon.
		#('do it (d)') -> #doItIcon.
		#('new morph...' 'objects (o)' 'save world as morph file') -> #morphsIcon.
		#('save' ) -> #saveIcon.
		#('Save options...' 'save as...' 'change category...' 'rename change set (r)' 'rename') -> #saveAsIcon.
		#('save as new version') -> #saveAsNewVersionIcon.
		#('quit') -> #quitIcon.
		#('save and quit' ) -> #saveAndQuitIcon.
		#('inspect it (i)' 'inspect world'  'inspect model' 'inspect morph'
		 'inspect owner chain' 'inspect' 'inspect (i)' 'basic inspect' 'message names' 'find message names' 'inspect instances' 'inspect subinstances' 'inspect change set' 'inspect context (c)' 'inspect receiver (i)' 'start CPUWatcher' 'stop CPUWatcher')
			-> #inspectIcon.
		#('explore' 'explore it (I)' 'explore world' 'explore morph' 'explore (I)' 'explore context (C)' 'explore receiver (I)' 'references finder' 'weight explorer' 'explore CompiledMethod') -> #exploreIcon.
		#('find...(f)' 'find class... (f)' 'find method...' 'find recent submissions' 'show hierarchy' 'show definition' 'show comment' 'filter' 'filter message list...' 'find context... (f)') -> #findIcon.
		#('add item...' 'new category...' 'create new change set...' 'new change set... (n)' 'add new file') -> #newIcon.
		#('remove method (x)' 'remove' 'remove class (x)' 'remove method from system (x)' 'remove class from system (x)' 'remove postscript') -> #deleteIcon.
		#('delete method from changeset (d)' 'delete class from change set (d)' 'destroy change set (X)' 'revert & remove from changes' 'delete unchanged windows' 'delete non windows' 'delete both of the above' 'reset variables' 'remove contained in class categories...' 'clear this change set' 'uninstall this change set' 'delete directory...' 'delete') -> #warningIcon.
		#('do again (j)' 'Redo - multiple (Z)') -> #redoIcon.
		#('undo (z)' 'revert to previous version' 'Undo - multiple (z)') -> #undoIcon.
		#('copy (c)' 'copy class...' 'copy class chgs to other side' 'copy method to other side' 'copy all to other side (c)' 'copy name to clipboard' 'copy selector to clipboard') -> #copyIcon.
		#('paste (v)' 'Paste without Format') -> #pasteIcon.
		#('cut (x)' 'move class chgs to other side' 'move method to other side' 'submerge into other side') -> #cutIcon.
		#('paste...' 'icons...') -> #worldIcon.
}! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

	Theme current class beCurrent!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3099-exploreCompiledMethod-menuOption-JuanVuletich-2017Jun05-11h19m-jmv.1.cs.st----!

----SNAPSHOT----#(14 June 2017 3:34:05.365138 pm) Cuis5.0-3099.image priorSource: 369571!

----QUIT----#(14 June 2017 3:34:31.560152 pm) Cuis5.0-3099.image priorSource: 400239!

----STARTUP----#(20 June 2017 5:55:35.881237 pm) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3099.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3099] on 9 June 2017 at 12:14:01 am'!
!RectangleLikeMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:47:05'!
                  categoryInNewMorphMenu
	^ 'Kernel'! !
!PasteUpMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:51:39'!
 categoryInNewMorphMenu
	^ 'Worlds'! !
!EllipseMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:50:14'!
 categoryInNewMorphMenu
	^ 'Basic'! !
!ProgressBarMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/9/2017 00:05:22'!
                              categoryInNewMorphMenu
	^ 'Widgets'! !
!ImageMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:54:09'!
  categoryInNewMorphMenu
	^ 'Basic'! !
!StringMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:55:41'!
   categoryInNewMorphMenu
	^ 'Basic'! !
!UpdatingStringMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/9/2017 00:04:50'!
                           categoryInNewMorphMenu
	^ 'Widgets'! !
!LayoutMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:48:35'!
 categoryInNewMorphMenu
	^ 'Layouts'! !
!ProgressMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/9/2017 00:10:17'!
                               categoryInNewMorphMenu
	^ 'Widgets'! !
!HaloHandleMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:53:34'!
                             categoryInNewMorphMenu
	^ 'Halos'! !
!HaloMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:53:26'!
     categoryInNewMorphMenu
	^ 'Halos'! !
!ResizeMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:56:28'!
   categoryInNewMorphMenu
	^ 'Views'! !
!FillInTheBlankMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:52:51'!
                           categoryInNewMorphMenu
	^ 'Widgets'! !
!HoverHelpMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:54:39'!
                              categoryInNewMorphMenu
	^ 'Widgets'! !
!TheWorldMenu methodsFor: 'construction' stamp: 'pb 6/9/2017 00:11:33' prior: 50332703!
 newMorph
	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs.  If the preference #classicNewMorphMenu is true, the full form of yore is used; otherwise, a much shortened form is used."
	| menu subMenu catDict |
	menu _ self menu: 'Add a new morph'.
	menu
		
			add: 'From Clipboard'
			target: myHand
			action: #pasteMorph;
		
			add: 'From Alphabetical List'
			subMenu: self alphabeticalMorphMenu.
	menu addLine.
	"Add 'Classic' New Morph menu"
	catDict _ Dictionary new.

	Morph allSubclassesDo: [ :eaSubclass |
		eaSubclass includeInNewMorphMenu ifTrue: [ | category |
			(eaSubclass respondsTo: #categoryInNewMorphMenu)
				ifTrue: [ category _ eaSubclass categoryInNewMorphMenu ]
				ifFalse: [ category _ 'Unknown' ].
			(catDict includesKey: category)
				ifTrue: [ (catDict at: category) add: eaSubclass ]
				ifFalse: [
					catDict
						at: category
						put: (OrderedCollection with: eaSubclass) ]]].
	catDict keys sort do: [ :categ |
		subMenu _ MenuMorph new.
		((catDict at: categ) asArray sort: [ :c1 :c2 |
			c1 name < c2 name ]) do: [ :cl |
			subMenu
				add: cl name
				target: self
				selector: #newMorphOfClass:event:
				argument: cl ].
		menu
			add: categ
			subMenu: subMenu ].
	self doPopUp: menu.! !

TheWorldMenu removeSelector: #newMorphOld!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3100-DynamicMorphMenuCategories-PhilBellalouna-2017Jun08-23h33m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3099] on 11 June 2017 at 8:11:06 pm'!
!TestCase class methodsFor: 'Testing' stamp: 'pb 6/11/2017 20:10:43' prior: 16927725!
                            isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"
	^ thisContext methodClass == self class.! !
!TestResource class methodsFor: 'Testing' stamp: 'pb 6/11/2017 20:10:52' prior: 16927869!
 isAbstract
	"Override to true if a TestResource subclass is Abstract and should not have
	TestCase instances built from it"
	^ thisContext methodClass == self class.! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3101-isAbstract-PhilBellalouna-2017Jun11-20h10m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3099] on 9 June 2017 at 1:04:48 am'!
!Preferences class methodsFor: 'halos' stamp: 'pb 6/9/2017 00:46:36' prior: 16893159!
iconicHaloSpecifications
	"Answer an array that characterizes the locations, colors, icons, and selectors of the halo handles that may be used in the iconic halo scheme"

	"
	Preferences resetHaloSpecifications
	"

^ #(
	"selector						horiz				vert					color info						icon key 						balloon help
	 ---------						------				-----------			-------------------------------		---------------"
	(addCollapseHandle:		left				topCenter		(tan)							haloCollapseIcon 			'Collapse')
	(addDebugHandle:			right				topCenter		(orange)						haloDebugIcon 				'Debug')
	(addDismissHandle:			left				top				(red)							haloDismissIcon 				'Remove')
	"FIXME - Currently non-functional...
	(addRotateHandle:			left				bottom			(blue)							haloRotateIcon 				'Rotate')
	"
	(addMenuHandle:			leftCenter		top				(blue lighter)					haloMenuIcon 				'Menu')
	(addGrabHandle:				center			top				(black)							haloGrabIcon 				'Pick up')
	(addDragHandle:				rightCenter		top				(brown)						haloDragIcon 				'Move')
	(addDupHandle:				right				top				(green)						haloDuplicateIcon 			'Duplicate')	
	(addHelpHandle:				center			bottom			(lightBlue)					haloHelpIcon 				'Help')
	(addGrowHandle:			right				bottom			(yellow)						haloScaleIcon 				'Change size')
	(addFontSizeHandle:		leftCenter		bottom			(lightGreen)					haloFontSizeIcon 			'Change font')
	(addFontEmphHandle:		rightCenter		bottom			(lightBrown darker)			haloFontEmphasisIcon 		'Emphasis & alignment')
	"FIXME - Currently non-functional...
	(addRecolorHandle:			right				bottomCenter	(magenta darker)			haloColorIcon 				'Change color')
	"
)! !
!Morph methodsFor: 'halos and balloon help' stamp: 'pb 6/9/2017 00:52:09' prior: 16875868!
               wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"

	(#(addRotateHandle: addRecolorHandle:) statePointsTo: aSelector)
		ifTrue: ["FIXME - hack to disable for non-functional halo items"
			^ false].

	Preferences selectiveHalos ifFalse: [
		^true ].

	(#(#addDismissHandle: ) includes: aSelector)
		ifTrue: [ ^ self resistsRemoval not ].
	(#(#addDragHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToBrownDragEasily ].
	(#(#addGrowHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToResizeEasily ].
	(#(#addRotateHandle: ) includes: aSelector)
		ifTrue: [ ^ self okayToRotateEasily ].
	(#(#addRecolorHandle: ) includes: aSelector)
		ifTrue: [ ^ self wantsRecolorHandle ].
	^ true! !
!PasteUpMorph methodsFor: 'halos and balloon help' stamp: 'pb 6/9/2017 00:51:44' prior: 16887852!
             wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph
	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"
	(#(addHelpHandle: addRotateHandle: addRecolorHandle:) statePointsTo: aSelector)
		ifTrue: ["FIXME - hack to disable for non-functional halo items"
			^ false].
	
	self isWorldMorph ifFalse: [
		^super wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph ].

	^#(addDebugHandle: addMenuHandle: addHelpHandle:)
		statePointsTo: aSelector! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3102-Disable-Nonfunctional-Halos-PhilBellalouna-2017Jun09-00h45m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3099] on 10 June 2017 at 1:39:18 am'!
!Array methodsFor: 'printing' stamp: 'pb 6/10/2017 01:39:04' prior: 16779829!
                      isLiteral
	"Definition from Squeak"
	^ self class == Array and: [
		self allSatisfy: [ :each |
			each isLiteral ]].! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3103-Array-isLiteral-compatibility-with-Squeak-PhilBellalouna-2017Jun10-01h39m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3103] on 19 June 2017 at 11:46:49 am'!
!ChangeList methodsFor: 'menu actions' stamp: 'jmv 6/19/2017 11:45:52'!
                              fileOutCurrentVersionsOfSelections
	
	(FillInTheBlankMorph
		request: 'Enter file name'
		initialAnswer: 'Filename.st'
		onCancel: [^nil])

			asFileEntry writeStreamDo: [ :stream |
				stream timeStamp.
				self currentVersionsOfSelections do: [ :methodRef |
					methodRef actualClass
						printMethodChunk: methodRef methodSymbol
						withPreamble: true
						on: stream
						moveSource: false
						toFile: 0 ]]! !
!ChangeListWindow methodsFor: 'menu building' stamp: 'jmv 6/19/2017 11:39:03' prior: 16797171!
                           listMenu
	"Fill aMenu up so that it comprises the primary changelist-browser menu"

	| aMenu |
	aMenu _ MenuMorph new defaultTarget: self.
	aMenu addTitle: 'change list'.
	aMenu addStayUpIcons.
	aMenu addList: #(
	('fileIn selections'							fileInSelections
			'import the selected items into the image'																			model)
	('fileOut selections...	'					fileOutSelections
			'create a new file containing the selected items'																	model)
	('fileOut current version of selections...'	fileOutCurrentVersionsOfSelections
			'create a new file containing the current (in-image) counterparts of the selected methods'					model)
	-
	('compare to current'						compareToCurrentVersion
			'open a separate window which shows the text differences between the on-file version and the in-image version.' model)
	('toggle diffing (D)'							toggleDiffing							
			'start or stop showing diffs in the code pane.'																		model)
	-
	('select new methods'						selectNewMethods
			'select methods in the file that do not currently exist in the image'												model)
	('select changes for absent classes'		selectAllForAbsentClasses
			'select methods in the file for classes that are not defined in the image'										model)
	('select all changes for this class'			selectAllForThisClass
			'select all methods in the file that belong to the currently-selected class'										model)
	('select unchanged methods'				selectUnchangedMethods	
			'select methods in the file whose in-image versions are the same as their in-file counterparts'				model)
	('select methods equivalent to current'	selectEquivalentMethods
			'select methods in the file whose in-image versions have the same behavior as their in-file counterparts'	model)
	('select methods older than current'		selectMethodsOlderThanCurrent
			'select methods in the file that are older than the one currently in the image'									model)
	('select removals of sent methods'		selectRemovalsOfSent
			'select all method removals of methods that have some sender in the image'									model)
	-
	('select all (a)'								selectAll
			'select all the items in the list'																							model)
	('deselect all'									deselectAll
			'deselect all the items in the list'																						model)
	('invert selections'							invertSelections
			'select every item that is not currently selected, and deselect every item that *is* currently selected'		model)
	-
	('browse class and method'				browseMethodFull
			'open a full browser showing the selected method')
	('browse all versions of single selection'	browseVersions
			'open a version browser showing the versions of the currently selected method')
	('browse current versions of selections'	browseCurrentVersionsOfSelections
			'open a message-list browser showing the current (in-image) counterparts of the selected methods')
	('destroy current methods of selections'	destroyCurrentCodeOfSelections
			'remove (*destroy*) the in-image counterparts of all selected methods'										model)
	-
	('remove doIts'								removeDoIts
			'remove all items that are doIts rather than definitions'																model)
	('remove older versions'					removeOlderMethodVersions
			'remove all but the most recent versions of methods in the list'													model)
	('remove up-to-date versions'				removeUpToDate
			'remove all items whose code is the same as the counterpart in-image code'									model)
	('remove empty class comments'			removeEmptyClassComments
			'remove all empty class comments'																					model)
	('remove selected items'					removeSelections
			'remove the selected items from the change-list'																	model)
	('remove unselected items'					removeNonSelections
			'remove all the items not currently selected from the change-list'												model)).
	^ aMenu! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3104-fileOutCurrentVersions-JuanVuletich-2017Jun19-11h26m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3103] on 19 June 2017 at 11:07:11 am'!

FloatArray variableWordSubclass: #Colour
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps ColorNamesDict FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #Colour category: #'Graphics-Primitives'!
FloatArray variableWordSubclass: #Colour
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps ColorNamesDict FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!
!Colour commentStamp: 'jmv 6/18/2017 20:14:31' prior: 0!
                This class represents abstract color, regardless of the depth of bitmap it will be shown in.  At the very last moment a Color is converted to a pixelValue that depends on the depth of the actual Bitmap inside the Form it will be used with.  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.  (See comment in BitBlt.)  To change the depth of the Display and set how many colors you can see, execute: (Display newDepth: 8).  (See comment in DisplayMedium)
	Color is represented as the amount of light in red, green, and blue.  White is (1.0, 1.0, 1.0) and black is (0, 0, 0).  Pure red is (1.0, 0, 0).  These colors are "additive".  Think of Color's instance variables as:
	r	amount of red, a Float between 0.0 and 1.0.
	g	amount of green, a Float between 0.0 and 1.0.
	b	amount of blue, a Float between 0.0 and 1.0.
	Many colors are named.  You find a color by name by sending a message to class Color, for example (Color lightBlue).  Also, (Color red: 0.2 green: 0.6 blue: 1.0) or (Color r: 0.2 g: 0.6 b: 1.0) creates a color. (see below)
	A color is essentially immutable.  Once you set red, green, and blue, you cannot change them.  Instead, create a new Color and use it.
	Applications such as contour maps and bar graphs will want to display one of a set of shades based on a number.  Convert the range of this number to an integer from 1 to N.  Then call (Color green lightShades: N) to get an Array of colors from white to green.  Use the Array messages at:, atPin:, or atWrap: to pull out the correct color from the array.  atPin: gives the first (or last) color if the index is out of range.  atWrap: wraps around to the other end if the index is out of range.
	Here are some fun things to run in when your screen has color:
		Pen new mandala: 30 diameter: Display height-100.
		Pen new web  "Draw with the mouse, opt-click to end"
		Display fillWhite.  Pen new hilberts: 5.
		Form toothpaste: 30  "Draw with mouse, opt-click to end"

Messages:
	mixed: proportion with: aColor	Answer this color mixed with the given color additively. The proportion, a number between 0.0 and 1.0, determines what what fraction of the receiver to use in the mix.

	+ 	add two colors
	- 	subtract two colors
	*	multiply the values of r, g, b by a number or an Array of factors.  ((Color named: #white) * 0.3) gives a darkish gray.  (aColor * #(0 0 0.9)) gives a color with slightly less blue.
	/	divide a color by a factor or an array of three factors.

	hue			Returns the hue of the color. On a wheel from 0 to 360 with pure red at 0 and again at 360.
	saturation	Returns the saturation of the color.  0.0 to 1.0
	brightness	Returns the brightness of the color.  0.0 to 1.0

	name    Look to see if this Color has a name.
	display	Show a swatch of this color tracking the cursor.

	lightShades: thisMany		An array of thisMany colors from white to the receiver. 
	darkShades: thisMany		An array of thisMany colors from black to the receiver.  Array is of length num.
	mix: color2 shades: thisMany		An array of thisMany colors from the receiver to color2.
	wheel: thisMany			An array of thisMany colors around the color wheel starting and ending at the receiver.

	pixelValueForDepth: d    Returns the bits that appear be in a Bitmap of this depth for this color.  Represents the nearest available color at this depth.  Normal users do not need to know which pixelValue is used for which color. 

Messages to Class Color.
	red: r green: g blue: b		Return a color with the given r, g, and b components.
	r: g: b:		Same as above, for fast typing.

 	hue: h saturation: s brightness: b		Create a color with the given hue, saturation, and brightness.

	pink
 	blue
	red ...	Many colors have messages that return an instance of Color.
	canUnderstand: #brown	  Returns true if #brown is a defined color.
	names		An OrderedCollection of the names of the colors.
	named: #notAllThatGray put: aColor    Add a new color to the list and create an access message and a class variable for it.
	fromUser	Shows the palette of colors available at this display depth.  Click anywhere to return the color you clicked on.

	hotColdShades: thisMany	An array of thisMany colors showing temperature from blue to red to white hot.

    stdColorsForDepth: d        An Array of colors available at this depth.  For 16 bit and 32 bits, returns a ColorGenerator.  It responds to at: with a Color for that index, simulating a very big Array. 

   colorFromPixelValue: value depth: d    Returns a Color whose bit pattern (inside a Bitmap) at this depth is the number specified.  Normal users do not need to use this.

(See also comments in these classes: Form, Bitmap, BitBlt)

Default colorSpace is #sRGB. Subclasses might use other color spaces!

Colour variableWordSubclass: #TranslucentColour
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #TranslucentColour category: #'Graphics-Primitives'!
Colour variableWordSubclass: #TranslucentColour
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!
!TranslucentColour commentStamp: '<historical>' prior: 0!
   A TranslucentColor behaves just like a normal color, except that it will pack its alpha value into the fourth position.  This allows creating forms with translucency for use with the alpha blend function of BitBlt.  An alpha of zero is transparent, and 1.0 is opaque.!
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:10:00'!
                     alpha
	"Return the opacity ('alpha') value of opaque so that normal colors can be compared to TranslucentColors."

	^ 1.0
! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:34'!
    blue
	"Return the blue component of this color, a float in the range [0.0..1.0]."

	^ self at: 3! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:33:10'!
                              brightness
	"Return the brightness of this color, a float in the range [0.0..1.0].
	Color red brightness
	"

	"Do not include alpha if TranslucentColour"
	^ (self red max: self green) max: self blue! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:34:30'!
                        chroma
	"Return the chroma of this color, a value between 0.0 and 1.0, somewhat related to saturation.
	See http://en.wikipedia.org/wiki/HSL_and_HSV
	Color red chroma
	Color gray chroma
	"

	| r g b max min |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	^max - min! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:28'!
                             green
	"Return the green component of this color, a float in the range [0.0..1.0]."

	^ self at: 2! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:31:54'!
                            hue
	"Return the hue of this color, an angle in the range [0.0..360.0].
	Color orange hue
	"

	| r g b max min span h |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	span _ (max - min) asFloat.
	span = 0.0 ifTrue: [ ^ 0.0 ].

	r = max ifTrue: [
		h _ ((g - b) asFloat / span) * 60.0.
	] ifFalse: [
		g = max
			ifTrue: [ h _ 120.0 + (((b - r) asFloat / span) * 60.0). ]
			ifFalse: [ h _ 240.0 + (((r - g) asFloat / span) * 60.0). ].
	].

	^h mod: 360.0! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:10:00'!
 icon
	"Answer a swatch to display in a menu or browser"
	^self swatch! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:10:00'!
                         iconOrThumbnailOfSize: aNumberOrPoint 
	"Answer an appropiate form to represent the receiver"
	| form |
	form := Form extent: aNumberOrPoint asPoint asPoint depth: 32.
	form fillColor: self.
	^ form! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:10:00'!
                        luminance
	"Return the luminance of this color, a brightness value weighted by the human eye's color sensitivity."

	^ ((299 * self red) +
	   (587 * self green) +
	   (114 * self blue)) / 1000! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:25'!
                             red
	"Return the red component of this color, a float in the range [0.0..1.0]."

	^ self at: 1! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:34:08'!
saturation
	"Return the saturation of this color, a value between 0.0 and 1.0.
	Color red saturation
	Color gray saturation
	"

	| r g b max min |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	max = 0.0 ifTrue: [ ^0.0 ].
	^max - min / max! !
!Colour methodsFor: 'access' stamp: 'jmv 6/18/2017 20:10:00'!
                        swatch
	"Answer a swatch to display in a menu or browser"
	^self iconOrThumbnailOfSize: 16! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                               asNontranslucentColor
	^ self! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:20:07'!
                            bitPatternForDepth: depth
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"

	^ Bitmap with: (self pixelWordForDepth: depth)! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
               bitPatternForGrayForm
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"
	"Details: The pattern for the most recently requested depth is cached."

	^Bitmap with: (self pixelWordFor: 8 filledWith: (self luminance * 255) rounded)! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
         closestPixelValue1
	"Return the nearest approximation to this color for a monochrome Form."

	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 0].  "white"

	self luminance > 0.5
		ifTrue: [^ 0]  "white"
		ifFalse: [^ 1].  "black"! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                closestPixelValue2
	"Return the nearest approximation to this color for a 2-bit deep Form."

	| lum |
	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 2].  "opaque white"

	lum _ self luminance.
	lum < 0.2 ifTrue: [^ 1].  "black"
	lum > 0.6 ifTrue: [^ 2].  "opaque white"
	^ 3  "50% gray"
! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                    closestPixelValue4
	"Return the nearest approximation to this color for a 4-bit deep Form."

	| bIndex |
	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 2].  "opaque white"

	self isRed ifTrue: [^ 4].
	self isGreen ifTrue: [^ 5].
	self isBlue ifTrue: [^ 6].
	self isCyan ifTrue: [^ 7].
	self isYellow ifTrue: [^ 8].
	self isMagenta ifTrue: [^ 9].

	bIndex _ (self luminance * 8.0) rounded.  "bIndex in [0..8]"
	^ #(
		1	"black"
		10	"1/8 gray"
		11	"2/8 gray"
		12	"3/8 gray"
		3	"4/8 gray"
		13	"5/8 gray"
		14	"6/8 gray"
		15	"7/8 gray"
		2	"opaque white"
	) at: bIndex + 1.
! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                   closestPixelValue8
	"Return the nearest approximation to this color for an 8-bit deep Form."

	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 255].  "white"

	^self saturation < 0.2
		ifTrue: [
			^ self class grayToIndexMap at:(self green * 255) rounded + 1.  "nearest gray"
			]
		ifFalse: [
			"compute nearest entry in the color cube"
			40 + 
				((self red * 5) rounded * 36) +
				((self blue * 5) rounded * 6) +
				(self green * 5) rounded ]! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                  dominantColor
	^ self! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
    indexInMap: aColorMap
	"Return the index corresponding to this color in the given color map. RGB colors are truncated to 3-, 4-, or 5-bits per color component when indexing into such a colorMap.  "

	aColorMap size = 2 ifTrue: [^ (self pixelValueForDepth: 1) + 1].
	aColorMap size = 4 ifTrue: [^ (self pixelValueForDepth: 2) + 1].
	aColorMap size = 16 ifTrue: [^ (self pixelValueForDepth: 4) + 1].
	aColorMap size = 256 ifTrue: [^ (self pixelValueForDepth: 8) + 1].
	aColorMap size = 512 ifTrue: [^ (self pixelValueForDepth: 9) + 1].
	aColorMap size = 4096 ifTrue: [^ (self pixelValueForDepth: 12) + 1].
	aColorMap size = 32768 ifTrue: [^ (self pixelValueForDepth: 15) + 1].
	self error: 'unknown pixel depth'.
! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:51:40'!
                  makeForegroundColor
        "Make a foreground color contrasting with me"
        ^self luminance >= 0.5
                ifTrue: [Colour black]
                ifFalse: [Colour white]! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
  pixelValueForDepth: d
	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"
	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."
	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8 and less than 32 (no Indexed colors, no real alpha), black maps to the darkest possible blue.
	Note that 
		Color transparent class = TranslucentColor
	this special case is handled in TranslucentColor >> #pixelValueForDepth:
	"

	| bitBltFakeBlack val |
	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"
	d < 8 ifTrue: [
		d = 4 ifTrue: [^ self closestPixelValue4].
		d = 2 ifTrue: [^ self closestPixelValue2].
		d = 1 ifTrue: [^ self closestPixelValue1]].

	d = 32 ifTrue: [
		"eight bits per component; top 8 bits set to all ones (opaque alpha)"
		val _ LargePositiveInteger new: 4.
		val at: 3 put: (self red * 255) rounded.
		val at: 2 put: (self green * 255) rounded.
		val at: 1 put: (self blue * 255) rounded.
		val at: 4 put: 16rFF.  "opaque alpha"
		^ val normalize].

	"For the depth 16, pixelValue = 0 means transparent, black is represented as 16r8000 (rgb=0, pixelvalue !!= 0)."
	(d = 16) | (d = 15) ifTrue: [
		"five bits per component; top bits ignored"
		val _ ((self red * 31) rounded bitShift: 10) bitOr:
			(((self green * 31) rounded bitShift: 5) bitOr: 
			((self blue * 31) rounded)).
		^ val = 0
			ifTrue: [d = 16 ifTrue: [16r8000] ifFalse: [1]]
			ifFalse: [val]].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	bitBltFakeBlack := 1.  "closest black that is not transparent in RGB - Not for depths <=8 (Indexed) or = 32 (RGBA)"
	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"
		val _ ((self red * 15) rounded bitShift: 8) bitOr:
			(((self green * 15) rounded bitShift: 4) bitOr: 
			((self blue * 15) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"
		val _ ((self red * 7) rounded bitShift: 6) bitOr:
			(((self green * 7) rounded bitShift: 3) bitOr: 
			((self blue * 7) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	self error: 'unknown pixel depth: ', d printString! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                         pixelWordFor: depth filledWith: pixelValue
	"Return to a 32-bit word that concatenates enough copies of the given pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."
	| halfword |
	depth = 32 ifTrue: [^ pixelValue].
	depth = 16
		ifTrue: [halfword _ pixelValue]
		ifFalse: [halfword _ pixelValue * 
					(#(16rFFFF				"replicates at every bit"
						16r5555 -			"replicates every 2 bits"
						16r1111 - - -			"replicates every 4 bits"
						16r0101) at: depth)	"replicates every 8 bits"].
	^ halfword bitOr: (halfword bitShift: 16)! !
!Colour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:00'!
                              pixelWordForDepth: depth
	"Return to a 32-bit word that concatenates enough copies of the receiver's pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."

	| pixelValue |
	pixelValue _ self pixelValueForDepth: depth.
	^ self pixelWordFor: depth filledWith: pixelValue
! !
!Colour methodsFor: 'equality' stamp: 'jmv 6/18/2017 20:38:11'!
          diff: theOther
	"Returns a number between 0.0 and 1.0.
	Color gray diff: Color red
	"
	^(self - theOther ) abs sum / self size! !
!Colour methodsFor: 'equality' stamp: 'jmv 6/18/2017 20:10:00'!
                              rgbDistance: otherColor
	"Compare two colors in distance"
"
	^ (self hue - otherColor hue) abs +
	  (self saturation - otherColor saturation) abs *10 +
	  (self brightness - otherColor brightness) abs
"
	"See http://www.compuphase.com/cmetric.htm"
	| meanRed deltaRed deltaGreen deltaBlue |
	meanRed := (self red + otherColor red) abs / 2.
	deltaRed := (self red - otherColor red) abs.
	deltaGreen := (self green - otherColor green) abs.
	deltaBlue := (self blue - otherColor blue) abs.
	
	^ ( ((2 + (meanRed / 256)) * (deltaRed * deltaRed)) +
		(4 * deltaGreen) +
		((2 + ((255 - meanRed) / 256)) * deltaBlue)
	  ) sqrt! !
!Colour methodsFor: 'groups of shades' stamp: 'jmv 6/18/2017 20:10:00'!
        darkShades: thisMany
	"An array of thisMany colors from black to the receiver.  Array is of length num. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red darkShades: 12)"

	^ self class black mix: self shades: thisMany
! !
!Colour methodsFor: 'groups of shades' stamp: 'jmv 6/18/2017 20:10:00'!
   lightShades: thisMany
	"An array of thisMany colors from white to self. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red lightShades: 12)"

	^ self class white mix: self shades: thisMany
! !
!Colour methodsFor: 'groups of shades' stamp: 'jmv 6/18/2017 20:51:45'!
  mix: color2 shades: thisMany
	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red mix: Color green shades: 12)"

	| redInc greenInc blueInc rr gg bb c out |
	thisMany = 1 ifTrue: [^ Array with: color2].
	redInc _ color2 red - self red / (thisMany-1).
	greenInc _ color2 green - self green / (thisMany-1).
	blueInc _ color2 blue - self blue / (thisMany-1).
	rr _ self red.  gg _ self green.  bb _ self blue.
	out _ (1 to: thisMany) collect: [:num |
		c _ Colour r: rr g: gg b: bb.
		rr _ rr + redInc.
		gg _ gg + greenInc.
		bb _ bb + blueInc.
		c].
	out at: out size put: color2.	"hide roundoff errors"
	^ out
! !
!Colour methodsFor: 'groups of shades' stamp: 'jmv 6/18/2017 20:52:45'!
     wheel: thisMany
	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "

	| sat bri hue step c |
	sat _ self saturation.
	bri _ self brightness.
	hue _ self hue.
	step _ 360.0 / (thisMany max: 1).
	^ (1 to: thisMany) collect: [:num |
		c _ Colour h: hue s: sat v: bri.  "hue is taken mod 360"
		hue _ hue + step.
		c].
"
(Colour wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]
"! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:00'!
      closestAssocFrom: aColorDict
	"Answer closest associated color in aColorDict"
"
	((Color r: 0.3 g: 0.2 b: 0.8) closestAssocFrom: (Color colorNamesDict)) explore.
"
	"Filter values for those close in hue (cheap test) then use rgbDistance"
	| closeInHue isClose close distance myHue |
	closeInHue := OrderedCollection new.
	myHue := self hue.
	isClose := [ :assoc | | delta |
		delta := ((assoc value hue) - myHue) abs.
		(delta < 20) or: [ delta > 340 ] "hues within 20 degrees"
	].
	aColorDict  associationsDo:  [ :assoc |
		(isClose value: assoc) ifTrue: [ closeInHue add: assoc ]
	].

	close := nil.
	distance := 1000. "big"
	(closeInHue size > 0)
		ifFalse: [ "fallback -- no color really close"
			aColorDict  associationsDo:  [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		]
		ifTrue: [ closeInHue do: [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		].
	
	^ close! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:51:07'!
                           closestColor
	"Answer the closest matching color in the colorNames dictionary"

"
	(Color red lighter lighter) closestColor explore.
"
	^ self closestColorFrom: (Colour colorNamesDict)! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:51:11'!
closestColorAssociation
	"Answer this color's closest name->color match."

"
	(Color blue lighter lighter) closestColorAssociation explore.
"	
	^ self closestAssocFrom: (Colour colorNamesDict)! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:00'!
                        closestColorFrom: aColorDict
	"Answer closest associated color"
"
	((Color lightBlue) closestColorFrom: (Color css2NamedColors)) explore..
"
	^(self closestAssocFrom: aColorDict) value! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:51:15'!
closestColorName
	"Answer the name symbol of the closest matching color in the colorNames dictionary"
"
	(Color red lighter lighter) closestColor name.
"
	
	^ self closestNameFrom: (Colour colorNamesDict)! !
!Colour methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:00'!
            closestNameFrom: aColorDict
	"Answer closest associated color name"
"
	((Color lightBlue) closestNameFrom: (Color namedColors)) print.
"
	^(self closestAssocFrom: aColorDict) key! !
!Colour methodsFor: 'other' stamp: 'jmv 6/18/2017 20:51:20'!
             colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."

	^(Colour colorNamesDict keyAtValue: self  ifAbsent: [nil])
! !
!Colour methodsFor: 'other' stamp: 'jmv 6/18/2017 20:10:00'!
      name
	"Return this color's name, or description if unnamed."

	^ self printString
! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:00'!
          hexStringRGB
	"
	Color fromUser hexStringRGB
	"
	^String streamContents: [ :strm |
		(self red * 255) rounded printOn: strm base: 16 length: 2 padded: true.
		(self green * 255) rounded printOn: strm base: 16 length: 2 padded: true.
		(self blue * 255) rounded printOn: strm base: 16 length: 2 padded: true ]! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:53:07'!
        printOn: aStream
	 self colorName ifNotNil: [ :name |
		^ aStream
			nextPutAll: 'Colour ';
			nextPutAll: name].
	self storeOn: aStream.
! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:00'!
                  printString
	"Answer a String whose characters are a description of the receiver."
	
	^ String streamContents: [ :stream | self printOn: stream ]! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:00'!
           storeArrayOn: aStream

	aStream nextPutAll: '#('.
	self storeArrayValuesOn: aStream.
	aStream nextPutAll: ') '
! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:00'!
             storeArrayValuesOn: aStream


	self red printOn: aStream fractionDigits: 3.
	aStream space.
	self green printOn: aStream fractionDigits: 3.
	aStream space.
	self blue printOn: aStream fractionDigits: 3

! !
!Colour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:00'!
                 storeOn: aStream

	aStream
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll: ' r: '.
	self red printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' g: '.
	self green printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' b: '.
	self blue printOn: aStream fractionDigits: 3.
	aStream nextPut: $)! !
!Colour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:40:55'!
   isBlack
	"Return true if the receiver represents black"
	(self at: 1) = 0.0 ifFalse: [ ^ false ].
	(self at: 2) = 0.0 ifFalse: [ ^ false ].
	(self at: 3) = 0.0 ifFalse: [ ^ false ].
	^ true! !
!Colour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:10:00'!
isOpaque
	^true! !
!Colour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:10:00'!
              isTransparent

	^ false
! !
!Colour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:40:46'!
     isWhite
	"Return true if the receiver represents white"
	(self at: 1) = 1.0 ifFalse: [ ^ false ].
	(self at: 2) = 1.0 ifFalse: [ ^ false ].
	(self at: 3) = 1.0 ifFalse: [ ^ false ].
	^ true! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                              isBlue
	"Am I considered Blue?"

	^self blue > (self green + 0.3)
		and: [self blue > (self red + 0.3)]
			and: [(self green - self red) abs < 0.4]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
        isBlueGreen
	"Am I considered BlueGreen ?"

	^self green > self red 
		and: [self red < 0.3]
			and: [(self green - self blue) abs < 0.1]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                  isBright
	"Am I considered a Bright color ?"

	^self brightness > 0.6! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                      isBrown
	"Am I considered Brown ?"

	^self red >= self green  
		and: [self green > self blue]					
			and: [(self red - self green) < 0.5]	
				and: [(self green - self blue) < 0.3]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
     isCyan
	"Am I considered Cyan ?"

	^self red < 0.05 
		and: [(self green min: self blue) > 0.5]					
			and: [(self green - self blue) abs < 0.2]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
          isDark
	"Am I considered a Dark color ?"

	^self brightness < 0.5! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                          isGray
	"Am I considered Gray  ?"

	^(self red closeTo: self green)
		and: [self blue closeTo: self green ]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                isGreen
	"Am I considered Green ?"

	^self green > (self blue + 0.3)
		and: [self blue > (self red + 0.3)]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                 isGrey
	"Am I considered Grey  ?"

	^self isGray! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
           isLight
	"Am I considered a Light color ?"

	^self brightness > 0.6! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                        isMagenta
	"Am I considered Magenta ?"

	^self green < 0.05 
		and: [(self red min: self blue) > 0.5]					
			and: [(self red - self blue) abs < 0.2]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
      isOrange
	"Am I considered Orange ?"

	^self red > ((self green max: self blue) + 0.2)  
		and: [self green > (self blue + 0.2)]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                           isPastel
	"Am I considered Pastel ?"

	^self saturation < 0.4! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                              isPink
	"Am I considered Pink ?"

	^self red > ((self green max: self blue) + 0.3)  
		and: [self blue > (self green + 0.2)]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
                               isRed
	"Am I considered Red ?"

	^self red > (self green + 0.4)
		and: [self red > (self blue + 0.6)]
			and: [(self green - self blue) abs < 0.4]! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
         isSaturated
	"Am I considered to be a Saturated color ?"

	^self saturation > 0.6! !
!Colour methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:00'!
          isYellow
	"Am I considered Yellow ?"

	^self blue < 0.05 
		and: [(self red min: self green) > 0.5]					
			and: [(self red - self green) abs < 0.2]! !
!Colour methodsFor: 'testing' stamp: 'jmv 6/18/2017 20:10:00'!
         is: aSymbol
	^ aSymbol == #Color or: [ super is: aSymbol ]! !
!Colour methodsFor: 'testing' stamp: 'jmv 6/18/2017 20:10:00'!
   mightBeTranslucent
	"For Colors, answer if actually translucent or not."
	^self isOpaque not! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:14'!
                         * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Colour brown *2) display
	"
	^ Colour new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:18'!
       + aColor
	"Answer this color mixed with the given color in an additive color space.  "
	"
	(Colour blue + Colour green) display
	"
	^ Colour new
		setRed: (self red + aColor red min: 1.0 max: 0.0)
		green: (self green + aColor green min: 1.0 max: 0.0)
		blue: (self blue + aColor blue min: 1.0 max: 0.0)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:22'!
      - aColor
	"Answer aColor is subtracted from the given color in an additive color space.  "
	"
	(Color white - Color red) display
	"
	^ Colour new
		setRed: (self red - aColor red min: 1.0 max: 0.0)
		green: (self green - aColor green min: 1.0 max: 0.0)
		blue: (self blue - aColor blue min: 1.0 max: 0.0)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:26'!
     / aNumber
	"Answer this color with its RGB divided by the given number. "
	"
	(Color red / 2) display
	"
	^ Colour new
		setRed: (self red / aNumber min: 1.0 max: 0.0)
		green: (self green / aNumber min: 1.0 max: 0.0)
		blue: (self blue / aNumber min: 1.0 max: 0.0)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:50:50'!
            adjustBrightness: brightness
	"Adjust the relative brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Colour
		h: self hue
		s: self saturation
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:50:53'!
                  adjustSaturation: saturation brightness: brightness
	"Adjust the relative saturation and brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Colour
		h: self hue
		s: (self saturation + saturation min: 1.0 max: 0.005)
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:10:41'!
         alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifFalse: [
		^ TranslucentColour new
			setRed: self red
			green: self green
			blue: self blue
			alpha: alphaValue ]! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:50:57'!
             alphaMixed: proportion with: aColor 
	"Answer this color mixed with the given color. The proportion, a number 
	between 0.0 and 1.0, determines what what fraction of the receiver to  
	use in the mix. For example, 0.9 would yield a color close to the  
	receiver. This method uses RGB interpolation; HSV interpolation can lead 
	to surprises.  Mixes the alphas (for transparency) also."

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Colour
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)
		alpha: self alpha * frac1 + (aColor alpha * frac2)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                atLeastAsLuminentAs: aFloat

	| revisedColor |
	revisedColor _ self.
	[revisedColor luminance < aFloat] whileTrue: [revisedColor _ revisedColor slightlyLighter].
	^revisedColor
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
    atMostAsLuminentAs: aFloat

	| revisedColor |
	revisedColor _ self.
	[revisedColor luminance > aFloat] whileTrue: [revisedColor _ revisedColor slightlyDarker].
	^revisedColor
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:51:02'!
      blacker

	^ self alphaMixed: 0.8333 with: Colour black
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:51:27'!
                              dansDarker
	"Return a darker shade of the same color.
	An attempt to do better than the current darker method.
	(now obsolete, since darker has been changed to do this. -dew)"
	^ Colour h: self hue s: self saturation
		v: (self brightness - 0.16 max: 0.0)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                      darker
	"Answer a darker shade of this color."

	^ self adjustBrightness: -0.08! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
      duller

	^ self adjustSaturation: -0.03 brightness: -0.2! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                             lighter
	"Answer a lighter shade of this color."

	^ self adjustSaturation: -0.03 brightness: 0.08! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:51:59'!
                   mixed: proportion with: aColor 
	"Mix with another color and do not preserve transpareny.  Only use this for extracting the RGB value and mixing it.  All other callers should use instead: 
	aColor alphaMixed: proportion with: anotherColor
	"

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Colour
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:03'!
                      muchDarker

	^ self alphaMixed: 0.5 with: Colour black
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:07'!
                              muchLighter

	^ self alphaMixed: 0.233 with: Colour white
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:12'!
                           negated
	"Return an RGB inverted color"
	^Colour
		r: 1.0 - self red
		g: 1.0 - self green
		b: 1.0 - self blue! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:37:53'!
      orColorUnlike: theOther
	"If this color is a lot like theOther, then return its complement, otherwide, return self"

	^ (self diff: theOther) < 0.3
		ifTrue: [theOther negated]
		ifFalse: [self]! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                   paler
	"Answer a paler shade of this color."

	^ self adjustSaturation: -0.09 brightness: 0.09
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:16'!
                      quiteBlacker

	^ self alphaMixed: 0.8 with: Colour black
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:19'!
                            quiteWhiter

	^ self alphaMixed: 0.6 with: Colour white! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                              slightlyDarker

	^ self adjustBrightness: -0.03
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
     slightlyLighter

	^ self adjustSaturation: -0.01 brightness: 0.03! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:24'!
                    slightlyWhiter

	^ self alphaMixed: 0.85 with: Colour white
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:00'!
                         twiceDarker
	"Answer a significantly darker shade of this color."

	^ self adjustSaturation: 0.076 brightness: -0.15! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:10:01'!
 twiceLighter
	"Answer a significantly lighter shade of this color."

	^ self adjustSaturation: -0.06 brightness: 0.15! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:27'!
veryMuchDarker

	^ self alphaMixed: 0.25 with: Colour black
! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:52:32'!
                         veryMuchLighter

	^ self alphaMixed: 0.07 with: Colour white! !
!Colour methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:02:05'!
                         whiter

	^ self alphaMixed: 0.8333 with: Colour white
! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:10:01'!
       attemptToMutateError
	"A color is immutable. Once a color's red, green, and blue have been initialized, you cannot change them. Instead, create a new Color and use it."

	self error: 'Color objects are immutable once created'
! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:29:32'!
                           basicSetRed: r green: g blue: b
	"Initialize this color's r, g, and b components to the given values in the range [0.0..1.0]."

	self
		at: 1 put: r;
		at: 2 put: g;
		at: 3 put: b! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:15:44'!
         setHue: hue chroma: chroma brightness: brightness
	"Initialize this color to the given hue, chroma, and luma. See the comment in the instance creation method for details.
	http://en.wikipedia.org/wiki/HSL_and_HSV
		hue belongs in [0.0, 360.0)
		chroma and luma belongs in [0.0, 1.0]
	"

	| x hf i r1 g1 b1 m | 
	hf _ hue \\ 360.
	i _ hf // 60.  				"integer part of hue"
	x _ (hf \\ 60) / 60.0 .         		"fractional part of hue"
	x _ x \\  2 .
	i \\ 2 = 1 ifTrue: [ x _ 1.0 - x ].
	x _ chroma  * x.

	0 = i ifTrue: [ r1 _ chroma. g1 _ x. b1 _ 0.0 ].
	1 = i ifTrue: [ r1 _ x. g1 _ chroma. b1 _ 0.0 ].
	2 = i ifTrue: [ r1 _ 0.0. g1 _ chroma. b1 _ x ].
	3 = i ifTrue: [ r1 _ 0.0. g1 _ x. b1 _ chroma ].
	4 = i ifTrue: [ r1 _ x. g1 _ 0.0. b1 _ chroma ].
	5 = i ifTrue: [ r1 _ chroma. g1 _ 0.0. b1 _ x ].

	m _ brightness - ((r1 max: g1) max: b1).
	m < 0.0
		ifTrue: [ ^nil ]. "No color exists with required parameters"
	r1 _ r1 + m.
	r1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	g1 _ g1 + m.
	g1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	b1 _ b1 + m.
	b1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	self setRed: r1 green: g1 blue: b1! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:15:49'!
                             setHue: hue chroma: chroma luminance: luma
	"Initialize this color to the given hue, chroma, and luma. See the comment in the instance creation method for details.
	http://en.wikipedia.org/wiki/HSL_and_HSV
		hue belongs in [0.0, 360.0)
		chroma and luma belongs in [0.0, 1.0]
	"

	| x hf i r1 g1 b1 m | 

	hf _ hue \\ 360.
	i _ hf // 60.  				"integer part of hue"
	x _ (hf \\ 60) / 60.0 .         		"fractional part of hue"
	x _ x \\  2 .
	i \\ 2 = 1 ifTrue: [ x _ 1.0 - x ].
	x _ chroma  * x.

	0 = i ifTrue: [ r1 _ chroma. g1 _ x. b1 _ 0.0 ].
	1 = i ifTrue: [ r1 _ x. g1 _ chroma. b1 _ 0.0 ].
	2 = i ifTrue: [ r1 _ 0.0. g1 _ chroma. b1 _ x ].
	3 = i ifTrue: [ r1 _ 0.0. g1 _ x. b1 _ chroma ].
	4 = i ifTrue: [ r1 _ x. g1 _ 0.0. b1 _ chroma ].
	5 = i ifTrue: [ r1 _ chroma. g1 _ 0.0. b1 _ x ].

	m _ luma - (0.299*r1) - (0.587*g1) - (0.114*b1).
	m < 0.0
		ifTrue: [ ^nil ]. "No color exists with required parameters"
	r1 _ r1 + m.
	r1 > 1.0 
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	g1 _ g1 + m.
	g1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	b1 _ b1 + m.
	b1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	self setRed: r1 green: g1 blue: b1! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:16:07'!
                          setHue: hue saturation: saturation brightness: brightness
	"Initialize this color to the given hue, saturation, and brightness. See the comment in the instance creation method for details."

	| s v hf i f p q t | 
	s _ saturation asFloat min: 1.0 max: 0.0.
	v _ brightness asFloat min: 1.0 max: 0.0.
	hf _ hue \\ 360.
	i _ hf // 60.  			"integer part of hue"
	f _ (hf \\ 60) / 60.0.         	"fractional part of hue"

	p _ (1.0 - s) * v.
	q _ (1.0 - (s * f)) * v.
	t _ (1.0 - (s * (1.0 - f))) * v.

	0 = i ifTrue: [ ^ self setRed: v green: t blue: p ].
	1 = i ifTrue: [ ^ self setRed: q green: v blue: p ].
	2 = i ifTrue: [ ^ self setRed: p green: v blue: t ].
	3 = i ifTrue: [ ^ self setRed: p green: q blue: v ].
	4 = i ifTrue: [ ^ self setRed: t green: p blue: v ].
	5 = i ifTrue: [ ^ self setRed: v green: p blue: q ].

	self error: 'implementation error'! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:13:04'!
  setRed: r green: g blue: b

	self basicSetRed: r green: g blue: b! !
!Colour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:29:48'!
                            setRed: r green: g blue: b range: range
	"Initialize this color's r, g, and b components to the given values in the range [0..r]."

	self basicSetRed: r green: g blue: b.
	self /= range! !
!Colour methodsFor: 'as yet unclassified' stamp: 'jmv 6/18/2017 20:10:01'!
                        color
	^ self! !
!Colour methodsFor: 'please remove' stamp: 'jmv 6/18/2017 21:26:21'!
          floatRGB
"to be removed"
	^ self! !
!Colour methodsFor: 'please remove' stamp: 'jmv 6/18/2017 21:26:07'!
                       setRed: r green: g blue: b colorSpace: aSymbol
	^ self setRed: r green: g blue: b! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
                            clipR: r g: g b: b
	"Return a color with the given r, g, and b components in the range [0.0..1.0].
	Clip if necessary"

	^ self 
		r: (r min: 1.0 max: 0.0)
		g: (g min: 1.0 max: 0.0)
		b: (b min: 1.0 max: 0.0)! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
                            colorFrom: parm
	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol or, if it is a list, it can either be an array of three numbers, which will be interpreted as RGB values, or a list of symbols, the first of which is sent to me and then the others of which are in turn sent to the prior result, thus allowing entries of the form #(blue darker).  Else just return the thing"

	| aColor firstParm |
	(parm is: #Color) ifTrue: [ ^ parm ].
	parm isSymbol ifTrue: [ ^ self perform: parm ].
	(parm isSequenceableCollection and: [ parm size > 0 ])
		ifTrue: [
			firstParm _ parm first.
			firstParm isNumber ifTrue: [
				^ self fromRgbTriplet: parm].
			aColor _ self colorFrom: firstParm.
			parm withIndexDo: [ :sym :ind |
				ind > 1 ifTrue: [
					aColor _ aColor perform: sym ]].
			^ aColor].
	^ parm

"
Color colorFrom: #(blue darker)
Color colorFrom: Color blue darker
Color colorFrom: #blue
Color colorFrom: #(0.0 0.0 1.0)
"! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 21:02:20'!
                  colorFromPixelValue: p depth: d
	"Convert a pixel value for the given display depth into a color."
	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."
	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.
	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).
	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.
	Squeak also answers darkest possible blue when asked for black. Again, this is not needed in 32 bits (with alpha). It is also not really needed for 16 bits as we have an extra, unused bit: 16r8000 is not zero, but rgb=0, and hence, black.
	The real rule is that pixelValue=0 means transparent.
	And that darkest blue must be used instead of black, but only for depths >8 and < 16 (no indexed colors, no alpha)
	This method is updated to reflect that."

	| r g b alpha |

	d = 1 ifTrue: [^ self indexedColors at: (p bitAnd: 16r01) + 1].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	p = 0 ifTrue: [ ^Colour transparent ].

	d = 8 ifTrue: [^ self indexedColors at: (p bitAnd: 16rFF) + 1].
	d = 4 ifTrue: [^ self indexedColors at: (p bitAnd: 16r0F) + 1].
	d = 2 ifTrue: [^ self indexedColors at: (p bitAnd: 16r03) + 1].

	d = 32 ifTrue: [
		"eight bits per component; 8 bits of alpha"
		alpha _ p bitShift: -24.
		alpha = 0 ifTrue: [ ^Colour transparent ].
		r _ (p bitShift: -16) bitAnd: 16rFF.
		g _ (p bitShift: -8) bitAnd: 16rFF.
		b _ p bitAnd: 16rFF.
		^alpha < 255
			ifTrue: [ (Colour r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]
			ifFalse: [ Colour r: r g: g b: b range: 255 ]].

	d = 16 ifTrue: [
		"five bits per component. The most significant bit, unused, allows having real black, without p being zero"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		^ Colour r: r g: g b: b range: 31].

	d = 15 ifTrue: [
		"five bits per component"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 31].

	d = 12 ifTrue: [
		"four bits per component"
		r _ (p bitShift: -8) bitAnd: 16rF.
		g _ (p bitShift: -4) bitAnd: 16rF.
		b _ p bitAnd: 16rF.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 15].

	d = 9 ifTrue: [
		"three bits per component"
		r _ (p bitShift: -6) bitAnd: 16r7.
		g _ (p bitShift: -3) bitAnd: 16r7.
		b _ p bitAnd: 16r7.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 7].

	self error: 'unknown pixel depth: ', d printString! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
                            fromArray: colorDef

	| answer |
	colorDef size = 0 ifTrue: [^self transparent].
	colorDef size between: 3 and: 4 :: ifFalse: [self error: 'Undefined color definition'].
	answer _ self r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3).
	^colorDef size = 3
		ifTrue: [answer]
		ifFalse: [answer alpha: (colorDef at: 4)]! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
     fromRgbTriplet: list
	^ self r: list first g: list second b: list last! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
       fromString: aString
	"For HTML color spec: #FFCCAA. Also support named colors.
	See http://www.w3schools.com/cssref/css_colors_legal.asp"
	"
	Color fromString: '#FFCCAA'.
	Color fromString: 'white'.
	Color fromString: 'orange'
	Color fromString: 'rgb(255,0,98)'
	"
	(aString size = 7 and: [ aString first = $# ]) ifTrue: [
		| aColorHexU red green blue |
		aColorHexU _ aString asUppercase.
		red _ ('16r', (aColorHexU copyFrom: 2 to: 3)) asNumber/255.
		green _ ('16r', (aColorHexU copyFrom: 4 to: 5)) asNumber/255.
		blue _ ('16r', (aColorHexU copyFrom: 6 to: 7)) asNumber/255.
		^ self r: red g: green b: blue].

	(aString beginsWith: 'rgb')
		ifTrue: [|values r g b|
				values := (aString allButFirst: 4) allButLast findTokens: ','.
				r  := (values first includes: $%)
						ifTrue: [(values first asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values first asInteger min: 255 max: 0) / 255.0].
				g := (values second includes: $%)
						ifTrue: [(values second asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values second asInteger min: 255 max: 0) / 255.0].
				b := (values third includes: $%)
						ifTrue: [(values third asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values third asInteger min: 255 max: 0) / 255.0].
				^self r: r g: g b: b].

	^self exactColorNamed: aString! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:29'!
                    gray: brightness
	"Return a gray shade with the given brightness in the range [0.0..1.0]."

	^ self new
		setRed: brightness
		green: brightness
		blue: brightness! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:31'!
          h: hue s: saturation v: brightness
	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."
	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."

	^ self new setHue: hue saturation: saturation brightness: brightness! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
          h: h s: s v: v alpha: alpha

	^ (self h: h s: s v: v) alpha: alpha! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:34'!
           hue: hue chroma: chroma brightness: brightness
	^self new setHue: hue chroma: chroma brightness: brightness! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:37'!
  hue: hue chroma: chroma luminance: luma
	^self new setHue: hue chroma: chroma luminance: luma! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:39'!
                hue: hue saturation: saturation brightness: brightness
	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."
	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."

	^ self new setHue: hue saturation: saturation brightness: brightness! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:54:20'!
                      new
	^ self new: 3! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:41'!
                           r: r g: g b: b
	"Return a color with the given r, g, and b components in the range [0.0..1.0]."

	^ self new
		setRed: r
		green: g
		blue: b! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
r: r g: g b: b alpha: alpha

	^ (self r: r g: g b: b) alpha: alpha! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:43'!
           r: r g: g b: b range: range
	"Return a color with the given r, g, and b components specified as integers in the range [0..r]. This avoids the floating point arithmetic in the red:green:blue: message and is thus a bit faster for certain applications (such as computing a sequence of colors for a palette)."

	^ self new setRed: r green: g blue: b range: range! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
       random
	"Return a random color that isn't too dark or under-saturated.
		Display fill: (10@10 extent: 200@200) fillColor: Color random
	"

	^ Random withDefaultDo: [ :random |
		self random: random ]! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:10:01'!
      random2
	"Return a random color with a distribution that spans over all possible colors.
		Display fill: (10@10 extent: 200@200) fillColor: Color random2
	"

	^ Random withDefaultDo: [ :random |
		self random2: random ]! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:46'!
                  random2: aRandom
	"Return a random color with a distribution that spans over all possible colors."

	^ self new
		setRed: aRandom next
		green: aRandom next
		blue: aRandom next! !
!Colour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:48'!
                            random: aRandom
	"Return a random color that isn't too dark or under-saturated."

	^ self new
		setHue: (360.0 * aRandom next)
		saturation: (0.3 + (aRandom next * 0.7))
		brightness: (0.4 + (aRandom next * 0.6))! !
!Colour class methodsFor: 'class initialization' stamp: 'jmv 6/18/2017 20:10:01'!
                      initializeGrayToIndexMap
	"Build an array of gray values available in the 8-bit colormap. This array is indexed by a gray level between black (1) and white (256) and returns the pixel value for the corresponding gray level."
	"Note: This method must be called after initializeIndexedColors, since it uses IndexedColors."
	"
	Color initializeGrayToIndexMap
	"

	| grayLevels grayIndices c distToClosest dist indexOfClosest indexedColors |
	"record the level and index of each gray in the 8-bit color table"
	grayLevels _ OrderedCollection new.
	grayIndices _ OrderedCollection new.
	indexedColors _ self indexedColors.
	"Note: skip the first entry, which is reserved for transparent"
	2 to: indexedColors size do: [:i |
		c _ indexedColors at: i.
		c saturation = 0.0 ifTrue: [  "c is a gray"
			grayLevels add: (c green * 255) rounded.  "0 to 255; R, G, and B are the same"
			grayIndices add: i - 1]].  "pixel values are zero-based"
	grayLevels _ grayLevels asArray.
	grayIndices _ grayIndices asArray.

	"for each gray level in [0..255], select the closest match"
	GrayToIndexMap _ ByteArray new: 256.
	0 to: 255 do: [ :level |
		distToClosest _ 10000.  "greater than distance to any real gray"
		1 to: grayLevels size do: [:i |
			dist _ (level - (grayLevels at: i)) abs.
			dist < distToClosest ifTrue: [
				distToClosest _ dist.
				indexOfClosest _ grayIndices at: i]].
		GrayToIndexMap at: (level + 1) put: indexOfClosest]! !
!Colour class methodsFor: 'class initialization' stamp: 'jmv 6/18/2017 20:59:48'!
                    initializeIndexedColors
	"Build an array of colors corresponding to the fixed colormap used
	 for display depths of 1, 2, 4, or 8 bits."
	"Color initializeIndexedColors"

	| a index grayVal |
	a _ Array new: 256.

	"1-bit colors (monochrome)"
	a at: 1 put: (Colour r: 1.0 g: 1.0 b: 1.0).		"white or transparent"
	a at: 2 put: (Colour r: 0.0 g: 0.0 b: 0.0).	"black"

	"additional colors for 2-bit color"
	a at: 3 put: (Colour r: 1.0 g: 1.0 b: 1.0).	"opaque white"
	a at: 4 put: (Colour r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"

	"additional colors for 4-bit color"
	a at:  5 put: (Colour r: 1.0 g: 0.0 b: 0.0).	"red"
	a at:  6 put: (Colour r: 0.0 g: 1.0 b: 0.0).	"green"
	a at:  7 put: (Colour r: 0.0 g: 0.0 b: 1.0).	"blue"
	a at:  8 put: (Colour r: 0.0 g: 1.0 b: 1.0).	"cyan"
	a at:  9 put: (Colour r: 1.0 g: 1.0 b: 0.0).	"yellow"
	a at: 10 put: (Colour r: 1.0 g: 0.0 b: 1.0).	"magenta"

	a at: 11 put: (Colour r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"
	a at: 12 put: (Colour r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"
	a at: 13 put: (Colour r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"
	a at: 14 put: (Colour r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"
	a at: 15 put: (Colour r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"
	a at: 16 put: (Colour r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"

	"additional colors for 8-bit color"
	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"
	index _ 17.
	1 to: 31 do: [:v |
		(v \\ 4) = 0 ifFalse: [
			grayVal _ v / 32.0.
			a at: index put: (Colour r: grayVal g: grayVal b: grayVal).
			index _ index + 1]].

	"The remainder of color table defines a color cube with six steps
	 for each primary color. Note that the corners of this cube repeat
	 previous colors, but this simplifies the mapping between RGB colors
	 and color map indices. This color cube spans indices 40 through 255
	 (indices 41-256 in this 1-based array)."
	0 to: 5 do: [:r |
		0 to: 5 do: [:g |
			0 to: 5 do: [:b |
				index _ 41 + ((36 * r) + (6 * b) + g).
				index > 256 ifTrue: [
					self error: 'index out of range in color table compuation'].
				a at: index put: (Colour r: r g: g b: b range: 5)]]].

	IndexedColors _ a.
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 20:58:14'!
                              colorRampForDepth: depth extent: aPoint
	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."
	"(Color colorRampForDepth: Display depth extent: 256@80) display"
	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"

	| f dx dy r |
	f _ Form extent: aPoint depth: depth.
	dx _ aPoint x // 256.
	dy _ aPoint y // 4.
	0 to: 255 do: [:i |
		r _ (dx * i)@0 extent: dx@dy.
		f fill: r fillColor: (Colour r: i g: 0 b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: 0 g: i b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: 0 g: 0 b: i range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: i g: i b: i range: 255)].
	^ f
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:29:30'!
                         experimentsTowarsANewColorPalette
"
self experimentsTowarsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width _ 300.
height _ 120.
selectedColor _ Colour random.
selectedHue _ selectedColor hue.
selectedSaturation _ selectedColor saturation.
selectedChroma _ selectedColor chroma.
selectedV _ selectedColor brightness.
selectedLuminance _ selectedColor luminance.
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
0 to: height do: [ :y |
	v _ 1.0 - (y / height).
	0 to: height do: [ :x |
		s _ x / height.
		color _ Colour new setHue: selectedHue saturation: s brightness: v.
		Display colorAt: x@(y+height) put: color
	].
	DisplayScreen screenUpdateRequired: nil
].
0 to: height do: [ :y | | c |
	v _ 1.0 - (y / height).
	s _ 1.0 - (y / height).
	c _ s.
	0 to: width do: [ :x |
		h _ x / width * 360.
		
		color _ Colour new setHue: h chroma: c luminance: selectedLuminance.
"		color _ Colour new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color _ Colour black ].
"		color _ Colour new setHue: h saturation: s brightness: selectedV."
		Display colorAt: x+height@y put: color.
		
		color _ Colour new setHue: h chroma: selectedChroma luminance: v.
"		color _ Colour new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color _ Colour black ].
"		color _ Colour new setHue: h saturation: selectedSaturation brightness: v."
		Display colorAt: x+height@(y+height) put: color.
		
	].
	DisplayScreen screenUpdateRequired: nil
].! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 20:10:01'!
         hotColdShades: thisMany
	"An array of thisMany colors showing temperature from blue to red to white hot.  (Later improve this by swinging in hue.)  "
	"Color showColors: (Color hotColdShades: 25)"

	| n s1 s2 s3 s4 s5 |
	thisMany < 5 ifTrue: [^ self error: 'must be at least 5 shades'].
	n _ thisMany // 5.
	s1 _ self white mix: self yellow shades: (thisMany - (n*4)).
	s2 _ self yellow mix: self red shades: n+1.
	s2 _ s2 copyFrom: 2 to: n+1.
	s3 _ self red mix: self green darker shades: n+1.
	s3 _ s3 copyFrom: 2 to: n+1.
	s4 _ self green darker mix: self blue shades: n+1.
	s4 _ s4 copyFrom: 2 to: n+1.
	s5 _ self blue mix: self black shades: n+1.
	s5 _ s5 copyFrom: 2 to: n+1.
	^ s1, s2, s3, s4, s5
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 20:59:58'!
                      showColorCube
	"Show a 12x12x12 color cube."
	"Color showColorCube"

	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				Display fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Colour r: r g: g b: b range: 11)]]].
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 20:10:01'!
  showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r |
	w _ Display width // colorList size.
	r _ 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		Display fill: r fillColor: c.
		r _ r translatedBy: w@0].
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:00:03'!
            showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"Color showHSVPalettes"

	| left top c |
	left _ top _ 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left _ (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c _ Colour h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4).
				Display fill: (left@top extent: 4@4) fillColor: c.

				c _ Colour h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4) + 50.
				Display fill: (left@top extent: 4@4) fillColor: c]]].
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 20:10:01'!
                  showHuesInteractively
	"Shows a palette of hues at a (saturation, brightness) point determined by the mouse position. Click the mouse button to exit and return the selected (saturation, brightness) point."
	"Color showHuesInteractively"

	| p s v |
	[Sensor isAnyButtonPressed] whileFalse: [
		p _ Sensor mousePoint.
		s _ p x asFloat / 300.0.
		v _ p y asFloat / 300.0.
		self showColors: (self wheel: 12 saturation: s brightness: v)].
	^ (s min: 1.0) @ (v min: 1.0)! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:01:15'!
   wheel: thisMany
	"Return a collection of thisMany colors evenly spaced around the color wheel."
	"Color showColors: (Color wheel: 12)"

	^ Colour wheel: thisMany saturation: 0.9 brightness: 0.7
! !
!Colour class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:01:20'!
                    wheel: thisMany saturation: s brightness: v
	"Return a collection of thisMany colors evenly spaced around the color wheel, all of the given saturation and brightness."
	"Color showColors: (Color wheel: 12 saturation: 0.4 brightness: 1.0)"
	"Color showColors: (Color wheel: 12 saturation: 0.8 brightness: 0.5)"

	^ (Colour h: 0.0 s: s v: v) wheel: thisMany
! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
              aqua

	^ self colorNamesDict at: #aqua! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            beige

	^ self colorNamesDict at: #beige! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          black

	^ self colorNamesDict at: #black! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          blue

	^ self colorNamesDict at: #blue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            brightGreen

	^ self colorNamesDict at: #brightGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              brown

	^ self colorNamesDict at: #brown! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          cyan

	^ self colorNamesDict at: #cyan! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            darkBlue

	^ self colorNamesDict at: #darkBlue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    darkGray

	^ self colorNamesDict at: #darkGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    darkGreen

	^ self colorNamesDict at: #darkGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  darkPink

	^ self colorNamesDict at: #darkPink! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    darkPurple

	^ self colorNamesDict at: #darkPurple! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
forestGreen

	^ self colorNamesDict at: #forestGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              gray

	^ self colorNamesDict at: #gray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            green

	^ self colorNamesDict at: #green! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          grey

	^ self colorNamesDict at: #grey! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            hotPink

	^ self colorNamesDict at: #hotPink! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
      indigo

	^ self colorNamesDict at: #indigo! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        lavender

	^ self colorNamesDict at: #lavender! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    lightBlue

	^ self colorNamesDict at: #lightBlue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  lightBrown

	^ self colorNamesDict at: #lightBrown! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
lightCyan

	^ self colorNamesDict at: #lightCyan! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  lightGray

	^ self colorNamesDict at: #lightGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  lightGreen

	^ self colorNamesDict at: #lightGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
lightMagenta

	^ self colorNamesDict at: #lightMagenta! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                            lightOrange

	^ self colorNamesDict at: #lightOrange! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              lightPink

	^ self colorNamesDict at: #lightPink! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  lightPurple

	^ self colorNamesDict at: #lightPurple! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              lightRed

	^ self colorNamesDict at: #lightRed! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    lightYellow

	^ self colorNamesDict at: #lightYellow! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              lilac

	^ self colorNamesDict at: #lilac! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          lime

	^ self colorNamesDict at: #lime! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            limeGreen

	^ self colorNamesDict at: #limeGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  magenta

	^ self colorNamesDict at: #magenta! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
      maroon

	^ self colorNamesDict at: #maroon! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        mauve

	^ self colorNamesDict at: #mauve! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          mustard

	^ self colorNamesDict at: #mustard! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
      navyBlue

	^ self colorNamesDict at: #navyBlue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    olive

	^ self colorNamesDict at: #olive! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          oliveGreen

	^ self colorNamesDict at: #oliveGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
orange

	^ self colorNamesDict at: #orange! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        paleGreen

	^ self colorNamesDict at: #paleGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  peach

	^ self colorNamesDict at: #peach! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          periwinkle

	^ self colorNamesDict at: #periwinkle! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
pink

	^ self colorNamesDict at: #pink! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            purple

	^ self colorNamesDict at: #purple! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        red

	^ self colorNamesDict at: #red! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
              royalBlue

	^ self colorNamesDict at: #royalBlue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  salmon

	^ self colorNamesDict at: #salmon! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        seaGreen

	^ self colorNamesDict at: #seaGreen! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
    skyBlue

	^ self colorNamesDict at: #skyBlue! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
      tan

	^ self colorNamesDict at: #tan! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
              teal

	^ self colorNamesDict at: #teal! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
            transparent

	^ self colorNamesDict at: #transparent! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                              turquoise

	^ self colorNamesDict at: #turquoise! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
  veryDarkGray

	^ self colorNamesDict at: #veryDarkGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                            veryLightGray

	^ self colorNamesDict at: #veryLightGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                          veryVeryDarkGray

	^ self colorNamesDict at: #veryVeryDarkGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                    veryVeryLightGray

	^ self colorNamesDict at: #veryVeryLightGray! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
                  violet

	^ self colorNamesDict at: #violet! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
        white

	^ self colorNamesDict at: #white! !
!Colour class methodsFor: 'named colors' stamp: 'jmv 6/18/2017 20:10:01'!
          yellow

	^ self colorNamesDict at: #yellow! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
           cachedColormapForGrayFrom: sourceDepth
	"Return a cached colormap for mapping from the given depth to the 8bpp grays. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| srcIndex map |
	ToGrayColormaps ifNil: [
		ToGrayColormaps _ Array new: 5].
	
	srcIndex _ sourceDepth highBit min: 5.

	(ToGrayColormaps at: srcIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapForGray8bppFrom: sourceDepth.
	ToGrayColormaps at: srcIndex put: map.
	^ map! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
                           cachedColormapFrom: sourceDepth to: destDepth
	"Return a cached colormap for mapping between the given depths. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| srcIndex dstIndex map |
	CachedColormaps
		ifNil: [CachedColormaps _ (1 to: 5) collect: [:i | Array new: 6]].

	srcIndex _ sourceDepth highBit min: 5.
	dstIndex _ destDepth highBit.

	((CachedColormaps at: srcIndex) at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapFrom: sourceDepth to: destDepth.
	(CachedColormaps at: srcIndex) at: dstIndex put: map.
	^ map! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
 cachedColormapFromGrayTo: destDepth
	"Return a cached colormap for mapping from 8bpp grays to the given depth. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| dstIndex map |
	FromGrayColormaps
		ifNil: [FromGrayColormaps _ Array new: 6 ].

	dstIndex _ destDepth highBit.

	(FromGrayColormaps at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapFromGray8bppForDepth: destDepth.
	FromGrayColormaps at: dstIndex put: map.
	^ map! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:57:57'!
 colorMapIfNeededFrom: sourceDepth to: destDepth
	"Return a colormap for mapping between the given depths, or nil if no colormap is needed."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"

	sourceDepth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"

	(sourceDepth >= 16) & (destDepth >= 16) ifTrue: [
		"mapping is done in BitBlt by zero-filling or truncating each color component"
		^ nil].

	^ Colour cachedColormapFrom: sourceDepth to: destDepth
! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
                              computeColorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix
	"Note: The color converting map for sourceDepth=16 and for sourceDepth=32 are the same"
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color.
		Assumed not to include subpixelAA"
		^ self computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	] ifFalse: [
		"source is 16-bit or 32-bit RGB.
		Might include subpixelAA"
		^ self computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	]! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
      computeColormapForGray8bppFrom: sourceDepth
	"Compute a colorMap for translatingfrom the given depth to the 8bpp grays"
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| map |
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color"
		map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))
					collect: [ :c | (c luminance * 255) rounded].
		map _ map as: Bitmap.
		^ map
		]
	ifFalse: [
		^ self computeRGBColormapForGray8 ]! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:10:01'!
                          computeColormapFrom: sourceDepth to: destDepth
	"Compute a colorMap for translating between the given depths. A colormap is a Bitmap whose entries contain the pixel values for the destination depth. Typical clients use cachedColormapFrom:to: instead."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| map bitsPerColor |
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color"
		map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))
					collect: [:c | c pixelValueForDepth: destDepth].
		map _ map as: Bitmap.
	] ifFalse: [
		"source is 16-bit or 32-bit RGB"
		destDepth > 8
			ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
			ifFalse: [bitsPerColor _ 4].
		map _ self computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor].

	"Note: zero is transparent except when source depth is one-bit deep"
	sourceDepth > 1 ifTrue: [map at: 1 put: 0].
	^ map
! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:58:29'!
                           computeColormapFromGray8bppForDepth: destDepth
	"Return a colormap for displaying a GrayForm at the given depth"

	| newMap |
	newMap _ Bitmap new: 256.
	1 to: 256 do: [ :i |
		newMap
			at: i
			put: ((Colour gray: (i-1) asFloat / 255.0) pixelValueForDepth: destDepth)].
	^ newMap! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:58:33'!
                            computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	| map |
	
	map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth)) collect: [ :cc | | f c |
		f _ 1.0 - (cc red + cc green + cc blue / 3.0 ).
		c _ targetColor
			ifNotNil: [
				destDepth = 32
					ifTrue: [ targetColor * f alpha: f]
					ifFalse: [ targetColor alphaMixed: f*1.5 with: Colour white ]]
			ifNil: [ cc ].
		destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f = 0.0
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]]].
	map _ map as: Bitmap.
	^map! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:58:41'!
                           computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: Preferences aaFontsColormapDepth.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Colour
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: Colour white ]]]
			ifNil: [ Colour r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:58:48'!
                        computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| mask map c |
	(#(3 4 5) includes: bitsPerColor)
		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Colour
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c pixelValueForDepth: destDepth)].

	map at: 1 put: (Colour transparent pixelWordForDepth: destDepth).  "zero always transparent"
	^ map
! !
!Colour class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 20:58:56'!
                        computeRGBColormapForGray8
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to 8bpp grays, using the default number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| bitsPerColor mask map c |
	bitsPerColor _ 5.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Colour
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c luminance * 255) rounded].

	^ map! !
!Colour class methodsFor: 'other' stamp: 'jmv 6/18/2017 20:10:01'!
                             maskingMap: depth
	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero. Cache the most recently used map."
	"Warning: The behavior is incorrect if depth = 32.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| sizeNeeded |
	depth <= 8
		ifTrue: [sizeNeeded _ 1 bitShift: depth]
		ifFalse: [sizeNeeded _ 4096].

	(MaskingMap == nil or: [MaskingMap size ~= sizeNeeded]) ifTrue:
		[MaskingMap _ Bitmap new: sizeNeeded withAll: 16rFFFFFFFF.
		MaskingMap at: 1 put: 0.  "transparent"].

	^ MaskingMap
! !
!Colour class methodsFor: 'color from user' stamp: 'jmv 6/18/2017 20:58:07'!
                    colorPaletteForDepth: depth extent: chartExtent
	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorPaletteForDepth: 16 extent: 190@60) display"

	| basicHue x y startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [ :h |
		basicHue _ Colour h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [ :n | | c |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Colour white.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [ :n | | c |
 			c _ Colour black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [ :n | | c |
 		c _ Colour black mixed: (n asFloat / (vSteps*2) asFloat) with: Colour white.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Colour class methodsFor: 'color from user' stamp: 'jmv 6/18/2017 20:58:24'!
      colorTest: depth extent: chartExtent colorMapper: colorMapper
	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 7) asInteger / 7
			g: (c green * 7) asInteger / 7
			b: (c blue * 3) asInteger / 3]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 5) asInteger / 5
			g: (c green * 5) asInteger / 5
			b: (c blue * 5) asInteger / 5]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 15) asInteger / 15
			g: (c green * 15) asInteger / 15
			b: (c blue * 15) asInteger / 15]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 31) asInteger / 31
			g: (c green * 31) asInteger / 31
			b: (c blue * 31) asInteger / 31]) display"

	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |
		basicHue _ Colour h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [:n |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Colour white.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [:n |
 			c _ Colour black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [:n |
 		c _ Colour black mixed: (n asFloat / (vSteps*2) asFloat) with: Colour white.
		c _ colorMapper value: c.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 20:10:01'!
                             colorNames
	"Answer the current dictionary of  name->color associations."

	^self colorNamesDict keys! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 20:59:02'!
        defaultColorNamesDictionary
	"Answer a amall but  useful name->color dictionary"
	
	| defaultDict |
	"Meld most used xkcd colors into traditional colors."
	defaultDict := (self traditionalColorNamesDictionary addAll: 
					self xkcdFirst48ColorNamesDictionary; 
					yourself).
		
	"Override traditional names existing in extended XKCD naming"
	defaultDict at: #lightYellow    put: (Colour r: 1.0 g: 0.996 b: 0.478).
	defaultDict at: #lightOrange   put: (Colour r: 0.992 g: 0.667 b: 0.283).
	defaultDict at: #lightCyan        put: (Colour r: 0.674 g: 1.0 b: 0.988).
	defaultDict at: #lightRed          put: (Colour r: 1.0 g: 0.279 b: 0.298).
	defaultDict at: #lightMagenta put: (Colour r: 0.98 g: 0.372 b: 0.969).
	
	^defaultDict! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 20:59:12'!
                    doesNotUnderstand: aMessage
	"Some code takes
		 Color colorNames 
	and does
		Color perform: aColorname.
		
	Make this work."

	^(Colour colorNamesDict) 
		at: (aMessage selector)
		ifAbsent: [super doesNotUnderstand: aMessage]! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 20:10:01'!
         exactColorNamed: aColorName

	"Answer color matching name or nil 
	from my ColorName->Color Dictionary"
	
	^ self colorNamesDict at: (aColorName asSymbol) ifAbsent: [nil]! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 20:59:55'!
   setColorNamesDict: aNameColorDictionary
	"Answer the current dictionary of  name->color associations."
	
	"Note: This is a non-standard name because this is a non-standard action!!
	Do this if you really, really know what you are doing."
	
	"Some Colors are required for proper system operation"
	Colour defaultColorNamesDictionary keysAndValuesDo: [ :colorName :colorValue |
		aNameColorDictionary at: colorName ifAbsentPut: colorValue
	].

	ColorNamesDict := aNameColorDictionary! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 21:01:08'!
            traditionalColorNamesDictionary
	"Answer a dictionary of Squeak traditional name->color associations.."

	| nameDict |
	nameDict _ Dictionary new.
	nameDict at: #black put: (Colour r: 0 g: 0 b: 0).
	nameDict at: #veryVeryDarkGray put: (Colour r: 0.125 g: 0.125 b: 0.125).
	nameDict at: #veryDarkGray put: (Colour r: 0.25 g: 0.25 b: 0.25).
	nameDict at: #darkGray put: (Colour r: 0.375 g: 0.375 b: 0.375).
	nameDict at: #gray put: (Colour r: 0.5 g: 0.5 b: 0.5).
	nameDict at: #lightGray put: (Colour r: 0.625 g: 0.625 b: 0.625).
	nameDict at: #veryLightGray put: (Colour r: 0.75 g: 0.75 b: 0.75).
	nameDict at: #veryVeryLightGray put: (Colour r: 0.875 g: 0.875 b: 0.875).
	nameDict at: #white put: (Colour r: 1.0 g: 1.0 b: 1.0).
	nameDict at: #red put: (Colour r: 1.0 g: 0 b: 0).
	nameDict at: #yellow put: (Colour r: 1.0 g: 1.0 b: 0).
	nameDict at: #green put: (Colour r: 0 g: 1.0 b: 0).
	nameDict at: #cyan put: (Colour r: 0 g: 1.0 b: 1.0).
	nameDict at: #blue put: (Colour r: 0 g: 0 b: 1.0).
	nameDict at: #magenta put: (Colour r: 1.0 g: 0 b: 1.0).
	nameDict at: #brown put: (Colour r: 0.6 g: 0.2 b: 0).
	nameDict at: #orange put: (Colour r: 1.0 g: 0.6 b: 0).
	nameDict at: #lightRed put: (Colour r: 1.0 g: 0.8 b: 0.8).
	nameDict at: #lightYellow put: (Colour r: 1.0 g: 1.0 b: 0.8).
	nameDict at: #lightGreen put: (Colour r: 0.8 g: 1.0 b: 0.6).
	nameDict at: #lightCyan put: (Colour r: 0.4 g: 1.0 b: 1.0).
	nameDict at: #lightBlue put: (Colour r: 0.8 g: 1.0 b: 1.0).
	nameDict at: #lightMagenta put: (Colour r: 1.0 g: 0.8 b: 1.0).
	nameDict at: #lightBrown put: (Colour r: 1.0 g: 0.6 b: 0.2).
	nameDict at: #lightOrange put: (Colour r: 1.0 g: 0.8 b: 0.4).
	nameDict at: #transparent put: (TranslucentColour r: 0.0 g: 0.0 b: 0.0 alpha: 0.0).
	
	^nameDict
! !
!Colour class methodsFor: 'color name lookup' stamp: 'jmv 6/18/2017 21:01:38'!
                 xkcdFirst48ColorNamesDictionary
	"XKCD color names are based on a survey oc colors people call by the same name.
	 http://blog.xkcd.com/2010/05/03/color-survey-results/"

	"Answer a dictionary of the most agreed upon first 48 xkcd colors"
"
	Color xkcdFirst48ColorNamesDictionary explore.
"	
	| xkcdDict |
	xkcdDict := Dictionary new
	at: #lightPink put: (Colour fromString: '#ffd1df') ;
	at: #mustard put: (Colour fromString: '#ceb301') ;
	at: #indigo put: (Colour fromString: '#380282') ;
	at: #lime put: (Colour fromString: '#aaff32') ;
	at: #seaGreen put: (Colour fromString: '#53fca1') ;
	at: #periwinkle put: (Colour fromString: '#8e82fe') ;
	at: #darkPink put: (Colour fromString: '#cb416b') ;
	at: #oliveGreen put: (Colour fromString: '#677a04') ;
	at: #peach put: (Colour fromString: '#ffb07c') ;
	at: #paleGreen put: (Colour fromString: '#c7fdb5') ;
	at: #lightBrown put: (Colour fromString: '#ad8150') ;
	at: #hotPink put: (Colour fromString: '#ff028d') ;
	at: #black put: (Colour fromString: '#000000') ;
	at: #lilac put: (Colour fromString: '#cea2fd') ;
	at: #navyBlue put: (Colour fromString: '#001146') ;
	at: #royalBlue put: (Colour fromString: '#0504aa') ;
	at: #beige put: (Colour fromString: '#e6daa6') ;
	at: #salmon put: (Colour fromString: '#ff796c') ;
	at: #olive put: (Colour fromString: '#6e750e') ;
	at: #maroon put: (Colour fromString: '#650021') ;
	at: #brightGreen put: (Colour fromString: '#01ff07') ;
	at: #darkPurple put: (Colour fromString: '#35063e') ;
	at: #mauve put: (Colour fromString: '#ae7181') ;
	at: #forestGreen put: (Colour fromString: '#06470c') ;
	at: #aqua put: (Colour fromString: '#13eac9') ;
	at: #cyan put: (Colour fromString: '#00ffff') ;
	at: #tan put: (Colour fromString: '#d1b26f') ;
	at: #darkBlue put: (Colour fromString: '#00035b') ;
	at: #lavender put: (Colour fromString: '#c79fef') ;
	at: #turquoise put: (Colour fromString: '#06c2ac') ;
	at: #darkGreen put: (Colour fromString: '#033500') ;
	at: #violet put: (Colour fromString: '#9a0eea') ;
	at: #lightPurple put: (Colour fromString: '#bf77f6') ;
	at: #limeGreen put: (Colour fromString: '#89fe05') ;
	at: #grey put: (Colour fromString: '#929591') ;
	at: #skyBlue put: (Colour fromString: '#75bbfd') ;
	at: #yellow put: (Colour fromString: '#ffff14') ;
	at: #magenta put: (Colour fromString: '#c20078') ;
	at: #lightGreen put: (Colour fromString: '#96f97b') ;
	at: #orange put: (Colour fromString: '#f97306') ;
	at: #teal put: (Colour fromString: '#029386') ;
	at: #lightBlue put: (Colour fromString: '#95d0fc') ;
	at: #red put: (Colour fromString: '#e50000') ;
	at: #brown put: (Colour fromString: '#653700') ;
	at: #pink put: (Colour fromString: '#ff81c0') ;
	at: #blue put: (Colour fromString: '#0343df') ;
	at: #green put: (Colour fromString: '#15b01a') ;
	at: #purple put: (Colour fromString: '#7e1e9c') ;
  	yourself.

	^xkcdDict

! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                   blueColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueColorDict explore.
"
	^self blueColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
  blueColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlue)
				or: [assoc key asString asLowercase includesSubString: 'blue'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                blueGreenColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueGreenColorDict explore.
"
	^self blueGreenColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                   blueGreenColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlueGreen)
				or: [assoc key asString asLowercase includesSubString: 'bluegreen'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
 brightColorDict
	"Answer a dictionary of named colors considered Bright"
"
	Color brightColorDict explore.
"
	^self brightColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                          brightColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isBright) ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                  brownColorDict
	"Answer a dictionary of named colors considered Brown"
"
	Color brownColorDict explore.
"
	^self brownColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                              brownColorDict: aColorDict
	"Answer a dictionary of named colors considered Brown"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBrown)
				or: [assoc key asString asLowercase includesSubString: 'brown'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
            darkColorDict
	"Answer a dictionary of named colors considered Dark"
"
	Color darkColorDict explore.
"
	^self darkColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
  darkColorDict: aColorDict
	"Answer a dictionary of named colors considered Dark"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isDark) ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                        grayColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                greenColorDict
	"Answer a dictionary of named colors considered Green"
"
	Color greenColorDict explore.
"
	^self greenColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                              greenColorDict: aColorDict
	"Answer a dictionary of named colors considered Green"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGreen)
				or: [assoc key asString asLowercase includesSubString: 'green'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
            greyColorDict
	"Answer a dictionary of named colors considered Grey"
"
	Color greyColorDict explore.
"
	^self greyColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
  greyColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                lightColorDict
	"Answer a dictionary of named colors considered light"
"
	Color lightColorDict explore.
"
	^self lightColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                              lightColorDict: aColorDict
	"Answer a dictionary of named colors considered Liight"

	^self brightColorDict: aColorDict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                              orangeColorDict
	"Answer a dictionary of named colors considered Orange"
"
	Color orangeColorDict explore.
"
	^self orangeColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                          orangeColorDict: aColorDict
	"Answer a dictionary of named colors considered Orange"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isOrange)
				or: [assoc key asString asLowercase includesSubString: 'orange'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
        pastelColorDict
	"Answer a dictionary of named colors considered Pastel"
"
	Color pastelColorDict explore.
"
	^self pastelColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                          pastelColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isPastel) ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                  pinkColorDict
	"Answer a dictionary of named colors considered Pink"
"
	Color pinkColorDict explore.
"
	^self pinkColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
  pinkColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isPink)
				or: [assoc key asString asLowercase includesSubString: 'pink'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                purpleColorDict
	"Answer a dictionary of named colors considered Purple"
"
	Color purpleColorDict explore.
"
	^self purpleColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                          purpleColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc key asString asLowercase includesSubString: 'purple')
				or: [assoc key asString asLowercase includesSubString: 'violet'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
    redColorDict
	"Answer a dictionary of named colors considered Red"
"
	Color redColorDict explore.
"
	^self redColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
      redColorDict: aColorDict
	"Answer a dictionary of named colors considered Red"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isRed)
				or: [assoc key asString asLowercase includesSubString: 'red'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                    saturatedColorDict
	"Answer a dictionary of named colors considered Saturated"
"
	Color saturatedColorDict explore.
"
	^self saturatedColorDict: (self colorNamesDict )! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
              saturatedColorDict: aColorDict
	"Answer a dictionary of named colors considered Saturated"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isSaturated) ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
         yellowColorDict
	"Answer a dictionary of named colors considered Yellow"
"
	Color yellowColorDict explore.
"
	^self yellowColorDict: (self colorNamesDict)! !
!Colour class methodsFor: 'selection' stamp: 'jmv 6/18/2017 20:10:01'!
                           yellowColorDict: aColorDict
	"Answer a dictionary of named colors considered Yellow"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isYellow)
				or: [assoc key asString asLowercase includesSubString: 'yellow'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Colour class methodsFor: 'color space conversions' stamp: 'jmv 6/18/2017 20:10:01'!
                          applySimpleGamma: gamma to: value
	"Encode / decode Gamma. Typical gamma are 0.4545 ( = 1.0 / 2.2, for encoding) and 2.2 (for decoding)
	In a non gamma encoded image, the pixel values are proportional to luminance, i.e. the actual light intensity, the photon count.
	In an gamma encoded image, the pixel value is close to the average perceived brightness, or 'lightness'. This optimizes the use of available bits in digital images, and dynamic range in analog images and film. This is like the 'luma' signal in video.

	Usually:
		- Images stored in file formats such as jpg, png, tiff and bmp are gamma encoded
				(unless they are actually raw images).
		- Images sent to a framebuffer (video memory) should be gamma encoded.
		- Raw images from sensors are not gamma encoded.

		- Image processing algorithms that simulate the real world, or are applied to real world data should work on unencoded (linear) images.
				This includes filtering, resizing, blending, and most operations done on images.
				This means that if the images come from jpg photos from a camera, they should be gamma decoded.
		- Image processing algorithms that works on human perception should work on gamma encoded images.
				This includes histograms, histogram equalization, bit allocation (i.e. quantization), compression, etc.
				This also includes detecting objects like a human would do
				

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html

	Mostly for documentation.
	value must be in [0.0 .. 1.0].
	Note that the sRGB standard specifies a function that is close to this, but slightly different.
	See #linearTosRGBGamma: and #sRGBGammaToLinear:"

	^ value raisedTo: gamma! !
!Colour class methodsFor: 'color space conversions' stamp: 'jmv 6/18/2017 20:10:01'!
        linearTosRGBGamma: value
	"The sRGB standard specifies a gamma curve that is close to gamma = 2.2, but is actually
	built from one stright line segment, and a curve with exponent = 2.4.
	This method converts value from linearSpace to gammaSpace, i.e. it 'encodes' with gamma.
	This is the operation done when producing an 8bit Form for displaying, or for saving on a JPG, PNG, etc; if source data is in linear space (for example, from raw data a sensor image, or data that was converted previously to linear space for proper image processing).
	value must be in [0.0 .. 1.0].

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html
		http://entropymine.com/imageworsener/srgbformula
	
	| r v |
	r _ Random new.
	1000 timesRepeat: [
		v _ r next.
		self assert: ((Color sRGBGammaToLinear: (Color linearTosRGBGamma: v)) closeTo: v) ]

	| r |
	r _ 10@10 extent: 600@400.
	Display fill: r fillColor: Color white.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color linearTosRGBGamma: v ]) in: r color: Color black min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color applySimpleGamma: 1/2.2 to: v ]) in: r color: Color blue min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color sRGBGammaToLinear: v ]) in: r color: Color black min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color applySimpleGamma: 2.2 to: v ]) in: r color: Color blue min: 0.0 max: 1.0.
	"

	^ value <= 0.00313066844250063
		ifTrue: [ value * 12.92 ]
		ifFalse: [ (value raisedTo: 1.0/2.4) * 1.055 - 0.055 ]! !
!Colour class methodsFor: 'color space conversions' stamp: 'jmv 6/18/2017 20:10:01'!
            sRGBGammaToLinear: value
	"The sRGB standard specifies a gamma curve that is close to gamma = 2.2, but is actually
	built from one stright line segment, and a curve with exponent = 2.4.
	This method converts value from gammaSpace to linearSpace, i.e. it 'decodes'.
	This is the operation done by display screens. It is also needed to convert 8bit Forms (from a frameBuffer, or from PNG, JPG, etc.) to linear space for proper image processing.
	value must be in [0.0 .. 1.0].

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html
		http://entropymine.com/imageworsener/srgbformula
	"

	^ value <= 0.0404482362771082
		ifTrue: [ value / 12.92 ]
		ifFalse: [ value + 0.055 / 1.055 raisedTo: 2.4 ]! !
!Colour class methodsFor: 'cached state access' stamp: 'jmv 6/18/2017 20:10:01'!
                        colorNamesDict
	"Answer the current dictionary of  name->color associations."
"
	Color colorNamesDict explore.
"
	ColorNamesDict ifNil: [
		self setColorNamesDict: self defaultColorNamesDictionary ].
	^ColorNamesDict! !
!Colour class methodsFor: 'cached state access' stamp: 'jmv 6/18/2017 20:10:01'!
                   grayToIndexMap
	"
	Color grayToIndexMap explore.
	"
	GrayToIndexMap ifNil: [
		self initializeGrayToIndexMap ].
	^GrayToIndexMap! !
!Colour class methodsFor: 'cached state access' stamp: 'jmv 6/18/2017 20:10:01'!
           indexedColors
	"
	Color indexedColors explore.
	"
	IndexedColors ifNil: [
		self initializeIndexedColors ].
	^IndexedColors! !
!Colour class methodsFor: 'cached state access' stamp: 'jmv 6/18/2017 20:10:01'!
                releaseClassCachedState
	"
	Color releaseClassCachedState
	"
	CachedColormaps _ nil. 		"Maps to translate between color depths"
	ToGrayColormaps _ nil.			"Maps colors to 8bpp grays for various color depths"
	FromGrayColormaps _ nil.		"Maps from 8bpp grays to colors of various depths"
	MaskingMap _ nil. 				"Maps all colors except transparent to black for creating a mask"
	ColorNamesDict _ nil.
	IndexedColors _ nil.
	GrayToIndexMap _ nil! !
!TranslucentColour methodsFor: 'accessing' stamp: 'jmv 6/18/2017 20:41:17'!
                        alpha
	"Return my alpha value, a number between 0.0 and 1.0 where 0.0 is completely transparent and 1.0 is completely opaque."

	^ self at: 4! !
!TranslucentColour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:08'!
    storeArrayValuesOn: aStream

	self isTransparent ifTrue: [
		^ aStream space].
	super storeArrayValuesOn: aStream.
	aStream space.
	self alpha printOn: aStream fractionDigits: 3! !
!TranslucentColour methodsFor: 'printing' stamp: 'jmv 6/18/2017 20:10:08'!
storeOn: aStream

	self isTransparent ifTrue: [^ aStream nextPutAll: '(Color transparent)'].
	aStream
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll: ' r: '.
	self red printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' g: '.
	self green printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' b: '.
	self blue printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' alpha: '.
	self alpha printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ')'! !
!TranslucentColour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:55:03'!
                    alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifTrue: [
		^ Colour new
			setRed: self red
			green: self green
			blue: self blue].
	^ super alpha: alphaValue! !
!TranslucentColour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:08'!
            asNontranslucentColor
	^ self alpha: 1.0! !
!TranslucentColour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:10:08'!
      bitPatternForDepth: depth
	"Return an appropriate bit pattern. This will almost never be meaningful for tranlucentColors, except for the degenerate case of tranparency."

	self isTransparent ifTrue: [
		^ Bitmap with: 0].
	^ super bitPatternForDepth: depth! !
!TranslucentColour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:41:47'!
              pixelValueForDepth: d
	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."
	| basicPixelWord |
	"In 32bpp, if alpha = 0, ignore any color components, and answer R=0, G=0, B=0, Alpha=0.
	In depths > 8 and < 32, pixelValue zero is the special value used by BitBlt to denote transparent."
	self isTransparent ifTrue: [
		^ 0].
	basicPixelWord _ super pixelValueForDepth: d.
	^d < 32
		ifTrue: [ basicPixelWord ]
		ifFalse: [ (basicPixelWord bitAnd: 16rFFFFFF) bitOr:
			((self alpha*255.0) rounded
				bitShift: 24) ]! !
!TranslucentColour methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:41:50'!
                           pixelWordForDepth: depth
	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."

	| basicPixelWord |
	self isTransparent ifTrue: [^ 0].
	basicPixelWord _ super pixelWordForDepth: depth.
	^depth < 32
		ifTrue: [ basicPixelWord ]
		ifFalse: [ (basicPixelWord bitAnd: 16rFFFFFF) bitOr:
			((self alpha*255.0) rounded
				bitShift: 24) ]! !
!TranslucentColour methodsFor: 'private' stamp: 'jmv 6/18/2017 20:42:05'!
                      setRed: r green: g blue: b alpha: alphaValue

	self basicSetRed: r green: g blue: b.
	self at: 4 put: alphaValue! !
!TranslucentColour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:41:26'!
  isOpaque

	^self alpha = 1.0! !
!TranslucentColour methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:41:54'!
                      isTransparent
	^ self alpha = 0.0! !
!TranslucentColour methodsFor: 'please remove' stamp: 'jmv 6/18/2017 21:27:51'!
           setRed: r green: g blue: b alpha: alphaValue colorSpace: aSymbol
	^ self setRed: r green: g blue: b alpha: alphaValue! !
!TranslucentColour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:54:35'!
             new
	^ self new: 4! !
!TranslucentColour class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:57:08'!
                r: r g: g b: b alpha: alphaValue
	"Return a color with the given r, g, and b components in the range [0.0..1.0]."

	^ self new
		setRed: r
		green: g
		blue: b
		alpha: alphaValue! !
!FloatArray methodsFor: 'comparing' stamp: 'jmv 6/18/2017 20:25:14' prior: 16846542!
                    = another 
	self == another ifTrue: [ ^ true ].
	self class == another class ifFalse: [ ^ false ].
	^self primitiveEqual: another! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3105-FloatArrayColour-JuanVuletich-2017Jun19-09h57m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3103] on 19 June 2017 at 11:11:02 am'!
!Integer methodsFor: 'converting' stamp: 'ar 10/31/1998 23:04' prior: 16859466!
   asColorOfDepth: d
	"Return a color value representing the receiver as color of the given depth"
	^Colour colorFromPixelValue: self depth: d! !
!InputSensor methodsFor: 'keyboard' stamp: 'jmv 9/2/2016 11:08:09' prior: 16856307!
                             kbdTest
	"
	Sensor kbdTest
	"
	"This test routine will print the unmodified character, its keycode,
	and the OR of all its modifier bits, until the character x is typed

Also useful:
	Sensor test
	"
	| char |
	char _ nil.
	[ char = $x ] whileFalse: [
		[ self keyboardPressed ] whileFalse.
		char _ self keyboard.
		Display fill: (5@5 extent: 400@20) fillColor: Colour white.
		(String streamContents: [ :s |
			s
				nextPut: $-;
				nextPut: char;
				nextPut: $-;
				space;
				print: char numericValue;
				space.
			self isMouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].
			self isMouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].
			self isMouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].
			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].
			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].
			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].
			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ]])
		displayAt: 10 @ 10 ].! !
!String methodsFor: 'displaying' stamp: 'jmv 5/12/2015 15:52' prior: 16917036!
                             displayOn: aDisplayMedium at: aPoint 
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."

	^self displayOn: aDisplayMedium at: aPoint textColor: Colour black
	"
	'Display' displayOn: Display at: 10@10
	"! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/25/2016 15:31' prior: 16922270!
                  reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	PasteUpMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	Preferences useNoIcons.
	Theme current initialize.
	Theme content: nil.
	Colour shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
"	ColorPickerMorph class removeSelector: #buildEyedropperIcon."
	Theme removeSelector: #miscellaneousIcons.
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont removeMostFonts.
	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 7/28/2015 08:26' prior: 16938828!
                       endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d _ textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ textComposition characterBlockAtPoint:
			0@0 + (0@(d+AbstractFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		textComposition: textComposition
		bounds: (4@4 + frame topLeft extent: Display extent)
		color: Colour black
		selectionColor: Colour blue.
	DisplayScreen screenUpdateRequired: nil! !
!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12' prior: 16938904!
           black
	Display depth = 1 ifTrue: [^ Bitmap with: 16rFFFFFFFF "Works without color support"].
	^ Colour black! !
!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12' prior: 16938910!
 white
	Display depth = 1 ifTrue: [^ Bitmap with: 0 "Works without color support"].
	^ Colour white! !
!DataStream class methodsFor: 'as yet unclassified' stamp: '' prior: 16827931!
           example
    "An example and test of DataStream/ReferenceStream.
     11/19/92 jhm: Use self testWith:."
    "DataStream example"
    "ReferenceStream example"
    | input sharedPoint |

    "Construct the test data."
    input _ Array new: 9.
    input at: 1 put: nil.
    input at: 2 put: true.
    input at: 3 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 3) fillWithColor: Colour lightBlue.
    input at: 4 put: #(3 3.0 'three').
    input at: 5 put: false.
    input at: 6 put: 1024 @ -2048.
    input at: 7 put: #x.
    input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
    input at: 9 put: sharedPoint.

    "Write it out, read it back, and return it for inspection."
    ^ self testWith: input! !
!ReferenceStream class methodsFor: 'as yet unclassified' stamp: '' prior: 16900040!
                              example2
"Here is the way to use DataStream and ReferenceStream:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	rr nextPut: <your object>.
	rr close.

To get it back:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	<your object> _ rr next.
	rr close.
"
"An example and test of DataStream/ReferenceStream.
	 11/19/92 jhm: Use self testWith:."
	"ReferenceStream example2"
	| input sharedPoint |

	"Construct the test data."
	input _ Array new: 9.
	input at: 1 put: nil.
	input at: 2 put: true.
	input at: 3 put: false.
	input at: 4 put: #(-4 -4.0 'four' four).
	input at: 5 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 5) fillWithColor: Colour lightOrange.
	input at: 6 put: 1024 @ -2048.
	input at: 7 put: input. "a cycle"
	input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
	input at: 9 put: sharedPoint.

	"Write it out, read it back, and return it for inspection."
	^ self testWith: input
! !
!TextEditor methodsFor: 'attributes' stamp: 'jmv 6/18/2017 21:32:55' prior: 16931569!
                            offerColorMenu
	"Present a menu of available colors, and if one is chosen, apply it to the current selection."
	"This is a user command, and generates undo"

	| attribute colors index thisSel |
	thisSel _ self selection.
	colors _ #(#black #magenta #red #yellow #green #blue #cyan #white ).
	index _ (PopUpMenu
		labelArray: colors , #('choose color...' )
		lines: (Array with: colors size + 1)) startUpMenu.
	index = 0 ifTrue: [ ^ true ].
	index <= colors size
		ifTrue: [ attribute _ TextColor color: (Colour perform: (colors at: index)) ]
		ifFalse: [
			index _ index - colors size - 1.
			"Re-number!!!!!!"
			index = 0 ifTrue: [ attribute _ self chooseColor ].
			thisSel ifNil: [ ^ true ]].
	attribute ifNotNil: [ self applyAttribute: attribute ].
	^ true.! !
!TextAction class methodsFor: 'as yet unclassified' stamp: 'jmv 4/19/2015 09:38' prior: 16930008!
                               textActionColor
	^Colour r: 0.4 g: 0 b: 1.0! !
!TextColor methodsFor: 'testing' stamp: 'jmv 1/21/2011 11:33' prior: 16930362!
  isSet
	"Do not include Colour black, as it is the default color."
	^color ~= Colour black! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930372!
                               black
	^ self new color: Colour black! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930375!
                   blue
	^ self new color: Colour blue! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930378!
                     cyan
	^ self new color: Colour cyan! !
!TextColor class methodsFor: 'constants' stamp: 'ajh 9/10/2002 02:26' prior: 16930382!
  gray
	^ self new color: Colour gray! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930385!
                     green
	^ self new color: Colour green! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930388!
                   magenta
	^ self new color: Colour magenta! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930391!
               red
	^ self new color: Colour red! !
!TextColor class methodsFor: 'constants' stamp: 'sma 3/24/2000 10:50' prior: 16930395!
    white 
	^ self new color: Colour white! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 16930398!
                  yellow
	^ self new color: Colour yellow! !
!Preferences class methodsFor: 'halos' stamp: 'jmv 6/18/2017 21:33:44' prior: 16893209!
                             installHaloSpecsFromArray: anArray

	| aColour |
	^ self parameters at: #HaloSpecs put: (anArray collect: [ :each |
				aColour _ Colour.
				each fourth do: [ :sel | aColour _ aColour perform: sel].
				HaloSpec new 
					horizontalPlacement: each second
					verticalPlacement: each third 
					color: aColour
					iconSymbol: each fifth
					addHandleSelector: each first
					hoverHelp: each sixth])! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/19/2016 20:45:55' prior: 16938476!
             displayOn: aForm in: aRectangle
	"
	Transcript displayOn: Display
	"
	| font count i string x y fh f canvas innerR |
	aForm fill: aRectangle fillColor: Colour white.
	font _ AbstractFont default.

	innerR _ aRectangle insetBy: self padding.
	fh _ font height.
	count _ innerR height // fh-1.
	x _ innerR left.
	y _ innerR top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	canvas _ aForm getCanvas.
	canvas newClipRect: innerR.
	[
		string _ entries at: i.	
		canvas drawString: string at: x@y font: font color: Colour veryDarkGray.
		y _ y + fh.
		i = lastIndex
	] whileFalse: [ i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.
	canvas drawString: string at: x@y font: font color: Colour veryDarkGray! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/19/2016 20:53:35' prior: 16938512!
                    displayUnfinishedEntryOn: aForm

	| font count string x y fh canvas r innerR |
	innerR _ bounds insetBy: self padding.
	lastDisplayPosition < innerR right ifTrue: [
		font _ AbstractFont default.
		fh _ font height.
		count _ innerR height // fh-1.
		x _ innerR left.
		string _ unfinishedEntry contents.
		y _ ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font height + innerR top.
		canvas _ aForm getCanvas.
		r _ innerR left: lastDisplayPosition.
		canvas newClipRect: r.
		(canvas drawString: string at: x@y font: font color: Colour veryDarkGray) ifNotNil: [ :lastPoint |
			lastDisplayPosition _ lastPoint x.
			^r ]].
	^nil! !
!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:40' prior: 16846838!
        dominantColor
	| tally max maxi |
	self depth > 16 ifTrue:
		[^(self asFormOfDepth: 16) dominantColor].
	tally _ self tallyPixelValues.
	max _ maxi _ 0.
	tally withIndexDo: [:n :i | n > max ifTrue: [max _ n. maxi _ i]].
	^ Colour colorFromPixelValue: maxi - 1 depth: self depth! !
!Form methodsFor: 'bordering' stamp: 'jmv 1/22/2015 10:22' prior: 16847019!
                           border: aRectangle width: borderWidth 
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of the border of each side is borderWidth. Uses black for 
	drawing the border."

	self border: aRectangle width: borderWidth fillColor: Colour black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 16847087!
       fillBlack
	"Set all bits in the receiver to black (ones)."

	self fill: self boundingBox fillColor: Colour black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 16847093!
 fillBlack: aRectangle 
	"Set all bits in the receiver's area defined by aRectangle to black (ones)."

	self fill: aRectangle rule: Form over fillColor: Colour black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 16847109!
             fillGray
	"Set all bits in the receiver to gray."

	self fill: self boundingBox fillColor: Colour gray! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 16847115!
           fillGray: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to the gray mask."

	self fill: aRectangle rule: Form over fillColor: Colour gray! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 16847146!
               fillWhite
	"Set all bits in the form to white."

	self fill: self boundingBox fillColor: Colour white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 16847152!
            fillWhite: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to white."

	self fill: aRectangle rule: Form over fillColor: Colour white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 16847165!
                     reverse
	"Change all the bits in the receiver that are white to black, and the ones 
	that are black to white.
	Display reverse
	"

	self fill: self boundingBox rule: Form reverse fillColor: Colour white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 16847174!
      reverse: aRectangle
	"Change all the bits in the receiver's area that intersects with aRectangle 
	that are white to black, and the ones that are black to white."

	self fill: aRectangle rule: Form reverse fillColor: Colour white! !
!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:42' prior: 16847212!
        colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	self depth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"
	^ Colour colorMapIfNeededFrom: self depth to: destDepth
! !
!Form methodsFor: 'color mapping' stamp: 'jmv 5/12/2016 13:53' prior: 16847223!
                          colormapIfNeededForGray8bpp
	"Return a colormap for displaying the receiver at the given depth.
	Note: Uses 5 bits per color component. 32bit Forms will lose information!!"

	^ Colour cachedColormapForGrayFrom: self depth! !
!Form methodsFor: 'color mapping' stamp: 'jmv 6/18/2017 21:31:52' prior: 16847240!
            mapColor: oldColour to: newColor
	"Make all pixels of the given color in this Form to the given new color."
	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."

	| map |
	map _ (Colour cachedColormapFrom: self depth to: self depth) copy.
	map at: (oldColour indexInMap: map) put: (newColor pixelWordForDepth: self depth).
	(BitBlt toForm: self)
		sourceForm: self;
		sourceOrigin: 0@0;
		combinationRule: Form over;
		destX: 0 destY: 0 width: width height: height;
		colorMap: map;
		copyBits.
! !
!Form methodsFor: 'color mapping' stamp: 'jmv 1/31/2011 09:21' prior: 16847262!
          maskingMap
	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Colour maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."
	^Colour maskingMap: self depth! !
!Form methodsFor: 'converting' stamp: 'jm 11/12/97 19:28' prior: 16847299!
             as8BitColorForm
	"Simple conversion of zero pixels to transparent.  Force it to 8 bits."

	| f map |
	f _ ColorForm extent: self extent depth: 8.
	self displayOn: f at: self offset negated.
	map _ Colour indexedColors copy.
	map at: 1 put: Colour transparent.
	f colors: map.
	f offset: self offset.
	^ f
! !
!Form methodsFor: 'pixel access' stamp: 'ar 5/17/2001 15:42' prior: 16848158!
                             colorAt: aPoint
	"Return the color in the pixel at the given point.  "

	^ Colour 
		colorFromPixelValue: (self pixelValueAt: aPoint)
		depth: self depth
! !
!Form methodsFor: 'pixel access' stamp: 'jmv 11/4/2015 12:40' prior: 16848175!
                   colorInterpolatedAt: aPoint
	"Evaluate a bilinear (i.e. cheap) interpolation
	Like OpenCV's CV_INTER_LINEAR
	Answer Colour transparent if outside image bounds.
	Copied almost verbatim from FloatImage.
	Answer Colors with float components. Will be rounded to be stored in, for example, a 32-bit Form."

	| x y w interpolated xWeight1 xWeight0 yWeight1 yWeight0 xIndex0 xIndex1 yIndex0 yIndex1 |
	x _ aPoint x.
	y _ aPoint y.
	x < 0.0 ifTrue: [ ^Colour transparent ].
	xIndex0 _ x truncated. 		"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	xIndex0 > (width-1) ifTrue: [ ^Colour transparent ].
	(xIndex0 = (width-1) and: [ x > (width-1) ]) ifTrue: [ ^Colour transparent ].
	xIndex1 _ xIndex0 = (width-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ xIndex0 + 1 ]
		ifTrue: [ xIndex0 ].

	y < 0.0 ifTrue: [ ^Colour transparent ].
	yIndex0 _ y truncated.			"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	yIndex0 > (height-1) ifTrue: [ ^Colour transparent ].
	(yIndex0 = (height-1) and: [ y > (height-1) ]) ifTrue: [ ^Colour transparent ].
	yIndex1 _ yIndex0 = (height-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ yIndex0 + 1 ]
		ifTrue: [ yIndex0 ].

	xWeight1 _ x - xIndex0.
	xWeight0 _ 1.0 - xWeight1.

	yWeight1 _ y - yIndex0.
	yWeight0 _ 1.0 - yWeight1.

	"/* perform interpolation */"
	w _ ((self colorAt: xIndex0 @ yIndex0) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex0) * xWeight1).
	interpolated _ w * yWeight0.

	w _ ((self colorAt: xIndex0 @ yIndex1) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex1) * xWeight1).
	interpolated _ w * yWeight1 + interpolated.

	^interpolated! !
!Form methodsFor: 'transitions' stamp: 'jmv 7/28/2015 08:32' prior: 16848519!
    pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: Colour black.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceToScreen.
		].

	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceToScreen.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"
! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 9/23/2012 21:44' prior: 16848886!
             dotOfSize: diameter
	"Create a form which contains a round black dot."
	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |
	radius _ diameter//2.
	form _ self extent: diameter@diameter offset: (0@0) - (radius@radius).	
	bb _ (BitBlt toForm: form)
		sourceX: 0; sourceY: 0;
		combinationRule: Form over;
		fillColor: Colour black.
	rect _ form boundingBox.
	centerX _ rect center x.
	centerY _ rect center y.
	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].
	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].
	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.
	xOverY _ rect width asFloat / rect height asFloat.
	maxy _ rect height - 1 // 2.

	"First do the inner fill, and collect x values"
	0 to: maxy do:
		[:dy |
		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.
		bb	destX: centerX - centerXBias - dx
			destY: centerY - centerYBias - dy
			width: dx + dx + centerXBias + 1
			height: 1;
			copyBits.
		bb	destY: centerY + dy;
			copyBits].
	^ form
"
Time millisecondsToRun:
	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]
"! !
!Form class methodsFor: 'instance creation' stamp: 'pb 5/4/2016 17:43' prior: 16849005!
                       fakeSphereAt: aPoint diameter: diameter color: aColor
	"Create a form which contains a round black dot."
	| bb rect d p |
	bb _ GrafPort toForm: Display.
	bb fillColor: aColor.
	bb combinationRule: Form blend.
	rect _ aPoint extent: diameter.
	bb fillOval: rect.
	p _ (diameter * 2 // 5) asPoint + aPoint.
	#(2 3 4 5 6 ) do: [ :i |
		"simulate facade by circles of gray"
		bb fillColor: (Colour white alpha: 0.3).
		d _ i * diameter // 10.
		rect _ Rectangle
			center: p
			extent: d.
		bb fillOval: rect ].
	DisplayScreen screenUpdateRequired: nil.
"
	Form fakeSphereAt: 50@50 diameter: 30 color:  (Colour red alpha: 0.5)
"! !
!Form class methodsFor: 'examples' stamp: 'jmv 3/20/2013 22:36' prior: 16849178!
                          toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ Colour red wheel: 12.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: -40@-40].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:37' prior: 16849256!
  bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:47' prior: 16849283!
                               bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:38' prior: 16849314!
             bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomRight corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:41' prior: 16849341!
         bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 11/30/2010 10:34' prior: 16849371!
                       topLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topLeft corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (w - 1 - x @ (w - 1 - y)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 11/30/2010 10:36' prior: 16849397!
                           topRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topRight corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ Colour white * gradientTopFactor.
	bottomColor _ Colour white * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (x @ (w - y - 1)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!ColorForm methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:45' prior: 16818750!
                  colors: colorList
	"Set my color palette to the given collection."

	| colorArray colorCount newColors |
	colorList ifNil: [
		colors _ cachedDepth _ cachedColormap _ nil.
		^ self].

	colorArray _ colorList asArray.
	colorCount _ colorArray size.
	newColors _ Array new: (1 bitShift: self depth).
	1 to: newColors size do: [:i |
		i <= colorCount
			ifTrue: [newColors at: i put: (colorArray at: i)]
			ifFalse: [newColors at: i put: Colour transparent]].

	colors _ newColors.
	cachedDepth _ nil.
	cachedColormap _ nil.
! !
!ColorForm methodsFor: 'color manipulation' stamp: 'di 11/11/1998 13:20' prior: 16818824!
                        asGrayScale
	"Return a grayscale ColorForm computed by mapping each color into its grayscale equivalent"
	^ self copy colors:
		(colors collect:
			[:c | c isTransparent ifTrue: [c]
						ifFalse: [Colour gray: c luminance]])! !
!ColorForm methodsFor: 'color manipulation' stamp: 'jmv 3/1/2010 09:41' prior: 16818834!
  colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	| newMap |
	colors ifNil: [
		"use the standard colormap"
		^ Colour colorMapIfNeededFrom: self depth to: destDepth].

	(destDepth = cachedDepth and:[cachedColormap isColormap not]) 
		ifTrue: [^ cachedColormap].
	newMap _ Bitmap new: colors size.
	1 to: colors size do: [:i |
		newMap
			at: i
			put: ((colors at: i) pixelValueForDepth: destDepth)].

	cachedDepth _ destDepth.
	^ cachedColormap _ newMap.
! !
!ColorForm methodsFor: 'private' stamp: 'ar 5/17/2001 15:44' prior: 16818940!
           ensureColorArrayExists
	"Return my color palette."

	colors ifNil: [
		self depth > 8 ifTrue: [^ self error: 'ColorForms only support depths up to 8 bits'].
		self colors: (Colour indexedColors copyFrom: 1 to: (1 bitShift: self depth))].
! !
!ColorForm class methodsFor: 'as yet unclassified' stamp: 'jmv 4/10/2015 23:20' prior: 16819047!
             mappingWhiteToTransparentFrom: aFormOrCursor
	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."

	| f map |
	aFormOrCursor depth <= 8 ifFalse: [
		^ self error: 'argument depth must be 8-bits per pixel or less'].
	(aFormOrCursor is: #ColorForm) ifTrue: [
		f _ aFormOrCursor copy.
		map _ aFormOrCursor colors.
	] ifFalse: [
		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.
		f copyBits: aFormOrCursor boundingBox
			from: aFormOrCursor
			at: 0@0
			clippingBox: aFormOrCursor boundingBox
			rule: Form over.
		map _ Colour indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].
	map _ map collect: [:c |
		c = Colour white ifTrue: [Colour transparent] ifFalse: [c]].
	f colors: map.
	^ f
! !
!ColorForm class methodsFor: 'instance creation' stamp: 'jmv 5/4/2016 16:31' prior: 16819074!
                               grayScaleAndTransparentExtent: aPoint
"Native depth"
	"Answer a ColorForm for storing 8bpp gray scale. (do not include any slot for transparent)"

	| grays result |
	result _ self extent: aPoint depth: (Smalltalk isLittleEndian ifTrue: [ -8 ] ifFalse: [ 8 ]).
	grays _ (0 to: 255) collect: [ :brightness | Colour gray: brightness asFloat / 255.0].
	grays at: 1 put: Colour transparent.
	result colors: grays.
	^result! !
!Cursor methodsFor: 'converting' stamp: 'jmv 2/25/2011 19:47' prior: 16825855!
            asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: self fillColor: Colour black at: offset negated.
	^ form offset: offset! !
!CursorWithMask methodsFor: 'converting' stamp: 'jmv 2/25/2011 19:47' prior: 16826695!
           asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: maskForm fillColor: Colour white.
	form fillShape: self fillColor: Colour black at: offset negated.
	^ form offset: offset! !
!GrayForm methodsFor: 'pixel accessing' stamp: 'jmv 5/11/2016 19:57' prior: 16850335!
                         grayAt: aPoint
	"Return the color of the pixel at aPoint."

	^Colour gray: (self pixelValueAt: aPoint) asFloat / 255.0! !
!GrayForm methodsFor: 'color manipulation' stamp: 'jmv 5/12/2016 15:04' prior: 16850359!
             colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	^ Colour cachedColormapFromGrayTo: destDepth! !
!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/24/2005 20:57' prior: 16781762!
                 readColorMap
	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."
	| colorCount colors maxLevel b g r ccStream |
	colorCount := (bfOffBits - 54) // 4.
	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"
	biBitCount >= 16 ifTrue:[^nil].
	colorCount = 0 ifTrue: [ "this BMP file does not have a color map"
		"default monochrome color map"
		biBitCount = 1 ifTrue: [^ Array with: Colour white with: Colour black].
		"default gray-scale color map"
		maxLevel := (2 raisedTo: biBitCount) - 1.
		^ (0 to: maxLevel) collect: [:level | Colour gray: (level asFloat / maxLevel)]].
	ccStream := ReadStream on: (stream next: colorCount*4).
	colors := Array new: colorCount.
	1 to: colorCount do: [:i |
		b := ccStream next.
		g := ccStream next.
		r := ccStream next.
		ccStream next. "skip reserved"
		colors at: i put: (Colour r: r g: g b: b range: 255)].
	^ colors
! !
!BitBlt methodsFor: 'accessing' stamp: 'jmv 3/20/2013 00:50' prior: 16785567!
           fillColor
	"Return the current fill color as a Color.  
	 Gives the wrong answer if the halftoneForm is a complex pattern of more than one word."

	halftoneForm ifNil: [^ Colour black].
	^ Colour colorFromPixelValue: halftoneForm first depth: destForm depth! !
!BitBlt class methodsFor: 'examples' stamp: 'jmv 7/27/2015 17:07' prior: 16786237!
        alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]	
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 _ Colour cachedColormapFrom: Display depth to: 32.
		map32toD _ Colour cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff _ Form extent: 500@50 depth: 32.
	dispToBuff _ BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Colour red alpha: i/10)
						rule: Form blend].
	buffToDisplay _ BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.
	DisplayScreen screenUpdateRequired: nil.

	"Create a brush with radially varying alpha"
	brush _ Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Colour red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor isMouseButton2Pressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor mousePoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor isMouseButton1Pressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor mousePoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) > buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect _ buffRect translatedBy: delta negated.
					newBuffRect
						areasOutside: buffRect
						do: [ :r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin ].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				DisplayScreen screenUpdateRequired: updateRect.
				prevP _ p]]]! !
!WarpBlt methodsFor: 'setup' stamp: 'mtf 8/14/2009 18:21' prior: 16942977!
              cellSize: s
	"Set the number of samples used for averaging"
	cellSize := s.
	cellSize = 1 ifTrue: [^ self].
	"Install the colorMap to used for mapping the averaged RGBA 32bit pixels to the
	destination depth. Note that we need to install the 32->32 color map explicitly because
	the VM will substitute a colorMap derived from sourceForm->destForm mapping which
	is just plain wrong for <32 source and 32bit dest depth"
	(destForm depth = 32 and: [sourceForm notNil] and: [sourceForm depth < 32])
		ifTrue:[colorMap := ColorMap shifts: #(0 0 0 0) masks:#(16rFF0000 16rFF00 16rFF 16rFF000000) colors: nil]
		ifFalse:[colorMap := Colour colorMapIfNeededFrom: 32 to: destForm depth].
! !
!GrafPort methodsFor: 'text' stamp: 'jmv 6/1/2015 13:28' prior: 16850127!
          displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font color: foregroundColor
	"If required, do a second pass with new rule and colorMap.
	Answer last affected pixel position
	Answer nil if nothing was done
	"

	| answer prevRule secondPassMap sourceDepth destDepth |

	"Slight optimization when there's nothing to do."
	clipHeight = 0 ifTrue: [^nil].
	clipWidth = 0 ifTrue: [^nil].

	self installStrikeFont: font foregroundColor: (foregroundColor alpha: 1).

	"If combinationRule is rgbMul, we might need the special two-pass technique for component alpha blending.
	If not, do it simply"
	combinationRule = 37 "rgbMul" ifFalse: [
		^self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font ].
	
	"We need to do a second pass. The colormap set is for use in the second pass."
	secondPassMap _ colorMap.
	sourceDepth _ sourceForm depth.
	destDepth _ destForm depth.
	colorMap _ sourceDepth ~= destDepth
		ifTrue: [ Colour cachedColormapFrom: sourceDepth to: destDepth ].
	answer := self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font.
	colorMap := secondPassMap.
	secondPassMap ifNotNil: [
		prevRule := combinationRule.
		combinationRule := 20. "rgbAdd"
		self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font.
		combinationRule := prevRule ].
	^answer! !
!GrafPort methodsFor: 'private' stamp: 'jmv 5/12/2016 14:52' prior: 16850173!
                             cachedFontColormapFrom1BitTo: destDepth

	| map dstIndex |
	CachedFontColorMaps 
		ifNil: [CachedFontColorMaps _ Array new: 6].

	dstIndex _ destDepth highBit.
	(CachedFontColorMaps at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ (Colour cachedColormapFrom: 1 to: destDepth) copy.
	CachedFontColorMaps at: dstIndex put: map.
	^ map! !
!GrafPort methodsFor: 'private' stamp: 'jmv 5/12/2016 14:55' prior: 16850186!
     colorConvertingMap: targetColour from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix
	"Note: The color converting map for sourceDepth=16 and for sourceDepth=32 are the same"
	
	| srcIndex dstIndex map mapsForSource mapsForSourceAndDest |
	ColorConvertingMaps 
		ifNil: [ColorConvertingMaps _ (1 to: 6) collect: [:i | Array new: 6]].

	srcIndex _ sourceDepth highBit.
	sourceDepth > 8 ifTrue: [ srcIndex _ keepSubPix ifTrue: [5] ifFalse: [6] ].
	dstIndex _ destDepth highBit.
	
	mapsForSource _ ColorConvertingMaps at: srcIndex.
	(mapsForSourceAndDest _ mapsForSource at: dstIndex) ifNil: [
		mapsForSourceAndDest _ mapsForSource at: dstIndex put: Dictionary new ].
	
	map _ mapsForSourceAndDest at: targetColour ifAbsentPut: [
		Colour 
			computeColorConvertingMap: targetColour 
			from: sourceDepth 
			to: destDepth 
			keepSubPixelAA: keepSubPix ].

	^ map! !
!GrafPort methodsFor: 'private' stamp: 'jmv 4/17/2014 16:57' prior: 16850225!
          setRuleAndMapFor: sourceDepth foregroundColor: foregroundColor

	| targetColor destDepth |
	destDepth _ destForm depth.
	halftoneForm _ nil.	"Don't use fillColor. Use a more powerful ColorMap"

	sourceDepth = 1 ifTrue: [
		self combinationRule: Form paint.
		"Set up color map for a different source depth (color font)"
		"Uses caching for reasonable efficiency"
		colorMap _ self cachedFontColormapFrom1BitTo: destDepth.
		colorMap at: 1 put: (destForm pixelValueFor: Colour transparent).
		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]
	
	ifFalse: [
		"Enable subpixel rendering if requested, but never for translucent text:
		This technique always draws opaque text. This could be added, by using an extra colormap for the rgbMul phase...
		So far, no need arised for doing so."
		(sourceDepth > 8 and: [
			Preferences subPixelRenderFonts and: [ foregroundColor = Colour black or: [ 
				Preferences subPixelRenderColorFonts and: [ foregroundColor isOpaque ]]]]) ifTrue: [
			destDepth > 8 ifTrue: [
				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"
				self combinationRule: 37.		"rgbMul"
				colorMap _ (foregroundColor ~= Colour black or: [
						destDepth = 32 and: [ destForm ~~ Display or: [Preferences properDisplayAlphaForFonts] ]]) ifTrue: [
					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"
					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)
					See #displayString:from:to:at:strikeFont:color:"
					"Note: In 32bpp, if we want the correct alpha in the result, we need the second pass, as the destination could have transparent pixels, 
					and we need to add to the alpha channel"
					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
			ifFalse: [
				self combinationRule: 25.		"Paint"
				targetColor _ foregroundColor = Colour black ifFalse: [ foregroundColor ].
				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
		ifFalse: [
			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"
			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).
			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]]! !
!Color methodsFor: 'conversions' stamp: 'bf 4/18/2001 16:25' prior: 16815566!
                         makeForegroundColor
        "Make a foreground color contrasting with me"
        ^self luminance >= 0.5
                ifTrue: [Colour black]
                ifFalse: [Colour white]! !
!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96' prior: 16815760!
                          mix: color2 shades: thisMany
	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red mix: Colour green shades: 12)"

	| redInc greenInc blueInc rr gg bb c out |
	thisMany = 1 ifTrue: [^ Array with: color2].
	redInc _ color2 red - self red / (thisMany-1).
	greenInc _ color2 green - self green / (thisMany-1).
	blueInc _ color2 blue - self blue / (thisMany-1).
	rr _ self red.  gg _ self green.  bb _ self blue.
	out _ (1 to: thisMany) collect: [:num |
		c _ Colour r: rr g: gg b: bb.
		rr _ rr + redInc.
		gg _ gg + greenInc.
		bb _ bb + blueInc.
		c].
	out at: out size put: color2.	"hide roundoff errors"
	^ out
! !
!Color methodsFor: 'groups of shades' stamp: 'di 10/23/2000 09:45' prior: 16815785!
                        wheel: thisMany
	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "

	| sat bri hue step c |
	sat _ self saturation.
	bri _ self brightness.
	hue _ self hue.
	step _ 360.0 / (thisMany max: 1).
	^ (1 to: thisMany) collect: [:num |
		c _ Colour h: hue s: sat v: bri.  "hue is taken mod 360"
		hue _ hue + step.
		c].
"
(Color wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]
"! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:33' prior: 16815842!
                          closestColor
	"Answer the closest matching color in the colorNames dictionary"

"
	(Colour red lighter lighter) closestColour explore.
"
	^ self closestColorFrom: (Colour colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36' prior: 16815850!
                 closestColorAssociation
	"Answer this color's closest name->color match."

"
	(Colour blue lighter lighter) closestColorAssociation explore.
"	
	^ self closestAssocFrom: (Colour colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36' prior: 16815867!
          closestColorName
	"Answer the name symbol of the closest matching color in the colorNames dictionary"
"
	(Colour red lighter lighter) closestColour name.
"
	
	^ self closestNameFrom: (Colour colorNamesDict)! !
!Color methodsFor: 'other' stamp: 'KenD 7/18/2015 20:41' prior: 16815891!
    colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."

	^(Colour colorNamesDict keyAtValue: self  ifAbsent: [nil])
! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:27:03' prior: 16816085!
             * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Color brown *2) display
	"
	^ Colour new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0)
		colorSpace: colorSpace! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:27:06' prior: 16816097!
+ aColor
	"Answer this color mixed with the given color in an additive color space.  "
	"
	(Color blue + Color green) display
	"
	^ Colour new
		setRed: (self red + aColor red min: 1.0 max: 0.0)
		green: (self green + aColor green min: 1.0 max: 0.0)
		blue: (self blue + aColor blue min: 1.0 max: 0.0)
		colorSpace: colorSpace! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:27:09' prior: 16816110!
- aColor
	"Answer aColor is subtracted from the given color in an additive color space.  "
	"
	(Color white - Color red) display
	"
	^ Colour new
		setRed: (self red - aColor red min: 1.0 max: 0.0)
		green: (self green - aColor green min: 1.0 max: 0.0)
		blue: (self blue - aColor blue min: 1.0 max: 0.0)
		colorSpace: colorSpace! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:27:10' prior: 16816123!
                             / aNumber
	"Answer this color with its RGB divided by the given number. "
	"
	(Color red / 2) display
	"
	^ Colour new
		setRed: (self red / aNumber min: 1.0 max: 0.0)
		green: (self green / aNumber min: 1.0 max: 0.0)
		blue: (self blue / aNumber min: 1.0 max: 0.0)
		colorSpace: colorSpace! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:34:18' prior: 16816135!
    adjustBrightness: brightness
	"Adjust the relative brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Colour
		h: self hue
		s: self saturation
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:34:22' prior: 16816146!
   adjustSaturation: saturation brightness: brightness
	"Adjust the relative saturation and brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Colour
		h: self hue
		s: (self saturation + saturation min: 1.0 max: 0.005)
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:28:01' prior: 16816159!
                          alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifFalse: [
		^ TranslucentColour new
			setRed: self red
			green: self green
			blue: self blue
			alpha: alphaValue
			colorSpace: colorSpace ]! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:34:26' prior: 16816170!
    alphaMixed: proportion with: aColour 
	"Answer this color mixed with the given color. The proportion, a number 
	between 0.0 and 1.0, determines what what fraction of the receiver to  
	use in the mix. For example, 0.9 would yield a color close to the  
	receiver. This method uses RGB interpolation; HSV interpolation can lead 
	to surprises.  Mixes the alphas (for transparency) also."

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Colour
		r: self red * frac1 + (aColour red * frac2)
		g: self green * frac1 + (aColour green * frac2)
		b: self blue * frac1 + (aColour blue * frac2)
		alpha: self alpha * frac1 + (aColour alpha * frac2)! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38' prior: 16816210!
                               blacker

	^ self alphaMixed: 0.8333 with: Colour black
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:54' prior: 16816214!
                  dansDarker
	"Return a darker shade of the same color.
	An attempt to do better than the current darker method.
	(now obsolete, since darker has been changed to do this. -dew)"
	^ Colour h: self hue s: self saturation
		v: (self brightness - 0.16 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:34:30' prior: 16816240!
       mixed: proportion with: aColour 
	"Mix with another color and do not preserve transpareny.  Only use this for extracting the RGB value and mixing it.  All other callers should use instead: 
	aColour alphaMixed: proportion with: anotherColor
	"

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Colour
		r: self red * frac1 + (aColour red * frac2)
		g: self green * frac1 + (aColour green * frac2)
		b: self blue * frac1 + (aColour blue * frac2)! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:29' prior: 16816258!
     muchDarker

	^ self alphaMixed: 0.5 with: Colour black
! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:07' prior: 16816262!
                    muchLighter

	^ self alphaMixed: 0.233 with: Colour white
! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:34:33' prior: 16816266!
            negated
	"Return an RGB inverted color"
	^Colour
		r: 1.0 - self red
		g: 1.0 - self green
		b: 1.0 - self blue! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:41' prior: 16816287!
                          quiteBlacker

	^ self alphaMixed: 0.8 with: Colour black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:44' prior: 16816291!
                quiteWhiter

	^ self alphaMixed: 0.6 with: Colour white! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:25' prior: 16816304!
                  slightlyWhiter

	^ self alphaMixed: 0.85 with: Colour white
! !
!Color methodsFor: 'transformations' stamp: 'jmv 8/23/2009 23:24' prior: 16816321!
             veryMuchDarker

	^ self alphaMixed: 0.25 with: Colour black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 7/28/2016 15:43:04' prior: 16816326!
          veryMuchLighter

	^ self alphaMixed: 0.07 with: Colour white! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38' prior: 16816331!
             whiter

	^ self alphaMixed: 0.8333 with: Colour white
! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/2/2016 15:04' prior: 16816547!
            colorFromPixelValue: p depth: d
	"Convert a pixel value for the given display depth into a color."
	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."
	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.
	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).
	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.
	Squeak also answers darkest possible blue when asked for black. Again, this is not needed in 32 bits (with alpha). It is also not really needed for 16 bits as we have an extra, unused bit: 16r8000 is not zero, but rgb=0, and hence, black.
	The real rule is that pixelValue=0 means transparent.
	And that darkest blue must be used instead of black, but only for depths >8 and < 16 (no indexed colors, no alpha)
	This method is updated to reflect that."

	| r g b alpha |

	d = 1 ifTrue: [^ self indexedColors at: (p bitAnd: 16r01) + 1].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	p = 0 ifTrue: [ ^Colour transparent ].

	d = 8 ifTrue: [^ self indexedColors at: (p bitAnd: 16rFF) + 1].
	d = 4 ifTrue: [^ self indexedColors at: (p bitAnd: 16r0F) + 1].
	d = 2 ifTrue: [^ self indexedColors at: (p bitAnd: 16r03) + 1].

	d = 32 ifTrue: [
		"eight bits per component; 8 bits of alpha"
		alpha _ p bitShift: -24.
		alpha = 0 ifTrue: [ ^Colour transparent ].
		r _ (p bitShift: -16) bitAnd: 16rFF.
		g _ (p bitShift: -8) bitAnd: 16rFF.
		b _ p bitAnd: 16rFF.
		^alpha < 255
			ifTrue: [ (Colour r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]
			ifFalse: [ Colour r: r g: g b: b range: 255 ]].

	d = 16 ifTrue: [
		"five bits per component. The most significant bit, unused, allows having real black, without p being zero"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		^ Colour r: r g: g b: b range: 31].

	d = 15 ifTrue: [
		"five bits per component"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 31].

	d = 12 ifTrue: [
		"four bits per component"
		r _ (p bitShift: -8) bitAnd: 16rF.
		g _ (p bitShift: -4) bitAnd: 16rF.
		b _ p bitAnd: 16rF.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 15].

	d = 9 ifTrue: [
		"three bits per component"
		r _ (p bitShift: -6) bitAnd: 16r7.
		g _ (p bitShift: -3) bitAnd: 16r7.
		b _ p bitAnd: 16r7.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Colour black ].
		^ Colour r: r g: g b: b range: 7].

	self error: 'unknown pixel depth: ', d printString! !
!Color class methodsFor: 'class initialization' stamp: '' prior: 16816881!
initializeIndexedColors
	"Build an array of colors corresponding to the fixed colormap used
	 for display depths of 1, 2, 4, or 8 bits."
	"Colour initializeIndexedColors"

	| a index grayVal |
	a _ Array new: 256.

	"1-bit colors (monochrome)"
	a at: 1 put: (Colour r: 1.0 g: 1.0 b: 1.0).		"white or transparent"
	a at: 2 put: (Colour r: 0.0 g: 0.0 b: 0.0).	"black"

	"additional colors for 2-bit color"
	a at: 3 put: (Colour r: 1.0 g: 1.0 b: 1.0).	"opaque white"
	a at: 4 put: (Colour r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"

	"additional colors for 4-bit color"
	a at:  5 put: (Colour r: 1.0 g: 0.0 b: 0.0).	"red"
	a at:  6 put: (Colour r: 0.0 g: 1.0 b: 0.0).	"green"
	a at:  7 put: (Colour r: 0.0 g: 0.0 b: 1.0).	"blue"
	a at:  8 put: (Colour r: 0.0 g: 1.0 b: 1.0).	"cyan"
	a at:  9 put: (Colour r: 1.0 g: 1.0 b: 0.0).	"yellow"
	a at: 10 put: (Colour r: 1.0 g: 0.0 b: 1.0).	"magenta"

	a at: 11 put: (Colour r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"
	a at: 12 put: (Colour r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"
	a at: 13 put: (Colour r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"
	a at: 14 put: (Colour r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"
	a at: 15 put: (Colour r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"
	a at: 16 put: (Colour r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"

	"additional colors for 8-bit color"
	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"
	index _ 17.
	1 to: 31 do: [:v |
		(v \\ 4) = 0 ifFalse: [
			grayVal _ v / 32.0.
			a at: index put: (Colour r: grayVal g: grayVal b: grayVal).
			index _ index + 1]].

	"The remainder of color table defines a color cube with six steps
	 for each primary color. Note that the corners of this cube repeat
	 previous colors, but this simplifies the mapping between RGB colors
	 and color map indices. This color cube spans indices 40 through 255
	 (indices 41-256 in this 1-based array)."
	0 to: 5 do: [:r |
		0 to: 5 do: [:g |
			0 to: 5 do: [:b |
				index _ 41 + ((36 * r) + (6 * b) + g).
				index > 256 ifTrue: [
					self error: 'index out of range in color table compuation'].
				a at: index put: (Colour r: r g: g b: b range: 5)]]].

	IndexedColors _ a.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48' prior: 16816950!
                 colorRampForDepth: depth extent: aPoint
	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."
	"(Colour colorRampForDepth: Display depth extent: 256@80) display"
	"(Colour colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"

	| f dx dy r |
	f _ Form extent: aPoint depth: depth.
	dx _ aPoint x // 256.
	dy _ aPoint y // 4.
	0 to: 255 do: [:i |
		r _ (dx * i)@0 extent: dx@dy.
		f fill: r fillColor: (Colour r: i g: 0 b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: 0 g: i b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: 0 g: 0 b: i range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Colour r: i g: i b: i range: 255)].
	^ f
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:30:09' prior: 16816978!
        experimentsTowarsANewColorPalette
"
self experimentsTowarsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width _ 300.
height _ 120.
selectedColor _ Colour random.
selectedHue _ selectedColor hue.
selectedSaturation _ selectedColor saturation.
selectedChroma _ selectedColor chroma.
selectedV _ selectedColor brightness.
selectedLuminance _ selectedColor luminance.
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
0 to: height do: [ :y |
	v _ 1.0 - (y / height).
	0 to: height do: [ :x |
		s _ x / height.
		color _ Colour new setHue: selectedHue saturation: s brightness: v.
		Display colorAt: x@(y+height) put: color
	].
	DisplayScreen screenUpdateRequired: nil
].
0 to: height do: [ :y | | c |
	v _ 1.0 - (y / height).
	s _ 1.0 - (y / height).
	c _ s.
	0 to: width do: [ :x |
		h _ x / width * 360.
		
		color _ Colour new setHue: h chroma: c luminance: selectedLuminance.
"		color _ Colour new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color _ Colour black ].
"		color _ Colour new setHue: h saturation: s brightness: selectedV."
		Display colorAt: x+height@y put: color.
		
		color _ Colour new setHue: h chroma: selectedChroma luminance: v.
"		color _ Colour new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color _ Colour black ].
"		color _ Colour new setHue: h saturation: selectedSaturation brightness: v."
		Display colorAt: x+height@(y+height) put: color.
		
	].
	DisplayScreen screenUpdateRequired: nil
].! !
!Color class methodsFor: 'examples' stamp: '' prior: 16817055!
                showColorCube
	"Show a 12x12x12 color cube."
	"Colour showColorCube"

	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				Display fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Colour r: r g: g b: b range: 11)]]].
! !
!Color class methodsFor: 'examples' stamp: '' prior: 16817075!
        showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"Color showHSVPalettes"

	| left top c |
	left _ top _ 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left _ (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c _ Colour h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4).
				Display fill: (left@top extent: 4@4) fillColor: c.

				c _ Colour h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4) + 50.
				Display fill: (left@top extent: 4@4) fillColor: c]]].
! !
!Color class methodsFor: 'examples' stamp: '' prior: 16817112!
                         wheel: thisMany
	"Return a collection of thisMany colors evenly spaced around the color wheel."
	"Color showColors: (Color wheel: 12)"

	^ Colour wheel: thisMany saturation: 0.9 brightness: 0.7
! !
!Color class methodsFor: 'examples' stamp: '' prior: 16817120!
                           wheel: thisMany saturation: s brightness: v
	"Return a collection of thisMany colors evenly spaced around the color wheel, all of the given saturation and brightness."
	"Colour showColors: (Colour wheel: 12 saturation: 0.4 brightness: 1.0)"
	"Colour showColors: (Colour wheel: 12 saturation: 0.8 brightness: 0.5)"

	^ (Colour h: 0.0 s: s v: v) wheel: thisMany
! !
!Color class methodsFor: 'colormaps' stamp: '' prior: 16817522!
                    colorMapIfNeededFrom: sourceDepth to: destDepth
	"Return a colormap for mapping between the given depths, or nil if no colormap is needed."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"

	sourceDepth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"

	(sourceDepth >= 16) & (destDepth >= 16) ifTrue: [
		"mapping is done in BitBlt by zero-filling or truncating each color component"
		^ nil].

	^ Colour cachedColormapFrom: sourceDepth to: destDepth
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:56' prior: 16817637!
                  computeColormapFromGray8bppForDepth: destDepth
	"Return a colormap for displaying a GrayForm at the given depth"

	| newMap |
	newMap _ Bitmap new: 256.
	1 to: 256 do: [ :i |
		newMap
			at: i
			put: ((Colour gray: (i-1) asFloat / 255.0) pixelValueForDepth: destDepth)].
	^ newMap! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 4/17/2015 15:05' prior: 16817648!
                computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	| map |
	
	map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth)) collect: [ :cc | | f c |
		f _ 1.0 - (cc red + cc green + cc blue / 3.0 ).
		c _ targetColor
			ifNotNil: [
				destDepth = 32
					ifTrue: [ targetColor * f alpha: f]
					ifFalse: [ targetColor alphaMixed: f*1.5 with: Colour white ]]
			ifNil: [ cc ].
		destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f = 0.0
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]]].
	map _ map as: Bitmap.
	^map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 21:34:38' prior: 16817670!
            computeRGBColorConvertingMap: targetColour to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColour values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColour r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColour _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColour _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColour _ bitsPerColour min: Preferences aaFontsColormapDepth.
	mask _ (1 bitShift: bitsPerColour) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColour)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColour)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColour) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColour
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Colour
							r: 1.0 - (r asFloat/mask) * targetColour red
							g: 1.0 - (g asFloat/mask) * targetColour green
							b: 1.0 - (b asFloat/mask) * targetColour blue
							alpha: f	* targetColour alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColour * f alpha: f * targetColour alpha ]
						ifFalse: [ targetColour alphaMixed: f*1.5 with: Colour white ]]]
			ifNil: [ Colour r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 21:34:42' prior: 16817730!
                      computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Colour maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| mask map c |
	(#(3 4 5) includes: bitsPerColor)
		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Colour
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c pixelValueForDepth: destDepth)].

	map at: 1 put: (Colour transparent pixelWordForDepth: destDepth).  "zero always transparent"
	^ map
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 6/18/2017 21:34:46' prior: 16817772!
        computeRGBColormapForGray8
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to 8bpp grays, using the default number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Colour maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| bitsPerColor mask map c |
	bitsPerColor _ 5.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Colour
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c luminance * 255) rounded].

	^ map! !
!Color class methodsFor: 'color from user' stamp: 'jmv 3/1/2010 15:13' prior: 16817838!
       colorPaletteForDepth: depth extent: chartExtent
	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorPaletteForDepth: 16 extent: 190@60) display"

	| basicHue x y startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [ :h |
		basicHue _ Colour h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [ :n | | c |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Colour white.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [ :n | | c |
 			c _ Colour black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [ :n | | c |
 		c _ Colour black mixed: (n asFloat / (vSteps*2) asFloat) with: Colour white.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color from user' stamp: 'jmv 7/27/2009 11:32' prior: 16817895!
                          colorTest: depth extent: chartExtent colorMapper: colorMapper
	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 7) asInteger / 7
			g: (c green * 7) asInteger / 7
			b: (c blue * 3) asInteger / 3]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 5) asInteger / 5
			g: (c green * 5) asInteger / 5
			b: (c blue * 5) asInteger / 5]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 15) asInteger / 15
			g: (c green * 15) asInteger / 15
			b: (c blue * 15) asInteger / 15]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 31) asInteger / 31
			g: (c green * 31) asInteger / 31
			b: (c blue * 31) asInteger / 31]) display"

	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |
		basicHue _ Colour h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [:n |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Colour white.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [:n |
 			c _ Colour black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [:n |
 		c _ Colour black mixed: (n asFloat / (vSteps*2) asFloat) with: Colour white.
		c _ colorMapper value: c.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/28/2013 20:34' prior: 16817983!
                defaultColorNamesDictionary
	"Answer a amall but  useful name->color dictionary"
	
	| defaultDict |
	"Meld most used xkcd colors into traditional colors."
	defaultDict := (self traditionalColorNamesDictionary addAll: 
					self xkcdFirst48ColorNamesDictionary; 
					yourself).
		
	"Override traditional names existing in extended XKCD naming"
	defaultDict at: #lightYellow    put: (Colour r: 1.0 g: 0.996 b: 0.478).
	defaultDict at: #lightOrange   put: (Colour r: 0.992 g: 0.667 b: 0.283).
	defaultDict at: #lightCyan        put: (Colour r: 0.674 g: 1.0 b: 0.988).
	defaultDict at: #lightRed          put: (Colour r: 1.0 g: 0.279 b: 0.298).
	defaultDict at: #lightMagenta put: (Colour r: 0.98 g: 0.372 b: 0.969).
	
	^defaultDict! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 2/1/2013 14:39' prior: 16818009!
        doesNotUnderstand: aMessage
	"Some code takes
		 Colour colorNames 
	and does
		Colour perform: aColorname.
		
	Make this work."

	^(Colour colorNamesDict) 
		at: (aMessage selector)
		ifAbsent: [super doesNotUnderstand: aMessage]! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 7/25/2014 21:22' prior: 16818027!
                          setColorNamesDict: aNameColorDictionary
	"Answer the current dictionary of  name->color associations."
	
	"Note: This is a non-standard name because this is a non-standard action!!
	Do this if you really, really know what you are doing."
	
	"Some Colors are required for proper system operation"
	Colour defaultColorNamesDictionary keysAndValuesDo: [ :colorName :colorValue |
		aNameColorDictionary at: colorName ifAbsentPut: colorValue
	].

	ColorNamesDict := aNameColorDictionary! !
!Color class methodsFor: 'color name lookup' stamp: 'sqr 10/21/2016 12:44:48' prior: 16818045!
                            traditionalColorNamesDictionary
	"Answer a dictionary of Squeak traditional name->color associations.."

	| nameDict |
	nameDict _ Dictionary new.
	nameDict at: #black put: (Colour r: 0 g: 0 b: 0).
	nameDict at: #veryVeryDarkGray put: (Colour r: 0.125 g: 0.125 b: 0.125).
	nameDict at: #veryDarkGray put: (Colour r: 0.25 g: 0.25 b: 0.25).
	nameDict at: #darkGray put: (Colour r: 0.375 g: 0.375 b: 0.375).
	nameDict at: #gray put: (Colour r: 0.5 g: 0.5 b: 0.5).
	nameDict at: #lightGray put: (Colour r: 0.625 g: 0.625 b: 0.625).
	nameDict at: #veryLightGray put: (Colour r: 0.75 g: 0.75 b: 0.75).
	nameDict at: #veryVeryLightGray put: (Colour r: 0.875 g: 0.875 b: 0.875).
	nameDict at: #white put: (Colour r: 1.0 g: 1.0 b: 1.0).
	nameDict at: #red put: (Colour r: 1.0 g: 0 b: 0).
	nameDict at: #yellow put: (Colour r: 1.0 g: 1.0 b: 0).
	nameDict at: #green put: (Colour r: 0 g: 1.0 b: 0).
	nameDict at: #cyan put: (Colour r: 0 g: 1.0 b: 1.0).
	nameDict at: #blue put: (Colour r: 0 g: 0 b: 1.0).
	nameDict at: #magenta put: (Colour r: 1.0 g: 0 b: 1.0).
	nameDict at: #brown put: (Colour r: 0.6 g: 0.2 b: 0).
	nameDict at: #orange put: (Colour r: 1.0 g: 0.6 b: 0).
	nameDict at: #lightRed put: (Colour r: 1.0 g: 0.8 b: 0.8).
	nameDict at: #lightYellow put: (Colour r: 1.0 g: 1.0 b: 0.8).
	nameDict at: #lightGreen put: (Colour r: 0.8 g: 1.0 b: 0.6).
	nameDict at: #lightCyan put: (Colour r: 0.4 g: 1.0 b: 1.0).
	nameDict at: #lightBlue put: (Colour r: 0.8 g: 1.0 b: 1.0).
	nameDict at: #lightMagenta put: (Colour r: 1.0 g: 0.8 b: 1.0).
	nameDict at: #lightBrown put: (Colour r: 1.0 g: 0.6 b: 0.2).
	nameDict at: #lightOrange put: (Colour r: 1.0 g: 0.8 b: 0.4).
	nameDict at: #transparent put: (TranslucentColour r: 0.0 g: 0.0 b: 0.0 alpha: 0.0).
	
	^nameDict
! !
!Color class methodsFor: 'color name lookup' stamp: 'jmv 6/30/2014 15:22' prior: 16818102!
     xkcdFirst48ColorNamesDictionary
	"XKCD color names are based on a survey oc colors people call by the same name.
	 http://blog.xkcd.com/2010/05/03/color-survey-results/"

	"Answer a dictionary of the most agreed upon first 48 xkcd colors"
"
	Colour xkcdFirst48ColorNamesDictionary explore.
"	
	| xkcdDict |
	xkcdDict := Dictionary new
	at: #lightPink put: (Colour fromString: '#ffd1df') ;
	at: #mustard put: (Colour fromString: '#ceb301') ;
	at: #indigo put: (Colour fromString: '#380282') ;
	at: #lime put: (Colour fromString: '#aaff32') ;
	at: #seaGreen put: (Colour fromString: '#53fca1') ;
	at: #periwinkle put: (Colour fromString: '#8e82fe') ;
	at: #darkPink put: (Colour fromString: '#cb416b') ;
	at: #oliveGreen put: (Colour fromString: '#677a04') ;
	at: #peach put: (Colour fromString: '#ffb07c') ;
	at: #paleGreen put: (Colour fromString: '#c7fdb5') ;
	at: #lightBrown put: (Colour fromString: '#ad8150') ;
	at: #hotPink put: (Colour fromString: '#ff028d') ;
	at: #black put: (Colour fromString: '#000000') ;
	at: #lilac put: (Colour fromString: '#cea2fd') ;
	at: #navyBlue put: (Colour fromString: '#001146') ;
	at: #royalBlue put: (Colour fromString: '#0504aa') ;
	at: #beige put: (Colour fromString: '#e6daa6') ;
	at: #salmon put: (Colour fromString: '#ff796c') ;
	at: #olive put: (Colour fromString: '#6e750e') ;
	at: #maroon put: (Colour fromString: '#650021') ;
	at: #brightGreen put: (Colour fromString: '#01ff07') ;
	at: #darkPurple put: (Colour fromString: '#35063e') ;
	at: #mauve put: (Colour fromString: '#ae7181') ;
	at: #forestGreen put: (Colour fromString: '#06470c') ;
	at: #aqua put: (Colour fromString: '#13eac9') ;
	at: #cyan put: (Colour fromString: '#00ffff') ;
	at: #tan put: (Colour fromString: '#d1b26f') ;
	at: #darkBlue put: (Colour fromString: '#00035b') ;
	at: #lavender put: (Colour fromString: '#c79fef') ;
	at: #turquoise put: (Colour fromString: '#06c2ac') ;
	at: #darkGreen put: (Colour fromString: '#033500') ;
	at: #violet put: (Colour fromString: '#9a0eea') ;
	at: #lightPurple put: (Colour fromString: '#bf77f6') ;
	at: #limeGreen put: (Colour fromString: '#89fe05') ;
	at: #grey put: (Colour fromString: '#929591') ;
	at: #skyBlue put: (Colour fromString: '#75bbfd') ;
	at: #yellow put: (Colour fromString: '#ffff14') ;
	at: #magenta put: (Colour fromString: '#c20078') ;
	at: #lightGreen put: (Colour fromString: '#96f97b') ;
	at: #orange put: (Colour fromString: '#f97306') ;
	at: #teal put: (Colour fromString: '#029386') ;
	at: #lightBlue put: (Colour fromString: '#95d0fc') ;
	at: #red put: (Colour fromString: '#e50000') ;
	at: #brown put: (Colour fromString: '#653700') ;
	at: #pink put: (Colour fromString: '#ff81c0') ;
	at: #blue put: (Colour fromString: '#0343df') ;
	at: #green put: (Colour fromString: '#15b01a') ;
	at: #purple put: (Colour fromString: '#7e1e9c') ;
  	yourself.

	^xkcdDict

! !
!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 6/18/2017 21:28:31' prior: 16939024!
                            alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifTrue: [
		^ Colour new
			setRed: self red
			green: self green
			blue: self blue
			colorSpace: colorSpace].
	^ super alpha: alphaValue! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 9/24/2013 22:36' prior: 16898974!
            newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay _ Delay forMilliseconds: 10.
	buttonStart _ buttonNow _ Sensor isAnyButtonPressed.
	rect _ self.
	Display border: rect width: 2 rule: Form reverse fillColor: Colour gray.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow _ Sensor isAnyButtonPressed.
		newRect _ newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: Colour gray.
			Display border: newRect width: 2 rule: Form reverse fillColor: Colour gray.
			rect _ newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: Colour gray.
	" pay the price for reading the sensor directly ; get this party started "
	aHand _ self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!StrikeFont methodsFor: 'emphasis' stamp: 'jmv 4/10/2015 23:21' prior: 16914485!
                       makeBoldGlyphs
	"Make a bold set of glyphs with same widths by ORing 1 bit to the right
		(requires at least 1 pixel of intercharacter space)"
	| g bonkForm |
	g _ glyphs copy.
	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.
	self bonk: g with: bonkForm.
	glyphs depth = 1 ifTrue: [
		g copyBits: g boundingBox from: g at: (1@0)
			clippingBox: g boundingBox rule: Form under ]
		ifFalse: [
			0 to: g width - 2 do: [ :x | 0 to: g height-1 do: [ :y |
				(glyphs colorAt:  x@y) = Colour white ifFalse: [
					g colorAt: x+1@y put: 
						((glyphs colorAt: x+1@y) = Colour white 
							ifTrue: [glyphs colorAt:  x@y]
							ifFalse: [Colour black])]]]].
	glyphs _ g.
	self isSynthetic: true! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:22' prior: 16914725!
                 makeControlCharsVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character space).
	glyph border: glyph boundingBox width: 1 fillColor: Colour blue.
	self glyphAt: (Character numericValue: 134) put: glyph.
	
	"Keep tab(9), lf(10), cr(13) and space(32) transparent or whatever the user chose"
	#(0 1 2 3 4 5 6 7 8 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 27)
		do: [ :ascii |
			characterToGlyphMap at: ascii + 1 put: 134 ]! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:27' prior: 16914749!
            makeCrVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character numericValue: 182).
	glyph border: glyph boundingBox width: 1 fillColor: Colour blue.
"	glyph _ glyph reverse."
	self glyphAt: (Character numericValue: 133) put: glyph.
	characterToGlyphMap at: 14 put: 133! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:31' prior: 16914768!
        makeLfVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character numericValue: 163).
	glyph border: glyph boundingBox width: 1 fillColor: Colour blue.
"	glyph _ glyph reverse."
	self glyphAt: (Character numericValue: 132) put: glyph.
	characterToGlyphMap at: 11 put: 132! !
!Morph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 20:40' prior: 16873946!
            color

	^ Colour blue! !
!Morph methodsFor: 'drawing' stamp: 'jmv 4/14/2015 08:53' prior: 16874298!
                            drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		fillRectangle: self morphLocalBounds
		color: Colour blue! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:46' prior: 16899196!
                             defaultColor
	^ Colour orange! !
!BorderedRectMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2014 21:28' prior: 16790410!
 defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ Colour gray! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'jmv 6/18/2017 21:33:36' prior: 16887268!
defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ Colour
		r: 0.861
		g: 1.0
		b: 0.722! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'jmv 6/18/2017 21:33:40' prior: 16887280!
      defaultColor
	"answer the default color/fill style for the receiver"
	^ Colour
		r: 0.8
		g: 1.0
		b: 0.6! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 11/10/2013 19:32' prior: 16887655!
                             findWindow: evt
	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."
	| menu expanded collapsed nakedMorphs |
	menu _ MenuMorph new.
	expanded _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed not ].
	collapsed _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed ].
	nakedMorphs _ self submorphsSatisfying: [ :m |
		(m is: #SystemWindow) not ].
	expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty) ifTrue: [ ^ Smalltalk beep ].
	(expanded asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #activateAndForceLabelToShow.
		w canDiscardEdits ifFalse: [ menu lastItem color: Colour red ]].
	expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty) ifFalse: [ menu addLine ].
	(collapsed asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #expand.
		w canDiscardEdits ifFalse: [ menu lastItem color: Colour red ]].
	nakedMorphs isEmpty ifFalse: [ menu addLine ].
	(nakedMorphs asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #comeToFrontAndAddHalo ].
	menu addTitle: 'find window'.
	menu popUpInWorld: self! !
!EllipseMorph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:14' prior: 16837113!
                       defaultColor
	"Return the default fill style for the receiver"
	^Colour yellow! !
!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 8/6/2014 09:15' prior: 16889451!
                    defaultColor
	"answer the default color/fill style for the receiver"
	^ Colour lightGray! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:50' prior: 16888164!
           drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Colour h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 4/12/2012 22:37' prior: 16888215!
   iconColor

	^ self isPressed
		ifTrue: [ Colour gray: 0.75 ]
		ifFalse: [
			self mouseIsOver
				ifTrue: [ Colour gray: 0.75 ]
				ifFalse: [ Colour white ]].! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 1/4/2013 13:31' prior: 16888484!
                              example
	"
	PluggableButtonMorph example openInWorld
	"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: Colour lightRed.
	b2 color: Colour lightRed.
	b3 color: Colour lightRed.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: 120@35.
	^ row
! !
!TextModelMorph methodsFor: 'drawing' stamp: 'cbr 10/10/2012 23:04' prior: 16933987!
                            drawOn: aCanvas 
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"


	| bw bc |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"


	super drawOn: aCanvas.
	bw _ Preferences focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"
				bc _ Colour tan]
			ifFalse: [
				self textMorph hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Colour red ] 
					ifFalse: [
						self textMorph hasUnacceptedEdits
							ifTrue: [
								bc _ Colour red]]]].

	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [
		bc ifNil: [
			bc _ Theme current focusIndicator ]]
	ifFalse: [
		bc ifNotNil: [
			bc _ bc alphaMixed: 0.4 with: Colour white ]].
	bc ifNotNil: [
		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !
!SystemWindow methodsFor: 'initialization' stamp: 'cbr 11/7/2010 18:58' prior: 16926270!
                             defaultColor
	"answer the default color/fill style for the receiver"
	^ Colour white! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 6/7/2013 23:23' prior: 16926535!
                          setWindowColor: incomingColor
	| existingColor aColor |
	incomingColor ifNil: [^ self].  "it happens"
	aColor _ incomingColor asNontranslucentColor.
	aColor = Colour black ifTrue: [^ self].
	existingColor _ self widgetsColor.
	existingColor ifNil: [^ Smalltalk beep].
	self widgetsColor: aColor.
	self redrawNeeded! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'KenD 8/27/2015 14:39' prior: 16811424!
 buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow  description summary backColor labelBackground textHeigth |
	backColor := self textBackgroundColor.	
	labelBackground := Theme current background.
	textHeigth := AbstractFont default height.
	
	dirtyFlags := PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: textHeigth;
		addMorphUseAll: dirtyFlags.

	names := PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: textHeigth;
		addMorphUseAll: names.

	fileNames := PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: textHeigth;
		addMorphUseAll: fileNames.

	upperRow := LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: names proportionalWidth: 0.27;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.6.
		
	description := TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary := TextModelMorph
		textProvider: model
		textGetter: #summary.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.5;
		addAdjusterAndMorph: self buildButtonPane proportionalHeight: 0.1;
		addAdjusterAndMorph: summary proportionalHeight: 0.18;
		addAdjusterAndMorph: description proportionalHeight: 0.22;
		addAdjusterAndMorph: self buildRequirementsPane proportionalHeight: 0.2.
	self setLabel: 'Installed Packages'! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'len 5/27/2016 21:51' prior: 16811499!
                 buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout |
	requirements := PluggableListMorph
		model: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	requirements color: Theme current textPane.
		
	deleteReqButton := PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete'.
	deleteReqButton color: self widgetsColor.
							
	buttonLayout := LayoutMorph newColumn.
	buttonLayout addMorph: deleteReqButton 
					layoutSpec: (LayoutSpec 
										proportionalWidth: 1.0 
										proportionalHeight: 1.0
										minorDirectionPadding: #top);
					color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.9 
							proportionalHeight: 1.0 
							minorDirectionPadding: #left);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.1 
							proportionalHeight: 1.0 
							minorDirectionPadding: #right);
		color: Colour transparent;
		yourself
		! !
!CodeWindow methodsFor: 'updating' stamp: 'jmv 6/18/2017 21:32:16' prior: 16813173!
      decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColour aButton flags buttonColour |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColour _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColour ].
	cm _ model currentCompiledMethod.
	(cm is: #CompiledMethod)
		ifFalse: [ ^aButton color: buttonColour ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColour _ {

		"This is NOTan override. There is no super implementation."
		buttonColour.							"no sends to super. there is not override in any subclass"
		Colour tan.							"no sends to super. there is an override in some subclass"
		Colour red.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		Colour red.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		Colour red muchLighter.			"doesn't have sub; has super but doesn't call it"
		Colour r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"
		Colour green muchLighter.			"doesn't have sub; has super and callsl it"
		Colour blue muchLighter.			"has sub; has super and callsl it"

	} at: flags + 1.
	aButton color: buttonColour! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'DM 8/22/2015 12:34' prior: 16799978!
                buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' Unsaved?');
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Change Set name');
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Classes');
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.47;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Colour transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Methods');
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55.

	self setLabel: model labelString! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:47:35' prior: 50336811!
    buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: Colour transparent.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!TestRunnerWindow methodsFor: 'constants' stamp: 'jmv 4/16/2011 13:57' prior: 16928704!
                     runButtonColor
	^ Colour green lighter duller! !
!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:52' prior: 16896023!
                  defaultColor
	^Colour white! !
!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:53' prior: 16896027!
    initialize
	super initialize.
	progressColor _ Colour gray.
	value _ 0.0! !
!MenuMorph methodsFor: 'construction' stamp: 'len 11/16/2015 02:52' prior: 16866472!
                               addStayUpIcons
	| closeBox pinBox w |
	Preferences optionalButtons ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	closeBox _ PluggableButtonMorph model: self action: #delete.
	closeBox icon: Theme current closeIcon; color: Colour transparent.
	pinBox _ PluggableButtonMorph model: self action: #stayUp.
	pinBox icon: Theme current pushPinIcon; color: Colour transparent.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 60.
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: 19);
			color: Colour transparent;
			addMorph: closeBox fixedWidth: 20;
			addMorph: (RectangleLikeMorph new color: Colour transparent) fixedWidth: 4;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (RectangleLikeMorph new color: Colour transparent) fixedWidth: 4;
			addMorph: pinBox fixedWidth: 20).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 6/8/2014 20:32' prior: 16867035!
             displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m is: #MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Colour veryDarkGray.
		self addMorphBack: feedbackMorph lock position: (0@ -20).
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self removeProperty: #feedbackMorph ].
	matches notEmpty ifTrue: [
		self selectItem: matches first ]! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 4/14/2016 15:10' prior: 16781489!
                           drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas frameAndFillRectangle: (0@0 extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			frameRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: self upButtonPosition.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: self downButtonPosition.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			fillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			color: Colour veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].
			aCanvas
				drawString: (completer entries at: index) asString
				at: rectangle topLeft
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:09' prior: 16781571!
                 defaultBorderColor
	^ Colour gray! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:59' prior: 16851609!
             drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"This method is only called when we are carrying morphs around..."
	 aCanvas
		stencil: Cursor move
		at: 0@0
		color: Colour black! !
!ImageMorph methodsFor: 'accessing' stamp: 'jmv 6/18/2017 21:32:59' prior: 16854101!
      color: aColor
        super color: aColor.
        (image depth = 1 and: [aColor is: #Color]) ifTrue: [
                image colors: {Colour transparent. aColor}.
                self redrawNeeded]! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 3/13/2009 10:04' prior: 16865863!
 isEnabled: aBoolean

	isEnabled = aBoolean ifTrue: [^ self].
	isEnabled _ aBoolean.
	self color: (aBoolean ifTrue: [Colour black] ifFalse: [Colour gray]).
! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55' prior: 16866162!
               offImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Colour gray: 0.9) 
			borderWidth: 1 borderColor: Colour black.
	^form! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55' prior: 16866174!
          onImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Colour gray: 0.8) 
			borderWidth: 1 borderColor: Colour black;
		fillRectangle: (form boundingBox insetBy: 2) color: Colour black.
	^form! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 12/1/2015 09:53' prior: 16863001!
      adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	doAdoptWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: paneColor) ]
		ifFalse: [ self color: Colour transparent ]! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2014 21:38' prior: 16863302!
                           defaultColor
	^Colour gray! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 4/3/2011 22:59' prior: 16863603!
  initializedInstance
	"Answer a row by default so the 'new morph' menu doesn't fail..."
	^self newRow color: (Colour red alpha: 0.2)! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 10:57' prior: 16863624!
  example1
"
	self example1
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Colour red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/12/2015 16:42' prior: 16863690!
       example10
"
	self example10 openInWorld
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example10.
pane color: Colour red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
^ pane! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 10:55' prior: 16863758!
example11
"
	self example11
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example11.
pane color: Colour red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:08' prior: 16863827!
                     example13
	"
	self example13
	"
	| pane row innerRow |
pane _ (LayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Colour red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	innerRow _ (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Colour red.
	innerRow
		addMorph: (BorderedRectMorph new name: #Box1)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Box2)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Bar)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Colour h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 				minorDirectionPadding: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 				minorDirectionPadding: #top);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 2/16/2016 13:27' prior: 16863874!
                       example1b
"
Based on #example1, but using some Morph instead of RectangleLikeMorph -> extent is not adjustable
	self example1b
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Colour red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (Morph new name: #B);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (BorderedRectMorph new color: (Colour h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (Morph new name: #G);
	addMorph: (BorderedRectMorph new color: (Colour h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Colour red;
	addMorph: (Morph new name: #J);
	addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:25' prior: 16863934!
              example2
	"
	self example2
	"
	| pane row |
	pane _ (LayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Colour red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Colour h: 270 s: 0.2 v: 0.6);
		addMorph: (BorderedRectMorph new color: (Colour h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 200@180 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 11/18/2015 09:45' prior: 16863965!
                         example20
"
	self example20
"
| column |

column _ (LayoutMorph newColumn separation: 5) name: #Column.
column
	color: Colour red;
	addMorph: (BorderedRectMorph new color: (Colour h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 30).
column morphPosition: 150@130 extent: 400@300.
column openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:13' prior: 16863988!
   example3
	"
	self example3
	"
	| pane row innerRow |
pane _ (LayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Colour red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	innerRow _ (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Colour red.
	innerRow
		addMorph: (BorderedRectMorph new name: #Box1)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Box2)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Bar)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Colour h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 				minorDirectionPadding: #center);
		addMorph: (BorderedRectMorph new color: (Colour h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 				minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Colour h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/8/2014 20:03' prior: 16864030!
                       example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane addMorph: (StringMorph contents: '1').

rect1 := BorderedRectMorph new color: (Colour lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := BorderedRectMorph new color: (Colour cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Colour lightGreen;
	morphPosition: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane _ LayoutMorph newRow separation: 5. "2"
pane addMorph: (StringMorph contents: '2').

rect1 := BorderedRectMorph new color: (Colour lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Colour cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane
	color: Colour lightGreen;
	morphPosition: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane _ LayoutMorph newRow separation: 5. "3"
pane addMorph: (StringMorph contents: '3').

rect1 := BorderedRectMorph new color: (Colour lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := BorderedRectMorph new color: (Colour cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane
	color: Colour lightGreen;
	morphPosition: 520 @ 50 extent: 180 @ 100;
	openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 1/4/2013 13:42' prior: 16864106!
   launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random _ Random new.
	b1 _ PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 _ PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 _ PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 _ PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons _ {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: Colour lightRed ].
	row _ LayoutMorph newRow
		 color: Colour red;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:55' prior: 16896260!
             defaultColor
	^Colour veryLightGray! !
!HaloHandleMorph class methodsFor: 'accessing' stamp: 'jmv 11/18/2010 09:44' prior: 16850573!
                           circleForm: extent
	"
	CircleForm _ nil
	"
	| r d l bw center |
	(CircleForm isNil or: [ CircleForm extent ~= extent ]) ifTrue: [
		center _ extent -1 * 0.5.
		r _ center r * 0.75.
		bw _ 1.3.
		CircleForm _ Form extent: extent depth: 32.
		0 to: extent y - 1 do: [ :y |
			0 to: extent x - 1 do: [ :x |
				d _ (x@y - center) r.
				l _ (r - d max: 0.0) min: bw.
				CircleForm
					colorAt: x @ y
					put: (Colour white alpha: (l / bw))
					]].
		].
	^CircleForm! !
!HaloMorph methodsFor: 'initialization' stamp: 'jmv 6/18/2017 21:33:32' prior: 16850854!
                 defaultColor
	"answer the default color/fill style for the receiver"
	^ Colour
		r: 0.6
		g: 0.8
		b: 1.0! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 5/27/2015 13:42' prior: 16850874!
    addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint colorToUse form icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Colour colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: self class handleSize asPoint).
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: 0@0 ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 7/4/2016 22:14' prior: 16850920!
         addNameString: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition nameBackground |
	nameBackground _ RectangleLikeMorph new
		color: ((target is: #SystemWindow) ifTrue: [target windowColor] ifFalse: [Colour lightBlue alpha: 0.9]).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Colour black.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	namePosition _ haloBox width - nameMorph morphWidth // 2 @ (haloBox height).
	self addMorph: nameBackground position: namePosition - 2.
	self addMorph: nameMorph position: namePosition.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:18' prior: 16851047!
              doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Colour lightBlue]
		ifFalse: [rotHandle color: Colour blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPositionInWorld: evt eventPosition - (rotHandle morphExtent // 2)! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/20/2012 00:01' prior: 16851135!
                            setDismissColor: evt with: dismissHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	evt hand obtainHalo: self.
	colorToUse _  (dismissHandle morphContainsPoint:  (dismissHandle internalizeFromWorld: evt eventPosition))
		ifFalse: [ Colour red muchLighter ]
		ifTrue: [ Colour lightGray ].
	dismissHandle color: colorToUse! !
!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 5/27/2013 09:39' prior: 16855063!
         initialize
	super initialize.
	self color: Colour black.
	font _ Preferences standardListFont.
	listItems _ #().
	selectedRow _ nil.
	selectedRows _ Set new.
	highlightedRow _ nil! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 10/16/2013 19:55' prior: 16855561!
                    debugDrawLineRectsOn: aCanvas
	"Shows where text line rectangles are"

	self textComposition lines do: [ :line |
		aCanvas
			frameRectangle: line rectangle
			borderWidth: 1
			color: Colour brown ]
! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:51' prior: 50333232!
                       initialize
	super initialize.
	extent _ 400@300.
	color _ Colour white.
	grid _ 8@6.
	gridLineWidth _ 2.
	gridColor _ Colour black.
	selectionColor _ Colour red! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:18' prior: 50333240!
                               mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	from _ self toGridPoint: localEventPosition.
	outlineMorph _ BorderedRectMorph new
		borderColor: Colour black;
		color: Colour transparent;
		openInWorld;
		hide.
	self selectTo: localEventPosition! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 9/25/2011 23:12' prior: 16853831!
                    defaultColor

	^Colour r: 1.0 g: 1.0 b: 0.7! !
!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 12/20/2014 15:09' prior: 16853866!
                            drawOn: aCanvas

	| r |
	r _ self morphLocalBounds.
	aCanvas roundRect: r color: self color radius: 4.
	aCanvas
		textComposition: textComposition
		bounds: (r insetBy: 4)
		color: Colour black
		selectionColor: (Theme current textHighlightFocused: false)! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:40:12' prior: 50339669!
           drawInvalidAreasSubmorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |

	"The simple implementation is slowers as it draws morph areas that will later be covered by other morphs.
	But it works, and it is easier to understand.
	See en.wikipedia.org/wiki/Painter's_algorithm"
	true not ifTrue: [ ^self simpleDrawInvalidAreasSubmorphs: submorphs ].

	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.

	"The idea here is to iterate morphs front to back, i.e. first the ones on top.
	For each morph, record the rectangles it affects. And if a morph is opaque, remove the area behind it from the list of rectangles to be repaired.
	This means, for example, that morphs completely covered might even not be redrawn.
	this is a huge performance gain when there are many morphs on screen, especially if there are more than ten open windows, and Theme uses opaque colors.
	See 'A reverse painter's algorithm' at en.wikipedia.org/wiki/Painter's_algorithm"
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ world fillRects: initialRectsToRepair color: Colour gray ].

	"Draw world background on those areas that were not completely covered by opaque morphs"
	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			world drawOn: (canvas newClipRect: r) ]].

	"Now, draw the recorded areas of selected morphs, back to front."
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could think about merging all xrects into just one call...
		This would mean drawing each morph just once.
		But that would mean drawing pixels we were not told to. There could be other morphs in that area that are not even being drawn!!
		See WorldState class >> #experiment1"
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			(canvas newClipRect: r) fullDraw: m.
		].
"		(canvas newClipRect: rr) fullDraw: m"
		"*make this true to flash damaged areas for testing*"
		Preferences debugShowDamage2 ifTrue: [
			world flashRects: xrects color: Colour random ].
	].

	"Answer a list of rectangles to be updated on the Display.
	This usually is not performance critical, drawing morphs is slower than just exposing the Display."
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !
!WorldState class methodsFor: 'sample code' stamp: 'jmv 3/2/2017 19:39:21' prior: 50339891!
        experiment1
	"To play with and learn about morphic Display update logic.
	Remove the morphs when done!!"
	"
	WorldState experiment1
	"
	| dr morph1 morph2 s w |
	morph1 _ RectangleLikeMorph new openInWorld.
	morph2 _ RectangleLikeMorph new openInWorld.
	morph2 color: Colour green.
	morph2 morphPosition: 200@800 extent: 50@40.
	morph1 morphPosition: 120@720 extent: 220@100.

	w _ self runningWorld.
	s _ w instVarNamed: 'worldState'.
	dr _ s instVarNamed: 'damageRecorder'.

	dr doFullRepaint.
	dr reset;
	"	recordInvalidRect: (100@700 corner: 400@900);"
		recordInvalidRect: (100@700 corner: 150@900);
		recordInvalidRect: (300@700 corner: 400@900).
	Display fillColor: Colour gray.
	"Do not draw the area used by the small rectangle, unless it is also drawn!!"
	s drawInvalidAreasSubmorphs: {morph1. morph2 }! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 12/20/2014 15:35' prior: 16877458!
                            drawCurrentAsError
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	r _ currentMorph morphLocalBounds.
	w _ r extent > (50@50)
		ifTrue: [ 6 ]
		ifFalse: [ 2 ].
	self
		frameAndFillRectangle: r
		fillColor: Colour red
		borderWidth: w
		borderColor: Colour yellow.
	self line: r topLeft to: r bottomRight-w width: w color: Colour yellow.
	self line: r topRight -(w@0) to: r bottomLeft -(0@w)width: w color: Colour yellow! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 6/1/2015 13:30' prior: 16877630!
                             drawStringEmbossed: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: aColor
	"Answer last affected pixel position
	Answer nil if nothing was done"

	aColor = Colour black ifFalse: [ | topColor |
		topColor _ aColor alphaMixed: 0.25 with: Colour black.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint
			font: fontOrNil
			color: topColor ].
	aColor = Colour white ifFalse: [ | bottomColor |
		bottomColor _ aColor alphaMixed: 0.22 with: Colour white.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint  + (0@2)
			font: fontOrNil
			color: bottomColor ].
	^self
		drawString: aString
		from: firstIndex
		to: lastIndex
		at: aPoint  + (0@1)
		font: fontOrNil
		color: aColor! !
!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 11/29/2015 18:01' prior: 16786666!
     fillRectangle: aRectangle color: aColor
	"Fill the given rectangle."

	aColor isTransparent ifFalse: [
		self 
			frameAndFillRectangle: aRectangle
			fillColor: aColor
			borderWidth: 0
			borderColor: Colour transparent ]! !
!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 11/29/2015 18:14' prior: 16786789!
                               reverseRectangleBorder: r borderWidth: borderWidth
	"
	Display getCanvas
		reverseRectangleBorder: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	| rect |
	rect _ currentTransformation displayBoundsOfTransformOf: r.
	port
		sourceForm: nil;
		fillColor: Colour gray;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth! !
!BitBltCanvas methodsFor: 'private' stamp: 'jmv 4/9/2015 09:46' prior: 16787146!
                              setPaintColor: aColor
	"Install a new color used for filling."
	| paintColor |
	paintColor _ aColor ifNil: [ Colour transparent ].
	(paintColor is: #Color) ifFalse: [
		^self error: 'Cannot install color' ].

	"Okay, so paintColor really *is* a color"
	port sourceForm: nil.
	(paintColor isOpaque or: [ self depth < 32]) ifTrue: [
		port fillColor: paintColor.
		port combinationRule: Form paint.
		^self ].

	"BitBlt setup for alpha mapped transfer"
	port fillColor: paintColor.
	port combinationRule: Form blend! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 4/17/2015 12:16' prior: 16787260!
                              steButtonForm: extent
	^self cachedForms
		at: { #steButton . extent }
		ifAbsentPut: [
			| form canvas |
			form _ Form extent: extent depth: 32.
			canvas _ form getCanvas.
			canvas
				roundRect: (0@0 extent: extent)
				color: (Colour gray: 0.4)
				radius: 4.
			canvas
				roundRect: (1@1 extent: extent-2)
				color: Colour white
				radius: 4
				gradientTop: 1.0
				gradientCenter: 0.73
				gradientBottom: 0.94
				gradient1Height: (extent y-8+1 max: extent y//2).
			form]! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 4/17/2015 12:16' prior: 16787305!
                         verticalGrayGradient: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	^self cachedForms
		at: { #vertical. height. gradientTopFactor . gradientBottomFactor }
		ifAbsentPut: [
			Form
				verticalGradient: height
				topColor: (Colour gray: gradientTopFactor)
				bottomColor: (Colour gray: gradientBottomFactor) ]! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/7/2015 08:12' prior: 16787328!
     buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	 (self buildArrowOfDirection: #up size: 120) display
	"

	| resizeFactor resizedForm f e c bottomMargin topMargin |
	resizeFactor _ 4.
	e _ finalSizeInteger@finalSizeInteger*resizeFactor.
	f _ Form extent: e depth: 32.
	c _ Colour gray: 0.5.
	topMargin _ finalSizeInteger * 3//4.
	bottomMargin _ finalSizeInteger * 4//4.
	0 to: e y-1-bottomMargin do: [ :y |
		0 to: e x -1 do: [ :x |
			(e x / 2 - 1 - x) abs * 2 + topMargin < y ifTrue: [
				f colorAt: x@y put: c
			]
		]
	].
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 10/9/2014 23:02' prior: 16787371!
                   buildArrowWith: insideForm borderForm: borderForm
	| extent translucentForm color insideSpec borderSpec border background alpha|
	"
	Display getCanvas
		image: (BitBltCanvas buildArrowWith: BitBltCanvas downInsideForm borderForm: BitBltCanvas downBorderForm)
		at: 20@20
	Display getCanvas
		image: (BitBltCanvas buildArrowWith:BitBltCanvas upInsideForm borderForm: BitBltCanvas upBorderForm)
		at: 40@20
	"
	extent _ insideForm extent - (1@2).
	translucentForm _ Form extent: insideForm extent depth: 32.
	0 to: extent x-1 do: [ :x |
		0 to: extent y-1 do: [ :y |
			insideSpec _ insideForm colorAt: x@(y+1).
			borderSpec _ borderForm colorAt: x@(y+1).
			insideSpec = (Colour r: 0.0 g: 0.0 b: 1.0)
				ifTrue: [ color _ Colour transparent ]
				ifFalse: [
					borderSpec = (Colour r: 1.0 g: 0.0 b: 0.0)
						ifTrue: [ color _ insideSpec ]
						ifFalse: [
							border _ x < (extent x//2)
								ifTrue: [Colour white]
								ifFalse: [Colour black].
							background _ borderForm colorAt: extent x@(y+1).
							alpha _ borderSpec red asFloat - background red / (border red - background red).
							color _ border alpha: (alpha min: 1 max: 0) ]].
			translucentForm colorAt: x@y put: color ]].
	^translucentForm! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/19/2010 14:06' prior: 16935417!
           background
	^ Colour r: 0.7 g: 0.72 b: 0.83! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/23/2010 09:42' prior: 16935421!
      buttonColorFrom: aColor
	^ Display depth <= 8
			ifTrue: [ Colour transparent ]
			ifFalse: [ aColor paler ]! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/14/2011 08:50' prior: 16935427!
      buttonLabel
	^Colour gray: 0.18! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:38' prior: 16935430!
                    errorColor
	^ Colour red lighter! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:40' prior: 16935433!
                   failureColor
	^ Colour yellow lighter! !
!Theme methodsFor: 'colors' stamp: 'len 11/14/2015 02:34' prior: 16935453!
            scrollbarButtonColor
	^Colour gray: 0.95! !
!Theme methodsFor: 'colors' stamp: 'len 11/17/2015 23:55' prior: 16935457!
         scrollbarColor
	^Colour white! !
!Theme methodsFor: 'colors' stamp: 'len 11/14/2015 02:34' prior: 16935460!
                    scrollbarSliderShadowColor
	^Colour white! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:38' prior: 16935464!
          successColor
	^ Colour green lighter! !
!Theme methodsFor: 'colors' stamp: 'cbr 11/7/2010 18:00' prior: 16935468!
              text
	^ Colour black! !
!Theme methodsFor: 'colors' stamp: 'jmv 10/16/2013 22:08' prior: 16935471!
                             textCursor
	^ Display depth <= 2
		ifTrue: [ Colour black ]
		ifFalse: [ self text ]! !
!Theme methodsFor: 'colors' stamp: 'jmv 5/30/2011 14:31' prior: 16935476!
                              textHighlight
	"A nice light blue."
	"
	^ Colour r: 0.71 g: 0.835 b: 1.0
	^ Colour hue: 214 chroma: 0.29 luminance: 0.816
	"
	^Colour hue: 204 chroma: 0.29 luminance: 0.77! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/23/2010 09:58' prior: 16935484!
      textHighlightFocused: focused
	"A nice light blue."
	| textHighlight |
	Display depth = 1 ifTrue: [^ Colour veryLightGray].
	Display depth = 2 ifTrue: [^ Colour gray: 0.87].
	textHighlight _ self textHighlight.
	^focused
		ifTrue: [ textHighlight ]
		ifFalse: [ self unfocusedTextHighlightFrom: textHighlight ]! !
!Theme methodsFor: 'colors' stamp: 'cbr 12/6/2010 20:08' prior: 16935501!
                            windowLabel
	^Colour gray: 0.3! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 5/26/2011 09:07' prior: 16935505!
               menu
	Display depth <= 2 ifTrue: [^ Colour white].
	^Colour r: 0.75 g: 0.75 b: 0.75 alpha: 0.93! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 11/23/2010 09:45' prior: 16935511!
             menuHighlight
	^ Display depth < 8
		ifTrue: [ Colour veryLightGray ]
		ifFalse: [ self textHighlight ]! !
!Theme methodsFor: 'menu colors' stamp: 'cbr 11/7/2010 18:28' prior: 16935517!
      menuText
	^ Colour black! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 11/28/2010 08:04' prior: 16935520!
                    menuTitleBar
	Display depth = 1 ifTrue: [^ Colour white].
	Display depth = 2 ifTrue: [^ Colour gray].
	^ self menu darker! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 4/15/2011 14:59' prior: 16935526!
                    browser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.5 g: 0.7 b: 0.4]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 2/14/2013 11:05' prior: 16935539!
                             debugger
	^Colour h: 0.0 s: 0.6 v: 0.7! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/23/2010 09:16' prior: 16935543!
      defaultWindowColor
	^ Colour lightGray! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/18/2010 12:44' prior: 16935551!
      fileContentsBrowser
	^Colour tan duller! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:44' prior: 16935555!
      fileList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.7 g: 0.55 b: 0.7 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 5/23/2012 19:23' prior: 16935561!
                          messageNames

	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.53 g: 0.77 b: 0.382 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:45' prior: 16935567!
                  messageSet
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.45 g: 0.6 b: 0.85 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/18/2010 12:44' prior: 16935573!
                      object
	^Colour white duller! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/28/2012 09:41' prior: 16935576!
                 packageList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.63 g: 0.47 b: 0.08 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/23/2010 09:17' prior: 16935582!
                    testRunner
	^ self useUniformColors
		ifTrue: [ self defaultWindowColour ]
		ifFalse: [ (Colour r: 0.650 g: 0.753 b: 0.976) duller ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/16/2011 08:15' prior: 16935589!
         textEditor
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour gray: 0.6 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:45' prior: 16935595!
    transcript
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour r: 0.8 g: 0.6 b: 0.3 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/18/2010 17:56' prior: 16935601!
                        versionsBrowser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColour ]
		ifFalse: [ (Colour r: 0.869 g: 0.753 b: 1.0) duller ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/16/2011 08:13' prior: 16935608!
      workspace
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Colour h: 60.0 s: 0.73 v: 0.72 ]! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:49' prior: 16935614!
                     acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Colour r: 0.2 g: 0.6 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:51' prior: 16935621!
                       cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Colour r: 0.8 g: 0.2 b: 0.2 ])! !
!Theme methodsFor: 'widget colors' stamp: 'cbr 10/10/2012 23:36' prior: 16935647!
                      textPane
	^Colour white! !
!SHTextStylerST80 class methodsFor: 'style table' stamp: 'pb 5/4/2016 17:44' prior: 16903544!
       initialTextAttributes
	| d element color emphasis attrArray |
	d _ IdentityDictionary new.
	self styleTable do: [ :each |
		element _ each first.
		color _ each at: 2 ifAbsent: nil.
		color _ color ifNotNil: [ Colour colorFrom: color ].
		emphasis _ each at: 3 ifAbsent: nil.
		attrArray _ self attributeArrayForColor: color emphasis: emphasis.
		attrArray notEmpty ifTrue: [
			d at: element put: attrArray ]].
	^ d! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3106-ChangeReferencesToColour-JuanVuletich-2017Jun19-11h07m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3106] on 19 June 2017 at 12:18:58 pm'!
!Colour methodsFor: 'transformations' stamp: 'jmv 6/19/2017 12:18:51' prior: 50345511!
                     * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Colour brown *2) display
	"
	^ (Colour new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0))
			alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/19/2017 12:18:50' prior: 50349788!
 * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Color brown *2) display
	"
	^ (Colour new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0)
		colorSpace: colorSpace)
			alpha: self alpha! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3107-KeepAlphaOnColorMultiply-JuanVuletich-2017Jun19-12h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3106] on 19 June 2017 at 11:52:30 am'!

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

| all |
all := Color allInstances.
all elementsForwardIdentityTo: (all collect: [ :c | c * 1 ]).
all := TranslucentColor allInstances.
all elementsForwardIdentityTo: (all collect: [ :c | c * 1 ]).!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3108-MigrateInstancesToColour-JuanVuletich-2017Jun19-11h51m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3103] on 19 June 2017 at 11:15:55 am'!

TranslucentColour removeSelector: #setRed:green:blue:alpha:colorSpace:!

TranslucentColour removeSelector: #setRed:green:blue:alpha:colorSpace:!

Colour removeSelector: #floatRGB!

Colour removeSelector: #floatRGB!

Colour removeSelector: #setRed:green:blue:colorSpace:!

Colour removeSelector: #setRed:green:blue:colorSpace:!

Smalltalk removeClassNamed: #Color!

Smalltalk removeClassNamed: #Color!

Smalltalk removeClassNamed: #TranslucentColor!

Smalltalk removeClassNamed: #TranslucentColor!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3109-removeColor-JuanVuletich-2017Jun19-11h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3108] on 19 June 2017 at 11:58:54 am'!

FloatArray variableWordSubclass: #Color
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps ColorNamesDict FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #Color category: #'Graphics-Primitives'!
FloatArray variableWordSubclass: #Color
	instanceVariableNames: ''
	classVariableNames: 'CachedColormaps ColorNamesDict FromGrayColormaps GrayToIndexMap IndexedColors MaskingMap ToGrayColormaps'
	poolDictionaries: ''
	category: 'Graphics-Primitives'!
!Color commentStamp: 'jmv 6/18/2017 20:14:31' prior: 0!
 This class represents abstract color, regardless of the depth of bitmap it will be shown in.  At the very last moment a Color is converted to a pixelValue that depends on the depth of the actual Bitmap inside the Form it will be used with.  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.  (See comment in BitBlt.)  To change the depth of the Display and set how many colors you can see, execute: (Display newDepth: 8).  (See comment in DisplayMedium)
	Color is represented as the amount of light in red, green, and blue.  White is (1.0, 1.0, 1.0) and black is (0, 0, 0).  Pure red is (1.0, 0, 0).  These colors are "additive".  Think of Color's instance variables as:
	r	amount of red, a Float between 0.0 and 1.0.
	g	amount of green, a Float between 0.0 and 1.0.
	b	amount of blue, a Float between 0.0 and 1.0.
	Many colors are named.  You find a color by name by sending a message to class Color, for example (Color lightBlue).  Also, (Color red: 0.2 green: 0.6 blue: 1.0) or (Color r: 0.2 g: 0.6 b: 1.0) creates a color. (see below)
	A color is essentially immutable.  Once you set red, green, and blue, you cannot change them.  Instead, create a new Color and use it.
	Applications such as contour maps and bar graphs will want to display one of a set of shades based on a number.  Convert the range of this number to an integer from 1 to N.  Then call (Color green lightShades: N) to get an Array of colors from white to green.  Use the Array messages at:, atPin:, or atWrap: to pull out the correct color from the array.  atPin: gives the first (or last) color if the index is out of range.  atWrap: wraps around to the other end if the index is out of range.
	Here are some fun things to run in when your screen has color:
		Pen new mandala: 30 diameter: Display height-100.
		Pen new web  "Draw with the mouse, opt-click to end"
		Display fillWhite.  Pen new hilberts: 5.
		Form toothpaste: 30  "Draw with mouse, opt-click to end"

Messages:
	mixed: proportion with: aColor	Answer this color mixed with the given color additively. The proportion, a number between 0.0 and 1.0, determines what what fraction of the receiver to use in the mix.

	+ 	add two colors
	- 	subtract two colors
	*	multiply the values of r, g, b by a number or an Array of factors.  ((Color named: #white) * 0.3) gives a darkish gray.  (aColor * #(0 0 0.9)) gives a color with slightly less blue.
	/	divide a color by a factor or an array of three factors.

	hue			Returns the hue of the color. On a wheel from 0 to 360 with pure red at 0 and again at 360.
	saturation	Returns the saturation of the color.  0.0 to 1.0
	brightness	Returns the brightness of the color.  0.0 to 1.0

	name    Look to see if this Color has a name.
	display	Show a swatch of this color tracking the cursor.

	lightShades: thisMany		An array of thisMany colors from white to the receiver. 
	darkShades: thisMany		An array of thisMany colors from black to the receiver.  Array is of length num.
	mix: color2 shades: thisMany		An array of thisMany colors from the receiver to color2.
	wheel: thisMany			An array of thisMany colors around the color wheel starting and ending at the receiver.

	pixelValueForDepth: d    Returns the bits that appear be in a Bitmap of this depth for this color.  Represents the nearest available color at this depth.  Normal users do not need to know which pixelValue is used for which color. 

Messages to Class Color.
	red: r green: g blue: b		Return a color with the given r, g, and b components.
	r: g: b:		Same as above, for fast typing.

 	hue: h saturation: s brightness: b		Create a color with the given hue, saturation, and brightness.

	pink
 	blue
	red ...	Many colors have messages that return an instance of Color.
	canUnderstand: #brown	  Returns true if #brown is a defined color.
	names		An OrderedCollection of the names of the colors.
	named: #notAllThatGray put: aColor    Add a new color to the list and create an access message and a class variable for it.
	fromUser	Shows the palette of colors available at this display depth.  Click anywhere to return the color you clicked on.

	hotColdShades: thisMany	An array of thisMany colors showing temperature from blue to red to white hot.

    stdColorsForDepth: d        An Array of colors available at this depth.  For 16 bit and 32 bits, returns a ColorGenerator.  It responds to at: with a Color for that index, simulating a very big Array. 

   colorFromPixelValue: value depth: d    Returns a Color whose bit pattern (inside a Bitmap) at this depth is the number specified.  Normal users do not need to use this.

(See also comments in these classes: Form, Bitmap, BitBlt)

Default colorSpace is #sRGB. Subclasses might use other color spaces!

Color variableWordSubclass: #TranslucentColor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!

!classDefinition: #TranslucentColor category: #'Graphics-Primitives'!
Color variableWordSubclass: #TranslucentColor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Graphics-Primitives'!
!TranslucentColor commentStamp: '<historical>' prior: 0!
         A TranslucentColor behaves just like a normal color, except that it will pack its alpha value into the fourth position.  This allows creating forms with translucency for use with the alpha blend function of BitBlt.  An alpha of zero is transparent, and 1.0 is opaque.!
!Color methodsFor: 'access' stamp: 'jmv 1/31/2011 09:25'!
                         alpha
	"Return the opacity ('alpha') value of opaque so that normal colors can be compared to TranslucentColors."

	^ 1.0
! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:34'!
     blue
	"Return the blue component of this color, a float in the range [0.0..1.0]."

	^ self at: 3! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:33:10'!
                               brightness
	"Return the brightness of this color, a float in the range [0.0..1.0].
	Color red brightness
	"

	"Do not include alpha if TranslucentColor"
	^ (self red max: self green) max: self blue! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:34:30'!
                          chroma
	"Return the chroma of this color, a value between 0.0 and 1.0, somewhat related to saturation.
	See http://en.wikipedia.org/wiki/HSL_and_HSV
	Color red chroma
	Color gray chroma
	"

	| r g b max min |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	^max - min! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:28'!
                              green
	"Return the green component of this color, a float in the range [0.0..1.0]."

	^ self at: 2! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:31:54'!
                             hue
	"Return the hue of this color, an angle in the range [0.0..360.0].
	Color orange hue
	"

	| r g b max min span h |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	span _ (max - min) asFloat.
	span = 0.0 ifTrue: [ ^ 0.0 ].

	r = max ifTrue: [
		h _ ((g - b) asFloat / span) * 60.0.
	] ifFalse: [
		g = max
			ifTrue: [ h _ 120.0 + (((b - r) asFloat / span) * 60.0). ]
			ifFalse: [ h _ 240.0 + (((r - g) asFloat / span) * 60.0). ].
	].

	^h mod: 360.0! !
!Color methodsFor: 'access' stamp: 'KenD 1/23/2013 18:19'!
    icon
	"Answer a swatch to display in a menu or browser"
	^self swatch! !
!Color methodsFor: 'access' stamp: 'KenD 1/23/2013 18:17'!
                            iconOrThumbnailOfSize: aNumberOrPoint 
	"Answer an appropiate form to represent the receiver"
	| form |
	form := Form extent: aNumberOrPoint asPoint asPoint depth: 32.
	form fillColor: self.
	^ form! !
!Color methodsFor: 'access' stamp: 'jmv 4/19/2013 16:46'!
                            luminance
	"Return the luminance of this color, a brightness value weighted by the human eye's color sensitivity."

	^ ((299 * self red) +
	   (587 * self green) +
	   (114 * self blue)) / 1000! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:35:25'!
                              red
	"Return the red component of this color, a float in the range [0.0..1.0]."

	^ self at: 1! !
!Color methodsFor: 'access' stamp: 'jmv 6/18/2017 20:34:08'!
 saturation
	"Return the saturation of this color, a value between 0.0 and 1.0.
	Color red saturation
	Color gray saturation
	"

	| r g b max min |
	r _ self red.
	g _ self green.
	b _ self blue. 
	max _ (r max: g) max: b.
	min _ (r min: g) min: b.
	max = 0.0 ifTrue: [ ^0.0 ].
	^max - min / max! !
!Color methodsFor: 'access' stamp: 'KenD 1/23/2013 18:18'!
                           swatch
	"Answer a swatch to display in a menu or browser"
	^self iconOrThumbnailOfSize: 16! !
!Color methodsFor: 'conversions' stamp: 'sw 10/27/1999 10:51'!
   asNontranslucentColor
	^ self! !
!Color methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:20:07'!
                             bitPatternForDepth: depth
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"

	^ Bitmap with: (self pixelWordForDepth: depth)! !
!Color methodsFor: 'conversions' stamp: 'jmv 6/3/2016 17:28'!
                    bitPatternForGrayForm
	"Return a Bitmap, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps."
	"See also:	pixelValueForDepth:	-- value for single pixel
				pixelWordForDepth:	-- a 32-bit word filled with the pixel value"
	"Details: The pattern for the most recently requested depth is cached."

	^Bitmap with: (self pixelWordFor: 8 filledWith: (self luminance * 255) rounded)! !
!Color methodsFor: 'conversions' stamp: 'jmv 4/19/2013 16:17'!
             closestPixelValue1
	"Return the nearest approximation to this color for a monochrome Form."

	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 0].  "white"

	self luminance > 0.5
		ifTrue: [^ 0]  "white"
		ifFalse: [^ 1].  "black"! !
!Color methodsFor: 'conversions' stamp: 'jmv 12/13/2014 16:18'!
                   closestPixelValue2
	"Return the nearest approximation to this color for a 2-bit deep Form."

	| lum |
	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 2].  "opaque white"

	lum _ self luminance.
	lum < 0.2 ifTrue: [^ 1].  "black"
	lum > 0.6 ifTrue: [^ 2].  "opaque white"
	^ 3  "50% gray"
! !
!Color methodsFor: 'conversions' stamp: 'jmv 12/13/2014 16:17'!
                       closestPixelValue4
	"Return the nearest approximation to this color for a 4-bit deep Form."

	| bIndex |
	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 2].  "opaque white"

	self isRed ifTrue: [^ 4].
	self isGreen ifTrue: [^ 5].
	self isBlue ifTrue: [^ 6].
	self isCyan ifTrue: [^ 7].
	self isYellow ifTrue: [^ 8].
	self isMagenta ifTrue: [^ 9].

	bIndex _ (self luminance * 8.0) rounded.  "bIndex in [0..8]"
	^ #(
		1	"black"
		10	"1/8 gray"
		11	"2/8 gray"
		12	"3/8 gray"
		3	"4/8 gray"
		13	"5/8 gray"
		14	"6/8 gray"
		15	"7/8 gray"
		2	"opaque white"
	) at: bIndex + 1.
! !
!Color methodsFor: 'conversions' stamp: 'jmv 4/21/2015 09:57'!
                       closestPixelValue8
	"Return the nearest approximation to this color for an 8-bit deep Form."

	"fast special cases"
	self isBlack ifTrue: [^ 1].  "black"
	self isWhite ifTrue: [^ 255].  "white"

	^self saturation < 0.2
		ifTrue: [
			^ self class grayToIndexMap at:(self green * 255) rounded + 1.  "nearest gray"
			]
		ifFalse: [
			"compute nearest entry in the color cube"
			40 + 
				((self red * 5) rounded * 36) +
				((self blue * 5) rounded * 6) +
				(self green * 5) rounded ]! !
!Color methodsFor: 'conversions' stamp: 'di 9/2/97 20:21'!
                          dominantColor
	^ self! !
!Color methodsFor: 'conversions' stamp: 'jmv 6/2/2016 14:48'!
         indexInMap: aColorMap
	"Return the index corresponding to this color in the given color map. RGB colors are truncated to 3-, 4-, or 5-bits per color component when indexing into such a colorMap.  "

	aColorMap size = 2 ifTrue: [^ (self pixelValueForDepth: 1) + 1].
	aColorMap size = 4 ifTrue: [^ (self pixelValueForDepth: 2) + 1].
	aColorMap size = 16 ifTrue: [^ (self pixelValueForDepth: 4) + 1].
	aColorMap size = 256 ifTrue: [^ (self pixelValueForDepth: 8) + 1].
	aColorMap size = 512 ifTrue: [^ (self pixelValueForDepth: 9) + 1].
	aColorMap size = 4096 ifTrue: [^ (self pixelValueForDepth: 12) + 1].
	aColorMap size = 32768 ifTrue: [^ (self pixelValueForDepth: 15) + 1].
	self error: 'unknown pixel depth'.
! !
!Color methodsFor: 'conversions' stamp: 'bf 4/18/2001 16:25'!
                       makeForegroundColor
        "Make a foreground color contrasting with me"
        ^self luminance >= 0.5
                ifTrue: [Color black]
                ifFalse: [Color white]! !
!Color methodsFor: 'conversions' stamp: 'jmv 6/2/2016 14:50'!
         pixelValueForDepth: d
	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"
	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."
	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8 and less than 32 (no Indexed colors, no real alpha), black maps to the darkest possible blue.
	Note that 
		Color transparent class = TranslucentColor
	this special case is handled in TranslucentColor >> #pixelValueForDepth:
	"

	| bitBltFakeBlack val |
	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"
	d < 8 ifTrue: [
		d = 4 ifTrue: [^ self closestPixelValue4].
		d = 2 ifTrue: [^ self closestPixelValue2].
		d = 1 ifTrue: [^ self closestPixelValue1]].

	d = 32 ifTrue: [
		"eight bits per component; top 8 bits set to all ones (opaque alpha)"
		val _ LargePositiveInteger new: 4.
		val at: 3 put: (self red * 255) rounded.
		val at: 2 put: (self green * 255) rounded.
		val at: 1 put: (self blue * 255) rounded.
		val at: 4 put: 16rFF.  "opaque alpha"
		^ val normalize].

	"For the depth 16, pixelValue = 0 means transparent, black is represented as 16r8000 (rgb=0, pixelvalue !!= 0)."
	(d = 16) | (d = 15) ifTrue: [
		"five bits per component; top bits ignored"
		val _ ((self red * 31) rounded bitShift: 10) bitOr:
			(((self green * 31) rounded bitShift: 5) bitOr: 
			((self blue * 31) rounded)).
		^ val = 0
			ifTrue: [d = 16 ifTrue: [16r8000] ifFalse: [1]]
			ifFalse: [val]].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	bitBltFakeBlack := 1.  "closest black that is not transparent in RGB - Not for depths <=8 (Indexed) or = 32 (RGBA)"
	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"
		val _ ((self red * 15) rounded bitShift: 8) bitOr:
			(((self green * 15) rounded bitShift: 4) bitOr: 
			((self blue * 15) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"
		val _ ((self red * 7) rounded bitShift: 6) bitOr:
			(((self green * 7) rounded bitShift: 3) bitOr: 
			((self blue * 7) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	self error: 'unknown pixel depth: ', d printString! !
!Color methodsFor: 'conversions' stamp: 'di 11/30/1998 09:03'!
                             pixelWordFor: depth filledWith: pixelValue
	"Return to a 32-bit word that concatenates enough copies of the given pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."
	| halfword |
	depth = 32 ifTrue: [^ pixelValue].
	depth = 16
		ifTrue: [halfword _ pixelValue]
		ifFalse: [halfword _ pixelValue * 
					(#(16rFFFF				"replicates at every bit"
						16r5555 -			"replicates every 2 bits"
						16r1111 - - -			"replicates every 4 bits"
						16r0101) at: depth)	"replicates every 8 bits"].
	^ halfword bitOr: (halfword bitShift: 16)! !
!Color methodsFor: 'conversions'!
                               pixelWordForDepth: depth
	"Return to a 32-bit word that concatenates enough copies of the receiver's pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."

	| pixelValue |
	pixelValue _ self pixelValueForDepth: depth.
	^ self pixelWordFor: depth filledWith: pixelValue
! !
!Color methodsFor: 'equality' stamp: 'jmv 6/18/2017 20:38:11'!
           diff: theOther
	"Returns a number between 0.0 and 1.0.
	Color gray diff: Color red
	"
	^(self - theOther ) abs sum / self size! !
!Color methodsFor: 'equality' stamp: 'KenD 12/8/2013 08:35'!
 rgbDistance: otherColor
	"Compare two colors in distance"
"
	^ (self hue - otherColor hue) abs +
	  (self saturation - otherColor saturation) abs *10 +
	  (self brightness - otherColor brightness) abs
"
	"See http://www.compuphase.com/cmetric.htm"
	| meanRed deltaRed deltaGreen deltaBlue |
	meanRed := (self red + otherColor red) abs / 2.
	deltaRed := (self red - otherColor red) abs.
	deltaGreen := (self green - otherColor green) abs.
	deltaBlue := (self blue - otherColor blue) abs.
	
	^ ( ((2 + (meanRed / 256)) * (deltaRed * deltaRed)) +
		(4 * deltaGreen) +
		((2 + ((255 - meanRed) / 256)) * deltaBlue)
	  ) sqrt! !
!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!
                     darkShades: thisMany
	"An array of thisMany colors from black to the receiver.  Array is of length num. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red darkShades: 12)"

	^ self class black mix: self shades: thisMany
! !
!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!
                lightShades: thisMany
	"An array of thisMany colors from white to self. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red lightShades: 12)"

	^ self class white mix: self shades: thisMany
! !
!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96'!
               mix: color2 shades: thisMany
	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red mix: Color green shades: 12)"

	| redInc greenInc blueInc rr gg bb c out |
	thisMany = 1 ifTrue: [^ Array with: color2].
	redInc _ color2 red - self red / (thisMany-1).
	greenInc _ color2 green - self green / (thisMany-1).
	blueInc _ color2 blue - self blue / (thisMany-1).
	rr _ self red.  gg _ self green.  bb _ self blue.
	out _ (1 to: thisMany) collect: [:num |
		c _ Color r: rr g: gg b: bb.
		rr _ rr + redInc.
		gg _ gg + greenInc.
		bb _ bb + blueInc.
		c].
	out at: out size put: color2.	"hide roundoff errors"
	^ out
! !
!Color methodsFor: 'groups of shades' stamp: 'di 10/23/2000 09:45'!
          wheel: thisMany
	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "

	| sat bri hue step c |
	sat _ self saturation.
	bri _ self brightness.
	hue _ self hue.
	step _ 360.0 / (thisMany max: 1).
	^ (1 to: thisMany) collect: [:num |
		c _ Color h: hue s: sat v: bri.  "hue is taken mod 360"
		hue _ hue + step.
		c].
"
(Color wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]
"! !
!Color methodsFor: 'named colors' stamp: 'KenD 12/8/2013 14:59'!
           closestAssocFrom: aColorDict
	"Answer closest associated color in aColorDict"
"
	((Color r: 0.3 g: 0.2 b: 0.8) closestAssocFrom: (Color colorNamesDict)) explore.
"
	"Filter values for those close in hue (cheap test) then use rgbDistance"
	| closeInHue isClose close distance myHue |
	closeInHue := OrderedCollection new.
	myHue := self hue.
	isClose := [ :assoc | | delta |
		delta := ((assoc value hue) - myHue) abs.
		(delta < 20) or: [ delta > 340 ] "hues within 20 degrees"
	].
	aColorDict  associationsDo:  [ :assoc |
		(isClose value: assoc) ifTrue: [ closeInHue add: assoc ]
	].

	close := nil.
	distance := 1000. "big"
	(closeInHue size > 0)
		ifFalse: [ "fallback -- no color really close"
			aColorDict  associationsDo:  [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		]
		ifTrue: [ closeInHue do: [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		].
	
	^ close! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:33'!
                              closestColor
	"Answer the closest matching color in the colorNames dictionary"

"
	(Color red lighter lighter) closestColor explore.
"
	^ self closestColorFrom: (Color colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36'!
    closestColorAssociation
	"Answer this color's closest name->color match."

"
	(Color blue lighter lighter) closestColorAssociation explore.
"	
	^ self closestAssocFrom: (Color colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/25/2013 14:31'!
                            closestColorFrom: aColorDict
	"Answer closest associated color"
"
	((Color lightBlue) closestColorFrom: (Color css2NamedColors)) explore..
"
	^(self closestAssocFrom: aColorDict) value! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36'!
   closestColorName
	"Answer the name symbol of the closest matching color in the colorNames dictionary"
"
	(Color red lighter lighter) closestColor name.
"
	
	^ self closestNameFrom: (Color colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36'!
                closestNameFrom: aColorDict
	"Answer closest associated color name"
"
	((Color lightBlue) closestNameFrom: (Color namedColors)) print.
"
	^(self closestAssocFrom: aColorDict) key! !
!Color methodsFor: 'other' stamp: 'KenD 7/18/2015 20:41'!
                colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."

	^(Color colorNamesDict keyAtValue: self  ifAbsent: [nil])
! !
!Color methodsFor: 'other' stamp: 'KenD 7/18/2015 20:46'!
          name
	"Return this color's name, or description if unnamed."

	^ self printString
! !
!Color methodsFor: 'printing' stamp: 'jmv 2/13/2014 13:41'!
              hexStringRGB
	"
	Color fromUser hexStringRGB
	"
	^String streamContents: [ :strm |
		(self red * 255) rounded printOn: strm base: 16 length: 2 padded: true.
		(self green * 255) rounded printOn: strm base: 16 length: 2 padded: true.
		(self blue * 255) rounded printOn: strm base: 16 length: 2 padded: true ]! !
!Color methodsFor: 'printing' stamp: 'KenD 7/18/2015 20:42'!
           printOn: aStream
	 self colorName ifNotNil: [ :name |
		^ aStream
			nextPutAll: 'Color ';
			nextPutAll: name].
	self storeOn: aStream.
! !
!Color methodsFor: 'printing' stamp: 'KenD 7/18/2015 20:44'!
                      printString
	"Answer a String whose characters are a description of the receiver."
	
	^ String streamContents: [ :stream | self printOn: stream ]! !
!Color methodsFor: 'printing' stamp: 'mir 7/21/1999 11:41'!
               storeArrayOn: aStream

	aStream nextPutAll: '#('.
	self storeArrayValuesOn: aStream.
	aStream nextPutAll: ') '
! !
!Color methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:04'!
                  storeArrayValuesOn: aStream


	self red printOn: aStream fractionDigits: 3.
	aStream space.
	self green printOn: aStream fractionDigits: 3.
	aStream space.
	self blue printOn: aStream fractionDigits: 3

! !
!Color methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:01'!
                      storeOn: aStream

	aStream
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll: ' r: '.
	self red printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' g: '.
	self green printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' b: '.
	self blue printOn: aStream fractionDigits: 3.
	aStream nextPut: $)! !
!Color methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:40:55'!
    isBlack
	"Return true if the receiver represents black"
	(self at: 1) = 0.0 ifFalse: [ ^ false ].
	(self at: 2) = 0.0 ifFalse: [ ^ false ].
	(self at: 3) = 0.0 ifFalse: [ ^ false ].
	^ true! !
!Color methodsFor: 'queries' stamp: 'ar 4/20/2001 04:33'!
     isOpaque
	^true! !
!Color methodsFor: 'queries'!
               isTransparent

	^ false
! !
!Color methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:40:46'!
      isWhite
	"Return true if the receiver represents white"
	(self at: 1) = 1.0 ifFalse: [ ^ false ].
	(self at: 2) = 1.0 ifFalse: [ ^ false ].
	(self at: 3) = 1.0 ifFalse: [ ^ false ].
	^ true! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:35'!
 isBlue
	"Am I considered Blue?"

	^self blue > (self green + 0.3)
		and: [self blue > (self red + 0.3)]
			and: [(self green - self red) abs < 0.4]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:37'!
           isBlueGreen
	"Am I considered BlueGreen ?"

	^self green > self red 
		and: [self red < 0.3]
			and: [(self green - self blue) abs < 0.1]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:50'!
                     isBright
	"Am I considered a Bright color ?"

	^self brightness > 0.6! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:40'!
                         isBrown
	"Am I considered Brown ?"

	^self red >= self green  
		and: [self green > self blue]					
			and: [(self red - self green) < 0.5]	
				and: [(self green - self blue) < 0.3]! !
!Color methodsFor: 'selection' stamp: 'jmv 4/19/2013 17:14'!
         isCyan
	"Am I considered Cyan ?"

	^self red < 0.05 
		and: [(self green min: self blue) > 0.5]					
			and: [(self green - self blue) abs < 0.2]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:50'!
             isDark
	"Am I considered a Dark color ?"

	^self brightness < 0.5! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:42'!
                             isGray
	"Am I considered Gray  ?"

	^(self red closeTo: self green)
		and: [self blue closeTo: self green ]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:38'!
                   isGreen
	"Am I considered Green ?"

	^self green > (self blue + 0.3)
		and: [self blue > (self red + 0.3)]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:40'!
                    isGrey
	"Am I considered Grey  ?"

	^self isGray! !
!Color methodsFor: 'selection' stamp: 'jmv 4/19/2013 17:06'!
               isLight
	"Am I considered a Light color ?"

	^self brightness > 0.6! !
!Color methodsFor: 'selection' stamp: 'jmv 4/19/2013 17:13'!
                            isMagenta
	"Am I considered Magenta ?"

	^self green < 0.05 
		and: [(self red min: self blue) > 0.5]					
			and: [(self red - self blue) abs < 0.2]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:44'!
         isOrange
	"Am I considered Orange ?"

	^self red > ((self green max: self blue) + 0.2)  
		and: [self green > (self blue + 0.2)]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:45'!
                              isPastel
	"Am I considered Pastel ?"

	^self saturation < 0.4! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:46'!
 isPink
	"Am I considered Pink ?"

	^self red > ((self green max: self blue) + 0.3)  
		and: [self blue > (self green + 0.2)]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:47'!
  isRed
	"Am I considered Red ?"

	^self red > (self green + 0.4)
		and: [self red > (self blue + 0.6)]
			and: [(self green - self blue) abs < 0.4]! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:55'!
            isSaturated
	"Am I considered to be a Saturated color ?"

	^self saturation > 0.6! !
!Color methodsFor: 'selection' stamp: 'KenD 1/30/2013 16:49'!
             isYellow
	"Am I considered Yellow ?"

	^self blue < 0.05 
		and: [(self red min: self green) > 0.5]					
			and: [(self red - self green) abs < 0.2]! !
!Color methodsFor: 'testing' stamp: 'jmv 12/2/2010 08:38'!
             is: aSymbol
	^ aSymbol == #Color or: [ super is: aSymbol ]! !
!Color methodsFor: 'testing' stamp: 'jmv 2/10/2011 21:46'!
       mightBeTranslucent
	"For Colors, answer if actually translucent or not."
	^self isOpaque not! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:14'!
                          * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Color brown *2) display
	"
	^ (Color new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0))
			alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:18'!
                   + aColor
	"Answer this color mixed with the given color in an additive color space.  "
	"
	(Color blue + Color green) display
	"
	^ Color new
		setRed: (self red + aColor red min: 1.0 max: 0.0)
		green: (self green + aColor green min: 1.0 max: 0.0)
		blue: (self blue + aColor blue min: 1.0 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:22'!
          - aColor
	"Answer aColor is subtracted from the given color in an additive color space.  "
	"
	(Color white - Color red) display
	"
	^ Color new
		setRed: (self red - aColor red min: 1.0 max: 0.0)
		green: (self green - aColor green min: 1.0 max: 0.0)
		blue: (self blue - aColor blue min: 1.0 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:56:26'!
       / aNumber
	"Answer this color with its RGB divided by the given number. "
	"
	(Color red / 2) display
	"
	^ Color new
		setRed: (self red / aNumber min: 1.0 max: 0.0)
		green: (self green / aNumber min: 1.0 max: 0.0)
		blue: (self blue / aNumber min: 1.0 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:50'!
                 adjustBrightness: brightness
	"Adjust the relative brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Color
		h: self hue
		s: self saturation
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:51'!
                       adjustSaturation: saturation brightness: brightness
	"Adjust the relative saturation and brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Color
		h: self hue
		s: (self saturation + saturation min: 1.0 max: 0.005)
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 21:10:41'!
           alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifFalse: [
		^ TranslucentColor new
			setRed: self red
			green: self green
			blue: self blue
			alpha: alphaValue ]! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 11:55'!
                    alphaMixed: proportion with: aColor 
	"Answer this color mixed with the given color. The proportion, a number 
	between 0.0 and 1.0, determines what what fraction of the receiver to  
	use in the mix. For example, 0.9 would yield a color close to the  
	receiver. This method uses RGB interpolation; HSV interpolation can lead 
	to surprises.  Mixes the alphas (for transparency) also."

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Color
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)
		alpha: self alpha * frac1 + (aColor alpha * frac2)! !
!Color methodsFor: 'transformations' stamp: 'RAA 6/2/2000 08:47'!
                      atLeastAsLuminentAs: aFloat

	| revisedColor |
	revisedColor _ self.
	[revisedColor luminance < aFloat] whileTrue: [revisedColor _ revisedColor slightlyLighter].
	^revisedColor
! !
!Color methodsFor: 'transformations' stamp: 'nk 3/8/2004 09:43'!
          atMostAsLuminentAs: aFloat

	| revisedColor |
	revisedColor _ self.
	[revisedColor luminance > aFloat] whileTrue: [revisedColor _ revisedColor slightlyDarker].
	^revisedColor
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38'!
          blacker

	^ self alphaMixed: 0.8333 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:54'!
   dansDarker
	"Return a darker shade of the same color.
	An attempt to do better than the current darker method.
	(now obsolete, since darker has been changed to do this. -dew)"
	^ Color h: self hue s: self saturation
		v: (self brightness - 0.16 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:40'!
                            darker
	"Answer a darker shade of this color."

	^ self adjustBrightness: -0.08! !
!Color methodsFor: 'transformations' stamp: 'dew 3/8/2002 00:13'!
           duller

	^ self adjustSaturation: -0.03 brightness: -0.2! !
!Color methodsFor: 'transformations' stamp: 'dew 1/23/2002 20:19'!
 lighter
	"Answer a lighter shade of this color."

	^ self adjustSaturation: -0.03 brightness: 0.08! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:00'!
                         mixed: proportion with: aColor 
	"Mix with another color and do not preserve transpareny.  Only use this for extracting the RGB value and mixing it.  All other callers should use instead: 
	aColor alphaMixed: proportion with: anotherColor
	"

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Color
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:29'!
                           muchDarker

	^ self alphaMixed: 0.5 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:07'!
     muchLighter

	^ self alphaMixed: 0.233 with: Color white
! !
!Color methodsFor: 'transformations' stamp: 'ar 6/19/1999 00:36'!
 negated
	"Return an RGB inverted color"
	^Color
		r: 1.0 - self red
		g: 1.0 - self green
		b: 1.0 - self blue! !
!Color methodsFor: 'transformations' stamp: 'jmv 6/18/2017 20:37:53'!
        orColorUnlike: theOther
	"If this color is a lot like theOther, then return its complement, otherwide, return self"

	^ (self diff: theOther) < 0.3
		ifTrue: [theOther negated]
		ifFalse: [self]! !
!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:42'!
                        paler
	"Answer a paler shade of this color."

	^ self adjustSaturation: -0.09 brightness: 0.09
! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:41'!
                          quiteBlacker

	^ self alphaMixed: 0.8 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:44'!
 quiteWhiter

	^ self alphaMixed: 0.6 with: Color white! !
!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:43'!
    slightlyDarker

	^ self adjustBrightness: -0.03
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:43'!
          slightlyLighter

	^ self adjustSaturation: -0.01 brightness: 0.03! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:25'!
                        slightlyWhiter

	^ self alphaMixed: 0.85 with: Color white
! !
!Color methodsFor: 'transformations' stamp: 'jmv 5/7/2012 15:05'!
                               twiceDarker
	"Answer a significantly darker shade of this color."

	^ self adjustSaturation: 0.076 brightness: -0.15! !
!Color methodsFor: 'transformations' stamp: 'dew 3/4/2002 01:45'!
      twiceLighter
	"Answer a significantly lighter shade of this color."

	^ self adjustSaturation: -0.06 brightness: 0.15! !
!Color methodsFor: 'transformations' stamp: 'jmv 8/23/2009 23:24'!
    veryMuchDarker

	^ self alphaMixed: 0.25 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 7/28/2016 15:43:04'!
                           veryMuchLighter

	^ self alphaMixed: 0.07 with: Color white! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38'!
                              whiter

	^ self alphaMixed: 0.8333 with: Color white
! !
!Color methodsFor: 'private'!
         attemptToMutateError
	"A color is immutable. Once a color's red, green, and blue have been initialized, you cannot change them. Instead, create a new Color and use it."

	self error: 'Color objects are immutable once created'
! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:29:32'!
                            basicSetRed: r green: g blue: b
	"Initialize this color's r, g, and b components to the given values in the range [0.0..1.0]."

	self
		at: 1 put: r;
		at: 2 put: g;
		at: 3 put: b! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:15:44'!
          setHue: hue chroma: chroma brightness: brightness
	"Initialize this color to the given hue, chroma, and luma. See the comment in the instance creation method for details.
	http://en.wikipedia.org/wiki/HSL_and_HSV
		hue belongs in [0.0, 360.0)
		chroma and luma belongs in [0.0, 1.0]
	"

	| x hf i r1 g1 b1 m | 
	hf _ hue \\ 360.
	i _ hf // 60.  				"integer part of hue"
	x _ (hf \\ 60) / 60.0 .         		"fractional part of hue"
	x _ x \\  2 .
	i \\ 2 = 1 ifTrue: [ x _ 1.0 - x ].
	x _ chroma  * x.

	0 = i ifTrue: [ r1 _ chroma. g1 _ x. b1 _ 0.0 ].
	1 = i ifTrue: [ r1 _ x. g1 _ chroma. b1 _ 0.0 ].
	2 = i ifTrue: [ r1 _ 0.0. g1 _ chroma. b1 _ x ].
	3 = i ifTrue: [ r1 _ 0.0. g1 _ x. b1 _ chroma ].
	4 = i ifTrue: [ r1 _ x. g1 _ 0.0. b1 _ chroma ].
	5 = i ifTrue: [ r1 _ chroma. g1 _ 0.0. b1 _ x ].

	m _ brightness - ((r1 max: g1) max: b1).
	m < 0.0
		ifTrue: [ ^nil ]. "No color exists with required parameters"
	r1 _ r1 + m.
	r1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	g1 _ g1 + m.
	g1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	b1 _ b1 + m.
	b1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	self setRed: r1 green: g1 blue: b1! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:15:49'!
                              setHue: hue chroma: chroma luminance: luma
	"Initialize this color to the given hue, chroma, and luma. See the comment in the instance creation method for details.
	http://en.wikipedia.org/wiki/HSL_and_HSV
		hue belongs in [0.0, 360.0)
		chroma and luma belongs in [0.0, 1.0]
	"

	| x hf i r1 g1 b1 m | 

	hf _ hue \\ 360.
	i _ hf // 60.  				"integer part of hue"
	x _ (hf \\ 60) / 60.0 .         		"fractional part of hue"
	x _ x \\  2 .
	i \\ 2 = 1 ifTrue: [ x _ 1.0 - x ].
	x _ chroma  * x.

	0 = i ifTrue: [ r1 _ chroma. g1 _ x. b1 _ 0.0 ].
	1 = i ifTrue: [ r1 _ x. g1 _ chroma. b1 _ 0.0 ].
	2 = i ifTrue: [ r1 _ 0.0. g1 _ chroma. b1 _ x ].
	3 = i ifTrue: [ r1 _ 0.0. g1 _ x. b1 _ chroma ].
	4 = i ifTrue: [ r1 _ x. g1 _ 0.0. b1 _ chroma ].
	5 = i ifTrue: [ r1 _ chroma. g1 _ 0.0. b1 _ x ].

	m _ luma - (0.299*r1) - (0.587*g1) - (0.114*b1).
	m < 0.0
		ifTrue: [ ^nil ]. "No color exists with required parameters"
	r1 _ r1 + m.
	r1 > 1.0 
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	g1 _ g1 + m.
	g1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	b1 _ b1 + m.
	b1 > 1.0
		ifTrue: [ ^nil ]. "No color exists with required parameters".
	self setRed: r1 green: g1 blue: b1! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:16:07'!
                           setHue: hue saturation: saturation brightness: brightness
	"Initialize this color to the given hue, saturation, and brightness. See the comment in the instance creation method for details."

	| s v hf i f p q t | 
	s _ saturation asFloat min: 1.0 max: 0.0.
	v _ brightness asFloat min: 1.0 max: 0.0.
	hf _ hue \\ 360.
	i _ hf // 60.  			"integer part of hue"
	f _ (hf \\ 60) / 60.0.         	"fractional part of hue"

	p _ (1.0 - s) * v.
	q _ (1.0 - (s * f)) * v.
	t _ (1.0 - (s * (1.0 - f))) * v.

	0 = i ifTrue: [ ^ self setRed: v green: t blue: p ].
	1 = i ifTrue: [ ^ self setRed: q green: v blue: p ].
	2 = i ifTrue: [ ^ self setRed: p green: v blue: t ].
	3 = i ifTrue: [ ^ self setRed: p green: q blue: v ].
	4 = i ifTrue: [ ^ self setRed: t green: p blue: v ].
	5 = i ifTrue: [ ^ self setRed: v green: p blue: q ].

	self error: 'implementation error'! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:13:04'!
   setRed: r green: g blue: b

	self basicSetRed: r green: g blue: b! !
!Color methodsFor: 'private' stamp: 'jmv 6/18/2017 20:29:48'!
                             setRed: r green: g blue: b range: range
	"Initialize this color's r, g, and b components to the given values in the range [0..r]."

	self basicSetRed: r green: g blue: b.
	self /= range! !
!Color methodsFor: 'as yet unclassified' stamp: 'jmv 8/15/2015 18:23'!
                            color
	^ self! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 9/17/2015 15:22'!
    clipR: r g: g b: b
	"Return a color with the given r, g, and b components in the range [0.0..1.0].
	Clip if necessary"

	^ self 
		r: (r min: 1.0 max: 0.0)
		g: (g min: 1.0 max: 0.0)
		b: (b min: 1.0 max: 0.0)! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 4/2/2016 23:05'!
 colorFrom: parm
	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol or, if it is a list, it can either be an array of three numbers, which will be interpreted as RGB values, or a list of symbols, the first of which is sent to me and then the others of which are in turn sent to the prior result, thus allowing entries of the form #(blue darker).  Else just return the thing"

	| aColor firstParm |
	(parm is: #Color) ifTrue: [ ^ parm ].
	parm isSymbol ifTrue: [ ^ self perform: parm ].
	(parm isSequenceableCollection and: [ parm size > 0 ])
		ifTrue: [
			firstParm _ parm first.
			firstParm isNumber ifTrue: [
				^ self fromRgbTriplet: parm].
			aColor _ self colorFrom: firstParm.
			parm withIndexDo: [ :sym :ind |
				ind > 1 ifTrue: [
					aColor _ aColor perform: sym ]].
			^ aColor].
	^ parm

"
Color colorFrom: #(blue darker)
Color colorFrom: Color blue darker
Color colorFrom: #blue
Color colorFrom: #(0.0 0.0 1.0)
"! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/2/2016 15:04'!
                       colorFromPixelValue: p depth: d
	"Convert a pixel value for the given display depth into a color."
	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."
	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.
	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).
	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.
	Squeak also answers darkest possible blue when asked for black. Again, this is not needed in 32 bits (with alpha). It is also not really needed for 16 bits as we have an extra, unused bit: 16r8000 is not zero, but rgb=0, and hence, black.
	The real rule is that pixelValue=0 means transparent.
	And that darkest blue must be used instead of black, but only for depths >8 and < 16 (no indexed colors, no alpha)
	This method is updated to reflect that."

	| r g b alpha |

	d = 1 ifTrue: [^ self indexedColors at: (p bitAnd: 16r01) + 1].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	p = 0 ifTrue: [ ^Color transparent ].

	d = 8 ifTrue: [^ self indexedColors at: (p bitAnd: 16rFF) + 1].
	d = 4 ifTrue: [^ self indexedColors at: (p bitAnd: 16r0F) + 1].
	d = 2 ifTrue: [^ self indexedColors at: (p bitAnd: 16r03) + 1].

	d = 32 ifTrue: [
		"eight bits per component; 8 bits of alpha"
		alpha _ p bitShift: -24.
		alpha = 0 ifTrue: [ ^Color transparent ].
		r _ (p bitShift: -16) bitAnd: 16rFF.
		g _ (p bitShift: -8) bitAnd: 16rFF.
		b _ p bitAnd: 16rFF.
		^alpha < 255
			ifTrue: [ (Color r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]
			ifFalse: [ Color r: r g: g b: b range: 255 ]].

	d = 16 ifTrue: [
		"five bits per component. The most significant bit, unused, allows having real black, without p being zero"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		^ Color r: r g: g b: b range: 31].

	d = 15 ifTrue: [
		"five bits per component"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 31].

	d = 12 ifTrue: [
		"four bits per component"
		r _ (p bitShift: -8) bitAnd: 16rF.
		g _ (p bitShift: -4) bitAnd: 16rF.
		b _ p bitAnd: 16rF.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 15].

	d = 9 ifTrue: [
		"three bits per component"
		r _ (p bitShift: -6) bitAnd: 16r7.
		g _ (p bitShift: -3) bitAnd: 16r7.
		b _ p bitAnd: 16r7.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 7].

	self error: 'unknown pixel depth: ', d printString! !
!Color class methodsFor: 'instance creation' stamp: 'sqr 10/15/2016 20:41:04'!
       fromArray: colorDef

	| answer |
	colorDef size = 0 ifTrue: [^self transparent].
	colorDef size between: 3 and: 4 :: ifFalse: [self error: 'Undefined color definition'].
	answer _ self r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3).
	^colorDef size = 3
		ifTrue: [answer]
		ifFalse: [answer alpha: (colorDef at: 4)]! !
!Color class methodsFor: 'instance creation' stamp: 'sw 8/8/97 22:03'!
             fromRgbTriplet: list
	^ self r: list first g: list second b: list last! !
!Color class methodsFor: 'instance creation' stamp: 'pb 10/16/2016 18:42:44'!
        fromString: aString
	"For HTML color spec: #FFCCAA. Also support named colors.
	See http://www.w3schools.com/cssref/css_colors_legal.asp"
	"
	Color fromString: '#FFCCAA'.
	Color fromString: 'white'.
	Color fromString: 'orange'
	Color fromString: 'rgb(255,0,98)'
	"
	(aString size = 7 and: [ aString first = $# ]) ifTrue: [
		| aColorHexU red green blue |
		aColorHexU _ aString asUppercase.
		red _ ('16r', (aColorHexU copyFrom: 2 to: 3)) asNumber/255.
		green _ ('16r', (aColorHexU copyFrom: 4 to: 5)) asNumber/255.
		blue _ ('16r', (aColorHexU copyFrom: 6 to: 7)) asNumber/255.
		^ self r: red g: green b: blue].

	(aString beginsWith: 'rgb')
		ifTrue: [|values r g b|
				values := (aString allButFirst: 4) allButLast findTokens: ','.
				r  := (values first includes: $%)
						ifTrue: [(values first asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values first asInteger min: 255 max: 0) / 255.0].
				g := (values second includes: $%)
						ifTrue: [(values second asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values second asInteger min: 255 max: 0) / 255.0].
				b := (values third includes: $%)
						ifTrue: [(values third asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values third asInteger min: 255 max: 0) / 255.0].
				^self r: r g: g b: b].

	^self exactColorNamed: aString! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:29'!
                     gray: brightness
	"Return a gray shade with the given brightness in the range [0.0..1.0]."

	^ self new
		setRed: brightness
		green: brightness
		blue: brightness! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:31'!
           h: hue s: saturation v: brightness
	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."
	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."

	^ self new setHue: hue saturation: saturation brightness: brightness! !
!Color class methodsFor: 'instance creation' stamp: 'dew 3/19/2002 23:49'!
              h: h s: s v: v alpha: alpha

	^ (self h: h s: s v: v) alpha: alpha! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:34'!
            hue: hue chroma: chroma brightness: brightness
	^self new setHue: hue chroma: chroma brightness: brightness! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:37'!
   hue: hue chroma: chroma luminance: luma
	^self new setHue: hue chroma: chroma luminance: luma! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:39'!
                 hue: hue saturation: saturation brightness: brightness
	"Create a color with the given hue, saturation, and brightness. Hue is given as the angle in degrees of the color on the color circle where red is zero degrees. Saturation and brightness are numbers in [0.0..1.0] where larger values are more saturated or brighter colors. For example, (Color h: 0 s: 1 v: 1) is pure red."
	"Note: By convention, brightness is abbreviated 'v' to to avoid confusion with blue."

	^ self new setHue: hue saturation: saturation brightness: brightness! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:54:20'!
                       new
	^ self new: 3! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:41'!
                            r: r g: g b: b
	"Return a color with the given r, g, and b components in the range [0.0..1.0]."

	^ self new
		setRed: r
		green: g
		blue: b! !
!Color class methodsFor: 'instance creation'!
 r: r g: g b: b alpha: alpha

	^ (self r: r g: g b: b) alpha: alpha! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:43'!
            r: r g: g b: b range: range
	"Return a color with the given r, g, and b components specified as integers in the range [0..r]. This avoids the floating point arithmetic in the red:green:blue: message and is thus a bit faster for certain applications (such as computing a sequence of colors for a palette)."

	^ self new setRed: r green: g blue: b range: range! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 4/4/2015 20:30'!
            random
	"Return a random color that isn't too dark or under-saturated.
		Display fill: (10@10 extent: 200@200) fillColor: Color random
	"

	^ Random withDefaultDo: [ :random |
		self random: random ]! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 4/4/2015 20:30'!
           random2
	"Return a random color with a distribution that spans over all possible colors.
		Display fill: (10@10 extent: 200@200) fillColor: Color random2
	"

	^ Random withDefaultDo: [ :random |
		self random2: random ]! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:46'!
                   random2: aRandom
	"Return a random color with a distribution that spans over all possible colors."

	^ self new
		setRed: aRandom next
		green: aRandom next
		blue: aRandom next! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:56:48'!
                             random: aRandom
	"Return a random color that isn't too dark or under-saturated."

	^ self new
		setHue: (360.0 * aRandom next)
		saturation: (0.3 + (aRandom next * 0.7))
		brightness: (0.4 + (aRandom next * 0.6))! !
!Color class methodsFor: 'class initialization' stamp: 'jmv 4/17/2015 15:06'!
                          initializeGrayToIndexMap
	"Build an array of gray values available in the 8-bit colormap. This array is indexed by a gray level between black (1) and white (256) and returns the pixel value for the corresponding gray level."
	"Note: This method must be called after initializeIndexedColors, since it uses IndexedColors."
	"
	Color initializeGrayToIndexMap
	"

	| grayLevels grayIndices c distToClosest dist indexOfClosest indexedColors |
	"record the level and index of each gray in the 8-bit color table"
	grayLevels _ OrderedCollection new.
	grayIndices _ OrderedCollection new.
	indexedColors _ self indexedColors.
	"Note: skip the first entry, which is reserved for transparent"
	2 to: indexedColors size do: [:i |
		c _ indexedColors at: i.
		c saturation = 0.0 ifTrue: [  "c is a gray"
			grayLevels add: (c green * 255) rounded.  "0 to 255; R, G, and B are the same"
			grayIndices add: i - 1]].  "pixel values are zero-based"
	grayLevels _ grayLevels asArray.
	grayIndices _ grayIndices asArray.

	"for each gray level in [0..255], select the closest match"
	GrayToIndexMap _ ByteArray new: 256.
	0 to: 255 do: [ :level |
		distToClosest _ 10000.  "greater than distance to any real gray"
		1 to: grayLevels size do: [:i |
			dist _ (level - (grayLevels at: i)) abs.
			dist < distToClosest ifTrue: [
				distToClosest _ dist.
				indexOfClosest _ grayIndices at: i]].
		GrayToIndexMap at: (level + 1) put: indexOfClosest]! !
!Color class methodsFor: 'class initialization'!
                     initializeIndexedColors
	"Build an array of colors corresponding to the fixed colormap used
	 for display depths of 1, 2, 4, or 8 bits."
	"Color initializeIndexedColors"

	| a index grayVal |
	a _ Array new: 256.

	"1-bit colors (monochrome)"
	a at: 1 put: (Color r: 1.0 g: 1.0 b: 1.0).		"white or transparent"
	a at: 2 put: (Color r: 0.0 g: 0.0 b: 0.0).	"black"

	"additional colors for 2-bit color"
	a at: 3 put: (Color r: 1.0 g: 1.0 b: 1.0).	"opaque white"
	a at: 4 put: (Color r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"

	"additional colors for 4-bit color"
	a at:  5 put: (Color r: 1.0 g: 0.0 b: 0.0).	"red"
	a at:  6 put: (Color r: 0.0 g: 1.0 b: 0.0).	"green"
	a at:  7 put: (Color r: 0.0 g: 0.0 b: 1.0).	"blue"
	a at:  8 put: (Color r: 0.0 g: 1.0 b: 1.0).	"cyan"
	a at:  9 put: (Color r: 1.0 g: 1.0 b: 0.0).	"yellow"
	a at: 10 put: (Color r: 1.0 g: 0.0 b: 1.0).	"magenta"

	a at: 11 put: (Color r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"
	a at: 12 put: (Color r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"
	a at: 13 put: (Color r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"
	a at: 14 put: (Color r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"
	a at: 15 put: (Color r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"
	a at: 16 put: (Color r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"

	"additional colors for 8-bit color"
	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"
	index _ 17.
	1 to: 31 do: [:v |
		(v \\ 4) = 0 ifFalse: [
			grayVal _ v / 32.0.
			a at: index put: (Color r: grayVal g: grayVal b: grayVal).
			index _ index + 1]].

	"The remainder of color table defines a color cube with six steps
	 for each primary color. Note that the corners of this cube repeat
	 previous colors, but this simplifies the mapping between RGB colors
	 and color map indices. This color cube spans indices 40 through 255
	 (indices 41-256 in this 1-based array)."
	0 to: 5 do: [:r |
		0 to: 5 do: [:g |
			0 to: 5 do: [:b |
				index _ 41 + ((36 * r) + (6 * b) + g).
				index > 256 ifTrue: [
					self error: 'index out of range in color table compuation'].
				a at: index put: (Color r: r g: g b: b range: 5)]]].

	IndexedColors _ a.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48'!
                    colorRampForDepth: depth extent: aPoint
	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."
	"(Color colorRampForDepth: Display depth extent: 256@80) display"
	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"

	| f dx dy r |
	f _ Form extent: aPoint depth: depth.
	dx _ aPoint x // 256.
	dy _ aPoint y // 4.
	0 to: 255 do: [:i |
		r _ (dx * i)@0 extent: dx@dy.
		f fill: r fillColor: (Color r: i g: 0 b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: i b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: 0 b: i range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: i g: i b: i range: 255)].
	^ f
! !
!Color class methodsFor: 'examples' stamp: 'jmv 6/18/2017 21:29:30'!
                              experimentsTowarsANewColorPalette
"
self experimentsTowarsANewColorPalette
"
| selectedHue selectedSaturation selectedV selectedColor h s v color width height selectedChroma selectedLuminance |
width _ 300.
height _ 120.
selectedColor _ Color random.
selectedHue _ selectedColor hue.
selectedSaturation _ selectedColor saturation.
selectedChroma _ selectedColor chroma.
selectedV _ selectedColor brightness.
selectedLuminance _ selectedColor luminance.
Display getCanvas fillRectangle: (0@0 extent: height@height) color: selectedColor.
0 to: height do: [ :y |
	v _ 1.0 - (y / height).
	0 to: height do: [ :x |
		s _ x / height.
		color _ Color new setHue: selectedHue saturation: s brightness: v.
		Display colorAt: x@(y+height) put: color
	].
	DisplayScreen screenUpdateRequired: nil
].
0 to: height do: [ :y | | c |
	v _ 1.0 - (y / height).
	s _ 1.0 - (y / height).
	c _ s.
	0 to: width do: [ :x |
		h _ x / width * 360.
		
		color _ Color new setHue: h chroma: c luminance: selectedLuminance.
"		color _ Color new setHue: h chroma: c brightness: selectedV."
		color ifNil: [ color _ Color black ].
"		color _ Color new setHue: h saturation: s brightness: selectedV."
		Display colorAt: x+height@y put: color.
		
		color _ Color new setHue: h chroma: selectedChroma luminance: v.
"		color _ Color new setHue: h chroma: selectedChroma brightness: v."
		color ifNil: [ color _ Color black ].
"		color _ Color new setHue: h saturation: selectedSaturation brightness: v."
		Display colorAt: x+height@(y+height) put: color.
		
	].
	DisplayScreen screenUpdateRequired: nil
].! !
!Color class methodsFor: 'examples' stamp: 'tk 6/19/96'!
hotColdShades: thisMany
	"An array of thisMany colors showing temperature from blue to red to white hot.  (Later improve this by swinging in hue.)  "
	"Color showColors: (Color hotColdShades: 25)"

	| n s1 s2 s3 s4 s5 |
	thisMany < 5 ifTrue: [^ self error: 'must be at least 5 shades'].
	n _ thisMany // 5.
	s1 _ self white mix: self yellow shades: (thisMany - (n*4)).
	s2 _ self yellow mix: self red shades: n+1.
	s2 _ s2 copyFrom: 2 to: n+1.
	s3 _ self red mix: self green darker shades: n+1.
	s3 _ s3 copyFrom: 2 to: n+1.
	s4 _ self green darker mix: self blue shades: n+1.
	s4 _ s4 copyFrom: 2 to: n+1.
	s5 _ self blue mix: self black shades: n+1.
	s5 _ s5 copyFrom: 2 to: n+1.
	^ s1, s2, s3, s4, s5
! !
!Color class methodsFor: 'examples'!
                       showColorCube
	"Show a 12x12x12 color cube."
	"Color showColorCube"

	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				Display fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Color r: r g: g b: b range: 11)]]].
! !
!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48'!
       showColors: colorList
	"Display the given collection of colors across the top of the Display."

	| w r |
	w _ Display width // colorList size.
	r _ 0@0 extent: w@((w min: 30) max: 10).
	colorList do: [:c |
		Display fill: r fillColor: c.
		r _ r translatedBy: w@0].
! !
!Color class methodsFor: 'examples'!
             showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"Color showHSVPalettes"

	| left top c |
	left _ top _ 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left _ (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c _ Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4).
				Display fill: (left@top extent: 4@4) fillColor: c.

				c _ Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4) + 50.
				Display fill: (left@top extent: 4@4) fillColor: c]]].
! !
!Color class methodsFor: 'examples' stamp: 'jmv 1/14/2013 21:12'!
                        showHuesInteractively
	"Shows a palette of hues at a (saturation, brightness) point determined by the mouse position. Click the mouse button to exit and return the selected (saturation, brightness) point."
	"Color showHuesInteractively"

	| p s v |
	[Sensor isAnyButtonPressed] whileFalse: [
		p _ Sensor mousePoint.
		s _ p x asFloat / 300.0.
		v _ p y asFloat / 300.0.
		self showColors: (self wheel: 12 saturation: s brightness: v)].
	^ (s min: 1.0) @ (v min: 1.0)! !
!Color class methodsFor: 'examples'!
    wheel: thisMany
	"Return a collection of thisMany colors evenly spaced around the color wheel."
	"Color showColors: (Color wheel: 12)"

	^ Color wheel: thisMany saturation: 0.9 brightness: 0.7
! !
!Color class methodsFor: 'examples'!
                      wheel: thisMany saturation: s brightness: v
	"Return a collection of thisMany colors evenly spaced around the color wheel, all of the given saturation and brightness."
	"Color showColors: (Color wheel: 12 saturation: 0.4 brightness: 1.0)"
	"Color showColors: (Color wheel: 12 saturation: 0.8 brightness: 0.5)"

	^ (Color h: 0.0 s: s v: v) wheel: thisMany
! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
                   aqua

	^ self colorNamesDict at: #aqua! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
                beige

	^ self colorNamesDict at: #beige! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
              black

	^ self colorNamesDict at: #black! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
              blue

	^ self colorNamesDict at: #blue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
                brightGreen

	^ self colorNamesDict at: #brightGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:58'!
  brown

	^ self colorNamesDict at: #brown! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
              cyan

	^ self colorNamesDict at: #cyan! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
                darkBlue

	^ self colorNamesDict at: #darkBlue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
        darkGray

	^ self colorNamesDict at: #darkGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
        darkGreen

	^ self colorNamesDict at: #darkGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
      darkPink

	^ self colorNamesDict at: #darkPink! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
        darkPurple

	^ self colorNamesDict at: #darkPurple! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
    forestGreen

	^ self colorNamesDict at: #forestGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
  gray

	^ self colorNamesDict at: #gray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
                green

	^ self colorNamesDict at: #green! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
              grey

	^ self colorNamesDict at: #grey! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
                hotPink

	^ self colorNamesDict at: #hotPink! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
          indigo

	^ self colorNamesDict at: #indigo! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
            lavender

	^ self colorNamesDict at: #lavender! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
        lightBlue

	^ self colorNamesDict at: #lightBlue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
      lightBrown

	^ self colorNamesDict at: #lightBrown! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
    lightCyan

	^ self colorNamesDict at: #lightCyan! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
      lightGray

	^ self colorNamesDict at: #lightGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
      lightGreen

	^ self colorNamesDict at: #lightGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
    lightMagenta

	^ self colorNamesDict at: #lightMagenta! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 14:59'!
lightOrange

	^ self colorNamesDict at: #lightOrange! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
  lightPink

	^ self colorNamesDict at: #lightPink! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
      lightPurple

	^ self colorNamesDict at: #lightPurple! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
  lightRed

	^ self colorNamesDict at: #lightRed! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
        lightYellow

	^ self colorNamesDict at: #lightYellow! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
  lilac

	^ self colorNamesDict at: #lilac! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
              lime

	^ self colorNamesDict at: #lime! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
                limeGreen

	^ self colorNamesDict at: #limeGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
      magenta

	^ self colorNamesDict at: #magenta! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
          maroon

	^ self colorNamesDict at: #maroon! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
            mauve

	^ self colorNamesDict at: #mauve! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
              mustard

	^ self colorNamesDict at: #mustard! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
          navyBlue

	^ self colorNamesDict at: #navyBlue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
        olive

	^ self colorNamesDict at: #olive! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
              oliveGreen

	^ self colorNamesDict at: #oliveGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
    orange

	^ self colorNamesDict at: #orange! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
            paleGreen

	^ self colorNamesDict at: #paleGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
      peach

	^ self colorNamesDict at: #peach! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
              periwinkle

	^ self colorNamesDict at: #periwinkle! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
    pink

	^ self colorNamesDict at: #pink! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
                purple

	^ self colorNamesDict at: #purple! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:00'!
            red

	^ self colorNamesDict at: #red! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                  royalBlue

	^ self colorNamesDict at: #royalBlue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
      salmon

	^ self colorNamesDict at: #salmon! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
            seaGreen

	^ self colorNamesDict at: #seaGreen! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
        skyBlue

	^ self colorNamesDict at: #skyBlue! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
          tan

	^ self colorNamesDict at: #tan! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                  teal

	^ self colorNamesDict at: #teal! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                transparent

	^ self colorNamesDict at: #transparent! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
  turquoise

	^ self colorNamesDict at: #turquoise! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
      veryDarkGray

	^ self colorNamesDict at: #veryDarkGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
veryLightGray

	^ self colorNamesDict at: #veryLightGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                              veryVeryDarkGray

	^ self colorNamesDict at: #veryVeryDarkGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                        veryVeryLightGray

	^ self colorNamesDict at: #veryVeryLightGray! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
                      violet

	^ self colorNamesDict at: #violet! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
            white

	^ self colorNamesDict at: #white! !
!Color class methodsFor: 'named colors' stamp: 'jmv 4/17/2015 15:01'!
              yellow

	^ self colorNamesDict at: #yellow! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:49'!
               cachedColormapForGrayFrom: sourceDepth
	"Return a cached colormap for mapping from the given depth to the 8bpp grays. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| srcIndex map |
	ToGrayColormaps ifNil: [
		ToGrayColormaps _ Array new: 5].
	
	srcIndex _ sourceDepth highBit min: 5.

	(ToGrayColormaps at: srcIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapForGray8bppFrom: sourceDepth.
	ToGrayColormaps at: srcIndex put: map.
	^ map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 14:50'!
                               cachedColormapFrom: sourceDepth to: destDepth
	"Return a cached colormap for mapping between the given depths. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| srcIndex dstIndex map |
	CachedColormaps
		ifNil: [CachedColormaps _ (1 to: 5) collect: [:i | Array new: 6]].

	srcIndex _ sourceDepth highBit min: 5.
	dstIndex _ destDepth highBit.

	((CachedColormaps at: srcIndex) at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapFrom: sourceDepth to: destDepth.
	(CachedColormaps at: srcIndex) at: dstIndex put: map.
	^ map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:49'!
     cachedColormapFromGrayTo: destDepth
	"Return a cached colormap for mapping from 8bpp grays to the given depth. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"
	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."
	"Note: The color maps for sourceDepth=16 and for sourceDepth=32 are the same"

	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| dstIndex map |
	FromGrayColormaps
		ifNil: [FromGrayColormaps _ Array new: 6 ].

	dstIndex _ destDepth highBit.

	(FromGrayColormaps at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ self computeColormapFromGray8bppForDepth: destDepth.
	FromGrayColormaps at: dstIndex put: map.
	^ map! !
!Color class methodsFor: 'colormaps'!
  colorMapIfNeededFrom: sourceDepth to: destDepth
	"Return a colormap for mapping between the given depths, or nil if no colormap is needed."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"

	sourceDepth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"

	(sourceDepth >= 16) & (destDepth >= 16) ifTrue: [
		"mapping is done in BitBlt by zero-filling or truncating each color component"
		^ nil].

	^ Color cachedColormapFrom: sourceDepth to: destDepth
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 8/27/2009 08:47'!
   computeColorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix
	"Note: The color converting map for sourceDepth=16 and for sourceDepth=32 are the same"
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color.
		Assumed not to include subpixelAA"
		^ self computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	] ifFalse: [
		"source is 16-bit or 32-bit RGB.
		Might include subpixelAA"
		^ self computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	]! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:55'!
          computeColormapForGray8bppFrom: sourceDepth
	"Compute a colorMap for translatingfrom the given depth to the 8bpp grays"
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| map |
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color"
		map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))
					collect: [ :c | (c luminance * 255) rounded].
		map _ map as: Bitmap.
		^ map
		]
	ifFalse: [
		^ self computeRGBColormapForGray8 ]! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 4/17/2015 15:05'!
                              computeColormapFrom: sourceDepth to: destDepth
	"Compute a colorMap for translating between the given depths. A colormap is a Bitmap whose entries contain the pixel values for the destination depth. Typical clients use cachedColormapFrom:to: instead."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| map bitsPerColor |
	sourceDepth < 16 ifTrue: [
		"source is 1-, 2-, 4-, or 8-bit indexed color"
		map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))
					collect: [:c | c pixelValueForDepth: destDepth].
		map _ map as: Bitmap.
	] ifFalse: [
		"source is 16-bit or 32-bit RGB"
		destDepth > 8
			ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
			ifFalse: [bitsPerColor _ 4].
		map _ self computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor].

	"Note: zero is transparent except when source depth is one-bit deep"
	sourceDepth > 1 ifTrue: [map at: 1 put: 0].
	^ map
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:56'!
                               computeColormapFromGray8bppForDepth: destDepth
	"Return a colormap for displaying a GrayForm at the given depth"

	| newMap |
	newMap _ Bitmap new: 256.
	1 to: 256 do: [ :i |
		newMap
			at: i
			put: ((Color gray: (i-1) asFloat / 255.0) pixelValueForDepth: destDepth)].
	^ newMap! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 4/17/2015 15:05'!
 computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	| map |
	
	map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth)) collect: [ :cc | | f c |
		f _ 1.0 - (cc red + cc green + cc blue / 3.0 ).
		c _ targetColor
			ifNotNil: [
				destDepth = 32
					ifTrue: [ targetColor * f alpha: f]
					ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]
			ifNil: [ cc ].
		destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f = 0.0
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]]].
	map _ map as: Bitmap.
	^map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 12/26/2011 13:49'!
                               computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: Preferences aaFontsColormapDepth.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Color
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]]
			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 1/30/2011 23:10'!
                               computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| mask map c |
	(#(3 4 5) includes: bitsPerColor)
		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Color
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c pixelValueForDepth: destDepth)].

	map at: 1 put: (Color transparent pixelWordForDepth: destDepth).  "zero always transparent"
	^ map
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:57'!
                              computeRGBColormapForGray8
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to 8bpp grays, using the default number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| bitsPerColor mask map c |
	bitsPerColor _ 5.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Color
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c luminance * 255) rounded].

	^ map! !
!Color class methodsFor: 'other' stamp: 'jmv 1/31/2011 09:30'!
  maskingMap: depth
	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero. Cache the most recently used map."
	"Warning: The behavior is incorrect if depth = 32.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| sizeNeeded |
	depth <= 8
		ifTrue: [sizeNeeded _ 1 bitShift: depth]
		ifFalse: [sizeNeeded _ 4096].

	(MaskingMap == nil or: [MaskingMap size ~= sizeNeeded]) ifTrue:
		[MaskingMap _ Bitmap new: sizeNeeded withAll: 16rFFFFFFFF.
		MaskingMap at: 1 put: 0.  "transparent"].

	^ MaskingMap
! !
!Color class methodsFor: 'color from user' stamp: 'jmv 3/1/2010 15:13'!
                         colorPaletteForDepth: depth extent: chartExtent
	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorPaletteForDepth: 16 extent: 190@60) display"

	| basicHue x y startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [ :h |
		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [ :n | | c |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [ :n | | c |
 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [ :n | | c |
 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color from user' stamp: 'jmv 7/27/2009 11:32'!
               colorTest: depth extent: chartExtent colorMapper: colorMapper
	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 7) asInteger / 7
			g: (c green * 7) asInteger / 7
			b: (c blue * 3) asInteger / 3]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 5) asInteger / 5
			g: (c green * 5) asInteger / 5
			b: (c blue * 5) asInteger / 5]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 15) asInteger / 15
			g: (c green * 15) asInteger / 15
			b: (c blue * 15) asInteger / 15]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 31) asInteger / 31
			g: (c green * 31) asInteger / 31
			b: (c blue * 31) asInteger / 31]) display"

	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |
		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [:n |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [:n |
 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [:n |
 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.
		c _ colorMapper value: c.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/26/2013 20:13'!
     colorNames
	"Answer the current dictionary of  name->color associations."

	^self colorNamesDict keys! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/28/2013 20:34'!
           defaultColorNamesDictionary
	"Answer a amall but  useful name->color dictionary"
	
	| defaultDict |
	"Meld most used xkcd colors into traditional colors."
	defaultDict := (self traditionalColorNamesDictionary addAll: 
					self xkcdFirst48ColorNamesDictionary; 
					yourself).
		
	"Override traditional names existing in extended XKCD naming"
	defaultDict at: #lightYellow    put: (Color r: 1.0 g: 0.996 b: 0.478).
	defaultDict at: #lightOrange   put: (Color r: 0.992 g: 0.667 b: 0.283).
	defaultDict at: #lightCyan        put: (Color r: 0.674 g: 1.0 b: 0.988).
	defaultDict at: #lightRed          put: (Color r: 1.0 g: 0.279 b: 0.298).
	defaultDict at: #lightMagenta put: (Color r: 0.98 g: 0.372 b: 0.969).
	
	^defaultDict! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 2/1/2013 14:39'!
                             doesNotUnderstand: aMessage
	"Some code takes
		 Color colorNames 
	and does
		Color perform: aColorname.
		
	Make this work."

	^(Color colorNamesDict) 
		at: (aMessage selector)
		ifAbsent: [super doesNotUnderstand: aMessage]! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/26/2013 20:51'!
             exactColorNamed: aColorName

	"Answer color matching name or nil 
	from my ColorName->Color Dictionary"
	
	^ self colorNamesDict at: (aColorName asSymbol) ifAbsent: [nil]! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 7/25/2014 21:22'!
      setColorNamesDict: aNameColorDictionary
	"Answer the current dictionary of  name->color associations."
	
	"Note: This is a non-standard name because this is a non-standard action!!
	Do this if you really, really know what you are doing."
	
	"Some Colors are required for proper system operation"
	Color defaultColorNamesDictionary keysAndValuesDo: [ :colorName :colorValue |
		aNameColorDictionary at: colorName ifAbsentPut: colorValue
	].

	ColorNamesDict := aNameColorDictionary! !
!Color class methodsFor: 'color name lookup' stamp: 'sqr 10/21/2016 12:44:48'!
             traditionalColorNamesDictionary
	"Answer a dictionary of Squeak traditional name->color associations.."

	| nameDict |
	nameDict _ Dictionary new.
	nameDict at: #black put: (Color r: 0 g: 0 b: 0).
	nameDict at: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).
	nameDict at: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).
	nameDict at: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).
	nameDict at: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).
	nameDict at: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).
	nameDict at: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).
	nameDict at: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).
	nameDict at: #white put: (Color r: 1.0 g: 1.0 b: 1.0).
	nameDict at: #red put: (Color r: 1.0 g: 0 b: 0).
	nameDict at: #yellow put: (Color r: 1.0 g: 1.0 b: 0).
	nameDict at: #green put: (Color r: 0 g: 1.0 b: 0).
	nameDict at: #cyan put: (Color r: 0 g: 1.0 b: 1.0).
	nameDict at: #blue put: (Color r: 0 g: 0 b: 1.0).
	nameDict at: #magenta put: (Color r: 1.0 g: 0 b: 1.0).
	nameDict at: #brown put: (Color r: 0.6 g: 0.2 b: 0).
	nameDict at: #orange put: (Color r: 1.0 g: 0.6 b: 0).
	nameDict at: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).
	nameDict at: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).
	nameDict at: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).
	nameDict at: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).
	nameDict at: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).
	nameDict at: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).
	nameDict at: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).
	nameDict at: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).
	nameDict at: #transparent put: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.0).
	
	^nameDict
! !
!Color class methodsFor: 'color name lookup' stamp: 'jmv 6/30/2014 15:22'!
               xkcdFirst48ColorNamesDictionary
	"XKCD color names are based on a survey oc colors people call by the same name.
	 http://blog.xkcd.com/2010/05/03/color-survey-results/"

	"Answer a dictionary of the most agreed upon first 48 xkcd colors"
"
	Color xkcdFirst48ColorNamesDictionary explore.
"	
	| xkcdDict |
	xkcdDict := Dictionary new
	at: #lightPink put: (Color fromString: '#ffd1df') ;
	at: #mustard put: (Color fromString: '#ceb301') ;
	at: #indigo put: (Color fromString: '#380282') ;
	at: #lime put: (Color fromString: '#aaff32') ;
	at: #seaGreen put: (Color fromString: '#53fca1') ;
	at: #periwinkle put: (Color fromString: '#8e82fe') ;
	at: #darkPink put: (Color fromString: '#cb416b') ;
	at: #oliveGreen put: (Color fromString: '#677a04') ;
	at: #peach put: (Color fromString: '#ffb07c') ;
	at: #paleGreen put: (Color fromString: '#c7fdb5') ;
	at: #lightBrown put: (Color fromString: '#ad8150') ;
	at: #hotPink put: (Color fromString: '#ff028d') ;
	at: #black put: (Color fromString: '#000000') ;
	at: #lilac put: (Color fromString: '#cea2fd') ;
	at: #navyBlue put: (Color fromString: '#001146') ;
	at: #royalBlue put: (Color fromString: '#0504aa') ;
	at: #beige put: (Color fromString: '#e6daa6') ;
	at: #salmon put: (Color fromString: '#ff796c') ;
	at: #olive put: (Color fromString: '#6e750e') ;
	at: #maroon put: (Color fromString: '#650021') ;
	at: #brightGreen put: (Color fromString: '#01ff07') ;
	at: #darkPurple put: (Color fromString: '#35063e') ;
	at: #mauve put: (Color fromString: '#ae7181') ;
	at: #forestGreen put: (Color fromString: '#06470c') ;
	at: #aqua put: (Color fromString: '#13eac9') ;
	at: #cyan put: (Color fromString: '#00ffff') ;
	at: #tan put: (Color fromString: '#d1b26f') ;
	at: #darkBlue put: (Color fromString: '#00035b') ;
	at: #lavender put: (Color fromString: '#c79fef') ;
	at: #turquoise put: (Color fromString: '#06c2ac') ;
	at: #darkGreen put: (Color fromString: '#033500') ;
	at: #violet put: (Color fromString: '#9a0eea') ;
	at: #lightPurple put: (Color fromString: '#bf77f6') ;
	at: #limeGreen put: (Color fromString: '#89fe05') ;
	at: #grey put: (Color fromString: '#929591') ;
	at: #skyBlue put: (Color fromString: '#75bbfd') ;
	at: #yellow put: (Color fromString: '#ffff14') ;
	at: #magenta put: (Color fromString: '#c20078') ;
	at: #lightGreen put: (Color fromString: '#96f97b') ;
	at: #orange put: (Color fromString: '#f97306') ;
	at: #teal put: (Color fromString: '#029386') ;
	at: #lightBlue put: (Color fromString: '#95d0fc') ;
	at: #red put: (Color fromString: '#e50000') ;
	at: #brown put: (Color fromString: '#653700') ;
	at: #pink put: (Color fromString: '#ff81c0') ;
	at: #blue put: (Color fromString: '#0343df') ;
	at: #green put: (Color fromString: '#15b01a') ;
	at: #purple put: (Color fromString: '#7e1e9c') ;
  	yourself.

	^xkcdDict

! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:26'!
      blueColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueColorDict explore.
"
	^self blueColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:24'!
     blueColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlue)
				or: [assoc key asString asLowercase includesSubString: 'blue'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:28'!
                   blueGreenColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueGreenColorDict explore.
"
	^self blueGreenColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:29'!
                      blueGreenColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlueGreen)
				or: [assoc key asString asLowercase includesSubString: 'bluegreen'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:31'!
    brightColorDict
	"Answer a dictionary of named colors considered Bright"
"
	Color brightColorDict explore.
"
	^self brightColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:31'!
                             brightColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isBright) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:34'!
                     brownColorDict
	"Answer a dictionary of named colors considered Brown"
"
	Color brownColorDict explore.
"
	^self brownColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:33'!
 brownColorDict: aColorDict
	"Answer a dictionary of named colors considered Brown"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBrown)
				or: [assoc key asString asLowercase includesSubString: 'brown'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:36'!
               darkColorDict
	"Answer a dictionary of named colors considered Dark"
"
	Color darkColorDict explore.
"
	^self darkColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:37'!
     darkColorDict: aColorDict
	"Answer a dictionary of named colors considered Dark"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isDark) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:41'!
                           grayColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:38'!
                   greenColorDict
	"Answer a dictionary of named colors considered Green"
"
	Color greenColorDict explore.
"
	^self greenColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:38'!
 greenColorDict: aColorDict
	"Answer a dictionary of named colors considered Green"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGreen)
				or: [assoc key asString asLowercase includesSubString: 'green'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:41'!
               greyColorDict
	"Answer a dictionary of named colors considered Grey"
"
	Color greyColorDict explore.
"
	^self greyColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:40'!
     greyColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:44'!
                   lightColorDict
	"Answer a dictionary of named colors considered light"
"
	Color lightColorDict explore.
"
	^self lightColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:43'!
 lightColorDict: aColorDict
	"Answer a dictionary of named colors considered Liight"

	^self brightColorDict: aColorDict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:46'!
 orangeColorDict
	"Answer a dictionary of named colors considered Orange"
"
	Color orangeColorDict explore.
"
	^self orangeColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:46'!
                             orangeColorDict: aColorDict
	"Answer a dictionary of named colors considered Orange"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isOrange)
				or: [assoc key asString asLowercase includesSubString: 'orange'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:48'!
           pastelColorDict
	"Answer a dictionary of named colors considered Pastel"
"
	Color pastelColorDict explore.
"
	^self pastelColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:48'!
                             pastelColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isPastel) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:50'!
                     pinkColorDict
	"Answer a dictionary of named colors considered Pink"
"
	Color pinkColorDict explore.
"
	^self pinkColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:50'!
     pinkColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isPink)
				or: [assoc key asString asLowercase includesSubString: 'pink'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:52'!
                   purpleColorDict
	"Answer a dictionary of named colors considered Purple"
"
	Color purpleColorDict explore.
"
	^self purpleColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:52'!
                             purpleColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc key asString asLowercase includesSubString: 'purple')
				or: [assoc key asString asLowercase includesSubString: 'violet'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:54'!
       redColorDict
	"Answer a dictionary of named colors considered Red"
"
	Color redColorDict explore.
"
	^self redColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:53'!
         redColorDict: aColorDict
	"Answer a dictionary of named colors considered Red"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isRed)
				or: [assoc key asString asLowercase includesSubString: 'red'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:56'!
                       saturatedColorDict
	"Answer a dictionary of named colors considered Saturated"
"
	Color saturatedColorDict explore.
"
	^self saturatedColorDict: (self colorNamesDict )! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:55'!
                 saturatedColorDict: aColorDict
	"Answer a dictionary of named colors considered Saturated"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isSaturated) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:26'!
            yellowColorDict
	"Answer a dictionary of named colors considered Yellow"
"
	Color yellowColorDict explore.
"
	^self yellowColorDict: (self colorNamesDict)! !
!Color class methodsFor: 'selection' stamp: 'KenD 1/30/2013 17:19'!
                              yellowColorDict: aColorDict
	"Answer a dictionary of named colors considered Yellow"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isYellow)
				or: [assoc key asString asLowercase includesSubString: 'yellow'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: 'color space conversions' stamp: 'jmv 4/24/2013 10:55'!
                              applySimpleGamma: gamma to: value
	"Encode / decode Gamma. Typical gamma are 0.4545 ( = 1.0 / 2.2, for encoding) and 2.2 (for decoding)
	In a non gamma encoded image, the pixel values are proportional to luminance, i.e. the actual light intensity, the photon count.
	In an gamma encoded image, the pixel value is close to the average perceived brightness, or 'lightness'. This optimizes the use of available bits in digital images, and dynamic range in analog images and film. This is like the 'luma' signal in video.

	Usually:
		- Images stored in file formats such as jpg, png, tiff and bmp are gamma encoded
				(unless they are actually raw images).
		- Images sent to a framebuffer (video memory) should be gamma encoded.
		- Raw images from sensors are not gamma encoded.

		- Image processing algorithms that simulate the real world, or are applied to real world data should work on unencoded (linear) images.
				This includes filtering, resizing, blending, and most operations done on images.
				This means that if the images come from jpg photos from a camera, they should be gamma decoded.
		- Image processing algorithms that works on human perception should work on gamma encoded images.
				This includes histograms, histogram equalization, bit allocation (i.e. quantization), compression, etc.
				This also includes detecting objects like a human would do
				

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html

	Mostly for documentation.
	value must be in [0.0 .. 1.0].
	Note that the sRGB standard specifies a function that is close to this, but slightly different.
	See #linearTosRGBGamma: and #sRGBGammaToLinear:"

	^ value raisedTo: gamma! !
!Color class methodsFor: 'color space conversions' stamp: 'jmv 4/24/2013 10:49'!
            linearTosRGBGamma: value
	"The sRGB standard specifies a gamma curve that is close to gamma = 2.2, but is actually
	built from one stright line segment, and a curve with exponent = 2.4.
	This method converts value from linearSpace to gammaSpace, i.e. it 'encodes' with gamma.
	This is the operation done when producing an 8bit Form for displaying, or for saving on a JPG, PNG, etc; if source data is in linear space (for example, from raw data a sensor image, or data that was converted previously to linear space for proper image processing).
	value must be in [0.0 .. 1.0].

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html
		http://entropymine.com/imageworsener/srgbformula
	
	| r v |
	r _ Random new.
	1000 timesRepeat: [
		v _ r next.
		self assert: ((Color sRGBGammaToLinear: (Color linearTosRGBGamma: v)) closeTo: v) ]

	| r |
	r _ 10@10 extent: 600@400.
	Display fill: r fillColor: Color white.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color linearTosRGBGamma: v ]) in: r color: Color black min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color applySimpleGamma: 1/2.2 to: v ]) in: r color: Color blue min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color sRGBGammaToLinear: v ]) in: r color: Color black min: 0.0 max: 1.0.
	FFT new plot: ((0.0 to: 1.0 count: 100) collect: [ :v | Color applySimpleGamma: 2.2 to: v ]) in: r color: Color blue min: 0.0 max: 1.0.
	"

	^ value <= 0.00313066844250063
		ifTrue: [ value * 12.92 ]
		ifFalse: [ (value raisedTo: 1.0/2.4) * 1.055 - 0.055 ]! !
!Color class methodsFor: 'color space conversions' stamp: 'jmv 4/24/2013 10:50'!
                sRGBGammaToLinear: value
	"The sRGB standard specifies a gamma curve that is close to gamma = 2.2, but is actually
	built from one stright line segment, and a curve with exponent = 2.4.
	This method converts value from gammaSpace to linearSpace, i.e. it 'decodes'.
	This is the operation done by display screens. It is also needed to convert 8bit Forms (from a frameBuffer, or from PNG, JPG, etc.) to linear space for proper image processing.
	value must be in [0.0 .. 1.0].

	See
		http://en.wikipedia.org/wiki/Gamma_correction
		http://www.poynton.com/notes/colour_and_gamma/GammaFAQ.html
		http://entropymine.com/imageworsener/srgbformula
	"

	^ value <= 0.0404482362771082
		ifTrue: [ value / 12.92 ]
		ifFalse: [ value + 0.055 / 1.055 raisedTo: 2.4 ]! !
!Color class methodsFor: 'cached state access' stamp: 'jmv 4/17/2015 14:58'!
                            colorNamesDict
	"Answer the current dictionary of  name->color associations."
"
	Color colorNamesDict explore.
"
	ColorNamesDict ifNil: [
		self setColorNamesDict: self defaultColorNamesDictionary ].
	^ColorNamesDict! !
!Color class methodsFor: 'cached state access' stamp: 'jmv 4/17/2015 15:08'!
                       grayToIndexMap
	"
	Color grayToIndexMap explore.
	"
	GrayToIndexMap ifNil: [
		self initializeGrayToIndexMap ].
	^GrayToIndexMap! !
!Color class methodsFor: 'cached state access' stamp: 'jmv 4/17/2015 15:04'!
               indexedColors
	"
	Color indexedColors explore.
	"
	IndexedColors ifNil: [
		self initializeIndexedColors ].
	^IndexedColors! !
!Color class methodsFor: 'cached state access' stamp: 'jmv 5/12/2016 14:58'!
                    releaseClassCachedState
	"
	Color releaseClassCachedState
	"
	CachedColormaps _ nil. 		"Maps to translate between color depths"
	ToGrayColormaps _ nil.			"Maps colors to 8bpp grays for various color depths"
	FromGrayColormaps _ nil.		"Maps from 8bpp grays to colors of various depths"
	MaskingMap _ nil. 				"Maps all colors except transparent to black for creating a mask"
	ColorNamesDict _ nil.
	IndexedColors _ nil.
	GrayToIndexMap _ nil! !
!TranslucentColor methodsFor: 'accessing' stamp: 'jmv 6/18/2017 20:41:17'!
                         alpha
	"Return my alpha value, a number between 0.0 and 1.0 where 0.0 is completely transparent and 1.0 is completely opaque."

	^ self at: 4! !
!TranslucentColor methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:06'!
         storeArrayValuesOn: aStream

	self isTransparent ifTrue: [
		^ aStream space].
	super storeArrayValuesOn: aStream.
	aStream space.
	self alpha printOn: aStream fractionDigits: 3! !
!TranslucentColor methodsFor: 'printing' stamp: 'jmv 1/5/2014 21:20'!
     storeOn: aStream

	self isTransparent ifTrue: [^ aStream nextPutAll: '(Color transparent)'].
	aStream
		nextPut: $(;
		nextPutAll: self class name;
		nextPutAll: ' r: '.
	self red printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' g: '.
	self green printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' b: '.
	self blue printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ' alpha: '.
	self alpha printOn: aStream fractionDigits: 3.
	aStream nextPutAll: ')'! !
!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:55:03'!
                     alpha: alphaValue
	"Return a new TranslucentColor with the given amount of opacity ('alpha')."
	alphaValue = 1.0 ifTrue: [
		^ Color new
			setRed: self red
			green: self green
			blue: self blue].
	^ super alpha: alphaValue! !
!TranslucentColor methodsFor: 'conversions' stamp: 'sw 10/27/1999 10:51'!
                 asNontranslucentColor
	^ self alpha: 1.0! !
!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 4/19/2013 16:10'!
          bitPatternForDepth: depth
	"Return an appropriate bit pattern. This will almost never be meaningful for tranlucentColors, except for the degenerate case of tranparency."

	self isTransparent ifTrue: [
		^ Bitmap with: 0].
	^ super bitPatternForDepth: depth! !
!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:41:47'!
               pixelValueForDepth: d
	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."
	| basicPixelWord |
	"In 32bpp, if alpha = 0, ignore any color components, and answer R=0, G=0, B=0, Alpha=0.
	In depths > 8 and < 32, pixelValue zero is the special value used by BitBlt to denote transparent."
	self isTransparent ifTrue: [
		^ 0].
	basicPixelWord _ super pixelValueForDepth: d.
	^d < 32
		ifTrue: [ basicPixelWord ]
		ifFalse: [ (basicPixelWord bitAnd: 16rFFFFFF) bitOr:
			((self alpha*255.0) rounded
				bitShift: 24) ]! !
!TranslucentColor methodsFor: 'conversions' stamp: 'jmv 6/18/2017 20:41:50'!
                            pixelWordForDepth: depth
	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."

	| basicPixelWord |
	self isTransparent ifTrue: [^ 0].
	basicPixelWord _ super pixelWordForDepth: depth.
	^depth < 32
		ifTrue: [ basicPixelWord ]
		ifFalse: [ (basicPixelWord bitAnd: 16rFFFFFF) bitOr:
			((self alpha*255.0) rounded
				bitShift: 24) ]! !
!TranslucentColor methodsFor: 'private' stamp: 'jmv 6/18/2017 20:42:05'!
                       setRed: r green: g blue: b alpha: alphaValue

	self basicSetRed: r green: g blue: b.
	self at: 4 put: alphaValue! !
!TranslucentColor methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:41:26'!
   isOpaque

	^self alpha = 1.0! !
!TranslucentColor methodsFor: 'queries' stamp: 'jmv 6/18/2017 20:41:54'!
                       isTransparent
	^ self alpha = 0.0! !
!TranslucentColor class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:54:35'!
  new
	^ self new: 4! !
!TranslucentColor class methodsFor: 'instance creation' stamp: 'jmv 6/18/2017 20:57:08'!
                 r: r g: g b: b alpha: alphaValue
	"Return a color with the given r, g, and b components in the range [0.0..1.0]."

	^ self new
		setRed: r
		green: g
		blue: b
		alpha: alphaValue! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3110-CallItColorAgain-JuanVuletich-2017Jun19-11h54m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3109] on 19 June 2017 at 12:07:06 pm'!
!Integer methodsFor: 'converting' stamp: 'ar 10/31/1998 23:04' prior: 50348248!
                 asColorOfDepth: d
	"Return a color value representing the receiver as color of the given depth"
	^Color colorFromPixelValue: self depth: d! !
!InputSensor methodsFor: 'keyboard' stamp: 'jmv 9/2/2016 11:08:09' prior: 50348256!
                              kbdTest
	"
	Sensor kbdTest
	"
	"This test routine will print the unmodified character, its keycode,
	and the OR of all its modifier bits, until the character x is typed

Also useful:
	Sensor test
	"
	| char |
	char _ nil.
	[ char = $x ] whileFalse: [
		[ self keyboardPressed ] whileFalse.
		char _ self keyboard.
		Display fill: (5@5 extent: 400@20) fillColor: Color white.
		(String streamContents: [ :s |
			s
				nextPut: $-;
				nextPut: char;
				nextPut: $-;
				space;
				print: char numericValue;
				space.
			self isMouseButton3Pressed ifTrue: [ s nextPutAll: ' mouseButton3/blue/tertiary/halo ' ].
			self isMouseButton2Pressed ifTrue: [ s nextPutAll: ' mouseButton2/yellow/secondary/menu ' ].
			self isMouseButton1Pressed ifTrue: [ s nextPutAll: ' mouseButton1/red/primary ' ].
			self shiftPressed ifTrue: [ s nextPutAll: ' shift ' ].
			self controlKeyPressed ifTrue: [ s nextPutAll: ' control/ctrl ' ].
			(self primMouseButtons anyMask: 32) ifTrue: [ s nextPutAll: ' macOption ' ].
			self commandAltKeyPressed ifTrue: [ s nextPutAll: ' macCommand/winAlt ' ]])
		displayAt: 10 @ 10 ].! !
!String methodsFor: 'displaying' stamp: 'jmv 5/12/2015 15:52' prior: 50348294!
                              displayOn: aDisplayMedium at: aPoint 
	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."

	^self displayOn: aDisplayMedium at: aPoint textColor: Color black
	"
	'Display' displayOn: Display at: 10@10
	"! !
!Color methodsFor: 'conversions' stamp: 'bf 4/18/2001 16:25' prior: 50353442!
                             makeForegroundColor
        "Make a foreground color contrasting with me"
        ^self luminance >= 0.5
                ifTrue: [Color black]
                ifFalse: [Color white]! !
!Color methodsFor: 'groups of shades' stamp: 'tk 6/18/96' prior: 50353622!
                            mix: color2 shades: thisMany
	"Return an array of thisMany colors from self to color2. Very useful for displaying color based on a variable in your program.  "
	"Color showColors: (Color red mix: Color green shades: 12)"

	| redInc greenInc blueInc rr gg bb c out |
	thisMany = 1 ifTrue: [^ Array with: color2].
	redInc _ color2 red - self red / (thisMany-1).
	greenInc _ color2 green - self green / (thisMany-1).
	blueInc _ color2 blue - self blue / (thisMany-1).
	rr _ self red.  gg _ self green.  bb _ self blue.
	out _ (1 to: thisMany) collect: [:num |
		c _ Color r: rr g: gg b: bb.
		rr _ rr + redInc.
		gg _ gg + greenInc.
		bb _ bb + blueInc.
		c].
	out at: out size put: color2.	"hide roundoff errors"
	^ out
! !
!Color methodsFor: 'groups of shades' stamp: 'di 10/23/2000 09:45' prior: 50353647!
                          wheel: thisMany
	"An array of thisMany colors around the color wheel starting at self and ending all the way around the hue space just before self.  Array is of length thisMany.  Very useful for displaying color based on a variable in your program.  "

	| sat bri hue step c |
	sat _ self saturation.
	bri _ self brightness.
	hue _ self hue.
	step _ 360.0 / (thisMany max: 1).
	^ (1 to: thisMany) collect: [:num |
		c _ Color h: hue s: sat v: bri.  "hue is taken mod 360"
		hue _ hue + step.
		c].
"
(Color wheel: 8) withIndexDo: [:c :i | Display fill: (i*10@20 extent: 10@20) fillColor: c]
"! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:33' prior: 50353704!
                           closestColor
	"Answer the closest matching color in the colorNames dictionary"

"
	(Color red lighter lighter) closestColor explore.
"
	^ self closestColorFrom: (Color colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36' prior: 50353712!
                    closestColorAssociation
	"Answer this color's closest name->color match."

"
	(Color blue lighter lighter) closestColorAssociation explore.
"	
	^ self closestAssocFrom: (Color colorNamesDict)! !
!Color methodsFor: 'named colors' stamp: 'KenD 1/26/2013 16:36' prior: 50353729!
            closestColorName
	"Answer the name symbol of the closest matching color in the colorNames dictionary"
"
	(Color red lighter lighter) closestColor name.
"
	
	^ self closestNameFrom: (Color colorNamesDict)! !
!Color methodsFor: 'other' stamp: 'KenD 7/18/2015 20:41' prior: 50353746!
       colorName
	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."

	^(Color colorNamesDict keyAtValue: self  ifAbsent: [nil])
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:50' prior: 50353993!
                 adjustBrightness: brightness
	"Adjust the relative brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Color
		h: self hue
		s: self saturation
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:51' prior: 50354004!
       adjustSaturation: saturation brightness: brightness
	"Adjust the relative saturation and brightness of this color. (lowest value is 0.005 so that hue information is not lost)"

	^ Color
		h: self hue
		s: (self saturation + saturation min: 1.0 max: 0.005)
		v: (self brightness + brightness min: 1.0 max: 0.005)
		alpha: self alpha! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 11:55' prior: 50354027!
alphaMixed: proportion with: aColor 
	"Answer this color mixed with the given color. The proportion, a number 
	between 0.0 and 1.0, determines what what fraction of the receiver to  
	use in the mix. For example, 0.9 would yield a color close to the  
	receiver. This method uses RGB interpolation; HSV interpolation can lead 
	to surprises.  Mixes the alphas (for transparency) also."

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Color
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)
		alpha: self alpha * frac1 + (aColor alpha * frac2)! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38' prior: 50354067!
     blacker

	^ self alphaMixed: 0.8333 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'dew 3/19/2002 23:54' prior: 50354071!
                   dansDarker
	"Return a darker shade of the same color.
	An attempt to do better than the current darker method.
	(now obsolete, since darker has been changed to do this. -dew)"
	^ Color h: self hue s: self saturation
		v: (self brightness - 0.16 max: 0.0)! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:00' prior: 50354097!
             mixed: proportion with: aColor 
	"Mix with another color and do not preserve transpareny.  Only use this for extracting the RGB value and mixing it.  All other callers should use instead: 
	aColor alphaMixed: proportion with: anotherColor
	"

	| frac1 frac2 |
	frac1 _ proportion asFloat min: 1.0 max: 0.0.
	frac2 _ 1.0 - frac1.
	^ Color
		r: self red * frac1 + (aColor red * frac2)
		g: self green * frac1 + (aColor green * frac2)
		b: self blue * frac1 + (aColor blue * frac2)! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:29' prior: 50354115!
           muchDarker

	^ self alphaMixed: 0.5 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'tk 7/4/2000 12:07' prior: 50354119!
                     muchLighter

	^ self alphaMixed: 0.233 with: Color white
! !
!Color methodsFor: 'transformations' stamp: 'ar 6/19/1999 00:36' prior: 50354123!
                 negated
	"Return an RGB inverted color"
	^Color
		r: 1.0 - self red
		g: 1.0 - self green
		b: 1.0 - self blue! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:41' prior: 50354144!
                           quiteBlacker

	^ self alphaMixed: 0.8 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 9/10/2009 18:44' prior: 50354148!
                 quiteWhiter

	^ self alphaMixed: 0.6 with: Color white! !
!Color methodsFor: 'transformations' stamp: 'dew 1/19/2002 01:25' prior: 50354161!
                   slightlyWhiter

	^ self alphaMixed: 0.85 with: Color white
! !
!Color methodsFor: 'transformations' stamp: 'jmv 8/23/2009 23:24' prior: 50354178!
              veryMuchDarker

	^ self alphaMixed: 0.25 with: Color black
! !
!Color methodsFor: 'transformations' stamp: 'jmv 7/28/2016 15:43:04' prior: 50354183!
           veryMuchLighter

	^ self alphaMixed: 0.07 with: Color white! !
!Color methodsFor: 'transformations' stamp: 'dew 3/23/2002 01:38' prior: 50354188!
              whiter

	^ self alphaMixed: 0.8333 with: Color white
! !
!Color class methodsFor: 'instance creation' stamp: 'jmv 6/2/2016 15:04' prior: 50354381!
             colorFromPixelValue: p depth: d
	"Convert a pixel value for the given display depth into a color."
	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."
	"Warning: In BitBlt, a pixel with pixelValue = 0 is transparent.
	Squeak usually assumes that r=g=b=0 => transparent. But this is false if we have alpha (opacity).
	A color with r=g=b=0 and opacity = 255 is BLACK, not TRANSPARENT.
	Squeak also answers darkest possible blue when asked for black. Again, this is not needed in 32 bits (with alpha). It is also not really needed for 16 bits as we have an extra, unused bit: 16r8000 is not zero, but rgb=0, and hence, black.
	The real rule is that pixelValue=0 means transparent.
	And that darkest blue must be used instead of black, but only for depths >8 and < 16 (no indexed colors, no alpha)
	This method is updated to reflect that."

	| r g b alpha |

	d = 1 ifTrue: [^ self indexedColors at: (p bitAnd: 16r01) + 1].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	p = 0 ifTrue: [ ^Color transparent ].

	d = 8 ifTrue: [^ self indexedColors at: (p bitAnd: 16rFF) + 1].
	d = 4 ifTrue: [^ self indexedColors at: (p bitAnd: 16r0F) + 1].
	d = 2 ifTrue: [^ self indexedColors at: (p bitAnd: 16r03) + 1].

	d = 32 ifTrue: [
		"eight bits per component; 8 bits of alpha"
		alpha _ p bitShift: -24.
		alpha = 0 ifTrue: [ ^Color transparent ].
		r _ (p bitShift: -16) bitAnd: 16rFF.
		g _ (p bitShift: -8) bitAnd: 16rFF.
		b _ p bitAnd: 16rFF.
		^alpha < 255
			ifTrue: [ (Color r: r g: g b: b range: 255) alpha: alpha asFloat / 255.0 ]
			ifFalse: [ Color r: r g: g b: b range: 255 ]].

	d = 16 ifTrue: [
		"five bits per component. The most significant bit, unused, allows having real black, without p being zero"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		^ Color r: r g: g b: b range: 31].

	d = 15 ifTrue: [
		"five bits per component"
		r _ (p bitShift: -10) bitAnd: 16r1F.
		g _ (p bitShift: -5) bitAnd: 16r1F.
		b _ p bitAnd: 16r1F.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 31].

	d = 12 ifTrue: [
		"four bits per component"
		r _ (p bitShift: -8) bitAnd: 16rF.
		g _ (p bitShift: -4) bitAnd: 16rF.
		b _ p bitAnd: 16rF.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 15].

	d = 9 ifTrue: [
		"three bits per component"
		r _ (p bitShift: -6) bitAnd: 16r7.
		g _ (p bitShift: -3) bitAnd: 16r7.
		b _ p bitAnd: 16r7.
		(r = 0 and: [ g = 0 and: [ b = 1]]) ifTrue: [
			^Color black ].
		^ Color r: r g: g b: b range: 7].

	self error: 'unknown pixel depth: ', d printString! !
!Color class methodsFor: 'class initialization' stamp: '' prior: 50354712!
           initializeIndexedColors
	"Build an array of colors corresponding to the fixed colormap used
	 for display depths of 1, 2, 4, or 8 bits."
	"Color initializeIndexedColors"

	| a index grayVal |
	a _ Array new: 256.

	"1-bit colors (monochrome)"
	a at: 1 put: (Color r: 1.0 g: 1.0 b: 1.0).		"white or transparent"
	a at: 2 put: (Color r: 0.0 g: 0.0 b: 0.0).	"black"

	"additional colors for 2-bit color"
	a at: 3 put: (Color r: 1.0 g: 1.0 b: 1.0).	"opaque white"
	a at: 4 put: (Color r: 0.5 g: 0.5 b: 0.5).	"1/2 gray"

	"additional colors for 4-bit color"
	a at:  5 put: (Color r: 1.0 g: 0.0 b: 0.0).	"red"
	a at:  6 put: (Color r: 0.0 g: 1.0 b: 0.0).	"green"
	a at:  7 put: (Color r: 0.0 g: 0.0 b: 1.0).	"blue"
	a at:  8 put: (Color r: 0.0 g: 1.0 b: 1.0).	"cyan"
	a at:  9 put: (Color r: 1.0 g: 1.0 b: 0.0).	"yellow"
	a at: 10 put: (Color r: 1.0 g: 0.0 b: 1.0).	"magenta"

	a at: 11 put: (Color r: 0.125 g: 0.125 b: 0.125).		"1/8 gray"
	a at: 12 put: (Color r: 0.25 g: 0.25 b: 0.25).		"2/8 gray"
	a at: 13 put: (Color r: 0.375 g: 0.375 b: 0.375).		"3/8 gray"
	a at: 14 put: (Color r: 0.625 g: 0.625 b: 0.625).		"5/8 gray"
	a at: 15 put: (Color r: 0.75 g: 0.75 b: 0.75).		"6/8 gray"
	a at: 16 put: (Color r: 0.875 g: 0.875 b: 0.875).		"7/8 gray"

	"additional colors for 8-bit color"
	"24 more shades of gray (1/32 increments but not repeating 1/8 increments)"
	index _ 17.
	1 to: 31 do: [:v |
		(v \\ 4) = 0 ifFalse: [
			grayVal _ v / 32.0.
			a at: index put: (Color r: grayVal g: grayVal b: grayVal).
			index _ index + 1]].

	"The remainder of color table defines a color cube with six steps
	 for each primary color. Note that the corners of this cube repeat
	 previous colors, but this simplifies the mapping between RGB colors
	 and color map indices. This color cube spans indices 40 through 255
	 (indices 41-256 in this 1-based array)."
	0 to: 5 do: [:r |
		0 to: 5 do: [:g |
			0 to: 5 do: [:b |
				index _ 41 + ((36 * r) + (6 * b) + g).
				index > 256 ifTrue: [
					self error: 'index out of range in color table compuation'].
				a at: index put: (Color r: r g: g b: b range: 5)]]].

	IndexedColors _ a.
! !
!Color class methodsFor: 'examples' stamp: 'jmv 8/17/2012 18:48' prior: 50354781!
    colorRampForDepth: depth extent: aPoint
	"Returns a form of the given size showing R, G, B, and gray ramps for the given depth. Useful for testing color conversions between different depths."
	"(Color colorRampForDepth: Display depth extent: 256@80) display"
	"(Color colorRampForDepth: 32 extent: 256@80) displayOn: Display at: 0@0 rule: Form paint"

	| f dx dy r |
	f _ Form extent: aPoint depth: depth.
	dx _ aPoint x // 256.
	dy _ aPoint y // 4.
	0 to: 255 do: [:i |
		r _ (dx * i)@0 extent: dx@dy.
		f fill: r fillColor: (Color r: i g: 0 b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: i b: 0 range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: 0 g: 0 b: i range: 255).
		r _ r translatedBy: 0@dy.
		f fill: r fillColor: (Color r: i g: i b: i range: 255)].
	^ f
! !
!Color class methodsFor: 'examples' stamp: '' prior: 50354885!
    showColorCube
	"Show a 12x12x12 color cube."
	"Color showColorCube"

	0 to: 11 do: [:r |
		0 to: 11 do: [:g |
			0 to: 11 do: [:b |	
				Display fill: (((r*60) + (b*5)) @ (g*5) extent: 5@5)
					fillColor: (Color r: r g: g b: b range: 11)]]].
! !
!Color class methodsFor: 'examples' stamp: '' prior: 50354905!
          showHSVPalettes
	"Shows a palette of hues, varying the saturation and brightness for each one. Best results are with depths 16 and 32."
	"Color showHSVPalettes"

	| left top c |
	left _ top _ 0.
	0 to: 179 by: 15 do: [:h |
		0 to: 10 do: [:s |
			left _ (h * 4) + (s * 4).
			0 to: 10 do: [:v |
				c _ Color h: h s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4).
				Display fill: (left@top extent: 4@4) fillColor: c.

				c _ Color h: h + 180 s: s asFloat / 10.0 v: v asFloat / 10.0.
				top _ (v * 4) + 50.
				Display fill: (left@top extent: 4@4) fillColor: c]]].
! !
!Color class methodsFor: 'examples' stamp: '' prior: 50354942!
                           wheel: thisMany
	"Return a collection of thisMany colors evenly spaced around the color wheel."
	"Color showColors: (Color wheel: 12)"

	^ Color wheel: thisMany saturation: 0.9 brightness: 0.7
! !
!Color class methodsFor: 'examples' stamp: '' prior: 50354950!
                            wheel: thisMany saturation: s brightness: v
	"Return a collection of thisMany colors evenly spaced around the color wheel, all of the given saturation and brightness."
	"Color showColors: (Color wheel: 12 saturation: 0.4 brightness: 1.0)"
	"Color showColors: (Color wheel: 12 saturation: 0.8 brightness: 0.5)"

	^ (Color h: 0.0 s: s v: v) wheel: thisMany
! !
!Color class methodsFor: 'colormaps' stamp: '' prior: 50355350!
                         colorMapIfNeededFrom: sourceDepth to: destDepth
	"Return a colormap for mapping between the given depths, or nil if no colormap is needed."
	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"

	sourceDepth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"

	(sourceDepth >= 16) & (destDepth >= 16) ifTrue: [
		"mapping is done in BitBlt by zero-filling or truncating each color component"
		^ nil].

	^ Color cachedColormapFrom: sourceDepth to: destDepth
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:56' prior: 50355465!
                   computeColormapFromGray8bppForDepth: destDepth
	"Return a colormap for displaying a GrayForm at the given depth"

	| newMap |
	newMap _ Bitmap new: 256.
	1 to: 256 do: [ :i |
		newMap
			at: i
			put: ((Color gray: (i-1) asFloat / 255.0) pixelValueForDepth: destDepth)].
	^ newMap! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 4/17/2015 15:05' prior: 50355476!
                 computeIndexedColorConvertingMap: targetColor from: sourceDepth to: destDepth
	| map |
	
	map _ (self indexedColors copyFrom: 1 to: (1 bitShift: sourceDepth)) collect: [ :cc | | f c |
		f _ 1.0 - (cc red + cc green + cc blue / 3.0 ).
		c _ targetColor
			ifNotNil: [
				destDepth = 32
					ifTrue: [ targetColor * f alpha: f]
					ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]
			ifNil: [ cc ].
		destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f = 0.0
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]]].
	map _ map as: Bitmap.
	^map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 12/26/2011 13:49' prior: 50355498!
               computeRGBColorConvertingMap: targetColor to: destDepth keepSubPixelAA: keepSubPix
	"Builds a colormap intended to convert from subpixelAA black values to targetColor values.
	keepSubPix
		ifTrue: [ Answer colors that also include subpixelAA ]
		ifFalse: [ 
			Take fullpixel luminance level. Apply it to targetColor.
			I.e. answer colors with NO subpixelAA ]"

	| mask map c bitsPerColor r g b f v |

	destDepth > 8
		ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"
		ifFalse: [bitsPerColor _ 4].
	"Usually a bit less is enough, but make it configurable"
	bitsPerColor _ bitsPerColor min: Preferences aaFontsColormapDepth.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		r _ (i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask.
		g _ (i bitShift: 0 - bitsPerColor) bitAnd: mask.
		b _ (i bitShift: 0) bitAnd: mask.
		f _ 1.0 - (r + g + b / 3.0 / mask).
		c _ targetColor
			ifNotNil: [
				(keepSubPix and: [destDepth > 8]) ifTrue: [
						Color
							r: 1.0 - (r asFloat/mask) * targetColor red
							g: 1.0 - (g asFloat/mask) * targetColor green
							b: 1.0 - (b asFloat/mask) * targetColor blue
							alpha: f	* targetColor alpha "alpha will be ignored below, in #pixelValueForDepth: if destDepth ~= 32" ]
				ifFalse: [
					destDepth = 32
						ifTrue: [ targetColor * f alpha: f * targetColor alpha ]
						ifFalse: [ targetColor alphaMixed: f*1.5 with: Color white ]]]
			ifNil: [ Color r: r g: g b: b range: mask].	"This is currently used only to keep some SubPixelAA on destDepth = 8, using a single pass of rule 25"
		v _ destDepth = 32
			ifTrue: [ c pixelValueForDepth: destDepth]
			ifFalse: [
				f < 0.1
					ifTrue: [ 0 ]
					ifFalse: [ c pixelValueForDepth: destDepth ]].
		map at: i + 1 put: v ].
	^ map! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 1/30/2011 23:10' prior: 50355558!
               computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to the given depth, using the given number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| mask map c |
	(#(3 4 5) includes: bitsPerColor)
		ifFalse: [self error: 'BitBlt only supports 3, 4, or 5 bits per color component'].
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Color
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c pixelValueForDepth: destDepth)].

	map at: 1 put: (Color transparent pixelWordForDepth: destDepth).  "zero always transparent"
	^ map
! !
!Color class methodsFor: 'colormaps' stamp: 'jmv 5/12/2016 15:57' prior: 50355600!
              computeRGBColormapForGray8
	"Compute a colorMap for translating from 16-bit or 32-bit RGB color to 8bpp grays, using the default number of of bits per color component."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."

	| bitsPerColor mask map c |
	bitsPerColor _ 5.
	mask _ (1 bitShift: bitsPerColor) - 1.
	map _ Bitmap new: (1 bitShift: (3 * bitsPerColor)).
	0 to: map size - 1 do: [:i |
		c _ Color
			r: ((i bitShift: 0 - (2 * bitsPerColor)) bitAnd: mask)
			g: ((i bitShift: 0 - bitsPerColor) bitAnd: mask)
			b: ((i bitShift: 0) bitAnd: mask)
			range: mask.
		map at: i + 1 put: (c luminance * 255) rounded].

	^ map! !
!Color class methodsFor: 'color from user' stamp: 'jmv 3/1/2010 15:13' prior: 50355666!
         colorPaletteForDepth: depth extent: chartExtent
	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorPaletteForDepth: 16 extent: 190@60) display"

	| basicHue x y startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [ :h |
		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [ :n | | c |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [ :n | | c |
 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [ :n | | c |
 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color from user' stamp: 'jmv 7/27/2009 11:32' prior: 50355723!
                               colorTest: depth extent: chartExtent colorMapper: colorMapper
	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."
	"Note: It is slow to build this palette, so it should be cached for quick access."
	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 7) asInteger / 7
			g: (c green * 7) asInteger / 7
			b: (c blue * 3) asInteger / 3]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 5) asInteger / 5
			g: (c green * 5) asInteger / 5
			b: (c blue * 5) asInteger / 5]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 15) asInteger / 15
			g: (c green * 15) asInteger / 15
			b: (c blue * 15) asInteger / 15]) display"
	"(Color colorTest: 32 extent: 570@180 colorMapper:
		[:c | Color
			r: (c red * 31) asInteger / 31
			g: (c green * 31) asInteger / 31
			b: (c blue * 31) asInteger / 31]) display"

	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |
	palette _ Form extent: chartExtent depth: depth.
	transCaption _ 
		(Form extent: 34@9 depth: 1
			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)
			offset: 0@0).
	transHt _ transCaption height.
	palette fillWhite: (0@0 extent: palette width@transHt).
	palette fillBlack: (0@transHt extent: palette width@1).
	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).
	grayWidth _ 10.
	startHue _ 338.0.
	vSteps _ palette height - transHt // 2.
	hSteps _ palette width - grayWidth.
	x _ 0.
	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |
		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.
		y _ transHt+1.
		0 to: vSteps do: [:n |
 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		1 to: vSteps do: [:n |
 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.
			c _ colorMapper value: c.
			palette fill: (x@y extent: 1@1) fillColor: c.
			y _ y + 1].
		x _ x + 1].
	y _ transHt + 1.
	1 to: vSteps * 2 do: [:n |
 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.
		c _ colorMapper value: c.
		palette fill: (x@y extent: 10@1) fillColor: c.
		y _ y + 1].
	^ palette
! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 1/28/2013 20:34' prior: 50355811!
                     defaultColorNamesDictionary
	"Answer a amall but  useful name->color dictionary"
	
	| defaultDict |
	"Meld most used xkcd colors into traditional colors."
	defaultDict := (self traditionalColorNamesDictionary addAll: 
					self xkcdFirst48ColorNamesDictionary; 
					yourself).
		
	"Override traditional names existing in extended XKCD naming"
	defaultDict at: #lightYellow    put: (Color r: 1.0 g: 0.996 b: 0.478).
	defaultDict at: #lightOrange   put: (Color r: 0.992 g: 0.667 b: 0.283).
	defaultDict at: #lightCyan        put: (Color r: 0.674 g: 1.0 b: 0.988).
	defaultDict at: #lightRed          put: (Color r: 1.0 g: 0.279 b: 0.298).
	defaultDict at: #lightMagenta put: (Color r: 0.98 g: 0.372 b: 0.969).
	
	^defaultDict! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 2/1/2013 14:39' prior: 50355837!
             doesNotUnderstand: aMessage
	"Some code takes
		 Color colorNames 
	and does
		Color perform: aColorname.
		
	Make this work."

	^(Color colorNamesDict) 
		at: (aMessage selector)
		ifAbsent: [super doesNotUnderstand: aMessage]! !
!Color class methodsFor: 'color name lookup' stamp: 'KenD 7/25/2014 21:22' prior: 50355855!
                             setColorNamesDict: aNameColorDictionary
	"Answer the current dictionary of  name->color associations."
	
	"Note: This is a non-standard name because this is a non-standard action!!
	Do this if you really, really know what you are doing."
	
	"Some Colors are required for proper system operation"
	Color defaultColorNamesDictionary keysAndValuesDo: [ :colorName :colorValue |
		aNameColorDictionary at: colorName ifAbsentPut: colorValue
	].

	ColorNamesDict := aNameColorDictionary! !
!Color class methodsFor: 'color name lookup' stamp: 'sqr 10/21/2016 12:44:48' prior: 50355873!
                             traditionalColorNamesDictionary
	"Answer a dictionary of Squeak traditional name->color associations.."

	| nameDict |
	nameDict _ Dictionary new.
	nameDict at: #black put: (Color r: 0 g: 0 b: 0).
	nameDict at: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).
	nameDict at: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).
	nameDict at: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).
	nameDict at: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).
	nameDict at: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).
	nameDict at: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).
	nameDict at: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).
	nameDict at: #white put: (Color r: 1.0 g: 1.0 b: 1.0).
	nameDict at: #red put: (Color r: 1.0 g: 0 b: 0).
	nameDict at: #yellow put: (Color r: 1.0 g: 1.0 b: 0).
	nameDict at: #green put: (Color r: 0 g: 1.0 b: 0).
	nameDict at: #cyan put: (Color r: 0 g: 1.0 b: 1.0).
	nameDict at: #blue put: (Color r: 0 g: 0 b: 1.0).
	nameDict at: #magenta put: (Color r: 1.0 g: 0 b: 1.0).
	nameDict at: #brown put: (Color r: 0.6 g: 0.2 b: 0).
	nameDict at: #orange put: (Color r: 1.0 g: 0.6 b: 0).
	nameDict at: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).
	nameDict at: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).
	nameDict at: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).
	nameDict at: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).
	nameDict at: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).
	nameDict at: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).
	nameDict at: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).
	nameDict at: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).
	nameDict at: #transparent put: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.0).
	
	^nameDict
! !
!Color class methodsFor: 'color name lookup' stamp: 'jmv 6/30/2014 15:22' prior: 50355930!
                               xkcdFirst48ColorNamesDictionary
	"XKCD color names are based on a survey oc colors people call by the same name.
	 http://blog.xkcd.com/2010/05/03/color-survey-results/"

	"Answer a dictionary of the most agreed upon first 48 xkcd colors"
"
	Color xkcdFirst48ColorNamesDictionary explore.
"	
	| xkcdDict |
	xkcdDict := Dictionary new
	at: #lightPink put: (Color fromString: '#ffd1df') ;
	at: #mustard put: (Color fromString: '#ceb301') ;
	at: #indigo put: (Color fromString: '#380282') ;
	at: #lime put: (Color fromString: '#aaff32') ;
	at: #seaGreen put: (Color fromString: '#53fca1') ;
	at: #periwinkle put: (Color fromString: '#8e82fe') ;
	at: #darkPink put: (Color fromString: '#cb416b') ;
	at: #oliveGreen put: (Color fromString: '#677a04') ;
	at: #peach put: (Color fromString: '#ffb07c') ;
	at: #paleGreen put: (Color fromString: '#c7fdb5') ;
	at: #lightBrown put: (Color fromString: '#ad8150') ;
	at: #hotPink put: (Color fromString: '#ff028d') ;
	at: #black put: (Color fromString: '#000000') ;
	at: #lilac put: (Color fromString: '#cea2fd') ;
	at: #navyBlue put: (Color fromString: '#001146') ;
	at: #royalBlue put: (Color fromString: '#0504aa') ;
	at: #beige put: (Color fromString: '#e6daa6') ;
	at: #salmon put: (Color fromString: '#ff796c') ;
	at: #olive put: (Color fromString: '#6e750e') ;
	at: #maroon put: (Color fromString: '#650021') ;
	at: #brightGreen put: (Color fromString: '#01ff07') ;
	at: #darkPurple put: (Color fromString: '#35063e') ;
	at: #mauve put: (Color fromString: '#ae7181') ;
	at: #forestGreen put: (Color fromString: '#06470c') ;
	at: #aqua put: (Color fromString: '#13eac9') ;
	at: #cyan put: (Color fromString: '#00ffff') ;
	at: #tan put: (Color fromString: '#d1b26f') ;
	at: #darkBlue put: (Color fromString: '#00035b') ;
	at: #lavender put: (Color fromString: '#c79fef') ;
	at: #turquoise put: (Color fromString: '#06c2ac') ;
	at: #darkGreen put: (Color fromString: '#033500') ;
	at: #violet put: (Color fromString: '#9a0eea') ;
	at: #lightPurple put: (Color fromString: '#bf77f6') ;
	at: #limeGreen put: (Color fromString: '#89fe05') ;
	at: #grey put: (Color fromString: '#929591') ;
	at: #skyBlue put: (Color fromString: '#75bbfd') ;
	at: #yellow put: (Color fromString: '#ffff14') ;
	at: #magenta put: (Color fromString: '#c20078') ;
	at: #lightGreen put: (Color fromString: '#96f97b') ;
	at: #orange put: (Color fromString: '#f97306') ;
	at: #teal put: (Color fromString: '#029386') ;
	at: #lightBlue put: (Color fromString: '#95d0fc') ;
	at: #red put: (Color fromString: '#e50000') ;
	at: #brown put: (Color fromString: '#653700') ;
	at: #pink put: (Color fromString: '#ff81c0') ;
	at: #blue put: (Color fromString: '#0343df') ;
	at: #green put: (Color fromString: '#15b01a') ;
	at: #purple put: (Color fromString: '#7e1e9c') ;
  	yourself.

	^xkcdDict

! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 4/25/2016 15:31' prior: 50348306!
                  reduceCuis
	"
	Smalltalk reduceCuis
	"
	| keep n unused newDicts oldDicts |

	self nominallyUnsent: #reduceCuis.
	
	"Remove icons"
	Smalltalk at: #ClassicTheme ifPresent: [ :cls | cls beCurrent ].
	PasteUpMorph allInstancesDo: [ :w |
		w backgroundImageData: nil.
		w  submorphsDo: [ :a | a delete ]].
	Preferences useNoIcons.
	Theme current initialize.
	Theme content: nil.
	Color shutDown.
	BitBltCanvas releaseClassCachedState.

	Transcript clear.
	Clipboard default initialize.


	"Remove some methods, even if they have senders."
"	ColorPickerMorph class removeSelector: #buildEyedropperIcon."
	Theme removeSelector: #miscellaneousIcons.
	Utilities removeSelector: #vmStatisticsReportString.
	SystemDictionary removeSelector: #recreateSpecialObjectsArray.

	StrikeFont removeMostFonts.
	StrikeFont saveSpace.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.

	keep := OrderedCollection new.
	keep addAll: #(SpaceTally).
	AppLauncher appGlobalName ifNotNil: [ :any |
		keep add: any ].
	unused := Smalltalk unusedClasses copyWithoutAll: keep.
	[
		#hereWeGo print.
		unused do: [:c | 
			c print.
			(Smalltalk at: c) removeFromSystem]. 
		n := Smalltalk removeAllUnSentMessages.
		unused := Smalltalk unusedClasses copyWithoutAll: keep.
		n > 0 or: [ 
			unused notEmpty ]] whileTrue.
	ChangeSet zapAllChangeSets.
	Smalltalk garbageCollect.

	Smalltalk removeEmptyMessageCategories.
	Smalltalk organization removeEmptyCategories.
	Symbol rehash.

	"Shrink method dictionaries."
	Smalltalk garbageCollect.
	oldDicts _ MethodDictionary allInstances.
	newDicts _ Array new: oldDicts size.
	oldDicts withIndexDo: [:d :index | 
		newDicts at: index put: d rehashWithoutBecome ].
	oldDicts elementsExchangeIdentityWith: newDicts.
	oldDicts _ newDicts _ nil.

	 SmalltalkCompleter initialize .

   "Sanity checks"
"   Undeclared
   Smalltalk cleanOutUndeclared
   Smalltalk browseUndeclaredReferences
   Smalltalk obsoleteClasses
   Smalltalk obsoleteBehaviors 
   Smalltalk browseObsoleteMethodReferences
   SmalltalkImage current fixObsoleteReferences
   Smalltalk browseAllUnimplementedCalls"! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 7/28/2015 08:26' prior: 50348377!
                        endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d _ textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ textComposition characterBlockAtPoint:
			0@0 + (0@(d+AbstractFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		textComposition: textComposition
		bounds: (4@4 + frame topLeft extent: Display extent)
		color: Color black
		selectionColor: Color blue.
	DisplayScreen screenUpdateRequired: nil! !
!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12' prior: 50348411!
             black
	Display depth = 1 ifTrue: [^ Bitmap with: 16rFFFFFFFF "Works without color support"].
	^ Color black! !
!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12' prior: 50348417!
  white
	Display depth = 1 ifTrue: [^ Bitmap with: 0 "Works without color support"].
	^ Color white! !
!DataStream class methodsFor: 'as yet unclassified' stamp: '' prior: 50348423!
            example
    "An example and test of DataStream/ReferenceStream.
     11/19/92 jhm: Use self testWith:."
    "DataStream example"
    "ReferenceStream example"
    | input sharedPoint |

    "Construct the test data."
    input _ Array new: 9.
    input at: 1 put: nil.
    input at: 2 put: true.
    input at: 3 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 3) fillWithColor: Color lightBlue.
    input at: 4 put: #(3 3.0 'three').
    input at: 5 put: false.
    input at: 6 put: 1024 @ -2048.
    input at: 7 put: #x.
    input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
    input at: 9 put: sharedPoint.

    "Write it out, read it back, and return it for inspection."
    ^ self testWith: input! !
!ReferenceStream class methodsFor: 'as yet unclassified' stamp: '' prior: 50348449!
                               example2
"Here is the way to use DataStream and ReferenceStream:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	rr nextPut: <your object>.
	rr close.

To get it back:
	rr _ ReferenceStream fileNamed: ''test.obj''.
	<your object> _ rr next.
	rr close.
"
"An example and test of DataStream/ReferenceStream.
	 11/19/92 jhm: Use self testWith:."
	"ReferenceStream example2"
	| input sharedPoint |

	"Construct the test data."
	input _ Array new: 9.
	input at: 1 put: nil.
	input at: 2 put: true.
	input at: 3 put: false.
	input at: 4 put: #(-4 -4.0 'four' four).
	input at: 5 put: (Form extent: 63 @ 50 depth: 8).
		(input at: 5) fillWithColor: Color lightOrange.
	input at: 6 put: 1024 @ -2048.
	input at: 7 put: input. "a cycle"
	input at: 8 put: (Array with: (sharedPoint _ 0 @ -30000)).
	input at: 9 put: sharedPoint.

	"Write it out, read it back, and return it for inspection."
	^ self testWith: input
! !
!TextEditor methodsFor: 'attributes' stamp: 'jmv 12/12/2014 15:53' prior: 50348481!
                               offerColorMenu
	"Present a menu of available colors, and if one is chosen, apply it to the current selection."
	"This is a user command, and generates undo"

	| attribute colors index thisSel |
	thisSel _ self selection.
	colors _ #(#black #magenta #red #yellow #green #blue #cyan #white ).
	index _ (PopUpMenu
		labelArray: colors , #('choose color...' )
		lines: (Array with: colors size + 1)) startUpMenu.
	index = 0 ifTrue: [ ^ true ].
	index <= colors size
		ifTrue: [ attribute _ TextColor color: (Color perform: (colors at: index)) ]
		ifFalse: [
			index _ index - colors size - 1.
			"Re-number!!!!!!"
			index = 0 ifTrue: [ attribute _ self chooseColor ].
			thisSel ifNil: [ ^ true ]].
	attribute ifNotNil: [ self applyAttribute: attribute ].
	^ true.! !
!TextAction class methodsFor: 'as yet unclassified' stamp: 'jmv 4/19/2015 09:38' prior: 50348509!
textActionColor
	^Color r: 0.4 g: 0 b: 1.0! !
!TextColor methodsFor: 'testing' stamp: 'jmv 1/21/2011 11:33' prior: 50348513!
   isSet
	"Do not include Color black, as it is the default color."
	^color ~= Color black! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348519!
 black
	^ self new color: Color black! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348523!
                    blue
	^ self new color: Color blue! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348527!
                      cyan
	^ self new color: Color cyan! !
!TextColor class methodsFor: 'constants' stamp: 'ajh 9/10/2002 02:26' prior: 50348531!
   gray
	^ self new color: Color gray! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348535!
                      green
	^ self new color: Color green! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348539!
                    magenta
	^ self new color: Color magenta! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348543!
                red
	^ self new color: Color red! !
!TextColor class methodsFor: 'constants' stamp: 'sma 3/24/2000 10:50' prior: 50348547!
     white 
	^ self new color: Color white! !
!TextColor class methodsFor: 'constants' stamp: '' prior: 50348551!
                   yellow
	^ self new color: Color yellow! !
!Preferences class methodsFor: 'halos' stamp: 'jmv 4/20/2015 16:17' prior: 50348556!
 installHaloSpecsFromArray: anArray

	| aColor |
	^ self parameters at: #HaloSpecs put: (anArray collect: [ :each |
				aColor _ Color.
				each fourth do: [ :sel | aColor _ aColor perform: sel].
				HaloSpec new 
					horizontalPlacement: each second
					verticalPlacement: each third 
					color: aColor
					iconSymbol: each fifth
					addHandleSelector: each first
					hoverHelp: each sixth])! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/19/2016 20:45:55' prior: 50348572!
                   displayOn: aForm in: aRectangle
	"
	Transcript displayOn: Display
	"
	| font count i string x y fh f canvas innerR |
	aForm fill: aRectangle fillColor: Color white.
	font _ AbstractFont default.

	innerR _ aRectangle insetBy: self padding.
	fh _ font height.
	count _ innerR height // fh-1.
	x _ innerR left.
	y _ innerR top.
	f _ firstIndex-1.
	firstIndex > lastIndex ifTrue: [ f _ f - self maxEntries ].
	i _ (lastIndex - count max: f) \\ self maxEntries + 1.
	canvas _ aForm getCanvas.
	canvas newClipRect: innerR.
	[
		string _ entries at: i.	
		canvas drawString: string at: x@y font: font color: Color veryDarkGray.
		y _ y + fh.
		i = lastIndex
	] whileFalse: [ i _ i \\ self maxEntries + 1 ].

	string _ unfinishedEntry contents.
	canvas drawString: string at: x@y font: font color: Color veryDarkGray! !
!Transcript class methodsFor: 'displaying' stamp: 'jmv 9/19/2016 20:53:35' prior: 50348601!
                       displayUnfinishedEntryOn: aForm

	| font count string x y fh canvas r innerR |
	innerR _ bounds insetBy: self padding.
	lastDisplayPosition < innerR right ifTrue: [
		font _ AbstractFont default.
		fh _ font height.
		count _ innerR height // fh-1.
		x _ innerR left.
		string _ unfinishedEntry contents.
		y _ ((lastIndex - firstIndex \\ self maxEntries) min: count-1) + 1 * font height + innerR top.
		canvas _ aForm getCanvas.
		r _ innerR left: lastDisplayPosition.
		canvas newClipRect: r.
		(canvas drawString: string at: x@y font: font color: Color veryDarkGray) ifNotNil: [ :lastPoint |
			lastDisplayPosition _ lastPoint x.
			^r ]].
	^nil! !
!Form methodsFor: 'analyzing' stamp: 'ar 5/17/2001 15:40' prior: 50348624!
         dominantColor
	| tally max maxi |
	self depth > 16 ifTrue:
		[^(self asFormOfDepth: 16) dominantColor].
	tally _ self tallyPixelValues.
	max _ maxi _ 0.
	tally withIndexDo: [:n :i | n > max ifTrue: [max _ n. maxi _ i]].
	^ Color colorFromPixelValue: maxi - 1 depth: self depth! !
!Form methodsFor: 'bordering' stamp: 'jmv 1/22/2015 10:22' prior: 50348636!
                            border: aRectangle width: borderWidth 
	"Paint a border whose rectangular area is defined by aRectangle. The 
	width of the border of each side is borderWidth. Uses black for 
	drawing the border."

	self border: aRectangle width: borderWidth fillColor: Color black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 50348647!
        fillBlack
	"Set all bits in the receiver to black (ones)."

	self fill: self boundingBox fillColor: Color black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 50348653!
  fillBlack: aRectangle 
	"Set all bits in the receiver's area defined by aRectangle to black (ones)."

	self fill: aRectangle rule: Form over fillColor: Color black! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 50348661!
              fillGray
	"Set all bits in the receiver to gray."

	self fill: self boundingBox fillColor: Color gray! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:20' prior: 50348667!
            fillGray: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to the gray mask."

	self fill: aRectangle rule: Form over fillColor: Color gray! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 50348675!
                fillWhite
	"Set all bits in the form to white."

	self fill: self boundingBox fillColor: Color white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 50348681!
             fillWhite: aRectangle
	"Set all bits in the receiver's area defined by aRectangle to white."

	self fill: aRectangle rule: Form over fillColor: Color white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 50348689!
                      reverse
	"Change all the bits in the receiver that are white to black, and the ones 
	that are black to white.
	Display reverse
	"

	self fill: self boundingBox rule: Form reverse fillColor: Color white! !
!Form methodsFor: 'coloring' stamp: 'jmv 1/22/2015 10:21' prior: 50348698!
       reverse: aRectangle
	"Change all the bits in the receiver's area that intersects with aRectangle 
	that are white to black, and the ones that are black to white."

	self fill: aRectangle rule: Form reverse fillColor: Color white! !
!Form methodsFor: 'color mapping' stamp: 'ar 5/17/2001 15:42' prior: 50348708!
         colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	self depth = destDepth ifTrue: [^ nil].  "not needed if depths are the same"
	^ Color colorMapIfNeededFrom: self depth to: destDepth
! !
!Form methodsFor: 'color mapping' stamp: 'jmv 5/12/2016 13:53' prior: 50348720!
                           colormapIfNeededForGray8bpp
	"Return a colormap for displaying the receiver at the given depth.
	Note: Uses 5 bits per color component. 32bit Forms will lose information!!"

	^ Color cachedColormapForGrayFrom: self depth! !
!Form methodsFor: 'color mapping' stamp: 'jmv 9/23/2012 21:42' prior: 50348730!
                mapColor: oldColor to: newColor
	"Make all pixels of the given color in this Form to the given new color."
	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."

	| map |
	map _ (Color cachedColormapFrom: self depth to: self depth) copy.
	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: self depth).
	(BitBlt toForm: self)
		sourceForm: self;
		sourceOrigin: 0@0;
		combinationRule: Form over;
		destX: 0 destY: 0 width: width height: height;
		colorMap: map;
		copyBits.
! !
!Form methodsFor: 'color mapping' stamp: 'jmv 1/31/2011 09:21' prior: 50348752!
             maskingMap
	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero."
	"Warning: The behavior is incorrect for 32bpp Forms with translucency.
	Color maps are RGB only, they don't map on alpha values. Alpha is ignored when using the color map. This means that the only value mapped as transparent is pixel value 0,
	that is R=0, G=0, B=0, Alpha=0.
	However, a 32bpp form could have, for instance R=255, G=0, B=0, Alpha=0, also meaning transparent. But this will be mapped as if the source was red, not transparent."
	^Color maskingMap: self depth! !
!Form methodsFor: 'converting' stamp: 'jm 11/12/97 19:28' prior: 50348775!
               as8BitColorForm
	"Simple conversion of zero pixels to transparent.  Force it to 8 bits."

	| f map |
	f _ ColorForm extent: self extent depth: 8.
	self displayOn: f at: self offset negated.
	map _ Color indexedColors copy.
	map at: 1 put: Color transparent.
	f colors: map.
	f offset: self offset.
	^ f
! !
!Form methodsFor: 'pixel access' stamp: 'ar 5/17/2001 15:42' prior: 50348788!
                               colorAt: aPoint
	"Return the color in the pixel at the given point.  "

	^ Color 
		colorFromPixelValue: (self pixelValueAt: aPoint)
		depth: self depth
! !
!Form methodsFor: 'pixel access' stamp: 'jmv 11/4/2015 12:40' prior: 50348796!
                    colorInterpolatedAt: aPoint
	"Evaluate a bilinear (i.e. cheap) interpolation
	Like OpenCV's CV_INTER_LINEAR
	Answer Color transparent if outside image bounds.
	Copied almost verbatim from FloatImage.
	Answer Colors with float components. Will be rounded to be stored in, for example, a 32-bit Form."

	| x y w interpolated xWeight1 xWeight0 yWeight1 yWeight0 xIndex0 xIndex1 yIndex0 yIndex1 |
	x _ aPoint x.
	y _ aPoint y.
	x < 0.0 ifTrue: [ ^Color transparent ].
	xIndex0 _ x truncated. 		"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	xIndex0 > (width-1) ifTrue: [ ^Color transparent ].
	(xIndex0 = (width-1) and: [ x > (width-1) ]) ifTrue: [ ^Color transparent ].
	xIndex1 _ xIndex0 = (width-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ xIndex0 + 1 ]
		ifTrue: [ xIndex0 ].

	y < 0.0 ifTrue: [ ^Color transparent ].
	yIndex0 _ y truncated.			"Could be #floor. But as we only care for values >=0, it is the same. But faster."
	yIndex0 > (height-1) ifTrue: [ ^Color transparent ].
	(yIndex0 = (height-1) and: [ y > (height-1) ]) ifTrue: [ ^Color transparent ].
	yIndex1 _ yIndex0 = (height-1) 	"Avoid the invalid access if this was true, but don't make it slower the most common, general case."
		ifFalse: [ yIndex0 + 1 ]
		ifTrue: [ yIndex0 ].

	xWeight1 _ x - xIndex0.
	xWeight0 _ 1.0 - xWeight1.

	yWeight1 _ y - yIndex0.
	yWeight0 _ 1.0 - yWeight1.

	"/* perform interpolation */"
	w _ ((self colorAt: xIndex0 @ yIndex0) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex0) * xWeight1).
	interpolated _ w * yWeight0.

	w _ ((self colorAt: xIndex0 @ yIndex1) * xWeight0) +
		((self colorAt: xIndex1 @ yIndex1) * xWeight1).
	interpolated _ w * yWeight1 + interpolated.

	^interpolated! !
!Form methodsFor: 'transitions' stamp: 'jmv 7/28/2015 08:32' prior: 50348855!
           pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: Color black.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceToScreen.
		].

	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceToScreen.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"
! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 9/23/2012 21:44' prior: 50348926!
              dotOfSize: diameter
	"Create a form which contains a round black dot."
	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |
	radius _ diameter//2.
	form _ self extent: diameter@diameter offset: (0@0) - (radius@radius).	
	bb _ (BitBlt toForm: form)
		sourceX: 0; sourceY: 0;
		combinationRule: Form over;
		fillColor: Color black.
	rect _ form boundingBox.
	centerX _ rect center x.
	centerY _ rect center y.
	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].
	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].
	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.
	xOverY _ rect width asFloat / rect height asFloat.
	maxy _ rect height - 1 // 2.

	"First do the inner fill, and collect x values"
	0 to: maxy do:
		[:dy |
		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.
		bb	destX: centerX - centerXBias - dx
			destY: centerY - centerYBias - dy
			width: dx + dx + centerXBias + 1
			height: 1;
			copyBits.
		bb	destY: centerY + dy;
			copyBits].
	^ form
"
Time millisecondsToRun:
	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]
"! !
!Form class methodsFor: 'instance creation' stamp: 'pb 5/4/2016 17:43' prior: 50348965!
                        fakeSphereAt: aPoint diameter: diameter color: aColor
	"Create a form which contains a round black dot."
	| bb rect d p |
	bb _ GrafPort toForm: Display.
	bb fillColor: aColor.
	bb combinationRule: Form blend.
	rect _ aPoint extent: diameter.
	bb fillOval: rect.
	p _ (diameter * 2 // 5) asPoint + aPoint.
	#(2 3 4 5 6 ) do: [ :i |
		"simulate facade by circles of gray"
		bb fillColor: (Color white alpha: 0.3).
		d _ i * diameter // 10.
		rect _ Rectangle
			center: p
			extent: d.
		bb fillOval: rect ].
	DisplayScreen screenUpdateRequired: nil.
"
	Form fakeSphereAt: 50@50 diameter: 30 color:  (Color red alpha: 0.5)
"! !
!Form class methodsFor: 'examples' stamp: 'jmv 3/20/2013 22:36' prior: 50348988!
                            toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ Color red wheel: 12.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: -40@-40].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:37' prior: 50349025!
   bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:47' prior: 50349053!
 bottomLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (width - 1 - x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:38' prior: 50349084!
               bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form for the bottomRight corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l _ ((r - d max: 0.0) min: aaw) / aaw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 5/15/2015 09:41' prior: 50349111!
           bottomRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor borderWidth: bw
	"Create and answer a Form for the bottomLeft corner of a rounded rectangle"
	| f aaw topColor bottomColor l d c width dy l1 l2 |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	width _ r.
	aaw _ 1.3.
	f _ Form
		extent: width @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: width - 1
				do: [ :x |
					dy _ height - r - y.
					dy > 0
						ifTrue: [ l _ 1.0 ]
						ifFalse: [
							d _ (x @ dy) r.
							l1 _ ((r - d-1+aaw max: 0.0) min: aaw) / aaw.
							l2 _ ((d - r+bw+aaw max: 0.0) min: aaw) / aaw.
							l _ l1 min: l2.
							].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 11/30/2010 10:34' prior: 50349142!
                         topLeftCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topLeft corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (w - 1 - x @ (w - 1 - y)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!Form class methodsFor: 'creation - anti aliased' stamp: 'jmv 11/30/2010 10:36' prior: 50349169!
                             topRightCorner: r height: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	"Create and answer a Form with a vertical gray gradient as specified for the topRight corner of a rounded rectangle"
	| f bw topColor bottomColor l d c w |
	topColor _ Color white * gradientTopFactor.
	bottomColor _ Color white * gradientBottomFactor.
	w _ r.
	bw _ 1.3.
	f _ Form
		extent: w @ height
		depth: 32.
	0
		to: height - 1
		do: [ :y |
			c _ bottomColor
				mixed: 1.0 * y / (height - 1)
				with: topColor.
			0
				to: w - 1
				do: [ :x |
					l _ 1.0.
					y < r ifTrue: [
						d _ (x @ (w - y - 1)) r.
						l _ ((r - d max: 0.0) min: bw) / bw ].
					f
						colorAt: x @ y
						put: (c alpha: l) ]].
	^ f! !
!ColorForm methodsFor: 'accessing' stamp: 'ar 5/17/2001 15:45' prior: 50349195!
                    colors: colorList
	"Set my color palette to the given collection."

	| colorArray colorCount newColors |
	colorList ifNil: [
		colors _ cachedDepth _ cachedColormap _ nil.
		^ self].

	colorArray _ colorList asArray.
	colorCount _ colorArray size.
	newColors _ Array new: (1 bitShift: self depth).
	1 to: newColors size do: [:i |
		i <= colorCount
			ifTrue: [newColors at: i put: (colorArray at: i)]
			ifFalse: [newColors at: i put: Color transparent]].

	colors _ newColors.
	cachedDepth _ nil.
	cachedColormap _ nil.
! !
!ColorForm methodsFor: 'color manipulation' stamp: 'di 11/11/1998 13:20' prior: 50349215!
                         asGrayScale
	"Return a grayscale ColorForm computed by mapping each color into its grayscale equivalent"
	^ self copy colors:
		(colors collect:
			[:c | c isTransparent ifTrue: [c]
						ifFalse: [Color gray: c luminance]])! !
!ColorForm methodsFor: 'color manipulation' stamp: 'jmv 3/1/2010 09:41' prior: 50349225!
   colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	| newMap |
	colors ifNil: [
		"use the standard colormap"
		^ Color colorMapIfNeededFrom: self depth to: destDepth].

	(destDepth = cachedDepth and:[cachedColormap isColormap not]) 
		ifTrue: [^ cachedColormap].
	newMap _ Bitmap new: colors size.
	1 to: colors size do: [:i |
		newMap
			at: i
			put: ((colors at: i) pixelValueForDepth: destDepth)].

	cachedDepth _ destDepth.
	^ cachedColormap _ newMap.
! !
!ColorForm methodsFor: 'private' stamp: 'ar 5/17/2001 15:44' prior: 50349245!
            ensureColorArrayExists
	"Return my color palette."

	colors ifNil: [
		self depth > 8 ifTrue: [^ self error: 'ColorForms only support depths up to 8 bits'].
		self colors: (Color indexedColors copyFrom: 1 to: (1 bitShift: self depth))].
! !
!ColorForm class methodsFor: 'as yet unclassified' stamp: 'jmv 4/10/2015 23:20' prior: 50349256!
              mappingWhiteToTransparentFrom: aFormOrCursor
	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."

	| f map |
	aFormOrCursor depth <= 8 ifFalse: [
		^ self error: 'argument depth must be 8-bits per pixel or less'].
	(aFormOrCursor is: #ColorForm) ifTrue: [
		f _ aFormOrCursor copy.
		map _ aFormOrCursor colors.
	] ifFalse: [
		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.
		f copyBits: aFormOrCursor boundingBox
			from: aFormOrCursor
			at: 0@0
			clippingBox: aFormOrCursor boundingBox
			rule: Form over.
		map _ Color indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].
	map _ map collect: [:c |
		c = Color white ifTrue: [Color transparent] ifFalse: [c]].
	f colors: map.
	^ f
! !
!ColorForm class methodsFor: 'instance creation' stamp: 'jmv 5/4/2016 16:31' prior: 50349284!
  grayScaleAndTransparentExtent: aPoint
"Native depth"
	"Answer a ColorForm for storing 8bpp gray scale. (do not include any slot for transparent)"

	| grays result |
	result _ self extent: aPoint depth: (Smalltalk isLittleEndian ifTrue: [ -8 ] ifFalse: [ 8 ]).
	grays _ (0 to: 255) collect: [ :brightness | Color gray: brightness asFloat / 255.0].
	grays at: 1 put: Color transparent.
	result colors: grays.
	^result! !
!Cursor methodsFor: 'converting' stamp: 'jmv 2/25/2011 19:47' prior: 50349300!
              asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: self fillColor: Color black at: offset negated.
	^ form offset: offset! !
!CursorWithMask methodsFor: 'converting' stamp: 'jmv 2/25/2011 19:47' prior: 50349308!
            asCursorForm
	| form |
	form _ Form extent: self extent depth: 8.
	form fillShape: maskForm fillColor: Color white.
	form fillShape: self fillColor: Color black at: offset negated.
	^ form offset: offset! !
!GrayForm methodsFor: 'pixel accessing' stamp: 'jmv 5/11/2016 19:57' prior: 50349318!
                           grayAt: aPoint
	"Return the color of the pixel at aPoint."

	^Color gray: (self pixelValueAt: aPoint) asFloat / 255.0! !
!GrayForm methodsFor: 'color manipulation' stamp: 'jmv 5/12/2016 15:04' prior: 50349325!
              colormapIfNeededForDepth: destDepth
	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."

	^ Color cachedColormapFromGrayTo: destDepth! !
!BMPReadWriter methodsFor: 'reading' stamp: 'ar 10/24/2005 20:57' prior: 50349334!
                  readColorMap
	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."
	| colorCount colors maxLevel b g r ccStream |
	colorCount := (bfOffBits - 54) // 4.
	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"
	biBitCount >= 16 ifTrue:[^nil].
	colorCount = 0 ifTrue: [ "this BMP file does not have a color map"
		"default monochrome color map"
		biBitCount = 1 ifTrue: [^ Array with: Color white with: Color black].
		"default gray-scale color map"
		maxLevel := (2 raisedTo: biBitCount) - 1.
		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].
	ccStream := ReadStream on: (stream next: colorCount*4).
	colors := Array new: colorCount.
	1 to: colorCount do: [:i |
		b := ccStream next.
		g := ccStream next.
		r := ccStream next.
		ccStream next. "skip reserved"
		colors at: i put: (Color r: r g: g b: b range: 255)].
	^ colors
! !
!BitBlt methodsFor: 'accessing' stamp: 'jmv 3/20/2013 00:50' prior: 50349369!
               fillColor
	"Return the current fill color as a Color.  
	 Gives the wrong answer if the halftoneForm is a complex pattern of more than one word."

	halftoneForm ifNil: [^ Color black].
	^ Color colorFromPixelValue: halftoneForm first depth: destForm depth! !
!BitBlt class methodsFor: 'examples' stamp: 'jmv 7/27/2015 17:07' prior: 50349380!
          alphaBlendDemo
	"To run this demo, use...
		Display restoreAfter: [BitBlt alphaBlendDemo]	
	Displays 10 alphas, then lets you paint.  Option-Click to stop painting."

	"This code exhibits alpha blending in any display depth by performing
	the blend in an off-screen buffer with 32-bit pixels, and then copying
	the result back onto the screen with an appropriate color map. - tk 3/10/97"
	
	"This version uses a sliding buffer for painting that keeps pixels in 32 bits
	as long as they are in the buffer, so as not to lose info by converting down
	to display resolution and back up to 32 bits at each operation. - di 3/15/97"

	| brush buff dispToBuff buffToDisplay mapDto32 map32toD prevP p brushToBuff theta buffRect buffSize buffToBuff brushRect delta newBuffRect updateRect |  

	"compute color maps if needed"
	Display depth <= 8 ifTrue: [
		mapDto32 _ Color cachedColormapFrom: Display depth to: 32.
		map32toD _ Color cachedColormapFrom: 32 to: Display depth].

	"display 10 different alphas, across top of screen"
	buff _ Form extent: 500@50 depth: 32.
	dispToBuff _ BitBlt toForm: buff.
	dispToBuff colorMap: mapDto32.
	dispToBuff copyFrom: (50@10 extent: 500@50) in: Display to: 0@0.
	1 to: 10 do: [:i | dispToBuff fill: (50*(i-1)@0 extent: 50@50)
						fillColor: (Color red alpha: i/10)
						rule: Form blend].
	buffToDisplay _ BitBlt toForm: Display.
	buffToDisplay colorMap: map32toD.
	buffToDisplay copyFrom: buff boundingBox in: buff to: 50@10.
	DisplayScreen screenUpdateRequired: nil.

	"Create a brush with radially varying alpha"
	brush _ Form extent: 30@30 depth: 32.
	1 to: 5 do: 
		[:i | brush fillShape: (Form dotOfSize: brush width*(6-i)//5)
				fillColor: (Color red alpha: 0.02 * i - 0.01)
				at: brush extent // 2].

	"Now paint with the brush using alpha blending."
	buffSize _ 100.
	buff _ Form extent: brush extent + buffSize depth: 32.  "Travelling 32-bit buffer"
	dispToBuff _ BitBlt toForm: buff.  "This is from Display to buff"
	dispToBuff colorMap: mapDto32.
	brushToBuff _ BitBlt toForm: buff.  "This is from brush to buff"
	brushToBuff sourceForm: brush; sourceOrigin: 0@0.
	brushToBuff combinationRule: Form blend.
	buffToBuff _ BitBlt toForm: buff.  "This is for slewing the buffer"

	[Sensor isMouseButton2Pressed] whileFalse:
		[prevP _ nil.
		buffRect _ Sensor mousePoint - (buffSize // 2) extent: buff extent.
		dispToBuff copyFrom: buffRect in: Display to: 0@0.
		[Sensor isMouseButton1Pressed] whileTrue:
			["Here is the painting loop"
			p _ Sensor mousePoint - (brush extent // 2).
			(prevP == nil or: [prevP ~= p]) ifTrue:
				[prevP == nil ifTrue: [prevP _ p].
				(p dist: prevP) > buffSize ifTrue:
					["Stroke too long to fit in buffer -- clip to buffer,
						and next time through will do more of it"
					theta _ (p-prevP) theta.
					p _ ((theta cos@theta sin) * buffSize asFloat + prevP) truncated].
				brushRect _ p extent: brush extent.
				(buffRect containsRect: brushRect) ifFalse:
					["Brush is out of buffer region.  Scroll the buffer,
						and fill vacated regions from the display"
					delta _ brushRect amountToTranslateWithin: buffRect.
					buffToBuff copyFrom: buff boundingBox in: buff to: delta.
					newBuffRect _ buffRect translatedBy: delta negated.
					newBuffRect
						areasOutside: buffRect
						do: [ :r | dispToBuff copyFrom: r in: Display to: r origin - newBuffRect origin ].
					buffRect _ newBuffRect].

				"Interpolate from prevP to p..."
				brushToBuff drawFrom: prevP - buffRect origin
									to: p - buffRect origin
									withFirstPoint: false.

				"Update (only) the altered pixels of the destination"
				updateRect _ (p min: prevP) corner: (p max: prevP) + brush extent.
				buffToDisplay copy: updateRect from: updateRect origin - buffRect origin in: buff.
				DisplayScreen screenUpdateRequired: updateRect.
				prevP _ p]]]! !
!WarpBlt methodsFor: 'setup' stamp: 'mtf 8/14/2009 18:21' prior: 50349503!
                  cellSize: s
	"Set the number of samples used for averaging"
	cellSize := s.
	cellSize = 1 ifTrue: [^ self].
	"Install the colorMap to used for mapping the averaged RGBA 32bit pixels to the
	destination depth. Note that we need to install the 32->32 color map explicitly because
	the VM will substitute a colorMap derived from sourceForm->destForm mapping which
	is just plain wrong for <32 source and 32bit dest depth"
	(destForm depth = 32 and: [sourceForm notNil] and: [sourceForm depth < 32])
		ifTrue:[colorMap := ColorMap shifts: #(0 0 0 0) masks:#(16rFF0000 16rFF00 16rFF 16rFF000000) colors: nil]
		ifFalse:[colorMap := Color colorMapIfNeededFrom: 32 to: destForm depth].
! !
!GrafPort methodsFor: 'text' stamp: 'jmv 6/1/2015 13:28' prior: 50349527!
           displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font color: foregroundColor
	"If required, do a second pass with new rule and colorMap.
	Answer last affected pixel position
	Answer nil if nothing was done
	"

	| answer prevRule secondPassMap sourceDepth destDepth |

	"Slight optimization when there's nothing to do."
	clipHeight = 0 ifTrue: [^nil].
	clipWidth = 0 ifTrue: [^nil].

	self installStrikeFont: font foregroundColor: (foregroundColor alpha: 1).

	"If combinationRule is rgbMul, we might need the special two-pass technique for component alpha blending.
	If not, do it simply"
	combinationRule = 37 "rgbMul" ifFalse: [
		^self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font ].
	
	"We need to do a second pass. The colormap set is for use in the second pass."
	secondPassMap _ colorMap.
	sourceDepth _ sourceForm depth.
	destDepth _ destForm depth.
	colorMap _ sourceDepth ~= destDepth
		ifTrue: [ Color cachedColormapFrom: sourceDepth to: destDepth ].
	answer := self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font.
	colorMap := secondPassMap.
	secondPassMap ifNotNil: [
		prevRule := combinationRule.
		combinationRule := 20. "rgbAdd"
		self basicDisplayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font.
		combinationRule := prevRule ].
	^answer! !
!GrafPort methodsFor: 'private' stamp: 'jmv 5/12/2016 14:52' prior: 50349574!
                              cachedFontColormapFrom1BitTo: destDepth

	| map dstIndex |
	CachedFontColorMaps 
		ifNil: [CachedFontColorMaps _ Array new: 6].

	dstIndex _ destDepth highBit.
	(CachedFontColorMaps at: dstIndex) ifNotNil: [ :m | ^ m ].

	map _ (Color cachedColormapFrom: 1 to: destDepth) copy.
	CachedFontColorMaps at: dstIndex put: map.
	^ map! !
!GrafPort methodsFor: 'private' stamp: 'jmv 5/12/2016 14:55' prior: 50349587!
      colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: keepSubPix
	"Note: The color converting map for sourceDepth=16 and for sourceDepth=32 are the same"
	
	| srcIndex dstIndex map mapsForSource mapsForSourceAndDest |
	ColorConvertingMaps 
		ifNil: [ColorConvertingMaps _ (1 to: 6) collect: [:i | Array new: 6]].

	srcIndex _ sourceDepth highBit.
	sourceDepth > 8 ifTrue: [ srcIndex _ keepSubPix ifTrue: [5] ifFalse: [6] ].
	dstIndex _ destDepth highBit.
	
	mapsForSource _ ColorConvertingMaps at: srcIndex.
	(mapsForSourceAndDest _ mapsForSource at: dstIndex) ifNil: [
		mapsForSourceAndDest _ mapsForSource at: dstIndex put: Dictionary new ].
	
	map _ mapsForSourceAndDest at: targetColor ifAbsentPut: [
		Color 
			computeColorConvertingMap: targetColor 
			from: sourceDepth 
			to: destDepth 
			keepSubPixelAA: keepSubPix ].

	^ map! !
!GrafPort methodsFor: 'private' stamp: 'jmv 4/17/2014 16:57' prior: 50349617!
              setRuleAndMapFor: sourceDepth foregroundColor: foregroundColor

	| targetColor destDepth |
	destDepth _ destForm depth.
	halftoneForm _ nil.	"Don't use fillColor. Use a more powerful ColorMap"

	sourceDepth = 1 ifTrue: [
		self combinationRule: Form paint.
		"Set up color map for a different source depth (color font)"
		"Uses caching for reasonable efficiency"
		colorMap _ self cachedFontColormapFrom1BitTo: destDepth.
		colorMap at: 1 put: (destForm pixelValueFor: Color transparent).
		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor) ]
	
	ifFalse: [
		"Enable subpixel rendering if requested, but never for translucent text:
		This technique always draws opaque text. This could be added, by using an extra colormap for the rgbMul phase...
		So far, no need arised for doing so."
		(sourceDepth > 8 and: [
			Preferences subPixelRenderFonts and: [ foregroundColor = Color black or: [ 
				Preferences subPixelRenderColorFonts and: [ foregroundColor isOpaque ]]]]) ifTrue: [
			destDepth > 8 ifTrue: [
				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"
				self combinationRule: 37.		"rgbMul"
				colorMap _ (foregroundColor ~= Color black or: [
						destDepth = 32 and: [ destForm ~~ Display or: [Preferences properDisplayAlphaForFonts] ]]) ifTrue: [
					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"
					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)
					See #displayString:from:to:at:strikeFont:color:"
					"Note: In 32bpp, if we want the correct alpha in the result, we need the second pass, as the destination could have transparent pixels, 
					and we need to add to the alpha channel"
					self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
			ifFalse: [
				self combinationRule: 25.		"Paint"
				targetColor _ foregroundColor = Color black ifFalse: [ foregroundColor ].
				colorMap _ self colorConvertingMap: targetColor from: sourceDepth to: destDepth keepSubPixelAA: true]]
		ifFalse: [
			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"
			self combinationRule: (destDepth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).
			colorMap _ self colorConvertingMap: foregroundColor from: sourceDepth to: destDepth keepSubPixelAA: false]]! !
!Rectangle methodsFor: 'transforming' stamp: 'jmv 9/24/2013 22:36' prior: 50350830!
                       newRectFrom: newRectBlock
	"Track the outline of a new rectangle until mouse button changes.
	newFrameBlock produces each new rectangle from the previous"
	| rect newRect buttonStart buttonNow aHand delay |
	delay _ Delay forMilliseconds: 10.
	buttonStart _ buttonNow _ Sensor isAnyButtonPressed.
	rect _ self.
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	[buttonNow == buttonStart] whileTrue: 
		[delay wait.
		buttonNow _ Sensor isAnyButtonPressed.
		newRect _ newRectBlock value: rect.
		newRect = rect ifFalse:
			[Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
			Display border: newRect width: 2 rule: Form reverse fillColor: Color gray.
			rect _ newRect]].
	Display border: rect width: 2 rule: Form reverse fillColor: Color gray.
	" pay the price for reading the sensor directly ; get this party started "
	aHand _ self runningWorld activeHand.
	aHand
		newMouseFocus: nil;
		flushEvents.
	Sensor processSensorEvent: Sensor createMouseEvent discardingMouseEvents: false.
	^ rect! !
!StrikeFont methodsFor: 'emphasis' stamp: 'jmv 4/10/2015 23:21' prior: 50350866!
                           makeBoldGlyphs
	"Make a bold set of glyphs with same widths by ORing 1 bit to the right
		(requires at least 1 pixel of intercharacter space)"
	| g bonkForm |
	g _ glyphs copy.
	bonkForm _ (Form extent: 1@16) fillBlack offset: -1@0.
	self bonk: g with: bonkForm.
	glyphs depth = 1 ifTrue: [
		g copyBits: g boundingBox from: g at: (1@0)
			clippingBox: g boundingBox rule: Form under ]
		ifFalse: [
			0 to: g width - 2 do: [ :x | 0 to: g height-1 do: [ :y |
				(glyphs colorAt:  x@y) = Color white ifFalse: [
					g colorAt: x+1@y put: 
						((glyphs colorAt: x+1@y) = Color white 
							ifTrue: [glyphs colorAt:  x@y]
							ifFalse: [Color black])]]]].
	glyphs _ g.
	self isSynthetic: true! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:22' prior: 50350891!
                    makeControlCharsVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character space).
	glyph border: glyph boundingBox width: 1 fillColor: Color blue.
	self glyphAt: (Character numericValue: 134) put: glyph.
	
	"Keep tab(9), lf(10), cr(13) and space(32) transparent or whatever the user chose"
	#(0 1 2 3 4 5 6 7 8 11 12 14 15 16 17 18 19 20 21 22 23 24 25 26 27)
		do: [ :ascii |
			characterToGlyphMap at: ascii + 1 put: 134 ]! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:27' prior: 50350908!
             makeCrVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character numericValue: 182).
	glyph border: glyph boundingBox width: 1 fillColor: Color blue.
"	glyph _ glyph reverse."
	self glyphAt: (Character numericValue: 133) put: glyph.
	characterToGlyphMap at: 14 put: 133! !
!StrikeFont methodsFor: 'glyphs' stamp: 'jmv 9/2/2016 11:03:31' prior: 50350920!
         makeLfVisible
	| glyph |
	self characterToGlyphMap.
	glyph _ self glyphAt: (Character numericValue: 163).
	glyph border: glyph boundingBox width: 1 fillColor: Color blue.
"	glyph _ glyph reverse."
	self glyphAt: (Character numericValue: 132) put: glyph.
	characterToGlyphMap at: 11 put: 132! !
!Morph methodsFor: 'accessing' stamp: 'jmv 8/21/2012 20:40' prior: 50350932!
             color

	^ Color blue! !
!Morph methodsFor: 'drawing' stamp: 'jmv 4/14/2015 08:53' prior: 50350936!
                             drawOn: aCanvas
	"A canvas is already set with a proper transformation from our coordinates to those of the Canvas target."
	aCanvas
		fillRectangle: self morphLocalBounds
		color: Color blue! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 18:46' prior: 50350946!
                              defaultColor
	^ Color orange! !
!BorderedRectMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2014 21:28' prior: 50350950!
  defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ Color gray! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35' prior: 50350956!
    defaultBorderColor
	"answer the default border color/fill style for the receiver"
	^ Color
		r: 0.861
		g: 1.0
		b: 0.722! !
!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:29' prior: 50350963!
          defaultColor
	"answer the default color/fill style for the receiver"
	^ Color
		r: 0.8
		g: 1.0
		b: 0.6! !
!PasteUpMorph methodsFor: 'world menu' stamp: 'jmv 11/10/2013 19:32' prior: 50350970!
                              findWindow: evt
	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."
	| menu expanded collapsed nakedMorphs |
	menu _ MenuMorph new.
	expanded _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed not ].
	collapsed _ SystemWindow windowsIn: self satisfying: [ :w | w isCollapsed ].
	nakedMorphs _ self submorphsSatisfying: [ :m |
		(m is: #SystemWindow) not ].
	expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty) ifTrue: [ ^ Smalltalk beep ].
	(expanded asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #activateAndForceLabelToShow.
		w canDiscardEdits ifFalse: [ menu lastItem color: Color red ]].
	expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty) ifFalse: [ menu addLine ].
	(collapsed asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #expand.
		w canDiscardEdits ifFalse: [ menu lastItem color: Color red ]].
	nakedMorphs isEmpty ifFalse: [ menu addLine ].
	(nakedMorphs asArray sort: [ :w1 :w2 |
		w1 label caseInsensitiveLessOrEqual: w2 label ]) do: [ :w |
		menu
			add: w label
			target: w
			action: #comeToFrontAndAddHalo ].
	menu addTitle: 'find window'.
	menu popUpInWorld: self! !
!EllipseMorph methodsFor: 'visual properties' stamp: 'ar 6/25/1999 11:14' prior: 50351024!
                         defaultColor
	"Return the default fill style for the receiver"
	^Color yellow! !
!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 8/6/2014 09:15' prior: 50351030!
                     defaultColor
	"answer the default color/fill style for the receiver"
	^ Color lightGray! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:50' prior: 50351036!
            drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (0@0 extent: extent) insetBy: 1@3.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 4/12/2012 22:37' prior: 50351077!
    iconColor

	^ self isPressed
		ifTrue: [ Color gray: 0.75 ]
		ifFalse: [
			self mouseIsOver
				ifTrue: [ Color gray: 0.75 ]
				ifFalse: [ Color white ]].! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 1/4/2013 13:31' prior: 50351086!
 example
	"
	PluggableButtonMorph example openInWorld
	"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: Color lightRed.
	b2 color: Color lightRed.
	b3 color: Color lightRed.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: 120@35.
	^ row
! !
!TextModelMorph methodsFor: 'drawing' stamp: 'cbr 10/10/2012 23:04' prior: 50351110!
                               drawOn: aCanvas 
	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"


	| bw bc |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"


	super drawOn: aCanvas.
	bw _ Preferences focusIndicatorWidth.
	bc _ nil.
	self wantsFrameAdornments ifTrue: [
		model refusesToAccept
			ifTrue: [  "Put up feedback showing that code cannot be submitted in this state"
				bc _ Color tan]
			ifFalse: [
				self textMorph hasEditingConflicts
					ifTrue: [
						bw _ 3.
						bc _ Color red ] 
					ifFalse: [
						self textMorph hasUnacceptedEdits
							ifTrue: [
								bc _ Color red]]]].

	(drawKeyboardFocusIndicator and: [ self textMorph hasKeyboardFocus ]) ifTrue: [
		bc ifNil: [
			bc _ Theme current focusIndicator ]]
	ifFalse: [
		bc ifNotNil: [
			bc _ bc alphaMixed: 0.4 with: Color white ]].
	bc ifNotNil: [
		aCanvas frameRectangle: self focusIndicatorRectangle borderWidth: bw color: bc ]! !
!SystemWindow methodsFor: 'initialization' stamp: 'cbr 11/7/2010 18:58' prior: 50351147!
 defaultColor
	"answer the default color/fill style for the receiver"
	^ Color white! !
!SystemWindow methodsFor: 'menu' stamp: 'jmv 6/7/2013 23:23' prior: 50351153!
                           setWindowColor: incomingColor
	| existingColor aColor |
	incomingColor ifNil: [^ self].  "it happens"
	aColor _ incomingColor asNontranslucentColor.
	aColor = Color black ifTrue: [^ self].
	existingColor _ self widgetsColor.
	existingColor ifNil: [^ Smalltalk beep].
	self widgetsColor: aColor.
	self redrawNeeded! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'KenD 8/27/2015 14:39' prior: 50351166!
  buildMorphicWindow
	" 
	CodePackageListWindow open: CodePackageList new
	"
	| dirtyFlags names fileNames upperRow  description summary backColor labelBackground textHeigth |
	backColor := self textBackgroundColor.	
	labelBackground := Theme current background.
	textHeigth := AbstractFont default height.
	
	dirtyFlags := PluggableListMorph
		model: model 
		listGetter: #packageDirtyFlags
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	dirtyFlags color: backColor.
	dirtyFlags := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Unsaved?') fixedHeight: textHeigth;
		addMorphUseAll: dirtyFlags.

	names := PluggableListMorph
		model: model 
		listGetter: #packageNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	names color: backColor.
	names := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' Package Name') fixedHeight: textHeigth;
		addMorphUseAll: names.

	fileNames := PluggableListMorph
		model: model 
		listGetter: #packageFullNames
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	fileNames color: backColor.
	fileNames := LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorph: (StringMorph new contents: ' File Name') fixedHeight: textHeigth;
		addMorphUseAll: fileNames.

	upperRow := LayoutMorph newRow.
	upperRow
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: names proportionalWidth: 0.27;
		addAdjusterAndMorph: fileNames proportionalWidth: 0.6.
		
	description := TextModelMorph
		textProvider: model
		textGetter: #description 
		textSetter: #description:.

	summary := TextModelMorph
		textProvider: model
		textGetter: #summary.

	self layoutMorph
		addMorph: upperRow proportionalHeight: 0.5;
		addAdjusterAndMorph: self buildButtonPane proportionalHeight: 0.1;
		addAdjusterAndMorph: summary proportionalHeight: 0.18;
		addAdjusterAndMorph: description proportionalHeight: 0.22;
		addAdjusterAndMorph: self buildRequirementsPane proportionalHeight: 0.2.
	self setLabel: 'Installed Packages'! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'len 5/27/2016 21:51' prior: 50351242!
                    buildRequirementsPane

	| requirements deleteReqButton "editReqButton" reqLayout buttonLayout |
	requirements := PluggableListMorph
		model: (PackageRequirementsList fromCodePackageList: model)
		listGetter: #requirementsStrings
		indexGetter: #selectionIndex
		indexSetter: #selectionIndex:.
	requirements color: Theme current textPane.
		
	deleteReqButton := PluggableButtonMorph 
							model: requirements model
							action: #deleteSelectedRequirement 
							label: 'delete'.
	deleteReqButton color: self widgetsColor.
							
	buttonLayout := LayoutMorph newColumn.
	buttonLayout addMorph: deleteReqButton 
					layoutSpec: (LayoutSpec 
										proportionalWidth: 1.0 
										proportionalHeight: 1.0
										minorDirectionPadding: #top);
					color: self widgetsColor quiteWhiter.
		
	model when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	self when: #changed: send: #updateRequirementsFromPackageList to: requirements model.
	requirements model when: #changed: send: #verifyContents to: requirements.
	self when: #changed: send: #verifyContents to: requirements.
	
	reqLayout := LayoutMorph newRow.
	^ reqLayout 
		doAdoptWidgetsColor;
		addMorph: requirements 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.9 
							proportionalHeight: 1.0 
							minorDirectionPadding: #left);
		addMorph: buttonLayout 
			layoutSpec: (LayoutSpec 
							proportionalWidth: 0.1 
							proportionalHeight: 1.0 
							minorDirectionPadding: #right);
		color: Color transparent;
		yourself
		! !
!CodeWindow methodsFor: 'updating' stamp: 'jmv 9/2/2013 10:25' prior: 50351293!
           decorateForInheritance
	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."

	| cm aColor aButton flags buttonColor |
	(aButton _ self inheritanceButton) ifNil: [^ self].
	buttonColor _ self buttonColor.

	Preferences decorateBrowserButtons
		ifFalse: [ ^aButton color: buttonColor ].
	cm _ model currentCompiledMethod.
	(cm is: #CompiledMethod)
		ifFalse: [ ^aButton color: buttonColor ].

	flags _ 0.
	model isThisAnOverride ifTrue: [ flags _ flags bitOr: 4 ].
	cm sendsToSuper ifTrue: [ flags _ flags bitOr: 2 ].
	model isThereAnOverride ifTrue: [ flags _ flags bitOr: 1 ].
	aColor _ {

		"This is NOTan override. There is no super implementation."
		buttonColor.							"no sends to super. there is not override in any subclass"
		Color tan.							"no sends to super. there is an override in some subclass"
		Color red.							"sends to super. there is no override in any subclass. Error: no super to call (or calls super with a different message)"
		Color red.							"sends to super. there is  an override in some subclass. Error: no super to call (or calls super with a different message)"

		"This is an override. There is some super implementation"
		Color red muchLighter.			"doesn't have sub; has super but doesn't call it"
		Color r: 0.94 g: 0.823 b: 0.673.		"has sub; has super but doesn't call it"
		Color green muchLighter.			"doesn't have sub; has super and callsl it"
		Color blue muchLighter.			"has sub; has super and callsl it"

	} at: flags + 1.
	aButton color: aColor! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'DM 8/22/2015 12:34' prior: 50351347!
    buildMorphicWindow
	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."

	| dirtyFlags changeSetList classList messageList upperPanes backColor labelBackground |
	backColor _ self textBackgroundColor.
	labelBackground _ Theme current background.
	model myChangeSet ifNil: [
		self flag: #ojo. "Or whatever was last changed, or is top of list, or whatever"
		model myChangeSet: ChangeSet changeSetForBaseSystem ].

	dirtyFlags _ PluggableListMorph
		model: model
		listGetter: #changeSetDirtyFlags
		indexGetter: nil
		indexSetter: nil.
	dirtyFlags color: backColor.
	dirtyFlags _ LayoutMorph newColumn
		color: Theme current background;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: ' Unsaved?');
		addMorphUseAll: dirtyFlags.

	changeSetList _ (PluggableListMorphByItem
				model: model
				listGetter: #changeSetList
				indexGetter: #currentCngSet
				indexSetter: #showChangeSetNamed:
				mainView: self
				menuGetter: #changeSetMenu
				keystrokeAction: #changeSetListKey:from:)
			autoDeselect: false.
	changeSetList color: backColor.
	changeSetList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Change Set name');
		addMorphUseAll: changeSetList.

	classList _ PluggableListMorphByItem
				model: model
				listGetter: #classList
				indexGetter: #currentClassName
				indexSetter: #currentClassName:
				mainView: self
				menuGetter: #classListMenu
				keystrokeAction: #classListKey:from:.
	classList color: backColor.
	classList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Classes');
		addMorphUseAll: classList.

	upperPanes _ LayoutMorph newRow.
	upperPanes
		addMorph: dirtyFlags proportionalWidth: 0.13;
		addAdjusterAndMorph: changeSetList proportionalWidth: 0.47;
		addAdjusterAndMorph: classList proportionalWidth: 0.4.

	messageList _ PluggableListMorphByItem
				model: model
				listGetter: #messageList
				indexGetter: #currentSelector
				indexSetter: #currentSelector:
				mainView: self
				menuGetter: #messageMenu
				keystrokeAction: #messageListKey:from:.
	messageList color: backColor.
	messageList _ LayoutMorph newColumn
		color: labelBackground;
		addMorph: (RectangleLikeMorph new color: Color transparent) fixedHeight: 4;
		addMorphKeepMorphHeight: (StringMorph new contents: 'Methods');
		addMorphUseAll: messageList.

	self layoutMorph
		addMorph: upperPanes proportionalHeight: 0.25;
		addAdjusterAndMorph: messageList proportionalHeight: 0.2;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.55.

	self setLabel: model labelString! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'HAW 1/12/2017 18:47:35' prior: 50351445!
        buttonRowForPreDebugWindow: aDebugger
	| row aButton triads buttons |
	buttons _ OrderedCollection new.
	triads _ OrderedCollection withAll: self preDebugButtonSpec.
	aDebugger shouldBeAbleToCreateMethod ifTrue: [ triads add: { 'Create'. #createMethod. 'create the missing method' }].
	
	triads do: [ :triad |
		aButton _ PluggableButtonMorph new model: self.
		aButton label: triad first.
		aButton action: triad second.
		aButton setBalloonText: triad third.
		buttons add: aButton].
	
	row _ LayoutMorph newRow.
	row doAdoptWidgetsColor.
	row color: Color transparent.
	row separation: 1.
	row addMorphs: buttons.
	^row! !
!TestRunnerWindow methodsFor: 'constants' stamp: 'jmv 4/16/2011 13:57' prior: 50351468!
                      runButtonColor
	^ Color green lighter duller! !
!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:52' prior: 50351473!
                   defaultColor
	^Color white! !
!ProgressBarMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:53' prior: 50351477!
     initialize
	super initialize.
	progressColor _ Color gray.
	value _ 0.0! !
!MenuMorph methodsFor: 'construction' stamp: 'len 11/16/2015 02:52' prior: 50351483!
addStayUpIcons
	| closeBox pinBox w |
	Preferences optionalButtons ifFalse: [ ^self ].
	(self valueOfProperty: #hasStayUpIcons ifAbsent: [ false ])
		ifTrue: [
		 	self removeProperty: #needsStayUpIcons.
			^self ].
	titleMorph ifNil: [
		"Title not yet there. Flag ourself, so this method is called again when adding title."
		self setProperty: #needsStayUpIcons toValue: true.
		^ self].
	closeBox _ PluggableButtonMorph model: self action: #delete.
	closeBox icon: Theme current closeIcon; color: Color transparent.
	pinBox _ PluggableButtonMorph model: self action: #stayUp.
	pinBox icon: Theme current pushPinIcon; color: Color transparent.
	w _ (titleMorph hasSubmorphs ifTrue: [ titleMorph firstSubmorph morphWidth ] ifFalse: [ 0 ]) + 60.
	self addMorphFront: 
		(LayoutMorph newRow
			"Make room for buttons"
			morphExtent: w @ (titleMorph morphHeight max: 19);
			color: Color transparent;
			addMorph: closeBox fixedWidth: 20;
			addMorph: (RectangleLikeMorph new color: Color transparent) fixedWidth: 4;
			addMorph: titleMorph proportionalWidth: 1;
			addMorph: (RectangleLikeMorph new color: Color transparent) fixedWidth: 4;
			addMorph: pinBox fixedWidth: 20).

	self setProperty: #hasStayUpIcons toValue: true.
	self removeProperty: #needsStayUpIcons! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 6/8/2014 20:32' prior: 50351526!
                  displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m is: #MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		self addMorphBack: feedbackMorph lock position: (0@ -20).
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self removeProperty: #feedbackMorph ].
	matches notEmpty ifTrue: [
		self selectItem: matches first ]! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 4/14/2016 15:10' prior: 50351556!
                            drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas frameAndFillRectangle: (0@0 extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			frameRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: self upButtonPosition.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: self downButtonPosition.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			fillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			color: Color veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].
			aCanvas
				drawString: (completer entries at: index) asString
				at: rectangle topLeft
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!AutoCompleterMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:09' prior: 50351607!
                  defaultBorderColor
	^ Color gray! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 9/9/2012 23:59' prior: 50351611!
              drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"This method is only called when we are carrying morphs around..."
	 aCanvas
		stencil: Cursor move
		at: 0@0
		color: Color black! !
!ImageMorph methodsFor: 'accessing' stamp: 'jmv 3/14/2011 09:15' prior: 50351620!
          color: aColor
        super color: aColor.
        (image depth = 1 and: [aColor is: #Color]) ifTrue: [
                image colors: {Color transparent. aColor}.
                self redrawNeeded]! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 3/13/2009 10:04' prior: 50351629!
  isEnabled: aBoolean

	isEnabled = aBoolean ifTrue: [^ self].
	isEnabled _ aBoolean.
	self color: (aBoolean ifTrue: [Color black] ifFalse: [Color gray]).
! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55' prior: 50351637!
                 offImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.9) 
			borderWidth: 1 borderColor: Color black.
	^form! !
!MenuItemMorph methodsFor: 'private' stamp: 'jmv 9/9/2012 23:55' prior: 50351649!
            onImage
	"Return the form to be used for indicating an '<off>' marker"
	| form |
	form _ Form extent: (self fontToUse ascent-2) asPoint depth: 16.
	form getCanvas
		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) 
			borderWidth: 1 borderColor: Color black;
		fillRectangle: (form boundingBox insetBy: 2) color: Color black.
	^form! !
!LayoutMorph methodsFor: 'accessing' stamp: 'jmv 12/1/2015 09:53' prior: 50351663!
         adoptWidgetsColor: paneColor
	super adoptWidgetsColor: paneColor.
	doAdoptWidgetsColor
		ifTrue: [ self color: (Theme current buttonColorFrom: paneColor) ]
		ifFalse: [ self color: Color transparent ]! !
!LayoutMorph methodsFor: 'initialization' stamp: 'jmv 8/17/2014 21:38' prior: 50351673!
                            defaultColor
	^Color gray! !
!LayoutMorph class methodsFor: 'instance creation' stamp: 'jmv 4/3/2011 22:59' prior: 50351677!
   initializedInstance
	"Answer a row by default so the 'new morph' menu doesn't fail..."
	^self newRow color: (Color red alpha: 0.2)! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 10:57' prior: 50351684!
   example1
"
	self example1
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (BorderedRectMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/12/2015 16:42' prior: 50351751!
                      example10
"
	self example10 openInWorld
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example10.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
^ pane! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 10:55' prior: 50351819!
               example11
"
	self example11
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example11.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color blue); name: #B)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addAdjusterMorph; 
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #G)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:08' prior: 50351889!
    example13
	"
	self example13
	"
	| pane row innerRow |
pane _ (LayoutMorph newColumn separation: 5)	name: #example13.
	pane color: Color red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	innerRow _ (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (BorderedRectMorph new name: #Box1)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Box2)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Bar)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 				minorDirectionPadding: #center);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 				minorDirectionPadding: #top);
		addMorph: LayoutAdjustingMorph new layoutSpec: (LayoutSpec fixedWidth: 5); 
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 2/16/2016 13:27' prior: 50351937!
                            example1b
"
Based on #example1, but using some Morph instead of RectangleLikeMorph -> extent is not adjustable
	self example1b
"
| pane row |
pane _ (LayoutMorph newColumn separation: 5)	name: #example1.
pane color: Color red.

row _ LayoutMorph newRow name: #Row1.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #A)
		layoutSpec: (LayoutSpec fixedWidth: 10); 
	addMorph: (Morph new name: #B);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #C)
		layoutSpec: (LayoutSpec proportionalWidth: 0.4);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #D)
		layoutSpec: (LayoutSpec proportionalWidth: 0.15);
	addMorph: (BorderedRectMorph new color: (Color h: 60 s: 0.6 v: 0.6); name: #E)
		layoutSpec: (LayoutSpec fixedWidth: 20 fixedHeight: 20).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row2.
row
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color blue); name: #F)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8);
	addMorph: (Morph new name: #G);
	addMorph: (BorderedRectMorph new color: (Color h: 30 s: 0.6 v: 0.6); name: #H)
		layoutSpec: (LayoutSpec proportionalWidth: 0.2).
pane addMorph: row layoutSpec: LayoutSpec useAll.

row _ (LayoutMorph newRow separation: 5) name: #Row3.
row
	color: Color red;
	addMorph: (Morph new name: #J);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec  proportionalWidth: 0.5 fixedHeight: 40);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
pane addMorph: row layoutSpec: (LayoutSpec fixedHeight: 60).
pane morphPosition: 150@130 extent: 400@300.
pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:25' prior: 50351998!
                          example2
	"
	self example2
	"
	| pane row |
	pane _ (LayoutMorph newColumn separation: 5)	name: #example2.
	pane color: Color red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #A)
			layoutSpec: (LayoutSpec fixedWidth: 20 proportionalHeight: 0.8 minorDirectionPadding: #bottom);
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #B)
			layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 40 minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #C)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 0.7 minorDirectionPadding: #center).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 200@180 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 11/18/2015 09:45' prior: 50352030!
                              example20
"
	self example20
"
| column |

column _ (LayoutMorph newColumn separation: 5) name: #Column.
column
	color: Color red;
	addMorph: (BorderedRectMorph new color: (Color h: 120 s: 0.6 v: 0.6); name: #J)
		layoutSpec: (LayoutSpec proportionalWidth: 0.8 fixedHeight: 20);
	addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #K)
		layoutSpec: (LayoutSpec fixedWidth: 40 proportionalHeight: 0.5);
	addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #L)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 30).
column morphPosition: 150@130 extent: 400@300.
column openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'dhn 4/5/2015 11:13' prior: 50352053!
       example3
	"
	self example3
	"
	| pane row innerRow |
pane _ (LayoutMorph newColumn separation: 5)	name: #example3.
	pane color: Color red.
	row _ (LayoutMorph newRow separation: 5) name: #Row.
	innerRow _ (LayoutMorph newRow separation: 5) name: #InnerRow;
		color: Color red.
	innerRow
		addMorph: (BorderedRectMorph new name: #Box1)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Box2)
			layoutSpec: (LayoutSpec fixedWidth: 10 fixedHeight: 10);
		addMorph: (BorderedRectMorph new name: #Bar)
		layoutSpec: (LayoutSpec proportionalWidth: 1.0 fixedHeight: 10).
	row
		color: (Color h: 270 s: 0.2 v: 0.6);
		addMorph: innerRow
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 30 				minorDirectionPadding: #center);
		addMorph: (BorderedRectMorph new color: (Color h: 90 s: 0.6 v: 0.6); name: #Rect1)
			layoutSpec: (LayoutSpec proportionalWidth: 0.5 fixedHeight: 40 				minorDirectionPadding: #top);
		addMorph: (BorderedRectMorph new color: (Color h: 150 s: 0.6 v: 0.6); name: #Rect2)
			layoutSpec: (LayoutSpec fixedWidth: 30 proportionalHeight: 1.0).
	pane addMorph: row layoutSpec: (LayoutSpec proportionalHeight: 0.9).
	pane morphPosition: 250@130 extent: 400@300.
	pane openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 6/8/2014 20:03' prior: 50352096!
                            example6
	"
	Useful example contributed by Ken Dickey
	All these should look the same, right? (mmmh this should be a test...)
	self example6
	"
| pane rect1 rect2 |
pane _ LayoutMorph newRow separation: 5. "1"
pane addMorph: (StringMorph contents: '1').

rect1 := BorderedRectMorph new color: (Color lightOrange); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect1.
rect2 := BorderedRectMorph new color: (Color cyan); 
	morphExtent: 20 @ 30.
pane addMorphFront: rect2.
pane
	color: Color lightGreen;
	morphPosition: 120 @ 50 extent: 180 @ 100;
	openInWorld.

pane _ LayoutMorph newRow separation: 5. "2"
pane addMorph: (StringMorph contents: '2').

rect1 := BorderedRectMorph new color: (Color lightOrange);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect1.
rect2 := BorderedRectMorph new color: (Color cyan).
pane addMorph: rect2
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane
	color: Color lightGreen;
	morphPosition: 320 @ 50 extent: 180 @ 100;
	openInWorld.


pane _ LayoutMorph newRow separation: 5. "3"
pane addMorph: (StringMorph contents: '3').

rect1 := BorderedRectMorph new color: (Color lightOrange).
pane addMorph: rect1 
         layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
rect2 := BorderedRectMorph new color: (Color cyan);
	layoutSpec: (LayoutSpec  fixedWidth: 20 fixedHeight: 30 minorDirectionPadding: #center).
pane addMorph: rect2.
pane
	color: Color lightGreen;
	morphPosition: 520 @ 50 extent: 180 @ 100;
	openInWorld! !
!LayoutMorph class methodsFor: 'examples' stamp: 'jmv 1/4/2013 13:42' prior: 50352149!
            launcherExample
	"
	self launcherExample
	"
	| b1 b2 b3 row b4 random buttons |
	random _ Random new.
	b1 _ PluggableButtonMorph model: [ Date today print ] action: #value label: 'Date'.
	b2 _ PluggableButtonMorph model: [ Time now print ] action: #value label: 'Time'.
	b3 _ PluggableButtonMorph model: [ SystemVersion current print ] action: #value label: 'Version'.
	b4 _ PluggableButtonMorph model: [ random next print ] action: #value label: 'Random'.
	buttons _ {b1. b2. b3. b4}.
	buttons do: [ :button |
		button color: Color lightRed ].
	row _ LayoutMorph newRow
		 color: Color red;
		 addMorphs: buttons;
		 morphExtent: 300 @ 40.
	^ row openInWorld! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:55' prior: 50352173!
               defaultColor
	^Color veryLightGray! !
!HaloHandleMorph class methodsFor: 'accessing' stamp: 'jmv 11/18/2010 09:44' prior: 50352178!
                            circleForm: extent
	"
	CircleForm _ nil
	"
	| r d l bw center |
	(CircleForm isNil or: [ CircleForm extent ~= extent ]) ifTrue: [
		center _ extent -1 * 0.5.
		r _ center r * 0.75.
		bw _ 1.3.
		CircleForm _ Form extent: extent depth: 32.
		0 to: extent y - 1 do: [ :y |
			0 to: extent x - 1 do: [ :x |
				d _ (x@y - center) r.
				l _ (r - d max: 0.0) min: bw.
				CircleForm
					colorAt: x @ y
					put: (Color white alpha: (l / bw))
					]].
		].
	^CircleForm! !
!HaloMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:28' prior: 50352196!
                      defaultColor
	"answer the default color/fill style for the receiver"
	^ Color
		r: 0.6
		g: 0.8
		b: 1.0! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 5/27/2015 13:42' prior: 50352202!
     addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint colorToUse form icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: self class handleSize asPoint).
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: 0@0 ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 7/4/2016 22:14' prior: 50352236!
          addNameString: aString 
	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."

	| nameMorph namePosition nameBackground |
	nameBackground _ RectangleLikeMorph new
		color: ((target is: #SystemWindow) ifTrue: [target windowColor] ifFalse: [Color lightBlue alpha: 0.9]).
	nameMorph _ StringMorph contents: aString.
	nameMorph color: Color black.
	nameBackground morphExtent: nameMorph morphExtent + 4.
	namePosition _ haloBox width - nameMorph morphWidth // 2 @ (haloBox height).
	self addMorph: nameBackground position: namePosition - 2.
	self addMorph: nameMorph position: namePosition.
	^nameMorph! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/22/2012 15:18' prior: 50352259!
                doRot: evt with: rotHandle
	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."

	| degrees |
self revisar.
	self flag: #jmvVer2.
	evt hand obtainHalo: self.
	degrees _ (evt eventPosition - target referencePosition) degrees.
	degrees _ degrees - angleOffset degrees.
	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.
	degrees = 0.0
		ifTrue: [rotHandle color: Color lightBlue]
		ifFalse: [rotHandle color: Color blue].
	rotHandle submorphsDo:
		[:m | m color: rotHandle color makeForegroundColor].
	self removeAllHandlesBut: rotHandle.

	target rotationDegrees: degrees.

	rotHandle morphPositionInWorld: evt eventPosition - (rotHandle morphExtent // 2)! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 9/20/2012 00:01' prior: 50352285!
                              setDismissColor: evt with: dismissHandle
	"Called on mouseStillDown in the dismiss handle; set the color appropriately."

	| colorToUse |
	evt hand obtainHalo: self.
	colorToUse _  (dismissHandle morphContainsPoint:  (dismissHandle internalizeFromWorld: evt eventPosition))
		ifFalse: [ Color red muchLighter ]
		ifTrue: [ Color lightGray ].
	dismissHandle color: colorToUse! !
!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 5/27/2013 09:39' prior: 50352300!
           initialize
	super initialize.
	self color: Color black.
	font _ Preferences standardListFont.
	listItems _ #().
	selectedRow _ nil.
	selectedRows _ Set new.
	highlightedRow _ nil! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 10/16/2013 19:55' prior: 50352309!
                     debugDrawLineRectsOn: aCanvas
	"Shows where text line rectangles are"

	self textComposition lines do: [ :line |
		aCanvas
			frameRectangle: line rectangle
			borderWidth: 1
			color: Color brown ]
! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/17/2015 15:51' prior: 50352319!
                        initialize
	super initialize.
	extent _ 400@300.
	color _ Color white.
	grid _ 8@6.
	gridLineWidth _ 2.
	gridColor _ Color black.
	selectionColor _ Color red! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'bp 10/11/2015 23:18' prior: 50352328!
  mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	from _ self toGridPoint: localEventPosition.
	outlineMorph _ BorderedRectMorph new
		borderColor: Color black;
		color: Color transparent;
		openInWorld;
		hide.
	self selectTo: localEventPosition! !
!HoverHelpMorph methodsFor: 'initialization' stamp: 'jmv 9/25/2011 23:12' prior: 50352340!
                      defaultColor

	^Color r: 1.0 g: 1.0 b: 0.7! !
!HoverHelpMorph methodsFor: 'drawing' stamp: 'jmv 12/20/2014 15:09' prior: 50352345!
                             drawOn: aCanvas

	| r |
	r _ self morphLocalBounds.
	aCanvas roundRect: r color: self color radius: 4.
	aCanvas
		textComposition: textComposition
		bounds: (r insetBy: 4)
		color: Color black
		selectionColor: (Theme current textHighlightFocused: false)! !
!WorldState methodsFor: 'drawing' stamp: 'jmv 3/2/2017 19:40:12' prior: 50352356!
            drawInvalidAreasSubmorphs: submorphs
	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas that were redrawn."

	| initialRectsToRepair currentRectsToRepair newRectsToRepair morphsToDraw rectsForEachMorph thisMorphRects reuse i n morph morphBounds morphClipRect |

	"The simple implementation is slowers as it draws morph areas that will later be covered by other morphs.
	But it works, and it is easier to understand.
	See en.wikipedia.org/wiki/Painter's_algorithm"
	true not ifTrue: [ ^self simpleDrawInvalidAreasSubmorphs: submorphs ].

	"The response for #invalidRectsFullBounds: can include nils, that should be ignored."
	initialRectsToRepair _ damageRecorder invalidRectsFullBounds: world viewBox.
	damageRecorder reset.
	currentRectsToRepair _ OrderedCollection new.
	newRectsToRepair _ OrderedCollection withAll: initialRectsToRepair.
	morphsToDraw _ OrderedCollection new.
	rectsForEachMorph _ OrderedCollection new.
	thisMorphRects _ OrderedCollection new.
	n _ submorphs size.
	i _ 1.

	"The idea here is to iterate morphs front to back, i.e. first the ones on top.
	For each morph, record the rectangles it affects. And if a morph is opaque, remove the area behind it from the list of rectangles to be repaired.
	This means, for example, that morphs completely covered might even not be redrawn.
	this is a huge performance gain when there are many morphs on screen, especially if there are more than ten open windows, and Theme uses opaque colors.
	See 'A reverse painter's algorithm' at en.wikipedia.org/wiki/Painter's_algorithm"
	[ i <= n and: [ newRectsToRepair notEmpty ]] whileTrue: [
		morph _ submorphs at: i.
		morph visible ifTrue: [
			morphBounds _ morph morphFullBoundsInWorld.
			reuse _ currentRectsToRepair.
			currentRectsToRepair _ newRectsToRepair.
			newRectsToRepair _ reuse removeAll.
			currentRectsToRepair do: [ :r |
				(morphBounds intersects: r)
					ifTrue: [
						morphClipRect _ morphBounds intersect: r.
						thisMorphRects add: morphClipRect. "We could perhaps try and join adjacent rectangles in this collection..."
						morph addPossiblyUncoveredAreasIn: r to: newRectsToRepair ]
					ifFalse: [
						newRectsToRepair add: r ]].
			thisMorphRects ifNotEmpty: [
				morphsToDraw add: morph.
				rectsForEachMorph add: thisMorphRects.
				thisMorphRects _ OrderedCollection new.
			]].
		i _ i + 1 ].

	"*make this true to flash damaged areas for testing*"
	Preferences debugShowDamage ifTrue: [ world fillRects: initialRectsToRepair color: Color gray ].

	"Draw world background on those areas that were not completely covered by opaque morphs"
	i > n  ifTrue: [
		newRectsToRepair do: [ :r |
			world drawOn: (canvas newClipRect: r) ]].

	"Now, draw the recorded areas of selected morphs, back to front."
	morphsToDraw with: rectsForEachMorph reverseDo: [ :m :xrects |
		"Here we could think about merging all xrects into just one call...
		This would mean drawing each morph just once.
		But that would mean drawing pixels we were not told to. There could be other morphs in that area that are not even being drawn!!
		See WorldState class >> #experiment1"
"		rr _ nil."
		xrects do: [ :r |
"			rr _ rr ifNil: [ r ] ifNotNil: [ r quickMerge: rr ]."
			(canvas newClipRect: r) fullDraw: m.
		].
"		(canvas newClipRect: rr) fullDraw: m"
		"*make this true to flash damaged areas for testing*"
		Preferences debugShowDamage2 ifTrue: [
			world flashRects: xrects color: Color random ].
	].

	"Answer a list of rectangles to be updated on the Display.
	This usually is not performance critical, drawing morphs is slower than just exposing the Display."
	"What should we force on Display? Whatever was asked? Each small rect that was updated? A single bigger rect?
	Right now, answer whatever was asked... Maybe this could be changed if that enhances performance...
	(think of vnc over slow networks)"
	^ initialRectsToRepair! !
!WorldState class methodsFor: 'sample code' stamp: 'jmv 3/2/2017 19:39:21' prior: 50352482!
          experiment1
	"To play with and learn about morphic Display update logic.
	Remove the morphs when done!!"
	"
	WorldState experiment1
	"
	| dr morph1 morph2 s w |
	morph1 _ RectangleLikeMorph new openInWorld.
	morph2 _ RectangleLikeMorph new openInWorld.
	morph2 color: Color green.
	morph2 morphPosition: 200@800 extent: 50@40.
	morph1 morphPosition: 120@720 extent: 220@100.

	w _ self runningWorld.
	s _ w instVarNamed: 'worldState'.
	dr _ s instVarNamed: 'damageRecorder'.

	dr doFullRepaint.
	dr reset;
	"	recordInvalidRect: (100@700 corner: 400@900);"
		recordInvalidRect: (100@700 corner: 150@900);
		recordInvalidRect: (300@700 corner: 400@900).
	Display fillColor: Color gray.
	"Do not draw the area used by the small rectangle, unless it is also drawn!!"
	s drawInvalidAreasSubmorphs: {morph1. morph2 }! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 12/20/2014 15:35' prior: 50352511!
                              drawCurrentAsError
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	r _ currentMorph morphLocalBounds.
	w _ r extent > (50@50)
		ifTrue: [ 6 ]
		ifFalse: [ 2 ].
	self
		frameAndFillRectangle: r
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.
	self line: r topLeft to: r bottomRight-w width: w color: Color yellow.
	self line: r topRight -(w@0) to: r bottomLeft -(0@w)width: w color: Color yellow! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 6/1/2015 13:30' prior: 50352529!
 drawStringEmbossed: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: aColor
	"Answer last affected pixel position
	Answer nil if nothing was done"

	aColor = Color black ifFalse: [ | topColor |
		topColor _ aColor alphaMixed: 0.25 with: Color black.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint
			font: fontOrNil
			color: topColor ].
	aColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ aColor alphaMixed: 0.22 with: Color white.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint  + (0@2)
			font: fontOrNil
			color: bottomColor ].
	^self
		drawString: aString
		from: firstIndex
		to: lastIndex
		at: aPoint  + (0@1)
		font: fontOrNil
		color: aColor! !
!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 11/29/2015 18:01' prior: 50352556!
         fillRectangle: aRectangle color: aColor
	"Fill the given rectangle."

	aColor isTransparent ifFalse: [
		self 
			frameAndFillRectangle: aRectangle
			fillColor: aColor
			borderWidth: 0
			borderColor: Color transparent ]! !
!BitBltCanvas methodsFor: 'drawing-rectangles' stamp: 'jmv 11/29/2015 18:14' prior: 50352567!
reverseRectangleBorder: r borderWidth: borderWidth
	"
	Display getCanvas
		reverseRectangleBorder: (10@10 extent: 300@200)
		borderWidth: 20.
	Display forceToScreen
	"
	| rect |
	rect _ currentTransformation displayBoundsOfTransformOf: r.
	port
		sourceForm: nil;
		fillColor: Color gray;
		combinationRule: Form reverse;
		frameRect: rect borderWidth: borderWidth! !
!BitBltCanvas methodsFor: 'private' stamp: 'jmv 4/9/2015 09:46' prior: 50352582!
                               setPaintColor: aColor
	"Install a new color used for filling."
	| paintColor |
	paintColor _ aColor ifNil: [ Color transparent ].
	(paintColor is: #Color) ifFalse: [
		^self error: 'Cannot install color' ].

	"Okay, so paintColor really *is* a color"
	port sourceForm: nil.
	(paintColor isOpaque or: [ self depth < 32]) ifTrue: [
		port fillColor: paintColor.
		port combinationRule: Form paint.
		^self ].

	"BitBlt setup for alpha mapped transfer"
	port fillColor: paintColor.
	port combinationRule: Form blend! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 4/17/2015 12:16' prior: 50352602!
                               steButtonForm: extent
	^self cachedForms
		at: { #steButton . extent }
		ifAbsentPut: [
			| form canvas |
			form _ Form extent: extent depth: 32.
			canvas _ form getCanvas.
			canvas
				roundRect: (0@0 extent: extent)
				color: (Color gray: 0.4)
				radius: 4.
			canvas
				roundRect: (1@1 extent: extent-2)
				color: Color white
				radius: 4
				gradientTop: 1.0
				gradientCenter: 0.73
				gradientBottom: 0.94
				gradient1Height: (extent y-8+1 max: extent y//2).
			form]! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 4/17/2015 12:16' prior: 50352621!
                           verticalGrayGradient: height gradientTop: gradientTopFactor gradientBottom: gradientBottomFactor
	^self cachedForms
		at: { #vertical. height. gradientTopFactor . gradientBottomFactor }
		ifAbsentPut: [
			Form
				verticalGradient: height
				topColor: (Color gray: gradientTopFactor)
				bottomColor: (Color gray: gradientBottomFactor) ]! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 1/7/2015 08:12' prior: 50352635!
       buildArrowOfDirection: aSymbolDirection size: finalSizeInteger
	"PRIVATE - create an arrow with aSymbolDirectionDirection,  
	finalSizeInteger and aColor  
	 
	aSymbolDirectionDirection = #up, #down. #left or #right
	 (self buildArrowOfDirection: #down size: 120) display
	 (self buildArrowOfDirection: #up size: 120) display
	"

	| resizeFactor resizedForm f e c bottomMargin topMargin |
	resizeFactor _ 4.
	e _ finalSizeInteger@finalSizeInteger*resizeFactor.
	f _ Form extent: e depth: 32.
	c _ Color gray: 0.5.
	topMargin _ finalSizeInteger * 3//4.
	bottomMargin _ finalSizeInteger * 4//4.
	0 to: e y-1-bottomMargin do: [ :y |
		0 to: e x -1 do: [ :x |
			(e x / 2 - 1 - x) abs * 2 + topMargin < y ifTrue: [
				f colorAt: x@y put: c
			]
		]
	].
	resizedForm _ f
		magnify: f boundingBox
		by: 1 / resizeFactor
		smoothing: 4.

	aSymbolDirection == #right ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 90 ].
	aSymbolDirection == #down ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees: 180 ].
	aSymbolDirection == #left ifTrue: [
		resizedForm _ resizedForm rotatedByDegrees:  270 ].
		
	aSymbolDirection == #up ifFalse: [
		resizedForm _ resizedForm
			copy: (resizedForm boundingBox insetBy: (resizedForm width - finalSizeInteger/ 2.0) rounded) ].
		
	^resizedForm! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 10/9/2014 23:02' prior: 50352679!
                    buildArrowWith: insideForm borderForm: borderForm
	| extent translucentForm color insideSpec borderSpec border background alpha|
	"
	Display getCanvas
		image: (BitBltCanvas buildArrowWith: BitBltCanvas downInsideForm borderForm: BitBltCanvas downBorderForm)
		at: 20@20
	Display getCanvas
		image: (BitBltCanvas buildArrowWith:BitBltCanvas upInsideForm borderForm: BitBltCanvas upBorderForm)
		at: 40@20
	"
	extent _ insideForm extent - (1@2).
	translucentForm _ Form extent: insideForm extent depth: 32.
	0 to: extent x-1 do: [ :x |
		0 to: extent y-1 do: [ :y |
			insideSpec _ insideForm colorAt: x@(y+1).
			borderSpec _ borderForm colorAt: x@(y+1).
			insideSpec = (Color r: 0.0 g: 0.0 b: 1.0)
				ifTrue: [ color _ Color transparent ]
				ifFalse: [
					borderSpec = (Color r: 1.0 g: 0.0 b: 0.0)
						ifTrue: [ color _ insideSpec ]
						ifFalse: [
							border _ x < (extent x//2)
								ifTrue: [Color white]
								ifFalse: [Color black].
							background _ borderForm colorAt: extent x@(y+1).
							alpha _ borderSpec red asFloat - background red / (border red - background red).
							color _ border alpha: (alpha min: 1 max: 0) ]].
			translucentForm colorAt: x@y put: color ]].
	^translucentForm! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/19/2010 14:06' prior: 50352720!
                background
	^ Color r: 0.7 g: 0.72 b: 0.83! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/23/2010 09:42' prior: 50352724!
       buttonColorFrom: aColor
	^ Display depth <= 8
			ifTrue: [ Color transparent ]
			ifFalse: [ aColor paler ]! !
!Theme methodsFor: 'colors' stamp: 'jmv 3/14/2011 08:50' prior: 50352730!
       buttonLabel
	^Color gray: 0.18! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:38' prior: 50352734!
                     errorColor
	^ Color red lighter! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:40' prior: 50352738!
                    failureColor
	^ Color yellow lighter! !
!Theme methodsFor: 'colors' stamp: 'len 11/14/2015 02:34' prior: 50352742!
             scrollbarButtonColor
	^Color gray: 0.95! !
!Theme methodsFor: 'colors' stamp: 'len 11/17/2015 23:55' prior: 50352746!
          scrollbarColor
	^Color white! !
!Theme methodsFor: 'colors' stamp: 'len 11/14/2015 02:34' prior: 50352750!
                     scrollbarSliderShadowColor
	^Color white! !
!Theme methodsFor: 'colors' stamp: 'len 6/9/2016 17:38' prior: 50352754!
           successColor
	^ Color green lighter! !
!Theme methodsFor: 'colors' stamp: 'cbr 11/7/2010 18:00' prior: 50352758!
               text
	^ Color black! !
!Theme methodsFor: 'colors' stamp: 'jmv 10/16/2013 22:08' prior: 50352762!
                              textCursor
	^ Display depth <= 2
		ifTrue: [ Color black ]
		ifFalse: [ self text ]! !
!Theme methodsFor: 'colors' stamp: 'jmv 5/30/2011 14:31' prior: 50352768!
                               textHighlight
	"A nice light blue."
	"
	^ Color r: 0.71 g: 0.835 b: 1.0
	^ Color hue: 214 chroma: 0.29 luminance: 0.816
	"
	^Color hue: 204 chroma: 0.29 luminance: 0.77! !
!Theme methodsFor: 'colors' stamp: 'jmv 11/23/2010 09:58' prior: 50352776!
         textHighlightFocused: focused
	"A nice light blue."
	| textHighlight |
	Display depth = 1 ifTrue: [^ Color veryLightGray].
	Display depth = 2 ifTrue: [^ Color gray: 0.87].
	textHighlight _ self textHighlight.
	^focused
		ifTrue: [ textHighlight ]
		ifFalse: [ self unfocusedTextHighlightFrom: textHighlight ]! !
!Theme methodsFor: 'colors' stamp: 'cbr 12/6/2010 20:08' prior: 50352789!
                              windowLabel
	^Color gray: 0.3! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 5/26/2011 09:07' prior: 50352793!
                menu
	Display depth <= 2 ifTrue: [^ Color white].
	^Color r: 0.75 g: 0.75 b: 0.75 alpha: 0.93! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 11/23/2010 09:45' prior: 50352799!
               menuHighlight
	^ Display depth < 8
		ifTrue: [ Color veryLightGray ]
		ifFalse: [ self textHighlight ]! !
!Theme methodsFor: 'menu colors' stamp: 'cbr 11/7/2010 18:28' prior: 50352805!
       menuText
	^ Color black! !
!Theme methodsFor: 'menu colors' stamp: 'jmv 11/28/2010 08:04' prior: 50352809!
                     menuTitleBar
	Display depth = 1 ifTrue: [^ Color white].
	Display depth = 2 ifTrue: [^ Color gray].
	^ self menu darker! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 4/15/2011 14:59' prior: 50352816!
                      browser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.5 g: 0.7 b: 0.4]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 2/14/2013 11:05' prior: 50352823!
                              debugger
	^Color h: 0.0 s: 0.6 v: 0.7! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/23/2010 09:16' prior: 50352827!
       defaultWindowColor
	^ Color lightGray! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/18/2010 12:44' prior: 50352831!
       fileContentsBrowser
	^Color tan duller! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:44' prior: 50352835!
       fileList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.7 g: 0.55 b: 0.7 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 5/23/2012 19:23' prior: 50352842!
                           messageNames

	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.53 g: 0.77 b: 0.382 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:45' prior: 50352849!
                   messageSet
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.45 g: 0.6 b: 0.85 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/18/2010 12:44' prior: 50352856!
                       object
	^Color white duller! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/28/2012 09:41' prior: 50352860!
                  packageList
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.63 g: 0.47 b: 0.08 ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 11/23/2010 09:17' prior: 50352867!
                     testRunner
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ (Color r: 0.650 g: 0.753 b: 0.976) duller ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/16/2011 08:15' prior: 50352874!
           textEditor
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color gray: 0.6 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/4/2010 18:45' prior: 50352880!
     transcript
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color r: 0.8 g: 0.6 b: 0.3 ]! !
!Theme methodsFor: 'tool colors' stamp: 'cbr 12/18/2010 17:56' prior: 50352887!
                         versionsBrowser
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ (Color r: 0.869 g: 0.753 b: 1.0) duller ]! !
!Theme methodsFor: 'tool colors' stamp: 'jmv 3/16/2011 08:13' prior: 50352894!
        workspace
	^ self useUniformColors
		ifTrue: [ self defaultWindowColor ]
		ifFalse: [ Color h: 60.0 s: 0.73 v: 0.72 ]! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:49' prior: 50352901!
                      acceptButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.2 g: 0.6 b: 0.1 ])! !
!Theme methodsFor: 'widget colors' stamp: 'jmv 5/23/2012 18:51' prior: 50352909!
                        cancelButton

	^ self buttonColorFrom: 
		(self useUniformColors
			ifTrue: [ self defaultWindowColor ]
			ifFalse: [ Color r: 0.8 g: 0.2 b: 0.2 ])! !
!Theme methodsFor: 'widget colors' stamp: 'cbr 10/10/2012 23:36' prior: 50352917!
                       textPane
	^Color white! !
!SHTextStylerST80 class methodsFor: 'style table' stamp: 'pb 5/4/2016 17:44' prior: 50352921!
        initialTextAttributes
	| d element color emphasis attrArray |
	d _ IdentityDictionary new.
	self styleTable do: [ :each |
		element _ each first.
		color _ each at: 2 ifAbsent: nil.
		color _ color ifNotNil: [ Color colorFrom: color ].
		emphasis _ each at: 3 ifAbsent: nil.
		attrArray _ self attributeArrayForColor: color emphasis: emphasis.
		attrArray notEmpty ifTrue: [
			d at: element put: attrArray ]].
	^ d! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3111-ChangeReferencesBackToColor-JuanVuletich-2017Jun19-12h05m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3106] on 19 June 2017 at 11:52:30 am'!
!Colour methodsFor: 'transformations' stamp: 'jmv 6/19/2017 12:10:13' prior: 50352945!
                   * aNumber
	"Answer this color with its RGB multiplied by the given number. "
	"
	(Colour brown *2) display
	"
	^ (Color new
		setRed: (self red * aNumber min: 1.0 max: 0.0)
		green: (self green * aNumber min: 1.0 max: 0.0)
		blue: (self blue * aNumber min: 1.0 max: 0.0))
			alpha: self alpha! !

"Postscript:
Leave the line above, and replace the rest of this comment by a useful one.
Executable statements should follow this comment, and should
be separated by periods, with no exclamation points (!!).
Be sure to put any further comments in double-quotes, like this one."

| all |
all := Colour allInstances.
all elementsForwardIdentityTo: (all collect: [ :c | c * 1 ]).
all := TranslucentColour allInstances.
all elementsForwardIdentityTo: (all collect: [ :c | c * 1 ]).!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3112-MigrateInstancesToColor-JuanVuletich-2017Jun19-11h51m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3111] on 19 June 2017 at 12:11:51 pm'!

Smalltalk removeClassNamed: #Colour!

Smalltalk removeClassNamed: #Colour!

Smalltalk removeClassNamed: #TranslucentColour!

Smalltalk removeClassNamed: #TranslucentColour!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3113-RemoveColour-JuanVuletich-2017Jun19-12h11m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3113] on 19 June 2017 at 3:22:14 pm'!

InnerPluggableMorph subclass: #InnerListMorph
	instanceVariableNames: 'listItems font selectedRow selectedRows highlightedRow '
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #InnerListMorph category: #'Morphic-Views'!
InnerPluggableMorph subclass: #InnerListMorph
	instanceVariableNames: 'listItems font selectedRow selectedRows highlightedRow'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!
!InnerListMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:21:44' prior: 50360533!
       initialize
	super initialize.
	self color: Color black.
	font _ Preferences standardListFont.
	listItems _ #().
	selectedRow _ nil.
	highlightedRow _ nil! !
!InnerListMorph methodsFor: 'list management' stamp: 'jmv 6/19/2017 15:21:40' prior: 16855089!
    listChanged
	"set newList to be the list of strings to display"
	listItems _ Array new: self getListSize withAll: nil.
	selectedRow _ nil.
	self adjustExtent! !
!InnerListMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 15:21:48' prior: 16855308!
        noSelection
	selectedRow _ nil.
	highlightedRow _ nil! !

InnerPluggableMorph subclass: #InnerListMorph
	instanceVariableNames: 'listItems font selectedRow highlightedRow'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

!classDefinition: #InnerListMorph category: #'Morphic-Views'!
InnerPluggableMorph subclass: #InnerListMorph
	instanceVariableNames: 'listItems font selectedRow highlightedRow'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Views'!

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3114-removeAnUnusedIvar-JuanVuletich-2017Jun19-15h21m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3113] on 19 June 2017 at 4:40:20 pm'!
!Object methodsFor: 'private' stamp: 'jmv 6/19/2017 16:14:39' prior: 16882717!
                       primitiveError: aString 
	"This method is called when the error handling results in a recursion in 
	calling on error: or halt or halt:."

	| context emergencyEvaluator lines r |
	r _ `10@10` extent: (Display extent -20 min: `700@1000`).
	lines _ r height // AbstractFont default height.
	emergencyEvaluator _ Transcripter newInFrame: r.
	emergencyEvaluator
		nextPutAll: '***System error handling failed***'; newLine;
		nextPutAll: aString; newLine;
		nextPutAll: '-------------------------------'; newLine.
	context _ thisContext sender sender.
	(30 min: lines - 10) timesRepeat: [context ifNotNil: [emergencyEvaluator print: (context _ context sender); newLine]].
	emergencyEvaluator
		nextPutAll: '-------------------------------'; newLine;
		nextPutAll: 'Type ''revert'' to revert your last method change.'; newLine;
		nextPutAll: 'Type ''exit'' to exit the emergency evaluator.'; newLine.
	emergencyEvaluator readEvalPrint! !
!InputSensor methodsFor: 'private' stamp: 'jmv 6/19/2017 15:53:29' prior: 16856661!
        primMousePt
	"Primitive. Poll the mouse to find out its position. Return a Point. Fail if
	event-driven tracking is used instead of polling. Optional. See Object
	documentation whatIsAPrimitive."

	<primitive: 90>
	^ `0@0`! !
!EventSensor methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:48:40' prior: 16839804!
   initialize
	"Run the I/O process"
	mouseButtons _ 0.
	mousePosition _ `0@0`.
	self setInterruptKey: (interruptKey ifNil: [$. numericValue bitOr: 16r0800 ]). 	"cmd-."
	interruptSemaphore _ (Smalltalk specialObjectsArray at: 31) ifNil: [Semaphore new].
	self flushAllButDandDEvents.
	inputSemaphore _ Semaphore new.
	hasInputSemaphore _ false.

	self primSetInputSemaphore: (Smalltalk registerExternalObject: inputSemaphore).
	self installInterruptWatcher.
	self installEventTickler.
	self flushAllButDandDEvents.

	"Attempt to discover whether the input semaphore is actually being signaled."
	hasInputSemaphore _ false.
	inputSemaphore initSignals! !
!String methodsFor: 'displaying' stamp: 'jmv 6/19/2017 16:12:23' prior: 16917029!
   displayOn: aDisplayMedium
	"Display the receiver on the given DisplayMedium.  5/16/96 sw"

	self displayOn: aDisplayMedium at: `0 @ 0`! !
!Bitmap methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 15:45:57' prior: 16787594!
                           asByteArray
	"Faster way to make a byte array from me.
	copyFromByteArray:, if receiver is BigEndian makes equal Bitmap.
	Assume receiver bytes-in-word mapping is BigEndian:
		Most significant bye of first word in self goes to first position in result.
	This means that for a BigEndian 8bpp Form, pixels are in the right order in the ByteArray
	
	Form lena asGrayForm bits asByteArray copyFrom: 1 to: 4.
	(Form lena asGrayForm asFormOfDepth: 8) bits asByteArray copyFrom: 1 to: 4.
	(0 to: 3) collect: [ :x | ((Form lena asGrayForm colorAt: x@0) luminance * 255) rounded ].
	"
	| f bytes hack |
	f _ Form extent: 4@self size depth: 8 bits: self.
	bytes _ ByteArray new: self size * 4.
	hack _ Form new hackBits: bytes.
	Smalltalk isLittleEndian ifTrue: [hack swapEndianness].
	hack copyBits: f boundingBox
		from: f
		at: `0@0`
		clippingBox: hack boundingBox
		rule: Form over.

	"f displayOn: hack."
	^ bytes! !
!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jmv 6/19/2017 16:12:37' prior: 50335423!
            snapshot: save andQuit: quit embedded: embeddedFlag clearAllClassState: clearAllStateFlag
"WARNING: Current process will be killed.
UI Process will be restarted
"
	"Mark the changes file and close all files as part of #processShutdownList.
	If save is true, save the current state of this Smalltalk in the image file.
	If quit is true, then exit to the outer OS shell.
	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."
	"
	To test the full cleanup and startup procedures, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: true

	To test the cleanup done when saving the image, evaluate:
		Smalltalk snapshot: false andQuit: false embedded: false clearAllClassState: false
	"
| activeProc |
activeProc _ Processor activeProcess.
[ 
	| isARealStartup world reopenTranscript |
	self logSapshot: save andQuit: quit.

	reopenTranscript _ false.
	clearAllStateFlag ifTrue: [
		TranscriptWindow allInstancesDo: [ :each | each isInWorld ifTrue: [ each delete. reopenTranscript _ true ]].
		Transcript logToFile: false ].
	ActiveModel flushEventSystem.
	self processShutDownList: quit.


	"Lo que sigue aca podria ir al shutdown de alguien... (se levantan en startup!!)"
	Smalltalk stopLowSpaceWatcher.
	WeakArray stopFinalizationProcess.
	ProcessorScheduler stopBackgroundProcess.
	
	"Cosas que levanto explicitamente abajo"
	world _ ProjectX ui.
	"Replace with this to create a new world at startup after 'saveAsNewVersion'"
	"world _ clearAllStateFlag ifFalse: [ ProjectX ui ]."
	ProjectX stopUIProcess.
	activeProc isTerminated ifFalse: [
		activeProc terminate ].

	"Clean Globals"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: nil.
	Smalltalk closeSourceFiles. Smalltalk at: #SourceFiles put: nil.
	Smalltalk allClassesDo: [ :cls | cls releaseClassCachedState ].
	clearAllStateFlag ifTrue: [	
		Smalltalk allClassesDo: [ :cls | cls releaseClassState ]].
	"Ojo con los pool dicts. Creo que no hay ninguno..."
	
	"To keep cleaning stuff that shouldn't be saved..."
	clearAllStateFlag ifTrue: [ Smalltalk printStuffToCleanOnImageSave ].


	"Do image save & quit as apropriate"
	Cursor write activateCursor.
	save
		ifTrue: [
			isARealStartup _ embeddedFlag
				ifTrue: [ self snapshotEmbeddedPrimitive ]
				ifFalse: [ self snapshotPrimitive ]]
		ifFalse: [ isARealStartup _ false ].
	quit & (isARealStartup == false) ifTrue: [ self quitPrimitive ].


	"If starting from absolute scratch, this would be a good time to recreate Global names"
	Smalltalk at: #Sensor put: nil.
	Smalltalk at: #Display put: (DisplayScreen extent: `1024@768` depth: 32).
	Smalltalk at: #SourceFiles put: (Array new: 2).
	Smalltalk openSourceFiles.

	"Here, startup begins!! (isARealStartup might be nil)"
	Smalltalk allClassesDo: [ :cls | cls initClassCachedState ].
	self doStartUp: isARealStartup == true.
	
	
	ProjectX spawnNewMorphicProcessFor: (world ifNil: [ PasteUpMorph newWorld ]).

	reopenTranscript ifTrue: [
		WorldState addDeferredUIMessage: [
			TranscriptWindow openTranscript ]].
	"
	WorldState addDeferredUIMessage: [
		world fullRepaintNeeded ].
	"

	"If system is coming up (VM and image just started)"
	isARealStartup == true ifTrue: [	
		WorldState addDeferredUIMessage: [
			self processCommandLineArguments.
			AppLauncher launchApp ]].

	"Now it's time to raise an error"
	isARealStartup ifNil: [ self error: 'Failed to write image file (disk full?)' ].

] forkAt: Processor timingPriority-1 named: 'Startup process'.! !
!Transcripter methodsFor: 'accessing' stamp: 'jmv 6/19/2017 16:13:36' prior: 50357755!
                  endEntry
	| c d cb |
	c _ self contents.
	Display extent ~= DisplayScreen actualScreenSize ifTrue: [
		"Handle case of user resizing physical window"
		DisplayScreen startUp.
		frame _ frame intersect: Display boundingBox.
		^ self clear; show: c].
	textComposition
		setModel: (TextModel withText: c asText);
		extentForComposing: frame width-8 @9999.
	textComposition composeAll.
	d _ textComposition usedHeight - frame height.
	d > 0 ifTrue: [
		"Scroll up to keep all contents visible"
		cb _ textComposition characterBlockAtPoint:
			`0@0` + (0@(d+AbstractFont default height)).
		self on: (c copyFrom: cb stringIndex to: c size).
		readLimit _ position _ collection size.
		^ self endEntry].
	Display fill: (frame insetBy: -2) fillColor: self black;
			fill: frame fillColor: self white.
	Display getCanvas
		textComposition: textComposition
		bounds: (`4@4` + frame topLeft extent: Display extent)
		color: Color black
		selectionColor: Color blue.
	DisplayScreen screenUpdateRequired: nil! !
!Transcripter class methodsFor: 'utilities' stamp: 'jmv 6/19/2017 15:58:42' prior: 16938949!
                           emergencyEvaluator
	(Transcripter newInFrame: `0@0 corner: 320@200`)
		show: 'Type ''exit'' to exit the emergency evaluator.';
		readEvalPrint! !
!ProgressInitiationException methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:15:27' prior: 50342779!
                              defaultAction

	| delta textFrame barFrame outerFrame result range width filledWidth f h textWidth textForm innerBarFrame oldFilledWidth oldFilledWidth2 prevContents |
	f _ AbstractFont default.
	h _ f height * 3//2.
	textWidth _ (f widthOfString: progressTitle) + h.
	width _ 150 max: textWidth.

	textForm _ Form extent: width@h depth: 32.
	textForm fillBlack.
	textForm fillWhite: (textForm boundingBox insetBy: 2).
	progressTitle displayOn: textForm at: (width-textWidth+h//2@4).
	barFrame _ Rectangle center: aPoint extent: width@h.
	textFrame _ `0@0` extent: width@h.
	textFrame _ textFrame
					aligned: textFrame bottomCenter
					with: barFrame topCenter + `0@2`.
	outerFrame _ barFrame merge: textFrame.
	delta _ outerFrame amountToTranslateWithin: Display boundingBox.
	barFrame _ barFrame translatedBy: delta.
	textFrame _ textFrame translatedBy: delta.
	outerFrame _ outerFrame translatedBy: delta.
	prevContents _ Form fromDisplay: outerFrame.
	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"
	innerBarFrame _ barFrame insetBy: 2.
	textForm displayAt: textFrame topLeft.
	Display fillBlack: barFrame.
	Display fillWhite: innerBarFrame.
	oldFilledWidth _ 0.
	oldFilledWidth2 _ 0.
	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"
		[ :barVal |
		barVal
			ifNotNil: [ currentVal _ barVal ]
			ifNil: [
				currentVal _ currentVal + 1.
				currentVal >= maxVal
					ifTrue: [ currentVal _ minVal ]].
		filledWidth _ ((barFrame width-4) asFloat * ((currentVal-minVal) asFloat / range min: 1.0)) asInteger.
		filledWidth  > oldFilledWidth ifTrue: [
			textForm displayAt: textFrame topLeft.
			Display fillBlack: barFrame.
			Display fillWhite: innerBarFrame.
			Display fillGray: (barFrame topLeft + `2@2` extent: filledWidth@17).
			filledWidth -200 > oldFilledWidth2
				ifFalse: [
					"Usually just request an update, to be done asynchronously."
					DisplayScreen screenUpdateRequired: outerFrame ]
				ifTrue: [
					"Once in a while, force a real screen update (warning: really slow on MacOS if done too often)"
					Display forceToScreen: outerFrame. oldFilledWidth2 _ filledWidth ].
			oldFilledWidth _ filledWidth ]].
	prevContents displayAt: outerFrame topLeft.
	self resume: result! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:10:37' prior: 16898287!
           staggerOffset
	^`6 @ 20`! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:10:46' prior: 16898320!
                          standardWindowExtent
	"Answer the standard default extent for new windows.  "

	| effectiveExtent width strips height grid allowedArea maxLevel |
	effectiveExtent _ self maximumUsableArea extent
					- (self scrollBarSetback @ self screenTopSetback).
	Preferences reverseWindowStagger ifTrue:
		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"
		allowedArea _ self maximumUsableArea insetBy: (
			self scrollBarSetback @ self screenTopSetback extent: `0@0`
		).
		"Number to be staggered at each corner (less on small screens)"
		maxLevel _ allowedArea area > 700000 ifTrue: [3] ifFalse: [2].
		"Amount by which to stagger (less on small screens)"
		grid _ allowedArea area > 700000 ifTrue: [40] ifFalse: [20].
		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: `52@40` * Preferences standardCodeFont height ].
	width _ (strips _ self windowColumnsDesired) > 1
		ifTrue:
			[effectiveExtent x // strips]
		ifFalse:
			[(3 * effectiveExtent x) // 4].
	height _ (strips _ self windowRowsDesired) > 1
		ifTrue:
			[effectiveExtent y // strips]
		ifFalse:
			[(3 * effectiveExtent y) //4].
	^ width @ height

"RealEstateAgent standardWindowExtent"! !
!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:10:58' prior: 16898360!
                            strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld 
	"This method implements a staggered window placement policy that I (di) like.
	Basically it provides for up to 4 windows, staggered from each of the 4 corners.
	The windows are staggered so that there will always be a corner visible."

	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |
	allowedArea := (self maximumUsableAreaInWorld: aWorld) 
				insetBy: (self scrollBarSetback @ self screenTopSetback extent: `0 @ 0`).
	"Number to be staggered at each corner (less on small screens)"
	maxLevel := allowedArea area > 300000 ifTrue: [3] ifFalse: [2].
	"Amount by which to stagger (less on small screens)"
	grid := allowedArea area > 500000 ifTrue: [40] ifFalse: [20].
	initialFrame := `0 @ 0` extent: initialExtent.
	"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))
							min: 600@400"
	otherFrames := (SystemWindow windowsIn: aWorld satisfying: [ :w | w visible and: [w isCollapsed not]]) 
						collect: [:w | w morphBoundsInWorld].
	otherFrames _ otherFrames reject: [ :f | f isNil ].
	0 to: maxLevel do: [ :level | 
			1 to: 4 do: [:ci | 
					cornerSel := #(#topLeft #topRight #bottomRight #bottomLeft) at: ci.
					corner := allowedArea perform: cornerSel.
					"The extra grid//2 in delta helps to keep title tabs distinct"
					delta := ((maxLevel - level) * grid + (grid // 2)) @ (level * grid).
					1 to: ci - 1 do: [ :i | delta _ delta y negated @ delta x ].	"slow way"
					putativeCorner := corner + delta.
					free := true.
					otherFrames do: [ :w |
						free := free & ((w perform: cornerSel) ~= putativeCorner)].
					free 
						ifTrue: [
							^(initialFrame aligned: (initialFrame perform: cornerSel)
								with: putativeCorner) translatedAndSquishedToBeWithin: allowedArea]]].
	"If all else fails..."
	^(self scrollBarSetback @ self screenTopSetback 
		extent: initialFrame extent) translatedAndSquishedToBeWithin: allowedArea! !
!Form methodsFor: 'accessing' stamp: 'jmv 6/19/2017 15:50:37' prior: 16846782!
           offset
	^offset ifNil:[`0@0`]! !
!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:51:14' prior: 16846919!
                primCountBits
	"Count the non-zero pixels of this form."
	self depth > 8 ifTrue:
		[^(self asFormOfDepth: 8) primCountBits].
	^ (BitBlt toForm: self)
		fillColor: (Bitmap with: 0);
		destRect: (`0@0` extent: width@height);
		combinationRule: 32;
		copyBits! !
!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:51:36' prior: 16846929!
             tallyPixelValuesInRect: destRect into: valueTable
	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."

	(BitBlt toForm: self)
		sourceForm: self;  "src must be given for color map ops"
		sourceOrigin: `0@0`;
		colorMap: valueTable;
		combinationRule: 33;
		destRect: destRect;
		copyBits.
	^ valueTable

"
Move a little rectangle around the screen and print its tallies...
 | r tallies nonZero |
Cursor blank showWhile: [
[Sensor isAnyButtonPressed] whileFalse:
	[r _ Sensor mousePoint extent: 10@10.
	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.
	tallies _ (Display copy: r) tallyPixelValues.
	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]
			thenCollect: [:i | (tallies at: i) -> (i-1)].
	Display fill: (0@0 extent: Display width@20) fillColor: Color white.
	nonZero printString , '          ' displayAt: 0@0.
	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]
"! !
!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:51:54' prior: 16846963!
                   xTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by x-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice countBlt copyBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: 1@height.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: 1 @ slice height
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap with: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	^ (0 to: width-1) collect:
		[:x |
		copyBlt sourceOrigin: x@0; copyBits.
		countBlt copyBits]! !
!Form methodsFor: 'analyzing' stamp: 'jmv 6/19/2017 15:52:04' prior: 16846991!
                     yTallyPixelValue: pv orNot: not
	"Return an array of the number of pixels with value pv by y-value.
	Note that if not is true, then this will tally those different from pv."
	| cm slice copyBlt countBlt |
	cm _ self newColorMap.		"Map all colors but pv to zero"
	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"
	cm at: pv+1 put: 1 - (cm at: pv+1).
	slice _ Form extent: width@1.
	copyBlt _ (BitBlt destForm: slice sourceForm: self
				combinationRule: Form over
				destOrigin: `0@0` sourceOrigin: `0@0` extent: slice width @ 1
				clipRect: slice boundingBox)
					colorMap: cm.
	countBlt _ (BitBlt toForm: slice)
				fillColor: (Bitmap with: 0);
				destRect: (`0@0` extent: slice extent);
				combinationRule: 32.
	^ (0 to: height-1) collect:
		[:y |
		copyBlt sourceOrigin: 0@y; copyBits.
		countBlt copyBits]! !
!Form methodsFor: 'coloring' stamp: 'jmv 6/19/2017 15:50:16' prior: 16847123!
                       fillShape: aShapeForm fillColor: aColor
	"Fill a region corresponding to 1 bits in aShapeForm with aColor"

	^ self fillShape: aShapeForm fillColor: aColor at: `0@0`! !
!Form methodsFor: 'coloring' stamp: 'jmv 6/19/2017 15:50:23' prior: 16847131!
         fillShape: aShapeForm fillColor: aColor at: location
	"Fill a region corresponding to 1 bits in aShapeForm with aColor"

	((BitBlt destForm: self sourceForm: aShapeForm fillColor: aColor
		combinationRule: Form paint
		destOrigin: location + aShapeForm offset sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))
		copyBits! !
!Form methodsFor: 'color mapping' stamp: 'jmv 6/19/2017 15:50:33' prior: 50358105!
     mapColor: oldColor to: newColor
	"Make all pixels of the given color in this Form to the given new color."
	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."

	| map |
	map _ (Color cachedColormapFrom: self depth to: self depth) copy.
	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: self depth).
	(BitBlt toForm: self)
		sourceForm: self;
		sourceOrigin: `0@0`;
		combinationRule: Form over;
		destX: 0 destY: 0 width: width height: height;
		colorMap: map;
		copyBits.
! !
!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:08' prior: 16847321!
           asFormOfDepth: d
	| newForm source |
	d = depth ifTrue: [ ^self ].
	source _ (self depth = 32 and: [ d abs < 32 ])
		ifTrue: [ self copy convertAlphaToZeroValueTransparency ]
		ifFalse: [ self ].
	newForm _ Form extent: source extent depth: d.
	(BitBlt toForm: newForm)
		colorMap: (source colormapIfNeededFor: newForm);
		copy: source boundingBox
		from: `0@0` in: source
		fillColor: nil rule: Form over.
	"If we build a 32bpp from one of smaller depth,
	it will have zero in the alpha channel (until BitBlt is fixed!!)"
	(newForm depth = 32 and: [self depth < 32]) ifTrue: [
		newForm fixAlpha ].
	^newForm! !
!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:12' prior: 16847342!
           asGrayForm
	| answer map |

	"For lower bit depths, the 15 bit ColorMap loses no information,
	and answers the real #luminance of each pixel."
	self depth < 32 ifTrue: [
		answer _ GrayForm extent: width@height.
		map _ self colormapIfNeededForGray8bpp.
		(BitBlt toForm: answer)
			colorMap: map;
			copy: self boundingBox
			from: `0@0` in: self
			fillColor: nil rule: Form over.
		answer offset: self offset.
		^ answer ].

	"For 32bpp, the approach below would use just 5bits per component.
	Generally it is best to extract a component in full 8bpp and keep full dynamic range.
	Green usually is a good choice."
	^ self asGrayForm: 3! !
!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:19' prior: 16847364!
              asGrayForm: componentIndex
"Native depth"
	"Assume the receiver is a grayscale image. Return a GrayForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit GrayForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)

	If component = 1, take the alpha component
	If component = 2, take the red component
	If component = 3, take the green component
	If component = 4, take the blue component
	"
	| f32 result map mask shift |
	self depth = 32 ifFalse: [
		f32 _ Form extent: width@height depth: 32.
		self displayOn: f32.
		^ f32 asGrayForm: componentIndex ].
	
	result _ GrayForm extent: width@height.
	shift _ #(-24 -16 -8 0) at: componentIndex.
	mask _ #(16rFF000000 16rFF0000 16rFF00 16rFF) at: componentIndex.
	map _ ColorMap masks: { mask. 0. 0. 0 } shifts: { shift. 0. 0. 0 }.
	(BitBlt toForm: result)
		sourceForm: self;
		combinationRule: Form over;
		colorMap: map;
		sourceRect: (`0@0` extent: width@height);
		destOrigin: `0@0`;
		copyBits.
	^ result! !
!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:49:38' prior: 16847425!
                       asGrayScaleAndTransparent: componentIndex
"Native depth"
	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)

	If component = 1, take the alpha component
	If component = 2, take the red component
	If component = 3, take the green component
	If component = 4, take the blue component
	"
	| f32 result map mask shift |
	self depth = 32 ifFalse: [
		f32 _ Form extent: width@height depth: 32.
		self displayOn: f32.
		^ f32 asGrayScaleAndTransparent: componentIndex ].

	result _ ColorForm grayScaleAndTransparentExtent: width@height.
	shift _ #(-24 -16 -8 0) at: componentIndex.
	mask _ #(16rFF000000 16rFF0000 16rFF00 16rFF) at: componentIndex.
	map _ ColorMap masks: { mask. 0. 0. 0 } shifts: { shift. 0. 0. 0 }.
	(BitBlt toForm: result)
		sourceForm: self;
		combinationRule: Form over;
		colorMap: map;
		sourceRect: (`0@0` extent: width@height);
		destOrigin: `0@0`;
		copyBits.

	"final BitBlt to zero-out pixels that were truely transparent in the original"
	map _ Bitmap new: 512.
	map at: 1 put: 16rFF.
	(BitBlt toForm: result)
		sourceForm: self;
		sourceRect: self boundingBox;
		destOrigin: `0@0`;
		combinationRule: Form erase;
		colorMap: map;
		copyBits.
	^ result! !
!Form methodsFor: 'converting' stamp: 'jmv 6/19/2017 16:04:17' prior: 16847525!
                        icon
	"Answer a 16 x 16 icon of myself"
	
	^self magnifyTo: `16 @ 16`! !
!Form methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:49:47' prior: 16847584!
          contentsOfArea: aRect into: newForm
 	"Return a new form which derives from the portion of the original form delineated by aRect."
	^ newForm copyBits: aRect from: self at: `0@0`
		clippingBox: newForm boundingBox rule: Form over! !
!Form methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:49:55' prior: 16847594!
          copy: aRect
 	"Return a new form which derives from the portion of the original form delineated by aRect."
	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	^ newForm copyBits: aRect from: self at: `0@0`
		clippingBox: newForm boundingBox rule: Form over! !
!Form methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:50:02' prior: 16847621!
                            copyBits: sourceForm at: destOrigin translucent: factor
	"Make up a BitBlt table and copy the bits with the given colorMap."
	(BitBlt 
		destForm: self
		sourceForm: sourceForm
		combinationRule: 30
		destOrigin: destOrigin
		sourceOrigin: `0@0`
		extent: sourceForm extent
		clipRect: self boundingBox)
			copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)
"
 | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.
0.0 to: 1.0 by: 1.0/32 do:
	[:t | f3 _ f2 copy. f3 copyBits: f at: 0@0 translucent: t.
	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait].
"! !
!Form methodsFor: 'display box access' stamp: 'jmv 6/19/2017 16:04:01' prior: 16847674!
boundingBox
	^ Rectangle
		origin: `0 @ 0`
		corner: width @ height! !
!Form methodsFor: 'displaying' stamp: 'jmv 6/19/2017 15:51:05' prior: 16847690!
         paintBits: sourceForm at: destOrigin translucent: factor
	"Make up a BitBlt table and copy the bits with the given colorMap."
	(BitBlt destForm: self
		sourceForm: sourceForm
		combinationRule: 31
		destOrigin: destOrigin
		sourceOrigin: `0@0`
		extent: sourceForm extent
		clipRect: self boundingBox)
			copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)
"
 | f f2 f3 | f _ Form fromUser. f replaceColor: f dominantColor withColor: Color transparent.
f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 copy.
0.0 to: 1.0 by: 1.0/32 do:
	[:t | f3 _ f2 copy. f3 paintBits: f at: 0@0 translucent: t.
	f3 displayAt: 0@0. (Delay forMilliseconds: 100) wait].
"! !
!Form methodsFor: 'displaying-generic' stamp: 'jmv 6/19/2017 16:04:09' prior: 16847730!
   displayOn: aDisplayMedium
	"Simple default display in order to see the receiver in the upper left 
	corner of screen."

	self displayOn: aDisplayMedium at: `0 @ 0`! !
!Form methodsFor: 'filling' stamp: 'jmv 6/19/2017 15:50:07' prior: 16847937!
            eraseShape: bwForm
	"use bwForm as a mask to clear all pixels where bwForm has 1's"
	((BitBlt destForm: self sourceForm: bwForm
		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"
		destOrigin: bwForm offset 
		sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox)
		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))
		copyBits.
! !
!Form methodsFor: 'filling' stamp: 'jmv 6/19/2017 15:50:12' prior: 16847951!
                              fill: aRectangle rule: anInteger fillColor: aForm 
	"Replace a rectangular area of the receiver with the pattern described by aForm 
	according to the rule anInteger."
	(BitBlt toForm: self)
		copy: aRectangle
		from: `0@0` in: nil
		fillColor: aForm rule: anInteger! !
!Form methodsFor: 'image manipulation' stamp: 'jmv 6/19/2017 15:51:26' prior: 16848014!
                          smear: dir distance: dist
	"Smear any black pixels in this form in the direction dir in Log N steps"
	| skew bb |
	bb _ BitBlt destForm: self sourceForm: self
		combinationRule: Form under destOrigin: `0@0` sourceOrigin: `0@0`
		extent: self extent clipRect: self boundingBox.
	skew _ 1.
	[skew < dist] whileTrue:
		[bb destOrigin: dir*skew; copyBits.
		skew _ skew+skew]! !
!Form methodsFor: 'transitions' stamp: 'jmv 6/19/2017 15:50:50' prior: 50358230!
                        pageWarp: otherImage at: topLeft forward: forward
	"Produce a page-turning illusion that gradually reveals otherImage
	located at topLeft in this form.
	forward == true means turn pages toward you, else away. [ignored for now]"
	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |
	pageRect _ otherImage boundingBox.
	oldPage _ self copy: (pageRect translatedBy: topLeft).
	(forward ifTrue: [oldPage] ifFalse: [otherImage])
		border: pageRect
		widthRectangle: (Rectangle
				left: 0
				right: 2
				top: 1
				bottom: 1)
		rule: Form over
		fillColor: Color black.
	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).
	nSteps _ 8.
	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.
	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.
	1 to: nSteps-1 do:
		[:i | forward
			ifTrue: [buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
					p _ pageRect topRight + (d * i // nSteps)]
			ifFalse: [buffer copy: pageRect from: oldPage to: `0@0` rule: Form over.
					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].
		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).
		sourceQuad _ Array with: pageRect topLeft
			with: pageRect bottomLeft + (0@p y)
			with: pageRect bottomRight
			with: pageRect topRight - (0@p y).
		warp _ (WarpBlt toForm: buffer)
				clipRect: leafRect;
				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);
				combinationRule: Form paint.
		warp copyQuad: sourceQuad toRect: leafRect.
		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
		Display forceToScreen.
		].

	buffer copy: pageRect from: otherImage to: `0@0` rule: Form over.
	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.
	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.
	Display forceToScreen.
"
1 to: 4 do: [:corner | Display pageWarp:
				(Form fromDisplay: (10@10 extent: 200@300)) reverse
			at: 10@10 forward: false]
"
! !
!Form methodsFor: 'private' stamp: 'jmv 6/19/2017 16:04:06' prior: 16848740!
                     copyFromByteArray: bigEndianByteArray
	"This method should work with either byte orderings.
	See comment at Bitmap>>#asByteArray
	Also see #copyFromByteArray2:to:"

	| myHack byteHack |
	myHack := Form new hackBits: bits.
	byteHack := Form new hackBits: bigEndianByteArray.
	"We are passing a ByteArray instead of a Words object. Will be accessed according to native endianness."
	Smalltalk isLittleEndian = self isLittleEndian ifFalse: [byteHack swapEndianness].
	byteHack displayOn: myHack at: `0 @ 0` rule: Form over! !
!Form methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:04:13' prior: 16848849!
 fromDisplay: aRectangle 
	"Create a virtual bit map from a user specified rectangular area on the 
	display screen. Reallocates bitmap only if aRectangle ~= the receiver's 
	extent."

	(width = aRectangle width and: [height = aRectangle height])
		ifFalse: [self setExtent: aRectangle extent depth: depth].
	self
		copyBits: (aRectangle origin extent: self extent)
		from: Display
		at: `0 @ 0`
		clippingBox: self boundingBox
		rule: Form over! !
!Form methodsFor: 'encoding' stamp: 'jmv 6/19/2017 15:49:02' prior: 16848870!
                  addDeltasFrom: previousForm

	(BitBlt 
		destForm: self 
		sourceForm: previousForm 
		fillColor: nil 
		combinationRule: Form reverse
		destOrigin: `0@0`
		sourceOrigin: `0@0`
		extent: self extent 
		clipRect: self boundingBox) copyBits.
	^self! !
!Form class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 16:37:08' prior: 50358301!
         dotOfSize: diameter
	"Create a form which contains a round black dot."
	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |
	radius _ diameter//2.
	form _ self extent: diameter@diameter offset: `0@0` - radius.
	bb _ (BitBlt toForm: form)
		sourceX: 0; sourceY: 0;
		combinationRule: Form over;
		fillColor: Color black.
	rect _ form boundingBox.
	centerX _ rect center x.
	centerY _ rect center y.
	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].
	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].
	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.
	xOverY _ rect width asFloat / rect height asFloat.
	maxy _ rect height - 1 // 2.

	"First do the inner fill, and collect x values"
	0 to: maxy do:
		[:dy |
		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.
		bb	destX: centerX - centerXBias - dx
			destY: centerY - centerYBias - dy
			width: dx + dx + centerXBias + 1
			height: 1;
			copyBits.
		bb	destY: centerY + dy;
			copyBits].
	^ form
"
Time millisecondsToRun:
	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]
"! !
!Form class methodsFor: 'examples' stamp: 'jmv 6/19/2017 16:04:23' prior: 50358363!
      toothpaste: diam	
	"
	Display restoreAfter: [Form toothpaste: 30]
	"
	"Not completely unlike the ST-80 implementation :)
	Original comment:
	Draws wormlike lines by laying down images of spheres.
	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.
	Draw with mouse button down; terminate by option-click."
	| point queue color q colors colr colr2 |
	colors _ Color red wheel: 12.
	color _ 8.
	[ true ] whileTrue: [
		queue _ OrderedCollection new: 32.
		16 timesRepeat: [queue addLast: `-40@-40`].
		Sensor waitButton.
		Sensor isMouseButton2Pressed ifTrue: [^ self].
		point _ Sensor mousePoint.
		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"
		colr2 _ colr alpha: 0.3.
		[Sensor isMouseButton1Pressed or: [queue size > 0]] whileTrue: [
			point _ point * 4 + Sensor mousePoint // 5.
			point _ point.
			Form fakeSphereAt: point diameter: diam color: colr.
			(q _ queue removeFirst) ifNil: [^ self].	"exit"
			Form fakeSphereAt: q diameter: diam color: colr2.
			Sensor isMouseButton1Pressed ifTrue: [queue addLast: point]]]! !
!ColorForm methodsFor: 'color manipulation' stamp: 'jmv 6/19/2017 15:47:08' prior: 16818811!
    asGrayForm
	"Build an optimal GrayForm,
	for any color palette in the receiver."
	| answer map |
	answer _ GrayForm extent: width@height.
	map _ self colormapIfNeededForGray8bpp.
	(BitBlt toForm: answer)
		colorMap: map;
		copy: self boundingBox
		from: `0@0` in: self
		fillColor: nil rule: Form over.
	^ answer! !
!ColorForm methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:47:12' prior: 16818912!
                  copy: aRect
 	"Return a new ColorForm containing the portion of the receiver delineated by aRect."

	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	((BitBlt
		destForm: newForm
		sourceForm: self
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: aRect origin
		extent: aRect extent
		clipRect: newForm boundingBox)
		colorMap: nil) copyBits.
	colors ifNotNil: [newForm colors: colors copy].
	^ newForm
! !
!ColorForm class methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 15:47:16' prior: 50358630!
mappingWhiteToTransparentFrom: aFormOrCursor
	"Return a ColorForm copied from the given Form or Cursor with white mapped to transparent."

	| f map |
	aFormOrCursor depth <= 8 ifFalse: [
		^ self error: 'argument depth must be 8-bits per pixel or less'].
	(aFormOrCursor is: #ColorForm) ifTrue: [
		f _ aFormOrCursor copy.
		map _ aFormOrCursor colors.
	] ifFalse: [
		f _ ColorForm extent: aFormOrCursor extent depth: aFormOrCursor depth.
		f copyBits: aFormOrCursor boundingBox
			from: aFormOrCursor
			at: `0@0`
			clippingBox: aFormOrCursor boundingBox
			rule: Form over.
		map _ Color indexedColors copyFrom: 1 to: (1 bitShift: aFormOrCursor depth)].
	map _ map collect: [:c |
		c = Color white ifTrue: [Color transparent] ifFalse: [c]].
	f colors: map.
	^ f
! !
!Cursor methodsFor: 'converting' stamp: 'jmv 6/19/2017 15:47:21' prior: 16825862!
            enlargedBy: scale
	"Big cursors are 32 bits deep (ARGB premultiplied)"
	| big |
	scale = 1 ifTrue: [^self].
	big := CursorWithAlpha extent: self extent * scale depth: 32.
	(self asCursorForm magnifyBy: scale) displayOn: big.
	big offset: (self offset - 0.5 * scale min: `0@0` max: big extent negated) asIntegerPoint.
	big fallback: self.
	^big! !
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/19/2017 16:02:49' prior: 16835519!
       actualScreenSize
	<primitive: 106>
	^ `640@480`! !
!DisplayScreen class methodsFor: 'snapshots' stamp: 'jmv 6/19/2017 16:02:57' prior: 16835523!
               shutDown 
	"Minimize Display memory saved in image"
	Display setExtent: `240@120` depth: Display nativeDepth.
	ScreenUpdaterProcess ifNotNil: [
		ScreenUpdaterProcess terminate.
		ScreenUpdaterProcess _ nil ]! !
!GrayForm methodsFor: 'copying' stamp: 'jmv 6/19/2017 15:52:16' prior: 16850389!
                           copy: aRect
 	"Return a new instance containing the portion of the receiver delineated by aRect."

	| newForm |
	newForm _ self class extent: aRect extent depth: depth.
	((BitBlt
		destForm: newForm
		sourceForm: self
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: aRect origin
		extent: aRect extent
		clipRect: newForm boundingBox)
		colorMap: nil) copyBits.
	^ newForm! !
!BitBlt class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:45:22' prior: 16786163!
                        bitPeekerFromForm: sourceForm
	"Answer an instance to be used extract individual pixels from the given Form. The destination for a 1x1 copyBits will be the low order bits of (bits at: 1)."
	| pixPerWord answer |
	pixPerWord _ sourceForm pixelsPerWord.
	answer _ self destForm: (Form extent: pixPerWord@1 depth: sourceForm depth)
	 	sourceForm: nil 			"To ensure no colormap set"
		combinationRule: Form over
		destOrigin: (pixPerWord - 1)@0
		sourceOrigin: `0@0`
		extent: `1@1`
		clipRect: (`0@0` extent: pixPerWord@1).
	"To ensure no colormap set"
	answer sourceForm: sourceForm.
	^ answer! !
!BitBlt class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:45:33' prior: 16786184!
              bitPokerToForm: destForm
	"Answer an instance to be used for valueAt: aPoint put: pixValue.
	The source for a 1x1 copyBits will be the low order of (bits at: 1)"
	| pixPerWord answer |
	pixPerWord _ 32//destForm depth.
	answer _ self destForm: destForm
	 	sourceForm: nil 		"To ensure no colormap set"
		combinationRule: Form over
		destOrigin: `0@0`
		sourceOrigin: (pixPerWord-1)@0
		extent: `1@1`
		clipRect: (`0@0` extent: destForm extent).
	"To ensure no colormap set"
	answer sourceForm: (Form extent: pixPerWord@1 depth: destForm depth).
	^ answer! !
!AffineTransformation methodsFor: 'converting coordinates' stamp: 'jmv 6/19/2017 15:43:10' prior: 16778110!
      internalizeDelta: aPoint
	"Internalize a distance vector. A distance is not a position. It is a magnitude with a direction.
	It is usually used as a delta to be added to a position to obtain some other position."

	| x y det a11 a12 a21 a22 detX detY |
	x _ aPoint x.
	y _ aPoint y.
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^`0@0` ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^(detX * det) @ (detY * det)! !
!AffineTransformation methodsFor: 'converting coordinates' stamp: 'jmv 6/19/2017 15:43:16' prior: 16778149!
                             inverseTransform: aPoint
	"Apply the inverse transformation to aPoint, i.e. multiply our inverse by aPoint.
	Use Smalltalk code, and not Matrix2x3Plugin, because we want Float conversion."
	| x y det a11 a12 a21 a22 detX detY |

	x _ aPoint x - self a13.
	y _ aPoint y - self a23.
	a11 _ self a11.
	a12 _ self a12.
	a21 _ self a21.
	a22 _ self a22.
	det _ (a11 * a22) - (a12 * a21).
	det = 0.0 ifTrue: [ ^`0@0` ].		"So we have at least a valid result"
	det _ 1.0 / det.
	detX _ (x * a22) - (a12 * y).
	detY _ (a11 * y) - (x * a21).
	^(detX * det) @ (detY * det)! !
!AffineTransformation methodsFor: 'accessing' stamp: 'jmv 6/19/2017 15:43:25' prior: 16778231!
            inverseTransformation
	"Return the inverse transformation of the receiver.
	The inverse transformation is computed by first calculating
	the inverse offset and then computing transformations
	for the two identity vectors (1@0) and (0@1)"
	| r1 r2 r3 m |
	r3 _ self inverseTransform: `0@0`.
	r1 _ (self inverseTransform: `1@0`) - r3.
	r2 _ (self inverseTransform: `0@1`) - r3.
	m _ self species new.
	m
		a11: r1 x; a12: r2 x; a13: r3 x;
		a21: r1 y; a22: r2 y; a23: r3 y.
	^m! !
!AffineTransformation methodsFor: 'transforming rects' stamp: 'jmv 6/19/2017 15:43:02' prior: 16778783!
                         displayBoundsOfTransformOf: aRectangle
	"Externalize aRectangle, and find a bounding rectangle with horizontal 
		and vertical bounds and integer coordinates (i.e. adisplayBounds).
	Primitive rounds and answers integers.
	Warning: if answer from primitive is not strictly positive, it is off by one. Fix it here."

	| dstRect |
	dstRect _ Rectangle new.
	(self primDisplayBoundsOfTransformOf: aRectangle into: dstRect) ifNotNil: [
		dstRect topLeft > `0@0` ifTrue: [ ^dstRect  ]].
	^Rectangle encompassing: (aRectangle corners collect: [ :pt |
		(self transform: pt) rounded ])! !
!Point methodsFor: 'point functions' stamp: 'jmv 6/19/2017 16:10:05' prior: 16890518!
     eightNeighbors
	^ (Array with: self + `1@0`
		with: self + `1@1`
		with: self + `0@1`
		with: self + `-1@1`) ,
	(Array with: self + `-1@0`
		with: self + `-1@-1`
		with: self + `0@-1`
		with: self + `1@-1`)
! !
!Point methodsFor: 'point functions' stamp: 'jmv 6/19/2017 16:10:18' prior: 16890538!
                       fourNeighbors
	^ Array with: self + `1@0`
		with: self + `0@1`
		with: self + `-1@0`
		with: self + `0@-1`
! !
!Rectangle methodsFor: 'accessing' stamp: 'jmv 6/19/2017 16:11:04' prior: 16898560!
                             innerCorners
	"Return an array of inner corner points,
	ie, the most extreme pixels included,
	in the order of a quadrilateral spec for WarpBlt"
	| r1 |
	r1 _ self topLeft corner: self bottomRight - `1@1`.
	^ Array with: r1 topLeft with: r1 bottomLeft with: r1 bottomRight with: r1 topRight! !
!Morph methodsFor: 'events-processing' stamp: 'jmv 6/19/2017 15:54:30' prior: 16875129!
  processUnknownEvent: aMorphicEvent localPosition: localEventPosition
	"An event of an unknown type was sent to the receiver. What shall we do?!!"

	Smalltalk beep. 
	aMorphicEvent printString displayAt: `0@0`.
	aMorphicEvent wasHandled: true! !
!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:08:34' prior: 16875336!
                            minimumExtent
	"This returns the minimum extent that the morph may be shrunk to.  Not honored in too many places yet, but respected by the resizeToFit feature, at least"

	self flag: #jmvVer2.	"in owner's coordinates?"
	^self valueOfProperty: #minimumExtent ifAbsent: [`1@1`]! !
!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:08:41' prior: 16875397!
                          morphExtent
	"In our own coordinates!!"
"Quizas eventualmente borrar este tambien? (no se usa mucho...)"
	self flag: #jmvVer2.
	^`50 @ 40`! !
!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:54:22' prior: 16875457!
   morphPositionInWorld

	self flag: #jmvVer2.
	"Most likely we don't want to use global coordinates...
	In fact, we could be in many frames of reference at the same time...
	This method makes no sense at all!!"

	^self externalizeToWorld: `0@0`! !
!Morph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:54:26' prior: 16875515!
                           morphTopLeft
	"By default, morphs occupy a rectangle specified by #morphTopLef and #morphExtent"
	^`0@0`! !
!Morph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:08:46' prior: 16875946!
                               openInWorld: aWorld
	"Add this morph to the requested World."
	(location = MorphicTranslation new)
		ifTrue: [ aWorld addMorph: self position: `50@50` ]
		ifFalse: [ aWorld addMorph: self ]! !
!RectangleLikeMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:11:08' prior: 16899200!
                             initialize
	super initialize.
	extent _ `50@40`.
	color _ self defaultColor! !
!PasteUpMorph methodsFor: 'change reporting' stamp: 'jmv 6/19/2017 15:55:13' prior: 16887050!
                   invalidateDisplayRect: damageRect from: aMorph
        "Clip damage reports to my bounds, since drawing is clipped to my bounds."

        self == self world 
                ifTrue: [ worldState recordDamagedRect: (damageRect intersect: ( `0@0` extent: extent) ) ]
                ifFalse: [ super invalidateDisplayRect: damageRect from: aMorph ]
! !
!PasteUpMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:55:00' prior: 16887077!
           drawOn: aCanvas

	"draw background image."
	backgroundImage
		ifNotNil: [
			aCanvas image: backgroundImage at: `0@0` ]
		ifNil: [
			"draw background fill"
			(self isWorldMorph and: [ aCanvas drawsOnDisplay ] and: [ color mightBeTranslucent ])
				ifTrue: [
					"Special case so a translucent background on the Display allows you to see through the main Cuis Window.
					Requires proper handling of translucent Display in the VM.
					Seems to work only on Linux when using a composing window manager."
					(BitBlt toForm: Display) clipRect: aCanvas clipRect;
						copy: Display boundingBox
						from: `0@0` in: nil
						fillColor: color rule: Form over.
					Display forceToScreen]
				ifFalse: [ super drawOn: aCanvas ]]! !
!PasteUpMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:55:18' prior: 16887238!
            morphPositionInWorld

	self flag: #jmvVer2. "Solo para evitar los warning por falta de owner... pensar despues este caso"
	self isWorldMorph ifTrue: [ ^ `0@0` ].
	^super morphPositionInWorld! !
!PasteUpMorph methodsFor: 'project state' stamp: 'jmv 6/19/2017 15:55:22' prior: 50337482!
   viewBox

	^ worldState
		ifNotNil: [
			 `0@0` extent: extent ]
		ifNil: [
			self world viewBox ]! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 6/19/2017 15:55:05' prior: 16887770!
 fillRects: rectangleList color: aColor
	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."


	| blt screenRect |
	blt _ (BitBlt toForm: Display)
		sourceForm: nil;
		sourceOrigin: `0@0`;
		clipRect: self viewBox;
		fillColor: aColor;
		combinationRule: Form over.

	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect ].

	(Delay forMilliseconds: 150) wait! !
!PasteUpMorph methodsFor: 'world state' stamp: 'jmv 6/19/2017 15:55:09' prior: 16887789!
                             flashRects: rectangleList color: aColor
	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."
	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."

	| blt screenRect |
	blt _ (BitBlt toForm: Display)
		sourceForm: nil;
		sourceOrigin: `0@0`;
		clipRect: self viewBox;
		fillColor: aColor;
		combinationRule: Form reverse.

	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect ].

	(Delay forMilliseconds: 250) wait.

	rectangleList do: [:r |
		screenRect _ r translatedBy: self viewBox origin.
		blt destRect: screenRect; copyBits.
		Display forceToScreen: screenRect ]! !
!PasteUpMorph class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:55:26' prior: 50337498!
              newWorld
	"
[
	ProjectX stopUIProcess.
	ProjectX spawnNewMorphicProcessFor: PasteUpMorph newWorld
] fork.
	"
	| w ws |
	w _ self new.
	ws _ WorldState new.
	w worldState: ws.
	w morphPosition: `0@0` extent: Display extent.
	ws setCanvas: Display getCanvas.
	w borderWidth: 0.
	ws handsDo: [ :h |
		h privateOwner: w ].
	^w! !
!EllipseMorph methodsFor: 'geometry testing' stamp: 'jmv 6/19/2017 16:03:06' prior: 16837091!
                            morphContainsPoint: aLocalPoint

	| radius other delta xOverY |
	((`0@0` extent: extent) containsPoint: aLocalPoint) ifFalse: [^ false].  "quick elimination"
	extent > `1@1`
		ifFalse: [^ true].  "Degenerate case -- code below fails by a bit"

	radius _ extent y asFloat / 2.
	other _ extent x asFloat / 2.
	delta _ aLocalPoint - (other@radius).
	xOverY _ extent x asFloat / extent y asFloat.
	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !
!HandleMorph methodsFor: 'events' stamp: 'jmv 6/19/2017 16:05:03' prior: 16852419!
                       keyStroke: aKeyboardEvent
	"Check for cursor keys"
	| keyValue |
	(owner is: #HandMorph) ifFalse: [ ^self ].
	keyValue _ aKeyboardEvent keyValue.
	keyValue = 28 ifTrue: [ ^self morphPosition: self morphPosition - `1@0` ].
	keyValue = 29 ifTrue: [ ^self morphPosition: self morphPosition + `1@0` ].
	keyValue = 30 ifTrue: [ ^self morphPosition: self morphPosition - `0@1` ].
	keyValue = 31 ifTrue: [ ^self morphPosition: self morphPosition + `0@1` ].
	"Special case for return"
	aKeyboardEvent isReturnKey ifTrue:[
		"Drop the receiver and be done"
	self flag: #arNote. "Probably unnecessary"
		owner releaseKeyboardFocus: self.
		self delete ]! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:04:48' prior: 16852446!
                              initialize
	"initialize the state of the receiver"
	super initialize.
	extent _ `12@12`! !
!PluggableMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:09:25' prior: 16889457!
       initialize
	super initialize.
	extent _ `200@100`! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:55:30' prior: 16888083!
              draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: c.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:55:46' prior: 50359274!
               drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (`0@0` extent: extent) insetBy: `1@3`.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (`0@0` extent: extent) insetBy: `1@3`.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:09:15' prior: 16888316!
                  initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle _ nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model _ nil.
	getStateSelector _ nil.
	actionSelector _ nil.
	isPressed _ false.
	mouseIsOver _ false.
	actWhen _ #buttonUp.
	extent _  `20 @ 15`! !
!PluggableButtonMorph methodsFor: 'geometry testing' stamp: 'jmv 6/19/2017 15:55:52' prior: 16888418!
     morphContainsPoint: aLocalPoint

	| iconOrigin |
	((`0@0` extent: extent) containsPoint: aLocalPoint) ifFalse: [ ^false ].
	^ self isOrthoRectangularMorph or: [
		magnifiedIcon isNil or: [
			iconOrigin _ extent - magnifiedIcon extent // 2.
			(magnifiedIcon isTransparentAt: (aLocalPoint - iconOrigin) rounded) not ]]! !
!PluggableButtonMorph class methodsFor: 'example' stamp: 'jmv 6/19/2017 16:09:19' prior: 50359323!
                           example
	"
	PluggableButtonMorph example openInWorld
	"

	| s1 s2 s3 b1 b2 b3 row |
	s1 _ Switch new.
	s2 _ Switch new turnOn.
	s3 _ Switch new.
	s2 onAction: [s3 turnOff].
	s3 onAction: [s2 turnOff].
	b1 _ (PluggableButtonMorph model: s1 stateGetter: #isOn action: #switch) label: 'S1'.
	b2 _ (PluggableButtonMorph model: s2 stateGetter: #isOn action: #turnOn) label: 'S2'.
	b3 _ (PluggableButtonMorph model: s3 stateGetter: #isOn action: #turnOn) label: 'S3'.
	b1 color: Color lightRed.
	b2 color: Color lightRed.
	b3 color: Color lightRed.
	row _ LayoutMorph newRow
		addMorphs: (Array with: b1 with: b2 with: b3);
		morphExtent: `120@35`.
	^ row
! !
!PluggableScrollPane methodsFor: 'access' stamp: 'jmv 6/19/2017 15:56:26' prior: 16889497!
                       addToScroller: aMorph

	scroller
		addMorph: aMorph position: `0@0`;
		morphExtent: aMorph morphExtent! !
!PluggableScrollPane methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:09:31' prior: 16889865!
                   initialize
	
	"initialize the state of the receiver"
	super initialize.
	hideScrollBars _ false.

	"initialize the receiver's scrollBars"
	scrollBar _ self scrollBarClass new model: self setValueSelector: #vScrollBarValue:.
	hScrollBar _ self scrollBarClass new model: self setValueSelector: #hScrollBarValue:.
	drawKeyboardFocusIndicator _ true.

	scroller _ self innerMorphClass new.
	self addMorph: scroller.
	self scrollerOffset: `0@ 0`.
	self addMorph: scrollBar.
	self addMorph: hScrollBar.! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'jmv 6/19/2017 15:56:31' prior: 16889992!
              scrollToShow: aRectangle
	"scroll to include as much of aRectangle as possible, where aRectangle is in the scroller's local space.
	This means that 0@0 is scrolling all the way top and all the way left"
	| delta |
	(aRectangle top >= 0 and: [
		aRectangle bottom <= self viewableHeight ])
		ifTrue: [
			"already visible"
			^self ].

	"Scroll end of selection into view if necessary"
	delta _ aRectangle amountToTranslateWithin: (`0@0` extent: self viewableExtent).
	delta y ~= 0 ifTrue: [
		self scrollBy: 0@delta y ]! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'jmv 6/19/2017 15:55:58' prior: 16889279!
                     mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (localEventPosition y < 0 and: [ scrollBar value > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: `0@0`) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ scrollBar value < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [ self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!SystemWindow methodsFor: 'change reporting' stamp: 'jmv 6/19/2017 15:58:02' prior: 16926004!
                     invalidateTitleArea

	"not really pretty... also invalidating the top border, regardless of it being above or below the title area
	(Different themes use various looks, this covers them all)"
	self invalidateLocalRect: (`0@0` extent: extent x @ (self labelHeight + borderWidth))! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:54' prior: 16926054!
                 drawClassicFrameOn: aCanvas color: titleColor
	"Window border encompasses title area. No round corners. No title gradient."

	aCanvas fillRectangle: (`0@0` extent: extent) color: color borderWidth: borderWidth borderStyleSymbol: #simple baseColorForBorder: self widgetsColor.

	"A border was drawn at the left, top and right of the title area.
	The look is that the title area is inside the window"
	aCanvas fillRectangle: (borderWidth@borderWidth extent: extent x - (2*borderWidth)@ self labelHeight) color: titleColor! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:58' prior: 16926109!
drawRoundedFrameOn: aCanvas color: widgetsColor
	"Title area is not inside window borders"
	| bottomFactor topFactor |
	Theme current useWindowTitleGradient
		ifTrue: [
			topFactor _ Theme current titleGradientTopFactor.
			bottomFactor _ Theme current titleGradientBottomFactor ]
		ifFalse: [
			topFactor _ 1.
			bottomFactor _ 1 ].
	aCanvas
		windowFrame: (`0@0` extent: extent)
		color: widgetsColor * Theme current titleGradientExtraLightness
		radius: Theme current roundedWindowRadius
		border: borderWidth
		labelHeight: self labelHeight + borderWidth
		gradientTop: topFactor
		gradientBottom: bottomFactor
		insideColor: color! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 16:37:43' prior: 16926132!
          makeMeFullyVisible 

	self world morphExtent > `0@0` ifFalse: [^ self].

	(self morphPosition >= `0@0` and: [ self morphPosition < (self world morphExtent-self morphExtent)]) ifTrue: [
		^ self "OK -- visible"].

	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: self morphExtentInWorld world: self world) topLeft! !
!SystemWindow methodsFor: 'drawing' stamp: 'jmv 6/19/2017 16:37:53' prior: 16926145!
                     makeMeVisible 

	self world morphExtent > `0@0` ifFalse: [^ self].

	(self morphPosition >= `0@0` and: [ self morphPosition < (self world morphExtent-self labelHeight)]) ifTrue: [
		^ self "OK -- at least my top left is visible"].

	"window not on screen (probably due to reframe) -- move it now"
	self morphPosition: (RealEstateAgent initialFrameFor: self initialExtent: extent world: self world) topLeft! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:12:56' prior: 16926196!
                 minimumExtent

	^`160@80`! !
!SystemWindow methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:13:07' prior: 16926199!
             rescaleButtons
	"boxExtent changed.  Update my buttons."
	| buttonExtent buttonPos buttonDelta |
	buttonExtent := self boxExtent.
	buttonPos := `2@2`.
	buttonDelta := self boxExtent x + 2.
	self submorphsReverseDo: [ :aMorph |
		(aMorph is: #PluggableButtonMorph) 
		  ifTrue: [ 
				aMorph morphExtent: buttonExtent. 
				aMorph morphPosition: buttonPos.
				buttonPos := (buttonPos x  + buttonDelta) @ 2.
		].
	].
! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:57:49' prior: 16926215!
boxExtent
	"answer the extent to use in all the buttons. 
	 
	the label height is used to be proportional to the fonts preferences"
	| e |
	Theme current minimalWindows ifTrue: [^`0@0`].
	e _ Preferences windowTitleFont height.
	^e@e! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:12:42' prior: 16926276!
                       initialize
	"Initialize a system window. Add label, stripes, etc., if desired"

	super initialize.
	labelString ifNil: [ labelString _ 'Untitled Window'].
	
	self initializeLabelArea.
	extent _ `300 @ 200`.

	adjusters _ Dictionary new.
	adjusters at: #topAdjuster put: WindowEdgeAdjustingMorph forTop.
	adjusters at: #bottomAdjuster put: WindowEdgeAdjustingMorph forBottom.
	adjusters at: #leftAdjuster put: WindowEdgeAdjustingMorph forLeft.
	adjusters at: #rightAdjuster put: WindowEdgeAdjustingMorph forRight.
	adjusters at: #topLeftAdjuster put: WindowEdgeAdjustingMorph forTopLeft.
	adjusters at: #bottomLeftAdjuster put: WindowEdgeAdjustingMorph forBottomLeft.
	adjusters at: #topRightAdjuster put: WindowEdgeAdjustingMorph forTopRight.
	adjusters at: #bottomRightAdjuster put: WindowEdgeAdjustingMorph forBottomRight.
	adjusters do: [ :m |
		self addMorphFront: m ].

	"by default"
	self beColumn! !
!SystemWindow methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:12:52' prior: 16926307!
                         initializeLabelArea
	"Initialize the label area (titlebar) for the window."

	| spacing |
	spacing _ self boxExtent x + 2.
	self addMorph: self createCloseBox position: `2@2`.
	self addMorph: self createCollapseBox position: spacing+2@2.
	self addMorph: self createExpandBox position: spacing*2+2@2.
	self addMorph: self createMenuBox position: spacing*3+2@2! !
!SystemWindow methodsFor: 'layout' stamp: 'jmv 6/19/2017 15:58:05' prior: 16926374!
  layoutSubmorphs
	"Compute a new layout of submorphs based on the given layout bounds."

	| h thickness w cornerExtent wh ww pos |
	thickness _ 4.
	cornerExtent _ 20.
	ww _ extent x.
	wh _ extent y.
	w _ ww - cornerExtent - cornerExtent.
	h _ wh - cornerExtent - cornerExtent.
	(adjusters at: #topAdjuster) morphPosition: cornerExtent@0 extent: w@thickness.
	(adjusters at: #bottomAdjuster) morphPosition: cornerExtent@(wh-thickness) extent: w@thickness.
	(adjusters at: #leftAdjuster) morphPosition: 0@cornerExtent extent: thickness@h.
	(adjusters at: #rightAdjuster) morphPosition: ww-thickness@cornerExtent extent: thickness@h.
	(adjusters at: #topLeftAdjuster) morphPosition: `0@0` extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomLeftAdjuster) morphPosition: 0@(wh-cornerExtent) extent: cornerExtent@cornerExtent.
	(adjusters at: #topRightAdjuster) morphPosition: ww-cornerExtent@0 extent: cornerExtent@cornerExtent.
	(adjusters at: #bottomRightAdjuster) morphPosition: ww@wh-cornerExtent extent: cornerExtent@cornerExtent.

	layoutMorph ifNotNil: [
		pos _ borderWidth @ (borderWidth + self labelHeight).
		layoutMorph
			morphPosition: pos
			extent: extent - pos - borderWidth ].
	
	layoutNeeded _ false! !
!SystemWindow methodsFor: 'resize/collapse' stamp: 'jmv 6/19/2017 16:13:13' prior: 50333187!
                            resize
	| resizeMorph |
	resizeMorph _ ResizeMorph new morphExtent: `200@150`.
	resizeMorph action: [self resize: (resizeMorph selectionRectangle: Display extent)].
	resizeMorph morphPosition: self world activeHand morphPosition.
	resizeMorph openInWorld
	! !
!CodePackageListWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:26' prior: 16811550!
                         initialExtent

	^`540@400`! !
!ChangeSorterWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:18' prior: 16800076!
  initialExtent
	^`540@300`! !
!PreDebugWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:38' prior: 16892600!
       initialExtent
	^ `640 @ 320`! !
!InspectorWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:32' prior: 50336316!
   initialExtent

	^`600@325`! !
!ObjectExplorerWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:01:35' prior: 16883318!
initialExtent

	^`300@500`! !
!TestRunnerWindow methodsFor: 'GUI building' stamp: 'jmv 6/19/2017 16:13:18' prior: 16928555!
    buildMorphicWindow

	self layoutMorph
		addMorph: self buildUpperControls proportionalHeight: 0.25;
		addAdjusterAndMorph: self buildLowerPanes proportionalHeight: 0.75.
	self setLabel: 'SUnit Test Runner'.
	self refreshWindow.
	self morphExtent: `460 @ 400`! !
!ScrollBar methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:09' prior: 16904515!
        drawOn: aCanvas

	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: (color alphaMixed: 0.3 with: Theme current scrollbarColor)
		borderWidth: borderWidth
		borderStyleSymbol: #simple
		baseColorForBorder: borderColor! !
!MenuMorph methodsFor: 'construction' stamp: 'jmv 6/19/2017 16:07:49' prior: 16866514!
      addTitle: aString
	"Add a title line at the top of this menu Make aString its initial 
	contents.  
	If aSelector is not nil, then periodically obtain fresh values for its 
	contents by sending aSelector to aTarget.."

	| s pp w |
	
	titleMorph _ RectangleLikeMorph new.
	titleMorph color: Theme current menuTitleBar.
	pp _ `8@2`.
	aString asString linesDo: [ :line |
		s _ StringMorph new
			contents: line;
			font: Preferences standardMenuFont bold.
		titleMorph addMorphBack: s position: pp.
		pp _ pp + (0@(s morphHeight+2)) ].
	w _ titleMorph submorphs inject: 0 into: [ :prev :each |
		prev max: each morphWidth ].
	titleMorph morphExtent: (w + 16) @ (pp y).
	self addMorphFront: titleMorph.
	
	(self hasProperty: #needsStayUpIcons) ifTrue: [ self addStayUpIcons ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 6/19/2017 16:37:20' prior: 50341059!
       popUpAdjacentTo: rightOrLeftPointInWorld from: sourceItem
	"Present this menu at the given point under control of the given hand.
	Used mostly for submenus."

	| delta tryToPlace selectedOffset |
	popUpOwner _ sourceItem.
	selectedOffset _ (selectedItem ifNil: [ self items first ]) morphPosition.
	sourceItem world addMorphFront: self.

	tryToPlace _ [ :where :mustFit |
		self morphPosition: where - selectedOffset.
		delta _ self morphFullBoundsInWorld
			amountToTranslateWithin: sourceItem world morphBoundsInWorld.
		(delta x = 0 | mustFit) ifTrue: [
			delta = `0@0` ifFalse: [ self morphPosition: self morphPosition + delta ].
			^ self]].
	tryToPlace 
		value: rightOrLeftPointInWorld first value: false;
		value: rightOrLeftPointInWorld last - (extent x @ 0) value: false;
		value: rightOrLeftPointInWorld first value: true! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 6/19/2017 16:08:25' prior: 50339215!
         popUpAt: aPoint forHand: hand allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	| evt |
	self items isEmpty ifTrue: [^self].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph ]) 
		do: [ :m | m updateContents].
	self runningWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ].
	evt _ hand lastMouseEvent.
	(evt isKeyboard or: [ evt isMouse and: [ evt anyButtonPressed not ]]) 
		ifTrue: [
			"Select first item if button not down"
			self moveSelectionDown: 1 event: evt ]! !
!MenuMorph methodsFor: 'control' stamp: 'jmv 6/19/2017 16:08:29' prior: 50339240!
      popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 
	"Present this menu at the given point under control of the given hand."

	self items isEmpty ifTrue: [ ^self ].
	Theme current decorateMenu: self.
	(self submorphs select: [ :m | m is: #UpdatingMenuItemMorph]) 
		do: [ :m | m updateContents].
	aWorld addMorphFront: self position: aPoint - `2 @ 8`.
	self fitInWorld.
	"Acquire focus for valid pop up behavior"
	hand newMouseFocus: self.
	aBoolean ifTrue: [ hand newKeyboardFocus: self ]! !
!MenuMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:08:18' prior: 50341135!
            initialize
	super initialize.
	extent _ `40@10`.
	defaultTarget _ nil.
	selectedItem _ nil.
	stayUp _ false.
	popUpOwner _ nil! !
!MenuMorph methodsFor: 'keyboard control' stamp: 'jmv 6/19/2017 16:08:04' prior: 50359760!
   displayFiltered: evt
	| matchStr allItems isMatch matches feedbackMorph |
	matchStr _ self valueOfProperty: #matchString.
	allItems _ self submorphs select: [ :m |
		m is: #MenuItemMorph ].
	matches _ allItems select: [ :m |
		isMatch _ matchStr isEmpty or: [
			m contents
				includesSubstring: matchStr
				caseSensitive: false ].
		m isEnabled: isMatch.
		isMatch ].
	feedbackMorph _ self valueOfProperty: #feedbackMorph.
	feedbackMorph ifNil: [
		feedbackMorph _ StringMorph new color: Color veryDarkGray.
		self addMorphBack: feedbackMorph lock position: `0@ -20`.
		self
			setProperty: #feedbackMorph
			toValue: feedbackMorph ].
	feedbackMorph contents: '<' , matchStr , '>'.
	matchStr isEmpty ifTrue: [
		feedbackMorph delete.
		self removeProperty: #feedbackMorph ].
	matches notEmpty ifTrue: [
		self selectItem: matches first ]! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 16:07:56' prior: 16867223!
  adjustSubmorphsLayout
	"Enlarge the width of submorphs as needed
	so all of them are have the same width, and no less than #minWidth.
	Also adjust their vertical position.
	Finally, set our own extent."
	
	| w p h |
	
	submorphs isEmpty ifTrue: [ ^self ].
	w _ submorphs inject: 0 into: [ :prev :each |
		prev max: each minItemWidth].

	w _ w + 1.
	p _ `5 @ 5`.
	submorphs do: [ :m |
		h _ m morphHeight.
		m morphPosition: p extent: w@h.
		p _ p + (0@(h + 1)) ].

	self morphExtent: w+4 @ p y + 5! !
!MenuMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 16:08:14' prior: 16867241!
                         fitInWorld
	"Note: items may not be laid out yet (I found them all to be at 0@0),  
	so we have to add up heights of items above the selected item."

	| delta |
	"If it doesn't fit, show it to the left, not to the right of the hand."
	self morphBoundsInWorld right > owner world morphBoundsInWorld right
		ifTrue: [
			self morphPosition: ((self morphPosition x + 10 - extent x) @ self morphPosition y) ].

	"Make sure that the menu fits in the world."
	delta _ self morphBoundsInWorld amountToTranslateWithin:
		(owner world morphBoundsInWorld withHeight:
			((owner world morphExtentInWorld y) max: (self morphPosition y) + 1)).
	delta = `0 @ 0` ifFalse: [ self morphPosition: self morphPosition + delta ]! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:43:48' prior: 16781484!
                              downButtonPosition
	^`0@0` + (extent - ScrollBar scrollbarThickness)! !
!AutoCompleterMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:43:54' prior: 50359790!
                             drawOn: aCanvas
	| rectangle w y0 h y1 y2 scrollbarThickness |
	aCanvas frameAndFillRectangle: (`0@0` extent: extent) fillColor: self color borderWidth: borderWidth borderColor: borderColor.
	y0 _ 1.
	w _ extent x-2.
	scrollbarThickness _ ScrollBar scrollbarThickness.
	completer entryCount > self class itemsPerPage  ifTrue: [
		w _ w - scrollbarThickness.
		aCanvas
			frameRectangle: (extent x - scrollbarThickness@0
				extent: scrollbarThickness @ extent y)
			borderWidth: 1
			color: borderColor.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #up size: scrollbarThickness)
			at: self upButtonPosition.
		aCanvas
			image: (BitBltCanvas arrowOfDirection: #down size: scrollbarThickness)
			at: self downButtonPosition.
		h _ extent y - (2 * scrollbarThickness).
		y1 _ (1.0 * self firstVisible-1 / completer entryCount * h) ceiling + y0 + scrollbarThickness-1.
		y2 _ (1.0 * self lastVisible / completer entryCount * h) floor + y0 + scrollbarThickness -1.
		aCanvas
			fillRectangle: (extent x - scrollbarThickness+2@y1 corner:  extent x-2 @ y2)
			color: Color veryLightGray ].
	self firstVisible
		to: self lastVisible
		do: [ :index |
			rectangle _ 1@y0 extent: w@self class itemHeight.
			index = self selected
				ifTrue: [
					aCanvas fillRectangle: rectangle color: (Theme current listHighlightFocused: true) ].
			aCanvas
				drawString: (completer entries at: index) asString
				at: rectangle topLeft
				font: self class listFont
				color: Theme current text.
			y0 _ y0 + self itemHeight ]! !
!AutoCompleterMorph class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 16:00:57' prior: 16781686!
    initializedInstance
	| completer m |
	completer _ SmalltalkCompleter withModel: (TextModel withText: 'Small').
	completer
		instVarNamed: 'position'
		put: 5.
	completer computeEntries.
	m _ AutoCompleterMorph
		completer: completer
		position: `200 @ 200`.
	completer instVarNamed: 'menuMorph' put: m.
	^m! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:36' prior: 50359845!
                        drawOn: aCanvas 
	"Draw the hand itself (i.e., the cursor)."
	"This method is only called when we are carrying morphs around..."
	 aCanvas
		stencil: Cursor move
		at: `0@0`
		color: Color black! !
!HandMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:45' prior: 16851711!
        savePatchFrom: aCanvas appendDamageTo: aStream
	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."

	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."

	| fullBounds |
	fullBounds _ self morphFullBoundsInWorld.
	fullBounds ifNil: [ ^self ].

	fullBounds _ fullBounds intersect: (`0@0` extent: aCanvas extent).
	(savedPatch isNil or: [savedPatch extent ~= fullBounds extent]) 
		ifTrue: [
			"allocate new patch form if needed"
			savedPatch _ Form extent: fullBounds extent depth: aCanvas depth ].
	aCanvas
		contentsOfArea: fullBounds
		into: savedPatch.
	savedPatch offset: fullBounds topLeft.
	prevFullBounds
		ifNil: [ aStream nextPut: fullBounds ]
		ifNotNil: [ aStream nextPut: (fullBounds merge: prevFullBounds)].
	prevFullBounds _ fullBounds! !
!HandMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 15:52:41' prior: 16852160!
          initForEvents
	mouseOverHandler _ nil.
	lastMouseEvent _ MouseEvent new setType: #mouseMove position: `0@0` buttons: 0 hand: self.
	lastMouseEventTime _ Time localMillisecondClock.
	lastEventBuffer _ {1. 0. 0. 0. 0. 0. nil. nil}.
	self dontWaitForMoreClicks! !
!ImageMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:49' prior: 16854128!
        drawOn: aCanvas

	aCanvas image: image at: `0@0`! !
!StringMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:57:40' prior: 50343919!
                        drawOn: aCanvas
	aCanvas
		drawString: (contents ifNil: [ '' ])
		at: `0@0`
		font: self fontToUse
		color: color
		! !
!StringMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 15:57:44' prior: 16918155!
                   fitContents
	"Measures contents later at #minimumExtent"
	self morphExtent: `0@0`! !
!IndentingListItemMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:00' prior: 16854676!
            drawOn: aCanvas

	| tRect colorToUse sLeft aForm centeringOffset |
	isHighlighted ifTrue: [
		aCanvas
			fillRectangle: (`0@0` extent: extent)
			color: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) duller ].
	isSelected ifTrue: [
		aCanvas
			fillRectangle: (`0@0` extent: extent)
			color: (Theme current
				listHighlightFocused: owner owner hasKeyboardFocus) ].
			
	tRect _ self toggleRectangle.
	aForm _ isExpanded 
		ifTrue: [ container expandedForm ]
		ifFalse: [ container notExpandedForm ].
	centeringOffset _ ((tRect height - aForm extent y) / 2.0) rounded.

	complexContents hasContents ifTrue: [
		aCanvas 
			image: aForm 
			at: (tRect topLeft translatedBy: 0 @ centeringOffset) ].

	icon isNil
	ifFalse: [
		 aCanvas 
			image: icon
			at:  (tRect topLeft translatedBy:  icon width  @ centeringOffset).
		sLeft _ indentLevel * 12 + 16 + (icon width + 2).
	]
	ifTrue: [
		sLeft _ indentLevel * 12 + 16.
	].
	colorToUse _ complexContents preferredColor ifNil: [ color ].

	aCanvas
		drawString: contents asString
		at: sLeft@0
		font: self fontToUse
		color: colorToUse! !
!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 6/19/2017 16:06:04' prior: 16865800!
                contents: aString withMarkers: aBool inverse: inverse 
	"Set the menu item entry. If aBool is true, parse aString for embedded markers."

	| markerIndex marker |
	self contentString: nil.	"get rid of old"
	aBool ifFalse: [^super contents: aString].
	self removeAllMorphs.	"get rid of old markers if updating"
	self hasIcon ifTrue: [ self icon: nil ].
	(aString notEmpty and: [aString first = $<]) 
		ifFalse: [^super contents: aString].
	markerIndex := aString indexOf: $>.
	markerIndex = 0 ifTrue: [^super contents: aString].
	marker := (aString copyFrom: 1 to: markerIndex) asLowercase.
	(#('<on>' '<off>' '<yes>' '<no>') includes: marker) 
		ifFalse: [^super contents: aString].
	self contentString: aString.	"remember actual string"
	marker := (marker = '<on>' or: [marker = '<yes>']) ~= inverse 
				ifTrue: [self onImage]
				ifFalse: [self offImage].
	super contents:  (aString copyFrom: markerIndex + 1 to: aString size).
	"And set the marker"
	marker := ImageMorph new image: marker.
	self addMorphFront: marker position: `0@2`! !
!MenuItemMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:42' prior: 16865892!
                          drawOn: aCanvas 
	| stringColor leftEdge |

	stringColor _ color.
	isSelected & isEnabled
		ifTrue: [
			aCanvas fillRectangle: (`0@0` extent: extent) color: Theme current menuHighlight].
	leftEdge _ 0.

	self hasMarker ifTrue: [
		leftEdge _ leftEdge + submorphs first morphWidth + 8 ].

	self hasIcon
		ifTrue: [| iconForm | 
			iconForm _ isEnabled ifTrue: [ self icon ] ifFalse: [ self icon asGrayScaleAndTransparent ].
			aCanvas image: iconForm at: leftEdge+1 @ (extent y - iconForm height // 2).
			leftEdge _ leftEdge + iconForm width + self iconSeparation].

	aCanvas
		drawString: contents
		at: leftEdge @ 1
		font: self fontToUse
		color: stringColor.
	subMenu ifNotNil: [
		aCanvas
			image: self class subMenuMarker
			at: extent x - 8 @ (extent y - self class subMenuMarker height // 2) ]! !
!MenuItemMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:06:09' prior: 16866103!
                            initialize
	"initialize the state of the receiver"
	super initialize.
	""
	extent _ `10@10`.
	contents _ ''.
	isEnabled _ true.
	subMenu _ nil.
	isSelected _ false.
	target _ nil.
	selector _ nil.
	arguments _ nil.
	font _ Preferences standardMenuFont! !
!MenuItemMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 16:06:26' prior: 16866117!
            measureContents
	| e |
	e _ super measureContents.
	^e y > 12
		ifTrue: [e+`2@2`]
		ifFalse: [e+`2@1`]! !
!MenuItemMorph methodsFor: 'selecting' stamp: 'jmv 6/19/2017 15:53:59' prior: 50341150!
                              select
	self isSelected: true.
	owner activeSubmenu: subMenu.
	subMenu ifNotNil: [
		subMenu delete.
		subMenu
			popUpAdjacentTo: (Array with: self morphBoundsInWorld topRight + `10@0`
											with: self morphBoundsInWorld topLeft)
			from: self.
		subMenu selectItem: nil ]! !
!MenuItemMorph class methodsFor: 'cached state access' stamp: 'jmv 6/19/2017 16:06:33' prior: 16866204!
                              subMenuMarker

	| f |
	SubMenuMarker ifNotNil: [ ^SubMenuMarker ].
	f _ Form
		extent: `5@9`
		fromArray: #(2147483648 3221225472 3758096384 4026531840 4160749568 4026531840 3758096384 3221225472 2147483648)
		offset: `0@0`.
	SubMenuMarker _ ColorForm mappingWhiteToTransparentFrom: f.
	^SubMenuMarker! !
!LayoutAdjustingMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:34' prior: 16862884!
                  drawOn: aCanvas

	aCanvas
		fillRectangle: (`0@0` extent: extent)
		color: color! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 15:53:38' prior: 16863315!
                         layoutBounds
	"Return the bounds for laying out children of the receiver"

	^`0@0` extent: extent! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 16:05:36' prior: 16863335!
        layoutSubmorphsHorizontallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableWidth sumOfFixed normalizationFactor availableForPropWidth 
		fractionalWidths integerWidths theLeft usableHeight boundsTop boundsRight theTop minWidth submorphsToLayout 
			nextMorph ht wd ls theRight boundsBottom theBottom alternativeWidths count diff i |
	
	boundsForLayout extent > `2@2` "self minimumExtent" 
		ifFalse: [ ^self ]. "Too small. Don't bother!!"

	submorphsToLayout := self submorphsToLayout.
	xSep := self xSeparation.
	ySep := self ySeparation.
	usableWidth := boundsForLayout width - ((submorphsToLayout size + 1) * xSep).
	sumOfFixed := submorphsToLayout sum: [ :m | m layoutSpec fixedWidth ].
	availableForPropWidth := usableWidth - sumOfFixed max: 0.
	normalizationFactor := self proportionalWidthNormalizationFactor.
	availableForPropWidth := availableForPropWidth * normalizationFactor.
	
	fractionalWidths := submorphsToLayout collect: [ :m | m layoutSpec widthFor: availableForPropWidth ].
	"Compute integer widths, mostly rounding but with occasional #floor or #ceiling as needed to keep sum"
	integerWidths _ fractionalWidths collect: [ :w | w rounded ].
	diff _ integerWidths sum - fractionalWidths sum rounded.
	alternativeWidths _ diff > 0 ifTrue: [ fractionalWidths collect: [ :w | w floor ]] ifFalse: [ fractionalWidths collect: [ :w | w ceiling ]].
	count _ diff abs.
	i _ 1.
	[ count > 0] whileTrue: [
		(integerWidths at: i) = (alternativeWidths at: i) ifFalse: [
			integerWidths at: i put: (alternativeWidths at: i).
			count _ count -1 ].
		i _ i + 1 ].
	minWidth := integerWidths sum.
	theLeft := ((usableWidth - minWidth) * (padding ifNil: [0]) max: 0) + boundsForLayout left + xSep.
	usableHeight := boundsForLayout height - (ySep * 2) max: 0.
	boundsTop    := boundsForLayout top + ySep.
	boundsRight  := boundsForLayout right - xSep.
	boundsBottom := boundsForLayout bottom - ySep.

	submorphsToLayout size to: 1 by: -1 do: [ :index |
		nextMorph := submorphsToLayout at: index.
		"major direction"
		wd := integerWidths at: index.
		"minor direction"
		ls := nextMorph layoutSpec.
		ht := (ls heightFor: usableHeight) min: usableHeight.
		theTop := ((usableHeight - ht) * ls minorDirectionPadding) floor + boundsTop.
		theBottom := (theTop + ht) ceiling min: boundsBottom.
		theRight := (theLeft + (wd min: minWidth)) "ceiling "min: boundsRight.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		ls usesMorphExtent
			ifTrue: [
				nextMorph morphPosition: theLeft floor @ theTop floor ]
			ifFalse: [
				nextMorph morphPosition: theLeft floor @ theTop floor extent: theRight - theLeft @ (theBottom - theTop) ].
		theLeft := theRight + xSep
	]! !
!LayoutMorph methodsFor: 'layout' stamp: 'jmv 6/19/2017 16:05:46' prior: 16863426!
  layoutSubmorphsVerticallyIn: boundsForLayout
	"Compute a new layout based on the given layout bounds."
	| xSep ySep usableHeight sumOfFixed normalizationFactor availableForPropHeight 
		fractionalHeights integerHeights theTop usableWidth boundsLeft boundsBottom theLeft minHeight submorphsToLayout 
			nextMorph ht wd ls theBottom boundsRight theRight alternativeHeights count diff i |

	boundsForLayout extent > `2@2` "self minimumExtent" 
		ifFalse: [ ^self ]. "Too small. Don't bother!!"

	submorphsToLayout := self submorphsToLayout.
	xSep := self xSeparation.
	ySep := self ySeparation.
	usableHeight := boundsForLayout height - ((submorphsToLayout size + 1) * ySep).
	sumOfFixed := submorphsToLayout sum: [ :m | m layoutSpec fixedHeight ].
	availableForPropHeight := usableHeight - sumOfFixed max: 0.
	normalizationFactor := self proportionalHeightNormalizationFactor.
	availableForPropHeight := availableForPropHeight * normalizationFactor.
	
	fractionalHeights := submorphsToLayout collect: [ :m | m layoutSpec heightFor: availableForPropHeight ].
	"Compute integer widths, mostly rounding but with occasional #floor or #ceiling as needed to keep sum"
	integerHeights _ fractionalHeights collect: [ :w | w rounded ].
	diff _ integerHeights sum - fractionalHeights sum rounded.
	alternativeHeights _ diff > 0 ifTrue: [ fractionalHeights collect: [ :w | w floor ]] ifFalse: [ fractionalHeights collect: [ :w | w ceiling ]].
	count _ diff abs.
	i _ 1.
	[ count > 0] whileTrue: [
		(integerHeights at: i) = (alternativeHeights at: i) ifFalse: [
			integerHeights at: i put: (alternativeHeights at: i).
			count _ count -1 ].
		i _ i + 1 ].
	minHeight := integerHeights sum.
	theTop := ((usableHeight - minHeight) * (padding ifNil: [0]) max: 0) + boundsForLayout top + ySep.
	usableWidth     := boundsForLayout width - (xSep * 2) max: 0.
	boundsLeft      := boundsForLayout left + xSep.
	boundsBottom := boundsForLayout bottom - ySep.
	boundsRight := boundsForLayout right - xSep.
	
	submorphsToLayout size to: 1 by: -1 do: [ :index |
		nextMorph := submorphsToLayout at: index.
		"major direction"
		ht := integerHeights at: index.
		"minor direction"
		ls := nextMorph layoutSpec.
		wd := (ls widthFor: usableWidth) min: usableWidth.
		theLeft := ((usableWidth - wd) * ls minorDirectionPadding) floor + boundsLeft.
		theRight := (theLeft + wd) ceiling min: boundsRight.
		theBottom := (theTop + (ht min: minHeight)) "ceiling" min: boundsBottom.
		"Set bounds and adjust major direction for next step"
		self flag: #jmvVer2.	"should extent be set in m's coordinate system? what if its scale is not 1?"
		ls usesMorphExtent
			ifTrue: [
				nextMorph morphPosition: theLeft floor @ theTop floor ]
			ifFalse: [
				nextMorph morphPosition: theLeft floor @ theTop floor extent: theRight - theLeft @ (theBottom - theTop) ].
		theTop := theBottom + ySep
	]! !
!ProgressMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:10:33' prior: 16896264!
                       initialize
	super initialize.
	self separation: 0.
	labelMorph _ StringMorph contents: '' font: AbstractFont default.
	subLabelMorph _ StringMorph contents: '' font: AbstractFont default.
	progress _ ProgressBarMorph new.
	progress morphExtent: `200 @ 15`.
	self addMorphFront: labelMorph.
	self addMorphFront: subLabelMorph.
	self addMorph: progress fixedHeight: 15.! !
!HaloHandleMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:52:21' prior: 16850527!
                     drawOn: aCanvas

	aCanvas
		image: (self class circleForm: extent)
		multipliedBy: color
		at: `0@0`! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 15:52:25' prior: 50360435!
      addHandle: handleSpec
	"Add a handle within the halo box as per the haloSpec, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."

	| handle aPoint colorToUse form icon |
	aPoint _ self 
				positionIn: haloBox
				horizontalPlacement: handleSpec horizontalPlacement
				verticalPlacement: handleSpec verticalPlacement.
	colorToUse _ Color colorFrom: handleSpec color.
	handle _ HaloHandleMorph new color: colorToUse.
	self addMorph: handle.
	handle morphBoundsInWorld: (Rectangle center: aPoint extent: self class handleSize asPoint).
	handleSpec iconSymbol ifNotNil: [ :iconName |
			form _ self class icons at: iconName ifAbsent: [self class perform: iconName].
			form ifNotNil: [
				icon _ ImageMorph new
					image: form;
					color: colorToUse makeForegroundColor;
					lock.
				handle addMorphFront: icon position: `0@0` ]].
	handle mouseUpSelector: #endInteraction.
	handle setBalloonText: handleSpec hoverHelp.
	^handle! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 16:04:44' prior: 16850943!
    basicBox
	| aBox minSide anExtent w |
	minSide _ 4 * self class handleSize.
	anExtent _ ((extent x + self class handleSize + 8) max: minSide) @
				((extent y + self class handleSize + 8) max: minSide).
	aBox _ Rectangle center: self morphBoundsInWorld center extent: anExtent.
	w _ self world ifNil: [ target world ].
	^ w
		ifNil:
			[ aBox ]
		ifNotNil:
			[ aBox intersect: (w viewBox insetBy: `8@8`) ]! !
!HaloMorph methodsFor: 'private' stamp: 'jmv 6/19/2017 15:52:32' prior: 16851149!
                    startGrow: evt with: growHandle
	"Initialize resizing of my target.  Launch a command representing it, to support Undo"

	| botRt |
	evt hand obtainHalo: self.	"Make sure the event's hand correlates with the receiver"
	self removeAllHandlesBut: growHandle.  "remove all other handles"
	botRt _ target morphPositionInWorld + target morphExtentInWorld.
	positionOffset _ (self world viewBox containsPoint: botRt)
		ifTrue: [evt eventPosition - botRt]
		ifFalse: [`0@0`]! !
!InnerHierarchicalListMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:36:31' prior: 16854885!
     itemFromPoint: aPoint
	"Return the list element (morph) at the given point or nil if outside"
	| ptY last |
	self hasSubmorphs ifFalse: [ ^nil ].
	(aPoint > `0@0` and: [ aPoint < extent ]) ifFalse: [ ^nil ].
	ptY _ aPoint y.
	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"
	self firstSubmorph morphPosition y > ptY ifTrue: [ ^nil ].
	last _ self lastSubmorph.
	last morphPosition y + last morphHeight < ptY ifTrue: [ ^nil ].
	"now use binary search"
	^self 
		findSubmorphBinary: [ :m |
			(m morphPosition y <= ptY and: [ m morphPosition y + m morphHeight >= ptY ])
				ifTrue: [ 0 ] "found"
				ifFalse: [ m morphPosition y + (m morphHeight // 2) > ptY ifTrue: [-1] ifFalse: [1]]]! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:10' prior: 16855151!
                      drawBackgroundForMulti: row on: aCanvas
	| selectionDrawBounds c |
	"shade the background darker, if this row is selected"
	selectionDrawBounds _ self drawBoundsForRow: row.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	c _ (selectedRow notNil and: [ row = selectedRow])
		ifTrue: [ Theme current listHighlightFocused: owner hasKeyboardFocus ]
		ifFalse: [ Theme current listMultiHighlightFocused: owner hasKeyboardFocus ].
	aCanvas fillRectangle: selectionDrawBounds color: c! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:15' prior: 16855170!
        drawHighlightOn: aCanvas
"Ademas, poner el mouse pointer de relojito si tarda... Detectarlo automaticamente, etc. Aunque no estoy seguro de como hacerlo... quizas colgar un cachito de codigo en un proceso de mayor prioridad, onda 'si pasa 1 segundo, y todavia no te resetee este flag, entonces pone el relojito'"
	| selectionDrawBounds |
	highlightedRow  ifNil: [ ^self ].
	highlightedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: highlightedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	aCanvas
		fillRectangle: selectionDrawBounds
		color: (Theme current listHighlightFocused: owner hasKeyboardFocus) duller! !
!InnerListMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:20' prior: 16855209!
   drawSelectionOn: aCanvas
	| selectionDrawBounds |
	selectedRow ifNil: [ ^self ].
	selectedRow = 0 ifTrue: [ ^self ].
	selectionDrawBounds _ self drawBoundsForRow: selectedRow.
	selectionDrawBounds _ selectionDrawBounds intersect: (`0@0` extent: extent).
	aCanvas
		fillRectangle: selectionDrawBounds
		color: (Theme current listHighlightFocused: owner hasKeyboardFocus)! !
!InnerTextMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:53:24' prior: 16855570!
                    drawOn: aCanvas
	"Draw the receiver on a canvas"

	false ifTrue: [ self debugDrawLineRectsOn: aCanvas ].  "show line rects for debugging"

	aCanvas
		textComposition: self textComposition
		bounds: (`0@0` extent: extent)
		color: color
		selectionColor: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!ResizeMorph methodsFor: 'as yet unclassified' stamp: 'jmv 6/19/2017 16:15:44' prior: 50360552!
   initialize
	super initialize.
	extent _ `400@300`.
	color _ Color white.
	grid _ `8@6`.
	gridLineWidth _ 2.
	gridColor _ Color black.
	selectionColor _ Color red! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:19' prior: 16844103!
                        createAcceptButton
	"create the [accept] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current acceptButton;
		 label: 'Accept';
		 action: #acceptClicked.
	result morphExtent: `6@2` * self sizeUnit.
	self addMorph: result position: `2@7.5` * self sizeUnit // 1.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:31' prior: 16844116!
createCancelButton
	"create the [cancel] button"
	| result |
	result _ PluggableButtonMorph new
		 model: self;
		 color: Theme current cancelButton;
		 label: 'Cancel';
		 action: #cancelClicked.
	result morphExtent: `6@2` * self sizeUnit.
	self addMorph: result position: `12@7.5` * self sizeUnit // 1.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:37' prior: 16844129!
                               createQueryTextMorph: queryString 
	"create the queryTextMorph"
	| result |
	result _ StringMorph new contents: queryString.
	result lock.
	result morphExtent: `24@2` * self sizeUnit.
	self addMorph: result position: `2@0.5` * self sizeUnit // 1.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:44' prior: 16844140!
                         createTextPaneAcceptOnCR: acceptBoolean
	"create the textPane"
	| result |

	self flag: #todo. "Integrate this method with the Theme system. --cbr"

	result _ TextModelMorph
				textProvider: self
				textGetter: #response
				textSetter: #response:
				selectionGetter: #selectionInterval.
	result hasUnacceptedEdits: true.
	result acceptOnCR: acceptBoolean.
	result morphExtent: `18@5` * self sizeUnit.
	self addMorph: result position: `1@2` * self sizeUnit.
	^ result! !
!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:03:48' prior: 16844169!
   initialize

	super initialize.
	extent _ `20@10` * self sizeUnit.
	responseUponCancel _ ''! !
!FillInTheBlankMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:48:53' prior: 16844226!
      drawOn: aCanvas

	Theme current roundWindowCorners
		ifTrue: [
			aCanvas
				roundRect: (`0@0` extent: extent)
				color: color
				radius: Theme current roundedWindowRadius ]
		ifFalse: [ super drawOn: aCanvas ]! !
!TranscriptMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:58:30' prior: 16938600!
               drawOn: aCanvas
	Transcript
		showOnDisplay: true;
		displayOn: form in: (`0@0` extent: extent).
	aCanvas image: form at: `0@0`.
	Transcript
		bounds: self morphBoundsInWorld;
		showOnDisplay: doImmediateUpdates.
	self updateWorkspace! !
!MenuLineMorph methodsFor: 'drawing' stamp: 'jmv 6/19/2017 15:54:11' prior: 16866232!
                            drawOn: aCanvas 
	| baseColor |
	baseColor _ owner color.
	aCanvas
		fillRectangle: (`0@0` corner: extent x @ (extent y / 2))
		color: baseColor twiceDarker.
			
	aCanvas
		fillRectangle: (0 @ (extent y / 2) corner: extent)
		color: baseColor twiceLighter! !
!MenuLineMorph methodsFor: 'initialization' stamp: 'jmv 6/19/2017 16:06:38' prior: 16866243!
initialize
	super initialize.
	extent _ `50 @ 2`! !
!MenuLineMorph methodsFor: 'geometry' stamp: 'jmv 6/19/2017 16:07:43' prior: 16866250!
                     minimumExtent

	^`10@2`! !
!WorldState methodsFor: 'update cycle' stamp: 'jmv 6/19/2017 15:59:45' prior: 50339595!
             tryDeferredUpdatingAndSetCanvas
        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, set a non-Disply canvas and answer false.."
	| properDisplay |
	
	"As this is the only sender of #deferUpdates: , this could be done in Morphic or image startup, and never efterwards..."
	(Display deferUpdates: true) ifNil: [
		"deferred updates not supported by the VM, do them in the image!!"
		self ensureNonDisplayCanvas.
		^ false].
	
	"if no canvas, or canvas was offscreen, from a platform that didnt support defers, then fix it"
	properDisplay _ canvas notNil and: [canvas drawsOnDisplay].
	properDisplay ifFalse: [
		world morphPosition: `0@0` extent: Display extent.
		self setCanvas: Display getCanvas.
	].
	^ true! !
!MorphicEvent methodsFor: 'dispatching' stamp: 'jmv 6/19/2017 15:54:47' prior: 16877833!
                   startDispatchFrom: aHand
	"double dispatch the event dispatch"
	"An event of an unknown type was sent. What shall we do?!!"

	Smalltalk beep. 
	self printString displayAt: `0@0`.
	self wasHandled: true! !
!MorphicCanvas methodsFor: 'accessing' stamp: 'jmv 6/19/2017 15:54:34' prior: 16877393!
                           newClipRect: aRectangleOrNil
	"aRectangle is in world coordinates.
	But ivar clipRect is relative to the form,
	For example, if we had previously been built like
		aCanvas on: someForm over: (100@100 extent 200@100)
	then our origin would be -100 @ -100.
	Then, a clipRect argument like (120@120 extent: 40@30) would mean affecting
	only (20@20 extent: 40@30) in our form"

	self setClipRect: (aRectangleOrNil
		ifNil: [ `0@0` corner: form extent ]
		ifNotNil: [ aRectangleOrNil translatedBy: self canvasOrigin ])! !
!MorphicCanvas methodsFor: 'morphic' stamp: 'jmv 6/19/2017 16:08:51' prior: 50360743!
     drawCurrentAsError
	"The morph (or one of its submorphs) had an error in its drawing method."
	| r w |
	r _ currentMorph morphLocalBounds.
	w _ r extent > `50@50`
		ifTrue: [ 6 ]
		ifFalse: [ 2 ].
	self
		frameAndFillRectangle: r
		fillColor: Color red
		borderWidth: w
		borderColor: Color yellow.
	self line: r topLeft to: r bottomRight-w width: w color: Color yellow.
	self line: r topRight -(w@0) to: r bottomLeft -(0@w)width: w color: Color yellow! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 6/19/2017 16:09:00' prior: 50360760!
                             drawStringEmbossed: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: aColor
	"Answer last affected pixel position
	Answer nil if nothing was done"

	aColor = Color black ifFalse: [ | topColor |
		topColor _ aColor alphaMixed: 0.25 with: Color black.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint
			font: fontOrNil
			color: topColor ].
	aColor = Color white ifFalse: [ | bottomColor |
		bottomColor _ aColor alphaMixed: 0.22 with: Color white.
		self
			drawString: aString
			from: firstIndex
			to: lastIndex
			at: aPoint  + `0@2`
			font: fontOrNil
			color: bottomColor ].
	^self
		drawString: aString
		from: firstIndex
		to: lastIndex
		at: aPoint  + `0@1`
		font: fontOrNil
		color: aColor! !
!MorphicCanvas methodsFor: 'drawing-text' stamp: 'jmv 6/19/2017 15:54:38' prior: 16877657!
            textComposition: aTextComposition bounds: boundsRect color: c selectionColor: sc
	| displayScanner leftInRun line boundsInWorld tl |

	tl _ boundsRect topLeft.
	boundsInWorld _ currentTransformation displayBoundsOfTransformOf: boundsRect.

	displayScanner _ MorphicScanner new
		defaultFont: aTextComposition defaultFont;
		text: aTextComposition textComposed
		foreground: c.
	displayScanner canvas: self.

	leftInRun _ 0.
	"Take clipRect into account. Extrememly fast scrolls and redraws of huge files (like .sources)"
	(aTextComposition lineIndexForPoint: (`0@0` max: (clipLeft@clipTop)- boundsInWorld origin))
		to: (aTextComposition lineIndexForPoint: (boundsInWorld extent min: (clipRight@clipBottom+1) - boundsInWorld origin))
		do: [ :i |
			line _ aTextComposition lines at: i.
			aTextComposition
				displaySelectionInLine: line
				on: self
				textTopLeft: tl
				selectionColor: sc.
			leftInRun _ displayScanner displayLine: line textTopLeft: tl leftInRun: leftInRun  ]! !
!MorphicCanvas class methodsFor: 'instance creation' stamp: 'jmv 6/19/2017 15:54:43' prior: 16877740!
                              onForm: aForm

	^ self basicNew
		initializeWith: aForm origin: `0@0`! !
!BitBltCanvas methodsFor: 'private' stamp: 'jmv 6/19/2017 15:45:38' prior: 16787053!
  fillRectangle: aRectangle tilingWith: aForm sourceRect: patternBox rule: aCombinationRule
	"aRectangle is in form coordinates, no transformation is done."
	| displayRectangle  additionalOffset clippedPort targetTopLeft clipOffset ex 
	targetBox savedMap top left |
	
	ex _ patternBox extent.
	ex x = 0 ifTrue: [ ^self ].
	ex y = 0 ifTrue: [ ^self ].
	displayRectangle _ currentTransformation displayBoundsOfTransformOf: aRectangle.

	"this is a bit of a kludge to get the form to be aligned where I *think* it should be.
	something better is needed, but not now"

	additionalOffset _ `0@0`.
	clippedPort _ port clippedBy: displayRectangle.
	targetTopLeft _ clippedPort clipRect topLeft truncateTo: ex.
	clipOffset _ displayRectangle topLeft - targetTopLeft.
	additionalOffset _ (clipOffset \\ ex) - ex.

	"do it iteratively"
	targetBox _ clippedPort clipRect.
	savedMap _ clippedPort colorMap.
	clippedPort sourceForm: aForm;
		fillColor: nil;
		combinationRule: aCombinationRule;
		sourceRect: patternBox;
		colorMap: (aForm colormapIfNeededFor: clippedPort destForm).
	top _ (targetBox top truncateTo: patternBox height) + additionalOffset y.
	left _  (targetBox left truncateTo: patternBox width) + additionalOffset x.

	left to: (targetBox right - 1) by: patternBox width do: [:x |
		top to: (targetBox bottom - 1) by: patternBox height do: [:y |
			clippedPort destOrigin: x@y; copyBits]].
	clippedPort colorMap: savedMap! !
!BitBltCanvas class methodsFor: 'cached forms' stamp: 'jmv 6/19/2017 15:45:51' prior: 50360832!
          steButtonForm: extent
	^self cachedForms
		at: { #steButton . extent }
		ifAbsentPut: [
			| form canvas |
			form _ Form extent: extent depth: 32.
			canvas _ form getCanvas.
			canvas
				roundRect: (`0@0` extent: extent)
				color: (Color gray: 0.4)
				radius: 4.
			canvas
				roundRect: (`1@1` extent: extent-2)
				color: Color white
				radius: 4
				gradientTop: 1.0
				gradientCenter: 0.73
				gradientBottom: 0.94
				gradient1Height: (extent y-8+1 max: extent y//2).
			form]! !
!BitBltCanvas class methodsFor: 'cached arrow forms' stamp: 'jmv 6/19/2017 16:01:13' prior: 50360909!
              buildArrowWith: insideForm borderForm: borderForm
	| extent translucentForm color insideSpec borderSpec border background alpha|
	"
	Display getCanvas
		image: (BitBltCanvas buildArrowWith: BitBltCanvas downInsideForm borderForm: BitBltCanvas downBorderForm)
		at: 20@20
	Display getCanvas
		image: (BitBltCanvas buildArrowWith:BitBltCanvas upInsideForm borderForm: BitBltCanvas upBorderForm)
		at: 40@20
	"
	extent _ insideForm extent - `1@2`.
	translucentForm _ Form extent: insideForm extent depth: 32.
	0 to: extent x-1 do: [ :x |
		0 to: extent y-1 do: [ :y |
			insideSpec _ insideForm colorAt: x@(y+1).
			borderSpec _ borderForm colorAt: x@(y+1).
			insideSpec = (Color r: 0.0 g: 0.0 b: 1.0)
				ifTrue: [ color _ Color transparent ]
				ifFalse: [
					borderSpec = (Color r: 1.0 g: 0.0 b: 0.0)
						ifTrue: [ color _ insideSpec ]
						ifFalse: [
							border _ x < (extent x//2)
								ifTrue: [Color white]
								ifFalse: [Color black].
							background _ borderForm colorAt: extent x@(y+1).
							alpha _ borderSpec red asFloat - background red / (border red - background red).
							color _ border alpha: (alpha min: 1 max: 0) ]].
			translucentForm colorAt: x@y put: color ]].
	^translucentForm! !
!TextComposition methodsFor: 'selection' stamp: 'jmv 6/19/2017 16:13:22' prior: 16931067!
 defaultCharacterBlock
	^ CharacterBlock
		stringIndex: 1
		text: model actualContents
		topLeft: lines first topLeft
		extent: `0 @ 0`
		textLine: lines first! !
!DifferenceFinder methodsFor: 'private' stamp: 'jmv 6/19/2017 16:02:44' prior: 16834082!
     maxLengthPoints
	| max points |
	max := self maxLength.
	max = 0 ifTrue: [^Array with: `0 @ 0`].
	points := OrderedCollection new.
	tally withIndexesDo: [:i :j :t | t = max ifTrue: [points add: i @ j]].
	^points! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3115-UseLiteralPoints-JuanVuletich-2017Jun19-16h29m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3115] on 20 June 2017 at 5:50:34 pm'!
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 6/20/2017 13:47:09' prior: 16919543!
    browseObsoleteMethodReferences
	"Open a browser on all referenced behaviors that are obsolete
		Smalltalk browseObsoleteMethodReferences
	Remember that if no methods reference obsoletes, but
		Smalltalk obsoleteBehaviors inspect
	still finds them, maybe they are referenced by ChangeSets!!
	"
	| list |
	list _ self obsoleteMethodReferences.
	self browseMessageList: list name:'Method referencing obsoletes' autoSelect: nil! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 6/20/2017 13:46:17' prior: 16919851!
                       obsoleteBehaviors
	"
	Smalltalk obsoleteBehaviors inspect
	Find all obsolete behaviors including meta classes
	"
	| obs |
	obs _ OrderedCollection new.
	Smalltalk garbageCollect.
	self allObjectsDo: [ :cl |
		(cl isBehavior and: [cl isObsolete]) ifTrue: [obs add: cl]].
	^ obs asArray! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 6/20/2017 13:46:10' prior: 16919891!
  obsoleteMethodReferences
	"
	Smalltalk obsoleteMethodReferences
	Smalltalk browseObsoleteMethodReferences
	Open a browser on all referenced behaviors that are obsolete"
	| obsClasses obsRefs references |
	references _ WriteStream on: Array new.
	obsClasses _ self obsoleteBehaviors.
	'Scanning for methods referencing obsolete classes' displayProgressAt: Sensor mousePoint
		from: 1 to: obsClasses size during: [ :bar |
	obsClasses keysAndValuesDo: [ :index :each |
		bar value: index.
		obsRefs _ self pointersTo: each except: obsClasses.
		obsRefs do: [ :ref |
			"Figure out if it may be a global"
			(ref isVariableBinding and: [ ref key isString "or Symbol" ]) ifTrue: [
				(self pointersTo: ref) do: [ :meth |
					(meth is: #CompiledMethod) ifTrue: [
						meth methodReference ifNotNil: [ :mref |
							(mref isValid and: [ mref compiledMethod == meth]) ifTrue: [
								references nextPut: mref ]]]]]]].
	].
	^references contents! !
!MethodReference methodsFor: 'queries' stamp: 'jmv 6/20/2017 13:30:02' prior: 16873082!
                       printOn: aStream
	"Print the receiver on a stream"

	super printOn: aStream.
	aStream
		space;
		nextPutAll: classSymbol.
	classIsMeta ifTrue: [ aStream nextPutAll: ' class' ].
	aStream
		nextPutAll: ' >> ';
		nextPutAll: methodSymbol! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3116-obsoleteMethodRefs-fix-JuanVuletich-2017Jun20-17h49m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3115] on 20 June 2017 at 5:51:43 pm'!
!Color methodsFor: 'conversions' stamp: 'jmv 6/20/2017 17:46:14' prior: 50353450!
                   pixelValueForDepth: d
	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"
	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."
	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8 and less than 32 (no Indexed colors, no real alpha), black maps to the darkest possible blue.
	Note that 
		Color transparent class = TranslucentColor
	this special case is handled in TranslucentColor >> #pixelValueForDepth:
	"

	| bitBltFakeBlack val |
	"Most common case"
	"eight bits per component; top 8 bits set to all ones (opaque alpha)"
	d = 32 ifTrue: [
		^ 16rFF000000 bitOr:
			((((self at: 1) * 255.999) truncated bitShift: 16) bitOr:
			((((self at: 2) * 255.999) truncated bitShift: 8) bitOr: 
			(((self at: 3) * 255.999) truncated))) ].

"Faster in 32 bit systems, but slower in 64 bits"
"	d = 32 ifTrue: [
		val _ LargePositiveInteger new: 4.
		val at: 3 put: ((self at: 1) * 255.999) truncated.
		val at: 2 put: ((self at: 2)  * 255.999) truncated.
		val at: 1 put: ((self at: 3)  * 255.999) truncated.
		val at: 4 put: 16rFF.
		^ val normalize]."

	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"
	d < 8 ifTrue: [
		d = 4 ifTrue: [^ self closestPixelValue4].
		d = 2 ifTrue: [^ self closestPixelValue2].
		d = 1 ifTrue: [^ self closestPixelValue1]].

	"For the depth 16, pixelValue = 0 means transparent, black is represented as 16r8000 (rgb=0, pixelvalue !!= 0)."
	(d = 16) | (d = 15) ifTrue: [
		"five bits per component; top bits ignored"
		val _ ((self red * 31) rounded bitShift: 10) bitOr:
			(((self green * 31) rounded bitShift: 5) bitOr: 
			((self blue * 31) rounded)).
		^ val = 0
			ifTrue: [d = 16 ifTrue: [16r8000] ifFalse: [1]]
			ifFalse: [val]].

	"For the rest of the depths, pixelValue = 0 means transparent, and darkest blue is considered to be black."
	bitBltFakeBlack := 1.  "closest black that is not transparent in RGB - Not for depths <=8 (Indexed) or = 32 (RGBA)"
	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"
		val _ ((self red * 15) rounded bitShift: 8) bitOr:
			(((self green * 15) rounded bitShift: 4) bitOr: 
			((self blue * 15) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"
		val _ ((self red * 7) rounded bitShift: 6) bitOr:
			(((self green * 7) rounded bitShift: 3) bitOr: 
			((self blue * 7) rounded)).
		^ val = 0 ifTrue: [bitBltFakeBlack] ifFalse: [val]].

	self error: 'unknown pixel depth: ', d printString! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3117-pixelValueForDepth-speedup-JuanVuletich-2017Jun20-17h50m-jmv.1.cs.st----!

----SNAPSHOT----#(20 June 2017 5:55:49.418702 pm) Cuis5.0-3117.image priorSource: 400330!

----QUIT----#(20 June 2017 5:56:01.546904 pm) Cuis5.0-3117.image priorSource: 1058175!

----STARTUP----#(27 June 2017 7:10:33.593307 am) as /root/PayloadSoftware/Cuis-Smalltalk-Dev/Cuis5.0-3117.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3117] on 20 June 2017 at 11:19:24 pm'!
!WorldState methodsFor: 'initialization' stamp: 'jmv 6/20/2014 20:24:55' prior: 16945777!
     clearWaitDelay
	waitDelay ifNotNil: [
		waitDelay unschedule.
		waitDelay _ nil ].
	"Needed if for some reason Cuis is started with an earlier DateTime than the image was saved.
	Might happen, especially on RasPi or other systems without an RTC"
	lastCycleTime _ Time localMillisecondClock.
	lastAlarmTime _ 0.! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3118-FixHangWhenStartupInThePast-JuanVuletich-2017Jun20-23h18m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3103] on 18 June 2017 at 5:34:41 am'!
!Browser methodsFor: 'class comment pane' stamp: 'pb 6/18/2017 05:34:23' prior: 16791499!
                          newClassComment: aText
	"The user has just entered aText.
	It may be all red (a side-effect of replacing the default comment), so remove the color if it is."
	| theClass |
	theClass _ self selectedClassOrMetaClass theNonMetaClass.
	theClass ifNotNil: [
		theClass classComment: aText asString ].
	self changed: #classCommentText.
	^ true! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3119-Class-comment-editor-fix-PhilBellalouna-2017Jun18-05h34m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3119] on 22 June 2017 at 12:54:43 pm'!
!Color methodsFor: 'as yet unclassified' stamp: 'jmv 6/22/2017 12:54:10'!
                convertToCurrentVersion: varDict refStream: smartRefStrm

	"subclasses should implement if they wish to convert old instances to modern ones"
	self size = 0 ifTrue: [
		^ Color new copyFrom: (varDict at: 'floatRGB') ].
	^ self! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3120-MigrateColorInstancesInSmartRefStream-JuanVuletich-2017Jun22-12h43m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3120] on 26 June 2017 at 8:03:37 pm'!
!ReadStream methodsFor: 'accessing' stamp: 'jmv 6/26/2017 19:34:17'!
                         readInto: byteArray startingAt: startIndex count: count
	"Read n objects into the given collection. 
	Return aCollection or a partial copy if less than
	n elements have been read."
	| max |
	max _ (readLimit - position) min: count.
	byteArray 
		replaceFrom: startIndex 
		to: startIndex+max-1
		with: collection
		startingAt: position+1.
	position _ position + max.
	^max! !

----End fileIn of /root/PayloadSoftware/Cuis-Smalltalk-Dev/CoreUpdates/3121-ReadStream-readInto-JuanVuletich-2017Jun26-19h32m-jmv.1.cs.st----!

----SNAPSHOT----#(27 June 2017 7:10:42.11782 am) Cuis5.0-3121.image priorSource: 1058266!

----QUIT----#(27 June 2017 7:10:56.089378 am) Cuis5.0-3121.image priorSource: 1061095!

----STARTUP----#(18 July 2017 10:29:00.631546 am) as /home/juan/Rectifier/Cuis-Smalltalk-Dev/Cuis5.0-3121.image!


'From Cuis 5.0 of 7 November 2016 [latest update: #3121] on 6 July 2017 at 3:13:37 am'!
!ScrollBar methodsFor: 'access' stamp: 'pb 7/6/2017 02:44:45'!
                          scrollValue
	^ value! !
!ScrollBar methodsFor: 'model access' stamp: 'pb 7/6/2017 02:53:19'!
   internalScrollValue: newValue
	"Called internally for propagation to model"
	self scrollValue: newValue.
	setValueSelector ifNotNil: [
		model perform: setValueSelector with: value ]! !
!ScrollBar methodsFor: 'model access' stamp: 'pb 7/6/2017 02:45:15'!
 scrollValue: newValue
	"Drive the slider position externally..."
	value _ newValue min: 1.0 max: 0.0.
	self computeSlider! !
!ProgressBarMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:42:04'!
                          progressValue
	^value! !
!ProgressBarMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:42:12'!
                              progressValue: aValue
	value _ aValue.
	self redrawNeeded! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 10/10/2015 23:26' prior: 16891768!
       fileInAnnouncing: announcement
	"This is special for reading expressions from text that has been formatted 
	with exclamation delimitors. The expressions are read and passed to the 
	Compiler. Answer the result of compilation.  Put up a progress report with
     the given announcement as the title."

	| val chunk |
	announcement 
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self size
		during: [ :bar | 
			[ self atEnd ] whileFalse: [
					bar value: self position.
					self skipSeparators.
					
					[
						val := (self peekFor: $!!) 
								ifTrue: [
									chunk := self nextChunk.
									"These are the ones that should do nothing, 
									because next line is a doit that does the stuff
									(or because it is handled elsewhere)"
									(chunk beginsWith: 'description:  ')
									| (chunk beginsWith: 'provides: ')
									| (chunk beginsWith: 'requires: ')
									| (chunk beginsWith: 'classDefinition: ')
									| (chunk beginsWith: 'classRemoval: ')
									| (chunk beginsWith: 'methodRemoval: ')
									| (chunk beginsWith: 'classMoveToSomePackage: ')
									| (chunk beginsWith: 'methodMoveToSomePackage: ')
										ifFalse: [(Compiler evaluate: chunk logged: false) scanFrom: self]]
								ifFalse: [
									chunk := self nextChunk.
									self checkForPreamble: chunk.
									[ Compiler evaluate: chunk logged: true ]
										on: Error
										do: [ :ex |
											ex print.
											('while evaluating: ', chunk) print.
											ex pass ]
										]] 
							on: InMidstOfFileinNotification
							do: [ :ex | ex resume: true ] ].
			].
	"Note:  The main purpose of this banner is to flush the changes file."
	Smalltalk logChange: '----End fileIn of ' , self name , '----'.
	^val! !
!PositionableStream methodsFor: 'gui' stamp: 'pb 7/6/2017 02:51:46' prior: 16892012!
           untilEnd: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :bar |
			[ self atEnd ] whileFalse: [
				bar scrollValue: self position.
				aBlock value ]]! !
!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'pb 7/6/2017 02:52:33' prior: 16896176!
          testInnermost

	"test the progress code WITHOUT special handling"

	^'Now here''s some Real Progress'
		displayProgressAt: Sensor mousePoint
		from: 0 
		to: 10
		during: [ :bar |
			1 to: 10 do: [ :x | 
				bar scrollValue: x.
				(Delay forMilliseconds: 500) wait.
				x = 5 ifTrue: [1/0].	"just to make life interesting"
			].
			'done'
		].

! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'pb 7/6/2017 02:46:41' prior: 16889660!
       hSetScrollDelta
	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."
	| range delta w |
	
	delta _ self scrollDeltaWidth * 1.0.		"avoid Fraction arithmetic"
	range _ self hLeftoverScrollRange.
	range = 0 ifTrue: [
		^hScrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; internalScrollValue: 0 ].

	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."
	w _ self viewableWidth * 1.0.		"avoid Fraction arithmetic"
	hScrollBar scrollDelta: delta / range pageDelta: w - delta / range.
	hScrollBar interval: w / self hTotalScrollRange.
	hScrollBar internalScrollValue: hScrollBar scrollValue! !
!PluggableScrollPane methodsFor: 'geometry' stamp: 'pb 7/6/2017 02:48:25' prior: 16889801!
                         vSetScrollDelta
	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."
	| range delta h |
	
	delta _ self scrollDeltaHeight * 1.0.	"avoid Fraction arithmetic"
	range _ self vLeftoverScrollRange.
	range = 0 ifTrue: [
		^ scrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; internalScrollValue: 0 ].

	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."
	h _ self viewableHeight * 1.0. 		"avoid Fraction arithmetic"
	scrollBar scrollDelta: delta / range pageDelta: h - delta / range.
	scrollBar interval: h / self vTotalScrollRange.
	scrollBar internalScrollValue: scrollBar scrollValue! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:48:00' prior: 16889930!
                          hideOrShowScrollBars

	"Assume for a moment we don't need an horizontal scrollbar"
	self hHideScrollBar.

	"Add or remove vertical scrollbar, asuming for a monent there's no horizontal scrollbar,
	to determine need of horizontal scrollbar..."
	self vIsScrollbarNeeded
		ifTrue: [ self vShowScrollBar ]
		ifFalse: [ self vHideScrollBar ].

	"If we need an horizontal scrollbar, add it."
	self hIsScrollbarNeeded ifTrue: [
		self hShowScrollBar.

		"If horizontal scrollbar is needed, maybe vertical scrollbar will be needed too (even if we previously thoutht it wouldn't be needed)."	
		"Note that there is no chance of modifying the need of horizontal scrollbar: it was already needed. Therefore, there is no circularity here."
		self vIsScrollbarNeeded  ifTrue: [
			self vShowScrollBar ]].

	"Ensure that if no scrollbars are needed, whole contents are visible"
	self vIsScrollbarShowing ifFalse: [
		scrollBar internalScrollValue: 0 ].
	self hIsScrollbarShowing ifFalse: [
		hScrollBar internalScrollValue: 0 ].

	self updateScrollBarsBounds! !
!PluggableScrollPane methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:51:24' prior: 16889965!
            scrollBy: delta
	"Move the contents in the direction delta."

	| newYoffset r newXoffset |
	
	"Set the offset on the scroller"
	newYoffset _ self scrollerOffset y - delta y max: 0.
	newXoffset _ self scrollerOffset x - delta x max: 0.
	
	self scrollerOffset: newXoffset@ newYoffset.

	"Update the scrollBars"
	(r _ self vLeftoverScrollRange) = 0
		ifTrue: [ scrollBar scrollValue: 0.0 ]
		ifFalse: [ scrollBar scrollValue: newYoffset asFloat / r ].
	(r _ self hLeftoverScrollRange) = 0
		ifTrue: [ hScrollBar scrollValue: 0.0 ]
		ifFalse: [ hScrollBar scrollValue: newXoffset asFloat / r ]! !
!PluggableListMorph methodsFor: 'selection' stamp: 'pb 7/6/2017 02:47:04' prior: 16889020!
                    scrollSelectionIntoView
	"make sure that the current selection is visible"
	| row r |
	row _ self getCurrentSelectionIndex.
	row = 0 
		ifTrue: [
			"Value is 0, but we need to propagate it to model"
			scrollBar internalScrollValue: scrollBar scrollValue ]
		ifFalse: [
			self flag: #jmvVer2.
			r _ self listMorph drawBoundsForRow: row.
			r _ ((self listMorph externalize: r origin) extent: r extent).
			self scrollToShow: r ]! !
!PluggableListMorphOfMany methodsFor: 'events' stamp: 'pb 7/6/2017 02:56:44' prior: 50362985!
               mouseMove: aMouseMoveEvent localPosition: localEventPosition
	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"

	| oldIndex oldVal row |
	row _ (localEventPosition y < 0 and: [ scrollBar scrollValue > 0.0 ])
		ifTrue: [
			scrollBar scrollUp: 1.
			"Leave at least one visible item unaffected, for better visual feedback to the user."
			(self rowAtLocation: `0@0`) + 2 ]
		ifFalse: [
			(localEventPosition y > extent y and: [ scrollBar scrollValue < 1.0 ])
				ifTrue: [
					scrollBar scrollDown: 1.
					"Leave at least one visible item unaffected, for better visual feedback to the user."
					(self rowAtLocation: 0@extent y) - 3 ]
				ifFalse: [ self rowAtLocation: localEventPosition ]].
	row = 0 ifTrue: [ ^ self ].

	"No change if model is locked"
	self owningWindow ifNotNil: [ :w |
		w okToChange ifFalse: [^ self]].

	dragOnOrOff ifNil: [
		"Was not set at mouse down, which means the mouse must have gone down in an area where there was no list item"
		dragOnOrOff _ (self listSelectionAt: row) not.
		dragStartRow _ row ].

	"Set meaning for subsequent dragging of selection"
	oldIndex _ self getCurrentSelectionIndex.
	oldIndex ~= 0 ifTrue: [ oldVal _ self listSelectionAt: oldIndex ].

	"Set or clear new primary selection (listIndex)"
	dragOnOrOff 
		ifTrue: [ self changeModelSelection: row ]
		ifFalse: [ self changeModelSelection: 0 ].

	"Need to restore the old one, due to how model works, and set new one."
	oldIndex ~= 0 ifTrue: [ self listSelectionAt: oldIndex put: oldVal ].
	
	"Select all in between if drag was too fast"
	"self listSelectionAt: row put: dragOnOrOff."
	(row min: dragStartRow) to: (row max: dragStartRow) do: [ :r |
		self listSelectionAt: r put: dragOnOrOff ]! !
!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:48:48' prior: 16904721!
                     scrollByPage
	"Scroll automatically while mouse is down"
	nextPageDirection
		ifTrue: [self internalScrollValue: (value + pageDelta min: 1.0)]
		ifFalse: [self internalScrollValue: (value - pageDelta max: 0.0)]
! !
!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:48:59' prior: 16904734!
                       scrollDown: count
	self internalScrollValue: (value + (scrollDelta * count) + 0.000001 min: 1.0)! !
!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:49:09' prior: 16904739!
          scrollTo: handPositionRelativeToSlider
	| v handPositionRelativeToUs |
	grabPosition ifNotNil: [
		handPositionRelativeToUs _ slider externalize: handPositionRelativeToSlider.
		v _ (self isHorizontal
			ifTrue: [ handPositionRelativeToUs x - grabPosition x ]
			ifFalse: [ handPositionRelativeToUs y - grabPosition y ])
				- borderWidth - self buttonExtent * 1.0
					/ self freeSliderRoom.
		self internalScrollValue: v ]! !
!ScrollBar methodsFor: 'scrolling' stamp: 'pb 7/6/2017 02:49:21' prior: 16904758!
  scrollUp: count
	self internalScrollValue: (value - (scrollDelta * count) - 0.000001 max: 0.0)! !
!ProgressBarMorph methodsFor: 'menu' stamp: 'pb 7/6/2017 02:57:29' prior: 16896049!
          changeProgressValue: evt
	| answer |
	answer _ FillInTheBlankMorph
		request: 'Enter new value (0 - 1.0)'
		initialAnswer: self progressValue contents asString.
	answer isEmptyOrNil ifTrue: [^ self].
	self progressValue: answer asNumber! !
!ProgressMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:57:41' prior: 16896233!
                          done
	^progress progressValue! !
!ProgressMorph methodsFor: 'accessing' stamp: 'pb 7/6/2017 02:52:47' prior: 16896236!
         done: amountDone
	progress progressValue: ((amountDone min: 1.0) max: 0.0)! !
!InnerTextMorph methodsFor: 'editing' stamp: 'pb 7/6/2017 02:47:26' prior: 50336501!
                             acceptContents
	"The message is sent when the user hits return or Cmd-S.
	Accept the current contents and end editing."
	"Inform the model of text to be accepted, and return true if OK."

	| accepted prevSelection prevScrollValue |
	
	prevSelection _ self editor selectionInterval copy.
	prevScrollValue _ owner verticalScrollBar scrollValue.
	
	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not]) ifTrue: [self flash. ^true].
	(self hasEditingConflicts and: [ self confirmAcceptAnyway not ]) ifTrue: [self flash. ^false].
	
	accepted _ model acceptContentsFrom: owner.
	"During the step for the browser, updatePaneIfNeeded is called, and 
		invariably resets the contents of the code-holding PluggableTextMorph
		at that time, resetting the cursor position and scroller in the process.
		The following line forces that update without waiting for the step,
 		then restores the cursor and scrollbar"
	
	"some implementors of acceptContentsFrom: answer self :("
	^accepted == true 
		ifTrue: [
			model refetch.
			self editor selectFrom: prevSelection first to: prevSelection last.
			WorldState addDeferredUIMessage: [
				self world ifNotNil: [ :w | w activeHand newKeyboardFocus: self ].
				owner verticalScrollBar internalScrollValue: prevScrollValue].
			true]
		ifFalse: [ false ]! !

ProgressBarMorph removeSelector: #value!

ProgressBarMorph removeSelector: #value!

ProgressBarMorph removeSelector: #value:!

ProgressBarMorph removeSelector: #value:!

ScrollBar removeSelector: #setValue:!

ScrollBar removeSelector: #setValue:!

ScrollBar removeSelector: #value!

ScrollBar removeSelector: #value!

ScrollBar removeSelector: #value:!

ScrollBar removeSelector: #value:!

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3122-Morphs-Distinct-value-Methods-PhilBellalouna-2017Jul06-02h42m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3121] on 15 July 2017 at 10:07:51 pm'!
!UpdatingStringMorph methodsFor: 'stepping' stamp: 'pb 7/15/2017 22:07:40' prior: 50337159!
              stepAt: millisecondSinceLast

	self contents: (target perform: getSelector) asString! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3123-UpdatingStringMorph-Squeak-compatibility-PhilBellalouna-2017Jul15-22h07m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3121] on 15 July 2017 at 11:19:17 pm'!
!PluggableButtonMorph methodsFor: 'as yet unclassified' stamp: 'pb 7/15/2017 23:15:35'!
                morphExtent
	"Use extent if it has already been manually set, otherwise try to set it by computing from the label text and font, otherwise try using the icon extent, or finally fall back to the default value."
	^ extent ifNil: [
		extent := (self fontToUse notNil and: [ label notNil ])
			ifTrue: [ "Add a bit of padding"
				(self fontToUse widthOfString: label) + 10 @ (self fontToUse height + 10) ]
			ifFalse: [
				icon
					ifNil: [ `20@15` ]
					ifNotNil: [ icon extent ]]].! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'pb 7/15/2017 22:34:12' prior: 16899252!
                              morphHeight

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	^ self morphExtent y! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'pb 7/15/2017 22:34:52' prior: 16899265!
                              morphPosition: newPos extent: newExtent
	"Change the position of this morph. Argument is in owner's coordinates."

	| oldBoundsInWorld someChange |

	"Ask for the old bounds before updating them, but ask for repair only if extent or position has really changed."
	oldBoundsInWorld _ self morphBoundsInWorld.
	someChange _ false.
	(location isTranslation: newPos) ifFalse: [
		location _ location withTranslation: newPos.
		someChange _ true ].

	self morphExtent = newExtent ifFalse: [
		(self privateExtent: newExtent) ifTrue: [
			someChange _ true ]].

	someChange ifTrue: [
		"Ask for the old bounds before updating them, but ask for repair only if extent or position has really changed."
		oldBoundsInWorld ifNotNil: [
			self invalidateDisplayRect: oldBoundsInWorld from: nil ].
		self someSubmorphPositionOrExtentChanged.
		owner ifNotNil: [ owner someSubmorphPositionOrExtentChanged ].
		self redrawNeeded ]! !
!RectangleLikeMorph methodsFor: 'geometry' stamp: 'pb 7/15/2017 22:34:20' prior: 16899296!
              morphWidth

"Ensure everybody wants our coordinates!!"
	self flag: #jmvVer2.
	^ self morphExtent x! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'pb 7/15/2017 22:40:30' prior: 50362830!
                              draw3DLookOn: aCanvas

	| borderStyleSymbol c |
	borderStyleSymbol _ self isPressed ifFalse: [ #raised ] ifTrue: [ #inset ].
	c _ color.
	self mouseIsOver ifTrue: [ c _ c  lighter ].
	aCanvas
		fillRectangle: (`0@0` extent: self morphExtent)
		color: c
		borderWidth: borderWidth
		borderStyleSymbol: borderStyleSymbol
		baseColorForBorder: c.

	self drawRegularLabelOn: aCanvas! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'pb 7/15/2017 22:40:17' prior: 16888097!
      drawEmbossedLabelOn: aCanvas

	| availableW center colorForLabel f l labelMargin targetSize w x y |
	label ifNotNil: [
		colorForLabel _ Theme current buttonLabel.
		self isPressed
			ifFalse: [
				self mouseIsOver
					ifFalse: [ colorForLabel _ colorForLabel adjustSaturation: -0.10 brightness: 0.10 ]]
			ifTrue: [ colorForLabel _ colorForLabel adjustSaturation: 0.0 brightness: -0.07 ].
		f _ self fontToUse.
		center _ self morphExtent // 2.
		labelMargin _ 3.
		w _ f widthOfString: label.
		availableW _ self morphExtent x - labelMargin - labelMargin.
		availableW >= w
			ifTrue: [
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				targetSize _ label size * availableW // w.
				l _ label squeezedTo: targetSize.
				(f widthOfString: l) > availableW ifTrue: [
					targetSize _ targetSize - 1.
					l _ label squeezedTo: targetSize ]].
		
		w _ f widthOfString: l.
		x _ center x - (w // 2).
		y _ center y - (f height // 2).
		aCanvas
			drawString: l
			at: x@y
			font: f
			color: colorForLabel
			embossed: true ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'pb 7/15/2017 22:39:57' prior: 16888142!
                       drawRegularLabelOn: aCanvas

	| w f center x y  availableW l labelMargin |

	f _ self fontToUse.
	center _ self morphExtent // 2.

	label ifNotNil: [
		labelMargin _ 4.
		w _ f widthOfString: label.
		availableW _ self morphExtent x - labelMargin - labelMargin - 1.
		availableW >= w
			ifTrue: [
				x _ center x - (w // 2).
				l _ label ]
			ifFalse: [
				x _ labelMargin.
				l _ label squeezedTo: (label size * availableW / w) rounded ].
		y _ center y - (f height // 2).
		self isPressed ifTrue: [
			x _ x + 1.
			y _ y + 1 ].
		aCanvas
			drawString: l
			at: x@y
			font: f
			color: Theme current buttonLabel ]! !
!PluggableButtonMorph methodsFor: 'drawing' stamp: 'pb 7/15/2017 22:39:34' prior: 50362845!
                   drawRoundGradientLookOn: aCanvas
	| r colorForButton rect bottomFactor topFactor |

	self isPressed
		ifFalse: [
			topFactor _ Theme current buttonGradientTopFactor.
			bottomFactor _ Theme current buttonGradientBottomFactor.
			self mouseIsOver
				ifTrue: [	
					colorForButton _ Color h: color hue s: color saturation * 1.3 v: color brightness * 0.9 ]
				ifFalse: [
					colorForButton _ color ]]
		ifTrue: [
			topFactor _ Theme current buttonGradientBottomFactor.
			bottomFactor _ Theme current buttonGradientTopFactor.
			colorForButton _ color adjustSaturation: 0.1 brightness: -0.1 ].

	colorForButton ifNotNil: [
		r _ Theme current roundedButtonRadius.
		Theme current useButtonGradient
			ifTrue: [
				rect _ (`0@0` extent: self morphExtent) insetBy: `1@3`.
				aCanvas
					roundRect: rect
					color: colorForButton
					radius: r
					gradientTop: topFactor
					gradientBottom: bottomFactor
					gradientHeight: Theme current buttonGradientHeight ]
			ifFalse: [
				rect _ (`0@0` extent: self morphExtent) insetBy: `1@3`.
				aCanvas roundRect: rect color: colorForButton radius: r ]
		].

	Theme current embossedButtonLabels
		ifTrue: [ self drawEmbossedLabelOn: aCanvas ]
		ifFalse: [ self drawRegularLabelOn: aCanvas ]! !
!PluggableButtonMorph methodsFor: 'initialization' stamp: 'pb 7/15/2017 22:36:46' prior: 50362887!
                               initialize
	"initialize the state of the receiver"
	super initialize.

	roundButtonStyle := nil.	"nil: honor Theme. true: draw as round button. false: draw as classic 3d border square button"
	model := nil.
	getStateSelector := nil.
	actionSelector := nil.
	isPressed := false.
	mouseIsOver := false.
	actWhen := #buttonUp.
	"We are overriding any value populated in extent by our superclass with nil so we know to perform the inital morph extent calculation"
	extent := nil! !
!PluggableButtonMorph methodsFor: 'private' stamp: 'pb 7/15/2017 22:36:28' prior: 50337971!
      magnifiedIcon
	| factor magnifiedExtent w h |

	icon ifNil: [ ^nil ].
	magnifiedIcon ifNil: [
		magnifiedIcon := icon.
		w := icon width.
		h := icon height.
		w*h = 0 ifFalse: [
			factor _ 1.0 * self morphExtent x / w min: 1.0 * self morphExtent y / h.
			(factor < 1 or: [ factor > 1.7 and: [self isRoundButton]]) ifTrue: [
				magnifiedExtent := (icon extent * factor) rounded.
				magnifiedIcon := icon magnifyTo: magnifiedExtent ]]].
	^magnifiedIcon! !
!PluggableButtonMorph methodsFor: 'geometry testing' stamp: 'pb 7/15/2017 22:38:44' prior: 50362901!
                morphContainsPoint: aLocalPoint

	| iconOrigin |
	((`0@0` extent: self morphExtent) containsPoint: aLocalPoint) ifFalse: [ ^false ].
	^ self isOrthoRectangularMorph or: [
		magnifiedIcon isNil or: [
			iconOrigin := self morphExtent - magnifiedIcon extent // 2.
			(magnifiedIcon isTransparentAt: (aLocalPoint - iconOrigin) rounded) not ]]! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3124-PluggableButtonMorph-initial-extent-PhilBellalouna-2017Jul15-22h29m-pb.2.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3121] on 16 July 2017 at 3:33:18 pm'!
!Morph methodsFor: 'events' stamp: 'pb 7/16/2017 15:06:53'!
                   mouseHover: aMouseMoveEvent localPosition: localEventPosition
	"Handle a mouse move event.
	This message will only be sent to Morphs that answer true to #handlesMouseHover for events that have not been previously handled.
	We can query aMouseMoveEvent to know about pressed mouse buttons."
	"Allow instances to dynamically use properties for handling common events."
	self
		valueOfProperty: #mouseHover:localPosition:
		ifPresentDo: [ :handler |
			handler
				value: aMouseMoveEvent
				value: localEventPosition ].! !
!Morph methodsFor: 'event handling testing' stamp: 'pb 7/16/2017 15:00:51'!
           handlesMouseHover
	"Do I want to receive unhandled mouseMove events when the button is up and the hand is empty?  The default response is false."
	"Use a property test to allow individual instances to specify this."
	^ self hasProperty: #handlesMouseHover.! !
!Morph methodsFor: 'events-processing' stamp: 'pb 7/16/2017 15:31:38' prior: 16875080!
     processMouseOver: aMouseEvent localPosition: localEventPosition
	"System level event handling."
	 self hasMouseFocus ifTrue: [
		"Got this directly through #handleFocusEvent: so check explicitly"
		(self containsPoint: localEventPosition event: aMouseEvent) ifFalse: [
			^self ]].
	aMouseEvent hand noticeMouseOver: self event: aMouseEvent.
	"Open question: should any unhandled mouse move events be filtered out? (i.e. should mouseHover:localPosition: be called when a mouse button is pressed but the morph doesn't have mouse button handlers?  Essentially, what are the limits of what is considered 'hovering'?"
	(self handlesMouseHover and: [aMouseEvent wasHandled not]) ifTrue: [
		self
			mouseHover: aMouseEvent
			localPosition: localEventPosition ].! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3125-Morph-hovering-PhilBellalouna-2017Jul16-15h00m-pb.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3122] on 17 July 2017 at 3:52:45 pm'!
!ChangeList methodsFor: 'scanning' stamp: 'jmv 7/17/2017 15:44:04' prior: 16795940!
              scanFile: aFile from: startPosition to: stopPosition

	file _ aFile.
	changeList _ OrderedCollection new.
	list _ OrderedCollection new.
	listIndex _ 0.
	file position: startPosition.
	'Scanning ', aFile localName, '...'
		displayProgressAt: Sensor mousePoint
		from: startPosition to: stopPosition
		during: [ :barBlock |
			[file position < stopPosition] whileTrue: [ | prevChar |
				barBlock value: file position.
				[file atEnd not and: [file peek isSeparator]]
					whileTrue: [prevChar _ file next].
				(file peekFor: $!!)
					ifTrue: [
						"A line starting with $!! means a specific ChangeRecord type"
						(prevChar notNil and: [ prevChar isLineSeparator ])
							ifTrue: [self scanSpecificChangeRecordType]]
					ifFalse: [
						"Otherwise, interpret it with #doIt:"
						| itemPosition item |
						itemPosition _ file position.
						item _ file nextChunk.
						item size > 0 ifTrue: [
							self
								addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)
								text: 'do it: ' , (item contractTo: 160)]]]].
	self clearSelections! !
!ClassBuilder methodsFor: 'private' stamp: 'jmv 7/17/2017 15:48:14' prior: 16803943!
                  informUserDuring: aBlock
	self class isSilent ifTrue:[^aBlock value].
	Utilities informUserDuring:[:barBlock|
		progress _ barBlock.
		aBlock value].
	progress _ nil.! !
!Integer class methodsFor: 'prime numbers' stamp: 'jmv 7/17/2017 15:44:55' prior: 16861068!
                          verbosePrimesUpTo: max do: aBlock
	"Integer verbosePrimesUpTo: SmallInteger maxVal" "<- heh, heh"
	"Compute primes up to max, but be verbose about it"
	| lastTime |
	lastTime := Time localMillisecondClock.
	Utilities informUserDuring: [ :barBlock|
		barBlock value:'Computing primes...'.
		self primesUpTo: max do: [ :prime| | nowTime |
			aBlock value: prime.
			nowTime := Time localMillisecondClock.
			(nowTime - lastTime > 1000) ifTrue:[
				lastTime := nowTime.
				barBlock value: 'Last prime found: ', prime printString]]].! !
!LookupKey methodsFor: 'bindings' stamp: 'jmv 7/17/2017 15:45:04' prior: 16865388!
                      recompileBindingsAnnouncing: aBool
	"Make the receiver (a global read-write binding) be a read-only binding"
	aBool ifTrue:[
		Utilities informUserDuring: [ :barBlock |
			(Smalltalk allCallsOn: self) do: [ :mref | 
				barBlock value: 'Recompiling ', mref stringVersion.
				mref actualClass recompile: mref methodSymbol ].
		].
	] ifFalse:[
		(Smalltalk allCallsOn: self) do: [ :mref |
			mref actualClass recompile: mref methodSymbol ]
	]! !
!SequenceableCollection methodsFor: 'gui' stamp: 'jmv 7/17/2017 15:45:17' prior: 16906997!
        do: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :barBlock |
			self withIndexDo: [ :each :i |
				barBlock value: i.
				aBlock value: each]]! !
!String methodsFor: 'displaying' stamp: 'jmv 7/17/2017 15:41:46' prior: 16917058!
                  displayProgressAt: aPoint from: minVal to: maxVal during: workBlock
	"Display this string as a caption over a progress bar while workBlock is evaluated.

EXAMPLE (Select next 6 lines and Do It)

'Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 100
	during: [:barBlock |
		1 to: 100 do: [:x | 
			(Delay forMilliseconds: 10) wait.
			barBlock value: x.]].

['Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 100
	during: [:barBlock |
	1 to: 100 do: [:x | barBlock value: x.
			(Delay forMilliseconds: 100) wait]].] fork
	
['Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 10
	during: [:barBlock |
	1 to: 30 do: [:x | barBlock value: x \\ 11.
			(Delay forMilliseconds: 100) wait]]] fork

'Now here''s some Real Progress'
	displayProgressAt: Sensor mousePoint
	from: 0 to: 10
	during: [:barBlock |
	1 to: 30 do: [:x | barBlock value: nil.
			(Delay forMilliseconds: 200) wait]].

HOW IT WORKS (Try this in any other language :-)
Since your code (the last 2 lines in the above example) is in a block,
this method gets control to display its heading before, and clean up 
the screen after, its execution.
The key, though, is that the block is supplied with an argument,
named 'bar' in the example, which will update the bar image every 
it is sent the message value: x, where x is in the from:to: range.

The use of ProgressInitiationException allows for avoiding actual
progress display, by catching the exception.
"
	^ProgressInitiationException 
		display: self
		at: aPoint 
		from: minVal 
		to: maxVal 
		during: workBlock! !
!Set class methodsFor: 'initialization' stamp: 'jmv 7/17/2017 15:40:16' prior: 16907390!
       quickRehashAllSets  "Set rehashAllSets"
	| insts |
	self withAllSubclassesDo:
		[:c |
			insts _ c allInstances.
			(insts isEmpty or: [c = MethodDictionary]) ifFalse:
			['Rehashing instances of ' , c name
				displayProgressAt: Sensor mousePoint
				from: 1 to: insts size
				during: [ :barBlock | 1 to: insts size do: [:x | barBlock value: x. (insts at: x) rehash]]
			]
		]! !
!Set class methodsFor: 'initialization' stamp: 'jmv 7/17/2017 15:40:27' prior: 16907404!
         rehashAllSets  "Set rehashAllSets"
	| insts |
	self withAllSubclassesDo:
		[:c | insts _ c allInstances.
		insts isEmpty ifFalse:
		['Rehashing instances of ' , c name
			displayProgressAt: Sensor mousePoint
			from: 1 to: insts size
			during: [ :barBlock |
			1 to: insts size do:
				[ :x | barBlock value: x.
				(insts at: x) rehash]]]]! !
!Dictionary methodsFor: 'removing' stamp: 'jmv 7/17/2017 15:44:29' prior: 16833635!
                   unreferencedKeys
	"| uk | (Time millisecondsToRun: [uk := TextConstants unreferencedKeys]) -> uk"

	^'Scanning for references . . .' 
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size * 2
		during: 
			[:barBlock | | currentClass n associations referencedAssociations |
			currentClass := nil.
			n := 0.
			associations := self associations asIdentitySet.
			referencedAssociations := IdentitySet new: associations size.
			Smalltalk allSelect:
				[:m|
				m methodClass ~~ currentClass ifTrue:
					[currentClass := m methodClass.
					 barBlock value: (n := n + 1)].
				m literalsDo:
					[:l|
					(l isVariableBinding and: [associations includes: l]) ifTrue:
						[referencedAssociations add: l]].
				false].
			((associations reject: [:assoc | referencedAssociations includes: assoc]) collect: [:assoc| assoc key]) asSet]! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:10' prior: 16919601!
condenseChanges
	"Move all the changes onto a compacted sources file."
	"
	Smalltalk condenseChanges
	"

	| oldChanges classCount oldChangesLocalName oldChangesPathName |
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' forceWriteStreamDo: [ :f |
		f timeStamp.
		'Condensing Changes File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: Smalltalk classNames size
			during: [ :barBlock |
				classCount _ 0.
				Smalltalk allClassesDo: [ :class | 
					barBlock value: (classCount _ classCount + 1).
					class moveChangesTo: f.
					class putClassCommentToCondensedChangesFile: f.
					class class moveChangesTo: f ]].
		LastQuitLogPosition _ f position ].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	oldChanges _ SourceFiles at: 2.
	oldChangesPathName _ oldChanges name.
	oldChangesLocalName _ oldChanges localName.
	oldChanges close.
	(oldChangesPathName, '.old') asFileEntry delete.
	oldChangesPathName asFileEntry rename: oldChangesLocalName, '.old'.
	DirectoryEntry smalltalkImageDirectory // 'ST80.temp' rename: oldChangesLocalName.
	
	SourceFiles
			at: 2 put: oldChangesPathName asFileEntry appendStream.

	self inform: 'Changes file has been rewritten!!

Check that all is well, and then save/quit.
 
Otherwise, remove new changes,
replace it with the former one, and
exit without saving the image.
 '! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:14' prior: 16919647!
                        condenseSources	
	"Move all the changes onto a compacted sources file."
	"Smalltalk condenseSources"

	| classCount newVersionString oldChanges oldChangesLocalName oldChangesPathName newChangesPathName newSourcesName |
	newVersionString _ FillInTheBlankMorph request: 'Please name the new sources file' initialAnswer: SourceFileVersionString.
	newVersionString ifNil: [^ self].
	newVersionString = SourceFileVersionString ifTrue: [
		^ self error: 'The new source file must not be the same as the old.'].
	SourceFileVersionString _ newVersionString.

	"Write all sources with fileIndex 1"
	newSourcesName _ self defaultSourcesName.
	newSourcesName asFileEntry writeStreamDo: [ :f |
		f timeStamp.
		'Condensing Sources File...'
			displayProgressAt: Sensor mousePoint
			from: 0 to: Smalltalk classNames size
			during: [ :barBlock |
				classCount _ 0.
				Smalltalk allClassesDo: [ :class |
					barBlock value: (classCount _ classCount + 1).
					class fileOutOn: f moveSource: true toFile: 1]]].

	CompiledMethod allInstancesDo: [ :e | 
		e isInstalled ifFalse: [ e destroySourcePointer ] ].

	"Make a new empty changes file"
	oldChanges _ SourceFiles at: 2.
	oldChangesPathName _ oldChanges name.
	oldChangesLocalName _ oldChanges localName.
	self closeSourceFiles.
	oldChangesPathName ifNotNil: [
		(oldChangesPathName, '.old') asFileEntry delete.
		oldChangesPathName asFileEntry rename: oldChangesLocalName, '.old' ].
	newChangesPathName _ self defaultChangesName.
	newChangesPathName asFileEntry writeStreamDo: [ :stream |
		stream timeStamp ].
	LastQuitLogPosition _ 0.

	self openSourceFiles.
	self inform: 'Source files have been rewritten!!
 
Check that all is well, and then save/quit.
 
Otherwise, remove new sources/changes,
replace them with the former ones, and
exit without saving the image.
 '! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:41:56' prior: 16919755!
         macroBenchmark1    "Smalltalk macroBenchmark1"
	"Decompiles and prettyPrints the source for every method in the system (or less depending on the *FILTER*, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same.  Because it never installs the new method, it should not cause any flusing of the method cache."
	 | methodNode oldMethod newMethod badOnes oldCodeString n classes |
	classes _ Smalltalk allClasses select: [:c | c name < 'B3'].
	badOnes _ OrderedCollection new.
'Decompiling and recompiling...'
displayProgressAt: Sensor mousePoint
from: 0 to: (classes detectSum: [:c | c selectors size])
during: [:barBlock | n _ 0.
	classes do:
		[:cls | 
		"Transcript cr; show: cls name."
		cls selectors do:
			[:selector | barBlock value: (n _ n+1).
			oldMethod _ cls compiledMethodAt: selector.
			oldCodeString _ (cls decompilerClass new
								decompile: selector in: cls method: oldMethod)
							decompileString.
			methodNode _ cls compilerClass new
						compile: oldCodeString
						in: cls notifying: nil ifFail: nil.
			newMethod _ methodNode generate: #(0 0 0 0).
			oldCodeString = (cls decompilerClass new
								decompile: selector in: cls method: newMethod)
							decompileString ifFalse: [badOnes add: cls name , ' ' , selector]]].
].
	^ badOnes size! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:19' prior: 16919804!
   macroBenchmark3   "Smalltalk macroBenchmark3"
	| testBlock tallies prev receiver |
	"Runs the stepping simulator with the messageTally tree (like tallySends)."
	testBlock _
		['Running the context step simulator'
			displayProgressAt: Sensor mousePoint
			from: 0 to: 200
			during:
				[:barBlock |
				1 to: 200 do:
				[:x | barBlock value: x.
				Float pi printString.
				15 factorial printString]]].
	tallies _ MessageTally new class: testBlock receiver class
							method: testBlock method.
	receiver _ nil.
	prev _ testBlock.
	thisContext sender
		runSimulated: testBlock
		contextAtEachStep:
			[:current |
			current == prev ifFalse: [
				"call or return"
				prev sender ifNotNil: [
					"call only"
					(receiver == nil or: [current receiver == receiver])
						ifTrue: [tallies tally: current by: 1]].
				prev _ current]].
! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:24' prior: 50364567!
                      obsoleteMethodReferences
	"
	Smalltalk obsoleteMethodReferences
	Smalltalk browseObsoleteMethodReferences
	Open a browser on all referenced behaviors that are obsolete"
	| obsClasses obsRefs references |
	references _ WriteStream on: Array new.
	obsClasses _ self obsoleteBehaviors.
	'Scanning for methods referencing obsolete classes' displayProgressAt: Sensor mousePoint
		from: 1 to: obsClasses size during: [ :barBlock |
	obsClasses keysAndValuesDo: [ :index :each |
		barBlock value: index.
		obsRefs _ self pointersTo: each except: obsClasses.
		obsRefs do: [ :ref |
			"Figure out if it may be a global"
			(ref isVariableBinding and: [ ref key isString "or Symbol" ]) ifTrue: [
				(self pointersTo: ref) do: [ :meth |
					(meth is: #CompiledMethod) ifTrue: [
						meth methodReference ifNotNil: [ :mref |
							(mref isValid and: [ mref compiledMethod == meth]) ifTrue: [
								references nextPut: mref ]]]]]]].
	].
	^references contents! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:30' prior: 16919989!
       testDecompiler
	"
	Smalltalk testDecompiler
	"
	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."
	| methodNode oldMethod newMethod badOnes oldCodeString n |
	badOnes _ OrderedCollection new.
	'Decompiling all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldMethod _ cls compiledMethodAt: selector.
					oldCodeString _ (cls decompilerClass new
						decompile: selector
						in: cls
						method: oldMethod) decompileString.
					methodNode _ cls compilerClass new
						compile: oldCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod _ methodNode generate: #(0 0 0 0 ).
					oldCodeString =
						(cls decompilerClass new
							decompile: selector
							in: cls
							method: newMethod) decompileString ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: (MethodReference class: cls selector: selector) ]]]].
	Smalltalk
		browseMessageList: badOnes asArray sort
		name: 'Decompiler Discrepancies'.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:37' prior: 16920039!
                       testFormatter
	"Smalltalk testFormatter"
	"Reformats the source for every method in the system, and then compiles that source and verifies that it generates identical code.
	The formatting used will be classic monochrome."
	| newCodeString methodNode oldMethod newMethod badOnes n |
	badOnes _ OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					newCodeString _ cls compilerClass new
						format: (cls sourceCodeAt: selector)
						in: cls
						notifying: nil.
					methodNode _ cls compilerClass new
						compile: newCodeString
						in: cls
						notifying: nil
						ifFail: nil.
					newMethod _ methodNode generate: #(0 0 0 0 ).
					oldMethod _ cls compiledMethodAt: selector.
					oldMethod = newMethod ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes asArray sort
		name: 'Formatter Discrepancies'.! !
!SystemDictionary methodsFor: 'housekeeping' stamp: 'jmv 7/17/2017 15:46:43' prior: 16920080!
        testFormatter2
	"Smalltalk testFormatter2"
	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.
	The formatting used will be classic monochrome"
	| newCodeString badOnes n oldCodeString oldTokens newTokens |
	badOnes _ OrderedCollection new.
	'Formatting all classes...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: CompiledMethod instanceCount
		during: [ :barBlock |
			n _ 0.
			Smalltalk allBehaviorsDo: [ :cls |
				"Transcript cr; show: cls name."
				cls selectors do: [ :selector |
					(n _ n + 1) \\ 100 = 0 ifTrue: [ barBlock value: n ].
					oldCodeString _ (cls sourceCodeAt: selector) asString.
					newCodeString _ cls compilerClass new
						format: oldCodeString
						in: cls
						notifying: nil.
					oldTokens _ oldCodeString findTokens: Character separators.
					newTokens _ newCodeString findTokens: Character separators.
					oldTokens = newTokens ifFalse: [
						Transcript
							 newLine;
							 show: '***' , cls name , ' ' , selector.
						badOnes add: cls name , ' ' , selector ]]]].
	Smalltalk
		browseMessageList: badOnes asArray sort
		name: 'Formatter Discrepancies'.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/17/2017 15:45:58' prior: 16921677!
   allMethodsSourceStringMatching: aString
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring. 
	Search the class comments also.
	Argument might include $*, that matches any subsequence.
	For example, try:
		ensure:*[*close*]
	"
	| list classCount adder |
	list _ Set new.
	adder _ [ :mrClass :mrSel |
	list add:
		(MethodReference new
			setStandardClass: mrClass
			methodSymbol: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size
		during: [ :barBlock |
			classCount _ 0.
			Smalltalk allClassesDo: [ :class |
				barBlock value: (classCount _ classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						(aString match: (cl sourceCodeAt: sel)) ifTrue: [
							adder
								value: cl
								value: sel ]].
					
					(aString match: cl organization classComment asString) ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'retrieving' stamp: 'jmv 7/17/2017 15:46:02' prior: 16921712!
             allMethodsWithSourceString: aString matchCase: caseSensitive
	"Answer a sorted Collection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"
	| list classCount adder |
	list _ Set new.
	adder _ [ :mrClass :mrSel |
	list add:
		(MethodReference new
			setStandardClass: mrClass
			methodSymbol: mrSel) ].
	'Searching all source code...'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: Smalltalk classNames size
		during: [ :barBlock |
			classCount _ 0.
			Smalltalk allClassesDo: [ :class |
				barBlock value: (classCount _ classCount + 1).
				(Array
					with: class
					with: class class) do: [ :cl |
					cl selectorsDo: [ :sel |
						((cl sourceCodeAt: sel)
							findString: aString
							startingAt: 1
							caseSensitive: caseSensitive) > 0 ifTrue: [
							adder
								value: cl
								value: sel ]].
					(cl organization classComment asString
						findString: aString
						startingAt: 1
						caseSensitive: caseSensitive) > 0 ifTrue: [
						adder
							value: cl
							value: #Comment ]]]].
	^ list asArray sort.! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 7/17/2017 15:45:48' prior: 16922180!
                     abandonSources
	"
	Smalltalk abandonSources
	"
	 | m bTotal bCount |
	(self confirm:
'This method will detach the image fom source code.
A fresh changes file will be created to record further changes.
-- CAUTION --
If you have backed up your system and
are prepared to face the consequences of
abandoning source code files, choose Yes.
If you have any doubts, you may choose No
to back out with no harm done.')
		==  true ifFalse: [^ self inform: 'Okay - no harm done'].
	bTotal _ 0.  bCount _ 0.
	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].
'Doing #destroySourcePointer ...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: bTotal
	during: [ :barBlock |
		Smalltalk allBehaviorsDo: [ :cl |
		"for testing"
		"{ EllipseMorph } do: [ :cl |"
			barBlock value: (bCount _ bCount + 1).
			cl selectors do: [:selector |
				m _ cl compiledMethodAt: selector.
				m destroySourcePointer ]]].
	Smalltalk allBehaviorsDo: [:b | b zapOrganization].
	Smalltalk closeSourceFiles.
	Preferences disable: #warnIfNoChangesFile.
	Preferences disable: #warnIfNoSourcesFile! !
!SystemDictionary methodsFor: 'shrinking' stamp: 'jmv 7/17/2017 15:42:02' prior: 16922340!
                      removeAllUnSentMessages
	"Smalltalk removeAllUnSentMessages"
	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]. 
	Smalltalk removeAllUnSentMessages > 0] whileTrue."
	"Remove all implementations of unsent messages."
	| sels n |
	sels _ self allUnSentMessages.
	self presumedSentMessages
		do: [:sel | sels
				remove: sel
				ifAbsent: nil].
	sels size = 0
		ifTrue: [^ 0].
	n _ 0.
	Smalltalk
		allBehaviorsDo: [:x | n _ n + 1].
	'Removing ' , sels size printString , ' messages . . .'
		displayProgressAt: Sensor mousePoint
		from: 0
		to: n
		during: [:barBlock | 
			n _ 0.
			self
				allBehaviorsDo: [:class | 
					barBlock value: (n _ n + 1).
					sels
						do: [:sel | class removeSelector: sel]]].
	^ sels size! !
!PositionableStream methodsFor: 'fileIn/Out' stamp: 'jmv 7/17/2017 15:45:10' prior: 50364849!
                        fileInAnnouncing: announcement
	"This is special for reading expressions from text that has been formatted 
	with exclamation delimitors. The expressions are read and passed to the 
	Compiler. Answer the result of compilation.  Put up a progress report with
     the given announcement as the title."

	| val chunk |
	announcement 
		displayProgressAt: Sensor mousePoint
		from: 0
		to: self size
		during: [ :barBlock | 
			[ self atEnd ] whileFalse: [
					barBlock value: self position.
					self skipSeparators.
					
					[
						val := (self peekFor: $!!) 
								ifTrue: [
									chunk := self nextChunk.
									"These are the ones that should do nothing, 
									because next line is a doit that does the stuff
									(or because it is handled elsewhere)"
									(chunk beginsWith: 'description:  ')
									| (chunk beginsWith: 'provides: ')
									| (chunk beginsWith: 'requires: ')
									| (chunk beginsWith: 'classDefinition: ')
									| (chunk beginsWith: 'classRemoval: ')
									| (chunk beginsWith: 'methodRemoval: ')
									| (chunk beginsWith: 'classMoveToSomePackage: ')
									| (chunk beginsWith: 'methodMoveToSomePackage: ')
										ifFalse: [(Compiler evaluate: chunk logged: false) scanFrom: self]]
								ifFalse: [
									chunk := self nextChunk.
									self checkForPreamble: chunk.
									[ Compiler evaluate: chunk logged: true ]
										on: Error
										do: [ :ex |
											ex print.
											('while evaluating: ', chunk) print.
											ex pass ]
										]] 
							on: InMidstOfFileinNotification
							do: [ :ex | ex resume: true ] ].
			].
	"Note:  The main purpose of this banner is to flush the changes file."
	Smalltalk logChange: '----End fileIn of ' , self name , '----'.
	^val! !
!PositionableStream methodsFor: 'gui' stamp: 'jmv 7/17/2017 15:38:57' prior: 50364907!
                               untilEnd: aBlock displayingProgress: aString
	aString
		displayProgressAt: Sensor mousePoint
		from: 0 to: self size
		during: [ :barBlock |
			[ self atEnd ] whileFalse: [
				barBlock value: self position.
				aBlock value ]]! !
!ReferenceStream methodsFor: 'statistics' stamp: 'jmv 7/17/2017 15:40:06' prior: 16899982!
                              statisticsOfRefs
	"Analyze the information in references, the objects being written out"

	| parents n kids nm ownerBags tallies owners objParent normalReferences |
	normalReferences _ self references.	"Exclude unrealized weaks"
	parents _ IdentityDictionary new: normalReferences size * 2.
	n _ 0.
	'Finding Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:
		[ :parent | barBlock value: (n _ n+1).
		kids _ parent class isFixed
			ifTrue: [(1 to: parent class instSize) collect: [:i | parent instVarAt: i]]
			ifFalse: [parent class isBits ifTrue: [Array new]
					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt: i]]].
		(kids select: [:x | normalReferences includesKey: x])
			do: [:child | parents at: child put: parent]]].
	ownerBags _ Dictionary new.
	tallies _ Bag new.
	n _ 0.
	'Tallying Owners...'
	displayProgressAt: Sensor mousePoint
	from: 0 to: normalReferences size
	during: [ :barBlock |
	normalReferences keysDo:  "For each class of obj, tally a bag of owner classes"
		[ :obj | barBlock value: (n _ n+1).
		nm _ obj class name.
		tallies add: nm.
		owners _ ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].
		(objParent _ parents at: obj ifAbsent: nil) ifNotNil: [
			owners add: objParent class name]]].
	^ String streamContents: [ :strm | 
		tallies sortedCounts do: [ :assn |
			n _ assn key.  nm _ assn value.
			owners _ ownerBags at: nm.
			strm newLine; nextPutAll: nm; space; print: n.
			owners size > 0 ifTrue: [
				strm newLine; tab; print: owners sortedCounts]]]! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 7/17/2017 15:40:37' prior: 16911182!
                             nextPut: anObject
	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.
	You can see an analysis of which objects are written out by doing: 
	(SmartRefStream statsOfSubObjects: anObject)
	(SmartRefStream tallyOfSubObjects: anObject)
	(SmartRefStream subObjects: anObject ofClass: aClass)"

| info |
topCall
	ifNil: [
		topCall _ anObject.
		'Please wait while objects are counted' 
			displayProgressAt: Sensor mousePoint
			from: 0 to: 10
			during: [ :barBlock | info _ self instVarInfo: anObject].
		byteStream binary.
		'Writing an object file' displayProgressAt: Sensor mousePoint
			from: 0 to: objCount*4	"estimate"
			during: [ :barBlock |
				objCount _ 0.
				progressBar _ barBlock.
				self setStream: byteStream reading: false.
					"set basePos, but keep any class renames"
				super nextPut: ReferenceStream versionCode.
				super nextPut: info.
				super nextPut: anObject.		"<- the real writing"
				].
					"Note: the terminator, $!!, is not doubled inside object data"
		"references is an IDict of every object that got written"
		byteStream ascii.
		byteStream nextPutAll: '!!'; newLine; newLine.
		byteStream padToEndWith: $ .	"really want to truncate file, but can't"
		topCall _ progressBar _ nil]	"reset it"
	ifNotNil: [
		super nextPut: anObject.
		progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].
! !
!SmartRefStream methodsFor: 'read write' stamp: 'jmv 7/17/2017 15:40:57' prior: 16911232!
                            nextPutObjOnly: anObject
	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"

	| info |
	topCall
		ifNil: [
			topCall _ anObject.
			super nextPut: ReferenceStream versionCode.
			'Please wait while objects are counted' displayProgressAt: Sensor mousePoint
				from: 0 to: 10
				during: [ :barBlock |
					info _ self instVarInfo: anObject].
			'Writing an object file' displayProgressAt: Sensor mousePoint
				from: 0 to: objCount*4	"estimate"
				during: [ :barBlock |
					objCount _ 0.
					progressBar _ barBlock.
					super nextPut: info.
					super nextPut: anObject.	"<- the real writing"
					"Class inst vars not written here!!"].
			"references is an IDict of every object that got written
			(in case you want to take statistics)"
			"Transcript cr; show: structures keys printString."		"debug"
			topCall _ progressBar _ nil]	"reset it"
		ifNotNil: [
			super nextPut: anObject.
			progressBar ifNotNil: [progressBar value: (objCount _ objCount + 1)]].! !
!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'jmv 7/17/2017 15:39:39' prior: 50364918!
testInnermost

	"
	test the progress code WITHOUT special handling
	
	ProgressInitiationException  testInnermost
	"

	^'Now here''s some Real Progress'
		displayProgressAt: Sensor mousePoint
		from: 0 
		to: 10
		during: [ :barBlock |
			1 to: 10 do: [ :x | 
				barBlock value: x.
				(Delay forMilliseconds: 500) wait.
				x = 5 ifTrue: [1/0].	"just to make life interesting"
			].
			'done'
		].

! !
!Utilities class methodsFor: 'user interface' stamp: 'jmv 7/17/2017 15:48:35' prior: 16941514!
             informUserDuring: barBlock 
	"Display a message above (or below if insufficient room) the cursor during execution of the given block."

	"Utilities informUserDuring:[:barBlock|
		#(one two three) do:[:info|
			barBlock value: info.
			(Delay forSeconds: 1) wait]]"

	(MVCMenuMorph from: (SelectionMenu labels: '') title: '						') 
				informUserAt: Sensor mousePoint
				during: barBlock! !
!CodeFile methodsFor: 'reading' stamp: 'jmv 7/17/2017 15:44:20' prior: 16808992!
       buildFrom: aStream
	| chgRec changes |
	changes _ (ChangeList new scanFile: aStream from: 0 to: aStream size) changeList.
	('Processing ', self name) 
		displayProgressAt: Sensor mousePoint
		from: 1
		to: changes size
		during: [ :barBlock |
			1 to: changes size do:[:i|
				barBlock value: i.
				chgRec := changes at: i.
				chgRec class == MethodDeletionChangeRecord
					ifTrue: [ self removedMethod: chgRec command with: chgRec ]
					ifFalse: [ self perform: (chgRec changeType copyWith: $:) asSymbol with: chgRec ].
			].
		]! !
!SpaceTally methodsFor: 'fileOut' stamp: 'jmv 7/17/2017 15:45:36' prior: 16912516!
                   printSpaceAnalysis: threshold on: aStream
	"
	SpaceTally new printSpaceAnalysis: 1 on:(FileStream forceNewFileNamed: 'STspace.text')
	"
	"sd-This method should be rewrote to be more coherent within the rest of the class 
	ie using preAllocate and spaceForInstanceOf:"

	"If threshold > 0, then only those classes with more than that number
	of instances will be shown, and they will be sorted by total instance space.
	If threshold = 0, then all classes will appear, sorted by name."

	| codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |
	Smalltalk garbageCollect.
	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.
	results _ OrderedCollection new: Smalltalk classNames size.
	'Taking statistics...'
		displayProgressAt: Sensor mousePoint
		from: 0 to: Smalltalk classNames size
		during: [ :barBlock |
			Smalltalk allClassesDo: [ :cl |
				codeSpace _ cl spaceUsed.
				barBlock value: (n _ n+1).
				Smalltalk garbageCollectMost.
				instCount _ cl instanceCount.
				instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8]) * instCount. "Object headers""Warning: The 3rd header word for big objects is not considered!!"
				cl isVariable
					ifTrue: [
						eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].
						cl allInstancesDo: [ :x |
							instSpace _ instSpace + (x basicSize * eltSize)]]
					ifFalse: [instSpace _ instSpace + (cl instSize * instCount * 4)].
				results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).
				totalCodeSpace _ totalCodeSpace + codeSpace.
				totalInstCount _ totalInstCount + instCount.
				totalInstSpace _ totalInstSpace + instSpace]].
	totalPercent _ 0.0.

	aStream timeStamp.
	aStream
		nextPutAll: ('Class' padded: #right to: 30 with: $ );
		nextPutAll: ('code space' padded: #left to: 12 with: $ );
		nextPutAll: ('# instances' padded: #left to: 12 with: $ );
		nextPutAll: ('inst space' padded: #left to: 12 with: $ );
		nextPutAll: ('percent' padded: #left to: 8 with: $ ); newLine.

	threshold > 0 ifTrue: [
		"If inst count threshold > 0, then sort by space"
		results _ (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])
			asArray sort: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].

	results do: [:s |
		aStream
			nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );
			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );
			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );
			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).
		percent _ s spaceForInstances*100.0/totalInstSpace.
		totalPercent _ totalPercent + percent.
		percent >= 0.1 ifTrue: [
			percent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil ].
		aStream newLine].

	aStream
		newLine; nextPutAll: ('Total' padded: #right to: 30 with: $ );
		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );
		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ ).
	totalPercent printOn: aStream integerDigits: 6 padWith: $  fractionDigits: 1 positiveIndicator: nil! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3126-ProgressArgumentIsABlock-JuanVuletich-2017Jul17-15h32m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3121] on 12 July 2017 at 1:50:53 pm'!
!Float64Array methodsFor: 'testing' stamp: 'jmv 7/11/2017 14:04:20'!
                      isLiteral
	"so that 
	#(1 #[1.0 2 3] 5)
	prints itself"
	^self class == Float64Array! !
!Float64Array methodsFor: 'printing' stamp: 'jmv 7/11/2017 14:10:44'!
  printOn: aStream

	self storeOn: aStream! !
!Float64Array methodsFor: 'printing' stamp: 'jmv 7/11/2017 14:10:41'!
              storeOn: aStream

	aStream nextPutAll: '#['.
	self
		do: [ :each | each storeOn: aStream ]
		separatedBy: [ aStream nextPut: $ ].
	aStream nextPut: $]! !
!ByteArray methodsFor: 'printing' stamp: 'jmv 7/11/2017 14:09:10' prior: 16793833!
                   printOn: aStream
	self storeOn: aStream! !
!Scanner methodsFor: 'expression types' stamp: 'jmv 7/12/2017 13:50:30' prior: 16903764!
                            scanLitByteVec
	"Also accept Floats besides bytes!!
	#[1 2 3 255]
	#[1.0 0.2 1.0]
	#[1.0 -0.2e-23 1.0e4]
	"
	| stream |
	stream _ nil.
	[ tokenType == #rightBracket or: [ tokenType == #doIt ] ] whileFalse: [
		(token == #- and: [(self typeTableAt: hereChar) == #xDigit]) ifTrue: [
			self scanToken.
			token _ token negated ].
		((token isInteger and: [ token between: 0 and: 255 ]) or: [token isFloat])
			ifFalse: [ ^ self offEnd: '8-bit integer, floating point number, or right bracket expected' ].
		stream ifNil: [
			stream _ ((token isFloat ifTrue: [Float64Array] ifFalse: [ByteArray]) new: 16) writeStream ].
		stream nextPut: token.
		self scanToken ].
	token _ stream contents! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3127-LiteralFloatArrays-JuanVuletich-2017Jul12-13h50m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3127] on 17 July 2017 at 5:00:00 pm'!
!Collection methodsFor: 'converting' stamp: 'jmv 7/17/2017 16:59:02'!
                               asFloat64Array
	"Answer a Float64Array whose elements are the elements of the receiver"

	^self as: Float64Array! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3128-asFloat64Array-JuanVuletich-2017Jul17-16h59m-jmv.1.cs.st----!

'From Cuis 5.0 of 7 November 2016 [latest update: #3128] on 18 July 2017 at 10:23:11 am'!
!PluggableButtonMorph methodsFor: 'as yet unclassified' stamp: 'jmv 7/18/2017 10:22:53' prior: 50365253!
                              morphExtent
	"Use extent if it has already been manually set, otherwise try to set it by computing from the label text and font, otherwise try using the icon extent, or finally fall back to the default value."
	^ extent ifNil: [
		extent := (self fontToUse notNil and: [ label notNil ])
			ifTrue: [ "Add a bit of padding"
				(self fontToUse widthOfString: label) + 10 @ (self fontToUse height + 10) ]
			ifFalse: [
				`20@15`
				"Usually button extent should not depend on icon extent. Icons are many times very big.
				For example, the icons in buttons in Taskbar are full size captures of the windows"
				"icon
					ifNil: [ `20@15` ]
					ifNotNil: [ icon extent ]"
				]].! !

----End fileIn of /home/juan/Rectifier/Cuis-Smalltalk-Dev/CoreUpdates/3129-AvoidHugeButtons-JuanVuletich-2017Jul18-10h22m-jmv.1.cs.st----!

----SNAPSHOT----#(18 July 2017 10:29:07.371067 am) Cuis5.0-3129.image priorSource: 1061186!

----QUIT----#(18 July 2017 10:29:18.081168 am) Cuis5.0-3129.image priorSource: 1122521!